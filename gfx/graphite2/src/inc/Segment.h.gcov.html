<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/graphite2/src/inc/Segment.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">gfx/graphite2/src/inc</a> - Segment.h<span style="font-size: 80%;"> (source / <a href="Segment.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">67</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*  GRAPHITE2 LICENSING</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :     Copyright 2010, SIL International
<span class="lineNum">       4 </span>            :     All rights reserved.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :     This library is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            :     it under the terms of the GNU Lesser General Public License as published
<span class="lineNum">       8 </span>            :     by the Free Software Foundation; either version 2.1 of License, or
<span class="lineNum">       9 </span>            :     (at your option) any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            :     This program is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            :     but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            :     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      14 </span>            :     Lesser General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :     You should also have received a copy of the GNU Lesser General Public
<span class="lineNum">      17 </span>            :     License along with this library in the file named &quot;LICENSE&quot;.
<span class="lineNum">      18 </span>            :     If not, write to the Free Software Foundation, 51 Franklin Street, 
<span class="lineNum">      19 </span>            :     Suite 500, Boston, MA 02110-1335, USA or visit their web page on the 
<span class="lineNum">      20 </span>            :     internet at http://www.fsf.org/licenses/lgpl.html.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : Alternatively, the contents of this file may be used under the terms of the
<span class="lineNum">      23 </span>            : Mozilla Public License (http://mozilla.org/MPL) or the GNU General Public
<span class="lineNum">      24 </span>            : License, as published by the Free Software Foundation, either version 2
<span class="lineNum">      25 </span>            : of the License or (at your option) any later version.
<span class="lineNum">      26 </span>            : */
<span class="lineNum">      27 </span>            : #pragma once
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;inc/Main.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;cassert&gt;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &quot;inc/CharInfo.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;inc/Face.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;inc/FeatureVal.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;inc/GlyphCache.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;inc/GlyphFace.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;inc/Slot.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;inc/Position.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;inc/List.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;inc/Collider.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #define MAX_SEG_GROWTH_FACTOR  64
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : namespace graphite2 {
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : typedef Vector&lt;Features&gt;        FeatureList;
<span class="lineNum">      48 </span>            : typedef Vector&lt;Slot *&gt;          SlotRope;
<span class="lineNum">      49 </span>            : typedef Vector&lt;int16 *&gt;         AttributeRope;
<span class="lineNum">      50 </span>            : typedef Vector&lt;SlotJustify *&gt;   JustifyRope;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #ifndef GRAPHITE2_NSEGCACHE
<span class="lineNum">      53 </span>            : class SegmentScopeState;
<span class="lineNum">      54 </span>            : #endif
<span class="lineNum">      55 </span>            : class Font;
<span class="lineNum">      56 </span>            : class Segment;
<span class="lineNum">      57 </span>            : class Silf;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : enum SpliceParam {
<span class="lineNum">      60 </span>            : /** sub-Segments longer than this are not cached
<span class="lineNum">      61 </span>            :  * (in Unicode code points) */
<span class="lineNum">      62 </span>            :     eMaxSpliceSize = 96
<span class="lineNum">      63 </span>            : };
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : enum justFlags {
<span class="lineNum">      66 </span>            :     gr_justStartInline = 1,
<span class="lineNum">      67 </span>            :     gr_justEndInline = 2
<span class="lineNum">      68 </span>            : };
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : class SegmentScopeState
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span>            : private:
<span class="lineNum">      73 </span>            :     friend class Segment;
<span class="lineNum">      74 </span>            :     Slot * realFirstSlot;
<span class="lineNum">      75 </span>            :     Slot * slotBeforeScope;
<span class="lineNum">      76 </span>            :     Slot * slotAfterScope;
<span class="lineNum">      77 </span>            :     Slot * realLastSlot;
<span class="lineNum">      78 </span>            :     size_t numGlyphsOutsideScope;
<span class="lineNum">      79 </span>            : };
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : class Segment
<span class="lineNum">      82 </span>            : {
<span class="lineNum">      83 </span>            :     // Prevent copying of any kind.
<span class="lineNum">      84 </span>            :     Segment(const Segment&amp;);
<span class="lineNum">      85 </span>            :     Segment&amp; operator=(const Segment&amp;);
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : public:
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     enum {
<span class="lineNum">      90 </span>            :         SEG_INITCOLLISIONS = 1,
<span class="lineNum">      91 </span>            :         SEG_HASCOLLISIONS = 2
<a name="92"><span class="lineNum">      92 </span>            :     };</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :     unsigned int slotCount() const { return m_numGlyphs; }      //one slot per glyph</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :     void extendLength(int num) { m_numGlyphs += num; }</span></a>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     Position advance() const { return m_advance; }</span>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :     bool runGraphite() { if (m_silf) return m_face-&gt;runGraphite(this, m_silf); else return true;};</span></a>
<a name="98"><span class="lineNum">      98 </span>            :     void chooseSilf(uint32 script) { m_silf = m_face-&gt;chooseSilf(script); }</a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :     const Silf *silf() const { return m_silf; }</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :     unsigned int charInfoCount() const { return m_numCharinfo; }</span></a>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     const CharInfo *charinfo(unsigned int index) const { return index &lt; m_numCharinfo ? m_charinfo + index : NULL; }</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     CharInfo *charinfo(unsigned int index) { return index &lt; m_numCharinfo ? m_charinfo + index : NULL; }</span>
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     Segment(unsigned int numchars, const Face* face, uint32 script, int dir);
<span class="lineNum">     105 </span>            :     ~Segment();
<span class="lineNum">     106 </span>            : #ifndef GRAPHITE2_NSEGCACHE
<span class="lineNum">     107 </span>            :     SegmentScopeState setScope(Slot * firstSlot, Slot * lastSlot, size_t subLength);
<span class="lineNum">     108 </span>            :     void removeScope(SegmentScopeState &amp; state);
<span class="lineNum">     109 </span>            :     void append(const Segment &amp;other);
<span class="lineNum">     110 </span>            :     void splice(size_t offset, size_t length, Slot * const startSlot,
<span class="lineNum">     111 </span>            :             Slot * endSlot, const Slot * srcSlot,
<a name="112"><span class="lineNum">     112 </span>            :             const size_t numGlyphs);</a>
<span class="lineNum">     113 </span>            : #endif
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :     uint8 flags() const { return m_flags; }</span></a>
<a name="115"><span class="lineNum">     115 </span>            :     void flags(uint8 f) { m_flags = f; }</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :     Slot *first() { return m_first; }</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :     void first(Slot *p) { m_first = p; }</span></a>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     Slot *last() { return m_last; }</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     void last(Slot *p) { m_last = p; }</span>
<span class="lineNum">     120 </span>            :     void appendSlot(int i, int cid, int gid, int fid, size_t coffset);
<span class="lineNum">     121 </span>            :     Slot *newSlot();
<span class="lineNum">     122 </span>            :     void freeSlot(Slot *);
<span class="lineNum">     123 </span>            :     SlotJustify *newJustify();
<span class="lineNum">     124 </span>            :     void freeJustify(SlotJustify *aJustify);
<span class="lineNum">     125 </span>            :     Position positionSlots(const Font *font=0, Slot *first=0, Slot *last=0, bool isRtl = false, bool isFinal = true);
<a name="126"><span class="lineNum">     126 </span>            :     void associateChars(int offset, int num);</a>
<a name="127"><span class="lineNum">     127 </span>            :     void linkClusters(Slot *first, Slot *last);</a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :     uint16 getClassGlyph(uint16 cid, uint16 offset) const { return m_silf-&gt;getClassGlyph(cid, offset); }</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :     uint16 findClassIndex(uint16 cid, uint16 gid) const { return m_silf-&gt;findClassIndex(cid, gid); }</span></a>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 :     int addFeatures(const Features&amp; feats) { m_feats.push_back(feats); return m_feats.size() - 1; }</span></a>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     uint32 getFeature(int index, uint8 findex) const { const FeatureRef* pFR=m_face-&gt;theSill().theFeatureMap().featureRef(findex); if (!pFR) return 0; else return pFR-&gt;getFeatureVal(m_feats[index]); }</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     void setFeature(int index, uint8 findex, uint32 val) {</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         const FeatureRef* pFR=m_face-&gt;theSill().theFeatureMap().featureRef(findex); </span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :         if (pFR)</span>
<span class="lineNum">     135 </span>            :         {
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :             if (val &gt; pFR-&gt;maxVal()) val = pFR-&gt;maxVal();</span>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :             pFR-&gt;applyValToFeature(val, m_feats[index]);</span></a>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         } }</span>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :     int8 dir() const { return m_dir; }</span></a>
<a name="140"><span class="lineNum">     140 </span>            :     void dir(int8 val) { m_dir = val; }</a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :     bool currdir() const { return ((m_dir &gt;&gt; 6) ^ m_dir) &amp; 1; }</span></a>
<a name="142"><span class="lineNum">     142 </span><span class="lineNoCov">          0 :     unsigned int passBits() const { return m_passBits; }</span></a>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     void mergePassBits(const unsigned int val) { m_passBits &amp;= val; }</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     int16 glyphAttr(uint16 gid, uint16 gattr) const { const GlyphFace * p = m_face-&gt;glyphs().glyphSafe(gid); return p ? p-&gt;attrs()[gattr] : 0; }</span>
<a name="145"><span class="lineNum">     145 </span>            :     int32 getGlyphMetric(Slot *iSlot, uint8 metric, uint8 attrLevel, bool rtl) const;</a>
<a name="146"><span class="lineNum">     146 </span>            :     float glyphAdvance(uint16 gid) const { return m_face-&gt;glyphs().glyph(gid)-&gt;theAdvance().x; }</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :     const Rect &amp;theGlyphBBoxTemporary(uint16 gid) const { return m_face-&gt;glyphs().glyph(gid)-&gt;theBBox(); }   //warning value may become invalid when another glyph is accessed</span></a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :     Slot *findRoot(Slot *is) const { return is-&gt;attachedTo() ? findRoot(is-&gt;attachedTo()) : is; }</span></a>
<a name="149"><span class="lineNum">     149 </span><span class="lineNoCov">          0 :     int numAttrs() const { return m_silf-&gt;numUser(); }</span></a>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     int defaultOriginal() const { return m_defaultOriginal; }</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     const Face * getFace() const { return m_face; }</span>
<span class="lineNum">     152 </span>            :     const Features &amp; getFeatures(unsigned int /*charIndex*/) { assert(m_feats.size() == 1); return m_feats[0]; }
<span class="lineNum">     153 </span>            :     void bidiPass(int paradir, uint8 aMirror);
<span class="lineNum">     154 </span>            :     int8 getSlotBidiClass(Slot *s) const;
<span class="lineNum">     155 </span>            :     void doMirror(uint16 aMirror);
<span class="lineNum">     156 </span>            :     Slot *addLineEnd(Slot *nSlot);
<span class="lineNum">     157 </span>            :     void delLineEnd(Slot *s);
<span class="lineNum">     158 </span>            :     bool hasJustification() const { return m_justifies.size() != 0; }
<span class="lineNum">     159 </span>            :     void reverseSlots();
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            :     bool isWhitespace(const int cid) const;</a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :     bool hasCollisionInfo() const { return (m_flags &amp; SEG_HASCOLLISIONS) &amp;&amp; m_collisions; }</span></a>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     SlotCollision *collisionInfo(const Slot *s) const { return m_collisions ? m_collisions + s-&gt;index() : 0; }</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     CLASS_NEW_DELETE</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : public:       //only used by: GrSegment* makeAndInitialize(const GrFont *font, const GrFace *face, uint32 script, const FeaturesHandle&amp; pFeats/*must not be IsNull*/, encform enc, const void* pStart, size_t nChars, int dir);
<span class="lineNum">     167 </span>            :     bool read_text(const Face *face, const Features* pFeats/*must not be NULL*/, gr_encform enc, const void*pStart, size_t nChars);
<span class="lineNum">     168 </span>            :     void finalise(const Font *font, bool reverse=false);
<span class="lineNum">     169 </span>            :     float justify(Slot *pSlot, const Font *font, float width, enum justFlags flags, Slot *pFirst, Slot *pLast);
<span class="lineNum">     170 </span>            :     bool initCollisions();
<span class="lineNum">     171 </span>            :   
<span class="lineNum">     172 </span>            : private:
<span class="lineNum">     173 </span>            :     Position        m_advance;          // whole segment advance
<span class="lineNum">     174 </span>            :     SlotRope        m_slots;            // Vector of slot buffers
<span class="lineNum">     175 </span>            :     AttributeRope   m_userAttrs;        // Vector of userAttrs buffers
<span class="lineNum">     176 </span>            :     JustifyRope     m_justifies;        // Slot justification info buffers
<span class="lineNum">     177 </span>            :     FeatureList     m_feats;            // feature settings referenced by charinfos in this segment
<span class="lineNum">     178 </span>            :     Slot          * m_freeSlots;        // linked list of free slots
<span class="lineNum">     179 </span>            :     SlotJustify   * m_freeJustifies;    // Slot justification blocks free list
<span class="lineNum">     180 </span>            :     CharInfo      * m_charinfo;         // character info, one per input character
<span class="lineNum">     181 </span>            :     SlotCollision * m_collisions;
<span class="lineNum">     182 </span>            :     const Face    * m_face;             // GrFace
<span class="lineNum">     183 </span>            :     const Silf    * m_silf;
<span class="lineNum">     184 </span>            :     Slot          * m_first;            // first slot in segment
<span class="lineNum">     185 </span>            :     Slot          * m_last;             // last slot in segment
<span class="lineNum">     186 </span>            :     unsigned int    m_bufSize,          // how big a buffer to create when need more slots
<span class="lineNum">     187 </span>            :                     m_numGlyphs,
<span class="lineNum">     188 </span>            :                     m_numCharinfo,      // size of the array and number of input characters
<span class="lineNum">     189 </span>            :                     m_passBits;         // if bit set then skip pass
<span class="lineNum">     190 </span>            :     int             m_defaultOriginal;  // number of whitespace chars in the string
<span class="lineNum">     191 </span>            :     int8            m_dir;
<span class="lineNum">     192 </span>            :     uint8           m_flags;            // General purpose flags
<span class="lineNum">     193 </span>            : };
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : inline
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : int8 Segment::getSlotBidiClass(Slot *s) const</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     int8 res = s-&gt;getBidiClass();</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     if (res != -1) return res;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     res = int8(glyphAttr(s-&gt;gid(), m_silf-&gt;aBidi()));</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     s-&gt;setBidiClass(res);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">     203 </span>            : }
<a name="204"><span class="lineNum">     204 </span>            : </a>
<span class="lineNum">     205 </span>            : inline
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : void Segment::finalise(const Font *font, bool reverse)</span>
<span class="lineNum">     207 </span>            : {
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     if (!m_first) return;</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     m_advance = positionSlots(font, m_first, m_last, m_silf-&gt;dir(), true);</span>
<span class="lineNum">     211 </span>            :     //associateChars(0, m_numCharinfo);
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if (reverse &amp;&amp; currdir() != (m_dir &amp; 1))</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         reverseSlots();</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     linkClusters(m_first, m_last);</span>
<span class="lineNum">     215 </span>            : }
<a name="216"><span class="lineNum">     216 </span>            : </a>
<span class="lineNum">     217 </span>            : inline
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : int32 Segment::getGlyphMetric(Slot *iSlot, uint8 metric, uint8 attrLevel, bool rtl) const {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (attrLevel &gt; 0)</span>
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         Slot *is = findRoot(iSlot);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         return is-&gt;clusterMetric(this, metric, attrLevel, rtl);</span>
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            :     else
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         return m_face-&gt;getGlyphMetric(iSlot-&gt;gid(), metric);</span>
<span class="lineNum">     226 </span>            : }
<a name="227"><span class="lineNum">     227 </span>            : </a>
<span class="lineNum">     228 </span>            : inline
<span class="lineNum">     229 </span><span class="lineNoCov">          0 : bool Segment::isWhitespace(const int cid) const</span>
<span class="lineNum">     230 </span>            : {
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     return ((cid &gt;= 0x0009) * (cid &lt;= 0x000D)</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :          + (cid == 0x0020)</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :          + (cid == 0x0085)</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :          + (cid == 0x00A0)</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :          + (cid == 0x1680)</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :          + (cid == 0x180E)</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :          + (cid &gt;= 0x2000) * (cid &lt;= 0x200A)</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :          + (cid == 0x2028)</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :          + (cid == 0x2029)</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :          + (cid == 0x202F)</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :          + (cid == 0x205F)</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :          + (cid == 0x3000)) != 0;</span>
<span class="lineNum">     243 </span>            : }
<span class="lineNum">     244 </span>            : 
<a name="245"><span class="lineNum">     245 </span>            : } // namespace graphite2</a>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 : struct gr_segment : public graphite2::Segment {};</span>
<span class="lineNum">     248 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

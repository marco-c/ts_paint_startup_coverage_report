<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/graphite2/src/Collider.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gfx/graphite2/src</a> - Collider.cpp<span style="font-size: 80%;"> (source / <a href="Collider.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">525</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*  GRAPHITE2 LICENSING</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :     Copyright 2010, SIL International
<span class="lineNum">       4 </span>            :     All rights reserved.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :     This library is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            :     it under the terms of the GNU Lesser General Public License as published
<span class="lineNum">       8 </span>            :     by the Free Software Foundation; either version 2.1 of License, or
<span class="lineNum">       9 </span>            :     (at your option) any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            :     This program is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            :     but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            :     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      14 </span>            :     Lesser General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :     You should also have received a copy of the GNU Lesser General Public
<span class="lineNum">      17 </span>            :     License along with this library in the file named &quot;LICENSE&quot;.
<span class="lineNum">      18 </span>            :     If not, write to the Free Software Foundation, 51 Franklin Street, 
<span class="lineNum">      19 </span>            :     Suite 500, Boston, MA 02110-1335, USA or visit their web page on the 
<span class="lineNum">      20 </span>            :     internet at http://www.fsf.org/licenses/lgpl.html.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : Alternatively, the contents of this file may be used under the terms of the
<span class="lineNum">      23 </span>            : Mozilla Public License (http://mozilla.org/MPL) or the GNU General Public
<span class="lineNum">      24 </span>            : License, as published by the Free Software Foundation, either version 2
<span class="lineNum">      25 </span>            : of the License or (at your option) any later version.
<span class="lineNum">      26 </span>            : */
<span class="lineNum">      27 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      28 </span>            : #include &lt;limits&gt;
<span class="lineNum">      29 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      30 </span>            : #include &lt;string&gt;
<span class="lineNum">      31 </span>            : #include &lt;functional&gt;
<span class="lineNum">      32 </span>            : #include &quot;inc/Collider.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;inc/Segment.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;inc/Slot.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;inc/GlyphCache.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;inc/Sparse.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #define ISQRT2 0.707106781f
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : // Possible rounding error for subbox boundaries: 0.016 = 1/64 = 1/256 * 4 
<span class="lineNum">      41 </span>            : // (values in font range from 0..256)
<span class="lineNum">      42 </span>            : // #define SUBBOX_RND_ERR 0.016
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : using namespace graphite2;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : ////    SHIFT-COLLIDER    ////
<span class="lineNum">      47 </span>            : 
<a name="48"><span class="lineNum">      48 </span>            : // Initialize the Collider to hold the basic movement limits for the</a>
<span class="lineNum">      49 </span>            : // target slot, the one we are focusing on fixing.
<span class="lineNum">      50 </span><span class="lineNoCov">          0 : bool ShiftCollider::initSlot(Segment *seg, Slot *aSlot, const Rect &amp;limit, float margin, float marginWeight,</span>
<span class="lineNum">      51 </span>            :     const Position &amp;currShift, const Position &amp;currOffset, int dir, GR_MAYBE_UNUSED json * const dbgout)
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            :     int i;
<span class="lineNum">      54 </span>            :     float mx, mn;
<span class="lineNum">      55 </span>            :     float a, shift;
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     const GlyphCache &amp;gc = seg-&gt;getFace()-&gt;glyphs();</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     unsigned short gid = aSlot-&gt;gid();</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     if (!gc.check(gid))</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     const BBox &amp;bb = gc.getBoundingBBox(gid);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     const SlantBox &amp;sb = gc.getBoundingSlantBox(gid);</span>
<span class="lineNum">      62 </span>            :     //float sx = aSlot-&gt;origin().x + currShift.x;
<span class="lineNum">      63 </span>            :     //float sy = aSlot-&gt;origin().y + currShift.y;
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     if (currOffset.x != 0.f || currOffset.y != 0.f)</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         _limit = Rect(limit.bl - currOffset, limit.tr - currOffset);</span>
<span class="lineNum">      66 </span>            :     else
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :         _limit = limit;</span>
<span class="lineNum">      68 </span>            :     // For a ShiftCollider, these indices indicate which vector we are moving by:
<span class="lineNum">      69 </span>            :     // each _ranges represents absolute space with respect to the origin of the slot. Thus take into account true origins but subtract the vmin for the slot
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">      71 </span>            :     {
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :         switch (i) {</span>
<span class="lineNum">      73 </span>            :             case 0 :    // x direction
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :                 mn = _limit.bl.x + currOffset.x;</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :                 mx = _limit.tr.x + currOffset.x;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :                 _len[i] = bb.xa - bb.xi;</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :                 a = currOffset.y + currShift.y;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :                 _ranges[i].initialise&lt;XY&gt;(mn, mx, margin, marginWeight, a);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">      80 </span>            :             case 1 :    // y direction
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :                 mn = _limit.bl.y + currOffset.y;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :                 mx = _limit.tr.y + currOffset.y;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :                 _len[i] = bb.ya - bb.yi;</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :                 a = currOffset.x + currShift.x;</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                 _ranges[i].initialise&lt;XY&gt;(mn, mx, margin, marginWeight, a);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">      87 </span>            :             case 2 :    // sum (negatively sloped diagonal boundaries)
<span class="lineNum">      88 </span>            :                 // pick closest x,y limit boundaries in s direction
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :                 shift = currOffset.x + currOffset.y + currShift.x + currShift.y;</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :                 mn = -2 * min(currShift.x - _limit.bl.x, currShift.y - _limit.bl.y) + shift;</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :                 mx = 2 * min(_limit.tr.x - currShift.x, _limit.tr.y - currShift.y) + shift;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :                 _len[i] = sb.sa - sb.si;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :                 a = currOffset.x - currOffset.y + currShift.x - currShift.y;</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :                 _ranges[i].initialise&lt;SD&gt;(mn, mx, margin / ISQRT2, marginWeight, a);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">      96 </span>            :             case 3 :    // diff (positively sloped diagonal boundaries)
<span class="lineNum">      97 </span>            :                 // pick closest x,y limit boundaries in d direction
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                 shift = currOffset.x - currOffset.y + currShift.x - currShift.y;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                 mn = -2 * min(currShift.x - _limit.bl.x, _limit.tr.y - currShift.y) + shift;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :                 mx = 2 * min(_limit.tr.x - currShift.x, currShift.y - _limit.bl.y) + shift;</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 _len[i] = sb.da - sb.di;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                 a = currOffset.x + currOffset.y + currShift.x + currShift.y;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 _ranges[i].initialise&lt;SD&gt;(mn, mx, margin / ISQRT2, marginWeight, a);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     105 </span>            :         }
<span class="lineNum">     106 </span>            :     }
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         _target = aSlot;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     if ((dir &amp; 1) == 0)</span>
<span class="lineNum">     110 </span>            :     {
<span class="lineNum">     111 </span>            :         // For LTR, switch and negate x limits.
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         _limit.bl.x = -1 * limit.tr.x;</span>
<span class="lineNum">     113 </span>            :         //_limit.tr.x = -1 * limit.bl.x;
<span class="lineNum">     114 </span>            :     }
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     _currOffset = currOffset;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     _currShift = currShift;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     _origin = aSlot-&gt;origin() - currOffset;     // the original anchor position of the glyph</span>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         _margin = margin;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         _marginWt = marginWeight;</span>
<span class="lineNum">     121 </span>            :     
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     SlotCollision *c = seg-&gt;collisionInfo(aSlot);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     _seqClass = c-&gt;seqClass();</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         _seqProxClass = c-&gt;seqProxClass();</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     _seqOrder = c-&gt;seqOrder();</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     127 </span>            : }
<a name="128"><span class="lineNum">     128 </span>            : </a>
<span class="lineNum">     129 </span>            : template &lt;class O&gt;
<span class="lineNum">     130 </span><span class="lineNoCov">          0 : float sdm(float vi, float va, float mx, float my, O op)</span>
<span class="lineNum">     131 </span>            : {
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     float res = 2 * mx - vi;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     if (op(res, vi + 2 * my))</span>
<span class="lineNum">     134 </span>            :     {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         res = va + 2 * my;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         if (op(res, 2 * mx - va))</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :             res = mx + my;</span>
<span class="lineNum">     138 </span>            :     }
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">     140 </span>            : }
<a name="141"><span class="lineNum">     141 </span>            : </a>
<span class="lineNum">     142 </span>            : // Mark an area with a cost that can vary along the x or y axis. The region is expressed in terms of the centre of the target glyph in each axis
<span class="lineNum">     143 </span><span class="lineNoCov">          0 : void ShiftCollider::addBox_slope(bool isx, const Rect &amp;box, const BBox &amp;bb, const SlantBox &amp;sb, const Position &amp;org, float weight, float m, bool minright, int axis)</span>
<span class="lineNum">     144 </span>            : {
<span class="lineNum">     145 </span>            :     float a, c;
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     switch (axis) {</span>
<span class="lineNum">     147 </span>            :         case 0 :
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :              if (box.bl.y &lt; org.y + bb.ya &amp;&amp; box.tr.y &gt; org.y + bb.yi &amp;&amp; box.width() &gt; 0)</span>
<span class="lineNum">     149 </span>            :             {
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                 a = org.y + 0.5f * (bb.yi + bb.ya);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 c = 0.5f * (bb.xi + bb.xa);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :                 if (isx)</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                     _ranges[axis].weighted&lt;XY&gt;(box.bl.x - c, box.tr.x - c, weight, a, m,</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                                                 (minright ? box.tr.x : box.bl.x) - c, a, 0, false);</span>
<span class="lineNum">     155 </span>            :                 else
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                     _ranges[axis].weighted&lt;XY&gt;(box.bl.x - c, box.tr.x - c, weight, a, 0, 0, org.y,</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                                                 m * (a * a + sqr((minright ? box.tr.y : box.bl.y) - 0.5f * (bb.yi + bb.ya))), false);</span>
<span class="lineNum">     158 </span>            :             }
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     160 </span>            :         case 1 :
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :             if (box.bl.x &lt; org.x + bb.xa &amp;&amp; box.tr.x &gt; org.x + bb.xi &amp;&amp; box.height() &gt; 0)</span>
<span class="lineNum">     162 </span>            :             {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                 a = org.x + 0.5f * (bb.xi + bb.xa);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                 c = 0.5f * (bb.yi + bb.ya);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :                 if (isx)</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :                     _ranges[axis].weighted&lt;XY&gt;(box.bl.y - c, box.tr.y - c, weight, a, 0, 0, org.x,</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                                                 m * (a * a + sqr((minright ? box.tr.x : box.bl.x) - 0.5f * (bb.xi + bb.xa))), false);</span>
<span class="lineNum">     168 </span>            :                 else
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :                     _ranges[axis].weighted&lt;XY&gt;(box.bl.y - c, box.tr.y - c, weight, a, m, </span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                                                 (minright ? box.tr.y : box.bl.y) - c, a, 0, false);</span>
<span class="lineNum">     171 </span>            :             }
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     173 </span>            :         case 2 :
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :             if (box.bl.x - box.tr.y &lt; org.x - org.y + sb.da &amp;&amp; box.tr.x - box.bl.y &gt; org.x - org.y + sb.di)</span>
<span class="lineNum">     175 </span>            :             {
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 float d = org.x - org.y + 0.5f * (sb.di + sb.da);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 c = 0.5f * (sb.si + sb.sa);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 float smax = min(2 * box.tr.x - d, 2 * box.tr.y + d);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                 float smin = max(2 * box.bl.x - d, 2 * box.bl.y + d);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :                 if (smin &gt; smax) return;</span>
<span class="lineNum">     181 </span>            :                 float si;
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                 a = d;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 if (isx)</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :                     si = 2 * (minright ? box.tr.x : box.bl.x) - a;</span>
<span class="lineNum">     185 </span>            :                 else
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                     si = 2 * (minright ? box.tr.y : box.bl.y) + a;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :                 _ranges[axis].weighted&lt;SD&gt;(smin - c, smax - c, weight / 2, a, m / 2, si, 0, 0, isx);</span>
<span class="lineNum">     188 </span>            :             }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     190 </span>            :         case 3 :
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :             if (box.bl.x + box.bl.y &lt; org.x + org.y + sb.sa &amp;&amp; box.tr.x + box.tr.y &gt; org.x + org.y + sb.si)</span>
<span class="lineNum">     192 </span>            :             {
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :                 float s = org.x + org.y + 0.5f * (sb.si + sb.sa);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :                 c = 0.5f * (sb.di + sb.da);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 float dmax = min(2 * box.tr.x - s, s - 2 * box.bl.y);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 float dmin = max(2 * box.bl.x - s, s - 2 * box.tr.y);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                 if (dmin &gt; dmax) return;</span>
<span class="lineNum">     198 </span>            :                 float di;
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 a = s;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                 if (isx)</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                     di = 2 * (minright ? box.tr.x : box.bl.x) - a;</span>
<span class="lineNum">     202 </span>            :                 else
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                     di = 2 * (minright ? box.tr.y : box.bl.y) + a;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                 _ranges[axis].weighted&lt;SD&gt;(dmin - c, dmax - c, weight / 2, a, m / 2, di, 0, 0, !isx);</span>
<span class="lineNum">     205 </span>            :             }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     207 </span>            :         default :
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     211 </span>            : }
<a name="212"><span class="lineNum">     212 </span>            : </a>
<span class="lineNum">     213 </span>            : // Mark an area with an absolute cost, making it completely inaccessible.
<span class="lineNum">     214 </span><span class="lineNoCov">          0 : inline void ShiftCollider::removeBox(const Rect &amp;box, const BBox &amp;bb, const SlantBox &amp;sb, const Position &amp;org, int axis)</span>
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span>            :     float c;
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     switch (axis) {</span>
<span class="lineNum">     218 </span>            :         case 0 :
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :             if (box.bl.y &lt; org.y + bb.ya &amp;&amp; box.tr.y &gt; org.y + bb.yi &amp;&amp; box.width() &gt; 0)</span>
<span class="lineNum">     220 </span>            :             {
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                 c = 0.5f * (bb.xi + bb.xa);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                 _ranges[axis].exclude(box.bl.x - c, box.tr.x - c);</span>
<span class="lineNum">     223 </span>            :             }
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     225 </span>            :         case 1 :
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             if (box.bl.x &lt; org.x + bb.xa &amp;&amp; box.tr.x &gt; org.x + bb.xi &amp;&amp; box.height() &gt; 0)</span>
<span class="lineNum">     227 </span>            :             {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :                 c = 0.5f * (bb.yi + bb.ya);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :                 _ranges[axis].exclude(box.bl.y - c, box.tr.y - c);</span>
<span class="lineNum">     230 </span>            :             }
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     232 </span>            :         case 2 :
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :             if (box.bl.x - box.tr.y &lt; org.x - org.y + sb.da &amp;&amp; box.tr.x - box.bl.y &gt; org.x - org.y + sb.di </span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                 &amp;&amp; box.width() &gt; 0 &amp;&amp; box.height() &gt; 0)</span>
<span class="lineNum">     235 </span>            :             {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                 float di = org.x - org.y + sb.di;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 float da = org.x - org.y + sb.da;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                 float smax = sdm(di, da, box.tr.x, box.tr.y, std::greater&lt;float&gt;());</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                 float smin = sdm(da, di, box.bl.x, box.bl.y, std::less&lt;float&gt;());</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 c = 0.5f * (sb.si + sb.sa);</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                 _ranges[axis].exclude(smin - c, smax - c);</span>
<span class="lineNum">     242 </span>            :             }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     244 </span>            :         case 3 :
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :             if (box.bl.x + box.bl.y &lt; org.x + org.y + sb.sa &amp;&amp; box.tr.x + box.tr.y &gt; org.x + org.y + sb.si </span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 &amp;&amp; box.width() &gt; 0 &amp;&amp; box.height() &gt; 0)</span>
<span class="lineNum">     247 </span>            :             {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                 float si = org.x + org.y + sb.si;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                 float sa = org.x + org.y + sb.sa;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                 float dmax = sdm(si, sa, box.tr.x, -box.bl.y, std::greater&lt;float&gt;());</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                 float dmin = sdm(sa, si, box.bl.x, -box.tr.y, std::less&lt;float&gt;());</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 c = 0.5f * (sb.di + sb.da);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                 _ranges[axis].exclude(dmin - c, dmax - c);</span>
<span class="lineNum">     254 </span>            :             }
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     256 </span>            :         default :
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     258 </span>            :     }
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     260 </span>            : }
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : // Adjust the movement limits for the target to avoid having it collide
<a name="263"><span class="lineNum">     263 </span>            : // with the given neighbor slot. Also determine if there is in fact a collision</a>
<span class="lineNum">     264 </span>            : // between the target and the given slot.
<span class="lineNum">     265 </span><span class="lineNoCov">          0 : bool ShiftCollider::mergeSlot(Segment *seg, Slot *slot, const SlotCollision *cslot, const Position &amp;currShift,</span>
<span class="lineNum">     266 </span>            :                 bool isAfter,  // slot is logically after _target
<span class="lineNum">     267 </span>            :                 bool sameCluster, bool &amp;hasCol, bool isExclusion,
<span class="lineNum">     268 </span>            :         GR_MAYBE_UNUSED json * const dbgout )
<span class="lineNum">     269 </span>            : {
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     bool isCol = false;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     const float sx = slot-&gt;origin().x - _origin.x + currShift.x;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     const float sy = slot-&gt;origin().y - _origin.y + currShift.y;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     const float sd = sx - sy;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     const float ss = sx + sy;</span>
<span class="lineNum">     275 </span>            :     float vmin, vmax;
<span class="lineNum">     276 </span>            :     float omin, omax, otmin, otmax;
<span class="lineNum">     277 </span>            :     float cmin, cmax;   // target limits
<span class="lineNum">     278 </span>            :     float torg;
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     const GlyphCache &amp;gc = seg-&gt;getFace()-&gt;glyphs();</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     const unsigned short gid = slot-&gt;gid();</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     if (!gc.check(gid))</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     const BBox &amp;bb = gc.getBoundingBBox(gid);</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :     // SlotCollision * cslot = seg-&gt;collisionInfo(slot);
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     int orderFlags = 0;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     bool sameClass = _seqProxClass == 0 &amp;&amp; cslot-&gt;seqClass() == _seqClass;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     if (sameCluster &amp;&amp; _seqClass </span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         &amp;&amp; (sameClass || (_seqProxClass != 0 &amp;&amp; cslot-&gt;seqClass() == _seqProxClass)))</span>
<span class="lineNum">     290 </span>            :                 // Force the target glyph to be in the specified direction from the slot we're testing.
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         orderFlags = _seqOrder;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     // short circuit if only interested in direct collision and we are out of range
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     if (orderFlags || (sx + bb.xa + _margin &gt;= _limit.bl.x &amp;&amp; sx + bb.xi - _margin &lt;= _limit.tr.x)</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :                     || (sy + bb.ya + _margin &gt;= _limit.bl.y &amp;&amp; sy + bb.yi - _margin &lt;= _limit.tr.y))</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     {
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         const float tx = _currOffset.x + _currShift.x;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         const float ty = _currOffset.y + _currShift.y;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         const float td = tx - ty;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         const float ts = tx + ty;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         const SlantBox &amp;sb = gc.getBoundingSlantBox(gid);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         const unsigned short tgid = _target-&gt;gid();</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         const BBox &amp;tbb = gc.getBoundingBBox(tgid);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         const SlantBox &amp;tsb = gc.getBoundingSlantBox(tgid);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         float seq_above_wt = cslot-&gt;seqAboveWt();</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         float seq_below_wt = cslot-&gt;seqBelowWt();</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         float seq_valign_wt = cslot-&gt;seqValignWt();</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         float lmargin = _margin;</span>
<span class="lineNum">     310 </span>            :         // if isAfter, invert orderFlags for diagonal orders.
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         if (isAfter)</span>
<span class="lineNum">     312 </span>            :         {
<span class="lineNum">     313 </span>            :             // invert appropriate bits
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             orderFlags ^= (sameClass ? 0x3F : 0x3);</span>
<span class="lineNum">     315 </span>            :             // consider 2 bits at a time, non overlapping. If both bits set, clear them
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :             orderFlags = orderFlags ^ ((((orderFlags &gt;&gt; 1) &amp; orderFlags) &amp; 0x15) * 3);</span>
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     320 </span>            :         if (dbgout)
<span class="lineNum">     321 </span>            :             dbgout-&gt;setenv(0, slot);
<span class="lineNum">     322 </span>            : #endif
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :         // Process main bounding octabox.
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     326 </span>            :         {
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :             switch (i) {</span>
<span class="lineNum">     328 </span>            :                 case 0 :        // x direction
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                     vmin = max(max(bb.xi - tbb.xa + sx, sb.di - tsb.da + ty + sd), sb.si - tsb.sa - ty + ss);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                     vmax = min(min(bb.xa - tbb.xi + sx, sb.da - tsb.di + ty + sd), sb.sa - tsb.si - ty + ss);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                     otmin = tbb.yi + ty;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                     otmax = tbb.ya + ty;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                     omin = bb.yi + sy;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                     omax = bb.ya + sy;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :                     torg = _currOffset.x;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                     cmin = _limit.bl.x + torg;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :                     cmax = _limit.tr.x - tbb.xi + tbb.xa + torg;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                     lmargin = _margin;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     340 </span>            :                 case 1 :        // y direction
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                     vmin = max(max(bb.yi - tbb.ya + sy, tsb.di - sb.da + tx - sd), sb.si - tsb.sa - tx + ss);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                     vmax = min(min(bb.ya - tbb.yi + sy, tsb.da - sb.di + tx - sd), sb.sa - tsb.si - tx + ss);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                     otmin = tbb.xi + tx;</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                     otmax = tbb.xa + tx;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                     omin = bb.xi + sx;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                     omax = bb.xa + sx;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                     torg = _currOffset.y;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                     cmin = _limit.bl.y + torg;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                     cmax = _limit.tr.y - tbb.yi + tbb.ya + torg;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                     lmargin = _margin;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     352 </span>            :                 case 2 :    // sum - moving along the positively-sloped vector, so the boundaries are the
<span class="lineNum">     353 </span>            :                             // negatively-sloped boundaries.
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                     vmin = max(max(sb.si - tsb.sa + ss, 2 * (bb.yi - tbb.ya + sy) + td), 2 * (bb.xi - tbb.xa + sx) - td);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                     vmax = min(min(sb.sa - tsb.si + ss, 2 * (bb.ya - tbb.yi + sy) + td), 2 * (bb.xa - tbb.xi + sx) - td);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                     otmin = tsb.di + td;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                     otmax = tsb.da + td;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                     omin = sb.di + sd;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :                     omax = sb.da + sd;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :                     torg = _currOffset.x + _currOffset.y;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                     cmin = _limit.bl.x + _limit.bl.y + torg;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :                     cmax = _limit.tr.x + _limit.tr.y - tsb.si + tsb.sa + torg;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                     lmargin = _margin / ISQRT2;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     365 </span>            :                 case 3 :    // diff - moving along the negatively-sloped vector, so the boundaries are the
<span class="lineNum">     366 </span>            :                             // positively-sloped boundaries.
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                     vmin = max(max(sb.di - tsb.da + sd, 2 * (bb.xi - tbb.xa + sx) - ts), -2 * (bb.ya - tbb.yi + sy) + ts);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                     vmax = min(min(sb.da - tsb.di + sd, 2 * (bb.xa - tbb.xi + sx) - ts), -2 * (bb.yi - tbb.ya + sy) + ts);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                     otmin = tsb.si + ts;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                     otmax = tsb.sa + ts;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                     omin = sb.si + ss;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                     omax = sb.sa + ss;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                     torg = _currOffset.x - _currOffset.y;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                     cmin = _limit.bl.x - _limit.tr.y + torg;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                     cmax = _limit.tr.x - _limit.bl.y - tsb.di + tsb.da + torg;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :                     lmargin = _margin / ISQRT2;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     378 </span>            :                 default :
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">     380 </span>            :             }
<span class="lineNum">     381 </span>            :             
<span class="lineNum">     382 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     383 </span>            :             if (dbgout)
<span class="lineNum">     384 </span>            :                 dbgout-&gt;setenv(1, reinterpret_cast&lt;void *&gt;(-1));
<span class="lineNum">     385 </span>            : #define DBGTAG(x) if (dbgout) dbgout-&gt;setenv(1, reinterpret_cast&lt;void *&gt;(-x));
<span class="lineNum">     386 </span>            : #else
<span class="lineNum">     387 </span>            : #define DBGTAG(x)
<span class="lineNum">     388 </span>            : #endif
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :             if (orderFlags)</span>
<span class="lineNum">     391 </span>            :             {
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :                 Position org(tx, ty);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                 float xminf = _limit.bl.x + _currOffset.x + tbb.xi;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                 float xpinf = _limit.tr.x + _currOffset.x + tbb.xa;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                 float ypinf = _limit.tr.y + _currOffset.y + tbb.ya;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 float yminf = _limit.bl.y + _currOffset.y + tbb.yi;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 switch (orderFlags) {</span>
<span class="lineNum">     398 </span>            :                     case SlotCollision::SEQ_ORDER_RIGHTUP :
<span class="lineNum">     399 </span>            :                     {
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                         float r1Xedge = cslot-&gt;seqAboveXoff() + 0.5f * (bb.xi + bb.xa) + sx;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                         float r3Xedge = cslot-&gt;seqBelowXlim() + bb.xa + sx + 0.5f * (tbb.xa - tbb.xi);</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                         float r2Yedge = 0.5f * (bb.yi + bb.ya) + sy;</span>
<span class="lineNum">     403 </span>            :                         
<span class="lineNum">     404 </span>            :                         // DBGTAG(1x) means the regions are up and right
<span class="lineNum">     405 </span>            :                         // region 1
<span class="lineNum">     406 </span>            :                         DBGTAG(11)
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                         addBox_slope(true, Rect(Position(xminf, r2Yedge), Position(r1Xedge, ypinf)),</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, 0, seq_above_wt, true, i);</span>
<span class="lineNum">     409 </span>            :                         // region 2
<span class="lineNum">     410 </span>            :                         DBGTAG(12)
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(xminf, yminf), Position(r3Xedge, r2Yedge)), tbb, tsb, org, i);</span>
<span class="lineNum">     412 </span>            :                         // region 3, which end is zero is irrelevant since m weight is 0
<span class="lineNum">     413 </span>            :                         DBGTAG(13)
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                         addBox_slope(true, Rect(Position(r3Xedge, yminf), Position(xpinf, r2Yedge - cslot-&gt;seqValignHt())),</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, seq_below_wt, 0, true, i);</span>
<span class="lineNum">     416 </span>            :                         // region 4
<span class="lineNum">     417 </span>            :                         DBGTAG(14)
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                         addBox_slope(false, Rect(Position(sx + bb.xi, r2Yedge), Position(xpinf, r2Yedge + cslot-&gt;seqValignHt())),</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, 0, seq_valign_wt, true, i);</span>
<span class="lineNum">     420 </span>            :                         // region 5
<span class="lineNum">     421 </span>            :                         DBGTAG(15)
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                         addBox_slope(false, Rect(Position(sx + bb.xi, r2Yedge - cslot-&gt;seqValignHt()), Position(xpinf, r2Yedge)),</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, seq_below_wt, seq_valign_wt, false, i);</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     425 </span>            :                     }
<span class="lineNum">     426 </span>            :                     case SlotCollision::SEQ_ORDER_LEFTDOWN :
<span class="lineNum">     427 </span>            :                     {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                         float r1Xedge = 0.5f * (bb.xi + bb.xa) + cslot-&gt;seqAboveXoff() + sx;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                         float r3Xedge = bb.xi - cslot-&gt;seqBelowXlim() + sx - 0.5f * (tbb.xa - tbb.xi);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                         float r2Yedge = 0.5f * (bb.yi + bb.ya) + sy;</span>
<span class="lineNum">     431 </span>            :                         // DBGTAG(2x) means the regions are up and right
<span class="lineNum">     432 </span>            :                         // region 1
<span class="lineNum">     433 </span>            :                         DBGTAG(21)
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                         addBox_slope(true, Rect(Position(r1Xedge, yminf), Position(xpinf, r2Yedge)),</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, 0, seq_above_wt, false, i);</span>
<span class="lineNum">     436 </span>            :                         // region 2
<span class="lineNum">     437 </span>            :                         DBGTAG(22)
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(r3Xedge, r2Yedge), Position(xpinf, ypinf)), tbb, tsb, org, i);</span>
<span class="lineNum">     439 </span>            :                         // region 3
<span class="lineNum">     440 </span>            :                         DBGTAG(23)
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                         addBox_slope(true, Rect(Position(xminf, r2Yedge - cslot-&gt;seqValignHt()), Position(r3Xedge, ypinf)),</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, seq_below_wt, 0, false, i);</span>
<span class="lineNum">     443 </span>            :                         // region 4
<span class="lineNum">     444 </span>            :                         DBGTAG(24)
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                         addBox_slope(false, Rect(Position(xminf, r2Yedge), Position(sx + bb.xa, r2Yedge + cslot-&gt;seqValignHt())),</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                                         tbb, tsb, org, 0, seq_valign_wt, true, i);</span>
<span class="lineNum">     447 </span>            :                         // region 5
<span class="lineNum">     448 </span>            :                         DBGTAG(25)
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                         addBox_slope(false, Rect(Position(xminf, r2Yedge - cslot-&gt;seqValignHt()),</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                                         Position(sx + bb.xa, r2Yedge)), tbb, tsb, org, seq_below_wt, seq_valign_wt, false, i);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     452 </span>            :                     }
<span class="lineNum">     453 </span>            :                     case SlotCollision::SEQ_ORDER_NOABOVE : // enforce neighboring glyph being above
<span class="lineNum">     454 </span>            :                         DBGTAG(31);
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(bb.xi - tbb.xa + sx, sy + bb.ya), </span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                                         Position(bb.xa - tbb.xi + sx, ypinf)), tbb, tsb, org, i);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     458 </span>            :                     case SlotCollision::SEQ_ORDER_NOBELOW :     // enforce neighboring glyph being below
<span class="lineNum">     459 </span>            :                         DBGTAG(32);
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(bb.xi - tbb.xa + sx, yminf),</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                                         Position(bb.xa - tbb.xi + sx, sy + bb.yi)), tbb, tsb, org, i);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     463 </span>            :                     case SlotCollision::SEQ_ORDER_NOLEFT :  // enforce neighboring glyph being to the left
<span class="lineNum">     464 </span>            :                         DBGTAG(33)
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(xminf, bb.yi - tbb.ya + sy),</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                                         Position(bb.xi - tbb.xa + sx, bb.ya - tbb.yi + sy)), tbb, tsb, org, i);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     468 </span>            :                     case SlotCollision::SEQ_ORDER_NORIGHT : // enforce neighboring glyph being to the right
<span class="lineNum">     469 </span>            :                         DBGTAG(34)
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                         removeBox(Rect(Position(bb.xa - tbb.xi + sx, bb.yi - tbb.ya + sy),</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                                         Position(xpinf, bb.ya - tbb.yi + sy)), tbb, tsb, org, i);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     473 </span>            :                     default :
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     475 </span>            :                 }
<span class="lineNum">     476 </span>            :             }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             if (vmax &lt; cmin - lmargin || vmin &gt; cmax + lmargin || omax &lt; otmin - lmargin || omin &gt; otmax + lmargin)</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :             // Process sub-boxes that are defined for this glyph.
<span class="lineNum">     482 </span>            :             // We only need to do this if there was in fact a collision with the main octabox.
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :             uint8 numsub = gc.numSubBounds(gid);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :             if (numsub &gt; 0)</span>
<span class="lineNum">     485 </span>            :             {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                 bool anyhits = false;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 for (int j = 0; j &lt; numsub; ++j)</span>
<span class="lineNum">     488 </span>            :                 {
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                     const BBox &amp;sbb = gc.getSubBoundingBBox(gid, j);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                     const SlantBox &amp;ssb = gc.getSubBoundingSlantBox(gid, j);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                     switch (i) {</span>
<span class="lineNum">     492 </span>            :                         case 0 :    // x
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                             vmin = max(max(sbb.xi-tbb.xa+sx, ssb.di-tsb.da+sd+ty), ssb.si-tsb.sa+ss-ty);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                             vmax = min(min(sbb.xa-tbb.xi+sx, ssb.da-tsb.di+sd+ty), ssb.sa-tsb.si+ss-ty);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                             omin = sbb.yi + sy;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                             omax = sbb.ya + sy;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     498 </span>            :                         case 1 :    // y
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                             vmin = max(max(sbb.yi-tbb.ya+sy, tsb.di-ssb.da-sd+tx), ssb.si-tsb.sa+ss-tx);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :                             vmax = min(min(sbb.ya-tbb.yi+sy, tsb.da-ssb.di-sd+tx), ssb.sa-tsb.si+ss-tx);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                             omin = sbb.xi + sx;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                             omax = sbb.xa + sx;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     504 </span>            :                         case 2 :    // sum
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                             vmin = max(max(ssb.si-tsb.sa+ss, 2*(sbb.yi-tbb.ya+sy)+td), 2*(sbb.xi-tbb.xa+sx)-td);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                             vmax = min(min(ssb.sa-tsb.si+ss, 2*(sbb.ya-tbb.yi+sy)+td), 2*(sbb.xa-tbb.xi+sx)-td);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                             omin = ssb.di + sd;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                             omax = ssb.da + sd;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     510 </span>            :                         case 3 :    // diff
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                             vmin = max(max(ssb.di-tsb.da+sd, 2*(sbb.xi-tbb.xa+sx)-ts), -2*(sbb.ya-tbb.yi+sy)+ts);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :                             vmax = min(min(ssb.da-tsb.di+sd, 2*(sbb.xa-tbb.xi+sx)-ts), -2*(sbb.yi-tbb.ya+sy)+ts);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :                             omin = ssb.si + ss;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                             omax = ssb.sa + ss;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     516 </span>            :                     }
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                     if (vmax &lt; cmin - lmargin || vmin &gt; cmax + lmargin || omax &lt; otmin - lmargin || omin &gt; otmax + lmargin)</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     521 </span>            :                     if (dbgout)
<span class="lineNum">     522 </span>            :                         dbgout-&gt;setenv(1, reinterpret_cast&lt;void *&gt;(j));
<span class="lineNum">     523 </span>            : #endif
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                     if (omin &gt; otmax)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                         _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                                                 sqr(lmargin - omin + otmax) * _marginWt, false);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                     else if (omax &lt; otmin)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                         _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                                                 sqr(lmargin - otmin + omax) * _marginWt, false);</span>
<span class="lineNum">     530 </span>            :                     else
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                         _ranges[i].exclude_with_margins(vmin, vmax, i);</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                     anyhits = true;</span>
<span class="lineNum">     533 </span>            :                 }
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                 if (anyhits)</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                     isCol = true;</span>
<span class="lineNum">     536 </span>            :             }
<span class="lineNum">     537 </span>            :             else // no sub-boxes
<span class="lineNum">     538 </span>            :             {
<span class="lineNum">     539 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     540 </span>            :                     if (dbgout)
<span class="lineNum">     541 </span>            :                         dbgout-&gt;setenv(1, reinterpret_cast&lt;void *&gt;(-1));
<span class="lineNum">     542 </span>            : #endif
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                 isCol = true;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 if (omin &gt; otmax)</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                     _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                                             sqr(lmargin - omin + otmax) * _marginWt, false);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 else if (omax &lt; otmin)</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                     _ranges[i].weightedAxis(i, vmin - lmargin, vmax + lmargin, 0, 0, 0, 0, 0,</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                                             sqr(lmargin - otmin + omax) * _marginWt, false);</span>
<span class="lineNum">     550 </span>            :                 else
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                     _ranges[i].exclude_with_margins(vmin, vmax, i);</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :             }
<span class="lineNum">     554 </span>            :         }
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     bool res = true;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     if (cslot-&gt;exclGlyph() &gt; 0 &amp;&amp; gc.check(cslot-&gt;exclGlyph()) &amp;&amp; !isExclusion)</span>
<span class="lineNum">     558 </span>            :     {
<span class="lineNum">     559 </span>            :         // Set up the bogus slot representing the exclusion glyph.
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         Slot *exclSlot = seg-&gt;newSlot();</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :         exclSlot-&gt;setGlyph(seg, cslot-&gt;exclGlyph());</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         Position exclOrigin(slot-&gt;origin() + cslot-&gt;exclOffset());</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         exclSlot-&gt;origin(exclOrigin);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         SlotCollision exclInfo(seg, exclSlot);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         res &amp;= mergeSlot(seg, exclSlot, &amp;exclInfo, currShift, isAfter, sameCluster, isCol, true, dbgout );</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         seg-&gt;freeSlot(exclSlot);</span>
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     hasCol |= isCol;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">     570 </span>            :     
<span class="lineNum">     571 </span>            : }   // end of ShiftCollider::mergeSlot
<span class="lineNum">     572 </span>            : 
<a name="573"><span class="lineNum">     573 </span>            : </a>
<span class="lineNum">     574 </span>            : // Figure out where to move the target glyph to, and return the amount to shift by.
<span class="lineNum">     575 </span><span class="lineNoCov">          0 : Position ShiftCollider::resolve(GR_MAYBE_UNUSED Segment *seg, bool &amp;isCol, GR_MAYBE_UNUSED json * const dbgout)</span>
<span class="lineNum">     576 </span>            : {
<span class="lineNum">     577 </span>            :     float tbase;
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     float totalCost = (float)(std::numeric_limits&lt;float&gt;::max() / 2);</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     Position resultPos = Position(0, 0);</span>
<span class="lineNum">     580 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     581 </span>            :         int bestAxis = -1;
<span class="lineNum">     582 </span>            :     if (dbgout)
<span class="lineNum">     583 </span>            :     {
<span class="lineNum">     584 </span>            :                 outputJsonDbgStartSlot(dbgout, seg);
<span class="lineNum">     585 </span>            :         *dbgout &lt;&lt; &quot;vectors&quot; &lt;&lt; json::array;
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span>            : #endif
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     isCol = true;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; 4; ++i)</span>
<span class="lineNum">     590 </span>            :     {
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         float bestCost = -1;</span>
<span class="lineNum">     592 </span>            :         float bestPos;
<span class="lineNum">     593 </span>            :         // Calculate the margin depending on whether we are moving diagonally or not:
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :         switch (i) {</span>
<span class="lineNum">     595 </span>            :             case 0 :    // x direction
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                 tbase = _currOffset.x;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     598 </span>            :             case 1 :    // y direction
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                 tbase = _currOffset.y;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     601 </span>            :             case 2 :    // sum (negatively-sloped diagonals)
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                 tbase = _currOffset.x + _currOffset.y;</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     604 </span>            :             case 3 :    // diff (positively-sloped diagonals)
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                 tbase = _currOffset.x - _currOffset.y;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     607 </span>            :         }
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         Position testp;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         bestPos = _ranges[i].closest(0, bestCost) - tbase;     // Get the best relative position</span>
<span class="lineNum">     610 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     611 </span>            :         if (dbgout)
<span class="lineNum">     612 </span>            :             outputJsonDbgOneVector(dbgout, seg, i, tbase, bestCost, bestPos) ;
<span class="lineNum">     613 </span>            : #endif
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         if (bestCost &gt;= 0.0f)</span>
<span class="lineNum">     615 </span>            :         {
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :             isCol = false;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :             switch (i) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                 case 0 : testp = Position(bestPos, _currShift.y); break;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                 case 1 : testp = Position(_currShift.x, bestPos); break;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                 case 2 : testp = Position(0.5f * (_currShift.x - _currShift.y + bestPos), 0.5f * (_currShift.y - _currShift.x + bestPos)); break;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 case 3 : testp = Position(0.5f * (_currShift.x + _currShift.y + bestPos), 0.5f * (_currShift.x + _currShift.y - bestPos)); break;</span>
<span class="lineNum">     622 </span>            :             }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             if (bestCost &lt; totalCost - 0.01f)</span>
<span class="lineNum">     624 </span>            :             {
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                 totalCost = bestCost;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                 resultPos = testp;</span>
<span class="lineNum">     627 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     628 </span>            :                 bestAxis = i;
<span class="lineNum">     629 </span>            : #endif
<span class="lineNum">     630 </span>            :             }
<span class="lineNum">     631 </span>            :         }
<span class="lineNum">     632 </span>            :     }  // end of loop over 4 directions
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     635 </span>            :     if (dbgout)
<span class="lineNum">     636 </span>            :         outputJsonDbgEndSlot(dbgout, resultPos, bestAxis, isCol);
<span class="lineNum">     637 </span>            : #endif
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     return resultPos;</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : }   // end of ShiftCollider::resolve
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : void ShiftCollider::outputJsonDbg(json * const dbgout, Segment *seg, int axis)
<span class="lineNum">     647 </span>            : {
<span class="lineNum">     648 </span>            :     int axisMax = axis;
<span class="lineNum">     649 </span>            :     if (axis &lt; 0) // output all axes
<span class="lineNum">     650 </span>            :     {
<span class="lineNum">     651 </span>            :         *dbgout &lt;&lt; &quot;gid&quot; &lt;&lt; _target-&gt;gid()
<span class="lineNum">     652 </span>            :             &lt;&lt; &quot;limit&quot; &lt;&lt; _limit
<span class="lineNum">     653 </span>            :             &lt;&lt; &quot;target&quot; &lt;&lt; json::object
<span class="lineNum">     654 </span>            :                 &lt;&lt; &quot;origin&quot; &lt;&lt; _target-&gt;origin()
<span class="lineNum">     655 </span>            :                 &lt;&lt; &quot;margin&quot; &lt;&lt; _margin
<span class="lineNum">     656 </span>            :                 &lt;&lt; &quot;bbox&quot; &lt;&lt; seg-&gt;theGlyphBBoxTemporary(_target-&gt;gid())
<span class="lineNum">     657 </span>            :                 &lt;&lt; &quot;slantbox&quot; &lt;&lt; seg-&gt;getFace()-&gt;glyphs().slant(_target-&gt;gid())
<span class="lineNum">     658 </span>            :                 &lt;&lt; json::close; // target object
<span class="lineNum">     659 </span>            :         *dbgout &lt;&lt; &quot;ranges&quot; &lt;&lt; json::array;
<span class="lineNum">     660 </span>            :         axis = 0;
<span class="lineNum">     661 </span>            :         axisMax = 3;
<span class="lineNum">     662 </span>            :     }
<span class="lineNum">     663 </span>            :     for (int iAxis = axis; iAxis &lt;= axisMax; ++iAxis)
<span class="lineNum">     664 </span>            :     {
<span class="lineNum">     665 </span>            :         *dbgout &lt;&lt; json::flat &lt;&lt; json::array &lt;&lt; _ranges[iAxis].position();
<span class="lineNum">     666 </span>            :         for (Zones::const_iterator s = _ranges[iAxis].begin(), e = _ranges[iAxis].end(); s != e; ++s)
<span class="lineNum">     667 </span>            :             *dbgout &lt;&lt; json::flat &lt;&lt; json::array 
<span class="lineNum">     668 </span>            :                         &lt;&lt; Position(s-&gt;x, s-&gt;xm) &lt;&lt; s-&gt;sm &lt;&lt; s-&gt;smx &lt;&lt; s-&gt;c
<span class="lineNum">     669 </span>            :                     &lt;&lt; json::close;
<span class="lineNum">     670 </span>            :         *dbgout &lt;&lt; json::close;
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            :     if (axis &lt; axisMax) // looped through the _ranges array for all axes
<span class="lineNum">     673 </span>            :         *dbgout &lt;&lt; json::close; // ranges array
<span class="lineNum">     674 </span>            : }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : void ShiftCollider::outputJsonDbgStartSlot(json * const dbgout, Segment *seg)
<span class="lineNum">     677 </span>            : {
<span class="lineNum">     678 </span>            :         *dbgout &lt;&lt; json::object // slot - not closed till the end of the caller method
<span class="lineNum">     679 </span>            :                 &lt;&lt; &quot;slot&quot; &lt;&lt; objectid(dslot(seg, _target))
<span class="lineNum">     680 </span>            :                                 &lt;&lt; &quot;gid&quot; &lt;&lt; _target-&gt;gid()
<span class="lineNum">     681 </span>            :                 &lt;&lt; &quot;limit&quot; &lt;&lt; _limit
<span class="lineNum">     682 </span>            :                 &lt;&lt; &quot;target&quot; &lt;&lt; json::object
<span class="lineNum">     683 </span>            :                     &lt;&lt; &quot;origin&quot; &lt;&lt; _origin
<span class="lineNum">     684 </span>            :                     &lt;&lt; &quot;currShift&quot; &lt;&lt; _currShift
<span class="lineNum">     685 </span>            :                     &lt;&lt; &quot;currOffset&quot; &lt;&lt; seg-&gt;collisionInfo(_target)-&gt;offset()
<span class="lineNum">     686 </span>            :                     &lt;&lt; &quot;bbox&quot; &lt;&lt; seg-&gt;theGlyphBBoxTemporary(_target-&gt;gid())
<span class="lineNum">     687 </span>            :                     &lt;&lt; &quot;slantBox&quot; &lt;&lt; seg-&gt;getFace()-&gt;glyphs().slant(_target-&gt;gid())
<span class="lineNum">     688 </span>            :                     &lt;&lt; &quot;fix&quot; &lt;&lt; &quot;shift&quot;;
<span class="lineNum">     689 </span>            :         *dbgout     &lt;&lt; json::close; // target object
<span class="lineNum">     690 </span>            : }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : void ShiftCollider::outputJsonDbgEndSlot(GR_MAYBE_UNUSED json * const dbgout,
<span class="lineNum">     693 </span>            :          Position resultPos, int bestAxis, bool isCol)
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span>            :     *dbgout &lt;&lt; json::close // vectors array
<span class="lineNum">     696 </span>            :     &lt;&lt; &quot;result&quot; &lt;&lt; resultPos
<span class="lineNum">     697 </span>            :         //&lt;&lt; &quot;scraping&quot; &lt;&lt; _scraping[bestAxis]
<span class="lineNum">     698 </span>            :         &lt;&lt; &quot;bestAxis&quot; &lt;&lt; bestAxis
<span class="lineNum">     699 </span>            :     &lt;&lt; &quot;stillBad&quot; &lt;&lt; isCol
<span class="lineNum">     700 </span>            :     &lt;&lt; json::close; // slot object
<span class="lineNum">     701 </span>            : }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : void ShiftCollider::outputJsonDbgOneVector(json * const dbgout, Segment *seg, int axis,
<span class="lineNum">     704 </span>            :         float tleft, float bestCost, float bestVal) 
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span>            :         const char * label;
<span class="lineNum">     707 </span>            :         switch (axis)
<span class="lineNum">     708 </span>            :         {
<span class="lineNum">     709 </span>            :                 case 0: label = &quot;x&quot;;                  break;
<span class="lineNum">     710 </span>            :                 case 1: label = &quot;y&quot;;                  break;
<span class="lineNum">     711 </span>            :                 case 2: label = &quot;sum (NE-SW)&quot;;        break;
<span class="lineNum">     712 </span>            :                 case 3: label = &quot;diff (NW-SE)&quot;;       break;
<span class="lineNum">     713 </span>            :                 default: label = &quot;???&quot;;                       break;
<span class="lineNum">     714 </span>            :         }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :         *dbgout &lt;&lt; json::object // vector
<span class="lineNum">     717 </span>            :                 &lt;&lt; &quot;direction&quot; &lt;&lt; label
<span class="lineNum">     718 </span>            :                 &lt;&lt; &quot;targetMin&quot; &lt;&lt; tleft;
<span class="lineNum">     719 </span>            :             
<span class="lineNum">     720 </span>            :         outputJsonDbgRemovals(dbgout, axis, seg);
<span class="lineNum">     721 </span>            :         
<span class="lineNum">     722 </span>            :     *dbgout &lt;&lt; &quot;ranges&quot;;
<span class="lineNum">     723 </span>            :     outputJsonDbg(dbgout, seg, axis);
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :     *dbgout &lt;&lt; &quot;bestCost&quot; &lt;&lt; bestCost
<span class="lineNum">     726 </span>            :         &lt;&lt; &quot;bestVal&quot; &lt;&lt; bestVal + tleft
<span class="lineNum">     727 </span>            :         &lt;&lt; json::close; // vectors object
<span class="lineNum">     728 </span>            : }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            : void ShiftCollider::outputJsonDbgRemovals(json * const dbgout, int axis, Segment *seg)
<span class="lineNum">     731 </span>            : {
<span class="lineNum">     732 </span>            :     *dbgout &lt;&lt; &quot;removals&quot; &lt;&lt; json::array;
<span class="lineNum">     733 </span>            :     _ranges[axis].jsonDbgOut(seg);
<span class="lineNum">     734 </span>            :     *dbgout &lt;&lt; json::close; // removals array
<span class="lineNum">     735 </span>            : }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : #endif // !defined GRAPHITE2_NTRACING
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : ////    KERN-COLLIDER    ////
<a name="741"><span class="lineNum">     741 </span>            : </a>
<span class="lineNum">     742 </span>            : inline
<span class="lineNum">     743 </span><span class="lineNoCov">          0 : static float localmax (float al, float au, float bl, float bu, float x)</span>
<span class="lineNum">     744 </span>            : {
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     if (al &lt; bl)</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     { if (au &lt; bu) return au &lt; x ? au : x; }</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     else if (au &gt; bu) return bl &lt; x ? bl : x;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     return x;</span>
<span class="lineNum">     749 </span>            : }
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : inline
<span class="lineNum">     752 </span><span class="lineNoCov">          0 : static float localmin(float al, float au, float bl, float bu, float x)</span>
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     if (bl &gt; al)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     { if (bu &gt; au) return bl &gt; x ? bl : x; }</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     else if (au &gt; bu) return al &gt; x ? al : x;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     return x;        </span>
<span class="lineNum">     758 </span>            : }
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : // Return the given edge of the glyph at height y, taking any slant box into account.
<span class="lineNum">     761 </span><span class="lineNoCov">          0 : static float get_edge(Segment *seg, const Slot *s, const Position &amp;shift, float y, float width, float margin, bool isRight)</span>
<span class="lineNum">     762 </span>            : {
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     const GlyphCache &amp;gc = seg-&gt;getFace()-&gt;glyphs();</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     unsigned short gid = s-&gt;gid();</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     float sx = s-&gt;origin().x + shift.x;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     float sy = s-&gt;origin().y + shift.y;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     uint8 numsub = gc.numSubBounds(gid);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     float res = isRight ? (float)-1e38 : (float)1e38;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     if (numsub &gt; 0)</span>
<span class="lineNum">     771 </span>            :     {
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; numsub; ++i)</span>
<span class="lineNum">     773 </span>            :         {
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :             const BBox &amp;sbb = gc.getSubBoundingBBox(gid, i);</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :             const SlantBox &amp;ssb = gc.getSubBoundingSlantBox(gid, i);</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :             if (sy + sbb.yi - margin &gt; y + width / 2 || sy + sbb.ya + margin &lt; y - width / 2)</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :             if (isRight)</span>
<span class="lineNum">     779 </span>            :             {
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                 float x = sx + sbb.xa + margin;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                 if (x &gt; res)</span>
<span class="lineNum">     782 </span>            :                 {
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :                     float td = sx - sy + ssb.da + margin + y;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :                     float ts = sx + sy + ssb.sa + margin - y;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :                     x = localmax(td - width / 2, td + width / 2,  ts - width / 2, ts + width / 2, x);</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                     if (x &gt; res)</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :                         res = x;</span>
<span class="lineNum">     788 </span>            :                 }
<span class="lineNum">     789 </span>            :             }
<span class="lineNum">     790 </span>            :             else
<span class="lineNum">     791 </span>            :             {
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :                 float x = sx + sbb.xi - margin;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                 if (x &lt; res)</span>
<span class="lineNum">     794 </span>            :                 {
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                     float td = sx - sy + ssb.di - margin + y;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                     float ts = sx + sy + ssb.si - margin - y;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :                     x = localmin(td - width / 2, td + width / 2, ts - width / 2, ts + width / 2, x);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                     if (x &lt; res)</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :                         res = x;</span>
<span class="lineNum">     800 </span>            :                 }
<span class="lineNum">     801 </span>            :             }
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            :     else
<span class="lineNum">     805 </span>            :     {
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         const BBox &amp;bb = gc.getBoundingBBox(gid);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         const SlantBox &amp;sb = gc.getBoundingSlantBox(gid);</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         float td = sx - sy + y;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         float ts = sx + sy - y;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         if (isRight)</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :             res = localmax(td + sb.da - width / 2, td + sb.da + width / 2, ts + sb.sa - width / 2, ts + sb.sa + width / 2, sx + bb.xa) + margin;</span>
<span class="lineNum">     812 </span>            :         else
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :             res = localmin(td + sb.di - width / 2, td + sb.di + width / 2, ts + sb.si - width / 2, ts + sb.si + width / 2, sx + bb.xi) - margin;</span>
<span class="lineNum">     814 </span>            :     }
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 : bool KernCollider::initSlot(Segment *seg, Slot *aSlot, const Rect &amp;limit, float margin,</span>
<span class="lineNum">     820 </span>            :     const Position &amp;currShift, const Position &amp;offsetPrev, int dir,
<span class="lineNum">     821 </span>            :     float ymin, float ymax, GR_MAYBE_UNUSED json * const dbgout)
<span class="lineNum">     822 </span>            : {
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     const GlyphCache &amp;gc = seg-&gt;getFace()-&gt;glyphs();</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     const Slot *base = aSlot;</span>
<span class="lineNum">     825 </span>            :     // const Slot *last = aSlot;
<span class="lineNum">     826 </span>            :     const Slot *s;
<span class="lineNum">     827 </span>            :     int numSlices;
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     while (base-&gt;attachedTo())</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         base = base-&gt;attachedTo();</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     if (margin &lt; 10) margin = 10;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     _limit = limit;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :     _offsetPrev = offsetPrev; // kern from a previous pass</span>
<span class="lineNum">     834 </span>            :     
<span class="lineNum">     835 </span>            :     // Calculate the height of the glyph and how many horizontal slices to use.
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     if (_maxy &gt;= 1e37f)</span>
<span class="lineNum">     837 </span>            :     {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         _sliceWidth = margin / 1.5f;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         _maxy = ymax + margin;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         _miny = ymin - margin;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         numSlices = int((_maxy - _miny + 2) / (_sliceWidth / 1.5f) + 1.f);  // +2 helps with rounding errors</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :         _edges.clear();</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         _edges.insert(_edges.begin(), numSlices, (dir &amp; 1) ? 1e38f : -1e38f);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         _xbound = (dir &amp; 1) ? (float)1e38f : (float)-1e38f;</span>
<span class="lineNum">     845 </span>            :     }
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     else if (_maxy != ymax || _miny != ymin)</span>
<span class="lineNum">     847 </span>            :     {
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         if (_miny != ymin)</span>
<span class="lineNum">     849 </span>            :         {
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :             numSlices = int((ymin - margin - _miny) / _sliceWidth - 1);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             _miny += numSlices * _sliceWidth;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :             if (numSlices &lt; 0)</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                 _edges.insert(_edges.begin(), -numSlices, (dir &amp; 1) ? 1e38f : -1e38f);</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :             else if ((unsigned)numSlices &lt; _edges.size())    // this shouldn't fire since we always grow the range</span>
<span class="lineNum">     855 </span>            :             {
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                 Vector&lt;float&gt;::iterator e = _edges.begin();</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                 while (numSlices--)</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                     ++e;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                 _edges.erase(_edges.begin(), e);</span>
<span class="lineNum">     860 </span>            :             }
<span class="lineNum">     861 </span>            :         }
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         if (_maxy != ymax)</span>
<span class="lineNum">     863 </span>            :         {
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :             numSlices = int((ymax + margin - _miny) / _sliceWidth + 1);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :             _maxy = numSlices * _sliceWidth + _miny;</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :             if (numSlices &gt; (int)_edges.size())</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :                 _edges.insert(_edges.end(), numSlices - _edges.size(), (dir &amp; 1) ? 1e38f : -1e38f);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :             else if (numSlices &lt; (int)_edges.size())   // this shouldn't fire since we always grow the range</span>
<span class="lineNum">     869 </span>            :             {
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                 while ((int)_edges.size() &gt; numSlices)</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                     _edges.pop_back();</span>
<span class="lineNum">     872 </span>            :             }
<span class="lineNum">     873 </span>            :         }
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         goto done;</span>
<span class="lineNum">     875 </span>            :     }
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     numSlices = _edges.size();</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     879 </span>            :     // Debugging
<span class="lineNum">     880 </span>            :     _seg = seg;
<span class="lineNum">     881 </span>            :     _slotNear.clear();
<span class="lineNum">     882 </span>            :     _slotNear.insert(_slotNear.begin(), numSlices, NULL);
<span class="lineNum">     883 </span>            :     _nearEdges.clear();
<span class="lineNum">     884 </span>            :     _nearEdges.insert(_nearEdges.begin(), numSlices, (dir &amp; 1) ? -1e38f : +1e38f);
<span class="lineNum">     885 </span>            : #endif
<span class="lineNum">     886 </span>            :     
<span class="lineNum">     887 </span>            :     // Determine the trailing edge of each slice (ie, left edge for a RTL glyph).
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     for (s = base; s; s = s-&gt;nextInCluster(s))</span>
<span class="lineNum">     889 </span>            :     {
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         SlotCollision *c = seg-&gt;collisionInfo(s);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         if (!gc.check(s-&gt;gid()))</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         const BBox &amp;bs = gc.getBoundingBBox(s-&gt;gid());</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         float x = s-&gt;origin().x + c-&gt;shift().x + ((dir &amp; 1) ? bs.xi : bs.xa);</span>
<span class="lineNum">     895 </span>            :         // Loop over slices.
<span class="lineNum">     896 </span>            :         // Note smin might not be zero if glyph s is not at the bottom of the cluster; similarly for smax.
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         float toffset = c-&gt;shift().y - _miny + 1 + s-&gt;origin().y;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         int smin = max(0, int((bs.yi + toffset) / _sliceWidth));</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         int smax = min(numSlices - 1, int((bs.ya + toffset) / _sliceWidth + 1));</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         for (int i = smin; i &lt;= smax; ++i)</span>
<span class="lineNum">     901 </span>            :         {
<span class="lineNum">     902 </span>            :             float t;
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :             float y = _miny - 1 + (i + .5f) * _sliceWidth; // vertical center of slice</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :             if ((dir &amp; 1) &amp;&amp; x &lt; _edges[i])</span>
<span class="lineNum">     905 </span>            :             {
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :                 t = get_edge(seg, s, c-&gt;shift(), y, _sliceWidth, margin, false);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 if (t &lt; _edges[i])</span>
<span class="lineNum">     908 </span>            :                 {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                     _edges[i] = t;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                     if (t &lt; _xbound)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                         _xbound = t;</span>
<span class="lineNum">     912 </span>            :                 }
<span class="lineNum">     913 </span>            :             }
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :             else if (!(dir &amp; 1) &amp;&amp; x &gt; _edges[i])</span>
<span class="lineNum">     915 </span>            :             {
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 t = get_edge(seg, s, c-&gt;shift(), y, _sliceWidth, margin, true);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 if (t &gt; _edges[i])</span>
<span class="lineNum">     918 </span>            :                 {
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                     _edges[i] = t;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                     if (t &gt; _xbound)</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                         _xbound = t;</span>
<span class="lineNum">     922 </span>            :                 }
<span class="lineNum">     923 </span>            :             }
<span class="lineNum">     924 </span>            :         }
<span class="lineNum">     925 </span>            :     }
<span class="lineNum">     926 </span>            :     done:
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     _mingap = (float)1e38;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     _target = aSlot;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     _margin = margin;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     _currShift = currShift;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     932 </span>            : }   // end of KernCollider::initSlot
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : // Determine how much the target slot needs to kern away from the given slot.
<span class="lineNum">     936 </span>            : // In other words, merge information from given slot's position with what the target slot knows
<a name="937"><span class="lineNum">     937 </span>            : // about how it can kern.</a>
<span class="lineNum">     938 </span>            : // Return false if we know there is no collision, true if we think there might be one.
<span class="lineNum">     939 </span><span class="lineNoCov">          0 : bool KernCollider::mergeSlot(Segment *seg, Slot *slot, const Position &amp;currShift, float currSpace, int dir, GR_MAYBE_UNUSED json * const dbgout)</span>
<span class="lineNum">     940 </span>            : {
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     int rtl = (dir &amp; 1) * 2 - 1;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     if (!seg-&gt;getFace()-&gt;glyphs().check(slot-&gt;gid()))</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     const Rect &amp;bb = seg-&gt;theGlyphBBoxTemporary(slot-&gt;gid());</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     const float sx = slot-&gt;origin().x + currShift.x;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     float x = (sx + (rtl &gt; 0 ? bb.tr.x : bb.bl.x)) * rtl;</span>
<span class="lineNum">     947 </span>            :     // this isn't going to reduce _mingap so skip
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     if (x &lt; rtl * (_xbound - _mingap - currSpace))</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     const float sy = slot-&gt;origin().y + currShift.y;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     int smin = max(1, int((bb.bl.y + (1 - _miny + sy)) / _sliceWidth + 1)) - 1;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     int smax = min((int)_edges.size() - 2, int((bb.tr.y + (1 - _miny + sy)) / _sliceWidth + 1)) + 1;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     if (smin &gt; smax)</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     bool collides = false;</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     for (int i = smin; i &lt;= smax; ++i)</span>
<span class="lineNum">     959 </span>            :     {
<span class="lineNum">     960 </span>            :         float t;
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         float here = _edges[i] * rtl;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         float y = (float)(_miny - 1 + (i + .5f) * _sliceWidth);  // vertical center of slice</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         if (    (x &gt; here - _mingap - currSpace) )</span>
<span class="lineNum">     964 </span>            :         {
<span class="lineNum">     965 </span>            :             // 2 * currSpace to account for the space that is already separating them and the space we want to add
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :             float m = get_edge(seg, slot, currShift, y, _sliceWidth, 0., rtl &gt; 0) * rtl + 2 * currSpace;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :             t = here - m;</span>
<span class="lineNum">     968 </span>            :             // _mingap is positive to shrink
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :             if (t &lt; _mingap)</span>
<span class="lineNum">     970 </span>            :             {
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                 _mingap = t;</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                 collides = true;</span>
<span class="lineNum">     973 </span>            :             }
<span class="lineNum">     974 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     975 </span>            :             // Debugging - remember the closest neighboring edge for this slice.
<span class="lineNum">     976 </span>            :             if (m &gt; rtl * _nearEdges[i])
<span class="lineNum">     977 </span>            :             {
<span class="lineNum">     978 </span>            :                 _slotNear[i] = slot;
<span class="lineNum">     979 </span>            :                 _nearEdges[i] = m * rtl;
<span class="lineNum">     980 </span>            :             }
<span class="lineNum">     981 </span>            : #endif
<span class="lineNum">     982 </span>            :         }
<span class="lineNum">     983 </span>            :     }
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     return collides;   // note that true is not a necessarily reliable value</span>
<span class="lineNum">     985 </span>            :     
<span class="lineNum">     986 </span>            : }   // end of KernCollider::mergeSlot
<span class="lineNum">     987 </span>            : 
<a name="988"><span class="lineNum">     988 </span>            : </a>
<span class="lineNum">     989 </span>            : // Return the amount to kern by.
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : Position KernCollider::resolve(GR_MAYBE_UNUSED Segment *seg, GR_MAYBE_UNUSED Slot *slot,</span>
<span class="lineNum">     991 </span>            :         int dir, GR_MAYBE_UNUSED json * const dbgout)
<span class="lineNum">     992 </span>            : {
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     float resultNeeded = (1 - 2 * (dir &amp; 1)) * _mingap;</span>
<span class="lineNum">     994 </span>            :     // float resultNeeded = (1 - 2 * (dir &amp; 1)) * (_mingap - margin);
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     float result = min(_limit.tr.x - _offsetPrev.x, max(resultNeeded, _limit.bl.x - _offsetPrev.x));</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : #if !defined GRAPHITE2_NTRACING
<span class="lineNum">     998 </span>            :     if (dbgout)
<span class="lineNum">     999 </span>            :     {
<span class="lineNum">    1000 </span>            :         *dbgout &lt;&lt; json::object // slot
<span class="lineNum">    1001 </span>            :                 &lt;&lt; &quot;slot&quot; &lt;&lt; objectid(dslot(seg, _target))
<span class="lineNum">    1002 </span>            :                                 &lt;&lt; &quot;gid&quot; &lt;&lt; _target-&gt;gid()
<span class="lineNum">    1003 </span>            :                 &lt;&lt; &quot;limit&quot; &lt;&lt; _limit
<span class="lineNum">    1004 </span>            :                 &lt;&lt; &quot;miny&quot; &lt;&lt; _miny
<span class="lineNum">    1005 </span>            :                 &lt;&lt; &quot;maxy&quot; &lt;&lt; _maxy
<span class="lineNum">    1006 </span>            :                 &lt;&lt; &quot;slicewidth&quot; &lt;&lt; _sliceWidth
<span class="lineNum">    1007 </span>            :                 &lt;&lt; &quot;target&quot; &lt;&lt; json::object
<span class="lineNum">    1008 </span>            :                     &lt;&lt; &quot;origin&quot; &lt;&lt; _target-&gt;origin()
<span class="lineNum">    1009 </span>            :                     //&lt;&lt; &quot;currShift&quot; &lt;&lt; _currShift
<span class="lineNum">    1010 </span>            :                     &lt;&lt; &quot;offsetPrev&quot; &lt;&lt; _offsetPrev
<span class="lineNum">    1011 </span>            :                     &lt;&lt; &quot;bbox&quot; &lt;&lt; seg-&gt;theGlyphBBoxTemporary(_target-&gt;gid())
<span class="lineNum">    1012 </span>            :                     &lt;&lt; &quot;slantBox&quot; &lt;&lt; seg-&gt;getFace()-&gt;glyphs().slant(_target-&gt;gid())
<span class="lineNum">    1013 </span>            :                     &lt;&lt; &quot;fix&quot; &lt;&lt; &quot;kern&quot;
<span class="lineNum">    1014 </span>            :                     &lt;&lt; json::close; // target object
<span class="lineNum">    1015 </span>            :         
<span class="lineNum">    1016 </span>            :         *dbgout &lt;&lt; &quot;slices&quot; &lt;&lt; json::array;
<span class="lineNum">    1017 </span>            :         for (int is = 0; is &lt; (int)_edges.size(); is++)
<span class="lineNum">    1018 </span>            :         {
<span class="lineNum">    1019 </span>            :             *dbgout &lt;&lt; json::flat &lt;&lt; json::object 
<span class="lineNum">    1020 </span>            :                 &lt;&lt; &quot;i&quot; &lt;&lt; is 
<span class="lineNum">    1021 </span>            :                 &lt;&lt; &quot;targetEdge&quot; &lt;&lt; _edges[is]
<span class="lineNum">    1022 </span>            :                 &lt;&lt; &quot;neighbor&quot; &lt;&lt; objectid(dslot(seg, _slotNear[is]))
<span class="lineNum">    1023 </span>            :                 &lt;&lt; &quot;nearEdge&quot; &lt;&lt; _nearEdges[is] 
<span class="lineNum">    1024 </span>            :                 &lt;&lt; json::close;
<span class="lineNum">    1025 </span>            :         }
<span class="lineNum">    1026 </span>            :         *dbgout &lt;&lt; json::close; // slices array
<span class="lineNum">    1027 </span>            :             
<span class="lineNum">    1028 </span>            :         *dbgout
<span class="lineNum">    1029 </span>            :             &lt;&lt; &quot;xbound&quot; &lt;&lt; _xbound
<span class="lineNum">    1030 </span>            :             &lt;&lt; &quot;minGap&quot; &lt;&lt; _mingap
<span class="lineNum">    1031 </span>            :             &lt;&lt; &quot;needed&quot; &lt;&lt; resultNeeded
<span class="lineNum">    1032 </span>            :             &lt;&lt; &quot;result&quot; &lt;&lt; result
<span class="lineNum">    1033 </span>            :             &lt;&lt; &quot;stillBad&quot; &lt;&lt; (result != resultNeeded)
<span class="lineNum">    1034 </span>            :             &lt;&lt; json::close; // slot object
<span class="lineNum">    1035 </span>            :     }
<span class="lineNum">    1036 </span>            : #endif
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     return Position(result, 0.);</span>
<span class="lineNum">    1039 </span>            :     
<a name="1040"><span class="lineNum">    1040 </span>            : }   // end of KernCollider::resolve</a>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 : void KernCollider::shift(const Position &amp;mv, int dir)</span>
<span class="lineNum">    1043 </span>            : {
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     for (Vector&lt;float&gt;::iterator e = _edges.begin(); e != _edges.end(); ++e)</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         *e += mv.x;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     _xbound += (1 - 2 * (dir &amp; 1)) * mv.x;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            : ////    SLOT-COLLISION    ////
<a name="1050"><span class="lineNum">    1050 </span>            : </a>
<span class="lineNum">    1051 </span>            : // Initialize the collision attributes for the given slot.
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 : SlotCollision::SlotCollision(Segment *seg, Slot *slot)</span>
<span class="lineNum">    1053 </span>            : {
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     initFromSlot(seg, slot);</span>
<a name="1055"><span class="lineNum">    1055 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 : void SlotCollision::initFromSlot(Segment *seg, Slot *slot)</span>
<span class="lineNum">    1058 </span>            : {
<span class="lineNum">    1059 </span>            :     // Initialize slot attributes from glyph attributes.
<span class="lineNum">    1060 </span>            :         // The order here must match the order in the grcompiler code, 
<span class="lineNum">    1061 </span>            :         // GrcSymbolTable::AssignInternalGlyphAttrIDs.
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     uint16 gid = slot-&gt;gid();</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     uint16 aCol = seg-&gt;silf()-&gt;aCollision(); // flags attr ID</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     const GlyphFace * glyphFace = seg-&gt;getFace()-&gt;glyphs().glyphSafe(gid);</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     if (!glyphFace)</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     const sparse &amp;p = glyphFace-&gt;attrs();</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     _flags = p[aCol];</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     _limit = Rect(Position(p[aCol+1], p[aCol+2]),</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                   Position(p[aCol+3], p[aCol+4]));</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     _margin = p[aCol+5];</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     _marginWt = p[aCol+6];</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     _seqClass = p[aCol+7];</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         _seqProxClass = p[aCol+8];</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     _seqOrder = p[aCol+9];</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         _seqAboveXoff = p[aCol+10];</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         _seqAboveWt = p[aCol+11];</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         _seqBelowXlim = p[aCol+12];</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :         _seqBelowWt = p[aCol+13];</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         _seqValignHt = p[aCol+14];</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         _seqValignWt = p[aCol+15];    </span>
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :     // These attributes do not have corresponding glyph attribute:
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     _exclGlyph = 0;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     _exclOffset = Position(0, 0);</span>
<a name="1087"><span class="lineNum">    1087 </span>            : }</a>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 : float SlotCollision::getKern(int dir) const</span>
<span class="lineNum">    1090 </span>            : {
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     if ((_flags &amp; SlotCollision::COLL_KERN) != 0)</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         return float(_shift.x * ((dir &amp; 1) ? -1 : 1));</span>
<span class="lineNum">    1093 </span>            :     else
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1095"><span class="lineNum">    1095 </span>            : }</a>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 : bool SlotCollision::ignore() const</span>
<span class="lineNum">    1098 </span>            : {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         return ((flags() &amp; SlotCollision::COLL_IGNORE) || (flags() &amp; SlotCollision::COLL_ISSPACE));</span>
<span class="lineNum">    1100 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

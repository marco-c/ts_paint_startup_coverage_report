<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/graphite2/src/TtfUtil.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gfx/graphite2/src</a> - TtfUtil.cpp<span style="font-size: 80%;"> (source / <a href="TtfUtil.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">335</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*  GRAPHITE2 LICENSING</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :     Copyright 2010, SIL International
<span class="lineNum">       4 </span>            :     All rights reserved.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :     This library is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            :     it under the terms of the GNU Lesser General Public License as published
<span class="lineNum">       8 </span>            :     by the Free Software Foundation; either version 2.1 of License, or
<span class="lineNum">       9 </span>            :     (at your option) any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            :     This program is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            :     but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            :     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
<span class="lineNum">      14 </span>            :     Lesser General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :     You should also have received a copy of the GNU Lesser General Public
<span class="lineNum">      17 </span>            :     License along with this library in the file named &quot;LICENSE&quot;.
<span class="lineNum">      18 </span>            :     If not, write to the Free Software Foundation, 51 Franklin Street, 
<span class="lineNum">      19 </span>            :     Suite 500, Boston, MA 02110-1335, USA or visit their web page on the 
<span class="lineNum">      20 </span>            :     internet at http://www.fsf.org/licenses/lgpl.html.
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : Alternatively, the contents of this file may be used under the terms of the
<span class="lineNum">      23 </span>            : Mozilla Public License (http://mozilla.org/MPL) or the GNU General Public
<span class="lineNum">      24 </span>            : License, as published by the Free Software Foundation, either version 2
<span class="lineNum">      25 </span>            : of the License or (at your option) any later version.
<span class="lineNum">      26 </span>            : */
<span class="lineNum">      27 </span>            : /*--------------------------------------------------------------------*//*:Ignore this sentence.
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : File: TtfUtil.cpp
<span class="lineNum">      30 </span>            : Responsibility: Alan Ward
<span class="lineNum">      31 </span>            : Last reviewed: Not yet.
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : Description
<span class="lineNum">      34 </span>            :     Implements the methods for TtfUtil class. This file should remain portable to any C++ 
<span class="lineNum">      35 </span>            :     environment by only using standard C++ and the TTF structurs defined in Tt.h.
<span class="lineNum">      36 </span>            : -------------------------------------------------------------------------------*//*:End Ignore*/
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /***********************************************************************************************
<span class="lineNum">      40 </span>            :     Include files
<span class="lineNum">      41 </span>            : ***********************************************************************************************/
<span class="lineNum">      42 </span>            : // Language headers
<span class="lineNum">      43 </span>            : //#include &lt;algorithm&gt;
<span class="lineNum">      44 </span>            : #include &lt;cassert&gt;
<span class="lineNum">      45 </span>            : #include &lt;cstddef&gt;
<span class="lineNum">      46 </span>            : #include &lt;cstring&gt;
<span class="lineNum">      47 </span>            : #include &lt;climits&gt;
<span class="lineNum">      48 </span>            : #include &lt;cwchar&gt;
<span class="lineNum">      49 </span>            : //#include &lt;stdexcept&gt;
<span class="lineNum">      50 </span>            : // Platform headers
<span class="lineNum">      51 </span>            : // Module headers
<span class="lineNum">      52 </span>            : #include &quot;inc/TtfUtil.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;inc/TtfTypes.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;inc/Endian.h&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /***********************************************************************************************
<span class="lineNum">      57 </span>            :     Forward declarations
<span class="lineNum">      58 </span>            : ***********************************************************************************************/
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /***********************************************************************************************
<span class="lineNum">      61 </span>            :     Local Constants and static variables
<span class="lineNum">      62 </span>            : ***********************************************************************************************/
<span class="lineNum">      63 </span>            : namespace 
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">      66 </span>            :     // max number of components allowed in composite glyphs
<span class="lineNum">      67 </span>            :     const int kMaxGlyphComponents = 8;
<span class="lineNum">      68 </span>            : #endif
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :     template &lt;int R, typename T&gt;
<span class="lineNum">      71 </span>            :     inline float fixed_to_float(const T f) {
<span class="lineNum">      72 </span>            :         return float(f)/float(2^R);
<span class="lineNum">      73 </span>            :     }
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">      76 </span>            :     Table of standard Postscript glyph names. From Martin Hosken. Disagress with ttfdump.exe
<span class="lineNum">      77 </span>            : ---------------------------------------------------------------------------------------------*/
<span class="lineNum">      78 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">      79 </span>            :     const int kcPostNames = 258;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :     const char * rgPostName[kcPostNames] = {
<span class="lineNum">      82 </span>            :         &quot;.notdef&quot;, &quot;.null&quot;, &quot;nonmarkingreturn&quot;, &quot;space&quot;, &quot;exclam&quot;, &quot;quotedbl&quot;, &quot;numbersign&quot;, 
<span class="lineNum">      83 </span>            :         &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;, &quot;quotesingle&quot;, &quot;parenleft&quot;, 
<span class="lineNum">      84 </span>            :         &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;, &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, 
<span class="lineNum">      85 </span>            :         &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, 
<span class="lineNum">      86 </span>            :         &quot;nine&quot;, &quot;colon&quot;, &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;, 
<span class="lineNum">      87 </span>            :         &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, 
<span class="lineNum">      88 </span>            :         &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, 
<span class="lineNum">      89 </span>            :         &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;, &quot;asciicircum&quot;, 
<span class="lineNum">      90 </span>            :         &quot;underscore&quot;, &quot;grave&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, 
<span class="lineNum">      91 </span>            :         &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, 
<span class="lineNum">      92 </span>            :         &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;, &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, 
<span class="lineNum">      93 </span>            :         &quot;Adieresis&quot;, &quot;Aring&quot;, &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ntilde&quot;, &quot;Odieresis&quot;, 
<span class="lineNum">      94 </span>            :         &quot;Udieresis&quot;, &quot;aacute&quot;, &quot;agrave&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;atilde&quot;, 
<span class="lineNum">      95 </span>            :         &quot;aring&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;egrave&quot;, &quot;ecircumflex&quot;, &quot;edieresis&quot;, 
<span class="lineNum">      96 </span>            :         &quot;iacute&quot;, &quot;igrave&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;, &quot;ntilde&quot;, &quot;oacute&quot;, 
<span class="lineNum">      97 </span>            :         &quot;ograve&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;, &quot;otilde&quot;, &quot;uacute&quot;, &quot;ugrave&quot;, 
<span class="lineNum">      98 </span>            :         &quot;ucircumflex&quot;, &quot;udieresis&quot;, &quot;dagger&quot;, &quot;degree&quot;, &quot;cent&quot;, &quot;sterling&quot;, 
<span class="lineNum">      99 </span>            :         &quot;section&quot;, &quot;bullet&quot;, &quot;paragraph&quot;, &quot;germandbls&quot;, &quot;registered&quot;, 
<span class="lineNum">     100 </span>            :         &quot;copyright&quot;, &quot;trademark&quot;, &quot;acute&quot;, &quot;dieresis&quot;, &quot;notequal&quot;, &quot;AE&quot;, 
<span class="lineNum">     101 </span>            :         &quot;Oslash&quot;, &quot;infinity&quot;, &quot;plusminus&quot;, &quot;lessequal&quot;, &quot;greaterequal&quot;, &quot;yen&quot;, 
<span class="lineNum">     102 </span>            :         &quot;mu&quot;, &quot;partialdiff&quot;, &quot;summation&quot;, &quot;product&quot;, &quot;pi&quot;, &quot;integral&quot;, 
<span class="lineNum">     103 </span>            :         &quot;ordfeminine&quot;, &quot;ordmasculine&quot;, &quot;Omega&quot;, &quot;ae&quot;, &quot;oslash&quot;, &quot;questiondown&quot;, 
<span class="lineNum">     104 </span>            :         &quot;exclamdown&quot;, &quot;logicalnot&quot;, &quot;radical&quot;, &quot;florin&quot;, &quot;approxequal&quot;, 
<span class="lineNum">     105 </span>            :         &quot;Delta&quot;, &quot;guillemotleft&quot;, &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;nonbreakingspace&quot;, 
<span class="lineNum">     106 </span>            :         &quot;Agrave&quot;, &quot;Atilde&quot;, &quot;Otilde&quot;, &quot;OE&quot;, &quot;oe&quot;, &quot;endash&quot;, &quot;emdash&quot;, 
<span class="lineNum">     107 </span>            :         &quot;quotedblleft&quot;, &quot;quotedblright&quot;, &quot;quoteleft&quot;, &quot;quoteright&quot;, &quot;divide&quot;, 
<span class="lineNum">     108 </span>            :         &quot;lozenge&quot;, &quot;ydieresis&quot;, &quot;Ydieresis&quot;, &quot;fraction&quot;, &quot;currency&quot;, 
<span class="lineNum">     109 </span>            :         &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;daggerdbl&quot;, &quot;periodcentered&quot;, 
<span class="lineNum">     110 </span>            :         &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;perthousand&quot;, &quot;Acircumflex&quot;, 
<span class="lineNum">     111 </span>            :         &quot;Ecircumflex&quot;, &quot;Aacute&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;, 
<span class="lineNum">     112 </span>            :         &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;, 
<span class="lineNum">     113 </span>            :         &quot;apple&quot;, &quot;Ograve&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Ugrave&quot;, &quot;dotlessi&quot;, 
<span class="lineNum">     114 </span>            :         &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;, &quot;dotaccent&quot;, &quot;ring&quot;, 
<span class="lineNum">     115 </span>            :         &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;, &quot;caron&quot;, &quot;Lslash&quot;, &quot;lslash&quot;, 
<span class="lineNum">     116 </span>            :         &quot;Scaron&quot;, &quot;scaron&quot;, &quot;Zcaron&quot;, &quot;zcaron&quot;, &quot;brokenbar&quot;, &quot;Eth&quot;, &quot;eth&quot;, 
<span class="lineNum">     117 </span>            :         &quot;Yacute&quot;, &quot;yacute&quot;, &quot;Thorn&quot;, &quot;thorn&quot;, &quot;minus&quot;, &quot;multiply&quot;, 
<span class="lineNum">     118 </span>            :         &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;onehalf&quot;, &quot;onequarter&quot;, 
<span class="lineNum">     119 </span>            :         &quot;threequarters&quot;, &quot;franc&quot;, &quot;Gbreve&quot;, &quot;gbreve&quot;, &quot;Idotaccent&quot;, &quot;Scedilla&quot;, 
<span class="lineNum">     120 </span>            :         &quot;scedilla&quot;, &quot;Cacute&quot;, &quot;cacute&quot;, &quot;Ccaron&quot;, &quot;ccaron&quot;, 
<span class="lineNum">     121 </span>            :         &quot;dcroat&quot; };
<span class="lineNum">     122 </span>            : #endif
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : } // end of namespace
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : /***********************************************************************************************
<span class="lineNum">     127 </span>            :     Methods
<span class="lineNum">     128 </span>            : ***********************************************************************************************/
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /* Note on error processing: The code guards against bad glyph ids being used to look up data
<span class="lineNum">     131 </span>            : in open ended tables (loca, hmtx). If the glyph id comes from a cmap this shouldn't happen 
<span class="lineNum">     132 </span>            : but it seems prudent to check for user errors here. The code does assume that data obtained 
<span class="lineNum">     133 </span>            : from the TTF file is valid otherwise (though the CheckTable method seeks to check for 
<span class="lineNum">     134 </span>            : obvious problems that might accompany a change in table versions). For example an invalid 
<span class="lineNum">     135 </span>            : offset in the loca table which could exceed the size of the glyf table is NOT trapped.
<span class="lineNum">     136 </span>            : Likewise if numberOf_LongHorMetrics in the hhea table is wrong, this will NOT be trapped, 
<span class="lineNum">     137 </span>            : which could cause a lookup in the hmtx table to exceed the table length. Of course, TTF tables
<span class="lineNum">     138 </span>            : that are completely corrupt will cause unpredictable results. */
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /* Note on composite glyphs: Glyphs that have components that are themselves composites
<span class="lineNum">     141 </span>            : are not supported. IsDeepComposite can be used to test for this. False is returned from many 
<span class="lineNum">     142 </span>            : of the methods in this cases. It is unclear how to build composite glyphs in some cases, 
<span class="lineNum">     143 </span>            : so this code represents my best guess until test cases can be found. See notes on the high-
<span class="lineNum">     144 </span>            : level GlyfPoints method. */
<span class="lineNum">     145 </span>            : namespace graphite2
<span class="lineNum">     146 </span>            : {
<span class="lineNum">     147 </span>            : namespace TtfUtil
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     152 </span>            :     Get offset and size of the offset table needed to find table directory.
<span class="lineNum">     153 </span>            :     Return true if success, false otherwise.
<a name="154"><span class="lineNum">     154 </span>            :     lSize excludes any table directory entries.</a>
<span class="lineNum">     155 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : bool GetHeaderInfo(size_t &amp; lOffset, size_t &amp; lSize)</span>
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     lOffset = 0;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     lSize   = offsetof(Sfnt::OffsetSubTable, table_directory);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     assert(sizeof(uint32) + 4*sizeof (uint16) == lSize);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     162 </span>            : }
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     165 </span>            :     Check the offset table for expected data.
<a name="166"><span class="lineNum">     166 </span>            :     Return true if success, false otherwise.</a>
<span class="lineNum">     167 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     168 </span><span class="lineNoCov">          0 : bool CheckHeader(const void * pHdr)</span>
<span class="lineNum">     169 </span>            : {
<span class="lineNum">     170 </span>            :     const Sfnt::OffsetSubTable * pOffsetTable  
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         = reinterpret_cast&lt;const Sfnt::OffsetSubTable *&gt;(pHdr);</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     return pHdr &amp;&amp; be::swap(pOffsetTable-&gt;scaler_type) == Sfnt::OffsetSubTable::TrueTypeWin;</span>
<span class="lineNum">     174 </span>            : }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     177 </span>            :     Get offset and size of the table directory.
<a name="178"><span class="lineNum">     178 </span>            :     Return true if successful, false otherwise.</a>
<span class="lineNum">     179 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : bool GetTableDirInfo(const void * pHdr, size_t &amp; lOffset, size_t &amp; lSize)</span>
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span>            :     const Sfnt::OffsetSubTable * pOffsetTable
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         = reinterpret_cast&lt;const Sfnt::OffsetSubTable *&gt;(pHdr);</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     lOffset = offsetof(Sfnt::OffsetSubTable, table_directory);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     lSize   = be::swap(pOffsetTable-&gt;num_tables)</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         * sizeof(Sfnt::OffsetSubTable::Entry);</span>
<span class="lineNum">     188 </span>            :     
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     190 </span>            : }
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     194 </span>            :     Get offset and size of the specified table.
<a name="195"><span class="lineNum">     195 </span>            :     Return true if successful, false otherwise. On false, offset and size will be 0.</a>
<span class="lineNum">     196 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     197 </span><span class="lineNoCov">          0 : bool GetTableInfo(const Tag TableTag, const void * pHdr, const void * pTableDir,</span>
<span class="lineNum">     198 </span>            :                            size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     199 </span>            : {
<span class="lineNum">     200 </span>            :     const Sfnt::OffsetSubTable * pOffsetTable 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         = reinterpret_cast&lt;const Sfnt::OffsetSubTable *&gt;(pHdr);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     const size_t num_tables = be::swap(pOffsetTable-&gt;num_tables);</span>
<span class="lineNum">     203 </span>            :     const Sfnt::OffsetSubTable::Entry 
<span class="lineNum">     204 </span>            :         * entry_itr = reinterpret_cast&lt;const Sfnt::OffsetSubTable::Entry *&gt;(
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :             pTableDir),</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         * const  dir_end = entry_itr + num_tables;</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     if (num_tables &gt; 40)</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     for (;entry_itr != dir_end; ++entry_itr) // 40 - safe guard</span>
<span class="lineNum">     212 </span>            :     {
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         if (be::swap(entry_itr-&gt;tag) == TableTag)</span>
<span class="lineNum">     214 </span>            :         {
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :             lOffset = be::swap(entry_itr-&gt;offset);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :             lSize   = be::swap(entry_itr-&gt;length);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     218 </span>            :         }
<span class="lineNum">     219 </span>            :     }
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     222 </span>            : }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     225 </span>            :     Check the specified table. Tests depend on the table type.
<a name="226"><span class="lineNum">     226 </span>            :     Return true if successful, false otherwise.</a>
<span class="lineNum">     227 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : bool CheckTable(const Tag TableId, const void * pTable, size_t lTableSize)</span>
<span class="lineNum">     229 </span>            : {
<span class="lineNum">     230 </span>            :     using namespace Sfnt;
<span class="lineNum">     231 </span>            :     
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (pTable == 0 || lTableSize &lt; 4) return false;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     switch(TableId)</span>
<span class="lineNum">     235 </span>            :     {
<span class="lineNum">     236 </span>            :     case Tag::cmap: // cmap
<span class="lineNum">     237 </span>            :     {
<span class="lineNum">     238 </span>            :         const Sfnt::CharacterCodeMap * const pCmap 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :             = reinterpret_cast&lt;const Sfnt::CharacterCodeMap *&gt;(pTable);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::CharacterCodeMap))</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         return be::swap(pCmap-&gt;version) == 0;</span>
<span class="lineNum">     243 </span>            :     }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :     case Tag::head: // head
<span class="lineNum">     246 </span>            :     {
<span class="lineNum">     247 </span>            :         const Sfnt::FontHeader * const pHead 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :             = reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pTable);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::FontHeader))</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         bool r = be::swap(pHead-&gt;version) == OneFix</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :             &amp;&amp; be::swap(pHead-&gt;magic_number) == FontHeader::MagicNumber</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :             &amp;&amp; be::swap(pHead-&gt;glyph_data_format)</span>
<span class="lineNum">     254 </span>            :                     == FontHeader::GlypDataFormat 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             &amp;&amp; (be::swap(pHead-&gt;index_to_loc_format)</span>
<span class="lineNum">     256 </span>            :                     == FontHeader::ShortIndexLocFormat 
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                 || be::swap(pHead-&gt;index_to_loc_format)</span>
<span class="lineNum">     258 </span>            :                     == FontHeader::LongIndexLocFormat) 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :             &amp;&amp; sizeof(FontHeader) &lt;= lTableSize;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         return r;</span>
<span class="lineNum">     261 </span>            :     }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :     case Tag::post: // post
<span class="lineNum">     264 </span>            :     {
<span class="lineNum">     265 </span>            :         const Sfnt::PostScriptGlyphName * const pPost 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             = reinterpret_cast&lt;const Sfnt::PostScriptGlyphName *&gt;(pTable);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::PostScriptGlyphName))</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         const fixed format = be::swap(pPost-&gt;format);</span>
<span class="lineNum">     270 </span>            :         bool r = format == PostScriptGlyphName::Format1 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :             || format == PostScriptGlyphName::Format2 </span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :             || format == PostScriptGlyphName::Format3 </span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :             || format == PostScriptGlyphName::Format25;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         return r;</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     case Tag::hhea: // hhea
<span class="lineNum">     278 </span>            :     {
<span class="lineNum">     279 </span>            :         const Sfnt::HorizontalHeader * pHhea = 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             reinterpret_cast&lt;const Sfnt::HorizontalHeader *&gt;(pTable);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::HorizontalHeader))</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         bool r = be::swap(pHhea-&gt;version) == OneFix</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :             &amp;&amp; be::swap(pHhea-&gt;metric_data_format) == 0</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :             &amp;&amp; sizeof (Sfnt::HorizontalHeader) &lt;= lTableSize;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         return r;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :     case Tag::maxp: // maxp
<span class="lineNum">     290 </span>            :     {
<span class="lineNum">     291 </span>            :         const Sfnt::MaximumProfile * pMaxp = 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :             reinterpret_cast&lt;const Sfnt::MaximumProfile *&gt;(pTable);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::MaximumProfile))</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         bool r = be::swap(pMaxp-&gt;version) == OneFix</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             &amp;&amp; sizeof(Sfnt::MaximumProfile) &lt;= lTableSize;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         return r;</span>
<span class="lineNum">     298 </span>            :     }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :     case Tag::OS_2: // OS/2
<span class="lineNum">     301 </span>            :     {
<span class="lineNum">     302 </span>            :         const Sfnt::Compatibility * pOs2 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :             = reinterpret_cast&lt;const Sfnt::Compatibility *&gt;(pTable);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         if (be::swap(pOs2-&gt;version) == 0)</span>
<span class="lineNum">     305 </span>            :         { // OS/2 table version 1 size
<span class="lineNum">     306 </span>            : //          if (sizeof(Sfnt::Compatibility) 
<span class="lineNum">     307 </span>            : //                  - sizeof(uint32)*2 - sizeof(int16)*2 
<span class="lineNum">     308 </span>            : //                  - sizeof(uint16)*3 &lt;= lTableSize)
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :             if (sizeof(Sfnt::Compatibility0) &lt;= lTableSize)</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     311 </span>            :         }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         else if (be::swap(pOs2-&gt;version) == 1)</span>
<span class="lineNum">     313 </span>            :         { // OS/2 table version 2 size
<span class="lineNum">     314 </span>            : //          if (sizeof(Sfnt::Compatibility) 
<span class="lineNum">     315 </span>            : //                  - sizeof(int16) *2 
<span class="lineNum">     316 </span>            : //                  - sizeof(uint16)*3 &lt;= lTableSize)
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :             if (sizeof(Sfnt::Compatibility1) &lt;= lTableSize)</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     319 </span>            :         }
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         else if (be::swap(pOs2-&gt;version) == 2)</span>
<span class="lineNum">     321 </span>            :         { // OS/2 table version 3 size
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :             if (sizeof(Sfnt::Compatibility2) &lt;= lTableSize)</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     324 </span>            :         }
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         else if (be::swap(pOs2-&gt;version) == 3 || be::swap(pOs2-&gt;version) == 4)</span>
<span class="lineNum">     326 </span>            :         { // OS/2 table version 4 size - version 4 changed the meaning of some fields which we don't use
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :             if (sizeof(Sfnt::Compatibility3) &lt;= lTableSize)</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     329 </span>            :         }
<span class="lineNum">     330 </span>            :         else
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     333 </span>            :     }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     case Tag::name:
<span class="lineNum">     336 </span>            :     {
<span class="lineNum">     337 </span>            :         const Sfnt::FontNames * pName 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :             = reinterpret_cast&lt;const Sfnt::FontNames *&gt;(pTable);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         if (lTableSize &lt; sizeof(Sfnt::FontNames))</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         return be::swap(pName-&gt;format) == 0;</span>
<span class="lineNum">     342 </span>            :     }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :     default:
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     346 </span>            :     }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     352 </span>            :     Return the number of glyphs in the font. Should never be less than zero.
<span class="lineNum">     353 </span>            : 
<a name="354"><span class="lineNum">     354 </span>            :     Note: this method is not currently used by the Graphite engine.</a>
<span class="lineNum">     355 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : size_t GlyphCount(const void * pMaxp)</span>
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span>            :     const Sfnt::MaximumProfile * pTable = 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             reinterpret_cast&lt;const Sfnt::MaximumProfile *&gt;(pMaxp);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     return be::swap(pTable-&gt;num_glyphs);</span>
<span class="lineNum">     361 </span>            : }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">     364 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     365 </span>            :     Return the maximum number of components for any composite glyph in the font.
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     368 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     369 </span>            : size_t  MaxCompositeComponentCount(const void * pMaxp)
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span>            :     const Sfnt::MaximumProfile * pTable = 
<span class="lineNum">     372 </span>            :             reinterpret_cast&lt;const Sfnt::MaximumProfile *&gt;(pMaxp);
<span class="lineNum">     373 </span>            :     return be::swap(pTable-&gt;max_component_elements);
<span class="lineNum">     374 </span>            : }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     377 </span>            :     Composite glyphs can be composed of glyphs that are themselves composites.
<span class="lineNum">     378 </span>            :     This method returns the maximum number of levels like this for any glyph in the font.
<span class="lineNum">     379 </span>            :     A non-composite glyph has a level of 1.
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     382 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     383 </span>            : size_t  MaxCompositeLevelCount(const void * pMaxp)
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span>            :     const Sfnt::MaximumProfile * pTable = 
<span class="lineNum">     386 </span>            :             reinterpret_cast&lt;const Sfnt::MaximumProfile *&gt;(pMaxp);
<span class="lineNum">     387 </span>            :     return be::swap(pTable-&gt;max_component_depth);
<span class="lineNum">     388 </span>            : }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     391 </span>            :     Return the number of glyphs in the font according to a differt source.
<span class="lineNum">     392 </span>            :     Should never be less than zero. Return -1 on failure.
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     395 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     396 </span>            : size_t LocaGlyphCount(size_t lLocaSize, const void * pHead) //throw(std::domain_error)
<span class="lineNum">     397 </span>            : {
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     const Sfnt::FontHeader * pTable 
<span class="lineNum">     400 </span>            :         = reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     if (be::swap(pTable-&gt;index_to_loc_format)
<span class="lineNum">     403 </span>            :         == Sfnt::FontHeader::ShortIndexLocFormat)
<span class="lineNum">     404 </span>            :     // loca entries are two bytes and have been divided by two
<span class="lineNum">     405 </span>            :         return (lLocaSize &gt;&gt; 1) - 1;
<span class="lineNum">     406 </span>            :     
<span class="lineNum">     407 </span>            :     if (be::swap(pTable-&gt;index_to_loc_format)
<span class="lineNum">     408 </span>            :         == Sfnt::FontHeader::LongIndexLocFormat)
<span class="lineNum">     409 </span>            :      // loca entries are four bytes
<span class="lineNum">     410 </span>            :         return (lLocaSize &gt;&gt; 2) - 1;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :     return -1;
<span class="lineNum">     413 </span>            :     //throw std::domain_error(&quot;head table in inconsistent state. The font may be corrupted&quot;);
<span class="lineNum">     414 </span>            : }
<span class="lineNum">     415 </span>            : #endif
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : /*----------------------------------------------------------------------------------------------
<a name="418"><span class="lineNum">     418 </span>            :     Return the design units the font is designed with</a>
<span class="lineNum">     419 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : int DesignUnits(const void * pHead)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :     const Sfnt::FontHeader * pTable = 
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :             reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);</span>
<span class="lineNum">     424 </span>            :     
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     return be::swap(pTable-&gt;units_per_em);</span>
<span class="lineNum">     426 </span>            : }
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">     429 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     430 </span>            :     Return the checksum from the head table, which serves as a unique identifer for the font.
<span class="lineNum">     431 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     432 </span>            : int HeadTableCheckSum(const void * pHead)
<span class="lineNum">     433 </span>            : {
<span class="lineNum">     434 </span>            :     const Sfnt::FontHeader * pTable = 
<span class="lineNum">     435 </span>            :             reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);
<span class="lineNum">     436 </span>            :     
<span class="lineNum">     437 </span>            :     return be::swap(pTable-&gt;check_sum_adjustment);
<span class="lineNum">     438 </span>            : }
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     441 </span>            :     Return the create time from the head table. This consists of a 64-bit integer, which
<span class="lineNum">     442 </span>            :     we return here as two 32-bit integers.
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     445 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     446 </span>            : void HeadTableCreateTime(const void * pHead,
<span class="lineNum">     447 </span>            :     unsigned int * pnDateBC, unsigned int * pnDateAD)
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span>            :     const Sfnt::FontHeader * pTable = 
<span class="lineNum">     450 </span>            :             reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);
<span class="lineNum">     451 </span>            :     
<span class="lineNum">     452 </span>            :     *pnDateBC = be::swap(pTable-&gt;created[0]);
<span class="lineNum">     453 </span>            :     *pnDateAD = be::swap(pTable-&gt;created[1]);
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     457 </span>            :     Return the modify time from the head table.This consists of a 64-bit integer, which
<span class="lineNum">     458 </span>            :     we return here as two 32-bit integers.
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     461 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     462 </span>            : void HeadTableModifyTime(const void * pHead,
<span class="lineNum">     463 </span>            :     unsigned int * pnDateBC, unsigned int *pnDateAD)
<span class="lineNum">     464 </span>            : {
<span class="lineNum">     465 </span>            :     const Sfnt::FontHeader * pTable = 
<span class="lineNum">     466 </span>            :             reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);
<span class="lineNum">     467 </span>            :     
<span class="lineNum">     468 </span>            :     *pnDateBC = be::swap(pTable-&gt;modified[0]);
<span class="lineNum">     469 </span>            :     *pnDateAD = be::swap(pTable-&gt;modified[1]);
<span class="lineNum">     470 </span>            : }
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     473 </span>            :     Return true if the font is italic.
<span class="lineNum">     474 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     475 </span>            : bool IsItalic(const void * pHead)
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span>            :     const Sfnt::FontHeader * pTable = 
<span class="lineNum">     478 </span>            :             reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     return ((be::swap(pTable-&gt;mac_style) &amp; 0x00000002) != 0);
<span class="lineNum">     481 </span>            : }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     484 </span>            :     Return the ascent for the font
<span class="lineNum">     485 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     486 </span>            : int FontAscent(const void * pOs2)
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span>            :     const Sfnt::Compatibility * pTable = reinterpret_cast&lt;const Sfnt::Compatibility *&gt;(pOs2);
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :     return be::swap(pTable-&gt;win_ascent);
<span class="lineNum">     491 </span>            : }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     494 </span>            :     Return the descent for the font
<span class="lineNum">     495 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     496 </span>            : int FontDescent(const void * pOs2)
<span class="lineNum">     497 </span>            : {
<span class="lineNum">     498 </span>            :     const Sfnt::Compatibility * pTable = reinterpret_cast&lt;const Sfnt::Compatibility *&gt;(pOs2);
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :     return be::swap(pTable-&gt;win_descent);
<span class="lineNum">     501 </span>            : }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     504 </span>            :     Get the bold and italic style bits.
<span class="lineNum">     505 </span>            :     Return true if successful. false otherwise.
<span class="lineNum">     506 </span>            :     In addition to checking the OS/2 table, one could also check
<span class="lineNum">     507 </span>            :         the head table's macStyle field (overridden by the OS/2 table on Win)
<span class="lineNum">     508 </span>            :         the sub-family name in the name table (though this can contain oblique, dark, etc too)
<span class="lineNum">     509 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     510 </span>            : bool FontOs2Style(const void *pOs2, bool &amp; fBold, bool &amp; fItalic)
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span>            :     const Sfnt::Compatibility * pTable = reinterpret_cast&lt;const Sfnt::Compatibility *&gt;(pOs2);
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     fBold = (be::swap(pTable-&gt;fs_selection) &amp; Sfnt::Compatibility::Bold) != 0;
<span class="lineNum">     515 </span>            :     fItalic = (be::swap(pTable-&gt;fs_selection) &amp; Sfnt::Compatibility::Italic) != 0;
<span class="lineNum">     516 </span>            :     
<span class="lineNum">     517 </span>            :     return true;
<span class="lineNum">     518 </span>            : }
<span class="lineNum">     519 </span>            : #endif
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : /*----------------------------------------------------------------------------------------------
<a name="522"><span class="lineNum">     522 </span>            :     Method for searching name table.</a>
<span class="lineNum">     523 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     524 </span><span class="lineNoCov">          0 : bool GetNameInfo(const void * pName, int nPlatformId, int nEncodingId,</span>
<span class="lineNum">     525 </span>            :         int nLangId, int nNameId, size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     lOffset = 0;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     lSize = 0;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     const Sfnt::FontNames * pTable = reinterpret_cast&lt;const Sfnt::FontNames *&gt;(pName);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     uint16 cRecord = be::swap(pTable-&gt;count);</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     uint16 nRecordOffset = be::swap(pTable-&gt;string_offset);</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     const Sfnt::NameRecord * pRecord = reinterpret_cast&lt;const Sfnt::NameRecord *&gt;(pTable + 1);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; cRecord; ++i)</span>
<span class="lineNum">     536 </span>            :     {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         if (be::swap(pRecord-&gt;platform_id) == nPlatformId &amp;&amp;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :             be::swap(pRecord-&gt;platform_specific_id) == nEncodingId &amp;&amp;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :             be::swap(pRecord-&gt;language_id) == nLangId &amp;&amp;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :             be::swap(pRecord-&gt;name_id) == nNameId)</span>
<span class="lineNum">     541 </span>            :         {
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :             lOffset = be::swap(pRecord-&gt;offset) + nRecordOffset;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :             lSize = be::swap(pRecord-&gt;length);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     545 </span>            :         }
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         pRecord++;</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     550 </span>            : }
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">     553 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     554 </span>            :     Return all the lang-IDs that have data for the given name-IDs. Assume that there is room
<span class="lineNum">     555 </span>            :     in the return array (langIdList) for 128 items. The purpose of this method is to return
<span class="lineNum">     556 </span>            :     a list of all possible lang-IDs.
<span class="lineNum">     557 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     558 </span>            : int GetLangsForNames(const void * pName, int nPlatformId, int nEncodingId,
<span class="lineNum">     559 </span>            :         int * nameIdList, int cNameIds, short * langIdList)
<span class="lineNum">     560 </span>            : {
<span class="lineNum">     561 </span>            :     const Sfnt::FontNames * pTable = reinterpret_cast&lt;const Sfnt::FontNames *&gt;(pName);
<span class="lineNum">     562 </span>            :         int cLangIds = 0;
<span class="lineNum">     563 </span>            :     uint16 cRecord = be::swap(pTable-&gt;count);
<span class="lineNum">     564 </span>            :         if (cRecord &gt; 127) return cLangIds;
<span class="lineNum">     565 </span>            :     //uint16 nRecordOffset = swapw(pTable-&gt;stringOffset);
<span class="lineNum">     566 </span>            :     const Sfnt::NameRecord * pRecord = reinterpret_cast&lt;const Sfnt::NameRecord *&gt;(pTable + 1);
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     for (int i = 0; i &lt; cRecord; ++i)
<span class="lineNum">     569 </span>            :     {
<span class="lineNum">     570 </span>            :         if (be::swap(pRecord-&gt;platform_id) == nPlatformId &amp;&amp;
<span class="lineNum">     571 </span>            :             be::swap(pRecord-&gt;platform_specific_id) == nEncodingId)
<span class="lineNum">     572 </span>            :         {
<span class="lineNum">     573 </span>            :             bool fNameFound = false;
<span class="lineNum">     574 </span>            :             int nLangId = be::swap(pRecord-&gt;language_id);
<span class="lineNum">     575 </span>            :             int nNameId = be::swap(pRecord-&gt;name_id);
<span class="lineNum">     576 </span>            :             for (int j = 0; j &lt; cNameIds; j++)
<span class="lineNum">     577 </span>            :             {
<span class="lineNum">     578 </span>            :                 if (nNameId == nameIdList[j])
<span class="lineNum">     579 </span>            :                 {
<span class="lineNum">     580 </span>            :                     fNameFound = true;
<span class="lineNum">     581 </span>            :                     break;
<span class="lineNum">     582 </span>            :                 }
<span class="lineNum">     583 </span>            :             }
<span class="lineNum">     584 </span>            :             if (fNameFound)
<span class="lineNum">     585 </span>            :             {
<span class="lineNum">     586 </span>            :                 // Add it if it's not there.
<span class="lineNum">     587 </span>            :                 int ilang;
<span class="lineNum">     588 </span>            :                 for (ilang = 0; ilang &lt; cLangIds; ilang++)
<span class="lineNum">     589 </span>            :                     if (langIdList[ilang] == nLangId)
<span class="lineNum">     590 </span>            :                         break;
<span class="lineNum">     591 </span>            :                 if (ilang &gt;= cLangIds)
<span class="lineNum">     592 </span>            :                 {
<span class="lineNum">     593 </span>            :                     langIdList[cLangIds] = short(nLangId);
<span class="lineNum">     594 </span>            :                     cLangIds++;
<span class="lineNum">     595 </span>            :                 }
<span class="lineNum">     596 </span>            :                 if (cLangIds == 128)
<span class="lineNum">     597 </span>            :                     return cLangIds;
<span class="lineNum">     598 </span>            :             }
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span>            :         pRecord++;
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     return cLangIds;
<span class="lineNum">     604 </span>            : }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     607 </span>            :     Get the offset and size of the font family name in English for the MS Platform with Unicode
<span class="lineNum">     608 </span>            :     writing system. The offset is within the pName data. The string is double byte with MSB
<span class="lineNum">     609 </span>            :     first.
<span class="lineNum">     610 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     611 </span>            : bool Get31EngFamilyInfo(const void * pName, size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     612 </span>            : {
<span class="lineNum">     613 </span>            :     return GetNameInfo(pName, Sfnt::NameRecord::Microsoft, 1, 1033, 
<span class="lineNum">     614 </span>            :         Sfnt::NameRecord::Family, lOffset, lSize);
<span class="lineNum">     615 </span>            : }
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     618 </span>            :     Get the offset and size of the full font name in English for the MS Platform with Unicode
<span class="lineNum">     619 </span>            :     writing system. The offset is within the pName data. The string is double byte with MSB
<span class="lineNum">     620 </span>            :     first.
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     623 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     624 </span>            : bool Get31EngFullFontInfo(const void * pName, size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span>            :     return GetNameInfo(pName, Sfnt::NameRecord::Microsoft, 1, 1033, 
<span class="lineNum">     627 </span>            :         Sfnt::NameRecord::Fullname, lOffset, lSize);
<span class="lineNum">     628 </span>            : }
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     631 </span>            :     Get the offset and size of the font family name in English for the MS Platform with Symbol
<span class="lineNum">     632 </span>            :     writing system. The offset is within the pName data. The string is double byte with MSB
<span class="lineNum">     633 </span>            :     first.
<span class="lineNum">     634 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     635 </span>            : bool Get30EngFamilyInfo(const void * pName, size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     636 </span>            : {
<span class="lineNum">     637 </span>            :     return GetNameInfo(pName, Sfnt::NameRecord::Microsoft, 0, 1033, 
<span class="lineNum">     638 </span>            :         Sfnt::NameRecord::Family, lOffset, lSize);
<span class="lineNum">     639 </span>            : }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     642 </span>            :     Get the offset and size of the full font name in English for the MS Platform with Symbol
<span class="lineNum">     643 </span>            :     writing system. The offset is within the pName data. The string is double byte with MSB
<span class="lineNum">     644 </span>            :     first.
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     647 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     648 </span>            : bool Get30EngFullFontInfo(const void * pName, size_t &amp; lOffset, size_t &amp; lSize)
<span class="lineNum">     649 </span>            : {
<span class="lineNum">     650 </span>            :     return GetNameInfo(pName, Sfnt::NameRecord::Microsoft, 0, 1033, 
<span class="lineNum">     651 </span>            :         Sfnt::NameRecord::Fullname, lOffset, lSize);
<span class="lineNum">     652 </span>            : }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     655 </span>            :     Return the Glyph ID for a given Postscript name. This method finds the first glyph which
<span class="lineNum">     656 </span>            :     matches the requested Postscript name. Ideally every glyph should have a unique Postscript 
<span class="lineNum">     657 </span>            :     name (except for special names such as .notdef), but this is not always true.
<span class="lineNum">     658 </span>            :     On failure return value less than zero.
<span class="lineNum">     659 </span>            :        -1 - table search failed
<span class="lineNum">     660 </span>            :        -2 - format 3 table (no Postscript glyph info)
<span class="lineNum">     661 </span>            :        -3 - other failures
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :     Note: this method is not currently used by the Graphite engine.
<span class="lineNum">     664 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     665 </span>            : int PostLookup(const void * pPost, size_t lPostSize, const void * pMaxp, 
<span class="lineNum">     666 </span>            :                         const char * pPostName)
<span class="lineNum">     667 </span>            : {
<span class="lineNum">     668 </span>            :     using namespace Sfnt;
<span class="lineNum">     669 </span>            :     
<span class="lineNum">     670 </span>            :     const Sfnt::PostScriptGlyphName * pTable 
<span class="lineNum">     671 </span>            :         = reinterpret_cast&lt;const Sfnt::PostScriptGlyphName *&gt;(pPost);
<span class="lineNum">     672 </span>            :     fixed format = be::swap(pTable-&gt;format);
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :     if (format == PostScriptGlyphName::Format3)
<span class="lineNum">     675 </span>            :     { // format 3 - no Postscript glyph info in font
<span class="lineNum">     676 </span>            :         return -2;
<span class="lineNum">     677 </span>            :     }
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :     // search for given Postscript name among the standard names
<span class="lineNum">     680 </span>            :     int iPostName = -1; // index in standard names
<span class="lineNum">     681 </span>            :     for (int i = 0; i &lt; kcPostNames; i++)
<span class="lineNum">     682 </span>            :     {
<span class="lineNum">     683 </span>            :         if (!strcmp(pPostName, rgPostName[i]))
<span class="lineNum">     684 </span>            :         {
<span class="lineNum">     685 </span>            :             iPostName = i;
<span class="lineNum">     686 </span>            :             break;
<span class="lineNum">     687 </span>            :         }
<span class="lineNum">     688 </span>            :     }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :     if (format == PostScriptGlyphName::Format1)
<span class="lineNum">     691 </span>            :     { // format 1 - use standard Postscript names
<span class="lineNum">     692 </span>            :         return iPostName;
<span class="lineNum">     693 </span>            :     }
<span class="lineNum">     694 </span>            :     
<span class="lineNum">     695 </span>            :     if (format == PostScriptGlyphName::Format25)
<span class="lineNum">     696 </span>            :     { 
<span class="lineNum">     697 </span>            :         if (iPostName == -1)
<span class="lineNum">     698 </span>            :             return -1;
<span class="lineNum">     699 </span>            :         
<span class="lineNum">     700 </span>            :         const PostScriptGlyphName25 * pTable25 
<span class="lineNum">     701 </span>            :             = static_cast&lt;const PostScriptGlyphName25 *&gt;(pTable);
<span class="lineNum">     702 </span>            :         int cnGlyphs = GlyphCount(pMaxp);
<span class="lineNum">     703 </span>            :         for (gid16 nGlyphId = 0; nGlyphId &lt; cnGlyphs &amp;&amp; nGlyphId &lt; kcPostNames; 
<span class="lineNum">     704 </span>            :                 nGlyphId++)
<span class="lineNum">     705 </span>            :         { // glyph_name_index25 contains bytes so no byte swapping needed
<span class="lineNum">     706 </span>            :           // search for first glyph id that uses the standard name 
<span class="lineNum">     707 </span>            :             if (nGlyphId + pTable25-&gt;offset[nGlyphId] == iPostName)
<span class="lineNum">     708 </span>            :                 return nGlyphId;
<span class="lineNum">     709 </span>            :         }
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :     if (format == PostScriptGlyphName::Format2)
<span class="lineNum">     713 </span>            :     { // format 2
<span class="lineNum">     714 </span>            :         const PostScriptGlyphName2 * pTable2 
<span class="lineNum">     715 </span>            :             = static_cast&lt;const PostScriptGlyphName2 *&gt;(pTable);
<span class="lineNum">     716 </span>            :         
<span class="lineNum">     717 </span>            :         int cnGlyphs = be::swap(pTable2-&gt;number_of_glyphs);
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :         if (iPostName != -1)
<span class="lineNum">     720 </span>            :         { // did match a standard name, look for first glyph id mapped to that name
<span class="lineNum">     721 </span>            :             for (gid16 nGlyphId = 0; nGlyphId &lt; cnGlyphs; nGlyphId++)
<span class="lineNum">     722 </span>            :             {
<span class="lineNum">     723 </span>            :                 if (be::swap(pTable2-&gt;glyph_name_index[nGlyphId]) == iPostName)
<span class="lineNum">     724 </span>            :                     return nGlyphId;
<span class="lineNum">     725 </span>            :             }
<span class="lineNum">     726 </span>            :         }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :         { // did not match a standard name, search font specific names
<span class="lineNum">     729 </span>            :             size_t nStrSizeGoal = strlen(pPostName);
<span class="lineNum">     730 </span>            :             const char * pFirstGlyphName = reinterpret_cast&lt;const char *&gt;(
<span class="lineNum">     731 </span>            :                 &amp;pTable2-&gt;glyph_name_index[0] + cnGlyphs);
<span class="lineNum">     732 </span>            :             const char * pGlyphName = pFirstGlyphName;
<span class="lineNum">     733 </span>            :             int iInNames = 0; // index in font specific names
<span class="lineNum">     734 </span>            :             bool fFound = false;
<span class="lineNum">     735 </span>            :             const char * const endOfTable 
<span class="lineNum">     736 </span>            :                 = reinterpret_cast&lt;const char *&gt;(pTable2) + lPostSize;
<span class="lineNum">     737 </span>            :             while (pGlyphName &lt; endOfTable &amp;&amp; !fFound) 
<span class="lineNum">     738 </span>            :             { // search Pascal strings for first matching name
<span class="lineNum">     739 </span>            :                 size_t nStringSize = size_t(*pGlyphName);
<span class="lineNum">     740 </span>            :                 if (nStrSizeGoal != nStringSize ||
<span class="lineNum">     741 </span>            :                     strncmp(pGlyphName + 1, pPostName, nStringSize))
<span class="lineNum">     742 </span>            :                 { // did not match
<span class="lineNum">     743 </span>            :                     ++iInNames;
<span class="lineNum">     744 </span>            :                     pGlyphName += nStringSize + 1;
<span class="lineNum">     745 </span>            :                 }
<span class="lineNum">     746 </span>            :                 else
<span class="lineNum">     747 </span>            :                 { // did match
<span class="lineNum">     748 </span>            :                     fFound = true;
<span class="lineNum">     749 </span>            :                 }
<span class="lineNum">     750 </span>            :             }
<span class="lineNum">     751 </span>            :             if (!fFound)
<span class="lineNum">     752 </span>            :                 return -1; // no font specific name matches request
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :             iInNames += kcPostNames;
<span class="lineNum">     755 </span>            :             for (gid16 nGlyphId = 0; nGlyphId &lt; cnGlyphs; nGlyphId++)
<span class="lineNum">     756 </span>            :             { // search for first glyph id that maps to the found string index
<span class="lineNum">     757 </span>            :                 if (be::swap(pTable2-&gt;glyph_name_index[nGlyphId]) == iInNames)
<span class="lineNum">     758 </span>            :                     return nGlyphId;
<span class="lineNum">     759 </span>            :             }
<span class="lineNum">     760 </span>            :             return -1; // no glyph mapped to this index (very strange)
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     return -3;
<span class="lineNum">     765 </span>            : }
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     768 </span>            :     Convert a Unicode character string from big endian (MSB first, Motorola) format to little 
<span class="lineNum">     769 </span>            :     endian (LSB first, Intel) format. 
<span class="lineNum">     770 </span>            :     nSize is the number of Unicode characters in the string. It should not include any 
<span class="lineNum">     771 </span>            :     terminating null. If nSize is 0, it is assumed the string is null terminated. nSize 
<span class="lineNum">     772 </span>            :     defaults to 0.
<span class="lineNum">     773 </span>            :     Return true if successful, false otherwise. 
<span class="lineNum">     774 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     775 </span>            : void SwapWString(void * pWStr, size_t nSize /* = 0 */) //throw (std::invalid_argument)
<span class="lineNum">     776 </span>            : {
<span class="lineNum">     777 </span>            :     if (pWStr == 0)
<span class="lineNum">     778 </span>            :     {
<span class="lineNum">     779 </span>            : //      throw std::invalid_argument(&quot;null pointer given&quot;);
<span class="lineNum">     780 </span>            :         return;
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :     uint16 * pStr = reinterpret_cast&lt;uint16 *&gt;(pWStr);
<span class="lineNum">     784 </span>            :     uint16 * const pStrEnd = pStr + (nSize == 0 ? wcslen((const wchar_t*)pStr) : nSize);
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :         for (; pStr != pStrEnd; ++pStr)
<span class="lineNum">     787 </span>            :           *pStr = be::swap(*pStr);
<span class="lineNum">     788 </span>            : //  std::transform(pStr, pStrEnd, pStr, read&lt;uint16&gt;);
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : //      for (int i = 0; i &lt; nSize; i++)
<span class="lineNum">     791 </span>            : //      { // swap the wide characters in the string
<span class="lineNum">     792 </span>            : //          pStr[i] = utf16(be::swap(uint16(pStr[i])));
<span class="lineNum">     793 </span>            : //      }
<span class="lineNum">     794 </span>            : }
<span class="lineNum">     795 </span>            : #endif
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     798 </span>            :     Get the left-side bearing and and advance width based on the given tables and Glyph ID
<a name="799"><span class="lineNum">     799 </span>            :     Return true if successful, false otherwise. On false, one or both value could be INT_MIN</a>
<span class="lineNum">     800 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     801 </span><span class="lineNoCov">          0 : bool HorMetrics(gid16 nGlyphId, const void * pHmtx, size_t lHmtxSize, const void * pHhea, </span>
<span class="lineNum">     802 </span>            :                          int &amp; nLsb, unsigned int &amp; nAdvWid)
<span class="lineNum">     803 </span>            : {
<span class="lineNum">     804 </span>            :     const Sfnt::HorizontalMetric * phmtx = 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         reinterpret_cast&lt;const Sfnt::HorizontalMetric *&gt;(pHmtx);</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :     const Sfnt::HorizontalHeader * phhea = 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         reinterpret_cast&lt;const Sfnt::HorizontalHeader *&gt;(pHhea);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     size_t cLongHorMetrics = be::swap(phhea-&gt;num_long_hor_metrics);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     if (nGlyphId &lt; cLongHorMetrics) </span>
<span class="lineNum">     812 </span>            :     {   // glyph id is acceptable
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if ((nGlyphId + 1) * sizeof(Sfnt::HorizontalMetric) &gt; lHmtxSize) return false;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         nAdvWid = be::swap(phmtx[nGlyphId].advance_width);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         nLsb = be::swap(phmtx[nGlyphId].left_side_bearing);</span>
<span class="lineNum">     816 </span>            :     }
<span class="lineNum">     817 </span>            :     else
<span class="lineNum">     818 </span>            :     {
<span class="lineNum">     819 </span>            :         // guard against bad glyph id
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         size_t lLsbOffset = sizeof(Sfnt::HorizontalMetric) * cLongHorMetrics +</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :             sizeof(int16) * (nGlyphId - cLongHorMetrics); // offset in bytes</span>
<span class="lineNum">     822 </span>            :         // We test like this as LsbOffset is an offset not a length.
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         if (lLsbOffset &gt;= lHmtxSize - sizeof(int16) || cLongHorMetrics == 0)</span>
<span class="lineNum">     824 </span>            :         {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :             nLsb = 0;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     827 </span>            :         }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         nAdvWid = be::swap(phmtx[cLongHorMetrics - 1].advance_width);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         nLsb = be::peek&lt;int16&gt;(reinterpret_cast&lt;const byte *&gt;(phmtx) + lLsbOffset);</span>
<span class="lineNum">     830 </span>            :     }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     833 </span>            : }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     836 </span>            :     Return a pointer to the requested cmap subtable. By default find the Microsoft Unicode
<span class="lineNum">     837 </span>            :     subtable. Pass nEncoding as -1 to find first table that matches only nPlatformId.
<a name="838"><span class="lineNum">     838 </span>            :     Return NULL if the subtable cannot be found.</a>
<span class="lineNum">     839 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     840 </span><span class="lineNoCov">          0 : const void * FindCmapSubtable(const void * pCmap, int nPlatformId, /* =3 */ int nEncodingId, /* = 1 */ size_t length)</span>
<span class="lineNum">     841 </span>            : {
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     const Sfnt::CharacterCodeMap * pTable = reinterpret_cast&lt;const Sfnt::CharacterCodeMap *&gt;(pCmap);</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     uint16 csuPlatforms = be::swap(pTable-&gt;num_subtables);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     if (length &amp;&amp; (sizeof(Sfnt::CharacterCodeMap) + 8 * (csuPlatforms - 1) &gt; length))</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; csuPlatforms; i++)</span>
<span class="lineNum">     847 </span>            :     {
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         if (be::swap(pTable-&gt;encoding[i].platform_id) == nPlatformId &amp;&amp;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                 (nEncodingId == -1 || be::swap(pTable-&gt;encoding[i].platform_specific_id) == nEncodingId))</span>
<span class="lineNum">     850 </span>            :         {
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             uint32 offset = be::swap(pTable-&gt;encoding[i].offset);</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :             const uint8 * pRtn = reinterpret_cast&lt;const uint8 *&gt;(pCmap) + offset;</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :             if (length)</span>
<span class="lineNum">     854 </span>            :             {
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                 if (offset &gt; length - 2) return NULL;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                 uint16 format = be::read&lt;uint16&gt;(pRtn);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                 if (format == 4)</span>
<span class="lineNum">     858 </span>            :                 {
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                     if (offset &gt; length - 4) return NULL;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :                     uint16 subTableLength = be::peek&lt;uint16&gt;(pRtn);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                     if (i + 1 == csuPlatforms)</span>
<span class="lineNum">     862 </span>            :                     {
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                         if (subTableLength &gt; length - offset)</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                             return NULL;</span>
<span class="lineNum">     865 </span>            :                     }
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                     else if (subTableLength &gt; be::swap(pTable-&gt;encoding[i+1].offset))</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     868 </span>            :                 }
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :                 if (format == 12)</span>
<span class="lineNum">     870 </span>            :                 {
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                     if (offset &gt; length - 6) return NULL;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :                     uint32 subTableLength = be::peek&lt;uint32&gt;(pRtn);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :                     if (i + 1 == csuPlatforms)</span>
<span class="lineNum">     874 </span>            :                     {
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                         if (subTableLength &gt; length - offset)</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :                             return NULL;</span>
<span class="lineNum">     877 </span>            :                     }
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :                     else if (subTableLength &gt; be::swap(pTable-&gt;encoding[i+1].offset))</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     880 </span>            :                 }
<span class="lineNum">     881 </span>            :             }
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :             return reinterpret_cast&lt;const uint8 *&gt;(pCmap) + offset;</span>
<span class="lineNum">     883 </span>            :         }
<span class="lineNum">     884 </span>            :     }
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     887 </span>            : }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            : /*----------------------------------------------------------------------------------------------
<a name="890"><span class="lineNum">     890 </span>            :     Check the Microsoft Unicode subtable for expected values</a>
<span class="lineNum">     891 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     892 </span><span class="lineNoCov">          0 : bool CheckCmapSubtable4(const void * pCmapSubtable4, const void * pCmapEnd /*, unsigned int maxgid*/)</span>
<span class="lineNum">     893 </span>            : {
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     size_t table_len = (const byte *)pCmapEnd - (const byte *)pCmapSubtable4;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     if (!pCmapSubtable4) return false;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTable * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTable *&gt;(pCmapSubtable4);</span>
<span class="lineNum">     897 </span>            :     // Bob H say some freeware TT fonts have version 1 (eg, CALIGULA.TTF) 
<span class="lineNum">     898 </span>            :     // so don't check subtable version. 21 Mar 2002 spec changes version to language.
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     if (table_len &lt; sizeof(*pTable) || be::swap(pTable-&gt;format) != 4) return false;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat4 * pTable4 = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat4 *&gt;(pCmapSubtable4);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if (table_len &lt; sizeof(*pTable4))</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     uint16 length = be::swap(pTable4-&gt;length);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     if (length &gt; table_len)</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     if (length &lt; sizeof(Sfnt::CmapSubTableFormat4))</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     uint16 nRanges = be::swap(pTable4-&gt;seg_count_x2) &gt;&gt; 1;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     if (!nRanges || length &lt; sizeof(Sfnt::CmapSubTableFormat4) + 4 * nRanges * sizeof(uint16))</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     911 </span>            :     // check last range is properly terminated
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     uint16 chEnd = be::peek&lt;uint16&gt;(pTable4-&gt;end_code + nRanges - 1);</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     if (chEnd != 0xFFFF)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     915 </span>            : #if 0
<span class="lineNum">     916 </span>            :     int lastend = -1;
<span class="lineNum">     917 </span>            :     for (int i = 0; i &lt; nRanges; ++i)
<span class="lineNum">     918 </span>            :     {
<span class="lineNum">     919 </span>            :         uint16 end = be::peek&lt;uint16&gt;(pTable4-&gt;end_code + i);
<span class="lineNum">     920 </span>            :         uint16 start = be::peek&lt;uint16&gt;(pTable4-&gt;end_code + nRanges + 1 + i);
<span class="lineNum">     921 </span>            :         int16 delta = be::peek&lt;int16&gt;(pTable4-&gt;end_code + 2*nRanges + 1 + i);
<span class="lineNum">     922 </span>            :         uint16 offset = be::peek&lt;uint16&gt;(pTable4-&gt;end_code + 3*nRanges + 1 + i);
<span class="lineNum">     923 </span>            :         if (lastend &gt;= end || lastend &gt;= start)
<span class="lineNum">     924 </span>            :             return false;
<span class="lineNum">     925 </span>            :         if (offset)
<span class="lineNum">     926 </span>            :         {
<span class="lineNum">     927 </span>            :             const uint16 *gstart = pTable4-&gt;end_code + 3*nRanges + 1 + i + (offset &gt;&gt; 1);
<span class="lineNum">     928 </span>            :             const uint16 *gend = gstart + end - start;
<span class="lineNum">     929 </span>            :             if ((char *)gend &gt;= (char *)pCmapSubtable4 + length)
<span class="lineNum">     930 </span>            :                 return false;
<span class="lineNum">     931 </span>            :             while (gstart &lt;= gend)
<span class="lineNum">     932 </span>            :             {
<span class="lineNum">     933 </span>            :                 uint16 g = be::peek&lt;uint16&gt;(gstart++);
<span class="lineNum">     934 </span>            :                 if (g &amp;&amp; ((g + delta) &amp; 0xFFFF) &gt; maxgid)
<span class="lineNum">     935 </span>            :                     return false;
<span class="lineNum">     936 </span>            :             }
<span class="lineNum">     937 </span>            :         }
<span class="lineNum">     938 </span>            :         else if (((delta + end) &amp; 0xFFFF) &gt; maxgid)
<span class="lineNum">     939 </span>            :             return false;
<span class="lineNum">     940 </span>            :         lastend = end;
<span class="lineNum">     941 </span>            :     }
<span class="lineNum">     942 </span>            : #endif
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     944 </span>            : }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">     947 </span>            :     Return the Glyph ID for the given Unicode ID in the Microsoft Unicode subtable.
<span class="lineNum">     948 </span>            :     (Actually this code only depends on subtable being format 4.)
<a name="949"><span class="lineNum">     949 </span>            :     Return 0 if the Unicode ID is not in the subtable.</a>
<span class="lineNum">     950 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">     951 </span><span class="lineNoCov">          0 : gid16 CmapSubtable4Lookup(const void * pCmapSubtabel4, unsigned int nUnicodeId, int rangeKey)</span>
<span class="lineNum">     952 </span>            : {
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat4 * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat4 *&gt;(pCmapSubtabel4);</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     uint16 nSeg = be::swap(pTable-&gt;seg_count_x2) &gt;&gt; 1;</span>
<span class="lineNum">     956 </span>            :   
<span class="lineNum">     957 </span>            :     uint16 n;
<span class="lineNum">     958 </span>            :     const uint16 * pLeft, * pMid;
<span class="lineNum">     959 </span>            :     uint16 cMid, chStart, chEnd;
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     if (rangeKey)</span>
<span class="lineNum">     962 </span>            :     {
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         pMid = &amp;(pTable-&gt;end_code[rangeKey]);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :         chEnd = be::peek&lt;uint16&gt;(pMid);</span>
<span class="lineNum">     965 </span>            :     }
<span class="lineNum">     966 </span>            :     else
<span class="lineNum">     967 </span>            :     {
<span class="lineNum">     968 </span>            :         // Binary search of the endCode[] array
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         pLeft = &amp;(pTable-&gt;end_code[0]);</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         n = nSeg;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         while (n &gt; 0)</span>
<span class="lineNum">     972 </span>            :         {
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             cMid = n &gt;&gt; 1;           // Pick an element in the middle</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :             pMid = pLeft + cMid;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :             chEnd = be::peek&lt;uint16&gt;(pMid);</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :             if (nUnicodeId &lt;= chEnd)</span>
<span class="lineNum">     977 </span>            :             {
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 if (cMid == 0 || nUnicodeId &gt; be::peek&lt;uint16&gt;(pMid -1))</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :                         break;          // Must be this seg or none!</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :                 n = cMid;            // Continue on left side, omitting mid point</span>
<span class="lineNum">     981 </span>            :             }
<span class="lineNum">     982 </span>            :             else
<span class="lineNum">     983 </span>            :             {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 pLeft = pMid + 1;    // Continue on right side, omitting mid point</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 n -= (cMid + 1);</span>
<span class="lineNum">     986 </span>            :             }
<span class="lineNum">     987 </span>            :         }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         if (!n)</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     991 </span>            :     }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :     // Ok, we're down to one segment and pMid points to the endCode element
<span class="lineNum">     994 </span>            :     // Either this is it or none is.
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     chStart = be::peek&lt;uint16&gt;(pMid += nSeg + 1);</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     if (chEnd &gt;= nUnicodeId &amp;&amp; nUnicodeId &gt;= chStart)</span>
<span class="lineNum">     998 </span>            :     {
<span class="lineNum">     999 </span>            :         // Found correct segment. Find Glyph Id
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :         int16 idDelta = be::peek&lt;uint16&gt;(pMid += nSeg);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         uint16 idRangeOffset = be::peek&lt;uint16&gt;(pMid += nSeg);</span>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         if (idRangeOffset == 0)</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :             return (uint16)(idDelta + nUnicodeId); // must use modulus 2^16</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :         // Look up value in glyphIdArray
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         const ptrdiff_t offset = (nUnicodeId - chStart) + (idRangeOffset &gt;&gt; 1) +</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                 (pMid - reinterpret_cast&lt;const uint16 *&gt;(pTable));</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         if (offset * 2 + 1 &gt;= be::swap&lt;uint16&gt;(pTable-&gt;length))</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         gid16 nGlyphId = be::peek&lt;uint16&gt;(reinterpret_cast&lt;const uint16 *&gt;(pTable)+offset);</span>
<span class="lineNum">    1012 </span>            :         // If this value is 0, return 0. Else add the idDelta
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         return nGlyphId ? nGlyphId + idDelta : 0;</span>
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1017 </span>            : }
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1020 </span>            :     Return the next Unicode value in the cmap. Pass 0 to obtain the first item.
<span class="lineNum">    1021 </span>            :     Returns 0xFFFF as the last item.
<span class="lineNum">    1022 </span>            :     pRangeKey is an optional key that is used to optimize the search; its value is the range
<a name="1023"><span class="lineNum">    1023 </span>            :     in which the character is found.</a>
<span class="lineNum">    1024 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 : unsigned int CmapSubtable4NextCodepoint(const void *pCmap31, unsigned int nUnicodeId, int * pRangeKey)</span>
<span class="lineNum">    1026 </span>            : {
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat4 * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat4 *&gt;(pCmap31);</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     uint16 nRange = be::swap(pTable-&gt;seg_count_x2) &gt;&gt; 1;</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     uint32 nUnicodePrev = (uint32)nUnicodeId;</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     const uint16 * pStartCode = &amp;(pTable-&gt;end_code[0])</span>
<span class="lineNum">    1034 </span>            :         + nRange // length of end code array
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         + 1;   // reserved word</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     if (nUnicodePrev == 0)</span>
<span class="lineNum">    1038 </span>            :     {
<span class="lineNum">    1039 </span>            :         // return the first codepoint.
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :             *pRangeKey = 0;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         return be::peek&lt;uint16&gt;(pStartCode);</span>
<span class="lineNum">    1043 </span>            :     }
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     else if (nUnicodePrev &gt;= 0xFFFF)</span>
<span class="lineNum">    1045 </span>            :     {
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :             *pRangeKey = nRange - 1;</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         return 0xFFFF;</span>
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     int iRange = (pRangeKey) ? *pRangeKey : 0;</span>
<span class="lineNum">    1052 </span>            :     // Just in case we have a bad key:
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     while (iRange &gt; 0 &amp;&amp; be::peek&lt;uint16&gt;(pStartCode + iRange) &gt; nUnicodePrev)</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         iRange--;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     while (iRange &lt; nRange - 1 &amp;&amp; be::peek&lt;uint16&gt;(pTable-&gt;end_code + iRange) &lt; nUnicodePrev)</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         iRange++;</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :     // Now iRange is the range containing nUnicodePrev.
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     unsigned int nStartCode = be::peek&lt;uint16&gt;(pStartCode + iRange);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     unsigned int nEndCode = be::peek&lt;uint16&gt;(pTable-&gt;end_code + iRange);</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     if (nStartCode &gt; nUnicodePrev)</span>
<span class="lineNum">    1063 </span>            :         // Oops, nUnicodePrev is not in the cmap! Adjust so we get a reasonable
<span class="lineNum">    1064 </span>            :         // answer this time around.
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         nUnicodePrev = nStartCode - 1;</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     if (nEndCode &gt; nUnicodePrev)</span>
<span class="lineNum">    1068 </span>            :     {
<span class="lineNum">    1069 </span>            :         // Next is in the same range; it is the next successive codepoint.
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :             *pRangeKey = iRange;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         return nUnicodePrev + 1;</span>
<span class="lineNum">    1073 </span>            :     }
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :     // Otherwise the next codepoint is the first one in the next range.
<span class="lineNum">    1076 </span>            :     // There is guaranteed to be a next range because there must be one that
<span class="lineNum">    1077 </span>            :     // ends with 0xFFFF.
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     if (pRangeKey)</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         *pRangeKey = iRange + 1;</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     return (iRange + 1 &gt;= nRange) ? 0xFFFF : be::peek&lt;uint16&gt;(pStartCode + iRange + 1);</span>
<span class="lineNum">    1081 </span>            : }
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            : /*----------------------------------------------------------------------------------------------
<a name="1084"><span class="lineNum">    1084 </span>            :     Check the Microsoft UCS-4 subtable for expected values.</a>
<span class="lineNum">    1085 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : bool CheckCmapSubtable12(const void *pCmapSubtable12, const void *pCmapEnd /*, unsigned int maxgid*/)</span>
<span class="lineNum">    1087 </span>            : {
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     size_t table_len = (const byte *)pCmapEnd - (const byte *)pCmapSubtable12;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     if (!pCmapSubtable12)  return false;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTable * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTable *&gt;(pCmapSubtable12);</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     if (table_len &lt; sizeof(*pTable) || be::swap(pTable-&gt;format) != 12)</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat12 * pTable12 = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat12 *&gt;(pCmapSubtable12);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     if (table_len &lt; sizeof(*pTable12))</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     uint32 length = be::swap(pTable12-&gt;length);</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     if (length &gt; table_len)</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     if (length &lt; sizeof(Sfnt::CmapSubTableFormat12))</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     uint32 num_groups = be::swap(pTable12-&gt;num_groups);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     if (num_groups &gt; 0x10000000 || length != (sizeof(Sfnt::CmapSubTableFormat12) + (num_groups - 1) * sizeof(uint32) * 3))</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1104 </span>            : #if 0
<span class="lineNum">    1105 </span>            :     for (unsigned int i = 0; i &lt; num_groups; ++i)
<span class="lineNum">    1106 </span>            :     {
<span class="lineNum">    1107 </span>            :         if (be::swap(pTable12-&gt;group[i].end_char_code)  - be::swap(pTable12-&gt;group[i].start_char_code) + be::swap(pTable12-&gt;group[i].start_glyph_id) &gt; maxgid)
<span class="lineNum">    1108 </span>            :             return false;
<span class="lineNum">    1109 </span>            :         if (i &gt; 0 &amp;&amp; be::swap(pTable12-&gt;group[i].start_char_code) &lt;= be::swap(pTable12-&gt;group[i-1].end_char_code))
<span class="lineNum">    1110 </span>            :             return false;
<span class="lineNum">    1111 </span>            :     }
<span class="lineNum">    1112 </span>            : #endif
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1114 </span>            : }
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1117 </span>            :     Return the Glyph ID for the given Unicode ID in the Microsoft UCS-4 subtable.
<span class="lineNum">    1118 </span>            :     (Actually this code only depends on subtable being format 12.)
<a name="1119"><span class="lineNum">    1119 </span>            :     Return 0 if the Unicode ID is not in the subtable.</a>
<span class="lineNum">    1120 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 : gid16 CmapSubtable12Lookup(const void * pCmap310, unsigned int uUnicodeId, int rangeKey)</span>
<span class="lineNum">    1122 </span>            : {
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat12 * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat12 *&gt;(pCmap310);</span>
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            :     //uint32 uLength = be::swap(pTable-&gt;length); //could use to test for premature end of table
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     uint32 ucGroups = be::swap(pTable-&gt;num_groups);</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     for (unsigned int i = rangeKey; i &lt; ucGroups; i++)</span>
<span class="lineNum">    1129 </span>            :     {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         uint32 uStartCode = be::swap(pTable-&gt;group[i].start_char_code);</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :         uint32 uEndCode = be::swap(pTable-&gt;group[i].end_char_code);</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         if (uUnicodeId &gt;= uStartCode &amp;&amp; uUnicodeId &lt;= uEndCode)</span>
<span class="lineNum">    1133 </span>            :         {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             uint32 uDiff = uUnicodeId - uStartCode;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             uint32 uStartGid = be::swap(pTable-&gt;group[i].start_glyph_id);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             return static_cast&lt;gid16&gt;(uStartGid + uDiff);</span>
<span class="lineNum">    1137 </span>            :         }
<span class="lineNum">    1138 </span>            :     }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1141 </span>            : }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1144 </span>            :     Return the next Unicode value in the cmap. Pass 0 to obtain the first item.
<span class="lineNum">    1145 </span>            :     Returns 0x10FFFF as the last item.
<span class="lineNum">    1146 </span>            :     pRangeKey is an optional key that is used to optimize the search; its value is the range
<a name="1147"><span class="lineNum">    1147 </span>            :     in which the character is found.</a>
<span class="lineNum">    1148 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 : unsigned int CmapSubtable12NextCodepoint(const void *pCmap310, unsigned int nUnicodeId, int * pRangeKey)</span>
<span class="lineNum">    1150 </span>            : {
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     const Sfnt::CmapSubTableFormat12 * pTable = reinterpret_cast&lt;const Sfnt::CmapSubTableFormat12 *&gt;(pCmap310);</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     int nRange = be::swap(pTable-&gt;num_groups);</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     uint32 nUnicodePrev = (uint32)nUnicodeId;</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     if (nUnicodePrev == 0)</span>
<span class="lineNum">    1158 </span>            :     {
<span class="lineNum">    1159 </span>            :         // return the first codepoint.
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             *pRangeKey = 0;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         return be::swap(pTable-&gt;group[0].start_char_code);</span>
<span class="lineNum">    1163 </span>            :     }
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :     else if (nUnicodePrev &gt;= 0x10FFFF)</span>
<span class="lineNum">    1165 </span>            :     {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             *pRangeKey = nRange;</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         return 0x10FFFF;</span>
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     int iRange = (pRangeKey) ? *pRangeKey : 0;</span>
<span class="lineNum">    1172 </span>            :     // Just in case we have a bad key:
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     while (iRange &gt; 0 &amp;&amp; be::swap(pTable-&gt;group[iRange].start_char_code) &gt; nUnicodePrev)</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         iRange--;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     while (iRange &lt; nRange - 1 &amp;&amp; be::swap(pTable-&gt;group[iRange].end_char_code) &lt; nUnicodePrev)</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :         iRange++;</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :     // Now iRange is the range containing nUnicodePrev.
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     unsigned int nStartCode = be::swap(pTable-&gt;group[iRange].start_char_code);</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     unsigned int nEndCode = be::swap(pTable-&gt;group[iRange].end_char_code);</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :     if (nStartCode &gt; nUnicodePrev)</span>
<span class="lineNum">    1184 </span>            :         // Oops, nUnicodePrev is not in the cmap! Adjust so we get a reasonable
<span class="lineNum">    1185 </span>            :         // answer this time around.
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         nUnicodePrev = nStartCode - 1;</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :     if (nEndCode &gt; nUnicodePrev)</span>
<span class="lineNum">    1189 </span>            :     {
<span class="lineNum">    1190 </span>            :         // Next is in the same range; it is the next successive codepoint.
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         if (pRangeKey)</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             *pRangeKey = iRange;</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         return nUnicodePrev + 1;</span>
<span class="lineNum">    1194 </span>            :     }
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            :     // Otherwise the next codepoint is the first one in the next range, or 10FFFF if we're done.
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     if (pRangeKey)</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :         *pRangeKey = iRange + 1;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     return (iRange + 1 &gt;= nRange) ? 0x10FFFF : be::swap(pTable-&gt;group[iRange + 1].start_char_code);</span>
<span class="lineNum">    1200 </span>            : }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1203 </span>            :     Return the offset stored in the loca table for the given Glyph ID.
<span class="lineNum">    1204 </span>            :     (This offset is into the glyf table.)
<span class="lineNum">    1205 </span>            :     Return -1 if the lookup failed.
<span class="lineNum">    1206 </span>            :     Technically this method should return an unsigned long but it is unlikely the offset will
<a name="1207"><span class="lineNum">    1207 </span>            :         exceed 2^31.</a>
<span class="lineNum">    1208 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 : size_t LocaLookup(gid16 nGlyphId, </span>
<span class="lineNum">    1210 </span>            :         const void * pLoca, size_t lLocaSize, 
<span class="lineNum">    1211 </span>            :         const void * pHead) // throw (std::out_of_range)
<span class="lineNum">    1212 </span>            : {
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     const Sfnt::FontHeader * pTable = reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     size_t res = -2;</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :     // CheckTable verifies the index_to_loc_format is valid
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     if (be::swap(pTable-&gt;index_to_loc_format) == Sfnt::FontHeader::ShortIndexLocFormat)</span>
<span class="lineNum">    1218 </span>            :     { // loca entries are two bytes and have been divided by two
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :         if (lLocaSize &gt; 1 &amp;&amp; nGlyphId + 1u &lt; lLocaSize &gt;&gt; 1) // allow sentinel value to be accessed</span>
<span class="lineNum">    1220 </span>            :         {
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :             const uint16 * pShortTable = reinterpret_cast&lt;const uint16 *&gt;(pLoca);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :             res = be::peek&lt;uint16&gt;(pShortTable + nGlyphId) &lt;&lt; 1;</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :             if (res == static_cast&lt;size_t&gt;(be::peek&lt;uint16&gt;(pShortTable + nGlyphId + 1) &lt;&lt; 1))</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1225 </span>            :         }
<span class="lineNum">    1226 </span>            :     }
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     else if (be::swap(pTable-&gt;index_to_loc_format) == Sfnt::FontHeader::LongIndexLocFormat)</span>
<span class="lineNum">    1228 </span>            :     { // loca entries are four bytes
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :         if (lLocaSize &gt; 3 &amp;&amp; nGlyphId + 1u &lt; lLocaSize &gt;&gt; 2)</span>
<span class="lineNum">    1230 </span>            :         {
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :             const uint32 * pLongTable = reinterpret_cast&lt;const uint32 *&gt;(pLoca);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :             res = be::peek&lt;uint32&gt;(pLongTable + nGlyphId);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             if (res == static_cast&lt;size_t&gt;(be::peek&lt;uint32&gt;(pLongTable + nGlyphId + 1)))</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1235 </span>            :         }
<span class="lineNum">    1236 </span>            :     }
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :     // only get here if glyph id was bad
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     return res;</span>
<span class="lineNum">    1240 </span>            :     //throw std::out_of_range(&quot;glyph id out of range for font&quot;);
<span class="lineNum">    1241 </span>            : }
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1244 </span>            :     Return a pointer into the glyf table based on the given offset (from LocaLookup).
<a name="1245"><span class="lineNum">    1245 </span>            :     Return NULL on error.</a>
<span class="lineNum">    1246 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 : void * GlyfLookup(const void * pGlyf, size_t nGlyfOffset, size_t nTableLen)</span>
<span class="lineNum">    1248 </span>            : {
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     const uint8 * pByte = reinterpret_cast&lt;const uint8 *&gt;(pGlyf);</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :         if (nGlyfOffset + pByte &lt; pByte || nGlyfOffset + sizeof(Sfnt::Glyph) &gt;= nTableLen)</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     return const_cast&lt;uint8 *&gt;(pByte + nGlyfOffset);</span>
<span class="lineNum">    1253 </span>            : }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1256 </span>            :     Get the bounding box coordinates for a simple glyf entry (non-composite).
<a name="1257"><span class="lineNum">    1257 </span>            :     Return true if successful, false otherwise.</a>
<span class="lineNum">    1258 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 : bool GlyfBox(const void * pSimpleGlyf, int &amp; xMin, int &amp; yMin, </span>
<span class="lineNum">    1260 </span>            :                       int &amp; xMax, int &amp; yMax)
<span class="lineNum">    1261 </span>            : {
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     const Sfnt::Glyph * pGlyph = reinterpret_cast&lt;const Sfnt::Glyph *&gt;(pSimpleGlyf);</span>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     xMin = be::swap(pGlyph-&gt;x_min);</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     yMin = be::swap(pGlyph-&gt;y_min);</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :     xMax = be::swap(pGlyph-&gt;x_max);</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     yMax = be::swap(pGlyph-&gt;y_max);</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1270 </span>            : }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">    1273 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1274 </span>            :     Return the number of contours for a simple glyf entry (non-composite)
<span class="lineNum">    1275 </span>            :     Returning -1 means this is a composite glyph
<span class="lineNum">    1276 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1277 </span>            : int GlyfContourCount(const void * pSimpleGlyf)
<span class="lineNum">    1278 </span>            : {
<span class="lineNum">    1279 </span>            :     const Sfnt::Glyph * pGlyph = reinterpret_cast&lt;const Sfnt::Glyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1280 </span>            :     return be::swap(pGlyph-&gt;number_of_contours); // -1 means composite glyph
<span class="lineNum">    1281 </span>            : }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1284 </span>            :     Get the point numbers for the end points of the glyph contours for a simple
<span class="lineNum">    1285 </span>            :     glyf entry (non-composite). 
<span class="lineNum">    1286 </span>            :     cnPointsTotal - count of contours from GlyfContourCount(); (same as number of end points)
<span class="lineNum">    1287 </span>            :     prgnContourEndPoints - should point to a buffer large enough to hold cnPoints integers
<span class="lineNum">    1288 </span>            :     cnPoints - count of points placed in above range
<span class="lineNum">    1289 </span>            :     Return true if successful, false otherwise.
<span class="lineNum">    1290 </span>            :         False could indicate a multi-level composite glyphs.
<span class="lineNum">    1291 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1292 </span>            : bool GlyfContourEndPoints(const void * pSimpleGlyf, int * prgnContourEndPoint, 
<span class="lineNum">    1293 </span>            :                                    int cnPointsTotal, int &amp; cnPoints)
<span class="lineNum">    1294 </span>            : {
<span class="lineNum">    1295 </span>            :     const Sfnt::SimpleGlyph * pGlyph = reinterpret_cast&lt;const Sfnt::SimpleGlyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            :     int cContours = be::swap(pGlyph-&gt;number_of_contours);
<span class="lineNum">    1298 </span>            :     if (cContours &lt; 0)
<span class="lineNum">    1299 </span>            :         return false; // this method isn't supposed handle composite glyphs
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :     for (int i = 0; i &lt; cContours &amp;&amp; i &lt; cnPointsTotal; i++)
<span class="lineNum">    1302 </span>            :     {
<span class="lineNum">    1303 </span>            :         prgnContourEndPoint[i] = be::swap(pGlyph-&gt;end_pts_of_contours[i]);
<span class="lineNum">    1304 </span>            :     }
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :     cnPoints = cContours;
<span class="lineNum">    1307 </span>            :     return true;
<span class="lineNum">    1308 </span>            : }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1311 </span>            :     Get the points for a simple glyf entry (non-composite)
<span class="lineNum">    1312 </span>            :     cnPointsTotal - count of points from largest end point obtained from GlyfContourEndPoints
<span class="lineNum">    1313 </span>            :     prgnX &amp; prgnY - should point to buffers large enough to hold cnPointsTotal integers
<span class="lineNum">    1314 </span>            :         The ranges are parallel so that coordinates for point(n) are found at offset n in both 
<span class="lineNum">    1315 </span>            :         ranges. This is raw point data with relative coordinates.
<span class="lineNum">    1316 </span>            :     prgbFlag - should point to a buffer a large enough to hold cnPointsTotal bytes
<span class="lineNum">    1317 </span>            :         This range is parallel to the prgnX &amp; prgnY
<span class="lineNum">    1318 </span>            :     cnPoints - count of points placed in above ranges
<span class="lineNum">    1319 </span>            :     Return true if successful, false otherwise. 
<span class="lineNum">    1320 </span>            :         False could indicate a composite glyph
<span class="lineNum">    1321 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1322 </span>            : bool GlyfPoints(const void * pSimpleGlyf, int * prgnX, int * prgnY, 
<span class="lineNum">    1323 </span>            :         char * prgbFlag, int cnPointsTotal, int &amp; cnPoints)
<span class="lineNum">    1324 </span>            : {
<span class="lineNum">    1325 </span>            :     using namespace Sfnt;
<span class="lineNum">    1326 </span>            :     
<span class="lineNum">    1327 </span>            :     const Sfnt::SimpleGlyph * pGlyph = reinterpret_cast&lt;const Sfnt::SimpleGlyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1328 </span>            :     int cContours = be::swap(pGlyph-&gt;number_of_contours);
<span class="lineNum">    1329 </span>            :     // return false for composite glyph
<span class="lineNum">    1330 </span>            :     if (cContours &lt;= 0)
<span class="lineNum">    1331 </span>            :         return false;
<span class="lineNum">    1332 </span>            :     int cPts = be::swap(pGlyph-&gt;end_pts_of_contours[cContours - 1]) + 1;
<span class="lineNum">    1333 </span>            :     if (cPts &gt; cnPointsTotal)
<span class="lineNum">    1334 </span>            :         return false;
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span>            :     // skip over bounding box data &amp; point to byte count of instructions (hints)
<span class="lineNum">    1337 </span>            :     const uint8 * pbGlyph = reinterpret_cast&lt;const uint8 *&gt;
<span class="lineNum">    1338 </span>            :         (&amp;pGlyph-&gt;end_pts_of_contours[cContours]);
<span class="lineNum">    1339 </span>            :     
<span class="lineNum">    1340 </span>            :     // skip over hints &amp; point to first flag
<span class="lineNum">    1341 </span>            :     int cbHints = be::swap(*(uint16 *)pbGlyph);
<span class="lineNum">    1342 </span>            :     pbGlyph += sizeof(uint16);
<span class="lineNum">    1343 </span>            :     pbGlyph += cbHints;
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :     // load flags &amp; point to first x coordinate
<span class="lineNum">    1346 </span>            :     int iFlag = 0;
<span class="lineNum">    1347 </span>            :     while (iFlag &lt; cPts)
<span class="lineNum">    1348 </span>            :     {
<span class="lineNum">    1349 </span>            :         if (!(*pbGlyph &amp; SimpleGlyph::Repeat))
<span class="lineNum">    1350 </span>            :         { // flag isn't repeated
<span class="lineNum">    1351 </span>            :             prgbFlag[iFlag] = (char)*pbGlyph;
<span class="lineNum">    1352 </span>            :             pbGlyph++;
<span class="lineNum">    1353 </span>            :             iFlag++;
<span class="lineNum">    1354 </span>            :         }
<span class="lineNum">    1355 </span>            :         else
<span class="lineNum">    1356 </span>            :         { // flag is repeated; count specified by next byte
<span class="lineNum">    1357 </span>            :             char chFlag = (char)*pbGlyph;
<span class="lineNum">    1358 </span>            :             pbGlyph++;
<span class="lineNum">    1359 </span>            :             int cFlags = (int)*pbGlyph;
<span class="lineNum">    1360 </span>            :             pbGlyph++;
<span class="lineNum">    1361 </span>            :             prgbFlag[iFlag] = chFlag;
<span class="lineNum">    1362 </span>            :             iFlag++;
<span class="lineNum">    1363 </span>            :             for (int i = 0; i &lt; cFlags; i++)
<span class="lineNum">    1364 </span>            :             {
<span class="lineNum">    1365 </span>            :                 prgbFlag[iFlag + i] = chFlag;
<span class="lineNum">    1366 </span>            :             }
<span class="lineNum">    1367 </span>            :             iFlag += cFlags;
<span class="lineNum">    1368 </span>            :         }
<span class="lineNum">    1369 </span>            :     }
<span class="lineNum">    1370 </span>            :     if (iFlag != cPts)
<span class="lineNum">    1371 </span>            :         return false;
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :     // load x coordinates
<span class="lineNum">    1374 </span>            :     iFlag = 0;
<span class="lineNum">    1375 </span>            :     while (iFlag &lt; cPts)
<span class="lineNum">    1376 </span>            :     {
<span class="lineNum">    1377 </span>            :         if (prgbFlag[iFlag] &amp; SimpleGlyph::XShort)
<span class="lineNum">    1378 </span>            :         {
<span class="lineNum">    1379 </span>            :             prgnX[iFlag] = *pbGlyph;
<span class="lineNum">    1380 </span>            :             if (!(prgbFlag[iFlag] &amp; SimpleGlyph::XIsPos))
<span class="lineNum">    1381 </span>            :             {
<span class="lineNum">    1382 </span>            :                 prgnX[iFlag] = -prgnX[iFlag];
<span class="lineNum">    1383 </span>            :             }
<span class="lineNum">    1384 </span>            :             pbGlyph++;
<span class="lineNum">    1385 </span>            :         }
<span class="lineNum">    1386 </span>            :         else
<span class="lineNum">    1387 </span>            :         {
<span class="lineNum">    1388 </span>            :             if (prgbFlag[iFlag] &amp; SimpleGlyph::XIsSame)
<span class="lineNum">    1389 </span>            :             {
<span class="lineNum">    1390 </span>            :                 prgnX[iFlag] = 0;
<span class="lineNum">    1391 </span>            :                 // do NOT increment pbGlyph
<span class="lineNum">    1392 </span>            :             }
<span class="lineNum">    1393 </span>            :             else
<span class="lineNum">    1394 </span>            :             {
<span class="lineNum">    1395 </span>            :                 prgnX[iFlag] = be::swap(*(int16 *)pbGlyph);
<span class="lineNum">    1396 </span>            :                 pbGlyph += sizeof(int16);
<span class="lineNum">    1397 </span>            :             }
<span class="lineNum">    1398 </span>            :         }
<span class="lineNum">    1399 </span>            :         iFlag++;
<span class="lineNum">    1400 </span>            :     }
<span class="lineNum">    1401 </span>            :         
<span class="lineNum">    1402 </span>            :     // load y coordinates
<span class="lineNum">    1403 </span>            :     iFlag = 0;
<span class="lineNum">    1404 </span>            :     while (iFlag &lt; cPts)
<span class="lineNum">    1405 </span>            :     {
<span class="lineNum">    1406 </span>            :         if (prgbFlag[iFlag] &amp; SimpleGlyph::YShort)
<span class="lineNum">    1407 </span>            :         {
<span class="lineNum">    1408 </span>            :             prgnY[iFlag] = *pbGlyph;
<span class="lineNum">    1409 </span>            :             if (!(prgbFlag[iFlag] &amp; SimpleGlyph::YIsPos))
<span class="lineNum">    1410 </span>            :             {
<span class="lineNum">    1411 </span>            :                 prgnY[iFlag] = -prgnY[iFlag];
<span class="lineNum">    1412 </span>            :             }
<span class="lineNum">    1413 </span>            :             pbGlyph++;
<span class="lineNum">    1414 </span>            :         }
<span class="lineNum">    1415 </span>            :         else
<span class="lineNum">    1416 </span>            :         {
<span class="lineNum">    1417 </span>            :             if (prgbFlag[iFlag] &amp; SimpleGlyph::YIsSame)
<span class="lineNum">    1418 </span>            :             {
<span class="lineNum">    1419 </span>            :                 prgnY[iFlag] = 0;
<span class="lineNum">    1420 </span>            :                 // do NOT increment pbGlyph
<span class="lineNum">    1421 </span>            :             }
<span class="lineNum">    1422 </span>            :             else
<span class="lineNum">    1423 </span>            :             {
<span class="lineNum">    1424 </span>            :                 prgnY[iFlag] = be::swap(*(int16 *)pbGlyph);
<span class="lineNum">    1425 </span>            :                 pbGlyph += sizeof(int16);
<span class="lineNum">    1426 </span>            :             }
<span class="lineNum">    1427 </span>            :         }
<span class="lineNum">    1428 </span>            :         iFlag++;
<span class="lineNum">    1429 </span>            :     }
<span class="lineNum">    1430 </span>            :         
<span class="lineNum">    1431 </span>            :     cnPoints = cPts;
<span class="lineNum">    1432 </span>            :     return true;
<span class="lineNum">    1433 </span>            : }
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1436 </span>            :     Fill prgnCompId with the component Glyph IDs from pSimpleGlyf.
<span class="lineNum">    1437 </span>            :     Client must allocate space before calling.
<span class="lineNum">    1438 </span>            :     pSimpleGlyf - assumed to point to a composite glyph
<span class="lineNum">    1439 </span>            :     cCompIdTotal - the number of elements in prgnCompId 
<span class="lineNum">    1440 </span>            :     cCompId  - the total number of Glyph IDs stored in prgnCompId
<span class="lineNum">    1441 </span>            :     Return true if successful, false otherwise
<span class="lineNum">    1442 </span>            :         False could indicate a non-composite glyph or the input array was not big enough
<span class="lineNum">    1443 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1444 </span>            : bool GetComponentGlyphIds(const void * pSimpleGlyf, int * prgnCompId, 
<span class="lineNum">    1445 </span>            :         size_t cnCompIdTotal, size_t &amp; cnCompId)
<span class="lineNum">    1446 </span>            : {
<span class="lineNum">    1447 </span>            :     using namespace Sfnt;
<span class="lineNum">    1448 </span>            :     
<span class="lineNum">    1449 </span>            :     if (GlyfContourCount(pSimpleGlyf) &gt;= 0)
<span class="lineNum">    1450 </span>            :         return false;
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :     const Sfnt::SimpleGlyph * pGlyph = reinterpret_cast&lt;const Sfnt::SimpleGlyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1453 </span>            :     // for a composite glyph, the special data begins here
<span class="lineNum">    1454 </span>            :     const uint8 * pbGlyph = reinterpret_cast&lt;const uint8 *&gt;(&amp;pGlyph-&gt;end_pts_of_contours[0]);
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            :     uint16 GlyphFlags;
<span class="lineNum">    1457 </span>            :     size_t iCurrentComp = 0;
<span class="lineNum">    1458 </span>            :     do 
<span class="lineNum">    1459 </span>            :     {
<span class="lineNum">    1460 </span>            :         GlyphFlags = be::swap(*((uint16 *)pbGlyph));
<span class="lineNum">    1461 </span>            :         pbGlyph += sizeof(uint16);
<span class="lineNum">    1462 </span>            :         prgnCompId[iCurrentComp++] = be::swap(*((uint16 *)pbGlyph));
<span class="lineNum">    1463 </span>            :         pbGlyph += sizeof(uint16);
<span class="lineNum">    1464 </span>            :         if (iCurrentComp &gt;= cnCompIdTotal) 
<span class="lineNum">    1465 </span>            :             return false;
<span class="lineNum">    1466 </span>            :         int nOffset = 0;
<span class="lineNum">    1467 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::Arg1Arg2Words ? 4 : 2;
<span class="lineNum">    1468 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveScale ? 2 : 0;
<span class="lineNum">    1469 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveXAndYScale  ? 4 : 0;
<span class="lineNum">    1470 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveTwoByTwo  ? 8 :  0;
<span class="lineNum">    1471 </span>            :         pbGlyph += nOffset;
<span class="lineNum">    1472 </span>            :     } while (GlyphFlags &amp; CompoundGlyph::MoreComponents);
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            :     cnCompId = iCurrentComp;
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :     return true;
<span class="lineNum">    1477 </span>            : }
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1480 </span>            :     Return info on how a component glyph is to be placed
<span class="lineNum">    1481 </span>            :     pSimpleGlyph - assumed to point to a composite glyph
<span class="lineNum">    1482 </span>            :     nCompId - glyph id for component of interest
<span class="lineNum">    1483 </span>            :     bOffset - if true, a &amp; b are the x &amp; y offsets for this component
<span class="lineNum">    1484 </span>            :               if false, b is the point on this component that is attaching to point a on the
<span class="lineNum">    1485 </span>            :                 preceding glyph
<span class="lineNum">    1486 </span>            :     Return true if successful, false otherwise
<span class="lineNum">    1487 </span>            :         False could indicate a non-composite glyph or that component wasn't found
<span class="lineNum">    1488 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1489 </span>            : bool GetComponentPlacement(const void * pSimpleGlyf, int nCompId,
<span class="lineNum">    1490 </span>            :                                     bool fOffset, int &amp; a, int &amp; b)
<span class="lineNum">    1491 </span>            : {
<span class="lineNum">    1492 </span>            :     using namespace Sfnt;
<span class="lineNum">    1493 </span>            :     
<span class="lineNum">    1494 </span>            :     if (GlyfContourCount(pSimpleGlyf) &gt;= 0)
<span class="lineNum">    1495 </span>            :         return false;
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :     const Sfnt::SimpleGlyph * pGlyph = reinterpret_cast&lt;const Sfnt::SimpleGlyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1498 </span>            :     // for a composite glyph, the special data begins here
<span class="lineNum">    1499 </span>            :     const uint8 * pbGlyph = reinterpret_cast&lt;const uint8 *&gt;(&amp;pGlyph-&gt;end_pts_of_contours[0]);
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span>            :     uint16 GlyphFlags;
<span class="lineNum">    1502 </span>            :     do 
<span class="lineNum">    1503 </span>            :     {
<span class="lineNum">    1504 </span>            :         GlyphFlags = be::swap(*((uint16 *)pbGlyph));
<span class="lineNum">    1505 </span>            :         pbGlyph += sizeof(uint16);
<span class="lineNum">    1506 </span>            :         if (be::swap(*((uint16 *)pbGlyph)) == nCompId)
<span class="lineNum">    1507 </span>            :         {
<span class="lineNum">    1508 </span>            :             pbGlyph += sizeof(uint16); // skip over glyph id of component
<span class="lineNum">    1509 </span>            :             fOffset = (GlyphFlags &amp; CompoundGlyph::ArgsAreXYValues) == CompoundGlyph::ArgsAreXYValues;
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            :             if (GlyphFlags &amp; CompoundGlyph::Arg1Arg2Words )
<span class="lineNum">    1512 </span>            :             {
<span class="lineNum">    1513 </span>            :                 a = be::swap(*(int16 *)pbGlyph);
<span class="lineNum">    1514 </span>            :                 pbGlyph += sizeof(int16);
<span class="lineNum">    1515 </span>            :                 b = be::swap(*(int16 *)pbGlyph);
<span class="lineNum">    1516 </span>            :                 pbGlyph += sizeof(int16);
<span class="lineNum">    1517 </span>            :             }
<span class="lineNum">    1518 </span>            :             else
<span class="lineNum">    1519 </span>            :             { // args are signed bytes
<span class="lineNum">    1520 </span>            :                 a = *pbGlyph++;
<span class="lineNum">    1521 </span>            :                 b = *pbGlyph++;
<span class="lineNum">    1522 </span>            :             }
<span class="lineNum">    1523 </span>            :             return true;
<span class="lineNum">    1524 </span>            :         }
<span class="lineNum">    1525 </span>            :         pbGlyph += sizeof(uint16); // skip over glyph id of component
<span class="lineNum">    1526 </span>            :         int nOffset = 0;
<span class="lineNum">    1527 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::Arg1Arg2Words  ? 4 : 2;
<span class="lineNum">    1528 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveScale ? 2 : 0;
<span class="lineNum">    1529 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveXAndYScale  ? 4 : 0;
<span class="lineNum">    1530 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveTwoByTwo  ? 8 :  0;
<span class="lineNum">    1531 </span>            :         pbGlyph += nOffset;
<span class="lineNum">    1532 </span>            :     } while (GlyphFlags &amp; CompoundGlyph::MoreComponents);
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            :     // didn't find requested component
<span class="lineNum">    1535 </span>            :     fOffset = true;
<span class="lineNum">    1536 </span>            :     a = 0;
<span class="lineNum">    1537 </span>            :     b = 0;
<span class="lineNum">    1538 </span>            :     return false;
<span class="lineNum">    1539 </span>            : }
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1542 </span>            :     Return info on how a component glyph is to be transformed
<span class="lineNum">    1543 </span>            :     pSimpleGlyph - assumed to point to a composite glyph
<span class="lineNum">    1544 </span>            :     nCompId - glyph id for component of interest
<span class="lineNum">    1545 </span>            :     flt11, flt11, flt11, flt11 - a 2x2 matrix giving the transform
<span class="lineNum">    1546 </span>            :     bTransOffset - whether to transform the offset from above method 
<span class="lineNum">    1547 </span>            :         The spec is unclear about the meaning of this flag
<span class="lineNum">    1548 </span>            :         Currently - initialize to true for MS rasterizer and false for Mac rasterizer, then
<span class="lineNum">    1549 </span>            :             on return it will indicate whether transform should apply to offset (MSDN CD 10/99)
<span class="lineNum">    1550 </span>            :     Return true if successful, false otherwise
<span class="lineNum">    1551 </span>            :         False could indicate a non-composite glyph or that component wasn't found
<span class="lineNum">    1552 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1553 </span>            : bool GetComponentTransform(const void * pSimpleGlyf, int nCompId, 
<span class="lineNum">    1554 </span>            :                                     float &amp; flt11, float &amp; flt12, float &amp; flt21, float &amp; flt22, 
<span class="lineNum">    1555 </span>            :                                     bool &amp; fTransOffset)
<span class="lineNum">    1556 </span>            : {
<span class="lineNum">    1557 </span>            :     using namespace Sfnt;
<span class="lineNum">    1558 </span>            :     
<span class="lineNum">    1559 </span>            :     if (GlyfContourCount(pSimpleGlyf) &gt;= 0)
<span class="lineNum">    1560 </span>            :         return false;
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :     const Sfnt::SimpleGlyph * pGlyph = reinterpret_cast&lt;const Sfnt::SimpleGlyph *&gt;(pSimpleGlyf);
<span class="lineNum">    1563 </span>            :     // for a composite glyph, the special data begins here
<span class="lineNum">    1564 </span>            :     const uint8 * pbGlyph = reinterpret_cast&lt;const uint8 *&gt;(&amp;pGlyph-&gt;end_pts_of_contours[0]);
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :     uint16 GlyphFlags;
<span class="lineNum">    1567 </span>            :     do 
<span class="lineNum">    1568 </span>            :     {
<span class="lineNum">    1569 </span>            :         GlyphFlags = be::swap(*((uint16 *)pbGlyph));
<span class="lineNum">    1570 </span>            :         pbGlyph += sizeof(uint16);
<span class="lineNum">    1571 </span>            :         if (be::swap(*((uint16 *)pbGlyph)) == nCompId)
<span class="lineNum">    1572 </span>            :         {
<span class="lineNum">    1573 </span>            :             pbGlyph += sizeof(uint16); // skip over glyph id of component
<span class="lineNum">    1574 </span>            :             pbGlyph += GlyphFlags &amp; CompoundGlyph::Arg1Arg2Words  ? 4 : 2; // skip over placement data
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span>            :             if (fTransOffset) // MS rasterizer
<span class="lineNum">    1577 </span>            :                 fTransOffset = !(GlyphFlags &amp; CompoundGlyph::UnscaledOffset); 
<span class="lineNum">    1578 </span>            :             else // Apple rasterizer
<span class="lineNum">    1579 </span>            :                 fTransOffset = (GlyphFlags &amp; CompoundGlyph::ScaledOffset) != 0;
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            :             if (GlyphFlags &amp; CompoundGlyph::HaveScale)
<span class="lineNum">    1582 </span>            :             {
<span class="lineNum">    1583 </span>            :                 flt11 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1584 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1585 </span>            :                 flt12 = 0;
<span class="lineNum">    1586 </span>            :                 flt21 = 0;
<span class="lineNum">    1587 </span>            :                 flt22 = flt11;
<span class="lineNum">    1588 </span>            :             }
<span class="lineNum">    1589 </span>            :             else if (GlyphFlags &amp; CompoundGlyph::HaveXAndYScale)
<span class="lineNum">    1590 </span>            :             {
<span class="lineNum">    1591 </span>            :                 flt11 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1592 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1593 </span>            :                 flt12 = 0;
<span class="lineNum">    1594 </span>            :                 flt21 = 0;
<span class="lineNum">    1595 </span>            :                 flt22 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1596 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1597 </span>            :             }
<span class="lineNum">    1598 </span>            :             else if (GlyphFlags &amp; CompoundGlyph::HaveTwoByTwo)
<span class="lineNum">    1599 </span>            :             {
<span class="lineNum">    1600 </span>            :                 flt11 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1601 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1602 </span>            :                 flt12 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1603 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1604 </span>            :                 flt21 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1605 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1606 </span>            :                 flt22 = fixed_to_float&lt;14&gt;(be::swap(*(uint16 *)pbGlyph));
<span class="lineNum">    1607 </span>            :                 pbGlyph += sizeof(uint16);
<span class="lineNum">    1608 </span>            :             }
<span class="lineNum">    1609 </span>            :             else
<span class="lineNum">    1610 </span>            :             { // identity transform
<span class="lineNum">    1611 </span>            :                 flt11 = 1.0;
<span class="lineNum">    1612 </span>            :                 flt12 = 0.0;
<span class="lineNum">    1613 </span>            :                 flt21 = 0.0;
<span class="lineNum">    1614 </span>            :                 flt22 = 1.0;
<span class="lineNum">    1615 </span>            :             }
<span class="lineNum">    1616 </span>            :             return true;
<span class="lineNum">    1617 </span>            :         }
<span class="lineNum">    1618 </span>            :         pbGlyph += sizeof(uint16); // skip over glyph id of component
<span class="lineNum">    1619 </span>            :         int nOffset = 0;
<span class="lineNum">    1620 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::Arg1Arg2Words  ? 4 : 2;
<span class="lineNum">    1621 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveScale ? 2 : 0;
<span class="lineNum">    1622 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveXAndYScale  ? 4 : 0;
<span class="lineNum">    1623 </span>            :         nOffset += GlyphFlags &amp; CompoundGlyph::HaveTwoByTwo  ? 8 :  0;
<span class="lineNum">    1624 </span>            :         pbGlyph += nOffset;
<span class="lineNum">    1625 </span>            :     } while (GlyphFlags &amp; CompoundGlyph::MoreComponents);
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            :     // didn't find requested component
<span class="lineNum">    1628 </span>            :     fTransOffset = false;
<span class="lineNum">    1629 </span>            :     flt11 = 1;
<span class="lineNum">    1630 </span>            :     flt12 = 0;
<span class="lineNum">    1631 </span>            :     flt21 = 0;
<span class="lineNum">    1632 </span>            :     flt22 = 1;
<span class="lineNum">    1633 </span>            :     return false;
<span class="lineNum">    1634 </span>            : }
<span class="lineNum">    1635 </span>            : #endif
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1638 </span>            :     Return a pointer into the glyf table based on the given tables and Glyph ID
<span class="lineNum">    1639 </span>            :     Since this method doesn't check for spaces, it is good to call IsSpace before using it.
<a name="1640"><span class="lineNum">    1640 </span>            :     Return NULL on error.</a>
<span class="lineNum">    1641 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 : void * GlyfLookup(gid16 nGlyphId, const void * pGlyf, const void * pLoca, </span>
<span class="lineNum">    1643 </span>            :                            size_t lGlyfSize, size_t lLocaSize, const void * pHead)
<span class="lineNum">    1644 </span>            : {
<span class="lineNum">    1645 </span>            :     // test for valid glyph id
<span class="lineNum">    1646 </span>            :     // CheckTable verifies the index_to_loc_format is valid
<span class="lineNum">    1647 </span>            :     
<span class="lineNum">    1648 </span>            :     const Sfnt::FontHeader * pTable 
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         = reinterpret_cast&lt;const Sfnt::FontHeader *&gt;(pHead);</span>
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :     if (be::swap(pTable-&gt;index_to_loc_format) == Sfnt::FontHeader::ShortIndexLocFormat)</span>
<span class="lineNum">    1652 </span>            :     { // loca entries are two bytes (and have been divided by two)
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :         if (nGlyphId &gt;= (lLocaSize &gt;&gt; 1) - 1) // don't allow nGlyphId to access sentinel</span>
<span class="lineNum">    1654 </span>            :         {
<span class="lineNum">    1655 </span>            : //          throw std::out_of_range(&quot;glyph id out of range for font&quot;);
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1657 </span>            :         }
<span class="lineNum">    1658 </span>            :     }
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :     if (be::swap(pTable-&gt;index_to_loc_format) == Sfnt::FontHeader::LongIndexLocFormat)</span>
<span class="lineNum">    1660 </span>            :     { // loca entries are four bytes
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :         if (nGlyphId &gt;= (lLocaSize &gt;&gt; 2) - 1)</span>
<span class="lineNum">    1662 </span>            :         {
<span class="lineNum">    1663 </span>            : //          throw std::out_of_range(&quot;glyph id out of range for font&quot;);
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1665 </span>            :         }
<span class="lineNum">    1666 </span>            :     }
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     long lGlyfOffset = LocaLookup(nGlyphId, pLoca, lLocaSize, pHead);</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     void * pSimpleGlyf = GlyfLookup(pGlyf, lGlyfOffset, lGlyfSize); // invalid loca offset returns null</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :     return pSimpleGlyf;</span>
<span class="lineNum">    1671 </span>            : }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            : #ifdef ALL_TTFUTILS
<span class="lineNum">    1674 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1675 </span>            :     Determine if a particular Glyph ID has any data in the glyf table. If it is white space,
<span class="lineNum">    1676 </span>            :     there will be no glyf data, though there will be metric data in hmtx, etc.
<span class="lineNum">    1677 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1678 </span>            : bool IsSpace(gid16 nGlyphId, const void * pLoca, size_t lLocaSize, const void * pHead)
<span class="lineNum">    1679 </span>            : {
<span class="lineNum">    1680 </span>            :     size_t lGlyfOffset = LocaLookup(nGlyphId, pLoca, lLocaSize, pHead);
<span class="lineNum">    1681 </span>            :     
<span class="lineNum">    1682 </span>            :     // the +1 should always work because there is a sentinel value at the end of the loca table
<span class="lineNum">    1683 </span>            :     size_t lNextGlyfOffset = LocaLookup(nGlyphId + 1, pLoca, lLocaSize, pHead);
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :     return (lNextGlyfOffset - lGlyfOffset) == 0;
<span class="lineNum">    1686 </span>            : }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1689 </span>            :     Determine if a particular Glyph ID is a multi-level composite.
<span class="lineNum">    1690 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1691 </span>            : bool IsDeepComposite(gid16 nGlyphId, const void * pGlyf, const void * pLoca, 
<span class="lineNum">    1692 </span>            :                     size_t lGlyfSize, long lLocaSize, const void * pHead)
<span class="lineNum">    1693 </span>            : {
<span class="lineNum">    1694 </span>            :     if (IsSpace(nGlyphId, pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span>            :     void * pSimpleGlyf = GlyfLookup(nGlyphId, pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1697 </span>            :     if (pSimpleGlyf == NULL)
<span class="lineNum">    1698 </span>            :         return false; // no way to really indicate an error occured here
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            :     if (GlyfContourCount(pSimpleGlyf) &gt;= 0)
<span class="lineNum">    1701 </span>            :         return false;
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            :     int rgnCompId[kMaxGlyphComponents]; // assumes only a limited number of glyph components
<span class="lineNum">    1704 </span>            :     size_t cCompIdTotal = kMaxGlyphComponents;
<span class="lineNum">    1705 </span>            :     size_t cCompId = 0;
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            :     if (!GetComponentGlyphIds(pSimpleGlyf, rgnCompId, cCompIdTotal, cCompId))
<span class="lineNum">    1708 </span>            :         return false;
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :     for (size_t i = 0; i &lt; cCompId; i++)
<span class="lineNum">    1711 </span>            :     {
<span class="lineNum">    1712 </span>            :         pSimpleGlyf = GlyfLookup(static_cast&lt;gid16&gt;(rgnCompId[i]), 
<span class="lineNum">    1713 </span>            :                             pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1714 </span>            :         if (pSimpleGlyf == NULL) {return false;}
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span>            :         if (GlyfContourCount(pSimpleGlyf) &lt; 0)
<span class="lineNum">    1717 </span>            :             return true;
<span class="lineNum">    1718 </span>            :     }
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :     return false;
<span class="lineNum">    1721 </span>            : }
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1724 </span>            :     Get the bounding box coordinates based on the given tables and Glyph ID
<span class="lineNum">    1725 </span>            :     Handles both simple and composite glyphs.
<span class="lineNum">    1726 </span>            :     Return true if successful, false otherwise. On false, all point values will be INT_MIN
<span class="lineNum">    1727 </span>            :         False may indicate a white space glyph
<span class="lineNum">    1728 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1729 </span>            : bool GlyfBox(gid16  nGlyphId, const void * pGlyf, const void * pLoca, 
<span class="lineNum">    1730 </span>            :         size_t lGlyfSize, size_t lLocaSize, const void * pHead, int &amp; xMin, int &amp; yMin, int &amp; xMax, int &amp; yMax)
<span class="lineNum">    1731 </span>            : {
<span class="lineNum">    1732 </span>            :     xMin = yMin = xMax = yMax = INT_MIN;
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :     if (IsSpace(nGlyphId, pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            :     void * pSimpleGlyf = GlyfLookup(nGlyphId, pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1737 </span>            :     if (pSimpleGlyf == NULL) {return false;}
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span>            :     return GlyfBox(pSimpleGlyf, xMin, yMin, xMax, yMax);
<span class="lineNum">    1740 </span>            : }
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1743 </span>            :     Get the number of contours based on the given tables and Glyph ID
<span class="lineNum">    1744 </span>            :     Handles both simple and composite glyphs.
<span class="lineNum">    1745 </span>            :     Return true if successful, false otherwise. On false, cnContours will be INT_MIN
<span class="lineNum">    1746 </span>            :         False may indicate a white space glyph or a multi-level composite glyph.
<span class="lineNum">    1747 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1748 </span>            : bool GlyfContourCount(gid16 nGlyphId, const void * pGlyf, const void * pLoca, 
<span class="lineNum">    1749 </span>            :     size_t lGlyfSize, size_t lLocaSize, const void * pHead, size_t &amp; cnContours)
<span class="lineNum">    1750 </span>            : {
<span class="lineNum">    1751 </span>            :     cnContours = static_cast&lt;size_t&gt;(INT_MIN);
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            :     if (IsSpace(nGlyphId, pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span>            :     void * pSimpleGlyf = GlyfLookup(nGlyphId, pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1756 </span>            :     if (pSimpleGlyf == NULL) {return false;}
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :     int cRtnContours = GlyfContourCount(pSimpleGlyf);
<span class="lineNum">    1759 </span>            :     if (cRtnContours &gt;= 0)
<span class="lineNum">    1760 </span>            :     {
<span class="lineNum">    1761 </span>            :         cnContours = size_t(cRtnContours);
<span class="lineNum">    1762 </span>            :         return true;
<span class="lineNum">    1763 </span>            :     }
<span class="lineNum">    1764 </span>            :         
<span class="lineNum">    1765 </span>            :     //handle composite glyphs
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :     int rgnCompId[kMaxGlyphComponents]; // assumes no glyph will be made of more than 8 components
<span class="lineNum">    1768 </span>            :     size_t cCompIdTotal = kMaxGlyphComponents;
<span class="lineNum">    1769 </span>            :     size_t cCompId = 0;
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            :     if (!GetComponentGlyphIds(pSimpleGlyf, rgnCompId, cCompIdTotal, cCompId))
<span class="lineNum">    1772 </span>            :         return false;
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :     cRtnContours = 0;
<span class="lineNum">    1775 </span>            :     int cTmp = 0;
<span class="lineNum">    1776 </span>            :     for (size_t i = 0; i &lt; cCompId; i++)
<span class="lineNum">    1777 </span>            :     {
<span class="lineNum">    1778 </span>            :         if (IsSpace(static_cast&lt;gid16&gt;(rgnCompId[i]), pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1779 </span>            :         pSimpleGlyf = GlyfLookup(static_cast&lt;gid16&gt;(rgnCompId[i]), 
<span class="lineNum">    1780 </span>            :                                  pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1781 </span>            :         if (pSimpleGlyf == 0) {return false;}
<span class="lineNum">    1782 </span>            :         // return false on multi-level composite
<span class="lineNum">    1783 </span>            :         if ((cTmp = GlyfContourCount(pSimpleGlyf)) &lt; 0) 
<span class="lineNum">    1784 </span>            :             return false;
<span class="lineNum">    1785 </span>            :         cRtnContours += cTmp;
<span class="lineNum">    1786 </span>            :     }
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span>            :     cnContours = size_t(cRtnContours);
<span class="lineNum">    1789 </span>            :     return true;
<span class="lineNum">    1790 </span>            : }
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1793 </span>            :     Get the point numbers for the end points of the glyph contours based on the given tables 
<span class="lineNum">    1794 </span>            :     and Glyph ID
<span class="lineNum">    1795 </span>            :     Handles both simple and composite glyphs.
<span class="lineNum">    1796 </span>            :     cnPoints - count of contours from GlyfContourCount (same as number of end points)
<span class="lineNum">    1797 </span>            :     prgnContourEndPoints - should point to a buffer large enough to hold cnPoints integers
<span class="lineNum">    1798 </span>            :     Return true if successful, false otherwise. On false, all end points are INT_MIN
<span class="lineNum">    1799 </span>            :         False may indicate a white space glyph or a multi-level composite glyph.
<span class="lineNum">    1800 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1801 </span>            : bool GlyfContourEndPoints(gid16 nGlyphId, const void * pGlyf, const void * pLoca, 
<span class="lineNum">    1802 </span>            :     size_t lGlyfSize, size_t lLocaSize, const void * pHead,
<span class="lineNum">    1803 </span>            :     int * prgnContourEndPoint, size_t cnPoints)
<span class="lineNum">    1804 </span>            : {
<span class="lineNum">    1805 </span>            :         memset(prgnContourEndPoint, 0xFF, cnPoints * sizeof(int));
<span class="lineNum">    1806 </span>            :     // std::fill_n(prgnContourEndPoint, cnPoints, INT_MIN);
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span>            :     if (IsSpace(nGlyphId, pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :     void * pSimpleGlyf = GlyfLookup(nGlyphId, pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1811 </span>            :     if (pSimpleGlyf == NULL) {return false;}
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :     int cContours = GlyfContourCount(pSimpleGlyf);
<span class="lineNum">    1814 </span>            :     int cActualPts = 0;
<span class="lineNum">    1815 </span>            :     if (cContours &gt; 0)
<span class="lineNum">    1816 </span>            :         return GlyfContourEndPoints(pSimpleGlyf, prgnContourEndPoint, cnPoints, cActualPts);
<span class="lineNum">    1817 </span>            :     
<span class="lineNum">    1818 </span>            :     // handle composite glyphs
<span class="lineNum">    1819 </span>            :     
<span class="lineNum">    1820 </span>            :     int rgnCompId[kMaxGlyphComponents]; // assumes no glyph will be made of more than 8 components
<span class="lineNum">    1821 </span>            :     size_t cCompIdTotal = kMaxGlyphComponents;
<span class="lineNum">    1822 </span>            :     size_t cCompId = 0;
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :     if (!GetComponentGlyphIds(pSimpleGlyf, rgnCompId, cCompIdTotal, cCompId))
<span class="lineNum">    1825 </span>            :         return false;
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :     int * prgnCurrentEndPoint = prgnContourEndPoint;
<span class="lineNum">    1828 </span>            :     int cCurrentPoints = cnPoints;
<span class="lineNum">    1829 </span>            :     int nPrevPt = 0;
<span class="lineNum">    1830 </span>            :     for (size_t i = 0; i &lt; cCompId; i++)
<span class="lineNum">    1831 </span>            :     {
<span class="lineNum">    1832 </span>            :         if (IsSpace(static_cast&lt;gid16&gt;(rgnCompId[i]), pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1833 </span>            :         pSimpleGlyf = GlyfLookup(static_cast&lt;gid16&gt;(rgnCompId[i]), pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1834 </span>            :         if (pSimpleGlyf == NULL) {return false;}
<span class="lineNum">    1835 </span>            :         // returns false on multi-level composite
<span class="lineNum">    1836 </span>            :         if (!GlyfContourEndPoints(pSimpleGlyf, prgnCurrentEndPoint, cCurrentPoints, cActualPts))
<span class="lineNum">    1837 </span>            :             return false;
<span class="lineNum">    1838 </span>            :         // points in composite are numbered sequentially as components are added
<span class="lineNum">    1839 </span>            :         //  must adjust end point numbers for new point numbers
<span class="lineNum">    1840 </span>            :         for (int j = 0; j &lt; cActualPts; j++)
<span class="lineNum">    1841 </span>            :             prgnCurrentEndPoint[j] += nPrevPt;
<span class="lineNum">    1842 </span>            :         nPrevPt = prgnCurrentEndPoint[cActualPts - 1] + 1;
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            :         prgnCurrentEndPoint += cActualPts;
<span class="lineNum">    1845 </span>            :         cCurrentPoints -= cActualPts;
<span class="lineNum">    1846 </span>            :     }
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            :     return true;
<span class="lineNum">    1849 </span>            : }
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1852 </span>            :     Get the points for a glyph based on the given tables and Glyph ID
<span class="lineNum">    1853 </span>            :     Handles both simple and composite glyphs.
<span class="lineNum">    1854 </span>            :     cnPoints - count of points from largest end point obtained from GlyfContourEndPoints
<span class="lineNum">    1855 </span>            :     prgnX &amp; prgnY - should point to buffers large enough to hold cnPoints integers
<span class="lineNum">    1856 </span>            :         The ranges are parallel so that coordinates for point(n) are found at offset n in 
<span class="lineNum">    1857 </span>            :         both ranges. These points are in absolute coordinates.
<span class="lineNum">    1858 </span>            :     prgfOnCurve - should point to a buffer a large enough to hold cnPoints bytes (bool)
<span class="lineNum">    1859 </span>            :         This range is parallel to the prgnX &amp; prgnY
<span class="lineNum">    1860 </span>            :     Return true if successful, false otherwise. On false, all points may be INT_MIN
<span class="lineNum">    1861 </span>            :         False may indicate a white space glyph, a multi-level composite, or a corrupt font
<span class="lineNum">    1862 </span>            :         It's not clear from the TTF spec when the transforms should be applied. Should the 
<span class="lineNum">    1863 </span>            :         transform be done before or after attachment point calcs? (current code - before) 
<span class="lineNum">    1864 </span>            :         Should the transform be applied to other offsets? (currently - no; however commented 
<span class="lineNum">    1865 </span>            :         out code is in place so that if CompoundGlyph::UnscaledOffset on the MS rasterizer is 
<span class="lineNum">    1866 </span>            :         clear (typical) then yes, and if CompoundGlyph::ScaledOffset on the Apple rasterizer is 
<span class="lineNum">    1867 </span>            :         clear (typical?) then no). See GetComponentTransform.
<span class="lineNum">    1868 </span>            :         It's also unclear where point numbering with attachment poinst starts 
<span class="lineNum">    1869 </span>            :         (currently - first point number is relative to whole glyph, second point number is 
<span class="lineNum">    1870 </span>            :         relative to current glyph). 
<span class="lineNum">    1871 </span>            : ----------------------------------------------------------------------------------------------*/
<span class="lineNum">    1872 </span>            : bool GlyfPoints(gid16 nGlyphId, const void * pGlyf,
<span class="lineNum">    1873 </span>            :         const void * pLoca, size_t lGlyfSize, size_t lLocaSize, const void * pHead,
<span class="lineNum">    1874 </span>            :         const int * /*prgnContourEndPoint*/, size_t /*cnEndPoints*/,
<span class="lineNum">    1875 </span>            :         int * prgnX, int * prgnY, bool * prgfOnCurve, size_t cnPoints)
<span class="lineNum">    1876 </span>            : {
<span class="lineNum">    1877 </span>            :         memset(prgnX, 0x7F, cnPoints * sizeof(int));
<span class="lineNum">    1878 </span>            :         memset(prgnY, 0x7F, cnPoints * sizeof(int));
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :     if (IsSpace(nGlyphId, pLoca, lLocaSize, pHead)) 
<span class="lineNum">    1881 </span>            :         return false;
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :     void * pSimpleGlyf = GlyfLookup(nGlyphId, pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1884 </span>            :     if (pSimpleGlyf == NULL)
<span class="lineNum">    1885 </span>            :         return false;
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span>            :     int cContours = GlyfContourCount(pSimpleGlyf);
<span class="lineNum">    1888 </span>            :     int cActualPts;
<span class="lineNum">    1889 </span>            :     if (cContours &gt; 0)
<span class="lineNum">    1890 </span>            :     {
<span class="lineNum">    1891 </span>            :         if (!GlyfPoints(pSimpleGlyf, prgnX, prgnY, (char *)prgfOnCurve, cnPoints, cActualPts))
<span class="lineNum">    1892 </span>            :             return false;
<span class="lineNum">    1893 </span>            :         CalcAbsolutePoints(prgnX, prgnY, cnPoints);
<span class="lineNum">    1894 </span>            :         SimplifyFlags((char *)prgfOnCurve, cnPoints);
<span class="lineNum">    1895 </span>            :         return true;
<span class="lineNum">    1896 </span>            :     }
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            :     // handle composite glyphs  
<span class="lineNum">    1899 </span>            :     int rgnCompId[kMaxGlyphComponents]; // assumes no glyph will be made of more than 8 components
<span class="lineNum">    1900 </span>            :     size_t cCompIdTotal = kMaxGlyphComponents;
<span class="lineNum">    1901 </span>            :     size_t cCompId = 0;
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span>            :     // this will fail if there are more components than there is room for
<span class="lineNum">    1904 </span>            :     if (!GetComponentGlyphIds(pSimpleGlyf, rgnCompId, cCompIdTotal, cCompId))
<span class="lineNum">    1905 </span>            :         return false;
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span>            :     int * prgnCurrentX = prgnX;
<span class="lineNum">    1908 </span>            :     int * prgnCurrentY = prgnY;
<span class="lineNum">    1909 </span>            :     char * prgbCurrentFlag = (char *)prgfOnCurve; // converting bool to char should be safe
<span class="lineNum">    1910 </span>            :     int cCurrentPoints = cnPoints;
<span class="lineNum">    1911 </span>            :     bool fOffset = true, fTransOff = true;
<span class="lineNum">    1912 </span>            :     int a, b;
<span class="lineNum">    1913 </span>            :     float flt11, flt12, flt21, flt22;
<span class="lineNum">    1914 </span>            :     // int * prgnPrevX = prgnX; // in case first att pt number relative to preceding glyph
<span class="lineNum">    1915 </span>            :     // int * prgnPrevY = prgnY;
<span class="lineNum">    1916 </span>            :     for (size_t i = 0; i &lt; cCompId; i++)
<span class="lineNum">    1917 </span>            :     {
<span class="lineNum">    1918 </span>            :         if (IsSpace(static_cast&lt;gid16&gt;(rgnCompId[i]), pLoca, lLocaSize, pHead)) {return false;}
<span class="lineNum">    1919 </span>            :         void * pCompGlyf = GlyfLookup(static_cast&lt;gid16&gt;(rgnCompId[i]), pGlyf, pLoca, lGlyfSize, lLocaSize, pHead);
<span class="lineNum">    1920 </span>            :         if (pCompGlyf == NULL) {return false;}
<span class="lineNum">    1921 </span>            :         // returns false on multi-level composite
<span class="lineNum">    1922 </span>            :         if (!GlyfPoints(pCompGlyf, prgnCurrentX, prgnCurrentY, prgbCurrentFlag, 
<span class="lineNum">    1923 </span>            :             cCurrentPoints, cActualPts))
<span class="lineNum">    1924 </span>            :             return false; 
<span class="lineNum">    1925 </span>            :         if (!GetComponentPlacement(pSimpleGlyf, rgnCompId[i], fOffset, a, b))
<span class="lineNum">    1926 </span>            :             return false;
<span class="lineNum">    1927 </span>            :         if (!GetComponentTransform(pSimpleGlyf, rgnCompId[i], 
<span class="lineNum">    1928 </span>            :             flt11, flt12, flt21, flt22, fTransOff))
<span class="lineNum">    1929 </span>            :             return false;
<span class="lineNum">    1930 </span>            :         bool fIdTrans = flt11 == 1.0 &amp;&amp; flt12 == 0.0 &amp;&amp; flt21 == 0.0 &amp;&amp; flt22 == 1.0;
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span>            :         // convert points to absolute coordinates
<span class="lineNum">    1933 </span>            :         // do before transform and attachment point placement are applied
<span class="lineNum">    1934 </span>            :         CalcAbsolutePoints(prgnCurrentX, prgnCurrentY, cActualPts);
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            :         // apply transform - see main method note above
<span class="lineNum">    1937 </span>            :         // do before attachment point calcs
<span class="lineNum">    1938 </span>            :         if (!fIdTrans)
<span class="lineNum">    1939 </span>            :             for (int j = 0; j &lt; cActualPts; j++)
<span class="lineNum">    1940 </span>            :             {
<span class="lineNum">    1941 </span>            :                 int x = prgnCurrentX[j]; // store before transform applied
<span class="lineNum">    1942 </span>            :                 int y = prgnCurrentY[j];
<span class="lineNum">    1943 </span>            :                 prgnCurrentX[j] = (int)(x * flt11 + y * flt12);
<span class="lineNum">    1944 </span>            :                 prgnCurrentY[j] = (int)(x * flt21 + y * flt22);
<span class="lineNum">    1945 </span>            :             }
<span class="lineNum">    1946 </span>            :             
<span class="lineNum">    1947 </span>            :         // apply placement - see main method note above
<span class="lineNum">    1948 </span>            :         int nXOff, nYOff;
<span class="lineNum">    1949 </span>            :         if (fOffset) // explicit x &amp; y offsets
<span class="lineNum">    1950 </span>            :         { 
<span class="lineNum">    1951 </span>            :             /* ignore fTransOff for now
<span class="lineNum">    1952 </span>            :             if (fTransOff &amp;&amp; !fIdTrans) 
<span class="lineNum">    1953 </span>            :             {   // transform x &amp; y offsets
<span class="lineNum">    1954 </span>            :                 nXOff = (int)(a * flt11 + b * flt12);
<span class="lineNum">    1955 </span>            :                 nYOff = (int)(a * flt21 + b * flt22);
<span class="lineNum">    1956 </span>            :             }
<span class="lineNum">    1957 </span>            :             else */ 
<span class="lineNum">    1958 </span>            :             { // don't transform offset
<span class="lineNum">    1959 </span>            :                 nXOff = a;
<span class="lineNum">    1960 </span>            :                 nYOff = b;
<span class="lineNum">    1961 </span>            :             }
<span class="lineNum">    1962 </span>            :         }
<span class="lineNum">    1963 </span>            :         else  // attachment points
<span class="lineNum">    1964 </span>            :         {   // in case first point is relative to preceding glyph and second relative to current
<span class="lineNum">    1965 </span>            :             // nXOff = prgnPrevX[a] - prgnCurrentX[b];
<span class="lineNum">    1966 </span>            :             // nYOff = prgnPrevY[a] - prgnCurrentY[b];
<span class="lineNum">    1967 </span>            :             // first point number relative to whole composite, second relative to current glyph
<span class="lineNum">    1968 </span>            :             nXOff = prgnX[a] - prgnCurrentX[b];
<span class="lineNum">    1969 </span>            :             nYOff = prgnY[a] - prgnCurrentY[b];
<span class="lineNum">    1970 </span>            :         }
<span class="lineNum">    1971 </span>            :         for (int j = 0; j &lt; cActualPts; j++)
<span class="lineNum">    1972 </span>            :         {
<span class="lineNum">    1973 </span>            :             prgnCurrentX[j] += nXOff;
<span class="lineNum">    1974 </span>            :             prgnCurrentY[j] += nYOff;
<span class="lineNum">    1975 </span>            :         }
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            :         // prgnPrevX = prgnCurrentX;
<span class="lineNum">    1978 </span>            :         // prgnPrevY = prgnCurrentY;
<span class="lineNum">    1979 </span>            :         prgnCurrentX += cActualPts;
<span class="lineNum">    1980 </span>            :         prgnCurrentY += cActualPts;
<span class="lineNum">    1981 </span>            :         prgbCurrentFlag += cActualPts;
<span class="lineNum">    1982 </span>            :         cCurrentPoints -= cActualPts;
<span class="lineNum">    1983 </span>            :     }
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span>            :     SimplifyFlags((char *)prgfOnCurve, cnPoints);
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span>            :     return true;
<span class="lineNum">    1988 </span>            : }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    1991 </span>            :     Simplify the meaning of flags to just indicate whether point is on-curve or off-curve.
<span class="lineNum">    1992 </span>            : ---------------------------------------------------------------------------------------------*/
<span class="lineNum">    1993 </span>            : bool SimplifyFlags(char * prgbFlags, int cnPoints)
<span class="lineNum">    1994 </span>            : {
<span class="lineNum">    1995 </span>            :     for (int i = 0; i &lt; cnPoints; i++)
<span class="lineNum">    1996 </span>            :         prgbFlags[i] = static_cast&lt;char&gt;(prgbFlags[i] &amp; Sfnt::SimpleGlyph::OnCurve);
<span class="lineNum">    1997 </span>            :     return true;
<span class="lineNum">    1998 </span>            : }
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    2001 </span>            :     Convert relative point coordinates to absolute coordinates
<span class="lineNum">    2002 </span>            :     Points are stored in the font such that they are offsets from one another except for the 
<span class="lineNum">    2003 </span>            :         first point of a glyph.
<span class="lineNum">    2004 </span>            : ---------------------------------------------------------------------------------------------*/
<span class="lineNum">    2005 </span>            : bool CalcAbsolutePoints(int * prgnX, int * prgnY, int cnPoints)
<span class="lineNum">    2006 </span>            : {
<span class="lineNum">    2007 </span>            :     int nX = prgnX[0];
<span class="lineNum">    2008 </span>            :     int nY = prgnY[0];
<span class="lineNum">    2009 </span>            :     for (int i = 1; i &lt; cnPoints; i++)
<span class="lineNum">    2010 </span>            :     {
<span class="lineNum">    2011 </span>            :         prgnX[i] += nX;
<span class="lineNum">    2012 </span>            :         nX = prgnX[i];
<span class="lineNum">    2013 </span>            :         prgnY[i] += nY;
<span class="lineNum">    2014 </span>            :         nY = prgnY[i];
<span class="lineNum">    2015 </span>            :     }
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            :     return true;
<span class="lineNum">    2018 </span>            : }
<span class="lineNum">    2019 </span>            : #endif
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span>            : /*----------------------------------------------------------------------------------------------
<span class="lineNum">    2022 </span>            :     Return the length of the 'name' table in bytes.
<span class="lineNum">    2023 </span>            :     Currently used.
<span class="lineNum">    2024 </span>            : ---------------------------------------------------------------------------------------------*/
<span class="lineNum">    2025 </span>            : #if 0
<span class="lineNum">    2026 </span>            : size_t NameTableLength(const byte * pTable)
<span class="lineNum">    2027 </span>            : {
<span class="lineNum">    2028 </span>            :     byte * pb = (const_cast&lt;byte *&gt;(pTable)) + 2; // skip format
<span class="lineNum">    2029 </span>            :     size_t cRecords = *pb++ &lt;&lt; 8; cRecords += *pb++;
<span class="lineNum">    2030 </span>            :     int dbStringOffset0 = (*pb++) &lt;&lt; 8; dbStringOffset0 += *pb++;
<span class="lineNum">    2031 </span>            :     int dbMaxStringOffset = 0;
<span class="lineNum">    2032 </span>            :     for (size_t irec = 0; irec &lt; cRecords; irec++)
<span class="lineNum">    2033 </span>            :     {
<span class="lineNum">    2034 </span>            :         int nPlatform = (*pb++) &lt;&lt; 8; nPlatform += *pb++;
<span class="lineNum">    2035 </span>            :         int nEncoding = (*pb++) &lt;&lt; 8; nEncoding += *pb++;
<span class="lineNum">    2036 </span>            :         int nLanguage = (*pb++) &lt;&lt; 8; nLanguage += *pb++;
<span class="lineNum">    2037 </span>            :         int nName = (*pb++) &lt;&lt; 8; nName += *pb++;
<span class="lineNum">    2038 </span>            :         int cbStringLen = (*pb++) &lt;&lt; 8; cbStringLen += *pb++;
<span class="lineNum">    2039 </span>            :         int dbStringOffset = (*pb++) &lt;&lt; 8; dbStringOffset += *pb++;
<span class="lineNum">    2040 </span>            :         if (dbMaxStringOffset &lt; dbStringOffset + cbStringLen)
<span class="lineNum">    2041 </span>            :             dbMaxStringOffset = dbStringOffset + cbStringLen;
<span class="lineNum">    2042 </span>            :     }
<span class="lineNum">    2043 </span>            :     return dbStringOffset0 + dbMaxStringOffset;
<span class="lineNum">    2044 </span>            : }
<span class="lineNum">    2045 </span>            : #endif
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span>            : } // end of namespace TtfUtil
<span class="lineNum">    2048 </span>            : } // end of namespace graphite
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

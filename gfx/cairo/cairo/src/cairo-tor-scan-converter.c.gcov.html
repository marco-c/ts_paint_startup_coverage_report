<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/cairo/cairo/src/cairo-tor-scan-converter.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">gfx/cairo/cairo/src</a> - cairo-tor-scan-converter.c<span style="font-size: 80%;"> (source / <a href="cairo-tor-scan-converter.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">730</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */</a>
<span class="lineNum">       2 </span>            : /* glitter-paths - polygon scan converter
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (c) 2008  M Joonas Pihlaja
<span class="lineNum">       5 </span>            :  * Copyright (c) 2007  David Turner
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Permission is hereby granted, free of charge, to any person
<span class="lineNum">       8 </span>            :  * obtaining a copy of this software and associated documentation
<span class="lineNum">       9 </span>            :  * files (the &quot;Software&quot;), to deal in the Software without
<span class="lineNum">      10 </span>            :  * restriction, including without limitation the rights to use,
<span class="lineNum">      11 </span>            :  * copy, modify, merge, publish, distribute, sublicense, and/or sell
<span class="lineNum">      12 </span>            :  * copies of the Software, and to permit persons to whom the
<span class="lineNum">      13 </span>            :  * Software is furnished to do so, subject to the following
<span class="lineNum">      14 </span>            :  * conditions:
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * The above copyright notice and this permission notice shall be
<span class="lineNum">      17 </span>            :  * included in all copies or substantial portions of the Software.
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
<span class="lineNum">      20 </span>            :  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
<span class="lineNum">      21 </span>            :  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
<span class="lineNum">      22 </span>            :  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
<span class="lineNum">      23 </span>            :  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
<span class="lineNum">      24 </span>            :  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      25 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
<span class="lineNum">      26 </span>            :  * OTHER DEALINGS IN THE SOFTWARE.
<span class="lineNum">      27 </span>            :  */
<span class="lineNum">      28 </span>            : /* This is the Glitter paths scan converter incorporated into cairo.
<span class="lineNum">      29 </span>            :  * The source is from commit 734c53237a867a773640bd5b64816249fa1730f8
<span class="lineNum">      30 </span>            :  * of
<span class="lineNum">      31 </span>            :  *
<span class="lineNum">      32 </span>            :  *   http://gitweb.freedesktop.org/?p=users/joonas/glitter-paths
<span class="lineNum">      33 </span>            :  */
<span class="lineNum">      34 </span>            : /* Glitter-paths is a stand alone polygon rasteriser derived from
<span class="lineNum">      35 </span>            :  * David Turner's reimplementation of Tor Anderssons's 15x17
<span class="lineNum">      36 </span>            :  * supersampling rasteriser from the Apparition graphics library.  The
<span class="lineNum">      37 </span>            :  * main new feature here is cheaply choosing per-scan line between
<span class="lineNum">      38 </span>            :  * doing fully analytical coverage computation for an entire row at a
<span class="lineNum">      39 </span>            :  * time vs. using a supersampling approach.
<span class="lineNum">      40 </span>            :  *
<span class="lineNum">      41 </span>            :  * David Turner's code can be found at
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  *   http://david.freetype.org/rasterizer-shootout/raster-comparison-20070813.tar.bz2
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * In particular this file incorporates large parts of ftgrays_tor10.h
<span class="lineNum">      46 </span>            :  * from raster-comparison-20070813.tar.bz2
<span class="lineNum">      47 </span>            :  */
<span class="lineNum">      48 </span>            : /* Overview
<span class="lineNum">      49 </span>            :  *
<span class="lineNum">      50 </span>            :  * A scan converter's basic purpose to take polygon edges and convert
<span class="lineNum">      51 </span>            :  * them into an RLE compressed A8 mask.  This one works in two phases:
<span class="lineNum">      52 </span>            :  * gathering edges and generating spans.
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * 1) As the user feeds the scan converter edges they are vertically
<span class="lineNum">      55 </span>            :  * clipped and bucketted into a _polygon_ data structure.  The edges
<span class="lineNum">      56 </span>            :  * are also snapped from the user's coordinates to the subpixel grid
<span class="lineNum">      57 </span>            :  * coordinates used during scan conversion.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  *     user
<span class="lineNum">      60 </span>            :  *      |
<span class="lineNum">      61 </span>            :  *      | edges
<span class="lineNum">      62 </span>            :  *      V
<span class="lineNum">      63 </span>            :  *    polygon buckets
<span class="lineNum">      64 </span>            :  *
<span class="lineNum">      65 </span>            :  * 2) Generating spans works by performing a vertical sweep of pixel
<span class="lineNum">      66 </span>            :  * rows from top to bottom and maintaining an _active_list_ of edges
<span class="lineNum">      67 </span>            :  * that intersect the row.  From the active list the fill rule
<span class="lineNum">      68 </span>            :  * determines which edges are the left and right edges of the start of
<span class="lineNum">      69 </span>            :  * each span, and their contribution is then accumulated into a pixel
<span class="lineNum">      70 </span>            :  * coverage list (_cell_list_) as coverage deltas.  Once the coverage
<span class="lineNum">      71 </span>            :  * deltas of all edges are known we can form spans of constant pixel
<span class="lineNum">      72 </span>            :  * coverage by summing the deltas during a traversal of the cell list.
<span class="lineNum">      73 </span>            :  * At the end of a pixel row the cell list is sent to a coverage
<span class="lineNum">      74 </span>            :  * blitter for rendering to some target surface.
<span class="lineNum">      75 </span>            :  *
<span class="lineNum">      76 </span>            :  * The pixel coverages are computed by either supersampling the row
<span class="lineNum">      77 </span>            :  * and box filtering a mono rasterisation, or by computing the exact
<span class="lineNum">      78 </span>            :  * coverages of edges in the active list.  The supersampling method is
<span class="lineNum">      79 </span>            :  * used whenever some edge starts or stops within the row or there are
<span class="lineNum">      80 </span>            :  * edge intersections in the row.
<span class="lineNum">      81 </span>            :  *
<span class="lineNum">      82 </span>            :  *   polygon bucket for       \
<span class="lineNum">      83 </span>            :  *   current pixel row        |
<span class="lineNum">      84 </span>            :  *      |                     |
<span class="lineNum">      85 </span>            :  *      | activate new edges  |  Repeat GRID_Y times if we
<span class="lineNum">      86 </span>            :  *      V                     \  are supersampling this row,
<span class="lineNum">      87 </span>            :  *   active list              /  or just once if we're computing
<span class="lineNum">      88 </span>            :  *      |                     |  analytical coverage.
<span class="lineNum">      89 </span>            :  *      | coverage deltas     |
<span class="lineNum">      90 </span>            :  *      V                     |
<span class="lineNum">      91 </span>            :  *   pixel coverage list     /
<span class="lineNum">      92 </span>            :  *      |
<span class="lineNum">      93 </span>            :  *      V
<span class="lineNum">      94 </span>            :  *   coverage blitter
<span class="lineNum">      95 </span>            :  */
<span class="lineNum">      96 </span>            : #include &quot;cairoint.h&quot;
<span class="lineNum">      97 </span>            : #include &quot;cairo-spans-private.h&quot;
<span class="lineNum">      98 </span>            : #include &quot;cairo-error-private.h&quot;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">     101 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">     102 </span>            : #include &lt;string.h&gt;
<span class="lineNum">     103 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">     106 </span>            :  * cairo specific config
<span class="lineNum">     107 </span>            :  */
<span class="lineNum">     108 </span>            : #define I static
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : /* Prefer cairo's status type. */
<span class="lineNum">     111 </span>            : #define GLITTER_HAVE_STATUS_T 1
<span class="lineNum">     112 </span>            : #define GLITTER_STATUS_SUCCESS CAIRO_STATUS_SUCCESS
<span class="lineNum">     113 </span>            : #define GLITTER_STATUS_NO_MEMORY CAIRO_STATUS_NO_MEMORY
<span class="lineNum">     114 </span>            : typedef cairo_status_t glitter_status_t;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : /* The input coordinate scale and the rasterisation grid scales. */
<span class="lineNum">     117 </span>            : #define GLITTER_INPUT_BITS CAIRO_FIXED_FRAC_BITS
<span class="lineNum">     118 </span>            : #define GRID_X_BITS CAIRO_FIXED_FRAC_BITS
<span class="lineNum">     119 </span>            : #define GRID_Y 15
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : /* Set glitter up to use a cairo span renderer to do the coverage
<span class="lineNum">     122 </span>            :  * blitting. */
<span class="lineNum">     123 </span>            : struct pool;
<span class="lineNum">     124 </span>            : struct cell_list;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : static glitter_status_t
<span class="lineNum">     127 </span>            : blit_with_span_renderer(
<span class="lineNum">     128 </span>            :     struct cell_list            *coverages,
<span class="lineNum">     129 </span>            :     cairo_span_renderer_t       *span_renderer,
<span class="lineNum">     130 </span>            :     struct pool                 *span_pool,
<span class="lineNum">     131 </span>            :     int                          y,
<span class="lineNum">     132 </span>            :     int                          height,
<span class="lineNum">     133 </span>            :     int                          xmin,
<span class="lineNum">     134 </span>            :     int                          xmax);
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : static glitter_status_t
<span class="lineNum">     137 </span>            : blit_empty_with_span_renderer (cairo_span_renderer_t *renderer, int y, int height);
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : #define GLITTER_BLIT_COVERAGES_ARGS \
<span class="lineNum">     140 </span>            :         cairo_span_renderer_t *span_renderer, \
<span class="lineNum">     141 </span>            :         struct pool *span_pool
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : #define GLITTER_BLIT_COVERAGES(cells, y, height,xmin, xmax) do {        \
<span class="lineNum">     144 </span>            :     cairo_status_t status = blit_with_span_renderer (cells,             \
<span class="lineNum">     145 </span>            :                                                      span_renderer,     \
<span class="lineNum">     146 </span>            :                                                      span_pool,         \
<span class="lineNum">     147 </span>            :                                                      y, height,         \
<span class="lineNum">     148 </span>            :                                                      xmin, xmax);       \
<span class="lineNum">     149 </span>            :     if (unlikely (status))                                              \
<span class="lineNum">     150 </span>            :         return status;                                                  \
<span class="lineNum">     151 </span>            : } while (0)
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : #define GLITTER_BLIT_COVERAGES_EMPTY(y, height, xmin, xmax) do {                \
<span class="lineNum">     154 </span>            :     cairo_status_t status = blit_empty_with_span_renderer (span_renderer, y, height); \
<span class="lineNum">     155 </span>            :     if (unlikely (status))                                              \
<span class="lineNum">     156 </span>            :         return status;                                                  \
<span class="lineNum">     157 </span>            : } while (0)
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">     160 </span>            :  * glitter-paths.h
<span class="lineNum">     161 </span>            :  */
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /* &quot;Input scaled&quot; numbers are fixed precision reals with multiplier
<span class="lineNum">     164 </span>            :  * 2**GLITTER_INPUT_BITS.  Input coordinates are given to glitter as
<span class="lineNum">     165 </span>            :  * pixel scaled numbers.  These get converted to the internal grid
<span class="lineNum">     166 </span>            :  * scaled numbers as soon as possible. Internal overflow is possible
<span class="lineNum">     167 </span>            :  * if GRID_X/Y inside glitter-paths.c is larger than
<span class="lineNum">     168 </span>            :  * 1&lt;&lt;GLITTER_INPUT_BITS. */
<span class="lineNum">     169 </span>            : #ifndef GLITTER_INPUT_BITS
<span class="lineNum">     170 </span>            : #  define GLITTER_INPUT_BITS 8
<span class="lineNum">     171 </span>            : #endif
<span class="lineNum">     172 </span>            : #define GLITTER_INPUT_SCALE (1&lt;&lt;GLITTER_INPUT_BITS)
<span class="lineNum">     173 </span>            : typedef int glitter_input_scaled_t;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : #if !GLITTER_HAVE_STATUS_T
<span class="lineNum">     176 </span>            : typedef enum {
<span class="lineNum">     177 </span>            :     GLITTER_STATUS_SUCCESS = 0,
<span class="lineNum">     178 </span>            :     GLITTER_STATUS_NO_MEMORY
<span class="lineNum">     179 </span>            : } glitter_status_t;
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : #ifndef I
<span class="lineNum">     183 </span>            : # define I /*static*/
<span class="lineNum">     184 </span>            : #endif
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Opaque type for scan converting. */
<span class="lineNum">     187 </span>            : typedef struct glitter_scan_converter glitter_scan_converter_t;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /* Reset a scan converter to accept polygon edges and set the clip box
<span class="lineNum">     190 </span>            :  * in pixels.  Allocates O(ymax-ymin) bytes of memory.  The clip box
<span class="lineNum">     191 </span>            :  * is set to integer pixel coordinates xmin &lt;= x &lt; xmax, ymin &lt;= y &lt;
<span class="lineNum">     192 </span>            :  * ymax. */
<span class="lineNum">     193 </span>            : I glitter_status_t
<span class="lineNum">     194 </span>            : glitter_scan_converter_reset(
<span class="lineNum">     195 </span>            :     glitter_scan_converter_t *converter,
<span class="lineNum">     196 </span>            :     int xmin, int ymin,
<span class="lineNum">     197 </span>            :     int xmax, int ymax);
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : /* Add a new polygon edge from pixel (x1,y1) to (x2,y2) to the scan
<span class="lineNum">     200 </span>            :  * converter.  The coordinates represent pixel positions scaled by
<span class="lineNum">     201 </span>            :  * 2**GLITTER_PIXEL_BITS.  If this function fails then the scan
<span class="lineNum">     202 </span>            :  * converter should be reset or destroyed.  Dir must be +1 or -1,
<span class="lineNum">     203 </span>            :  * with the latter reversing the orientation of the edge. */
<span class="lineNum">     204 </span>            : I glitter_status_t
<span class="lineNum">     205 </span>            : glitter_scan_converter_add_edge (glitter_scan_converter_t *converter,
<span class="lineNum">     206 </span>            :                                  const cairo_edge_t *edge);
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /* Render the polygon in the scan converter to the given A8 format
<span class="lineNum">     209 </span>            :  * image raster.  Only the pixels accessible as pixels[y*stride+x] for
<span class="lineNum">     210 </span>            :  * x,y inside the clip box are written to, where xmin &lt;= x &lt; xmax,
<span class="lineNum">     211 </span>            :  * ymin &lt;= y &lt; ymax.  The image is assumed to be clear on input.
<span class="lineNum">     212 </span>            :  *
<span class="lineNum">     213 </span>            :  * If nonzero_fill is true then the interior of the polygon is
<span class="lineNum">     214 </span>            :  * computed with the non-zero fill rule.  Otherwise the even-odd fill
<span class="lineNum">     215 </span>            :  * rule is used.
<span class="lineNum">     216 </span>            :  *
<span class="lineNum">     217 </span>            :  * The scan converter must be reset or destroyed after this call. */
<span class="lineNum">     218 </span>            : #ifndef GLITTER_BLIT_COVERAGES_ARGS
<span class="lineNum">     219 </span>            : # define GLITTER_BLIT_COVERAGES_ARGS unsigned char *raster_pixels, long raster_stride
<span class="lineNum">     220 </span>            : #endif
<span class="lineNum">     221 </span>            : I glitter_status_t
<span class="lineNum">     222 </span>            : glitter_scan_converter_render(
<span class="lineNum">     223 </span>            :     glitter_scan_converter_t *converter,
<span class="lineNum">     224 </span>            :     int nonzero_fill,
<span class="lineNum">     225 </span>            :     GLITTER_BLIT_COVERAGES_ARGS);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">     228 </span>            :  * glitter-paths.c: Implementation internal types
<span class="lineNum">     229 </span>            :  */
<span class="lineNum">     230 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">     231 </span>            : #include &lt;string.h&gt;
<span class="lineNum">     232 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /* All polygon coordinates are snapped onto a subsample grid. &quot;Grid
<span class="lineNum">     235 </span>            :  * scaled&quot; numbers are fixed precision reals with multiplier GRID_X or
<span class="lineNum">     236 </span>            :  * GRID_Y. */
<span class="lineNum">     237 </span>            : typedef int grid_scaled_t;
<span class="lineNum">     238 </span>            : typedef int grid_scaled_x_t;
<span class="lineNum">     239 </span>            : typedef int grid_scaled_y_t;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /* Default x/y scale factors.
<span class="lineNum">     242 </span>            :  *  You can either define GRID_X/Y_BITS to get a power-of-two scale
<span class="lineNum">     243 </span>            :  *  or define GRID_X/Y separately. */
<span class="lineNum">     244 </span>            : #if !defined(GRID_X) &amp;&amp; !defined(GRID_X_BITS)
<span class="lineNum">     245 </span>            : #  define GRID_X_BITS 8
<span class="lineNum">     246 </span>            : #endif
<span class="lineNum">     247 </span>            : #if !defined(GRID_Y) &amp;&amp; !defined(GRID_Y_BITS)
<span class="lineNum">     248 </span>            : #  define GRID_Y 15
<span class="lineNum">     249 </span>            : #endif
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : /* Use GRID_X/Y_BITS to define GRID_X/Y if they're available. */
<span class="lineNum">     252 </span>            : #ifdef GRID_X_BITS
<span class="lineNum">     253 </span>            : #  define GRID_X (1 &lt;&lt; GRID_X_BITS)
<span class="lineNum">     254 </span>            : #endif
<span class="lineNum">     255 </span>            : #ifdef GRID_Y_BITS
<span class="lineNum">     256 </span>            : #  define GRID_Y (1 &lt;&lt; GRID_Y_BITS)
<span class="lineNum">     257 </span>            : #endif
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /* The GRID_X_TO_INT_FRAC macro splits a grid scaled coordinate into
<span class="lineNum">     260 </span>            :  * integer and fractional parts. The integer part is floored. */
<span class="lineNum">     261 </span>            : #if defined(GRID_X_TO_INT_FRAC)
<span class="lineNum">     262 </span>            :   /* do nothing */
<span class="lineNum">     263 </span>            : #elif defined(GRID_X_BITS)
<span class="lineNum">     264 </span>            : #  define GRID_X_TO_INT_FRAC(x, i, f) \
<span class="lineNum">     265 </span>            :         _GRID_TO_INT_FRAC_shift(x, i, f, GRID_X_BITS)
<span class="lineNum">     266 </span>            : #else
<span class="lineNum">     267 </span>            : #  define GRID_X_TO_INT_FRAC(x, i, f) \
<span class="lineNum">     268 </span>            :         _GRID_TO_INT_FRAC_general(x, i, f, GRID_X)
<span class="lineNum">     269 </span>            : #endif
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : #define _GRID_TO_INT_FRAC_general(t, i, f, m) do {      \
<span class="lineNum">     272 </span>            :     (i) = (t) / (m);                                    \
<span class="lineNum">     273 </span>            :     (f) = (t) % (m);                                    \
<span class="lineNum">     274 </span>            :     if ((f) &lt; 0) {                                   \
<span class="lineNum">     275 </span>            :         --(i);                                          \
<span class="lineNum">     276 </span>            :         (f) += (m);                                     \
<span class="lineNum">     277 </span>            :     }                                                   \
<span class="lineNum">     278 </span>            : } while (0)
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : #define _GRID_TO_INT_FRAC_shift(t, i, f, b) do {        \
<span class="lineNum">     281 </span>            :     (f) = (t) &amp; ((1 &lt;&lt; (b)) - 1);                     \
<span class="lineNum">     282 </span>            :     (i) = (t) &gt;&gt; (b);                                     \
<span class="lineNum">     283 </span>            : } while (0)
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : /* A grid area is a real in [0,1] scaled by 2*GRID_X*GRID_Y.  We want
<span class="lineNum">     286 </span>            :  * to be able to represent exactly areas of subpixel trapezoids whose
<span class="lineNum">     287 </span>            :  * vertices are given in grid scaled coordinates.  The scale factor
<span class="lineNum">     288 </span>            :  * comes from needing to accurately represent the area 0.5*dx*dy of a
<span class="lineNum">     289 </span>            :  * triangle with base dx and height dy in grid scaled numbers. */
<span class="lineNum">     290 </span>            : typedef int grid_area_t;
<span class="lineNum">     291 </span>            : #define GRID_XY (2*GRID_X*GRID_Y) /* Unit area on the grid. */
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : /* GRID_AREA_TO_ALPHA(area): map [0,GRID_XY] to [0,255]. */
<span class="lineNum">     294 </span>            : #if GRID_XY == 510
<span class="lineNum">     295 </span>            : #  define GRID_AREA_TO_ALPHA(c)   (((c)+1) &gt;&gt; 1)
<span class="lineNum">     296 </span>            : #elif GRID_XY == 255
<span class="lineNum">     297 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (c)
<span class="lineNum">     298 </span>            : #elif GRID_XY == 64
<span class="lineNum">     299 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (((c) &lt;&lt; 2) | -(((c) &amp; 0x40) &gt;&gt; 6))
<span class="lineNum">     300 </span>            : #elif GRID_XY == 128
<span class="lineNum">     301 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  ((((c) &lt;&lt; 1) | -((c) &gt;&gt; 7)) &amp; 255)
<span class="lineNum">     302 </span>            : #elif GRID_XY == 256
<span class="lineNum">     303 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (((c) | -((c) &gt;&gt; 8)) &amp; 255)
<span class="lineNum">     304 </span>            : #elif GRID_XY == 15
<span class="lineNum">     305 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (((c) &lt;&lt; 4) + (c))
<span class="lineNum">     306 </span>            : #elif GRID_XY == 2*256*15
<span class="lineNum">     307 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (((c) + ((c)&lt;&lt;4) + 256) &gt;&gt; 9)
<span class="lineNum">     308 </span>            : #else
<span class="lineNum">     309 </span>            : #  define  GRID_AREA_TO_ALPHA(c)  (((c)*255 + GRID_XY/2) / GRID_XY)
<span class="lineNum">     310 </span>            : #endif
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : #define UNROLL3(x) x x x
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : struct quorem {
<span class="lineNum">     315 </span>            :     int32_t quo;
<span class="lineNum">     316 </span>            :     int32_t rem;
<span class="lineNum">     317 </span>            : };
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : /* Header for a chunk of memory in a memory pool. */
<span class="lineNum">     320 </span>            : struct _pool_chunk {
<span class="lineNum">     321 </span>            :     /* # bytes used in this chunk. */
<span class="lineNum">     322 </span>            :     size_t size;
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :     /* # bytes total in this chunk */
<span class="lineNum">     325 </span>            :     size_t capacity;
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :     /* Pointer to the previous chunk or %NULL if this is the sentinel
<span class="lineNum">     328 </span>            :      * chunk in the pool header. */
<span class="lineNum">     329 </span>            :     struct _pool_chunk *prev_chunk;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     /* Actual data starts here.  Well aligned for pointers. */
<span class="lineNum">     332 </span>            : };
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : /* A memory pool.  This is supposed to be embedded on the stack or
<span class="lineNum">     335 </span>            :  * within some other structure.  It may optionally be followed by an
<span class="lineNum">     336 </span>            :  * embedded array from which requests are fulfilled until
<span class="lineNum">     337 </span>            :  * malloc needs to be called to allocate a first real chunk. */
<span class="lineNum">     338 </span>            : struct pool {
<span class="lineNum">     339 </span>            :     /* Chunk we're allocating from. */
<span class="lineNum">     340 </span>            :     struct _pool_chunk *current;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     /* Free list of previously allocated chunks.  All have &gt;= default
<span class="lineNum">     343 </span>            :      * capacity. */
<span class="lineNum">     344 </span>            :     struct _pool_chunk *first_free;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :     /* The default capacity of a chunk. */
<span class="lineNum">     347 </span>            :     size_t default_capacity;
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     /* Header for the sentinel chunk.  Directly following the pool
<span class="lineNum">     350 </span>            :      * struct should be some space for embedded elements from which
<span class="lineNum">     351 </span>            :      * the sentinel chunk allocates from. */
<span class="lineNum">     352 </span>            :     struct _pool_chunk sentinel[1];
<span class="lineNum">     353 </span>            : };
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : /* A polygon edge. */
<span class="lineNum">     356 </span>            : struct edge {
<span class="lineNum">     357 </span>            :     /* Next in y-bucket or active list. */
<span class="lineNum">     358 </span>            :     struct edge *next;
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :     /* Current x coordinate while the edge is on the active
<span class="lineNum">     361 </span>            :      * list. Initialised to the x coordinate of the top of the
<span class="lineNum">     362 </span>            :      * edge. The quotient is in grid_scaled_x_t units and the
<span class="lineNum">     363 </span>            :      * remainder is mod dy in grid_scaled_y_t units.*/
<span class="lineNum">     364 </span>            :     struct quorem x;
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /* Advance of the current x when moving down a subsample line. */
<span class="lineNum">     367 </span>            :     struct quorem dxdy;
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     /* Advance of the current x when moving down a full pixel
<span class="lineNum">     370 </span>            :      * row. Only initialised when the height of the edge is large
<span class="lineNum">     371 </span>            :      * enough that there's a chance the edge could be stepped by a
<span class="lineNum">     372 </span>            :      * full row's worth of subsample rows at a time. */
<span class="lineNum">     373 </span>            :     struct quorem dxdy_full;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     /* The clipped y of the top of the edge. */
<span class="lineNum">     376 </span>            :     grid_scaled_y_t ytop;
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :     /* y2-y1 after orienting the edge downwards.  */
<span class="lineNum">     379 </span>            :     grid_scaled_y_t dy;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     /* Number of subsample rows remaining to scan convert of this
<span class="lineNum">     382 </span>            :      * edge. */
<span class="lineNum">     383 </span>            :     grid_scaled_y_t height_left;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :     /* Original sign of the edge: +1 for downwards, -1 for upwards
<span class="lineNum">     386 </span>            :      * edges.  */
<span class="lineNum">     387 </span>            :     int dir;
<span class="lineNum">     388 </span>            :     int vertical;
<span class="lineNum">     389 </span>            : };
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : /* Number of subsample rows per y-bucket. Must be GRID_Y. */
<span class="lineNum">     392 </span>            : #define EDGE_Y_BUCKET_HEIGHT GRID_Y
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : #define EDGE_Y_BUCKET_INDEX(y, ymin) (((y) - (ymin))/EDGE_Y_BUCKET_HEIGHT)
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : struct bucket {
<span class="lineNum">     397 </span>            :     /* Unsorted list of edges starting within this bucket. */
<span class="lineNum">     398 </span>            :     struct edge *edges;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :     /* Set to non-zero if there are edges starting strictly within the
<span class="lineNum">     401 </span>            :      * bucket. */
<span class="lineNum">     402 </span>            :     unsigned     have_inside_edges;
<span class="lineNum">     403 </span>            : };
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : /* A collection of sorted and vertically clipped edges of the polygon.
<span class="lineNum">     406 </span>            :  * Edges are moved from the polygon to an active list while scan
<span class="lineNum">     407 </span>            :  * converting. */
<span class="lineNum">     408 </span>            : struct polygon {
<span class="lineNum">     409 </span>            :     /* The clip extents. */
<span class="lineNum">     410 </span>            :     grid_scaled_x_t xmin, xmax;
<span class="lineNum">     411 </span>            :     grid_scaled_y_t ymin, ymax;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :     /* Array of edges all starting in the same bucket.  An edge is put
<span class="lineNum">     414 </span>            :      * into bucket EDGE_BUCKET_INDEX(edge-&gt;ytop, polygon-&gt;ymin) when
<span class="lineNum">     415 </span>            :      * it is added to the polygon. */
<span class="lineNum">     416 </span>            :     struct bucket *y_buckets;
<span class="lineNum">     417 </span>            :     struct bucket  y_buckets_embedded[64];
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :     struct {
<span class="lineNum">     420 </span>            :         struct pool base[1];
<span class="lineNum">     421 </span>            :         struct edge embedded[32];
<span class="lineNum">     422 </span>            :     } edge_pool;
<span class="lineNum">     423 </span>            : };
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            : /* A cell records the effect on pixel coverage of polygon edges
<span class="lineNum">     426 </span>            :  * passing through a pixel.  It contains two accumulators of pixel
<span class="lineNum">     427 </span>            :  * coverage.
<span class="lineNum">     428 </span>            :  *
<span class="lineNum">     429 </span>            :  * Consider the effects of a polygon edge on the coverage of a pixel
<span class="lineNum">     430 </span>            :  * it intersects and that of the following one.  The coverage of the
<span class="lineNum">     431 </span>            :  * following pixel is the height of the edge multiplied by the width
<span class="lineNum">     432 </span>            :  * of the pixel, and the coverage of the pixel itself is the area of
<span class="lineNum">     433 </span>            :  * the trapezoid formed by the edge and the right side of the pixel.
<span class="lineNum">     434 </span>            :  *
<span class="lineNum">     435 </span>            :  * +-----------------------+-----------------------+
<span class="lineNum">     436 </span>            :  * |                       |                       |
<span class="lineNum">     437 </span>            :  * |                       |                       |
<span class="lineNum">     438 </span>            :  * |_______________________|_______________________|
<span class="lineNum">     439 </span>            :  * |   \...................|.......................|\
<span class="lineNum">     440 </span>            :  * |    \..................|.......................| |
<span class="lineNum">     441 </span>            :  * |     \.................|.......................| |
<span class="lineNum">     442 </span>            :  * |      \....covered.....|.......................| |
<span class="lineNum">     443 </span>            :  * |       \....area.......|.......................| } covered height
<span class="lineNum">     444 </span>            :  * |        \..............|.......................| |
<span class="lineNum">     445 </span>            :  * |uncovered\.............|.......................| |
<span class="lineNum">     446 </span>            :  * |  area    \............|.......................| |
<span class="lineNum">     447 </span>            :  * |___________\...........|.......................|/
<span class="lineNum">     448 </span>            :  * |                       |                       |
<span class="lineNum">     449 </span>            :  * |                       |                       |
<span class="lineNum">     450 </span>            :  * |                       |                       |
<span class="lineNum">     451 </span>            :  * +-----------------------+-----------------------+
<span class="lineNum">     452 </span>            :  *
<span class="lineNum">     453 </span>            :  * Since the coverage of the following pixel will always be a multiple
<span class="lineNum">     454 </span>            :  * of the width of the pixel, we can store the height of the covered
<span class="lineNum">     455 </span>            :  * area instead.  The coverage of the pixel itself is the total
<span class="lineNum">     456 </span>            :  * coverage minus the area of the uncovered area to the left of the
<span class="lineNum">     457 </span>            :  * edge.  As it's faster to compute the uncovered area we only store
<span class="lineNum">     458 </span>            :  * that and subtract it from the total coverage later when forming
<span class="lineNum">     459 </span>            :  * spans to blit.
<span class="lineNum">     460 </span>            :  *
<span class="lineNum">     461 </span>            :  * The heights and areas are signed, with left edges of the polygon
<span class="lineNum">     462 </span>            :  * having positive sign and right edges having negative sign.  When
<span class="lineNum">     463 </span>            :  * two edges intersect they swap their left/rightness so their
<span class="lineNum">     464 </span>            :  * contribution above and below the intersection point must be
<span class="lineNum">     465 </span>            :  * computed separately. */
<span class="lineNum">     466 </span>            : struct cell {
<span class="lineNum">     467 </span>            :     struct cell         *next;
<span class="lineNum">     468 </span>            :     int                  x;
<span class="lineNum">     469 </span>            :     grid_area_t          uncovered_area;
<span class="lineNum">     470 </span>            :     grid_scaled_y_t      covered_height;
<span class="lineNum">     471 </span>            : };
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : /* A cell list represents the scan line sparsely as cells ordered by
<span class="lineNum">     474 </span>            :  * ascending x.  It is geared towards scanning the cells in order
<span class="lineNum">     475 </span>            :  * using an internal cursor. */
<span class="lineNum">     476 </span>            : struct cell_list {
<span class="lineNum">     477 </span>            :     /* Points to the left-most cell in the scan line. */
<span class="lineNum">     478 </span>            :     struct cell *head;
<span class="lineNum">     479 </span>            :     /* Sentinel node */
<span class="lineNum">     480 </span>            :     struct cell tail;
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     /* Cursor state for iterating through the cell list.  Points to
<span class="lineNum">     483 </span>            :      * a pointer to the current cell: either &amp;cell_list-&gt;head or the next
<span class="lineNum">     484 </span>            :      * field of the previous cell. */
<span class="lineNum">     485 </span>            :     struct cell **cursor;
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :     /* Cells in the cell list are owned by the cell list and are
<span class="lineNum">     488 </span>            :      * allocated from this pool.  */
<span class="lineNum">     489 </span>            :     struct {
<span class="lineNum">     490 </span>            :         struct pool base[1];
<span class="lineNum">     491 </span>            :         struct cell embedded[32];
<span class="lineNum">     492 </span>            :     } cell_pool;
<span class="lineNum">     493 </span>            : };
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : struct cell_pair {
<span class="lineNum">     496 </span>            :     struct cell *cell1;
<span class="lineNum">     497 </span>            :     struct cell *cell2;
<span class="lineNum">     498 </span>            : };
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : /* The active list contains edges in the current scan line ordered by
<span class="lineNum">     501 </span>            :  * the x-coordinate of the intercept of the edge and the scan line. */
<span class="lineNum">     502 </span>            : struct active_list {
<span class="lineNum">     503 </span>            :     /* Leftmost edge on the current scan line. */
<span class="lineNum">     504 </span>            :     struct edge *head;
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     /* A lower bound on the height of the active edges is used to
<span class="lineNum">     507 </span>            :      * estimate how soon some active edge ends.  We can't advance the
<span class="lineNum">     508 </span>            :      * scan conversion by a full pixel row if an edge ends somewhere
<span class="lineNum">     509 </span>            :      * within it. */
<span class="lineNum">     510 </span>            :     grid_scaled_y_t min_height;
<span class="lineNum">     511 </span>            : };
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : struct glitter_scan_converter {
<span class="lineNum">     514 </span>            :     struct polygon      polygon[1];
<span class="lineNum">     515 </span>            :     struct active_list  active[1];
<span class="lineNum">     516 </span>            :     struct cell_list    coverages[1];
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     /* Clip box. */
<span class="lineNum">     519 </span>            :     grid_scaled_x_t xmin, xmax;
<span class="lineNum">     520 </span>            :     grid_scaled_y_t ymin, ymax;
<span class="lineNum">     521 </span>            : };
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            : /* Compute the floored division a/b. Assumes / and % perform symmetric
<a name="524"><span class="lineNum">     524 </span>            :  * division. */</a>
<span class="lineNum">     525 </span>            : inline static struct quorem
<span class="lineNum">     526 </span><span class="lineNoCov">          0 : floored_divrem(int a, int b)</span>
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span>            :     struct quorem qr;
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     qr.quo = a/b;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     qr.rem = a%b;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     if ((a^b)&lt;0 &amp;&amp; qr.rem) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         qr.quo -= 1;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         qr.rem += b;</span>
<span class="lineNum">     534 </span>            :     }
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     return qr;</span>
<span class="lineNum">     536 </span>            : }
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /* Compute the floored division (x*a)/b. Assumes / and % perform symmetric
<a name="539"><span class="lineNum">     539 </span>            :  * division. */</a>
<span class="lineNum">     540 </span>            : static struct quorem
<span class="lineNum">     541 </span><span class="lineNoCov">          0 : floored_muldivrem(int x, int a, int b)</span>
<span class="lineNum">     542 </span>            : {
<span class="lineNum">     543 </span>            :     struct quorem qr;
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     long long xa = (long long)x*a;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     qr.quo = xa/b;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     qr.rem = xa%b;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     if ((xa&gt;=0) != (b&gt;=0) &amp;&amp; qr.rem) {</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         qr.quo -= 1;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         qr.rem += b;</span>
<span class="lineNum">     550 </span>            :     }
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     return qr;</span>
<span class="lineNum">     552 </span>            : }
<a name="553"><span class="lineNum">     553 </span>            : </a>
<span class="lineNum">     554 </span>            : static void
<span class="lineNum">     555 </span><span class="lineNoCov">          0 : _pool_chunk_init(</span>
<span class="lineNum">     556 </span>            :     struct _pool_chunk *p,
<span class="lineNum">     557 </span>            :     struct _pool_chunk *prev_chunk,
<span class="lineNum">     558 </span>            :     size_t capacity)
<span class="lineNum">     559 </span>            : {
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     p-&gt;prev_chunk = prev_chunk;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     p-&gt;size = 0;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     p-&gt;capacity = capacity;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : }</span>
<a name="564"><span class="lineNum">     564 </span>            : </a>
<span class="lineNum">     565 </span>            : static struct _pool_chunk *
<span class="lineNum">     566 </span><span class="lineNoCov">          0 : _pool_chunk_create(</span>
<span class="lineNum">     567 </span>            :     struct _pool_chunk *prev_chunk,
<span class="lineNum">     568 </span>            :     size_t size)
<span class="lineNum">     569 </span>            : {
<span class="lineNum">     570 </span>            :     struct _pool_chunk *p;
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     size_t size_with_head = size + sizeof(struct _pool_chunk);</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     if (size_with_head &lt; size)</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     p = malloc(size_with_head);</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     if (p)</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         _pool_chunk_init(p, prev_chunk, size);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     return p;</span>
<span class="lineNum">     578 </span>            : }
<a name="579"><span class="lineNum">     579 </span>            : </a>
<span class="lineNum">     580 </span>            : static void
<span class="lineNum">     581 </span><span class="lineNoCov">          0 : pool_init(</span>
<span class="lineNum">     582 </span>            :     struct pool *pool,
<span class="lineNum">     583 </span>            :     size_t default_capacity,
<span class="lineNum">     584 </span>            :     size_t embedded_capacity)
<span class="lineNum">     585 </span>            : {
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     pool-&gt;current = pool-&gt;sentinel;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     pool-&gt;first_free = NULL;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     pool-&gt;default_capacity = default_capacity;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     _pool_chunk_init(pool-&gt;sentinel, NULL, embedded_capacity);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 : }</span>
<a name="591"><span class="lineNum">     591 </span>            : </a>
<span class="lineNum">     592 </span>            : static void
<span class="lineNum">     593 </span><span class="lineNoCov">          0 : pool_fini(struct pool *pool)</span>
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     struct _pool_chunk *p = pool-&gt;current;</span>
<span class="lineNum">     596 </span>            :     do {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         while (NULL != p) {</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :             struct _pool_chunk *prev = p-&gt;prev_chunk;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :             if (p != pool-&gt;sentinel)</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :                 free(p);</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :             p = prev;</span>
<span class="lineNum">     602 </span>            :         }
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         p = pool-&gt;first_free;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         pool-&gt;first_free = NULL;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     } while (NULL != p);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     pool_init(pool, 0, 0);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : /* Satisfy an allocation by first allocating a new large enough chunk
<span class="lineNum">     610 </span>            :  * and adding it to the head of the pool's chunk list. This function
<span class="lineNum">     611 </span>            :  * is called as a fallback if pool_alloc() couldn't do a quick
<a name="612"><span class="lineNum">     612 </span>            :  * allocation from the current chunk in the pool. */</a>
<span class="lineNum">     613 </span>            : static void *
<span class="lineNum">     614 </span><span class="lineNoCov">          0 : _pool_alloc_from_new_chunk(</span>
<span class="lineNum">     615 </span>            :     struct pool *pool,
<span class="lineNum">     616 </span>            :     size_t size)
<span class="lineNum">     617 </span>            : {
<span class="lineNum">     618 </span>            :     struct _pool_chunk *chunk;
<span class="lineNum">     619 </span>            :     void *obj;
<span class="lineNum">     620 </span>            :     size_t capacity;
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :     /* If the allocation is smaller than the default chunk size then
<span class="lineNum">     623 </span>            :      * try getting a chunk off the free list.  Force alloc of a new
<span class="lineNum">     624 </span>            :      * chunk for large requests. */
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     capacity = size;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     chunk = NULL;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     if (size &lt; pool-&gt;default_capacity) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         capacity = pool-&gt;default_capacity;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         chunk = pool-&gt;first_free;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         if (chunk) {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :             pool-&gt;first_free = chunk-&gt;prev_chunk;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :             _pool_chunk_init(chunk, pool-&gt;current, chunk-&gt;capacity);</span>
<span class="lineNum">     633 </span>            :         }
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     if (NULL == chunk) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         chunk = _pool_chunk_create (pool-&gt;current, capacity);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         if (unlikely (NULL == chunk))</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     640 </span>            :     }
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     pool-&gt;current = chunk;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     obj = ((unsigned char*)chunk + sizeof(*chunk) + chunk-&gt;size);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     chunk-&gt;size += size;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     return obj;</span>
<span class="lineNum">     646 </span>            : }
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : /* Allocate size bytes from the pool.  The first allocated address
<span class="lineNum">     649 </span>            :  * returned from a pool is aligned to sizeof(void*).  Subsequent
<span class="lineNum">     650 </span>            :  * addresses will maintain alignment as long as multiples of void* are
<span class="lineNum">     651 </span>            :  * allocated.  Returns the address of a new memory area or %NULL on
<span class="lineNum">     652 </span>            :  * allocation failures.  The pool retains ownership of the returned
<a name="653"><span class="lineNum">     653 </span>            :  * memory. */</a>
<span class="lineNum">     654 </span>            : inline static void *
<span class="lineNum">     655 </span><span class="lineNoCov">          0 : pool_alloc (struct pool *pool, size_t size)</span>
<span class="lineNum">     656 </span>            : {
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     struct _pool_chunk *chunk = pool-&gt;current;</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     if (size &lt;= chunk-&gt;capacity - chunk-&gt;size) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         void *obj = ((unsigned char*)chunk + sizeof(*chunk) + chunk-&gt;size);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         chunk-&gt;size += size;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         return obj;</span>
<span class="lineNum">     663 </span>            :     } else {
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         return _pool_alloc_from_new_chunk(pool, size);</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            : }
<span class="lineNum">     667 </span>            : 
<a name="668"><span class="lineNum">     668 </span>            : /* Relinquish all pool_alloced memory back to the pool. */</a>
<span class="lineNum">     669 </span>            : static void
<span class="lineNum">     670 </span><span class="lineNoCov">          0 : pool_reset (struct pool *pool)</span>
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span>            :     /* Transfer all used chunks to the chunk free list. */
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     struct _pool_chunk *chunk = pool-&gt;current;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     if (chunk != pool-&gt;sentinel) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         while (chunk-&gt;prev_chunk != pool-&gt;sentinel) {</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :             chunk = chunk-&gt;prev_chunk;</span>
<span class="lineNum">     677 </span>            :         }
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         chunk-&gt;prev_chunk = pool-&gt;first_free;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         pool-&gt;first_free = pool-&gt;current;</span>
<span class="lineNum">     680 </span>            :     }
<span class="lineNum">     681 </span>            :     /* Reset the sentinel as the current chunk. */
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     pool-&gt;current = pool-&gt;sentinel;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     pool-&gt;sentinel-&gt;size = 0;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : /* Rewinds the cell list's cursor to the beginning.  After rewinding
<a name="687"><span class="lineNum">     687 </span>            :  * we're good to cell_list_find() the cell any x coordinate. */</a>
<span class="lineNum">     688 </span>            : inline static void
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : cell_list_rewind (struct cell_list *cells)</span>
<span class="lineNum">     690 </span>            : {
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     cells-&gt;cursor = &amp;cells-&gt;head;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     693 </span>            : 
<a name="694"><span class="lineNum">     694 </span>            : /* Rewind the cell list if its cursor has been advanced past x. */</a>
<span class="lineNum">     695 </span>            : inline static void
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : cell_list_maybe_rewind (struct cell_list *cells, int x)</span>
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     struct cell *tail = *cells-&gt;cursor;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     if (tail-&gt;x &gt; x)</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         cell_list_rewind (cells);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 : }</span>
<a name="702"><span class="lineNum">     702 </span>            : </a>
<span class="lineNum">     703 </span>            : static void
<span class="lineNum">     704 </span><span class="lineNoCov">          0 : cell_list_init(struct cell_list *cells)</span>
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     pool_init(cells-&gt;cell_pool.base,</span>
<span class="lineNum">     707 </span>            :               256*sizeof(struct cell),
<span class="lineNum">     708 </span>            :               sizeof(cells-&gt;cell_pool.embedded));
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     cells-&gt;tail.next = NULL;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     cells-&gt;tail.x = INT_MAX;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     cells-&gt;head = &amp;cells-&gt;tail;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     cell_list_rewind (cells);</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 : }</span>
<a name="714"><span class="lineNum">     714 </span>            : </a>
<span class="lineNum">     715 </span>            : static void
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : cell_list_fini(struct cell_list *cells)</span>
<span class="lineNum">     717 </span>            : {
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     pool_fini (cells-&gt;cell_pool.base);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            : /* Empty the cell list.  This is called at the start of every pixel
<a name="722"><span class="lineNum">     722 </span>            :  * row. */</a>
<span class="lineNum">     723 </span>            : inline static void
<span class="lineNum">     724 </span><span class="lineNoCov">          0 : cell_list_reset (struct cell_list *cells)</span>
<span class="lineNum">     725 </span>            : {
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     cell_list_rewind (cells);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     cells-&gt;head = &amp;cells-&gt;tail;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     pool_reset (cells-&gt;cell_pool.base);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 : }</span>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<span class="lineNum">     731 </span>            : static struct cell *
<span class="lineNum">     732 </span><span class="lineNoCov">          0 : cell_list_alloc (struct cell_list *cells,</span>
<span class="lineNum">     733 </span>            :                  struct cell **cursor,
<span class="lineNum">     734 </span>            :                  struct cell *tail,
<span class="lineNum">     735 </span>            :                  int x)
<span class="lineNum">     736 </span>            : {
<span class="lineNum">     737 </span>            :     struct cell *cell;
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     cell = pool_alloc (cells-&gt;cell_pool.base, sizeof (struct cell));</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     if (unlikely (NULL == cell))</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     *cursor = cell;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     cell-&gt;next = tail;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     cell-&gt;x = x;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     cell-&gt;uncovered_area = 0;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     cell-&gt;covered_height = 0;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     return cell;</span>
<span class="lineNum">     749 </span>            : }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : /* Find a cell at the given x-coordinate.  Returns %NULL if a new cell
<span class="lineNum">     752 </span>            :  * needed to be allocated but couldn't be.  Cells must be found with
<span class="lineNum">     753 </span>            :  * non-decreasing x-coordinate until the cell list is rewound using
<span class="lineNum">     754 </span>            :  * cell_list_rewind(). Ownership of the returned cell is retained by
<a name="755"><span class="lineNum">     755 </span>            :  * the cell list. */</a>
<span class="lineNum">     756 </span>            : inline static struct cell *
<span class="lineNum">     757 </span><span class="lineNoCov">          0 : cell_list_find (struct cell_list *cells, int x)</span>
<span class="lineNum">     758 </span>            : {
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     struct cell **cursor = cells-&gt;cursor;</span>
<span class="lineNum">     760 </span>            :     struct cell *tail;
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :     while (1) {
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         UNROLL3({</span>
<span class="lineNum">     764 </span>            :             tail = *cursor;
<span class="lineNum">     765 </span>            :             if (tail-&gt;x &gt;= x) {
<span class="lineNum">     766 </span>            :                 break;
<span class="lineNum">     767 </span>            :             }
<span class="lineNum">     768 </span>            :             cursor = &amp;tail-&gt;next;
<span class="lineNum">     769 </span>            :         });
<span class="lineNum">     770 </span>            :     }
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     cells-&gt;cursor = cursor;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     if (tail-&gt;x == x)</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         return tail;</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     return cell_list_alloc (cells, cursor, tail, x);</span>
<span class="lineNum">     777 </span>            : }
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : /* Find two cells at x1 and x2.  This is exactly equivalent
<span class="lineNum">     780 </span>            :  * to
<span class="lineNum">     781 </span>            :  *
<span class="lineNum">     782 </span>            :  *   pair.cell1 = cell_list_find(cells, x1);
<span class="lineNum">     783 </span>            :  *   pair.cell2 = cell_list_find(cells, x2);
<span class="lineNum">     784 </span>            :  *
<a name="785"><span class="lineNum">     785 </span>            :  * except with less function call overhead. */</a>
<span class="lineNum">     786 </span>            : inline static struct cell_pair
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : cell_list_find_pair(struct cell_list *cells, int x1, int x2)</span>
<span class="lineNum">     788 </span>            : {
<span class="lineNum">     789 </span>            :     struct cell_pair pair;
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     struct cell **cursor = cells-&gt;cursor;</span>
<span class="lineNum">     791 </span>            :     struct cell *cell1;
<span class="lineNum">     792 </span>            :     struct cell *cell2;
<span class="lineNum">     793 </span>            :     struct cell *newcell;
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     /* Find first cell at x1. */
<span class="lineNum">     796 </span>            :     while (1) {
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         UNROLL3({</span>
<span class="lineNum">     798 </span>            :             cell1 = *cursor;
<span class="lineNum">     799 </span>            :             if (cell1-&gt;x &gt; x1)
<span class="lineNum">     800 </span>            :                 break;
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :             if (cell1-&gt;x == x1)
<span class="lineNum">     803 </span>            :                 goto found_first;
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :             cursor = &amp;cell1-&gt;next;
<span class="lineNum">     806 </span>            :         });
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     /* New first cell at x1. */
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     newcell = pool_alloc (cells-&gt;cell_pool.base,</span>
<span class="lineNum">     811 </span>            :                           sizeof (struct cell));
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     if (likely (NULL != newcell)) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         *cursor = newcell;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         newcell-&gt;next = cell1;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         newcell-&gt;x = x1;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         newcell-&gt;uncovered_area = 0;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         newcell-&gt;covered_height = 0;</span>
<span class="lineNum">     818 </span>            :     }
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     cell1 = newcell;</span>
<span class="lineNum">     820 </span>            :  found_first:
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :     /* Find second cell at x2. */
<span class="lineNum">     823 </span>            :     while (1) {
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         UNROLL3({</span>
<span class="lineNum">     825 </span>            :             cell2 = *cursor;
<span class="lineNum">     826 </span>            :             if (cell2-&gt;x &gt; x2)
<span class="lineNum">     827 </span>            :                 break;
<span class="lineNum">     828 </span>            :             if (cell2-&gt;x == x2)
<span class="lineNum">     829 </span>            :                 goto found_second;
<span class="lineNum">     830 </span>            :             cursor = &amp;cell2-&gt;next;
<span class="lineNum">     831 </span>            :         });
<span class="lineNum">     832 </span>            :     }
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     /* New second cell at x2. */
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     newcell = pool_alloc (cells-&gt;cell_pool.base,</span>
<span class="lineNum">     836 </span>            :                          sizeof (struct cell));
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     if (likely (NULL != newcell)) {</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         *cursor = newcell;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         newcell-&gt;next = cell2;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         newcell-&gt;x = x2;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         newcell-&gt;uncovered_area = 0;</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :         newcell-&gt;covered_height = 0;</span>
<span class="lineNum">     843 </span>            :     }
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     cell2 = newcell;</span>
<span class="lineNum">     845 </span>            :  found_second:
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     cells-&gt;cursor = cursor;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     pair.cell1 = cell1;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     pair.cell2 = cell2;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     return pair;</span>
<span class="lineNum">     851 </span>            : }
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : /* Add an unbounded subpixel span covering subpixels &gt;= x to the
<a name="854"><span class="lineNum">     854 </span>            :  * coverage cells. */</a>
<span class="lineNum">     855 </span>            : static glitter_status_t
<span class="lineNum">     856 </span><span class="lineNoCov">          0 : cell_list_add_unbounded_subspan (struct cell_list *cells,</span>
<span class="lineNum">     857 </span>            :                                  grid_scaled_x_t x)
<span class="lineNum">     858 </span>            : {
<span class="lineNum">     859 </span>            :     struct cell *cell;
<span class="lineNum">     860 </span>            :     int ix, fx;
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     GRID_X_TO_INT_FRAC(x, ix, fx);</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     cell = cell_list_find (cells, ix);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     if (likely (cell != NULL)) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :         cell-&gt;uncovered_area += 2*fx;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         cell-&gt;covered_height++;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">     869 </span>            :     }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">     872 </span>            : }
<span class="lineNum">     873 </span>            : 
<a name="874"><span class="lineNum">     874 </span>            : /* Add a subpixel span covering [x1, x2) to the coverage cells. */</a>
<span class="lineNum">     875 </span>            : inline static glitter_status_t
<span class="lineNum">     876 </span><span class="lineNoCov">          0 : cell_list_add_subspan(</span>
<span class="lineNum">     877 </span>            :     struct cell_list *cells,
<span class="lineNum">     878 </span>            :     grid_scaled_x_t x1,
<span class="lineNum">     879 </span>            :     grid_scaled_x_t x2)
<span class="lineNum">     880 </span>            : {
<span class="lineNum">     881 </span>            :     int ix1, fx1;
<span class="lineNum">     882 </span>            :     int ix2, fx2;
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     GRID_X_TO_INT_FRAC(x1, ix1, fx1);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     GRID_X_TO_INT_FRAC(x2, ix2, fx2);</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     if (ix1 != ix2) {</span>
<span class="lineNum">     888 </span>            :         struct cell_pair p;
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         p = cell_list_find_pair(cells, ix1, ix2);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         if (likely (p.cell1 != NULL &amp;&amp; p.cell2 != NULL)) {</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :             p.cell1-&gt;uncovered_area += 2*fx1;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :             ++p.cell1-&gt;covered_height;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :             p.cell2-&gt;uncovered_area -= 2*fx2;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :             --p.cell2-&gt;covered_height;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">     896 </span>            :         }
<span class="lineNum">     897 </span>            :     } else {
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         struct cell *cell = cell_list_find(cells, ix1);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         if (likely (cell != NULL)) {</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :             cell-&gt;uncovered_area += 2*(fx1-fx2);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">     902 </span>            :         }
<span class="lineNum">     903 </span>            :     }
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">     905 </span>            : }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            : /* Adds the analytical coverage of an edge crossing the current pixel
<span class="lineNum">     908 </span>            :  * row to the coverage cells and advances the edge's x position to the
<span class="lineNum">     909 </span>            :  * following row.
<span class="lineNum">     910 </span>            :  *
<span class="lineNum">     911 </span>            :  * This function is only called when we know that during this pixel row:
<span class="lineNum">     912 </span>            :  *
<span class="lineNum">     913 </span>            :  * 1) The relative order of all edges on the active list doesn't
<span class="lineNum">     914 </span>            :  * change.  In particular, no edges intersect within this row to pixel
<span class="lineNum">     915 </span>            :  * precision.
<span class="lineNum">     916 </span>            :  *
<span class="lineNum">     917 </span>            :  * 2) No new edges start in this row.
<span class="lineNum">     918 </span>            :  *
<span class="lineNum">     919 </span>            :  * 3) No existing edges end mid-row.
<span class="lineNum">     920 </span>            :  *
<span class="lineNum">     921 </span>            :  * This function depends on being called with all edges from the
<span class="lineNum">     922 </span>            :  * active list in the order they appear on the list (i.e. with
<a name="923"><span class="lineNum">     923 </span>            :  * non-decreasing x-coordinate.)  */</a>
<span class="lineNum">     924 </span>            : static glitter_status_t
<span class="lineNum">     925 </span><span class="lineNoCov">          0 : cell_list_render_edge(</span>
<span class="lineNum">     926 </span>            :     struct cell_list *cells,
<span class="lineNum">     927 </span>            :     struct edge *edge,
<span class="lineNum">     928 </span>            :     int sign)
<span class="lineNum">     929 </span>            : {
<span class="lineNum">     930 </span>            :     grid_scaled_y_t y1, y2, dy;
<span class="lineNum">     931 </span>            :     grid_scaled_x_t dx;
<span class="lineNum">     932 </span>            :     int ix1, ix2;
<span class="lineNum">     933 </span>            :     grid_scaled_x_t fx1, fx2;
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     struct quorem x1 = edge-&gt;x;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     struct quorem x2 = x1;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     if (! edge-&gt;vertical) {</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         x2.quo += edge-&gt;dxdy_full.quo;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         x2.rem += edge-&gt;dxdy_full.rem;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         if (x2.rem &gt;= 0) {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :             ++x2.quo;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :             x2.rem -= edge-&gt;dy;</span>
<span class="lineNum">     944 </span>            :         }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         edge-&gt;x = x2;</span>
<span class="lineNum">     947 </span>            :     }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     GRID_X_TO_INT_FRAC(x1.quo, ix1, fx1);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     GRID_X_TO_INT_FRAC(x2.quo, ix2, fx2);</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :     /* Edge is entirely within a column? */
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if (ix1 == ix2) {</span>
<span class="lineNum">     954 </span>            :         /* We always know that ix1 is &gt;= the cell list cursor in this
<span class="lineNum">     955 </span>            :          * case due to the no-intersections precondition.  */
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         struct cell *cell = cell_list_find(cells, ix1);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         if (unlikely (NULL == cell))</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         cell-&gt;covered_height += sign*GRID_Y;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         cell-&gt;uncovered_area += sign*(fx1 + fx2)*GRID_Y;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">     963 </span>            :     }
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            :     /* Orient the edge left-to-right. */
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     dx = x2.quo - x1.quo;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     if (dx &gt;= 0) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         y1 = 0;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         y2 = GRID_Y;</span>
<span class="lineNum">     970 </span>            :     } else {
<span class="lineNum">     971 </span>            :         int tmp;
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         tmp = ix1; ix1 = ix2; ix2 = tmp;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         tmp = fx1; fx1 = fx2; fx2 = tmp;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         dx = -dx;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         sign = -sign;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :         y1 = GRID_Y;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         y2 = 0;</span>
<span class="lineNum">     978 </span>            :     }
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     dy = y2 - y1;</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            :     /* Add coverage for all pixels [ix1,ix2] on this row crossed
<span class="lineNum">     982 </span>            :      * by the edge. */
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span>            :         struct cell_pair pair;
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :         struct quorem y = floored_divrem((GRID_X - fx1)*dy, dx);</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            :         /* When rendering a previous edge on the active list we may
<span class="lineNum">     988 </span>            :          * advance the cell list cursor past the leftmost pixel of the
<span class="lineNum">     989 </span>            :          * current edge even though the two edges don't intersect.
<span class="lineNum">     990 </span>            :          * e.g. consider two edges going down and rightwards:
<span class="lineNum">     991 </span>            :          *
<span class="lineNum">     992 </span>            :          *  --\_+---\_+-----+-----+----
<span class="lineNum">     993 </span>            :          *      \_    \_    |     |
<span class="lineNum">     994 </span>            :          *      | \_  | \_  |     |
<span class="lineNum">     995 </span>            :          *      |   \_|   \_|     |
<span class="lineNum">     996 </span>            :          *      |     \_    \_    |
<span class="lineNum">     997 </span>            :          *  ----+-----+-\---+-\---+----
<span class="lineNum">     998 </span>            :          *
<span class="lineNum">     999 </span>            :          * The left edge touches cells past the starting cell of the
<span class="lineNum">    1000 </span>            :          * right edge.  Fortunately such cases are rare.
<span class="lineNum">    1001 </span>            :          *
<span class="lineNum">    1002 </span>            :          * The rewinding is never necessary if the current edge stays
<span class="lineNum">    1003 </span>            :          * within a single column because we've checked before calling
<span class="lineNum">    1004 </span>            :          * this function that the active list order won't change. */
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         cell_list_maybe_rewind(cells, ix1);</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         pair = cell_list_find_pair(cells, ix1, ix1+1);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :         if (unlikely (!pair.cell1 || !pair.cell2))</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         pair.cell1-&gt;uncovered_area += sign*y.quo*(GRID_X + fx1);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         pair.cell1-&gt;covered_height += sign*y.quo;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         y.quo += y1;</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         if (ix1+1 &lt; ix2) {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :             struct quorem dydx_full = floored_divrem(GRID_X*dy, dx);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :             struct cell *cell = pair.cell2;</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :             ++ix1;</span>
<span class="lineNum">    1020 </span>            :             do {
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                 grid_scaled_y_t y_skip = dydx_full.quo;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                 y.rem += dydx_full.rem;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                 if (y.rem &gt;= dx) {</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                     ++y_skip;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                     y.rem -= dx;</span>
<span class="lineNum">    1026 </span>            :                 }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                 y.quo += y_skip;</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                 y_skip *= sign;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                 cell-&gt;uncovered_area += y_skip*GRID_X;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                 cell-&gt;covered_height += y_skip;</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                 ++ix1;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                 cell = cell_list_find(cells, ix1);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                 if (unlikely (NULL == cell))</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                     return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :             } while (ix1 != ix2);</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :             pair.cell2 = cell;</span>
<span class="lineNum">    1041 </span>            :         }
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         pair.cell2-&gt;uncovered_area += sign*(y2 - y.quo)*fx2;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :         pair.cell2-&gt;covered_height += sign*(y2 - y.quo);</span>
<span class="lineNum">    1044 </span>            :     }
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1047 </span>            : }
<a name="1048"><span class="lineNum">    1048 </span>            : </a>
<span class="lineNum">    1049 </span>            : static void
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 : polygon_init (struct polygon *polygon)</span>
<span class="lineNum">    1051 </span>            : {
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     polygon-&gt;ymin = polygon-&gt;ymax = 0;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     polygon-&gt;xmin = polygon-&gt;xmax = 0;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     polygon-&gt;y_buckets = polygon-&gt;y_buckets_embedded;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     pool_init (polygon-&gt;edge_pool.base,</span>
<span class="lineNum">    1056 </span>            :                8192 - sizeof (struct _pool_chunk),
<span class="lineNum">    1057 </span>            :                sizeof (polygon-&gt;edge_pool.embedded));
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 : }</span>
<a name="1059"><span class="lineNum">    1059 </span>            : </a>
<span class="lineNum">    1060 </span>            : static void
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 : polygon_fini (struct polygon *polygon)</span>
<span class="lineNum">    1062 </span>            : {
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     if (polygon-&gt;y_buckets != polygon-&gt;y_buckets_embedded)</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         free (polygon-&gt;y_buckets);</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     pool_fini (polygon-&gt;edge_pool.base);</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            : /* Empties the polygon of all edges. The polygon is then prepared to
<span class="lineNum">    1070 </span>            :  * receive new edges and clip them to the vertical range
<a name="1071"><span class="lineNum">    1071 </span>            :  * [ymin,ymax). */</a>
<span class="lineNum">    1072 </span>            : static glitter_status_t
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 : polygon_reset (struct polygon *polygon,</span>
<span class="lineNum">    1074 </span>            :                grid_scaled_x_t xmin,
<span class="lineNum">    1075 </span>            :                grid_scaled_x_t xmax,
<span class="lineNum">    1076 </span>            :                grid_scaled_y_t ymin,
<span class="lineNum">    1077 </span>            :                grid_scaled_y_t ymax)
<span class="lineNum">    1078 </span>            : {
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     unsigned h = ymax - ymin;</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     unsigned num_buckets = EDGE_Y_BUCKET_INDEX(ymax + EDGE_Y_BUCKET_HEIGHT-1,</span>
<span class="lineNum">    1081 </span>            :                                                ymin);
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     pool_reset(polygon-&gt;edge_pool.base);</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     if (unlikely (h &gt; 0x7FFFFFFFU - EDGE_Y_BUCKET_HEIGHT))</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         goto bail_no_mem; /* even if you could, you wouldn't want to. */</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     if (polygon-&gt;y_buckets != polygon-&gt;y_buckets_embedded)</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         free (polygon-&gt;y_buckets);</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     polygon-&gt;y_buckets =  polygon-&gt;y_buckets_embedded;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     if (num_buckets &gt; ARRAY_LENGTH (polygon-&gt;y_buckets_embedded)) {</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         polygon-&gt;y_buckets = _cairo_malloc_ab (num_buckets,</span>
<span class="lineNum">    1094 </span>            :                                                sizeof (struct bucket));
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         if (unlikely (NULL == polygon-&gt;y_buckets))</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :             goto bail_no_mem;</span>
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     memset (polygon-&gt;y_buckets, 0, num_buckets * sizeof (struct bucket));</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     polygon-&gt;ymin = ymin;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     polygon-&gt;ymax = ymax;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     polygon-&gt;xmin = xmin;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     polygon-&gt;xmax = xmax;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            :  bail_no_mem:
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     polygon-&gt;ymin = 0;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     polygon-&gt;ymax = 0;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">    1110 </span>            : }
<a name="1111"><span class="lineNum">    1111 </span>            : </a>
<span class="lineNum">    1112 </span>            : static void
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 : _polygon_insert_edge_into_its_y_bucket(</span>
<span class="lineNum">    1114 </span>            :     struct polygon *polygon,
<span class="lineNum">    1115 </span>            :     struct edge *e)
<span class="lineNum">    1116 </span>            : {
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     unsigned j = e-&gt;ytop - polygon-&gt;ymin;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     unsigned ix = j / EDGE_Y_BUCKET_HEIGHT;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     unsigned offset = j % EDGE_Y_BUCKET_HEIGHT;</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     struct edge **ptail = &amp;polygon-&gt;y_buckets[ix].edges;</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     e-&gt;next = *ptail;</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     *ptail = e;</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     polygon-&gt;y_buckets[ix].have_inside_edges |= offset;</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : }</span>
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<span class="lineNum">    1126 </span>            : inline static glitter_status_t
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 : polygon_add_edge (struct polygon *polygon,</span>
<span class="lineNum">    1128 </span>            :                   const cairo_edge_t *edge)
<span class="lineNum">    1129 </span>            : {
<span class="lineNum">    1130 </span>            :     struct edge *e;
<span class="lineNum">    1131 </span>            :     grid_scaled_x_t dx;
<span class="lineNum">    1132 </span>            :     grid_scaled_y_t dy;
<span class="lineNum">    1133 </span>            :     grid_scaled_y_t ytop, ybot;
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     grid_scaled_y_t ymin = polygon-&gt;ymin;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     grid_scaled_y_t ymax = polygon-&gt;ymax;</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     assert (edge-&gt;bottom &gt; edge-&gt;top);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     if (unlikely (edge-&gt;top &gt;= ymax || edge-&gt;bottom &lt;= ymin))</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     e = pool_alloc (polygon-&gt;edge_pool.base, sizeof (struct edge));</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :     if (unlikely (NULL == e))</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :     dx = edge-&gt;line.p2.x - edge-&gt;line.p1.x;</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :     dy = edge-&gt;line.p2.y - edge-&gt;line.p1.y;</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     e-&gt;dy = dy;</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :     e-&gt;dir = edge-&gt;dir;</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     ytop = edge-&gt;top &gt;= ymin ? edge-&gt;top : ymin;</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     ybot = edge-&gt;bottom &lt;= ymax ? edge-&gt;bottom : ymax;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     e-&gt;ytop = ytop;</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     e-&gt;height_left = ybot - ytop;</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     if (dx == 0) {</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         e-&gt;vertical = TRUE;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         e-&gt;x.quo = edge-&gt;line.p1.x;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         e-&gt;x.rem = 0;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         e-&gt;dxdy.quo = 0;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         e-&gt;dxdy.rem = 0;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         e-&gt;dxdy_full.quo = 0;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         e-&gt;dxdy_full.rem = 0;</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :         /* Drop edges to the right of the clip extents. */
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         if (e-&gt;x.quo &gt;= polygon-&gt;xmax)</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :         /* Offset vertical edges at the left side of the clip extents
<span class="lineNum">    1170 </span>            :          * to just shy of the left side.  We depend on this when
<span class="lineNum">    1171 </span>            :          * checking for possible intersections within the clip
<span class="lineNum">    1172 </span>            :          * rectangle. */
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         if (e-&gt;x.quo &lt;= polygon-&gt;xmin) {</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :             e-&gt;x.quo = polygon-&gt;xmin - 1;</span>
<span class="lineNum">    1175 </span>            :         }
<span class="lineNum">    1176 </span>            :     } else {
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         e-&gt;vertical = FALSE;</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         e-&gt;dxdy = floored_divrem (dx, dy);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         if (ytop == edge-&gt;line.p1.y) {</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :             e-&gt;x.quo = edge-&gt;line.p1.x;</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :             e-&gt;x.rem = 0;</span>
<span class="lineNum">    1182 </span>            :         } else {
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :             e-&gt;x = floored_muldivrem (ytop - edge-&gt;line.p1.y, dx, dy);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :             e-&gt;x.quo += edge-&gt;line.p1.x;</span>
<span class="lineNum">    1185 </span>            :         }
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         if (e-&gt;x.quo &gt;= polygon-&gt;xmax &amp;&amp; e-&gt;dxdy.quo &gt;= 0)</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :             return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :         if (e-&gt;height_left &gt;= GRID_Y) {</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             e-&gt;dxdy_full = floored_muldivrem (GRID_Y, dx, dy);</span>
<span class="lineNum">    1192 </span>            :         } else {
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :             e-&gt;dxdy_full.quo = 0;</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :             e-&gt;dxdy_full.rem = 0;</span>
<span class="lineNum">    1195 </span>            :         }
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     _polygon_insert_edge_into_its_y_bucket (polygon, e);</span>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     e-&gt;x.rem -= dy;          /* Bias the remainder for faster</span>
<span class="lineNum">    1201 </span>            :                                  * edge advancement. */
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1203 </span>            : }
<a name="1204"><span class="lineNum">    1204 </span>            : </a>
<span class="lineNum">    1205 </span>            : static void
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 : active_list_reset (struct active_list *active)</span>
<span class="lineNum">    1207 </span>            : {
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     active-&gt;head = NULL;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     active-&gt;min_height = 0;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 : }</span>
<a name="1211"><span class="lineNum">    1211 </span>            : </a>
<span class="lineNum">    1212 </span>            : static void
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 : active_list_init(struct active_list *active)</span>
<span class="lineNum">    1214 </span>            : {
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     active_list_reset(active);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            : /*
<span class="lineNum">    1219 </span>            :  * Merge two sorted edge lists.
<span class="lineNum">    1220 </span>            :  * Input:
<span class="lineNum">    1221 </span>            :  *  - head_a: The head of the first list.
<span class="lineNum">    1222 </span>            :  *  - head_b: The head of the second list; head_b cannot be NULL.
<span class="lineNum">    1223 </span>            :  * Output:
<span class="lineNum">    1224 </span>            :  * Returns the head of the merged list.
<span class="lineNum">    1225 </span>            :  *
<span class="lineNum">    1226 </span>            :  * Implementation notes:
<span class="lineNum">    1227 </span>            :  * To make it fast (in particular, to reduce to an insertion sort whenever
<span class="lineNum">    1228 </span>            :  * one of the two input lists only has a single element) we iterate through
<span class="lineNum">    1229 </span>            :  * a list until its head becomes greater than the head of the other list,
<span class="lineNum">    1230 </span>            :  * then we switch their roles. As soon as one of the two lists is empty, we
<span class="lineNum">    1231 </span>            :  * just attach the other one to the current list and exit.
<span class="lineNum">    1232 </span>            :  * Writes to memory are only needed to &quot;switch&quot; lists (as it also requires
<span class="lineNum">    1233 </span>            :  * attaching to the output list the list which we will be iterating next) and
<span class="lineNum">    1234 </span>            :  * to attach the last non-empty list.
<a name="1235"><span class="lineNum">    1235 </span>            :  */</a>
<span class="lineNum">    1236 </span>            : static struct edge *
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : merge_sorted_edges (struct edge *head_a, struct edge *head_b)</span>
<span class="lineNum">    1238 </span>            : {
<span class="lineNum">    1239 </span>            :     struct edge *head, **next;
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     head = head_a;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     next = &amp;head;</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            :     while (1) {
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :         while (head_a != NULL &amp;&amp; head_a-&gt;x.quo &lt;= head_b-&gt;x.quo) {</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :             next = &amp;head_a-&gt;next;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :             head_a = head_a-&gt;next;</span>
<span class="lineNum">    1248 </span>            :         }
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :         *next = head_b;</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         if (head_a == NULL)</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :             return head;</span>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         while (head_b != NULL &amp;&amp; head_b-&gt;x.quo &lt;= head_a-&gt;x.quo) {</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :             next = &amp;head_b-&gt;next;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             head_b = head_b-&gt;next;</span>
<span class="lineNum">    1257 </span>            :         }
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         *next = head_a;</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         if (head_b == NULL)</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             return head;</span>
<span class="lineNum">    1262 </span>            :     }
<span class="lineNum">    1263 </span>            : }
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            : /*
<span class="lineNum">    1266 </span>            :  * Sort (part of) a list.
<span class="lineNum">    1267 </span>            :  * Input:
<span class="lineNum">    1268 </span>            :  *  - list: The list to be sorted; list cannot be NULL.
<span class="lineNum">    1269 </span>            :  *  - limit: Recursion limit.
<span class="lineNum">    1270 </span>            :  * Output:
<span class="lineNum">    1271 </span>            :  *  - head_out: The head of the sorted list containing the first 2^(level+1) elements of the
<span class="lineNum">    1272 </span>            :  *              input list; if the input list has fewer elements, head_out be a sorted list
<span class="lineNum">    1273 </span>            :  *              containing all the elements of the input list.
<span class="lineNum">    1274 </span>            :  * Returns the head of the list of unprocessed elements (NULL if the sorted list contains
<span class="lineNum">    1275 </span>            :  * all the elements of the input list).
<span class="lineNum">    1276 </span>            :  *
<span class="lineNum">    1277 </span>            :  * Implementation notes:
<span class="lineNum">    1278 </span>            :  * Special case single element list, unroll/inline the sorting of the first two elements.
<span class="lineNum">    1279 </span>            :  * Some tail recursion is used since we iterate on the bottom-up solution of the problem
<span class="lineNum">    1280 </span>            :  * (we start with a small sorted list and keep merging other lists of the same size to it).
<a name="1281"><span class="lineNum">    1281 </span>            :  */</a>
<span class="lineNum">    1282 </span>            : static struct edge *
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 : sort_edges (struct edge  *list,</span>
<span class="lineNum">    1284 </span>            :             unsigned int  level,
<span class="lineNum">    1285 </span>            :             struct edge **head_out)
<span class="lineNum">    1286 </span>            : {
<span class="lineNum">    1287 </span>            :     struct edge *head_other, *remaining;
<span class="lineNum">    1288 </span>            :     unsigned int i;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     head_other = list-&gt;next;</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span>            :     /* Single element list -&gt; return */
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     if (head_other == NULL) {</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :         *head_out = list;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1296 </span>            :     }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :     /* Unroll the first iteration of the following loop (halves the number of calls to merge_sorted_edges):
<span class="lineNum">    1299 </span>            :      *  - Initialize remaining to be the list containing the elements after the second in the input list.
<span class="lineNum">    1300 </span>            :      *  - Initialize *head_out to be the sorted list containing the first two element.
<span class="lineNum">    1301 </span>            :      */
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     remaining = head_other-&gt;next;</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     if (list-&gt;x.quo &lt;= head_other-&gt;x.quo) {</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :         *head_out = list;</span>
<span class="lineNum">    1305 </span>            :         /* list-&gt;next = head_other; */ /* The input list is already like this. */
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         head_other-&gt;next = NULL;</span>
<span class="lineNum">    1307 </span>            :     } else {
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :         *head_out = head_other;</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :         head_other-&gt;next = list;</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         list-&gt;next = NULL;</span>
<span class="lineNum">    1311 </span>            :     }
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; level &amp;&amp; remaining; i++) {</span>
<span class="lineNum">    1314 </span>            :         /* Extract a sorted list of the same size as *head_out
<span class="lineNum">    1315 </span>            :          * (2^(i+1) elements) from the list of remaining elements. */
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         remaining = sort_edges (remaining, i, &amp;head_other);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         *head_out = merge_sorted_edges (*head_out, head_other);</span>
<span class="lineNum">    1318 </span>            :     }
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :     /* *head_out now contains (at most) 2^(level+1) elements. */
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     return remaining;</span>
<span class="lineNum">    1323 </span>            : }
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : /* Test if the edges on the active list can be safely advanced by a
<a name="1326"><span class="lineNum">    1326 </span>            :  * full row without intersections or any edges ending. */</a>
<span class="lineNum">    1327 </span>            : inline static int
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 : active_list_can_step_full_row (struct active_list *active,</span>
<span class="lineNum">    1329 </span>            :                                grid_scaled_x_t     xmin)
<span class="lineNum">    1330 </span>            : {
<span class="lineNum">    1331 </span>            :     const struct edge *e;
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :     grid_scaled_x_t prev_x = INT_MIN;</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            :     /* Recomputes the minimum height of all edges on the active
<span class="lineNum">    1335 </span>            :      * list if we have been dropping edges. */
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     if (active-&gt;min_height &lt;= 0) {</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         int min_height = INT_MAX;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :         e = active-&gt;head;</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         while (NULL != e) {</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :             if (e-&gt;height_left &lt; min_height)</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                 min_height = e-&gt;height_left;</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :             e = e-&gt;next;</span>
<span class="lineNum">    1344 </span>            :         }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :         active-&gt;min_height = min_height;</span>
<span class="lineNum">    1347 </span>            :     }
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     if (active-&gt;min_height &lt; GRID_Y)</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :     /* Check for intersections as no edges end during the next row. */
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     e = active-&gt;head;</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :     while (NULL != e) {</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :         struct quorem x = e-&gt;x;</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :         if (! e-&gt;vertical) {</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :             x.quo += e-&gt;dxdy_full.quo;</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :             x.rem += e-&gt;dxdy_full.rem;</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :             if (x.rem &gt;= 0)</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :                 ++x.quo;</span>
<span class="lineNum">    1362 </span>            :         }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :         /* There's may be an intersection if the edge sort order might
<span class="lineNum">    1365 </span>            :          * change. */
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :         if (x.quo &lt;= prev_x) {</span>
<span class="lineNum">    1367 </span>            :             /* Ignore intersections to the left of the clip extents.
<span class="lineNum">    1368 </span>            :              * This assumes that all vertical edges on or at the left
<span class="lineNum">    1369 </span>            :              * side of the clip rectangle have been shifted slightly
<span class="lineNum">    1370 </span>            :              * to the left in polygon_add_edge(). */
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :             if (prev_x &gt;= xmin || x.quo &gt;= xmin || e-&gt;x.quo &gt;= xmin)</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1373 </span>            :         }
<span class="lineNum">    1374 </span>            :         else {
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :             prev_x = x.quo;</span>
<span class="lineNum">    1376 </span>            :         }
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :         e = e-&gt;next;</span>
<span class="lineNum">    1378 </span>            :     }
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1381 </span>            : }
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            : /* Merges edges on the given subpixel row from the polygon to the
<a name="1384"><span class="lineNum">    1384 </span>            :  * active_list. */</a>
<span class="lineNum">    1385 </span>            : inline static void
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 : active_list_merge_edges_from_polygon(</span>
<span class="lineNum">    1387 </span>            :     struct active_list *active,
<span class="lineNum">    1388 </span>            :     grid_scaled_y_t y,
<span class="lineNum">    1389 </span>            :     struct polygon *polygon)
<span class="lineNum">    1390 </span>            : {
<span class="lineNum">    1391 </span>            :     /* Split off the edges on the current subrow and merge them into
<span class="lineNum">    1392 </span>            :      * the active list. */
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     unsigned ix = EDGE_Y_BUCKET_INDEX(y, polygon-&gt;ymin);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     int min_height = active-&gt;min_height;</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :     struct edge *subrow_edges = NULL;</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     struct edge **ptail = &amp;polygon-&gt;y_buckets[ix].edges;</span>
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     while (1) {</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         struct edge *tail = *ptail;</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         if (NULL == tail) break;</span>
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         if (y == tail-&gt;ytop) {</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             *ptail = tail-&gt;next;</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :             tail-&gt;next = subrow_edges;</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :             subrow_edges = tail;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :             if (tail-&gt;height_left &lt; min_height)</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                 min_height = tail-&gt;height_left;</span>
<span class="lineNum">    1408 </span>            :         } else {
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :             ptail = &amp;tail-&gt;next;</span>
<span class="lineNum">    1410 </span>            :         }
<span class="lineNum">    1411 </span>            :     }
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     if (subrow_edges) {</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :         sort_edges (subrow_edges, UINT_MAX, &amp;subrow_edges);</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         active-&gt;head = merge_sorted_edges (active-&gt;head, subrow_edges);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :         active-&gt;min_height = min_height;</span>
<span class="lineNum">    1416 </span>            :     }
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            : /* Advance the edges on the active list by one subsample row by
<a name="1420"><span class="lineNum">    1420 </span>            :  * updating their x positions.  Drop edges from the list that end. */</a>
<span class="lineNum">    1421 </span>            : inline static void
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 : active_list_substep_edges(</span>
<span class="lineNum">    1423 </span>            :     struct active_list *active)
<span class="lineNum">    1424 </span>            : {
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     struct edge **cursor = &amp;active-&gt;head;</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :     grid_scaled_x_t prev_x = INT_MIN;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     struct edge *unsorted = NULL;</span>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     while (1) {</span>
<span class="lineNum">    1430 </span>            :         struct edge *edge;
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :         UNROLL3({</span>
<span class="lineNum">    1433 </span>            :             edge = *cursor;
<span class="lineNum">    1434 </span>            :             if (NULL == edge)
<span class="lineNum">    1435 </span>            :                 break;
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            :             if (0 != --edge-&gt;height_left) {
<span class="lineNum">    1438 </span>            :                 edge-&gt;x.quo += edge-&gt;dxdy.quo;
<span class="lineNum">    1439 </span>            :                 edge-&gt;x.rem += edge-&gt;dxdy.rem;
<span class="lineNum">    1440 </span>            :                 if (edge-&gt;x.rem &gt;= 0) {
<span class="lineNum">    1441 </span>            :                     ++edge-&gt;x.quo;
<span class="lineNum">    1442 </span>            :                     edge-&gt;x.rem -= edge-&gt;dy;
<span class="lineNum">    1443 </span>            :                 }
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            :                 if (edge-&gt;x.quo &lt; prev_x) {
<span class="lineNum">    1446 </span>            :                     *cursor = edge-&gt;next;
<span class="lineNum">    1447 </span>            :                     edge-&gt;next = unsorted;
<span class="lineNum">    1448 </span>            :                     unsorted = edge;
<span class="lineNum">    1449 </span>            :                 } else {
<span class="lineNum">    1450 </span>            :                     prev_x = edge-&gt;x.quo;
<span class="lineNum">    1451 </span>            :                     cursor = &amp;edge-&gt;next;
<span class="lineNum">    1452 </span>            :                 }
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            :             } else {
<span class="lineNum">    1455 </span>            :                 *cursor = edge-&gt;next;
<span class="lineNum">    1456 </span>            :             }
<span class="lineNum">    1457 </span>            :         });
<span class="lineNum">    1458 </span>            :     }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     if (unsorted) {</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :         sort_edges (unsorted, UINT_MAX, &amp;unsorted);</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         active-&gt;head = merge_sorted_edges (active-&gt;head, unsorted);</span>
<span class="lineNum">    1463 </span>            :     }
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 : }</span>
<a name="1465"><span class="lineNum">    1465 </span>            : </a>
<span class="lineNum">    1466 </span>            : inline static glitter_status_t
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 : apply_nonzero_fill_rule_for_subrow (struct active_list *active,</span>
<span class="lineNum">    1468 </span>            :                                     struct cell_list *coverages)
<span class="lineNum">    1469 </span>            : {
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     struct edge *edge = active-&gt;head;</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     int winding = 0;</span>
<span class="lineNum">    1472 </span>            :     int xstart;
<span class="lineNum">    1473 </span>            :     int xend;
<span class="lineNum">    1474 </span>            :     int status;
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     cell_list_rewind (coverages);</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     while (NULL != edge) {</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :         xstart = edge-&gt;x.quo;</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         winding = edge-&gt;dir;</span>
<span class="lineNum">    1481 </span>            :         while (1) {
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :             edge = edge-&gt;next;</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             if (NULL == edge)</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                 return cell_list_add_unbounded_subspan (coverages, xstart);</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :             winding += edge-&gt;dir;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :             if (0 == winding) {</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :                 if (edge-&gt;next == NULL || edge-&gt;next-&gt;x.quo != edge-&gt;x.quo)</span>
<span class="lineNum">    1489 </span>            :                     break;
<span class="lineNum">    1490 </span>            :             }
<span class="lineNum">    1491 </span>            :         }
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         xend = edge-&gt;x.quo;</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         status = cell_list_add_subspan (coverages, xstart, xend);</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :         edge = edge-&gt;next;</span>
<span class="lineNum">    1499 </span>            :     }
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1502 </span>            : }
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<span class="lineNum">    1504 </span>            : static glitter_status_t
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 : apply_evenodd_fill_rule_for_subrow (struct active_list *active,</span>
<span class="lineNum">    1506 </span>            :                                     struct cell_list *coverages)
<span class="lineNum">    1507 </span>            : {
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :     struct edge *edge = active-&gt;head;</span>
<span class="lineNum">    1509 </span>            :     int xstart;
<span class="lineNum">    1510 </span>            :     int xend;
<span class="lineNum">    1511 </span>            :     int status;
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     cell_list_rewind (coverages);</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     while (NULL != edge) {</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :         xstart = edge-&gt;x.quo;</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span>            :         while (1) {
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :             edge = edge-&gt;next;</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :             if (NULL == edge)</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :                 return cell_list_add_unbounded_subspan (coverages, xstart);</span>
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :             if (edge-&gt;next == NULL || edge-&gt;next-&gt;x.quo != edge-&gt;x.quo)</span>
<span class="lineNum">    1524 </span>            :                 break;
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :             edge = edge-&gt;next;</span>
<span class="lineNum">    1527 </span>            :         }
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         xend = edge-&gt;x.quo;</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :         status = cell_list_add_subspan (coverages, xstart, xend);</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :         edge = edge-&gt;next;</span>
<span class="lineNum">    1535 </span>            :     }
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1538 </span>            : }
<a name="1539"><span class="lineNum">    1539 </span>            : </a>
<span class="lineNum">    1540 </span>            : static glitter_status_t
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 : apply_nonzero_fill_rule_and_step_edges (struct active_list *active,</span>
<span class="lineNum">    1542 </span>            :                                         struct cell_list *coverages)
<span class="lineNum">    1543 </span>            : {
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :     struct edge **cursor = &amp;active-&gt;head;</span>
<span class="lineNum">    1545 </span>            :     struct edge *left_edge;
<span class="lineNum">    1546 </span>            :     int status;
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :     left_edge = *cursor;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     while (NULL != left_edge) {</span>
<span class="lineNum">    1550 </span>            :         struct edge *right_edge;
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :         int winding = left_edge-&gt;dir;</span>
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         left_edge-&gt;height_left -= GRID_Y;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :         if (left_edge-&gt;height_left)</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :             cursor = &amp;left_edge-&gt;next;</span>
<span class="lineNum">    1556 </span>            :         else
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :             *cursor = left_edge-&gt;next;</span>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            :         while (1) {
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :             right_edge = *cursor;</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :             if (NULL == right_edge)</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 return cell_list_render_edge (coverages, left_edge, +1);</span>
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :             right_edge-&gt;height_left -= GRID_Y;</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :             if (right_edge-&gt;height_left)</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :                 cursor = &amp;right_edge-&gt;next;</span>
<span class="lineNum">    1567 </span>            :             else
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :                 *cursor = right_edge-&gt;next;</span>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :             winding += right_edge-&gt;dir;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :             if (0 == winding) {</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :                 if (right_edge-&gt;next == NULL ||</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                     right_edge-&gt;next-&gt;x.quo != right_edge-&gt;x.quo)</span>
<span class="lineNum">    1574 </span>            :                 {
<span class="lineNum">    1575 </span>            :                     break;
<span class="lineNum">    1576 </span>            :                 }
<span class="lineNum">    1577 </span>            :             }
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :             if (! right_edge-&gt;vertical) {</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :                 right_edge-&gt;x.quo += right_edge-&gt;dxdy_full.quo;</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :                 right_edge-&gt;x.rem += right_edge-&gt;dxdy_full.rem;</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :                 if (right_edge-&gt;x.rem &gt;= 0) {</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :                     ++right_edge-&gt;x.quo;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :                     right_edge-&gt;x.rem -= right_edge-&gt;dy;</span>
<span class="lineNum">    1585 </span>            :                 }
<span class="lineNum">    1586 </span>            :             }
<span class="lineNum">    1587 </span>            :         }
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :         status = cell_list_render_edge (coverages, left_edge, +1);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :         status = cell_list_render_edge (coverages, right_edge, -1);</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :         left_edge = *cursor;</span>
<span class="lineNum">    1598 </span>            :     }
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1601 </span>            : }
<a name="1602"><span class="lineNum">    1602 </span>            : </a>
<span class="lineNum">    1603 </span>            : static glitter_status_t
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 : apply_evenodd_fill_rule_and_step_edges (struct active_list *active,</span>
<span class="lineNum">    1605 </span>            :                                         struct cell_list *coverages)
<span class="lineNum">    1606 </span>            : {
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :     struct edge **cursor = &amp;active-&gt;head;</span>
<span class="lineNum">    1608 </span>            :     struct edge *left_edge;
<span class="lineNum">    1609 </span>            :     int status;
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     left_edge = *cursor;</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     while (NULL != left_edge) {</span>
<span class="lineNum">    1613 </span>            :         struct edge *right_edge;
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :         int winding = left_edge-&gt;dir;</span>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :         left_edge-&gt;height_left -= GRID_Y;</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :         if (left_edge-&gt;height_left)</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :             cursor = &amp;left_edge-&gt;next;</span>
<span class="lineNum">    1619 </span>            :         else
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :             *cursor = left_edge-&gt;next;</span>
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :         while (1) {
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :             right_edge = *cursor;</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :             if (NULL == right_edge)</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                 return cell_list_render_edge (coverages, left_edge, +1);</span>
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :             right_edge-&gt;height_left -= GRID_Y;</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :             if (right_edge-&gt;height_left)</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :                 cursor = &amp;right_edge-&gt;next;</span>
<span class="lineNum">    1630 </span>            :             else
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :                 *cursor = right_edge-&gt;next;</span>
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :             winding += right_edge-&gt;dir;</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :             if ((winding &amp; 1) == 0) {</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :                 if (right_edge-&gt;next == NULL ||</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                     right_edge-&gt;next-&gt;x.quo != right_edge-&gt;x.quo)</span>
<span class="lineNum">    1637 </span>            :                 {
<span class="lineNum">    1638 </span>            :                     break;
<span class="lineNum">    1639 </span>            :                 }
<span class="lineNum">    1640 </span>            :             }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :             if (! right_edge-&gt;vertical) {</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :                 right_edge-&gt;x.quo += right_edge-&gt;dxdy_full.quo;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :                 right_edge-&gt;x.rem += right_edge-&gt;dxdy_full.rem;</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :                 if (right_edge-&gt;x.rem &gt;= 0) {</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :                     ++right_edge-&gt;x.quo;</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :                     right_edge-&gt;x.rem -= right_edge-&gt;dy;</span>
<span class="lineNum">    1648 </span>            :                 }
<span class="lineNum">    1649 </span>            :             }
<span class="lineNum">    1650 </span>            :         }
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :         status = cell_list_render_edge (coverages, left_edge, +1);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :         status = cell_list_render_edge (coverages, right_edge, -1);</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :         left_edge = *cursor;</span>
<span class="lineNum">    1661 </span>            :     }
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1664 </span>            : }
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span>            : /* If the user hasn't configured a coverage blitter, use a default one
<span class="lineNum">    1667 </span>            :  * that blits spans directly to an A8 raster. */
<span class="lineNum">    1668 </span>            : #ifndef GLITTER_BLIT_COVERAGES
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            : inline static void
<span class="lineNum">    1671 </span>            : blit_span(
<span class="lineNum">    1672 </span>            :     unsigned char *row_pixels,
<span class="lineNum">    1673 </span>            :     int x, unsigned len,
<span class="lineNum">    1674 </span>            :     grid_area_t coverage)
<span class="lineNum">    1675 </span>            : {
<span class="lineNum">    1676 </span>            :     int alpha = GRID_AREA_TO_ALPHA(coverage);
<span class="lineNum">    1677 </span>            :     if (1 == len) {
<span class="lineNum">    1678 </span>            :         row_pixels[x] = alpha;
<span class="lineNum">    1679 </span>            :     }
<span class="lineNum">    1680 </span>            :     else {
<span class="lineNum">    1681 </span>            :         memset(row_pixels + x, alpha, len);
<span class="lineNum">    1682 </span>            :     }
<span class="lineNum">    1683 </span>            : }
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            : #define GLITTER_BLIT_COVERAGES(coverages, y, height, xmin, xmax) \
<span class="lineNum">    1686 </span>            :     do { \
<span class="lineNum">    1687 </span>            :         int __y = y; \
<span class="lineNum">    1688 </span>            :         int __h = height; \
<span class="lineNum">    1689 </span>            :         do { \
<span class="lineNum">    1690 </span>            :             blit_cells(coverages, raster_pixels + (__y)*raster_stride, xmin, xmax); \
<span class="lineNum">    1691 </span>            :         } while (--__h); \
<span class="lineNum">    1692 </span>            :     } while (0)
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span>            : static void
<span class="lineNum">    1695 </span>            : blit_cells(
<span class="lineNum">    1696 </span>            :     struct cell_list *cells,
<span class="lineNum">    1697 </span>            :     unsigned char *row_pixels,
<span class="lineNum">    1698 </span>            :     int xmin, int xmax)
<span class="lineNum">    1699 </span>            : {
<span class="lineNum">    1700 </span>            :     struct cell *cell = cells-&gt;head;
<span class="lineNum">    1701 </span>            :     int prev_x = xmin;
<span class="lineNum">    1702 </span>            :     int coverage = 0;
<span class="lineNum">    1703 </span>            :     if (NULL == cell)
<span class="lineNum">    1704 </span>            :         return;
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            :     while (NULL != cell &amp;&amp; cell-&gt;x &lt; xmin) {
<span class="lineNum">    1707 </span>            :         coverage += cell-&gt;covered_height;
<span class="lineNum">    1708 </span>            :         cell = cell-&gt;next;
<span class="lineNum">    1709 </span>            :     }
<span class="lineNum">    1710 </span>            :     coverage *= GRID_X*2;
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :     for (; NULL != cell; cell = cell-&gt;next) {
<span class="lineNum">    1713 </span>            :         int x = cell-&gt;x;
<span class="lineNum">    1714 </span>            :         int area;
<span class="lineNum">    1715 </span>            :         if (x &gt;= xmax)
<span class="lineNum">    1716 </span>            :             break;
<span class="lineNum">    1717 </span>            :         if (x &gt; prev_x &amp;&amp; 0 != coverage) {
<span class="lineNum">    1718 </span>            :             blit_span(row_pixels, prev_x, x - prev_x, coverage);
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :         coverage += cell-&gt;covered_height * GRID_X*2;
<span class="lineNum">    1722 </span>            :         area = coverage - cell-&gt;uncovered_area;
<span class="lineNum">    1723 </span>            :         if (area) {
<span class="lineNum">    1724 </span>            :             blit_span(row_pixels, x, 1, area);
<span class="lineNum">    1725 </span>            :         }
<span class="lineNum">    1726 </span>            :         prev_x = x+1;
<span class="lineNum">    1727 </span>            :     }
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :     if (0 != coverage &amp;&amp; prev_x &lt; xmax) {
<span class="lineNum">    1730 </span>            :         blit_span(row_pixels, prev_x, xmax - prev_x, coverage);
<span class="lineNum">    1731 </span>            :     }
<span class="lineNum">    1732 </span>            : }
<span class="lineNum">    1733 </span>            : #endif /* GLITTER_BLIT_COVERAGES */
<a name="1734"><span class="lineNum">    1734 </span>            : </a>
<span class="lineNum">    1735 </span>            : static void
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 : _glitter_scan_converter_init(glitter_scan_converter_t *converter)</span>
<span class="lineNum">    1737 </span>            : {
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     polygon_init(converter-&gt;polygon);</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :     active_list_init(converter-&gt;active);</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :     cell_list_init(converter-&gt;coverages);</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :     converter-&gt;xmin=0;</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     converter-&gt;ymin=0;</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     converter-&gt;xmax=0;</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     converter-&gt;ymax=0;</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 : }</span>
<a name="1746"><span class="lineNum">    1746 </span>            : </a>
<span class="lineNum">    1747 </span>            : static void
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 : _glitter_scan_converter_fini(glitter_scan_converter_t *converter)</span>
<span class="lineNum">    1749 </span>            : {
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :     polygon_fini(converter-&gt;polygon);</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     cell_list_fini(converter-&gt;coverages);</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :     converter-&gt;xmin=0;</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :     converter-&gt;ymin=0;</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     converter-&gt;xmax=0;</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     converter-&gt;ymax=0;</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 : }</span>
<a name="1757"><span class="lineNum">    1757 </span>            : </a>
<span class="lineNum">    1758 </span>            : static grid_scaled_t
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 : int_to_grid_scaled(int i, int scale)</span>
<span class="lineNum">    1760 </span>            : {
<span class="lineNum">    1761 </span>            :     /* Clamp to max/min representable scaled number. */
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :     if (i &gt;= 0) {</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         if (i &gt;= INT_MAX/scale)</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :             i = INT_MAX/scale;</span>
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span>            :     else {
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :         if (i &lt;= INT_MIN/scale)</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :             i = INT_MIN/scale;</span>
<span class="lineNum">    1769 </span>            :     }
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     return i*scale;</span>
<span class="lineNum">    1771 </span>            : }
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            : #define int_to_grid_scaled_x(x) int_to_grid_scaled((x), GRID_X)
<span class="lineNum">    1774 </span>            : #define int_to_grid_scaled_y(x) int_to_grid_scaled((x), GRID_Y)
<a name="1775"><span class="lineNum">    1775 </span>            : </a>
<span class="lineNum">    1776 </span>            : I glitter_status_t
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 : glitter_scan_converter_reset(</span>
<span class="lineNum">    1778 </span>            :     glitter_scan_converter_t *converter,
<span class="lineNum">    1779 </span>            :     int xmin, int ymin,
<span class="lineNum">    1780 </span>            :     int xmax, int ymax)
<span class="lineNum">    1781 </span>            : {
<span class="lineNum">    1782 </span>            :     glitter_status_t status;
<span class="lineNum">    1783 </span>            : 
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     converter-&gt;xmin = 0; converter-&gt;xmax = 0;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     converter-&gt;ymin = 0; converter-&gt;ymax = 0;</span>
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     xmin = int_to_grid_scaled_x(xmin);</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     ymin = int_to_grid_scaled_y(ymin);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     xmax = int_to_grid_scaled_x(xmax);</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :     ymax = int_to_grid_scaled_y(ymax);</span>
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :     active_list_reset(converter-&gt;active);</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :     cell_list_reset(converter-&gt;coverages);</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :     status = polygon_reset(converter-&gt;polygon, xmin, xmax, ymin, ymax);</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :     if (status)</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :         return status;</span>
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :     converter-&gt;xmin = xmin;</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     converter-&gt;xmax = xmax;</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     converter-&gt;ymin = ymin;</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :     converter-&gt;ymax = ymax;</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1803 </span>            : }
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            : /* INPUT_TO_GRID_X/Y (in_coord, out_grid_scaled, grid_scale)
<span class="lineNum">    1806 </span>            :  *   These macros convert an input coordinate in the client's
<span class="lineNum">    1807 </span>            :  *   device space to the rasterisation grid.
<span class="lineNum">    1808 </span>            :  */
<span class="lineNum">    1809 </span>            : /* Gah.. this bit of ugly defines INPUT_TO_GRID_X/Y so as to use
<span class="lineNum">    1810 </span>            :  * shifts if possible, and something saneish if not.
<span class="lineNum">    1811 </span>            :  */
<span class="lineNum">    1812 </span>            : #if !defined(INPUT_TO_GRID_Y) &amp;&amp; defined(GRID_Y_BITS) &amp;&amp; GRID_Y_BITS &lt;= GLITTER_INPUT_BITS
<span class="lineNum">    1813 </span>            : #  define INPUT_TO_GRID_Y(in, out) (out) = (in) &gt;&gt; (GLITTER_INPUT_BITS - GRID_Y_BITS)
<span class="lineNum">    1814 </span>            : #else
<span class="lineNum">    1815 </span>            : #  define INPUT_TO_GRID_Y(in, out) INPUT_TO_GRID_general(in, out, GRID_Y)
<span class="lineNum">    1816 </span>            : #endif
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span>            : #if !defined(INPUT_TO_GRID_X) &amp;&amp; defined(GRID_X_BITS) &amp;&amp; GRID_X_BITS &lt;= GLITTER_INPUT_BITS
<span class="lineNum">    1819 </span>            : #  define INPUT_TO_GRID_X(in, out) (out) = (in) &gt;&gt; (GLITTER_INPUT_BITS - GRID_X_BITS)
<span class="lineNum">    1820 </span>            : #else
<span class="lineNum">    1821 </span>            : #  define INPUT_TO_GRID_X(in, out) INPUT_TO_GRID_general(in, out, GRID_X)
<span class="lineNum">    1822 </span>            : #endif
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            : #define INPUT_TO_GRID_general(in, out, grid_scale) do {         \
<span class="lineNum">    1825 </span>            :         long long tmp__ = (long long)(grid_scale) * (in);       \
<span class="lineNum">    1826 </span>            :         tmp__ &gt;&gt;= GLITTER_INPUT_BITS;                             \
<span class="lineNum">    1827 </span>            :         (out) = tmp__;                                          \
<span class="lineNum">    1828 </span>            : } while (0)
<a name="1829"><span class="lineNum">    1829 </span>            : </a>
<span class="lineNum">    1830 </span>            : I glitter_status_t
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 : glitter_scan_converter_add_edge (glitter_scan_converter_t *converter,</span>
<span class="lineNum">    1832 </span>            :                                  const cairo_edge_t *edge)
<span class="lineNum">    1833 </span>            : {
<span class="lineNum">    1834 </span>            :     cairo_edge_t e;
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_Y (edge-&gt;top, e.top);</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_Y (edge-&gt;bottom, e.bottom);</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :     if (e.top &gt;= e.bottom)</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :     /* XXX: possible overflows if GRID_X/Y &gt; 2**GLITTER_INPUT_BITS */
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_Y (edge-&gt;line.p1.y, e.line.p1.y);</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_Y (edge-&gt;line.p2.y, e.line.p2.y);</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :     if (e.line.p1.y == e.line.p2.y)</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1846 </span>            : 
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_X (edge-&gt;line.p1.x, e.line.p1.x);</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     INPUT_TO_GRID_X (edge-&gt;line.p2.x, e.line.p2.x);</span>
<span class="lineNum">    1849 </span>            : 
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :     e.dir = edge-&gt;dir;</span>
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     return polygon_add_edge (converter-&gt;polygon, &amp;e);</span>
<span class="lineNum">    1853 </span>            : }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            : #ifndef GLITTER_BLIT_COVERAGES_BEGIN
<span class="lineNum">    1856 </span>            : # define GLITTER_BLIT_COVERAGES_BEGIN
<span class="lineNum">    1857 </span>            : #endif
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            : #ifndef GLITTER_BLIT_COVERAGES_END
<span class="lineNum">    1860 </span>            : # define GLITTER_BLIT_COVERAGES_END
<span class="lineNum">    1861 </span>            : #endif
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : #ifndef GLITTER_BLIT_COVERAGES_EMPTY
<span class="lineNum">    1864 </span>            : # define GLITTER_BLIT_COVERAGES_EMPTY(y0, y1, xmin, xmax)
<span class="lineNum">    1865 </span>            : #endif
<a name="1866"><span class="lineNum">    1866 </span>            : </a>
<span class="lineNum">    1867 </span>            : static cairo_bool_t
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 : active_list_is_vertical (struct active_list *active)</span>
<span class="lineNum">    1869 </span>            : {
<span class="lineNum">    1870 </span>            :     struct edge *e;
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     for (e = active-&gt;head; e != NULL; e = e-&gt;next) {</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         if (! e-&gt;vertical)</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1875 </span>            :     }
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1878 </span>            : }
<a name="1879"><span class="lineNum">    1879 </span>            : </a>
<span class="lineNum">    1880 </span>            : static void
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 : step_edges (struct active_list *active, int count)</span>
<span class="lineNum">    1882 </span>            : {
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     struct edge **cursor = &amp;active-&gt;head;</span>
<span class="lineNum">    1884 </span>            :     struct edge *edge;
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     for (edge = *cursor; edge != NULL; edge = *cursor) {</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :         edge-&gt;height_left -= GRID_Y * count;</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :         if (edge-&gt;height_left)</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :             cursor = &amp;edge-&gt;next;</span>
<span class="lineNum">    1890 </span>            :         else
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :             *cursor = edge-&gt;next;</span>
<span class="lineNum">    1892 </span>            :     }
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 : }</span>
<a name="1894"><span class="lineNum">    1894 </span>            : </a>
<span class="lineNum">    1895 </span>            : I glitter_status_t
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 : glitter_scan_converter_render(</span>
<span class="lineNum">    1897 </span>            :     glitter_scan_converter_t *converter,
<span class="lineNum">    1898 </span>            :     int nonzero_fill,
<span class="lineNum">    1899 </span>            :     GLITTER_BLIT_COVERAGES_ARGS)
<span class="lineNum">    1900 </span>            : {
<span class="lineNum">    1901 </span>            :     int i, j;
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     int ymax_i = converter-&gt;ymax / GRID_Y;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     int ymin_i = converter-&gt;ymin / GRID_Y;</span>
<span class="lineNum">    1904 </span>            :     int xmin_i, xmax_i;
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :     grid_scaled_x_t xmin = converter-&gt;xmin;</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :     int h = ymax_i - ymin_i;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     struct polygon *polygon = converter-&gt;polygon;</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :     struct cell_list *coverages = converter-&gt;coverages;</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :     struct active_list *active = converter-&gt;active;</span>
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     xmin_i = converter-&gt;xmin / GRID_X;</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     xmax_i = converter-&gt;xmax / GRID_X;</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     if (xmin_i &gt;= xmax_i)</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            :     /* Let the coverage blitter initialise itself. */
<span class="lineNum">    1917 </span>            :     GLITTER_BLIT_COVERAGES_BEGIN;
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            :     /* Render each pixel row. */
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; h; i = j) {</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :         int do_full_step = 0;</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :         glitter_status_t status = 0;</span>
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :         j = i + 1;</span>
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span>            :         /* Determine if we can ignore this row or use the full pixel
<span class="lineNum">    1927 </span>            :          * stepper. */
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :         if (polygon-&gt;y_buckets[i].edges == NULL) {</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :             if (! active-&gt;head) {</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                 for (; j &lt; h &amp;&amp; ! polygon-&gt;y_buckets[j].edges; j++)</span>
<span class="lineNum">    1931 </span>            :                     ;
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :                 GLITTER_BLIT_COVERAGES_EMPTY (i+ymin_i, j-i, xmin_i, xmax_i);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1934 </span>            :             }
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :             do_full_step = active_list_can_step_full_row (active, xmin);</span>
<span class="lineNum">    1936 </span>            :         }
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :         else if (! polygon-&gt;y_buckets[i].have_inside_edges) {</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :             grid_scaled_y_t y = (i+ymin_i)*GRID_Y;</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :             active_list_merge_edges_from_polygon (active, y, polygon);</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :             do_full_step = active_list_can_step_full_row (active, xmin);</span>
<span class="lineNum">    1941 </span>            :         }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :         if (do_full_step) {</span>
<span class="lineNum">    1944 </span>            :             /* Step by a full pixel row's worth. */
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :             if (nonzero_fill) {</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :                 status = apply_nonzero_fill_rule_and_step_edges (active,</span>
<span class="lineNum">    1947 </span>            :                                                                  coverages);
<span class="lineNum">    1948 </span>            :             } else {
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :                 status = apply_evenodd_fill_rule_and_step_edges (active,</span>
<span class="lineNum">    1950 </span>            :                                                                  coverages);
<span class="lineNum">    1951 </span>            :             }
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :             if (active_list_is_vertical (active)) {</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :                 while (j &lt; h &amp;&amp;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :                        polygon-&gt;y_buckets[j].edges == NULL &amp;&amp;</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :                        active-&gt;min_height &gt;= 2*GRID_Y)</span>
<span class="lineNum">    1957 </span>            :                 {
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                     active-&gt;min_height -= GRID_Y;</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :                     j++;</span>
<span class="lineNum">    1960 </span>            :                 }
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :                 if (j != i + 1)</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :                     step_edges (active, j - (i + 1));</span>
<span class="lineNum">    1963 </span>            :             }
<span class="lineNum">    1964 </span>            :         } else {
<span class="lineNum">    1965 </span>            :             /* Supersample this row. */
<span class="lineNum">    1966 </span>            :             grid_scaled_y_t suby;
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :             for (suby = 0; suby &lt; GRID_Y; suby++) {</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :                 grid_scaled_y_t y = (i+ymin_i)*GRID_Y + suby;</span>
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :                 active_list_merge_edges_from_polygon (active, y, polygon);</span>
<span class="lineNum">    1971 </span>            : 
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :                 if (nonzero_fill) {</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :                     status |= apply_nonzero_fill_rule_for_subrow (active,</span>
<span class="lineNum">    1974 </span>            :                                                                   coverages);
<span class="lineNum">    1975 </span>            :                 } else {
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :                     status |= apply_evenodd_fill_rule_for_subrow (active,</span>
<span class="lineNum">    1977 </span>            :                                                                   coverages);
<span class="lineNum">    1978 </span>            :                 }
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                 active_list_substep_edges(active);</span>
<span class="lineNum">    1981 </span>            :             }
<span class="lineNum">    1982 </span>            :         }
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         if (unlikely (status))</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :             return status;</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :         GLITTER_BLIT_COVERAGES(coverages, i+ymin_i, j-i, xmin_i, xmax_i);</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :         cell_list_reset (coverages);</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         if (! active-&gt;head)</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :             active-&gt;min_height = INT_MAX;</span>
<span class="lineNum">    1992 </span>            :         else
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :             active-&gt;min_height -= GRID_Y;</span>
<span class="lineNum">    1994 </span>            :     }
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span>            :     /* Clean up the coverage blitter. */
<span class="lineNum">    1997 </span>            :     GLITTER_BLIT_COVERAGES_END;
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :     return GLITTER_STATUS_SUCCESS;</span>
<span class="lineNum">    2000 </span>            : }
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">    2003 </span>            :  * cairo specific implementation: the coverage blitter and
<span class="lineNum">    2004 </span>            :  * scan converter subclass. */
<a name="2005"><span class="lineNum">    2005 </span>            : </a>
<span class="lineNum">    2006 </span>            : static glitter_status_t
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 : blit_with_span_renderer (struct cell_list *cells,</span>
<span class="lineNum">    2008 </span>            :                          cairo_span_renderer_t *renderer,
<span class="lineNum">    2009 </span>            :                          struct pool *span_pool,
<span class="lineNum">    2010 </span>            :                          int y, int height,
<span class="lineNum">    2011 </span>            :                          int xmin, int xmax)
<span class="lineNum">    2012 </span>            : {
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :     struct cell *cell = cells-&gt;head;</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :     int prev_x = xmin;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :     int cover = 0;</span>
<span class="lineNum">    2016 </span>            :     cairo_half_open_span_t *spans;
<span class="lineNum">    2017 </span>            :     unsigned num_spans;
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :     if (cell == NULL)</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :         return blit_empty_with_span_renderer (renderer, y, height);</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     /* Skip cells to the left of the clip region. */
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :     while (cell != NULL &amp;&amp; cell-&gt;x &lt; xmin) {</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :         cover += cell-&gt;covered_height;</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :         cell = cell-&gt;next;</span>
<span class="lineNum">    2026 </span>            :     }
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     cover *= GRID_X*2;</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            :     /* Count number of cells remaining. */
<span class="lineNum">    2030 </span>            :     {
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :         struct cell *next = cell;</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         num_spans = 1;</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :         while (next != NULL) {</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :             next = next-&gt;next;</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :             ++num_spans;</span>
<span class="lineNum">    2036 </span>            :         }
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :         num_spans = 2*num_spans;</span>
<span class="lineNum">    2038 </span>            :     }
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span>            :     /* Allocate enough spans for the row. */
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :     pool_reset (span_pool);</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :     spans = pool_alloc (span_pool, sizeof(spans[0])*num_spans);</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :     if (unlikely (spans == NULL))</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :         return GLITTER_STATUS_NO_MEMORY;</span>
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :     num_spans = 0;</span>
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            :     /* Form the spans from the coverages and areas. */
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :     for (; cell != NULL; cell = cell-&gt;next) {</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :         int x = cell-&gt;x;</span>
<span class="lineNum">    2051 </span>            :         int area;
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         if (x &gt;= xmax)</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         if (x &gt; prev_x) {</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :             spans[num_spans].x = prev_x;</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :             spans[num_spans].coverage = GRID_AREA_TO_ALPHA (cover);</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :             ++num_spans;</span>
<span class="lineNum">    2060 </span>            :         }
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :         cover += cell-&gt;covered_height*GRID_X*2;</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :         area = cover - cell-&gt;uncovered_area;</span>
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :         spans[num_spans].x = x;</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         spans[num_spans].coverage = GRID_AREA_TO_ALPHA (area);</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :         ++num_spans;</span>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :         prev_x = x+1;</span>
<span class="lineNum">    2070 </span>            :     }
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     if (prev_x &lt;= xmax) {</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         spans[num_spans].x = prev_x;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         spans[num_spans].coverage = GRID_AREA_TO_ALPHA (cover);</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         ++num_spans;</span>
<span class="lineNum">    2076 </span>            :     }
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :     if (prev_x &lt; xmax &amp;&amp; cover) {</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :         spans[num_spans].x = xmax;</span>
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :         spans[num_spans].coverage = 0;</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :         ++num_spans;</span>
<span class="lineNum">    2082 </span>            :     }
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            :     /* Dump them into the renderer. */
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     return renderer-&gt;render_rows (renderer, y, height, spans, num_spans);</span>
<span class="lineNum">    2086 </span>            : }
<a name="2087"><span class="lineNum">    2087 </span>            : </a>
<span class="lineNum">    2088 </span>            : static glitter_status_t
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 : blit_empty_with_span_renderer (cairo_span_renderer_t *renderer, int y, int height)</span>
<span class="lineNum">    2090 </span>            : {
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     return renderer-&gt;render_rows (renderer, y, height, NULL, 0);</span>
<span class="lineNum">    2092 </span>            : }
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            : struct _cairo_tor_scan_converter {
<span class="lineNum">    2095 </span>            :     cairo_scan_converter_t base;
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span>            :     glitter_scan_converter_t converter[1];
<span class="lineNum">    2098 </span>            :     cairo_fill_rule_t fill_rule;
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span>            :     struct {
<span class="lineNum">    2101 </span>            :         struct pool base[1];
<span class="lineNum">    2102 </span>            :         cairo_half_open_span_t embedded[32];
<span class="lineNum">    2103 </span>            :     } span_pool;
<span class="lineNum">    2104 </span>            : };
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span>            : typedef struct _cairo_tor_scan_converter cairo_tor_scan_converter_t;
<a name="2107"><span class="lineNum">    2107 </span>            : </a>
<span class="lineNum">    2108 </span>            : static void
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 : _cairo_tor_scan_converter_destroy (void *converter)</span>
<span class="lineNum">    2110 </span>            : {
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :     cairo_tor_scan_converter_t *self = converter;</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     if (self == NULL) {</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2114 </span>            :     }
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :     _glitter_scan_converter_fini (self-&gt;converter);</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     pool_fini (self-&gt;span_pool.base);</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     free(self);</span>
<span class="lineNum">    2118 </span>            : }
<a name="2119"><span class="lineNum">    2119 </span>            : </a>
<span class="lineNum">    2120 </span>            : static cairo_status_t
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 : _cairo_tor_scan_converter_add_edge (void                *converter,</span>
<span class="lineNum">    2122 </span>            :                                     const cairo_point_t *p1,
<span class="lineNum">    2123 </span>            :                                     const cairo_point_t *p2,
<span class="lineNum">    2124 </span>            :                                     int top, int bottom,
<span class="lineNum">    2125 </span>            :                                     int dir)
<span class="lineNum">    2126 </span>            : {
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :     cairo_tor_scan_converter_t *self = converter;</span>
<span class="lineNum">    2128 </span>            :     cairo_status_t status;
<span class="lineNum">    2129 </span>            :     cairo_edge_t edge;
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :     edge.line.p1 = *p1;</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :     edge.line.p2 = *p2;</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :     edge.top = top;</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :     edge.bottom = bottom;</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :     edge.dir = dir;</span>
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :     status = glitter_scan_converter_add_edge (self-&gt;converter, &amp;edge);</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :     if (unlikely (status))</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :         return _cairo_scan_converter_set_error (self, _cairo_error (status));</span>
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     return CAIRO_STATUS_SUCCESS;</span>
<span class="lineNum">    2142 </span>            : }
<a name="2143"><span class="lineNum">    2143 </span>            : </a>
<span class="lineNum">    2144 </span>            : static cairo_status_t
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 : _cairo_tor_scan_converter_add_polygon (void             *converter,</span>
<span class="lineNum">    2146 </span>            :                                        const cairo_polygon_t *polygon)
<span class="lineNum">    2147 </span>            : {
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     cairo_tor_scan_converter_t *self = converter;</span>
<span class="lineNum">    2149 </span>            :     cairo_status_t status;
<span class="lineNum">    2150 </span>            :     int i;
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; polygon-&gt;num_edges; i++) {</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :         status = glitter_scan_converter_add_edge (self-&gt;converter,</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :                                                   &amp;polygon-&gt;edges[i]);</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :         if (unlikely (status)) {</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :             return _cairo_scan_converter_set_error (self,</span>
<span class="lineNum">    2157 </span>            :                                                     _cairo_error (status));
<span class="lineNum">    2158 </span>            :         }
<span class="lineNum">    2159 </span>            :     }
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :     return CAIRO_STATUS_SUCCESS;</span>
<span class="lineNum">    2162 </span>            : }
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<span class="lineNum">    2164 </span>            : static cairo_status_t
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 : _cairo_tor_scan_converter_generate (void                        *converter,</span>
<span class="lineNum">    2166 </span>            :                                     cairo_span_renderer_t       *renderer)
<span class="lineNum">    2167 </span>            : {
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :     cairo_tor_scan_converter_t *self = converter;</span>
<span class="lineNum">    2169 </span>            :     cairo_status_t status;
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :    status = glitter_scan_converter_render (self-&gt;converter,</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :                                            self-&gt;fill_rule == CAIRO_FILL_RULE_WINDING,</span>
<span class="lineNum">    2173 </span>            :                                            renderer,
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :                                            self-&gt;span_pool.base);</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :     if (unlikely (status))</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         return _cairo_scan_converter_set_error (self, _cairo_error (status));</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :     return CAIRO_STATUS_SUCCESS;</span>
<span class="lineNum">    2179 </span>            : }
<a name="2180"><span class="lineNum">    2180 </span>            : </a>
<span class="lineNum">    2181 </span>            : cairo_scan_converter_t *
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 : _cairo_tor_scan_converter_create (int                   xmin,</span>
<span class="lineNum">    2183 </span>            :                                   int                   ymin,
<span class="lineNum">    2184 </span>            :                                   int                   xmax,
<span class="lineNum">    2185 </span>            :                                   int                   ymax,
<span class="lineNum">    2186 </span>            :                                   cairo_fill_rule_t     fill_rule)
<span class="lineNum">    2187 </span>            : {
<span class="lineNum">    2188 </span>            :     cairo_tor_scan_converter_t *self;
<span class="lineNum">    2189 </span>            :     cairo_status_t status;
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :     self = calloc (1, sizeof(struct _cairo_tor_scan_converter));</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :     if (unlikely (self == NULL)) {</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :         status = _cairo_error (CAIRO_STATUS_NO_MEMORY);</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :         goto bail_nomem;</span>
<span class="lineNum">    2195 </span>            :     }
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :     self-&gt;base.destroy = _cairo_tor_scan_converter_destroy;</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :     self-&gt;base.add_edge = _cairo_tor_scan_converter_add_edge;</span>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :     self-&gt;base.add_polygon = _cairo_tor_scan_converter_add_polygon;</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     self-&gt;base.generate = _cairo_tor_scan_converter_generate;</span>
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :     pool_init (self-&gt;span_pool.base,</span>
<span class="lineNum">    2203 </span>            :               250 * sizeof(self-&gt;span_pool.embedded[0]),
<span class="lineNum">    2204 </span>            :               sizeof(self-&gt;span_pool.embedded));
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :     _glitter_scan_converter_init (self-&gt;converter);</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :     status = glitter_scan_converter_reset (self-&gt;converter,</span>
<span class="lineNum">    2208 </span>            :                                            xmin, ymin, xmax, ymax);
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     if (unlikely (status))</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :         goto bail;</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :     self-&gt;fill_rule = fill_rule;</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :     return &amp;self-&gt;base;</span>
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span>            :  bail:
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     self-&gt;base.destroy(&amp;self-&gt;base);</span>
<span class="lineNum">    2218 </span>            :  bail_nomem:
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :     return _cairo_scan_converter_create_in_error (status);</span>
<span class="lineNum">    2220 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/gl/GLUploadHelpers.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/gl</a> - GLUploadHelpers.cpp<span style="font-size: 80%;"> (source / <a href="GLUploadHelpers.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">222</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40; -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;GLUploadHelpers.h&quot;
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;GLContext.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/gfx/Tools.h&quot;  // For BytesPerPixel
<span class="lineNum">      12 </span>            : #include &quot;nsRegion.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;GfxTexturesReporter.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/gfx/Logging.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : namespace mozilla {
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : using namespace gfx;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : namespace gl {
<a name="21"><span class="lineNum">      21 </span>            : </a>
<span class="lineNum">      22 </span>            : static unsigned int
<span class="lineNum">      23 </span><span class="lineNoCov">          0 : DataOffset(const IntPoint&amp; aPoint, int32_t aStride, SurfaceFormat aFormat)</span>
<span class="lineNum">      24 </span>            : {
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :   unsigned int data = aPoint.y * aStride;</span>
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :   data += aPoint.x * BytesPerPixel(aFormat);</span>
<span class="lineNum">      27 </span><span class="lineNoCov">          0 :   return data;</span>
<a name="28"><span class="lineNum">      28 </span>            : }</a>
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span><span class="lineNoCov">          0 : static GLint GetAddressAlignment(ptrdiff_t aAddress)</span>
<span class="lineNum">      31 </span>            : {
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :     if (!(aAddress &amp; 0x7)) {</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :        return 8;</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :     } else if (!(aAddress &amp; 0x3)) {</span>
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :         return 4;</span>
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :     } else if (!(aAddress &amp; 0x1)) {</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :         return 2;</span>
<span class="lineNum">      38 </span>            :     } else {
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">      40 </span>            :     }
<span class="lineNum">      41 </span>            : }
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : // Take texture data in a given buffer and copy it into a larger buffer,
<a name="44"><span class="lineNum">      44 </span>            : // padding out the edge pixels for filtering if necessary</a>
<span class="lineNum">      45 </span>            : static void
<span class="lineNum">      46 </span><span class="lineNoCov">          0 : CopyAndPadTextureData(const GLvoid* srcBuffer,</span>
<span class="lineNum">      47 </span>            :                       GLvoid* dstBuffer,
<span class="lineNum">      48 </span>            :                       GLsizei srcWidth, GLsizei srcHeight,
<span class="lineNum">      49 </span>            :                       GLsizei dstWidth, GLsizei dstHeight,
<span class="lineNum">      50 </span>            :                       GLsizei stride, GLint pixelsize)
<span class="lineNum">      51 </span>            : {
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :     unsigned char* rowDest = static_cast&lt;unsigned char*&gt;(dstBuffer);</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     const unsigned char* source = static_cast&lt;const unsigned char*&gt;(srcBuffer);</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     for (GLsizei h = 0; h &lt; srcHeight; ++h) {</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         memcpy(rowDest, source, srcWidth * pixelsize);</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :         rowDest += dstWidth * pixelsize;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :         source += stride;</span>
<span class="lineNum">      59 </span>            :     }
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     GLsizei padHeight = srcHeight;</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :     // Pad out an extra row of pixels so that edge filtering doesn't use garbage data
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     if (dstHeight &gt; srcHeight) {</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         memcpy(rowDest, source - stride, srcWidth * pixelsize);</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :         padHeight++;</span>
<span class="lineNum">      67 </span>            :     }
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :     // Pad out an extra column of pixels
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     if (dstWidth &gt; srcWidth) {</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :         rowDest = static_cast&lt;unsigned char*&gt;(dstBuffer) + srcWidth * pixelsize;</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :         for (GLsizei h = 0; h &lt; padHeight; ++h) {</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :             memcpy(rowDest, rowDest - pixelsize, pixelsize);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :             rowDest += dstWidth * pixelsize;</span>
<span class="lineNum">      75 </span>            :         }
<span class="lineNum">      76 </span>            :     }
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : // In both of these cases (for the Adreno at least) it is impossible
<span class="lineNum">      80 </span>            : // to determine good or bad driver versions for POT texture uploads,
<span class="lineNum">      81 </span>            : // so blacklist them all. Newer drivers use a different rendering
<span class="lineNum">      82 </span>            : // string in the form &quot;Adreno (TM) 200&quot; and the drivers we've seen so
<span class="lineNum">      83 </span>            : // far work fine with NPOT textures, so don't blacklist those until we
<a name="84"><span class="lineNum">      84 </span>            : // have evidence of any problems with them.</a>
<span class="lineNum">      85 </span>            : bool
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : CanUploadSubTextures(GLContext* gl)</span>
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     if (!gl-&gt;WorkAroundDriverBugs())</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     // There are certain GPUs that we don't want to use glTexSubImage2D on
<span class="lineNum">      92 </span>            :     // because that function can be very slow and/or buggy
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     if (gl-&gt;Renderer() == GLRenderer::Adreno200 ||</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :         gl-&gt;Renderer() == GLRenderer::Adreno205)</span>
<span class="lineNum">      95 </span>            :     {
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :     // On PowerVR glTexSubImage does a readback, so it will be slower
<span class="lineNum">     100 </span>            :     // than just doing a glTexImage2D() directly. i.e. 26ms vs 10ms
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     if (gl-&gt;Renderer() == GLRenderer::SGX540 ||</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         gl-&gt;Renderer() == GLRenderer::SGX530)</span>
<span class="lineNum">     103 </span>            :     {
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     105 </span>            :     }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     108 </span>            : }
<a name="109"><span class="lineNum">     109 </span>            : </a>
<span class="lineNum">     110 </span>            : static void
<span class="lineNum">     111 </span><span class="lineNoCov">          0 : TexSubImage2DWithUnpackSubimageGLES(GLContext* gl,</span>
<span class="lineNum">     112 </span>            :                                     GLenum target, GLint level,
<span class="lineNum">     113 </span>            :                                     GLint xoffset, GLint yoffset,
<span class="lineNum">     114 </span>            :                                     GLsizei width, GLsizei height,
<span class="lineNum">     115 </span>            :                                     GLsizei stride, GLint pixelsize,
<span class="lineNum">     116 </span>            :                                     GLenum format, GLenum type,
<span class="lineNum">     117 </span>            :                                     const GLvoid* pixels)
<span class="lineNum">     118 </span>            : {
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                      std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :                               GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     122 </span>            :     // When using GL_UNPACK_ROW_LENGTH, we need to work around a Tegra
<span class="lineNum">     123 </span>            :     // driver crash where the driver apparently tries to read
<span class="lineNum">     124 </span>            :     // (stride - width * pixelsize) bytes past the end of the last input
<span class="lineNum">     125 </span>            :     // row. We only upload the first height-1 rows using GL_UNPACK_ROW_LENGTH,
<span class="lineNum">     126 </span>            :     // and then we upload the final row separately. See bug 697990.
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     int rowLength = stride/pixelsize;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     gl-&gt;fTexSubImage2D(target,</span>
<span class="lineNum">     130 </span>            :                        level,
<span class="lineNum">     131 </span>            :                        xoffset,
<span class="lineNum">     132 </span>            :                        yoffset,
<span class="lineNum">     133 </span>            :                        width,
<span class="lineNum">     134 </span>            :                        height-1,
<span class="lineNum">     135 </span>            :                        format,
<span class="lineNum">     136 </span>            :                        type,
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :                        pixels);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     gl-&gt;fTexSubImage2D(target,</span>
<span class="lineNum">     140 </span>            :                        level,
<span class="lineNum">     141 </span>            :                        xoffset,
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :                        yoffset+height-1,</span>
<span class="lineNum">     143 </span>            :                        width,
<span class="lineNum">     144 </span>            :                        1,
<span class="lineNum">     145 </span>            :                        format,
<span class="lineNum">     146 </span>            :                        type,
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                        (const unsigned char*)pixels+(height-1)*stride);</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 : }</span>
<a name="150"><span class="lineNum">     150 </span>            : </a>
<span class="lineNum">     151 </span>            : static void
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : TexSubImage2DWithoutUnpackSubimage(GLContext* gl,</span>
<span class="lineNum">     153 </span>            :                                    GLenum target, GLint level,
<span class="lineNum">     154 </span>            :                                    GLint xoffset, GLint yoffset,
<span class="lineNum">     155 </span>            :                                    GLsizei width, GLsizei height,
<span class="lineNum">     156 </span>            :                                    GLsizei stride, GLint pixelsize,
<span class="lineNum">     157 </span>            :                                    GLenum format, GLenum type,
<span class="lineNum">     158 </span>            :                                    const GLvoid* pixels)
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span>            :     // Not using the whole row of texture data and GL_UNPACK_ROW_LENGTH
<span class="lineNum">     161 </span>            :     // isn't supported. We make a copy of the texture data we're using,
<span class="lineNum">     162 </span>            :     // such that we're using the whole row of data in the copy. This turns
<span class="lineNum">     163 </span>            :     // out to be more efficient than uploading row-by-row; see bug 698197.
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     unsigned char* newPixels = new (fallible) unsigned char[width*height*pixelsize];</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     if (newPixels) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         unsigned char* rowDest = newPixels;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         const unsigned char* rowSource = (const unsigned char*)pixels;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         for (int h = 0; h &lt; height; h++) {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :             memcpy(rowDest, rowSource, width*pixelsize);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :             rowDest += width*pixelsize;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :             rowSource += stride;</span>
<span class="lineNum">     173 </span>            :         }
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         stride = width*pixelsize;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                          std::min(GetAddressAlignment((ptrdiff_t)newPixels),</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                                   GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     179 </span>            :         gl-&gt;fTexSubImage2D(target,
<span class="lineNum">     180 </span>            :                            level,
<span class="lineNum">     181 </span>            :                            xoffset,
<span class="lineNum">     182 </span>            :                            yoffset,
<span class="lineNum">     183 </span>            :                            width,
<span class="lineNum">     184 </span>            :                            height,
<span class="lineNum">     185 </span>            :                            format,
<span class="lineNum">     186 </span>            :                            type,
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :                            newPixels);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         delete [] newPixels;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     } else {
<span class="lineNum">     192 </span>            :         // If we did not have sufficient memory for the required
<span class="lineNum">     193 </span>            :         // temporary buffer, then fall back to uploading row-by-row.
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :         const unsigned char* rowSource = (const unsigned char*)pixels;</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                          std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :                                   GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; height; i++) {</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :             gl-&gt;fTexSubImage2D(target, level,</span>
<span class="lineNum">     202 </span>            :                                xoffset, yoffset + i,
<span class="lineNum">     203 </span>            :                                width, 1,
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                                format, type, rowSource);</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :             rowSource += stride;</span>
<span class="lineNum">     206 </span>            :         }
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : }</span>
<a name="211"><span class="lineNum">     211 </span>            : </a>
<span class="lineNum">     212 </span>            : static void
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : TexSubImage2DHelper(GLContext* gl,</span>
<span class="lineNum">     214 </span>            :                     GLenum target, GLint level,
<span class="lineNum">     215 </span>            :                     GLint xoffset, GLint yoffset,
<span class="lineNum">     216 </span>            :                     GLsizei width, GLsizei height, GLsizei stride,
<span class="lineNum">     217 </span>            :                     GLint pixelsize, GLenum format,
<span class="lineNum">     218 </span>            :                     GLenum type, const GLvoid* pixels)
<span class="lineNum">     219 </span>            : {
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     if (gl-&gt;IsGLES()) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         if (stride == width * pixelsize) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                              std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                                       GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     225 </span>            :             gl-&gt;fTexSubImage2D(target,
<span class="lineNum">     226 </span>            :                                level,
<span class="lineNum">     227 </span>            :                                xoffset,
<span class="lineNum">     228 </span>            :                                yoffset,
<span class="lineNum">     229 </span>            :                                width,
<span class="lineNum">     230 </span>            :                                height,
<span class="lineNum">     231 </span>            :                                format,
<span class="lineNum">     232 </span>            :                                type,
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                                pixels);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         } else if (gl-&gt;IsExtensionSupported(GLContext::EXT_unpack_subimage)) {</span>
<span class="lineNum">     236 </span>            :             TexSubImage2DWithUnpackSubimageGLES(gl, target, level, xoffset, yoffset,
<span class="lineNum">     237 </span>            :                                                 width, height, stride,
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                                                 pixelsize, format, type, pixels);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :         } else {
<span class="lineNum">     241 </span>            :             TexSubImage2DWithoutUnpackSubimage(gl, target, level, xoffset, yoffset,
<span class="lineNum">     242 </span>            :                                               width, height, stride,
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                                               pixelsize, format, type, pixels);</span>
<span class="lineNum">     244 </span>            :         }
<span class="lineNum">     245 </span>            :     } else {
<span class="lineNum">     246 </span>            :         // desktop GL (non-ES) path
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                          std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                                   GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         int rowLength = stride/pixelsize;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);</span>
<span class="lineNum">     252 </span>            :         gl-&gt;fTexSubImage2D(target,
<span class="lineNum">     253 </span>            :                            level,
<span class="lineNum">     254 </span>            :                            xoffset,
<span class="lineNum">     255 </span>            :                            yoffset,
<span class="lineNum">     256 </span>            :                            width,
<span class="lineNum">     257 </span>            :                            height,
<span class="lineNum">     258 </span>            :                            format,
<span class="lineNum">     259 </span>            :                            type,
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :                            pixels);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     263 </span>            :     }
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : }</span>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<span class="lineNum">     266 </span>            : static void
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : TexImage2DHelper(GLContext* gl,</span>
<span class="lineNum">     268 </span>            :                  GLenum target, GLint level, GLint internalformat,
<span class="lineNum">     269 </span>            :                  GLsizei width, GLsizei height, GLsizei stride,
<span class="lineNum">     270 </span>            :                  GLint pixelsize, GLint border, GLenum format,
<span class="lineNum">     271 </span>            :                  GLenum type, const GLvoid* pixels)
<span class="lineNum">     272 </span>            : {
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     if (gl-&gt;IsGLES()) {</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         NS_ASSERTION(format == (GLenum)internalformat,</span>
<span class="lineNum">     276 </span>            :                     &quot;format and internalformat not the same for glTexImage2D on GLES2&quot;);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         if (!CanUploadNonPowerOfTwo(gl)</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             &amp;&amp; (stride != width * pixelsize</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :             || !IsPowerOfTwo((uint32_t)width)</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             || !IsPowerOfTwo((uint32_t)height))) {</span>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :             // Pad out texture width and height to the next power of two
<span class="lineNum">     285 </span>            :             // as we don't support/want non power of two texture uploads
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :             GLsizei paddedWidth = RoundUpPow2((uint32_t)width);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :             GLsizei paddedHeight = RoundUpPow2((uint32_t)height);</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :             GLvoid* paddedPixels = new unsigned char[paddedWidth * paddedHeight * pixelsize];</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :             // Pad out texture data to be in a POT sized buffer for uploading to
<span class="lineNum">     292 </span>            :             // a POT sized texture
<span class="lineNum">     293 </span>            :             CopyAndPadTextureData(pixels, paddedPixels, width, height,
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                                   paddedWidth, paddedHeight, stride, pixelsize);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                              std::min(GetAddressAlignment((ptrdiff_t)paddedPixels),</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                                       GetAddressAlignment((ptrdiff_t)paddedWidth * pixelsize)));</span>
<span class="lineNum">     299 </span>            :             gl-&gt;fTexImage2D(target,
<span class="lineNum">     300 </span>            :                             border,
<span class="lineNum">     301 </span>            :                             internalformat,
<span class="lineNum">     302 </span>            :                             paddedWidth,
<span class="lineNum">     303 </span>            :                             paddedHeight,
<span class="lineNum">     304 </span>            :                             border,
<span class="lineNum">     305 </span>            :                             format,
<span class="lineNum">     306 </span>            :                             type,
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                             paddedPixels);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             delete[] static_cast&lt;unsigned char*&gt;(paddedPixels);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     312 </span>            :         }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         if (stride == width * pixelsize) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                              std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                                       GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     318 </span>            :             gl-&gt;fTexImage2D(target,
<span class="lineNum">     319 </span>            :                             border,
<span class="lineNum">     320 </span>            :                             internalformat,
<span class="lineNum">     321 </span>            :                             width,
<span class="lineNum">     322 </span>            :                             height,
<span class="lineNum">     323 </span>            :                             border,
<span class="lineNum">     324 </span>            :                             format,
<span class="lineNum">     325 </span>            :                             type,
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                             pixels);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :             gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     328 </span>            :         } else {
<span class="lineNum">     329 </span>            :             // Use GLES-specific workarounds for GL_UNPACK_ROW_LENGTH; these are
<span class="lineNum">     330 </span>            :             // implemented in TexSubImage2D.
<span class="lineNum">     331 </span>            :             gl-&gt;fTexImage2D(target,
<span class="lineNum">     332 </span>            :                             border,
<span class="lineNum">     333 </span>            :                             internalformat,
<span class="lineNum">     334 </span>            :                             width,
<span class="lineNum">     335 </span>            :                             height,
<span class="lineNum">     336 </span>            :                             border,
<span class="lineNum">     337 </span>            :                             format,
<span class="lineNum">     338 </span>            :                             type,
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                             nullptr);</span>
<span class="lineNum">     340 </span>            :             TexSubImage2DHelper(gl,
<span class="lineNum">     341 </span>            :                                 target,
<span class="lineNum">     342 </span>            :                                 level,
<span class="lineNum">     343 </span>            :                                 0,
<span class="lineNum">     344 </span>            :                                 0,
<span class="lineNum">     345 </span>            :                                 width,
<span class="lineNum">     346 </span>            :                                 height,
<span class="lineNum">     347 </span>            :                                 stride,
<span class="lineNum">     348 </span>            :                                 pixelsize,
<span class="lineNum">     349 </span>            :                                 format,
<span class="lineNum">     350 </span>            :                                 type,
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                                 pixels);</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span>            :     } else {
<span class="lineNum">     354 </span>            :         // desktop GL (non-ES) path
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT,</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                          std::min(GetAddressAlignment((ptrdiff_t)pixels),</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                                   GetAddressAlignment((ptrdiff_t)stride)));</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         int rowLength = stride/pixelsize;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, rowLength);</span>
<span class="lineNum">     361 </span>            :         gl-&gt;fTexImage2D(target,
<span class="lineNum">     362 </span>            :                         level,
<span class="lineNum">     363 </span>            :                         internalformat,
<span class="lineNum">     364 </span>            :                         width,
<span class="lineNum">     365 </span>            :                         height,
<span class="lineNum">     366 </span>            :                         border,
<span class="lineNum">     367 </span>            :                         format,
<span class="lineNum">     368 </span>            :                         type,
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                         pixels);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ROW_LENGTH, 0);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         gl-&gt;fPixelStorei(LOCAL_GL_UNPACK_ALIGNMENT, 4);</span>
<span class="lineNum">     372 </span>            :     }
<span class="lineNum">     373 </span>            : }
<a name="374"><span class="lineNum">     374 </span>            : </a>
<span class="lineNum">     375 </span>            : SurfaceFormat
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : UploadImageDataToTexture(GLContext* gl,</span>
<span class="lineNum">     377 </span>            :                          unsigned char* aData,
<span class="lineNum">     378 </span>            :                          int32_t aStride,
<span class="lineNum">     379 </span>            :                          SurfaceFormat aFormat,
<span class="lineNum">     380 </span>            :                          const nsIntRegion&amp; aDstRegion,
<span class="lineNum">     381 </span>            :                          GLuint aTexture,
<span class="lineNum">     382 </span>            :                          const gfx::IntSize&amp; aSize,
<span class="lineNum">     383 </span>            :                          size_t* aOutUploadSize,
<span class="lineNum">     384 </span>            :                          bool aNeedInit,
<span class="lineNum">     385 </span>            :                          GLenum aTextureUnit,
<span class="lineNum">     386 </span>            :                          GLenum aTextureTarget)
<span class="lineNum">     387 </span>            : {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     gl-&gt;MakeCurrent();</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     gl-&gt;fActiveTexture(aTextureUnit);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     gl-&gt;fBindTexture(aTextureTarget, aTexture);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     GLenum format = 0;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     GLenum internalFormat = 0;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     GLenum type = 0;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     int32_t pixelSize = BytesPerPixel(aFormat);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     SurfaceFormat surfaceFormat = gfx::SurfaceFormat::UNKNOWN;</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA ||</span>
<span class="lineNum">     399 </span>            :                gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_RGBA);
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     switch (aFormat) {</span>
<span class="lineNum">     402 </span>            :         case SurfaceFormat::B8G8R8A8:
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             if (gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_BGRA;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::R8G8B8A8;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;</span>
<span class="lineNum">     407 </span>            :             } else {
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_RGBA;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::B8G8R8A8;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     411 </span>            :             }
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :             internalFormat = LOCAL_GL_RGBA;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     414 </span>            :         case SurfaceFormat::B8G8R8X8:
<span class="lineNum">     415 </span>            :             // Treat BGRX surfaces as BGRA except for the surface
<span class="lineNum">     416 </span>            :             // format used.
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :             if (gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA) {</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_BGRA;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::R8G8B8X8;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;</span>
<span class="lineNum">     421 </span>            :             } else {
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_RGBA;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::B8G8R8X8;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     425 </span>            :             }
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             internalFormat = LOCAL_GL_RGBA;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     428 </span>            :         case SurfaceFormat::R8G8B8A8:
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             if (gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA) {</span>
<span class="lineNum">     430 </span>            :               // Upload our RGBA as BGRA, but store that the uploaded format is
<span class="lineNum">     431 </span>            :               // BGRA. (sample from R to get B)
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_BGRA;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::B8G8R8A8;</span>
<span class="lineNum">     435 </span>            :             } else {
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_RGBA;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::R8G8B8A8;</span>
<span class="lineNum">     439 </span>            :             }
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :             internalFormat = LOCAL_GL_RGBA;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     442 </span>            :         case SurfaceFormat::R8G8B8X8:
<span class="lineNum">     443 </span>            :             // Treat RGBX surfaces as RGBA except for the surface
<span class="lineNum">     444 </span>            :             // format used.
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :             if (gl-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_BGRA;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::B8G8R8X8;</span>
<span class="lineNum">     449 </span>            :             } else {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :               format = LOCAL_GL_RGBA;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :               type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :               surfaceFormat = SurfaceFormat::R8G8B8X8;</span>
<span class="lineNum">     453 </span>            :             }
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             internalFormat = LOCAL_GL_RGBA;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     456 </span>            :         case SurfaceFormat::R5G6B5_UINT16:
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :             internalFormat = format = LOCAL_GL_RGB;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :             type = LOCAL_GL_UNSIGNED_SHORT_5_6_5;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :             surfaceFormat = SurfaceFormat::R5G6B5_UINT16;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     461 </span>            :         case SurfaceFormat::A8:
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :             internalFormat = format = LOCAL_GL_LUMINANCE;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     464 </span>            :             // We don't have a specific luminance shader
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             surfaceFormat = SurfaceFormat::A8;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     467 </span>            :         default:
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :             NS_ASSERTION(false, &quot;Unhandled image surface format!&quot;);</span>
<span class="lineNum">     469 </span>            :     }
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     if (aOutUploadSize) {</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :         *aOutUploadSize = 0;</span>
<span class="lineNum">     473 </span>            :     }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     if (aNeedInit || !CanUploadSubTextures(gl)) {</span>
<span class="lineNum">     476 </span>            :         // If the texture needs initialized, or we are unable to
<span class="lineNum">     477 </span>            :         // upload sub textures, then initialize and upload the entire
<span class="lineNum">     478 </span>            :         // texture.
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         TexImage2DHelper(gl,</span>
<span class="lineNum">     480 </span>            :                          aTextureTarget,
<span class="lineNum">     481 </span>            :                          0,
<span class="lineNum">     482 </span>            :                          internalFormat,
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                          aSize.width,</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                          aSize.height,</span>
<span class="lineNum">     485 </span>            :                          aStride,
<span class="lineNum">     486 </span>            :                          pixelSize,
<span class="lineNum">     487 </span>            :                          0,
<span class="lineNum">     488 </span>            :                          format,
<span class="lineNum">     489 </span>            :                          type,
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                          aData);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         if (aOutUploadSize &amp;&amp; aNeedInit) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             uint32_t texelSize = GetBytesPerTexel(internalFormat, type);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :             size_t numTexels = size_t(aSize.width) * size_t(aSize.height);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             *aOutUploadSize += texelSize * numTexels;</span>
<span class="lineNum">     496 </span>            :         }
<span class="lineNum">     497 </span>            :     } else {
<span class="lineNum">     498 </span>            :         // Upload each rect in the region to the texture
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         for (auto iter = aDstRegion.RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             const IntRect&amp; rect = iter.Get();</span>
<span class="lineNum">     501 </span>            :             const unsigned char* rectData =
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                 aData + DataOffset(rect.TopLeft(), aStride, aFormat);</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :             TexSubImage2DHelper(gl,
<span class="lineNum">     505 </span>            :                                 aTextureTarget,
<span class="lineNum">     506 </span>            :                                 0,
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                                 rect.x,</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                                 rect.y,</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                                 rect.width,</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                                 rect.height,</span>
<span class="lineNum">     511 </span>            :                                 aStride,
<span class="lineNum">     512 </span>            :                                 pixelSize,
<span class="lineNum">     513 </span>            :                                 format,
<span class="lineNum">     514 </span>            :                                 type,
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                                 rectData);</span>
<span class="lineNum">     516 </span>            :         }
<span class="lineNum">     517 </span>            :     }
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     return surfaceFormat;</span>
<span class="lineNum">     520 </span>            : }
<a name="521"><span class="lineNum">     521 </span>            : </a>
<span class="lineNum">     522 </span>            : SurfaceFormat
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : UploadSurfaceToTexture(GLContext* gl,</span>
<span class="lineNum">     524 </span>            :                        DataSourceSurface* aSurface,
<span class="lineNum">     525 </span>            :                        const nsIntRegion&amp; aDstRegion,
<span class="lineNum">     526 </span>            :                        GLuint aTexture,
<span class="lineNum">     527 </span>            :                        const gfx::IntSize&amp; aSize,
<span class="lineNum">     528 </span>            :                        size_t* aOutUploadSize,
<span class="lineNum">     529 </span>            :                        bool aNeedInit,
<span class="lineNum">     530 </span>            :                        const gfx::IntPoint&amp; aSrcPoint,
<span class="lineNum">     531 </span>            :                        GLenum aTextureUnit,
<span class="lineNum">     532 </span>            :                        GLenum aTextureTarget)
<span class="lineNum">     533 </span>            : {
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     int32_t stride = aSurface-&gt;Stride();</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     SurfaceFormat format = aSurface-&gt;GetFormat();</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     unsigned char* data = aSurface-&gt;GetData() +</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :         DataOffset(aSrcPoint, stride, format);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     return UploadImageDataToTexture(gl, data, stride, format,</span>
<span class="lineNum">     541 </span>            :                                     aDstRegion, aTexture, aSize,
<span class="lineNum">     542 </span>            :                                     aOutUploadSize, aNeedInit,
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                                     aTextureUnit, aTextureTarget);</span>
<span class="lineNum">     544 </span>            : }
<a name="545"><span class="lineNum">     545 </span>            : </a>
<span class="lineNum">     546 </span>            : bool
<span class="lineNum">     547 </span><span class="lineNoCov">          0 : CanUploadNonPowerOfTwo(GLContext* gl)</span>
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if (!gl-&gt;WorkAroundDriverBugs())</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :     // Some GPUs driver crash when uploading non power of two 565 textures.
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     return gl-&gt;Renderer() != GLRenderer::Adreno200 &amp;&amp;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :            gl-&gt;Renderer() != GLRenderer::Adreno205;</span>
<span class="lineNum">     555 </span>            : }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : } // namespace gl
<span class="lineNum">     558 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

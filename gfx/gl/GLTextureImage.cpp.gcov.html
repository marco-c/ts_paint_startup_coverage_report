<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/gl/GLTextureImage.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/gl</a> - GLTextureImage.cpp<span style="font-size: 80%;"> (source / <a href="GLTextureImage.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">220</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40; -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;GLTextureImage.h&quot;
<span class="lineNum">       7 </span>            : #include &quot;GLContext.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;gfxContext.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;gfxPlatform.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;gfx2DGlue.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;ScopedGLHelpers.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;GLUploadHelpers.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;GfxTexturesReporter.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;TextureImageEGL.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : namespace mozilla {
<span class="lineNum">      22 </span>            : namespace gl {
<a name="23"><span class="lineNum">      23 </span>            : </a>
<span class="lineNum">      24 </span>            : already_AddRefed&lt;TextureImage&gt;
<span class="lineNum">      25 </span><span class="lineNoCov">          0 : CreateTextureImage(GLContext* gl,</span>
<span class="lineNum">      26 </span>            :                    const gfx::IntSize&amp; aSize,
<span class="lineNum">      27 </span>            :                    TextureImage::ContentType aContentType,
<span class="lineNum">      28 </span>            :                    GLenum aWrapMode,
<span class="lineNum">      29 </span>            :                    TextureImage::Flags aFlags,
<span class="lineNum">      30 </span>            :                    TextureImage::ImageFormat aImageFormat)
<span class="lineNum">      31 </span>            : {
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :     switch (gl-&gt;GetContextType()) {</span>
<span class="lineNum">      33 </span>            :         case GLContextType::EGL:
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :             return CreateTextureImageEGL(gl, aSize, aContentType, aWrapMode, aFlags, aImageFormat);</span>
<span class="lineNum">      35 </span>            :         default: {
<span class="lineNum">      36 </span>            :             GLint maxTextureSize;
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :             gl-&gt;fGetIntegerv(LOCAL_GL_MAX_TEXTURE_SIZE, &amp;maxTextureSize);</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :             if (aSize.width &gt; maxTextureSize || aSize.height &gt; maxTextureSize) {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :               NS_ASSERTION(aWrapMode == LOCAL_GL_CLAMP_TO_EDGE, &quot;Can't support wrapping with tiles!&quot;);</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :               return CreateTiledTextureImage(gl, aSize, aContentType, aFlags, aImageFormat);</span>
<span class="lineNum">      41 </span>            :             } else {
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :               return CreateBasicTextureImage(gl, aSize, aContentType, aWrapMode, aFlags);</span>
<span class="lineNum">      43 </span>            :             }
<span class="lineNum">      44 </span>            :         }
<span class="lineNum">      45 </span>            :     }
<span class="lineNum">      46 </span>            : }
<span class="lineNum">      47 </span>            : 
<a name="48"><span class="lineNum">      48 </span>            : </a>
<span class="lineNum">      49 </span>            : static already_AddRefed&lt;TextureImage&gt;
<span class="lineNum">      50 </span><span class="lineNoCov">          0 : TileGenFunc(GLContext* gl,</span>
<span class="lineNum">      51 </span>            :             const IntSize&amp; aSize,
<span class="lineNum">      52 </span>            :             TextureImage::ContentType aContentType,
<span class="lineNum">      53 </span>            :             TextureImage::Flags aFlags,
<span class="lineNum">      54 </span>            :             TextureImage::ImageFormat aImageFormat)
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     switch (gl-&gt;GetContextType()) {</span>
<span class="lineNum">      57 </span>            :         case GLContextType::EGL:
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :             return TileGenFuncEGL(gl, aSize, aContentType, aFlags, aImageFormat);</span>
<span class="lineNum">      59 </span>            :         default:
<span class="lineNum">      60 </span>            :             return CreateBasicTextureImage(gl, aSize, aContentType,
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :                                            LOCAL_GL_CLAMP_TO_EDGE, aFlags);</span>
<span class="lineNum">      62 </span>            :     }
<span class="lineNum">      63 </span>            : }
<a name="64"><span class="lineNum">      64 </span>            : </a>
<span class="lineNum">      65 </span>            : already_AddRefed&lt;TextureImage&gt;
<span class="lineNum">      66 </span><span class="lineNoCov">          0 : TextureImage::Create(GLContext* gl,</span>
<span class="lineNum">      67 </span>            :                      const gfx::IntSize&amp; size,
<span class="lineNum">      68 </span>            :                      TextureImage::ContentType contentType,
<span class="lineNum">      69 </span>            :                      GLenum wrapMode,
<span class="lineNum">      70 </span>            :                      TextureImage::Flags flags)
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     return CreateTextureImage(gl, size, contentType, wrapMode, flags);</span>
<span class="lineNum">      73 </span>            : }
<a name="74"><span class="lineNum">      74 </span>            : </a>
<span class="lineNum">      75 </span>            : bool
<span class="lineNum">      76 </span><span class="lineNoCov">          0 : TextureImage::UpdateFromDataSource(gfx::DataSourceSurface* aSurface,</span>
<span class="lineNum">      77 </span>            :                                    const nsIntRegion* aDestRegion,
<span class="lineNum">      78 </span>            :                                    const gfx::IntPoint* aSrcPoint)
<span class="lineNum">      79 </span>            : {
<span class="lineNum">      80 </span>            :     nsIntRegion destRegion = aDestRegion ? *aDestRegion
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :                                          : IntRect(0, 0,</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :                                                      aSurface-&gt;GetSize().width,</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :                                                      aSurface-&gt;GetSize().height);</span>
<span class="lineNum">      84 </span>            :     gfx::IntPoint srcPoint = aSrcPoint ? *aSrcPoint
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                                        : gfx::IntPoint(0, 0);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     return DirectUpdate(aSurface, destRegion, srcPoint);</span>
<a name="87"><span class="lineNum">      87 </span>            : }</a>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineNoCov">          0 : gfx::IntRect TextureImage::GetTileRect() {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     return gfx::IntRect(gfx::IntPoint(0,0), mSize);</span>
<a name="91"><span class="lineNum">      91 </span>            : }</a>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : gfx::IntRect TextureImage::GetSrcTileRect() {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     return GetTileRect();</span>
<span class="lineNum">      95 </span>            : }
<a name="96"><span class="lineNum">      96 </span>            : </a>
<span class="lineNum">      97 </span>            : void
<span class="lineNum">      98 </span><span class="lineNoCov">          0 : TextureImage::UpdateUploadSize(size_t amount)</span>
<span class="lineNum">      99 </span>            : {
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     if (mUploadSize &gt; 0) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         GfxTexturesReporter::UpdateAmount(GfxTexturesReporter::MemoryFreed, mUploadSize);</span>
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     mUploadSize = amount;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     GfxTexturesReporter::UpdateAmount(GfxTexturesReporter::MemoryAllocated, mUploadSize);</span>
<a name="105"><span class="lineNum">     105 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : BasicTextureImage::~BasicTextureImage()</span>
<span class="lineNum">     108 </span>            : {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     GLContext* ctx = mGLContext;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     if (ctx-&gt;IsDestroyed() || !ctx-&gt;IsOwningThreadCurrent()) {</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         ctx = ctx-&gt;GetSharedContext();</span>
<span class="lineNum">     112 </span>            :     }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :     // If we have a context, then we need to delete the texture;
<span class="lineNum">     115 </span>            :     // if we don't have a context (either real or shared),
<span class="lineNum">     116 </span>            :     // then they went away when the contex was deleted, because it
<span class="lineNum">     117 </span>            :     // was the only one that had access to it.
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     if (ctx &amp;&amp; ctx-&gt;MakeCurrent()) {</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         ctx-&gt;fDeleteTextures(1, &amp;mTexture);</span>
<span class="lineNum">     120 </span>            :     }
<span class="lineNum">     121 </span><span class="lineNoCov">          0 : }</span>
<a name="122"><span class="lineNum">     122 </span>            : </a>
<span class="lineNum">     123 </span>            : void
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : BasicTextureImage::BindTexture(GLenum aTextureUnit)</span>
<span class="lineNum">     125 </span>            : {
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     mGLContext-&gt;fActiveTexture(aTextureUnit);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     mGLContext-&gt;fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     mGLContext-&gt;fActiveTexture(LOCAL_GL_TEXTURE0);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : }</span>
<a name="130"><span class="lineNum">     130 </span>            : </a>
<span class="lineNum">     131 </span>            : bool
<span class="lineNum">     132 </span><span class="lineNoCov">          0 : BasicTextureImage::DirectUpdate(gfx::DataSourceSurface* aSurf, const nsIntRegion&amp; aRegion, const gfx::IntPoint&amp; aFrom /* = gfx::IntPoint(0, 0) */)</span>
<span class="lineNum">     133 </span>            : {
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     nsIntRegion region;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     if (mTextureState == Valid) {</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         region = aRegion;</span>
<span class="lineNum">     137 </span>            :     } else {
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         region = nsIntRegion(IntRect(0, 0, mSize.width, mSize.height));</span>
<span class="lineNum">     139 </span>            :     }
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     bool needInit = mTextureState == Created;</span>
<span class="lineNum">     141 </span>            :     size_t uploadSize;
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     mTextureFormat =</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         UploadSurfaceToTexture(mGLContext,</span>
<span class="lineNum">     145 </span>            :                                aSurf,
<span class="lineNum">     146 </span>            :                                region,
<span class="lineNum">     147 </span>            :                                mTexture,
<span class="lineNum">     148 </span>            :                                mSize,
<span class="lineNum">     149 </span>            :                                &amp;uploadSize,
<span class="lineNum">     150 </span>            :                                needInit,
<span class="lineNum">     151 </span>            :                                aFrom);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     if (uploadSize &gt; 0) {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         UpdateUploadSize(uploadSize);</span>
<span class="lineNum">     155 </span>            :     }
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     mTextureState = Valid;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     158 </span>            : }
<a name="159"><span class="lineNum">     159 </span>            : </a>
<span class="lineNum">     160 </span>            : void
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : BasicTextureImage::Resize(const gfx::IntSize&amp; aSize)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     mGLContext-&gt;fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     // This matches the logic in UploadImageDataToTexture so that
<span class="lineNum">     166 </span>            :     // we avoid mixing formats.
<span class="lineNum">     167 </span>            :     GLenum format;
<span class="lineNum">     168 </span>            :     GLenum type;
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     if (mGLContext-&gt;GetPreferredARGB32Format() == LOCAL_GL_BGRA) {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!mGLContext-&gt;IsGLES());</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         format = LOCAL_GL_BGRA;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         type = LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV;</span>
<span class="lineNum">     173 </span>            :     } else {
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         format = LOCAL_GL_RGBA;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         type = LOCAL_GL_UNSIGNED_BYTE;</span>
<span class="lineNum">     176 </span>            :     }
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     mGLContext-&gt;fTexImage2D(LOCAL_GL_TEXTURE_2D,</span>
<span class="lineNum">     179 </span>            :                             0,
<span class="lineNum">     180 </span>            :                             LOCAL_GL_RGBA,
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :                             aSize.width,</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :                             aSize.height,</span>
<span class="lineNum">     183 </span>            :                             0,
<span class="lineNum">     184 </span>            :                             format,
<span class="lineNum">     185 </span>            :                             type,
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                             nullptr);</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     mTextureState = Allocated;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     mSize = aSize;</span>
<a name="190"><span class="lineNum">     190 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 : gfx::IntSize TextureImage::GetSize() const {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   return mSize;</span>
<a name="194"><span class="lineNum">     194 </span>            : }</a>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : TextureImage::TextureImage(const gfx::IntSize&amp; aSize,</span>
<span class="lineNum">     197 </span>            :              GLenum aWrapMode, ContentType aContentType,
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :              Flags aFlags)</span>
<span class="lineNum">     199 </span>            :     : mSize(aSize)
<span class="lineNum">     200 </span>            :     , mWrapMode(aWrapMode)
<span class="lineNum">     201 </span>            :     , mContentType(aContentType)
<span class="lineNum">     202 </span>            :     , mTextureFormat(gfx::SurfaceFormat::UNKNOWN)
<span class="lineNum">     203 </span>            :     , mSamplingFilter(SamplingFilter::GOOD)
<span class="lineNum">     204 </span>            :     , mFlags(aFlags)
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     , mUploadSize(0)</span>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 : {}</span></a>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 : BasicTextureImage::BasicTextureImage(GLuint aTexture,</span>
<span class="lineNum">     209 </span>            :                   const gfx::IntSize&amp; aSize,
<span class="lineNum">     210 </span>            :                   GLenum aWrapMode,
<span class="lineNum">     211 </span>            :                   ContentType aContentType,
<span class="lineNum">     212 </span>            :                   GLContext* aContext,
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :                   TextureImage::Flags aFlags)</span>
<span class="lineNum">     214 </span>            :   : TextureImage(aSize, aWrapMode, aContentType, aFlags)
<span class="lineNum">     215 </span>            :   , mTexture(aTexture)
<span class="lineNum">     216 </span>            :   , mTextureState(Created)
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   , mGLContext(aContext)</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : {}</span>
<a name="219"><span class="lineNum">     219 </span>            : </a>
<span class="lineNum">     220 </span>            : static bool
<span class="lineNum">     221 </span><span class="lineNoCov">          0 : WantsSmallTiles(GLContext* gl)</span>
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span>            :     // We can't use small tiles on the SGX 540, because of races in texture upload.
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if (gl-&gt;WorkAroundDriverBugs() &amp;&amp;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         gl-&gt;Renderer() == GLRenderer::SGX540)</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :     // We should use small tiles for good performance if we can't use
<span class="lineNum">     229 </span>            :     // glTexSubImage2D() for some reason.
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     if (!CanUploadSubTextures(gl))</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :     // Don't use small tiles otherwise. (If we implement incremental texture upload,
<span class="lineNum">     234 </span>            :     // then we will want to revisit this.)
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="236"><span class="lineNum">     236 </span>            : }</a>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : TiledTextureImage::TiledTextureImage(GLContext* aGL,</span>
<span class="lineNum">     239 </span>            :                                      gfx::IntSize aSize,
<span class="lineNum">     240 </span>            :                                      TextureImage::ContentType aContentType,
<span class="lineNum">     241 </span>            :                                      TextureImage::Flags aFlags,
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :                                      TextureImage::ImageFormat aImageFormat)</span>
<span class="lineNum">     243 </span>            :     : TextureImage(aSize, LOCAL_GL_CLAMP_TO_EDGE, aContentType, aFlags)
<span class="lineNum">     244 </span>            :     , mCurrentImage(0)
<span class="lineNum">     245 </span>            :     , mIterationCallback(nullptr)
<span class="lineNum">     246 </span>            :     , mIterationCallbackData(nullptr)
<span class="lineNum">     247 </span>            :     , mRows(0)
<span class="lineNum">     248 </span>            :     , mColumns(0)
<span class="lineNum">     249 </span>            :     , mGL(aGL)
<span class="lineNum">     250 </span>            :     , mTextureState(Created)
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     , mImageFormat(aImageFormat)</span>
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     if (!(aFlags &amp; TextureImage::DisallowBigImage) &amp;&amp; WantsSmallTiles(mGL)) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       mTileSize = 256;</span>
<span class="lineNum">     255 </span>            :     } else {
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       mGL-&gt;fGetIntegerv(LOCAL_GL_MAX_TEXTURE_SIZE, (GLint*) &amp;mTileSize);</span>
<span class="lineNum">     257 </span>            :     }
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     if (aSize.width != 0 &amp;&amp; aSize.height != 0) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :         Resize(aSize);</span>
<span class="lineNum">     260 </span>            :     }
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 : TiledTextureImage::~TiledTextureImage()</span>
<span class="lineNum">     264 </span>            : {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 : }</span>
<a name="266"><span class="lineNum">     266 </span>            : </a>
<span class="lineNum">     267 </span>            : bool
<span class="lineNum">     268 </span><span class="lineNoCov">          0 : TiledTextureImage::DirectUpdate(gfx::DataSourceSurface* aSurf, const nsIntRegion&amp; aRegion, const gfx::IntPoint&amp; aFrom /* = gfx::IntPoint(0, 0) */)</span>
<span class="lineNum">     269 </span>            : {
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     if (mSize.width == 0 || mSize.height == 0) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     nsIntRegion region;</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     if (mTextureState != Valid) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         IntRect bounds = IntRect(0, 0, mSize.width, mSize.height);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         region = nsIntRegion(bounds);</span>
<span class="lineNum">     279 </span>            :     } else {
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         region = aRegion;</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     bool result = true;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     int oldCurrentImage = mCurrentImage;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     BeginBigImageIteration();</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         IntRect tileRect = GetSrcTileRect();</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         int xPos = tileRect.x;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         int yPos = tileRect.y;</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         nsIntRegion tileRegion;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         tileRegion.And(region, tileRect); // intersect with tile</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         if (tileRegion.IsEmpty())</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         tileRegion.MoveBy(-xPos, -yPos); // translate into tile local space</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         result &amp;= mImages[mCurrentImage]-&gt;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :           DirectUpdate(aSurf, tileRegion, aFrom + gfx::IntPoint(xPos, yPos));</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         if (mCurrentImage == mImages.Length() - 1) {</span>
<span class="lineNum">     303 </span>            :             // We know we're done, but we still need to ensure that the callback
<span class="lineNum">     304 </span>            :             // gets called (e.g. to update the uploaded region).
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :             NextTile();</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     307 </span>            :         }
<span class="lineNum">     308 </span>            :         // Override a callback cancelling iteration if the texture wasn't valid.
<span class="lineNum">     309 </span>            :         // We need to force the update in that situation, or we may end up
<span class="lineNum">     310 </span>            :         // showing invalid/out-of-date texture data.
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     } while (NextTile() || (mTextureState != Valid));</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     mCurrentImage = oldCurrentImage;</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     mTextureFormat = mImages[0]-&gt;GetTextureFormat();</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     mTextureState = Valid;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="317"><span class="lineNum">     317 </span>            : }</a>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : void TiledTextureImage::BeginBigImageIteration()</span>
<span class="lineNum">     320 </span>            : {
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     mCurrentImage = 0;</span>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 : bool TiledTextureImage::NextTile()</span>
<span class="lineNum">     325 </span>            : {
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     bool continueIteration = true;</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     if (mIterationCallback)</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         continueIteration = mIterationCallback(this, mCurrentImage,</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                                                mIterationCallbackData);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     if (mCurrentImage + 1 &lt; mImages.Length()) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         mCurrentImage++;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         return continueIteration;</span>
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="337"><span class="lineNum">     337 </span>            : }</a>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 : void TiledTextureImage::SetIterationCallback(BigImageIterationCallback aCallback,</span>
<span class="lineNum">     340 </span>            :                                              void* aCallbackData)
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     mIterationCallback = aCallback;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     mIterationCallbackData = aCallbackData;</span>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 : gfx::IntRect TiledTextureImage::GetTileRect()</span>
<span class="lineNum">     347 </span>            : {
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     if (!GetTileCount()) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         return gfx::IntRect();</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     gfx::IntRect rect = mImages[mCurrentImage]-&gt;GetTileRect();</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     unsigned int xPos = (mCurrentImage % mColumns) * mTileSize;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     unsigned int yPos = (mCurrentImage / mColumns) * mTileSize;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     rect.MoveBy(xPos, yPos);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     return rect;</span>
<a name="356"><span class="lineNum">     356 </span>            : }</a>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 : gfx::IntRect TiledTextureImage::GetSrcTileRect()</span>
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     gfx::IntRect rect = GetTileRect();</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     const bool needsYFlip = mFlags &amp; OriginBottomLeft;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     unsigned int srcY = needsYFlip ? mSize.height - rect.height - rect.y</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                                    : rect.y;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     return gfx::IntRect(rect.x, srcY, rect.width, rect.height);</span>
<span class="lineNum">     365 </span>            : }
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : void
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : TiledTextureImage::BindTexture(GLenum aTextureUnit)</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     if (!GetTileCount()) {</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     372 </span>            :     }
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     mImages[mCurrentImage]-&gt;BindTexture(aTextureUnit);</span>
<span class="lineNum">     374 </span>            : }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : /*
<span class="lineNum">     377 </span>            :  * Resize, trying to reuse tiles. The reuse strategy is to decide on reuse per
<span class="lineNum">     378 </span>            :  * column. A tile on a column is reused if it hasn't changed size, otherwise it
<span class="lineNum">     379 </span>            :  * is discarded/replaced. Extra tiles on a column are pruned after iterating
<span class="lineNum">     380 </span>            :  * each column, and extra rows are pruned after iteration over the entire image
<a name="381"><span class="lineNum">     381 </span>            :  * finishes.</a>
<span class="lineNum">     382 </span>            :  */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 : void TiledTextureImage::Resize(const gfx::IntSize&amp; aSize)</span>
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     if (mSize == aSize &amp;&amp; mTextureState != Created) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     387 </span>            :     }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :     // calculate rows and columns, rounding up
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     unsigned int columns = (aSize.width  + mTileSize - 1) / mTileSize;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     unsigned int rows = (aSize.height + mTileSize - 1) / mTileSize;</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :     // Iterate over old tile-store and insert/remove tiles as necessary
<span class="lineNum">     394 </span>            :     int row;
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     unsigned int i = 0;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     for (row = 0; row &lt; (int)rows; row++) {</span>
<span class="lineNum">     397 </span>            :         // If we've gone beyond how many rows there were before, set mColumns to
<span class="lineNum">     398 </span>            :         // zero so that we only create new tiles.
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         if (row &gt;= (int)mRows)</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :             mColumns = 0;</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :         // Similarly, if we're on the last row of old tiles and the height has
<span class="lineNum">     403 </span>            :         // changed, discard all tiles in that row.
<span class="lineNum">     404 </span>            :         // This will cause the pruning of columns not to work, but we don't need
<span class="lineNum">     405 </span>            :         // to worry about that, as no more tiles will be reused past this point
<span class="lineNum">     406 </span>            :         // anyway.
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         if ((row == (int)mRows - 1) &amp;&amp; (aSize.height != mSize.height))</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :             mColumns = 0;</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :         int col;
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         for (col = 0; col &lt; (int)columns; col++) {</span>
<span class="lineNum">     412 </span>            :             IntSize size( // use tilesize first, then the remainder
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :                     (col+1) * mTileSize &gt; (unsigned int)aSize.width  ? aSize.width  % mTileSize : mTileSize,</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                     (row+1) * mTileSize &gt; (unsigned int)aSize.height ? aSize.height % mTileSize : mTileSize);</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :             bool replace = false;</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :             // Check if we can re-use old tiles.
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :             if (col &lt; (int)mColumns) {</span>
<span class="lineNum">     420 </span>            :                 // Reuse an existing tile. If the tile is an end-tile and the
<span class="lineNum">     421 </span>            :                 // width differs, replace it instead.
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                 if (mSize.width != aSize.width) {</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                     if (col == (int)mColumns - 1) {</span>
<span class="lineNum">     424 </span>            :                         // Tile at the end of the old column, replace it with
<span class="lineNum">     425 </span>            :                         // a new one.
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                         replace = true;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                     } else if (col == (int)columns - 1) {</span>
<span class="lineNum">     428 </span>            :                         // Tile at the end of the new column, create a new one.
<span class="lineNum">     429 </span>            :                     } else {
<span class="lineNum">     430 </span>            :                         // Before the last column on both the old and new sizes,
<span class="lineNum">     431 </span>            :                         // reuse existing tile.
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                         i++;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     434 </span>            :                     }
<span class="lineNum">     435 </span>            :                 } else {
<span class="lineNum">     436 </span>            :                     // Width hasn't changed, reuse existing tile.
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                     i++;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">     439 </span>            :                 }
<span class="lineNum">     440 </span>            :             }
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :             // Create a new tile.
<span class="lineNum">     443 </span>            :             RefPtr&lt;TextureImage&gt; teximg =
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                 TileGenFunc(mGL, size, mContentType, mFlags, mImageFormat);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :             if (replace)</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                 mImages.ReplaceElementAt(i, teximg);</span>
<span class="lineNum">     447 </span>            :             else
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                 mImages.InsertElementAt(i, teximg);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :             i++;</span>
<span class="lineNum">     450 </span>            :         }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :         // Prune any unused tiles on the end of the column.
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         if (row &lt; (int)mRows) {</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             for (col = (int)mColumns - col; col &gt; 0; col--) {</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 mImages.RemoveElementAt(i);</span>
<span class="lineNum">     456 </span>            :             }
<span class="lineNum">     457 </span>            :         }
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :     // Prune any unused tiles at the end of the store.
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     unsigned int length = mImages.Length();</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     for (; i &lt; length; i++)</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       mImages.RemoveElementAt(mImages.Length()-1);</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :     // Reset tile-store properties.
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     mRows = rows;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     mColumns = columns;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     mSize = aSize;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     mTextureState = Allocated;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     mCurrentImage = 0;</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : uint32_t TiledTextureImage::GetTileCount()</span>
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     return mImages.Length();</span>
<span class="lineNum">     476 </span>            : }
<a name="477"><span class="lineNum">     477 </span>            : </a>
<span class="lineNum">     478 </span>            : already_AddRefed&lt;TextureImage&gt;
<span class="lineNum">     479 </span><span class="lineNoCov">          0 : CreateTiledTextureImage(GLContext* aGL,</span>
<span class="lineNum">     480 </span>            :                         const gfx::IntSize&amp; aSize,
<span class="lineNum">     481 </span>            :                         TextureImage::ContentType aContentType,
<span class="lineNum">     482 </span>            :                         TextureImage::Flags aFlags,
<span class="lineNum">     483 </span>            :                         TextureImage::ImageFormat aImageFormat)
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span>            :   RefPtr&lt;TextureImage&gt; texImage = static_cast&lt;TextureImage*&gt;(
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       new gl::TiledTextureImage(aGL, aSize, aContentType, aFlags, aImageFormat));</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   return texImage.forget();</span>
<span class="lineNum">     488 </span>            : }
<span class="lineNum">     489 </span>            : 
<a name="490"><span class="lineNum">     490 </span>            : </a>
<span class="lineNum">     491 </span>            : already_AddRefed&lt;TextureImage&gt;
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : CreateBasicTextureImage(GLContext* aGL,</span>
<span class="lineNum">     493 </span>            :                         const gfx::IntSize&amp; aSize,
<span class="lineNum">     494 </span>            :                         TextureImage::ContentType aContentType,
<span class="lineNum">     495 </span>            :                         GLenum aWrapMode,
<span class="lineNum">     496 </span>            :                         TextureImage::Flags aFlags)
<span class="lineNum">     497 </span>            : {
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     bool useNearestFilter = aFlags &amp; TextureImage::UseNearestFilter;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     if (!aGL-&gt;MakeCurrent()) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     GLuint texture = 0;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     aGL-&gt;fGenTextures(1, &amp;texture);</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     ScopedBindTexture bind(aGL, texture);</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     GLint texfilter = useNearestFilter ? LOCAL_GL_NEAREST : LOCAL_GL_LINEAR;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     aGL-&gt;fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, texfilter);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     aGL-&gt;fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, texfilter);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     aGL-&gt;fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, aWrapMode);</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     aGL-&gt;fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, aWrapMode);</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     RefPtr&lt;BasicTextureImage&gt; texImage =
<span class="lineNum">     515 </span>            :         new BasicTextureImage(texture, aSize, aWrapMode, aContentType,
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                               aGL, aFlags);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     return texImage.forget();</span>
<span class="lineNum">     518 </span>            : }
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : } // namespace gl
<span class="lineNum">     521 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

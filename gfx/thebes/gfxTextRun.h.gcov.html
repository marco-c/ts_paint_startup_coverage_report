<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/thebes/gfxTextRun.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/thebes</a> - gfxTextRun.h<span style="font-size: 80%;"> (source / <a href="gfxTextRun.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">111</td>
            <td class="headerCovTableEntry">221</td>
            <td class="headerCovTableEntryLo">50.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">45</td>
            <td class="headerCovTableEntry">78</td>
            <td class="headerCovTableEntryLo">57.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=4 et sw=4 tw=80:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef GFX_TEXTRUN_H
<span class="lineNum">       8 </span>            : #define GFX_TEXTRUN_H
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;gfxTypes.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;gfxPoint.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;gfxFont.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;gfxFontConstants.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;gfxSkipChars.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;gfxPlatform.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mozilla/RefPtr.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsPoint.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsTextFrameUtils.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;DrawMode.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;harfbuzz/hb.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsUnicodeScriptCodes.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsColor.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;X11UndefineNone.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #ifdef DEBUG
<span class="lineNum">      31 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : class gfxContext;
<span class="lineNum">      35 </span>            : class gfxFontGroup;
<span class="lineNum">      36 </span>            : class gfxUserFontEntry;
<span class="lineNum">      37 </span>            : class gfxUserFontSet;
<span class="lineNum">      38 </span>            : class nsIAtom;
<span class="lineNum">      39 </span>            : class nsLanguageAtomService;
<span class="lineNum">      40 </span>            : class gfxMissingFontRecorder;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : namespace mozilla {
<span class="lineNum">      43 </span>            : class SVGContextPaint;
<span class="lineNum">      44 </span>            : enum class StyleHyphens : uint8_t;
<span class="lineNum">      45 </span>            : };
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : /**
<span class="lineNum">      48 </span>            :  * Callback for Draw() to use when drawing text with mode
<span class="lineNum">      49 </span>            :  * DrawMode::GLYPH_PATH.
<span class="lineNum">      50 </span>            :  */
<span class="lineNum">      51 </span>            : struct gfxTextRunDrawCallbacks {
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :     /**
<span class="lineNum">      54 </span>            :      * Constructs a new DrawCallbacks object.
<span class="lineNum">      55 </span>            :      *
<span class="lineNum">      56 </span>            :      * @param aShouldPaintSVGGlyphs If true, SVG glyphs will be painted.  If
<span class="lineNum">      57 </span>            :      *   false, SVG glyphs will not be painted; fallback plain glyphs are not
<a name="58"><span class="lineNum">      58 </span>            :      *   emitted either.</a>
<span class="lineNum">      59 </span>            :      */
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     explicit gfxTextRunDrawCallbacks(bool aShouldPaintSVGGlyphs = false)</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :       : mShouldPaintSVGGlyphs(aShouldPaintSVGGlyphs)</span>
<span class="lineNum">      62 </span>            :     {
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :     /**
<span class="lineNum">      66 </span>            :      * Called when a path has been emitted to the gfxContext when
<span class="lineNum">      67 </span>            :      * painting a text run.  This can be called any number of times,
<span class="lineNum">      68 </span>            :      * due to partial ligatures and intervening SVG glyphs.
<span class="lineNum">      69 </span>            :      */
<span class="lineNum">      70 </span>            :     virtual void NotifyGlyphPathEmitted() = 0;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :     bool mShouldPaintSVGGlyphs;
<span class="lineNum">      73 </span>            : };
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /**
<span class="lineNum">      76 </span>            :  * gfxTextRun is an abstraction for drawing and measuring substrings of a run
<span class="lineNum">      77 </span>            :  * of text. It stores runs of positioned glyph data, each run having a single
<span class="lineNum">      78 </span>            :  * gfxFont. The glyphs are associated with a string of source text, and the
<span class="lineNum">      79 </span>            :  * gfxTextRun APIs take parameters that are offsets into that source text.
<span class="lineNum">      80 </span>            :  *
<span class="lineNum">      81 </span>            :  * gfxTextRuns are mostly immutable. The only things that can change are
<span class="lineNum">      82 </span>            :  * inter-cluster spacing and line break placement. Spacing is always obtained
<span class="lineNum">      83 </span>            :  * lazily by methods that need it, it is not cached. Line breaks are stored
<span class="lineNum">      84 </span>            :  * persistently (insofar as they affect the shaping of glyphs; gfxTextRun does
<span class="lineNum">      85 </span>            :  * not actually do anything to explicitly account for line breaks). Initially
<span class="lineNum">      86 </span>            :  * there are no line breaks. The textrun can record line breaks before or after
<span class="lineNum">      87 </span>            :  * any given cluster. (Line breaks specified inside clusters are ignored.)
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  * It is important that zero-length substrings are handled correctly. This will
<span class="lineNum">      90 </span>            :  * be on the test!
<span class="lineNum">      91 </span>            :  */
<a name="92"><span class="lineNum">      92 </span>            : class gfxTextRun : public gfxShapedText</a>
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span><span class="lineCov">        418 :     NS_INLINE_DECL_REFCOUNTING(gfxTextRun);</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : protected:
<a name="97"><span class="lineNum">      97 </span>            :     // Override operator delete to properly free the object that was</a>
<span class="lineNum">      98 </span>            :     // allocated via malloc.
<span class="lineNum">      99 </span><span class="lineCov">         71 :     void operator delete(void* p) {</span>
<span class="lineNum">     100 </span><span class="lineCov">         71 :         free(p);</span>
<span class="lineNum">     101 </span><span class="lineCov">         71 :     }</span>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :     virtual ~gfxTextRun();
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : public:
<span class="lineNum">     106 </span>            :     typedef gfxFont::RunMetrics Metrics;
<span class="lineNum">     107 </span>            :     typedef mozilla::gfx::DrawTarget DrawTarget;
<span class="lineNum">     108 </span>            : 
<a name="109"><span class="lineNum">     109 </span>            :     // Public textrun API for general use</a>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span><span class="lineCov">          2 :     bool IsClusterStart(uint32_t aPos) const {</span>
<span class="lineNum">     112 </span><span class="lineCov">          2 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">          2 :         return mCharacterGlyphs[aPos].IsClusterStart();</span></a>
<span class="lineNum">     114 </span>            :     }
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     bool IsLigatureGroupStart(uint32_t aPos) const {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :         return mCharacterGlyphs[aPos].IsLigatureGroupStart();</span></a>
<span class="lineNum">     118 </span>            :     }
<span class="lineNum">     119 </span><span class="lineCov">        164 :     bool CanBreakLineBefore(uint32_t aPos) const {</span>
<a name="120"><span class="lineNum">     120 </span><span class="lineCov">        164 :         return CanBreakBefore(aPos) == CompressedGlyph::FLAG_BREAK_TYPE_NORMAL;</span></a>
<span class="lineNum">     121 </span>            :     }
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     bool CanHyphenateBefore(uint32_t aPos) const {</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         return CanBreakBefore(aPos) == CompressedGlyph::FLAG_BREAK_TYPE_HYPHEN;</span>
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span>            : 
<a name="126"><span class="lineNum">     126 </span>            :     // Returns a gfxShapedText::CompressedGlyph::FLAG_BREAK_TYPE_* value</a>
<span class="lineNum">     127 </span>            :     // as defined in gfxFont.h (may be NONE, NORMAL or HYPHEN).
<span class="lineNum">     128 </span><span class="lineCov">        164 :     uint8_t CanBreakBefore(uint32_t aPos) const {</span>
<span class="lineNum">     129 </span><span class="lineCov">        164 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<span class="lineNum">     130 </span><span class="lineCov">        164 :         return mCharacterGlyphs[aPos].CanBreakBefore();</span>
<span class="lineNum">     131 </span>            :     }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     bool CharIsSpace(uint32_t aPos) const {
<span class="lineNum">     134 </span>            :         MOZ_ASSERT(aPos &lt; GetLength());
<a name="135"><span class="lineNum">     135 </span>            :         return mCharacterGlyphs[aPos].CharIsSpace();</a>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span><span class="lineCov">        208 :     bool CharIsTab(uint32_t aPos) const {</span>
<span class="lineNum">     138 </span><span class="lineCov">        208 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<a name="139"><span class="lineNum">     139 </span><span class="lineCov">        208 :         return mCharacterGlyphs[aPos].CharIsTab();</span></a>
<span class="lineNum">     140 </span>            :     }
<span class="lineNum">     141 </span><span class="lineCov">        208 :     bool CharIsNewline(uint32_t aPos) const {</span>
<span class="lineNum">     142 </span><span class="lineCov">        208 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<a name="143"><span class="lineNum">     143 </span><span class="lineCov">        208 :         return mCharacterGlyphs[aPos].CharIsNewline();</span></a>
<span class="lineNum">     144 </span>            :     }
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     bool CharMayHaveEmphasisMark(uint32_t aPos) const {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(aPos &lt; GetLength());</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :         return mCharacterGlyphs[aPos].CharMayHaveEmphasisMark();</span>
<span class="lineNum">     148 </span>            :     }
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :     // All offsets are in terms of the string passed into MakeTextRun.
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     // Describe range [start, end) of a text run. The range is
<span class="lineNum">     153 </span>            :     // restricted to grapheme cluster boundaries.
<span class="lineNum">     154 </span>            :     struct Range
<span class="lineNum">     155 </span>            :     {
<a name="156"><span class="lineNum">     156 </span>            :         uint32_t start;</a>
<span class="lineNum">     157 </span>            :         uint32_t end;
<a name="158"><span class="lineNum">     158 </span><span class="lineCov">        122 :         uint32_t Length() const { return end - start; }</span></a>
<a name="159"><span class="lineNum">     159 </span>            : </a>
<span class="lineNum">     160 </span><span class="lineCov">         19 :         Range() : start(0), end(0) {}</span>
<a name="161"><span class="lineNum">     161 </span><span class="lineCov">        980 :         Range(uint32_t aStart, uint32_t aEnd)</span></a>
<span class="lineNum">     162 </span><span class="lineCov">        980 :             : start(aStart), end(aEnd) {}</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         explicit Range(const gfxTextRun* aTextRun)</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :             : start(0), end(aTextRun-&gt;GetLength()) {}</span>
<span class="lineNum">     165 </span>            :     };
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     // All coordinates are in layout/app units
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :     /**
<span class="lineNum">     170 </span>            :      * Set the potential linebreaks for a substring of the textrun. These are
<span class="lineNum">     171 </span>            :      * the &quot;allow break before&quot; points. Initially, there are no potential
<span class="lineNum">     172 </span>            :      * linebreaks.
<span class="lineNum">     173 </span>            :      *
<span class="lineNum">     174 </span>            :      * This can change glyphs and/or geometry! Some textruns' shapes
<span class="lineNum">     175 </span>            :      * depend on potential line breaks (e.g., title-case-converting textruns).
<span class="lineNum">     176 </span>            :      * This function is virtual so that those textruns can reshape themselves.
<span class="lineNum">     177 </span>            :      *
<span class="lineNum">     178 </span>            :      * @return true if this changed the linebreaks, false if the new line
<span class="lineNum">     179 </span>            :      * breaks are the same as the old
<span class="lineNum">     180 </span>            :      */
<span class="lineNum">     181 </span>            :     virtual bool SetPotentialLineBreaks(Range aRange,
<span class="lineNum">     182 </span>            :                                         const uint8_t* aBreakBefore);
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :     enum class HyphenType : uint8_t {
<span class="lineNum">     185 </span>            :       None,
<span class="lineNum">     186 </span>            :       Explicit,
<span class="lineNum">     187 </span>            :       Soft,
<span class="lineNum">     188 </span>            :       AutoWithManualInSameWord,
<span class="lineNum">     189 </span>            :       AutoWithoutManualInSameWord
<span class="lineNum">     190 </span>            :     };
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :     struct HyphenationState {
<span class="lineNum">     193 </span>            :       uint32_t mostRecentBoundary = 0;
<span class="lineNum">     194 </span>            :       bool     hasManualHyphen = false;
<span class="lineNum">     195 </span>            :       bool     hasExplicitHyphen = false;
<span class="lineNum">     196 </span>            :       bool     hasAutoHyphen = false;
<span class="lineNum">     197 </span>            :     };
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :     /**
<span class="lineNum">     200 </span>            :      * Layout provides PropertyProvider objects. These allow detection of
<span class="lineNum">     201 </span>            :      * potential line break points and computation of spacing. We pass the data
<span class="lineNum">     202 </span>            :      * this way to allow lazy data acquisition; for example BreakAndMeasureText
<span class="lineNum">     203 </span>            :      * will want to only ask for properties of text it's actually looking at.
<span class="lineNum">     204 </span>            :      *
<span class="lineNum">     205 </span>            :      * NOTE that requested spacing may not actually be applied, if the textrun
<span class="lineNum">     206 </span>            :      * is unable to apply it in some context. Exception: spacing around a
<a name="207"><span class="lineNum">     207 </span>            :      * whitespace character MUST always be applied.</a>
<span class="lineNum">     208 </span>            :      */
<span class="lineNum">     209 </span><span class="lineCov">         80 :     class PropertyProvider {</span>
<span class="lineNum">     210 </span>            :     public:
<span class="lineNum">     211 </span>            :         // Detect hyphenation break opportunities in the given range; breaks
<span class="lineNum">     212 </span>            :         // not at cluster boundaries will be ignored.
<span class="lineNum">     213 </span>            :         virtual void GetHyphenationBreaks(Range aRange,
<span class="lineNum">     214 </span>            :                                           HyphenType *aBreakBefore) const = 0;
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :         // Returns the provider's hyphenation setting, so callers can decide
<span class="lineNum">     217 </span>            :         // whether it is necessary to call GetHyphenationBreaks.
<span class="lineNum">     218 </span>            :         // Result is an StyleHyphens value.
<span class="lineNum">     219 </span>            :         virtual mozilla::StyleHyphens GetHyphensOption() const = 0;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :         // Returns the extra width that will be consumed by a hyphen. This should
<span class="lineNum">     222 </span>            :         // be constant for a given textrun.
<span class="lineNum">     223 </span>            :         virtual gfxFloat GetHyphenWidth() const = 0;
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :         typedef gfxFont::Spacing Spacing;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :         /**
<span class="lineNum">     228 </span>            :          * Get the spacing around the indicated characters. Spacing must be zero
<span class="lineNum">     229 </span>            :          * inside clusters. In other words, if character i is not
<span class="lineNum">     230 </span>            :          * CLUSTER_START, then character i-1 must have zero after-spacing and
<span class="lineNum">     231 </span>            :          * character i must have zero before-spacing.
<span class="lineNum">     232 </span>            :          */
<span class="lineNum">     233 </span>            :         virtual void GetSpacing(Range aRange, Spacing *aSpacing) const = 0;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :         // Returns a gfxContext that can be used to measure the hyphen glyph.
<span class="lineNum">     236 </span>            :         // Only called if the hyphen width is requested.
<span class="lineNum">     237 </span>            :         virtual already_AddRefed&lt;DrawTarget&gt; GetDrawTarget() const = 0;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :         // Return the appUnitsPerDevUnit value to be used when measuring.
<span class="lineNum">     240 </span>            :         // Only called if the hyphen width is requested.
<span class="lineNum">     241 </span>            :         virtual uint32_t GetAppUnitsPerDevUnit() const = 0;
<span class="lineNum">     242 </span>            :     };
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :     struct DrawParams
<span class="lineNum">     245 </span>            :     {
<span class="lineNum">     246 </span>            :         gfxContext* context;
<span class="lineNum">     247 </span>            :         DrawMode drawMode = DrawMode::GLYPH_FILL;
<span class="lineNum">     248 </span>            :         nscolor textStrokeColor = 0;
<span class="lineNum">     249 </span>            :         gfxPattern* textStrokePattern = nullptr;
<span class="lineNum">     250 </span>            :         const mozilla::gfx::StrokeOptions *strokeOpts = nullptr;
<span class="lineNum">     251 </span>            :         const mozilla::gfx::DrawOptions *drawOpts = nullptr;
<span class="lineNum">     252 </span>            :         PropertyProvider* provider = nullptr;
<span class="lineNum">     253 </span>            :         // If non-null, the advance width of the substring is set.
<span class="lineNum">     254 </span>            :         gfxFloat* advanceWidth = nullptr;
<a name="255"><span class="lineNum">     255 </span>            :         mozilla::SVGContextPaint* contextPaint = nullptr;</a>
<span class="lineNum">     256 </span>            :         gfxTextRunDrawCallbacks* callbacks = nullptr;
<span class="lineNum">     257 </span><span class="lineCov">         21 :         explicit DrawParams(gfxContext* aContext) : context(aContext) {}</span>
<span class="lineNum">     258 </span>            :     };
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     /**
<span class="lineNum">     261 </span>            :      * Draws a substring. Uses only GetSpacing from aBreakProvider.
<span class="lineNum">     262 </span>            :      * The provided point is the baseline origin on the left of the string
<span class="lineNum">     263 </span>            :      * for LTR, on the right of the string for RTL.
<span class="lineNum">     264 </span>            :      *
<span class="lineNum">     265 </span>            :      * Drawing should respect advance widths in the sense that for LTR runs,
<span class="lineNum">     266 </span>            :      *   Draw(Range(start, middle), pt, ...) followed by
<span class="lineNum">     267 </span>            :      *   Draw(Range(middle, end), gfxPoint(pt.x + advance, pt.y), ...)
<span class="lineNum">     268 </span>            :      * should have the same effect as
<span class="lineNum">     269 </span>            :      *   Draw(Range(start, end), pt, ...)
<span class="lineNum">     270 </span>            :      *
<span class="lineNum">     271 </span>            :      * For RTL runs the rule is:
<span class="lineNum">     272 </span>            :      *   Draw(Range(middle, end), pt, ...) followed by
<span class="lineNum">     273 </span>            :      *   Draw(Range(start, middle), gfxPoint(pt.x + advance, pt.y), ...)
<span class="lineNum">     274 </span>            :      * should have the same effect as
<span class="lineNum">     275 </span>            :      *   Draw(Range(start, end), pt, ...)
<span class="lineNum">     276 </span>            :      *
<span class="lineNum">     277 </span>            :      * Glyphs should be drawn in logical content order, which can be significant
<span class="lineNum">     278 </span>            :      * if they overlap (perhaps due to negative spacing).
<span class="lineNum">     279 </span>            :      */
<span class="lineNum">     280 </span>            :     void Draw(Range aRange, gfxPoint aPt, const DrawParams&amp; aParams) const;
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :     /**
<span class="lineNum">     283 </span>            :      * Draws the emphasis marks for this text run. Uses only GetSpacing
<span class="lineNum">     284 </span>            :      * from aProvider. The provided point is the baseline origin of the
<span class="lineNum">     285 </span>            :      * line of emphasis marks.
<span class="lineNum">     286 </span>            :      */
<span class="lineNum">     287 </span>            :     void DrawEmphasisMarks(gfxContext* aContext, gfxTextRun* aMark,
<span class="lineNum">     288 </span>            :                            gfxFloat aMarkAdvance, gfxPoint aPt,
<span class="lineNum">     289 </span>            :                            Range aRange, PropertyProvider* aProvider) const;
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :     /**
<span class="lineNum">     292 </span>            :      * Computes the ReflowMetrics for a substring.
<span class="lineNum">     293 </span>            :      * Uses GetSpacing from aBreakProvider.
<span class="lineNum">     294 </span>            :      * @param aBoundingBoxType which kind of bounding box (loose/tight)
<span class="lineNum">     295 </span>            :      */
<span class="lineNum">     296 </span>            :     Metrics MeasureText(Range aRange,
<span class="lineNum">     297 </span>            :                         gfxFont::BoundingBoxType aBoundingBoxType,
<span class="lineNum">     298 </span>            :                         DrawTarget* aDrawTargetForTightBoundingBox,
<a name="299"><span class="lineNum">     299 </span>            :                         PropertyProvider* aProvider) const;</a>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     Metrics MeasureText(gfxFont::BoundingBoxType aBoundingBoxType,</span>
<span class="lineNum">     302 </span>            :                         DrawTarget* aDrawTargetForTightBoundingBox,
<span class="lineNum">     303 </span>            :                         PropertyProvider* aProvider = nullptr) const {
<span class="lineNum">     304 </span>            :         return MeasureText(Range(this), aBoundingBoxType,
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :                            aDrawTargetForTightBoundingBox, aProvider);</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     /**
<span class="lineNum">     309 </span>            :      * Computes just the advance width for a substring.
<span class="lineNum">     310 </span>            :      * Uses GetSpacing from aBreakProvider.
<span class="lineNum">     311 </span>            :      * If aSpacing is not null, the spacing attached before and after
<span class="lineNum">     312 </span>            :      * the substring would be returned in it. NOTE: the spacing is
<span class="lineNum">     313 </span>            :      * included in the advance width.
<span class="lineNum">     314 </span>            :      */
<span class="lineNum">     315 </span>            :     gfxFloat GetAdvanceWidth(Range aRange, PropertyProvider *aProvider,
<span class="lineNum">     316 </span>            :                              PropertyProvider::Spacing*
<a name="317"><span class="lineNum">     317 </span>            :                                  aSpacing = nullptr) const;</a>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     gfxFloat GetAdvanceWidth() const {</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         return GetAdvanceWidth(Range(this), nullptr);</span>
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     /**
<span class="lineNum">     324 </span>            :      * Clear all stored line breaks for the given range (both before and after),
<span class="lineNum">     325 </span>            :      * and then set the line-break state before aRange.start to aBreakBefore and
<span class="lineNum">     326 </span>            :      * after the last cluster to aBreakAfter.
<span class="lineNum">     327 </span>            :      *
<span class="lineNum">     328 </span>            :      * We require that before and after line breaks be consistent. For clusters
<span class="lineNum">     329 </span>            :      * i and i+1, we require that if there is a break after cluster i, a break
<span class="lineNum">     330 </span>            :      * will be specified before cluster i+1. This may be temporarily violated
<span class="lineNum">     331 </span>            :      * (e.g. after reflowing line L and before reflowing line L+1); to handle
<span class="lineNum">     332 </span>            :      * these temporary violations, we say that there is a break betwen i and i+1
<span class="lineNum">     333 </span>            :      * if a break is specified after i OR a break is specified before i+1.
<span class="lineNum">     334 </span>            :      *
<span class="lineNum">     335 </span>            :      * This can change textrun geometry! The existence of a linebreak can affect
<span class="lineNum">     336 </span>            :      * the advance width of the cluster before the break (when kerning) or the
<span class="lineNum">     337 </span>            :      * geometry of one cluster before the break or any number of clusters
<span class="lineNum">     338 </span>            :      * after the break. (The one-cluster-before-the-break limit is somewhat
<span class="lineNum">     339 </span>            :      * arbitrary; if some scripts require breaking it, then we need to
<span class="lineNum">     340 </span>            :      * alter nsTextFrame::TrimTrailingWhitespace, perhaps drastically becase
<span class="lineNum">     341 </span>            :      * it could affect the layout of frames before it...)
<span class="lineNum">     342 </span>            :      *
<span class="lineNum">     343 </span>            :      * We return true if glyphs or geometry changed, false otherwise. This
<span class="lineNum">     344 </span>            :      * function is virtual so that gfxTextRun subclasses can reshape
<span class="lineNum">     345 </span>            :      * properly.
<span class="lineNum">     346 </span>            :      *
<span class="lineNum">     347 </span>            :      * @param aAdvanceWidthDelta if non-null, returns the change in advance
<span class="lineNum">     348 </span>            :      * width of the given range.
<span class="lineNum">     349 </span>            :      */
<span class="lineNum">     350 </span>            :     virtual bool SetLineBreaks(Range aRange,
<span class="lineNum">     351 </span>            :                                bool aLineBreakBefore, bool aLineBreakAfter,
<span class="lineNum">     352 </span>            :                                gfxFloat* aAdvanceWidthDelta);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :     enum SuppressBreak {
<span class="lineNum">     355 </span>            :       eNoSuppressBreak,
<span class="lineNum">     356 </span>            :       // Measure the range of text as if there is no break before it.
<span class="lineNum">     357 </span>            :       eSuppressInitialBreak,
<span class="lineNum">     358 </span>            :       // Measure the range of text as if it contains no break
<span class="lineNum">     359 </span>            :       eSuppressAllBreaks
<span class="lineNum">     360 </span>            :     };
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :     void ClassifyAutoHyphenations(uint32_t aStart, Range aRange,
<span class="lineNum">     363 </span>            :                                   nsTArray&lt;HyphenType&gt;&amp; aHyphenBuffer,
<span class="lineNum">     364 </span>            :                                   HyphenationState* aWordState);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /**
<span class="lineNum">     367 </span>            :      * Finds the longest substring that will fit into the given width.
<span class="lineNum">     368 </span>            :      * Uses GetHyphenationBreaks and GetSpacing from aBreakProvider.
<span class="lineNum">     369 </span>            :      * Guarantees the following:
<span class="lineNum">     370 </span>            :      * -- 0 &lt;= result &lt;= aMaxLength
<span class="lineNum">     371 </span>            :      * -- result is the maximal value of N such that either
<span class="lineNum">     372 </span>            :      *       N &lt; aMaxLength &amp;&amp; line break at N &amp;&amp; GetAdvanceWidth(aStart, N) &lt;= aWidth
<span class="lineNum">     373 </span>            :      *   OR  N &lt; aMaxLength &amp;&amp; hyphen break at N &amp;&amp; GetAdvanceWidth(aStart, N) + GetHyphenWidth() &lt;= aWidth
<span class="lineNum">     374 </span>            :      *   OR  N == aMaxLength &amp;&amp; GetAdvanceWidth(aStart, N) &lt;= aWidth
<span class="lineNum">     375 </span>            :      * where GetAdvanceWidth assumes the effect of
<span class="lineNum">     376 </span>            :      * SetLineBreaks(aStart, N, aLineBreakBefore, N &lt; aMaxLength, aProvider)
<span class="lineNum">     377 </span>            :      * -- if no such N exists, then result is the smallest N such that
<span class="lineNum">     378 </span>            :      *       N &lt; aMaxLength &amp;&amp; line break at N
<span class="lineNum">     379 </span>            :      *   OR  N &lt; aMaxLength &amp;&amp; hyphen break at N
<span class="lineNum">     380 </span>            :      *   OR  N == aMaxLength
<span class="lineNum">     381 </span>            :      *
<span class="lineNum">     382 </span>            :      * The call has the effect of
<span class="lineNum">     383 </span>            :      * SetLineBreaks(aStart, result, aLineBreakBefore, result &lt; aMaxLength, aProvider)
<span class="lineNum">     384 </span>            :      * and the returned metrics and the invariants above reflect this.
<span class="lineNum">     385 </span>            :      *
<span class="lineNum">     386 </span>            :      * @param aMaxLength this can be UINT32_MAX, in which case the length used
<span class="lineNum">     387 </span>            :      * is up to the end of the string
<span class="lineNum">     388 </span>            :      * @param aLineBreakBefore set to true if and only if there is an actual
<span class="lineNum">     389 </span>            :      * line break at the start of this string.
<span class="lineNum">     390 </span>            :      * @param aSuppressBreak what break should be suppressed.
<span class="lineNum">     391 </span>            :      * @param aTrimWhitespace if non-null, then we allow a trailing run of
<span class="lineNum">     392 </span>            :      * spaces to be trimmed; the width of the space(s) will not be included in
<span class="lineNum">     393 </span>            :      * the measured string width for comparison with the limit aWidth, and
<span class="lineNum">     394 </span>            :      * trimmed spaces will not be included in returned metrics. The width
<span class="lineNum">     395 </span>            :      * of the trimmed spaces will be returned in aTrimWhitespace.
<span class="lineNum">     396 </span>            :      * Trimmed spaces are still counted in the &quot;characters fit&quot; result.
<span class="lineNum">     397 </span>            :      * @param aMetrics if non-null, we fill this in for the returned substring.
<span class="lineNum">     398 </span>            :      * If a hyphenation break was used, the hyphen is NOT included in the returned metrics.
<span class="lineNum">     399 </span>            :      * @param aBoundingBoxType whether to make the bounding box in aMetrics tight
<span class="lineNum">     400 </span>            :      * @param aDrawTargetForTightBoundingbox a reference DrawTarget to get the
<span class="lineNum">     401 </span>            :      * tight bounding box, if requested
<span class="lineNum">     402 </span>            :      * @param aUsedHyphenation if non-null, records if we selected a hyphenation break
<span class="lineNum">     403 </span>            :      * @param aLastBreak if non-null and result is aMaxLength, we set this to
<span class="lineNum">     404 </span>            :      * the maximal N such that
<span class="lineNum">     405 </span>            :      *       N &lt; aMaxLength &amp;&amp; line break at N &amp;&amp; GetAdvanceWidth(aStart, N) &lt;= aWidth
<span class="lineNum">     406 </span>            :      *   OR  N &lt; aMaxLength &amp;&amp; hyphen break at N &amp;&amp; GetAdvanceWidth(aStart, N) + GetHyphenWidth() &lt;= aWidth
<span class="lineNum">     407 </span>            :      * or UINT32_MAX if no such N exists, where GetAdvanceWidth assumes
<span class="lineNum">     408 </span>            :      * the effect of
<span class="lineNum">     409 </span>            :      * SetLineBreaks(aStart, N, aLineBreakBefore, N &lt; aMaxLength, aProvider)
<span class="lineNum">     410 </span>            :      *
<span class="lineNum">     411 </span>            :      * @param aCanWordWrap true if we can break between any two grapheme
<span class="lineNum">     412 </span>            :      * clusters. This is set by overflow-wrap|word-wrap: break-word
<span class="lineNum">     413 </span>            :      *
<span class="lineNum">     414 </span>            :      * @param aBreakPriority in/out the priority of the break opportunity
<span class="lineNum">     415 </span>            :      * saved in the line. If we are prioritizing break opportunities, we will
<span class="lineNum">     416 </span>            :      * not set a break with a lower priority. @see gfxBreakPriority.
<span class="lineNum">     417 </span>            :      *
<span class="lineNum">     418 </span>            :      * Note that negative advance widths are possible especially if negative
<span class="lineNum">     419 </span>            :      * spacing is provided.
<span class="lineNum">     420 </span>            :      */
<span class="lineNum">     421 </span>            :     uint32_t BreakAndMeasureText(uint32_t aStart, uint32_t aMaxLength,
<span class="lineNum">     422 </span>            :                                  bool aLineBreakBefore, gfxFloat aWidth,
<span class="lineNum">     423 </span>            :                                  PropertyProvider *aProvider,
<span class="lineNum">     424 </span>            :                                  SuppressBreak aSuppressBreak,
<span class="lineNum">     425 </span>            :                                  gfxFloat *aTrimWhitespace,
<span class="lineNum">     426 </span>            :                                  bool aHangWhitespace,
<span class="lineNum">     427 </span>            :                                  Metrics *aMetrics,
<span class="lineNum">     428 </span>            :                                  gfxFont::BoundingBoxType aBoundingBoxType,
<span class="lineNum">     429 </span>            :                                  DrawTarget* aDrawTargetForTightBoundingBox,
<span class="lineNum">     430 </span>            :                                  bool *aUsedHyphenation,
<span class="lineNum">     431 </span>            :                                  uint32_t *aLastBreak,
<span class="lineNum">     432 </span>            :                                  bool aCanWordWrap,
<span class="lineNum">     433 </span>            :                                  gfxBreakPriority *aBreakPriority);
<span class="lineNum">     434 </span>            : 
<a name="435"><span class="lineNum">     435 </span>            :     // Utility getters</a>
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span><span class="lineCov">         48 :     void *GetUserData() const { return mUserData; }</span>
<a name="438"><span class="lineNum">     438 </span><span class="lineCov">          9 :     void SetUserData(void *aUserData) { mUserData = aUserData; }</span></a>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     void SetFlagBits(nsTextFrameUtils::Flags aFlags) {</span>
<a name="441"><span class="lineNum">     441 </span><span class="lineNoCov">          0 :       mFlags2 |= aFlags;</span></a>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     443 </span><span class="lineCov">         10 :     void ClearFlagBits(nsTextFrameUtils::Flags aFlags) {</span>
<a name="444"><span class="lineNum">     444 </span><span class="lineCov">         10 :       mFlags2 &amp;= ~aFlags;</span></a>
<a name="445"><span class="lineNum">     445 </span><span class="lineCov">         10 :     }</span></a>
<span class="lineNum">     446 </span><span class="lineCov">        125 :     const gfxSkipChars&amp; GetSkipChars() const { return mSkipChars; }</span>
<span class="lineNum">     447 </span><span class="lineCov">         71 :     gfxFontGroup *GetFontGroup() const { return mFontGroup; }</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :     // Call this, don't call &quot;new gfxTextRun&quot; directly. This does custom
<span class="lineNum">     451 </span>            :     // allocation and initialization
<span class="lineNum">     452 </span>            :     static already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">     453 </span>            :     Create(const gfxTextRunFactory::Parameters *aParams,
<span class="lineNum">     454 </span>            :            uint32_t aLength, gfxFontGroup *aFontGroup,
<span class="lineNum">     455 </span>            :            mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     456 </span>            :            nsTextFrameUtils::Flags aFlags2);
<span class="lineNum">     457 </span>            : 
<a name="458"><span class="lineNum">     458 </span>            :     // The text is divided into GlyphRuns as necessary. (In the vast majority</a>
<span class="lineNum">     459 </span>            :     // of cases, a gfxTextRun contains just a single GlyphRun.)
<span class="lineNum">     460 </span><span class="lineCov">         83 :     struct GlyphRun {</span>
<span class="lineNum">     461 </span>            :         RefPtr&lt;gfxFont&gt; mFont; // never null in a valid GlyphRun
<span class="lineNum">     462 </span>            :         uint32_t        mCharacterOffset; // into original UTF16 string
<span class="lineNum">     463 </span>            :         mozilla::gfx::ShapedTextFlags mOrientation; // gfxTextRunFactory::TEXT_ORIENT_* value
<span class="lineNum">     464 </span>            :         uint8_t         mMatchType;
<span class="lineNum">     465 </span>            :     };
<span class="lineNum">     466 </span>            : 
<a name="467"><span class="lineNum">     467 </span>            :     class GlyphRunIterator {</a>
<span class="lineNum">     468 </span>            :     public:
<span class="lineNum">     469 </span><span class="lineCov">         77 :         GlyphRunIterator(const gfxTextRun *aTextRun, Range aRange)</span>
<span class="lineNum">     470 </span><span class="lineCov">         77 :           : mTextRun(aTextRun)</span>
<span class="lineNum">     471 </span><span class="lineCov">         77 :           , mStartOffset(aRange.start)</span>
<span class="lineNum">     472 </span><span class="lineCov">        154 :           , mEndOffset(aRange.end) {</span>
<span class="lineNum">     473 </span><span class="lineCov">         77 :             mNextIndex = mTextRun-&gt;FindFirstGlyphRunContaining(aRange.start);</span>
<a name="474"><span class="lineNum">     474 </span><span class="lineCov">         77 :         }</span></a>
<a name="475"><span class="lineNum">     475 </span>            :         bool NextRun();</a>
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">        284 :         const GlyphRun *GetGlyphRun() const { return mGlyphRun; }</span></a>
<span class="lineNum">     477 </span><span class="lineCov">         69 :         uint32_t GetStringStart() const { return mStringStart; }</span>
<span class="lineNum">     478 </span><span class="lineCov">         69 :         uint32_t GetStringEnd() const { return mStringEnd; }</span>
<span class="lineNum">     479 </span>            :     private:
<span class="lineNum">     480 </span>            :         const gfxTextRun *mTextRun;
<span class="lineNum">     481 </span>            :         MOZ_INIT_OUTSIDE_CTOR const GlyphRun   *mGlyphRun;
<span class="lineNum">     482 </span>            :         MOZ_INIT_OUTSIDE_CTOR uint32_t    mStringStart;
<span class="lineNum">     483 </span>            :         MOZ_INIT_OUTSIDE_CTOR uint32_t    mStringEnd;
<span class="lineNum">     484 </span>            :         uint32_t    mNextIndex;
<span class="lineNum">     485 </span>            :         uint32_t    mStartOffset;
<span class="lineNum">     486 </span>            :         uint32_t    mEndOffset;
<span class="lineNum">     487 </span>            :     };
<span class="lineNum">     488 </span>            : 
<a name="489"><span class="lineNum">     489 </span>            :     class GlyphRunOffsetComparator {</a>
<span class="lineNum">     490 </span>            :     public:
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         bool Equals(const GlyphRun&amp; a,</span>
<span class="lineNum">     492 </span>            :                       const GlyphRun&amp; b) const
<span class="lineNum">     493 </span>            :         {
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :             return a.mCharacterOffset == b.mCharacterOffset;</span>
<a name="495"><span class="lineNum">     495 </span>            :         }</a>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         bool LessThan(const GlyphRun&amp; a,</span>
<span class="lineNum">     498 </span>            :                         const GlyphRun&amp; b) const
<span class="lineNum">     499 </span>            :         {
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             return a.mCharacterOffset &lt; b.mCharacterOffset;</span>
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span>            :     };
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :     friend class GlyphRunIterator;
<span class="lineNum">     505 </span>            :     friend class FontSelector;
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :     // API for setting up the textrun glyphs. Should only be called by
<span class="lineNum">     508 </span>            :     // things that construct textruns.
<span class="lineNum">     509 </span>            :     /**
<span class="lineNum">     510 </span>            :      * We've found a run of text that should use a particular font. Call this
<span class="lineNum">     511 </span>            :      * only during initialization when font substitution has been computed.
<span class="lineNum">     512 </span>            :      * Call it before setting up the glyphs for the characters in this run;
<span class="lineNum">     513 </span>            :      * SetMissingGlyph requires that the correct glyphrun be installed.
<span class="lineNum">     514 </span>            :      *
<span class="lineNum">     515 </span>            :      * If aForceNewRun, a new glyph run will be added, even if the
<span class="lineNum">     516 </span>            :      * previously added run uses the same font.  If glyph runs are
<span class="lineNum">     517 </span>            :      * added out of strictly increasing aStartCharIndex order (via
<span class="lineNum">     518 </span>            :      * force), then SortGlyphRuns must be called after all glyph runs
<span class="lineNum">     519 </span>            :      * are added before any further operations are performed with this
<span class="lineNum">     520 </span>            :      * TextRun.
<span class="lineNum">     521 </span>            :      */
<span class="lineNum">     522 </span>            :     nsresult AddGlyphRun(gfxFont *aFont, uint8_t aMatchType,
<a name="523"><span class="lineNum">     523 </span>            :                          uint32_t aStartCharIndex, bool aForceNewRun,</a>
<span class="lineNum">     524 </span>            :                          mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     void ResetGlyphRuns()</span>
<span class="lineNum">     526 </span>            :     {
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         if (mHasGlyphRunArray) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(mGlyphRunArray.Length() &gt; 1);</span>
<span class="lineNum">     529 </span>            :             // Discard all but the first GlyphRun...
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :             mGlyphRunArray.TruncateLength(1);</span>
<span class="lineNum">     531 </span>            :             // ...and then convert to the single-run representation.
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :             ConvertFromGlyphRunArray();</span>
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span>            :         // Clear out the one remaining GlyphRun.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :         mSingleGlyphRun.mFont = nullptr;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     537 </span>            :     void SortGlyphRuns();
<a name="538"><span class="lineNum">     538 </span>            :     void SanitizeGlyphRuns();</a>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineCov">         64 :     const CompressedGlyph* GetCharacterGlyphs() const final {</span>
<span class="lineNum">     541 </span><span class="lineCov">         64 :         MOZ_ASSERT(mCharacterGlyphs, &quot;failed to initialize mCharacterGlyphs&quot;);</span>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">         64 :         return mCharacterGlyphs;</span></a>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span><span class="lineCov">        251 :     CompressedGlyph* GetCharacterGlyphs() final {</span>
<span class="lineNum">     545 </span><span class="lineCov">        251 :         MOZ_ASSERT(mCharacterGlyphs, &quot;failed to initialize mCharacterGlyphs&quot;);</span>
<span class="lineNum">     546 </span><span class="lineCov">        251 :         return mCharacterGlyphs;</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :     // clean out results from shaping in progress, used for fallback scenarios
<span class="lineNum">     550 </span>            :     void ClearGlyphsAndCharacters();
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :     void SetSpaceGlyph(gfxFont* aFont, DrawTarget* aDrawTarget,
<span class="lineNum">     553 </span>            :                        uint32_t aCharIndex,
<span class="lineNum">     554 </span>            :                        mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :     // Set the glyph data for the given character index to the font's
<span class="lineNum">     557 </span>            :     // space glyph, IF this can be done as a &quot;simple&quot; glyph record
<span class="lineNum">     558 </span>            :     // (not requiring a DetailedGlyph entry). This avoids the need to call
<span class="lineNum">     559 </span>            :     // the font shaper and go through the shaped-word cache for most spaces.
<span class="lineNum">     560 </span>            :     //
<span class="lineNum">     561 </span>            :     // The parameter aSpaceChar is the original character code for which
<span class="lineNum">     562 </span>            :     // this space glyph is being used; if this is U+0020, we need to record
<span class="lineNum">     563 </span>            :     // that it could be trimmed at a run edge, whereas other kinds of space
<span class="lineNum">     564 </span>            :     // (currently just U+00A0) would not be trimmable/breakable.
<span class="lineNum">     565 </span>            :     //
<span class="lineNum">     566 </span>            :     // Returns true if it was able to set simple glyph data for the space;
<span class="lineNum">     567 </span>            :     // if it returns false, the caller needs to fall back to some other
<span class="lineNum">     568 </span>            :     // means to create the necessary (detailed) glyph data.
<span class="lineNum">     569 </span>            :     bool SetSpaceGlyphIfSimple(gfxFont *aFont, uint32_t aCharIndex,
<span class="lineNum">     570 </span>            :                                char16_t aSpaceChar, 
<span class="lineNum">     571 </span>            :                                mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :     // Record the positions of specific characters that layout may need to
<span class="lineNum">     574 </span>            :     // detect in the textrun, even though it doesn't have an explicit copy
<span class="lineNum">     575 </span>            :     // of the original text. These are recorded using flag bits in the
<span class="lineNum">     576 </span>            :     // CompressedGlyph record; if necessary, we convert &quot;simple&quot; glyph records
<a name="577"><span class="lineNum">     577 </span>            :     // to &quot;complex&quot; ones as the Tab and Newline flags are not present in</a>
<span class="lineNum">     578 </span>            :     // simple CompressedGlyph records.
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     void SetIsTab(uint32_t aIndex) {</span>
<a name="580"><span class="lineNum">     580 </span><span class="lineNoCov">          0 :         EnsureComplexGlyph(aIndex).SetIsTab();</span></a>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     void SetIsNewline(uint32_t aIndex) {</span>
<a name="583"><span class="lineNum">     583 </span><span class="lineNoCov">          0 :         EnsureComplexGlyph(aIndex).SetIsNewline();</span></a>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     void SetNoEmphasisMark(uint32_t aIndex) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         EnsureComplexGlyph(aIndex).SetNoEmphasisMark();</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :     /**
<span class="lineNum">     590 </span>            :      * Prefetch all the glyph extents needed to ensure that Measure calls
<span class="lineNum">     591 </span>            :      * on this textrun not requesting tight boundingBoxes will succeed. Note
<span class="lineNum">     592 </span>            :      * that some glyph extents might not be fetched due to OOM or other
<span class="lineNum">     593 </span>            :      * errors.
<span class="lineNum">     594 </span>            :      */
<span class="lineNum">     595 </span>            :     void FetchGlyphExtents(DrawTarget* aRefDrawTarget);
<span class="lineNum">     596 </span>            : 
<a name="597"><span class="lineNum">     597 </span>            :     uint32_t CountMissingGlyphs() const;</a>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineCov">         92 :     const GlyphRun* GetGlyphRuns(uint32_t* aNumGlyphRuns) const</span>
<span class="lineNum">     600 </span>            :     {
<span class="lineNum">     601 </span><span class="lineCov">         92 :         if (mHasGlyphRunArray) {</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :             *aNumGlyphRuns = mGlyphRunArray.Length();</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :             return mGlyphRunArray.Elements();</span>
<span class="lineNum">     604 </span>            :         } else {
<span class="lineNum">     605 </span><span class="lineCov">         92 :             *aNumGlyphRuns = mSingleGlyphRun.mFont ? 1 : 0;</span>
<span class="lineNum">     606 </span><span class="lineCov">         92 :             return &amp;mSingleGlyphRun;</span>
<span class="lineNum">     607 </span>            :         }
<span class="lineNum">     608 </span>            :     }
<span class="lineNum">     609 </span>            :     // Returns the index of the GlyphRun containing the given offset.
<span class="lineNum">     610 </span>            :     // Returns mGlyphRuns.Length() when aOffset is mCharacterCount.
<span class="lineNum">     611 </span>            :     uint32_t FindFirstGlyphRunContaining(uint32_t aOffset) const;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     // Copy glyph data from a ShapedWord into this textrun.
<span class="lineNum">     614 </span>            :     void CopyGlyphDataFrom(gfxShapedWord *aSource, uint32_t aStart);
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :     // Copy glyph data for a range of characters from aSource to this
<span class="lineNum">     617 </span>            :     // textrun.
<span class="lineNum">     618 </span>            :     void CopyGlyphDataFrom(gfxTextRun *aSource, Range aRange, uint32_t aDest);
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     // Tell the textrun to release its reference to its creating gfxFontGroup
<span class="lineNum">     621 </span>            :     // immediately, rather than on destruction. This is used for textruns
<span class="lineNum">     622 </span>            :     // that are actually owned by a gfxFontGroup, so that they don't keep it
<span class="lineNum">     623 </span>            :     // permanently alive due to a circular reference. (The caller of this is
<span class="lineNum">     624 </span>            :     // taking responsibility for ensuring the textrun will not outlive its
<span class="lineNum">     625 </span>            :     // mFontGroup.)
<a name="626"><span class="lineNum">     626 </span>            :     void ReleaseFontGroup();</a>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     struct LigatureData {</span>
<span class="lineNum">     629 </span>            :         // textrun range of the containing ligature
<span class="lineNum">     630 </span>            :         Range mRange;
<span class="lineNum">     631 </span>            :         // appunits advance to the start of the ligature part within the ligature;
<span class="lineNum">     632 </span>            :         // never includes any spacing
<span class="lineNum">     633 </span>            :         gfxFloat mPartAdvance;
<span class="lineNum">     634 </span>            :         // appunits width of the ligature part; includes before-spacing
<span class="lineNum">     635 </span>            :         // when the part is at the start of the ligature, and after-spacing
<span class="lineNum">     636 </span>            :         // when the part is as the end of the ligature
<span class="lineNum">     637 </span>            :         gfxFloat mPartWidth;
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :         bool mClipBeforePart;
<span class="lineNum">     640 </span>            :         bool mClipAfterPart;
<span class="lineNum">     641 </span>            :     };
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :     // return storage used by this run, for memory reporter;
<span class="lineNum">     644 </span>            :     // nsTransformedTextRun needs to override this as it holds additional data
<span class="lineNum">     645 </span>            :     virtual size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf)
<span class="lineNum">     646 </span>            :       MOZ_MUST_OVERRIDE;
<span class="lineNum">     647 </span>            :     virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)
<a name="648"><span class="lineNum">     648 </span>            :       MOZ_MUST_OVERRIDE;</a>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">        324 :     nsTextFrameUtils::Flags GetFlags2() const {</span>
<span class="lineNum">     651 </span><span class="lineCov">        324 :         return mFlags2;</span>
<span class="lineNum">     652 </span>            :     }
<a name="653"><span class="lineNum">     653 </span>            : </a>
<span class="lineNum">     654 </span>            :     // Get the size, if it hasn't already been gotten, marking as it goes.
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     size_t MaybeSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf)  {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         if (mFlags2 &amp; nsTextFrameUtils::Flags::TEXT_RUN_SIZE_ACCOUNTED) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     658 </span>            :         }
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         mFlags2 |= nsTextFrameUtils::Flags::TEXT_RUN_SIZE_ACCOUNTED;</span>
<a name="660"><span class="lineNum">     660 </span><span class="lineNoCov">          0 :         return SizeOfIncludingThis(aMallocSizeOf);</span></a>
<span class="lineNum">     661 </span>            :     }
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     void ResetSizeOfAccountingFlags() {</span>
<span class="lineNum">     663 </span><span class="lineCov">         81 :         mFlags2 &amp;= ~nsTextFrameUtils::Flags::TEXT_RUN_SIZE_ACCOUNTED;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :     // shaping state - for some font features, fallback is required that
<span class="lineNum">     667 </span>            :     // affects the entire run. for example, fallback for one script/font
<span class="lineNum">     668 </span>            :     // portion of a textrun requires fallback to be applied to the entire run
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :     enum ShapingState : uint8_t {
<span class="lineNum">     671 </span>            :         eShapingState_Normal,                 // default state
<span class="lineNum">     672 </span>            :         eShapingState_ShapingWithFeature,     // have shaped with feature
<span class="lineNum">     673 </span>            :         eShapingState_ShapingWithFallback,    // have shaped with fallback
<span class="lineNum">     674 </span>            :         eShapingState_Aborted,                // abort initial iteration
<span class="lineNum">     675 </span>            :         eShapingState_ForceFallbackFeature    // redo with fallback forced on
<a name="676"><span class="lineNum">     676 </span>            :     };</a>
<a name="677"><span class="lineNum">     677 </span>            : </a>
<span class="lineNum">     678 </span><span class="lineCov">        142 :     ShapingState GetShapingState() const { return mShapingState; }</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     void SetShapingState(ShapingState aShapingState) {</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         mShapingState = aShapingState;</span>
<a name="681"><span class="lineNum">     681 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineCov">       1164 :     int32_t GetAdvanceForGlyph(uint32_t aIndex) const</span>
<span class="lineNum">     684 </span>            :     {
<span class="lineNum">     685 </span><span class="lineCov">       1164 :         const CompressedGlyph&amp; glyphData = mCharacterGlyphs[aIndex];</span>
<span class="lineNum">     686 </span><span class="lineCov">       1164 :         if (glyphData.IsSimpleGlyph()) {</span>
<span class="lineNum">     687 </span><span class="lineCov">       1164 :             return glyphData.GetSimpleAdvance();</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         uint32_t glyphCount = glyphData.GetGlyphCount();</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         if (!glyphCount) {</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     692 </span>            :         }
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         const DetailedGlyph* details = GetDetailedGlyphs(aIndex);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         int32_t advance = 0;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         for (uint32_t j = 0; j &lt; glyphCount; ++j, ++details) {</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :             advance += details-&gt;mAdvance;</span>
<span class="lineNum">     697 </span>            :         }
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         return advance;</span>
<span class="lineNum">     699 </span>            :     }
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : #ifdef DEBUG
<span class="lineNum">     702 </span>            :     void Dump(FILE* aOutput);
<span class="lineNum">     703 </span>            : #endif
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : protected:
<span class="lineNum">     706 </span>            :     /**
<span class="lineNum">     707 </span>            :      * Create a textrun, and set its mCharacterGlyphs to point immediately
<span class="lineNum">     708 </span>            :      * after the base object; this is ONLY used in conjunction with placement
<span class="lineNum">     709 </span>            :      * new, after allocating a block large enough for the glyph records to
<span class="lineNum">     710 </span>            :      * follow the base textrun object.
<span class="lineNum">     711 </span>            :      */
<span class="lineNum">     712 </span>            :     gfxTextRun(const gfxTextRunFactory::Parameters *aParams,
<span class="lineNum">     713 </span>            :                uint32_t aLength, gfxFontGroup *aFontGroup,
<span class="lineNum">     714 </span>            :                mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     715 </span>            :                nsTextFrameUtils::Flags aFlags2);
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :     /**
<span class="lineNum">     718 </span>            :      * Helper for the Create() factory method to allocate the required
<span class="lineNum">     719 </span>            :      * glyph storage for a textrun object with the basic size aSize,
<span class="lineNum">     720 </span>            :      * plus room for aLength glyph records.
<span class="lineNum">     721 </span>            :      */
<span class="lineNum">     722 </span>            :     static void* AllocateStorageForTextRun(size_t aSize, uint32_t aLength);
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :     // Pointer to the array of CompressedGlyph records; must be initialized
<span class="lineNum">     725 </span>            :     // when the object is constructed.
<span class="lineNum">     726 </span>            :     CompressedGlyph *mCharacterGlyphs;
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            : private:
<span class="lineNum">     729 </span>            :     // **** general helpers ****
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :     // Get the total advance for a range of glyphs.
<span class="lineNum">     732 </span>            :     int32_t GetAdvanceForGlyphs(Range aRange) const;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :     // Spacing for characters outside the range aSpacingStart/aSpacingEnd
<span class="lineNum">     735 </span>            :     // is assumed to be zero; such characters are not passed to aProvider.
<span class="lineNum">     736 </span>            :     // This is useful to protect aProvider from being passed character indices
<span class="lineNum">     737 </span>            :     // it is not currently able to handle.
<span class="lineNum">     738 </span>            :     bool GetAdjustedSpacingArray(Range aRange, PropertyProvider *aProvider,
<span class="lineNum">     739 </span>            :                                  Range aSpacingRange,
<span class="lineNum">     740 </span>            :                                  nsTArray&lt;PropertyProvider::Spacing&gt;*
<a name="741"><span class="lineNum">     741 </span>            :                                      aSpacing) const;</a>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     CompressedGlyph&amp; EnsureComplexGlyph(uint32_t aIndex)</span>
<span class="lineNum">     744 </span>            :     {
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         gfxShapedText::EnsureComplexGlyph(aIndex, mCharacterGlyphs[aIndex]);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         return mCharacterGlyphs[aIndex];</span>
<span class="lineNum">     747 </span>            :     }
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :     //  **** ligature helpers ****
<span class="lineNum">     750 </span>            :     // (Platforms do the actual ligaturization, but we need to do a bunch of stuff
<span class="lineNum">     751 </span>            :     // to handle requests that begin or end inside a ligature)
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :     // if aProvider is null then mBeforeSpacing and mAfterSpacing are set to zero
<span class="lineNum">     754 </span>            :     LigatureData ComputeLigatureData(Range aPartRange,
<span class="lineNum">     755 </span>            :                                      PropertyProvider *aProvider) const;
<span class="lineNum">     756 </span>            :     gfxFloat ComputePartialLigatureWidth(Range aPartRange,
<span class="lineNum">     757 </span>            :                                          PropertyProvider *aProvider) const;
<span class="lineNum">     758 </span>            :     void DrawPartialLigature(gfxFont *aFont, Range aRange,
<span class="lineNum">     759 </span>            :                              gfxPoint *aPt, PropertyProvider *aProvider,
<span class="lineNum">     760 </span>            :                              TextRunDrawParams&amp; aParams,
<span class="lineNum">     761 </span>            :                              mozilla::gfx::ShapedTextFlags aOrientation) const;
<span class="lineNum">     762 </span>            :     // Advance aRange.start to the start of the nearest ligature, back
<span class="lineNum">     763 </span>            :     // up aRange.end to the nearest ligature end; may result in
<span class="lineNum">     764 </span>            :     // aRange-&gt;start == aRange-&gt;end.
<span class="lineNum">     765 </span>            :     void ShrinkToLigatureBoundaries(Range* aRange) const;
<span class="lineNum">     766 </span>            :     // result in appunits
<span class="lineNum">     767 </span>            :     gfxFloat GetPartialLigatureWidth(Range aRange,
<span class="lineNum">     768 </span>            :                                      PropertyProvider *aProvider) const;
<span class="lineNum">     769 </span>            :     void AccumulatePartialLigatureMetrics(gfxFont *aFont, Range aRange,
<span class="lineNum">     770 </span>            :                                           gfxFont::BoundingBoxType aBoundingBoxType,
<span class="lineNum">     771 </span>            :                                           DrawTarget* aRefDrawTarget,
<span class="lineNum">     772 </span>            :                                           PropertyProvider *aProvider,
<span class="lineNum">     773 </span>            :                                           mozilla::gfx::ShapedTextFlags aOrientation,
<span class="lineNum">     774 </span>            :                                           Metrics *aMetrics) const;
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :     // **** measurement helper ****
<span class="lineNum">     777 </span>            :     void AccumulateMetricsForRun(gfxFont *aFont, Range aRange,
<span class="lineNum">     778 </span>            :                                  gfxFont::BoundingBoxType aBoundingBoxType,
<span class="lineNum">     779 </span>            :                                  DrawTarget* aRefDrawTarget,
<span class="lineNum">     780 </span>            :                                  PropertyProvider *aProvider,
<span class="lineNum">     781 </span>            :                                  Range aSpacingRange,
<span class="lineNum">     782 </span>            :                                  mozilla::gfx::ShapedTextFlags aOrientation,
<span class="lineNum">     783 </span>            :                                  Metrics *aMetrics) const;
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :     // **** drawing helper ****
<span class="lineNum">     786 </span>            :     void DrawGlyphs(gfxFont *aFont, Range aRange, gfxPoint *aPt,
<span class="lineNum">     787 </span>            :                     PropertyProvider *aProvider, Range aSpacingRange,
<span class="lineNum">     788 </span>            :                     TextRunDrawParams&amp; aParams,
<span class="lineNum">     789 </span>            :                     mozilla::gfx::ShapedTextFlags aOrientation) const;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :     // The textrun holds either a single GlyphRun -or- an array;
<span class="lineNum">     792 </span>            :     // the flag mHasGlyphRunArray tells us which is present.
<span class="lineNum">     793 </span>            :     union {
<span class="lineNum">     794 </span>            :         GlyphRun           mSingleGlyphRun;
<span class="lineNum">     795 </span>            :         nsTArray&lt;GlyphRun&gt; mGlyphRunArray;
<a name="796"><span class="lineNum">     796 </span>            :     };</a>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     void ConvertToGlyphRunArray() {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!mHasGlyphRunArray &amp;&amp; mSingleGlyphRun.mFont);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         GlyphRun tmp = mozilla::Move(mSingleGlyphRun);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         mSingleGlyphRun.~GlyphRun();</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         new (&amp;mGlyphRunArray) nsTArray&lt;GlyphRun&gt;(2);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         mGlyphRunArray.AppendElement(mozilla::Move(tmp));</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         mHasGlyphRunArray = true;</span>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     void ConvertFromGlyphRunArray() {</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(mHasGlyphRunArray &amp;&amp; mGlyphRunArray.Length() == 1);</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         GlyphRun tmp = mozilla::Move(mGlyphRunArray[0]);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         mGlyphRunArray.~nsTArray&lt;GlyphRun&gt;();</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :         new (&amp;mSingleGlyphRun) GlyphRun(mozilla::Move(tmp));</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         mHasGlyphRunArray = false;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :     void             *mUserData;
<span class="lineNum">     816 </span>            :     gfxFontGroup     *mFontGroup; // addrefed on creation, but our reference
<span class="lineNum">     817 </span>            :                                   // may be released by ReleaseFontGroup()
<span class="lineNum">     818 </span>            :     gfxSkipChars      mSkipChars;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     nsTextFrameUtils::Flags mFlags2; // additional flags (see also gfxShapedText::mFlags)
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :     bool              mSkipDrawing; // true if the font group we used had a user font
<span class="lineNum">     823 </span>            :                                     // download that's in progress, so we should hide text
<span class="lineNum">     824 </span>            :                                     // until the download completes (or timeout fires)
<span class="lineNum">     825 </span>            :     bool              mReleasedFontGroup; // we already called NS_RELEASE on
<span class="lineNum">     826 </span>            :                                           // mFontGroup, so don't do it again
<span class="lineNum">     827 </span>            :     bool              mHasGlyphRunArray; // whether we're using an array or
<span class="lineNum">     828 </span>            :                                          // just storing a single glyphrun
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :     // shaping state for handling variant fallback features
<span class="lineNum">     831 </span>            :     // such as subscript/superscript variant glyphs
<span class="lineNum">     832 </span>            :     ShapingState      mShapingState;
<span class="lineNum">     833 </span>            : };
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            : class gfxFontGroup final : public gfxTextRunFactory {
<span class="lineNum">     836 </span>            : public:
<span class="lineNum">     837 </span>            :     typedef mozilla::unicode::Script Script;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :     static void Shutdown(); // platform must call this to release the languageAtomService
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :     gfxFontGroup(const mozilla::FontFamilyList&amp; aFontFamilyList,
<span class="lineNum">     842 </span>            :                  const gfxFontStyle* aStyle,
<span class="lineNum">     843 </span>            :                  gfxTextPerfMetrics* aTextPerf,
<span class="lineNum">     844 </span>            :                  gfxUserFontSet* aUserFontSet,
<span class="lineNum">     845 </span>            :                  gfxFloat aDevToCssSize);
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     virtual ~gfxFontGroup();
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :     // Returns first valid font in the fontlist or default font.
<span class="lineNum">     850 </span>            :     // Initiates userfont loads if userfont not loaded
<span class="lineNum">     851 </span>            :     gfxFont* GetFirstValidFont(uint32_t aCh = 0x20);
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :     // Returns the first font in the font-group that has an OpenType MATH table,
<span class="lineNum">     854 </span>            :     // or null if no such font is available. The GetMathConstant methods may be
<span class="lineNum">     855 </span>            :     // called on the returned font.
<a name="856"><span class="lineNum">     856 </span>            :     gfxFont *GetFirstMathFont();</a>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineCov">        142 :     const gfxFontStyle *GetStyle() const { return &amp;mStyle; }</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :     gfxFontGroup *Copy(const gfxFontStyle *aStyle);
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            :     /**
<span class="lineNum">     863 </span>            :      * The listed characters should be treated as invisible and zero-width
<span class="lineNum">     864 </span>            :      * when creating textruns.
<span class="lineNum">     865 </span>            :      */
<span class="lineNum">     866 </span>            :     static bool IsInvalidChar(uint8_t ch);
<span class="lineNum">     867 </span>            :     static bool IsInvalidChar(char16_t ch);
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :     /**
<span class="lineNum">     870 </span>            :      * Make a textrun for a given string.
<span class="lineNum">     871 </span>            :      * If aText is not persistent (aFlags &amp; TEXT_IS_PERSISTENT), the
<span class="lineNum">     872 </span>            :      * textrun will copy it.
<span class="lineNum">     873 </span>            :      * This calls FetchGlyphExtents on the textrun.
<span class="lineNum">     874 </span>            :      */
<span class="lineNum">     875 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">     876 </span>            :     MakeTextRun(const char16_t *aString, uint32_t aLength,
<span class="lineNum">     877 </span>            :                 const Parameters *aParams,
<span class="lineNum">     878 </span>            :                 mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     879 </span>            :                 nsTextFrameUtils::Flags aFlags2,
<span class="lineNum">     880 </span>            :                 gfxMissingFontRecorder *aMFR);
<span class="lineNum">     881 </span>            :     /**
<span class="lineNum">     882 </span>            :      * Make a textrun for a given string.
<span class="lineNum">     883 </span>            :      * If aText is not persistent (aFlags &amp; TEXT_IS_PERSISTENT), the
<span class="lineNum">     884 </span>            :      * textrun will copy it.
<span class="lineNum">     885 </span>            :      * This calls FetchGlyphExtents on the textrun.
<span class="lineNum">     886 </span>            :      */
<span class="lineNum">     887 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">     888 </span>            :     MakeTextRun(const uint8_t *aString, uint32_t aLength,
<span class="lineNum">     889 </span>            :                 const Parameters *aParams,
<span class="lineNum">     890 </span>            :                 mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     891 </span>            :                 nsTextFrameUtils::Flags aFlags2,
<span class="lineNum">     892 </span>            :                 gfxMissingFontRecorder *aMFR);
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :     /**
<span class="lineNum">     895 </span>            :      * Textrun creation helper for clients that don't want to pass
<span class="lineNum">     896 </span>            :      * a full Parameters record.
<span class="lineNum">     897 </span>            :      */
<a name="898"><span class="lineNum">     898 </span>            :     template&lt;typename T&gt;</a>
<span class="lineNum">     899 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">     900 </span><span class="lineCov">         62 :     MakeTextRun(const T* aString, uint32_t aLength,</span>
<span class="lineNum">     901 </span>            :                 DrawTarget* aRefDrawTarget,
<span class="lineNum">     902 </span>            :                 int32_t aAppUnitsPerDevUnit,
<span class="lineNum">     903 </span>            :                 mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     904 </span>            :                 nsTextFrameUtils::Flags aFlags2,
<span class="lineNum">     905 </span>            :                 gfxMissingFontRecorder *aMFR)
<span class="lineNum">     906 </span>            :     {
<span class="lineNum">     907 </span>            :         gfxTextRunFactory::Parameters params = {
<span class="lineNum">     908 </span>            :             aRefDrawTarget, nullptr, nullptr, nullptr, 0, aAppUnitsPerDevUnit
<span class="lineNum">     909 </span><span class="lineCov">         62 :         };</span>
<span class="lineNum">     910 </span><span class="lineCov">         62 :         return MakeTextRun(aString, aLength, &amp;params, aFlags, aFlags2, aMFR);</span>
<span class="lineNum">     911 </span>            :     }
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     // Get the (possibly-cached) width of the hyphen character.
<span class="lineNum">     914 </span>            :     gfxFloat GetHyphenWidth(const gfxTextRun::PropertyProvider* aProvider);
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :     /**
<span class="lineNum">     917 </span>            :      * Make a text run representing a single hyphen character.
<span class="lineNum">     918 </span>            :      * This will use U+2010 HYPHEN if available in the first font,
<span class="lineNum">     919 </span>            :      * otherwise fall back to U+002D HYPHEN-MINUS.
<span class="lineNum">     920 </span>            :      * The caller is responsible for deleting the returned text run
<span class="lineNum">     921 </span>            :      * when no longer required.
<span class="lineNum">     922 </span>            :      */
<span class="lineNum">     923 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">     924 </span>            :     MakeHyphenTextRun(DrawTarget* aDrawTarget, uint32_t aAppUnitsPerDevUnit);
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     /**
<span class="lineNum">     927 </span>            :      * Check whether a given font (specified by its gfxFontEntry)
<span class="lineNum">     928 </span>            :      * is already in the fontgroup's list of actual fonts
<span class="lineNum">     929 </span>            :      */
<span class="lineNum">     930 </span>            :     bool HasFont(const gfxFontEntry *aFontEntry);
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            :     // This returns the preferred underline for this font group.
<span class="lineNum">     933 </span>            :     // Some CJK fonts have wrong underline offset in its metrics.
<span class="lineNum">     934 </span>            :     // If this group has such &quot;bad&quot; font, each platform's gfxFontGroup
<span class="lineNum">     935 </span>            :     // initialized mUnderlineOffset. The value should be lower value of
<span class="lineNum">     936 </span>            :     // first font's metrics and the bad font's metrics. Otherwise, this
<span class="lineNum">     937 </span>            :     // returns from first font's metrics.
<span class="lineNum">     938 </span>            :     enum { UNDERLINE_OFFSET_NOT_SET = INT16_MAX };
<span class="lineNum">     939 </span>            :     gfxFloat GetUnderlineOffset();
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :     gfxFont* FindFontForChar(uint32_t ch, uint32_t prevCh, uint32_t aNextCh,
<span class="lineNum">     942 </span>            :                              Script aRunScript, gfxFont *aPrevMatchedFont,
<span class="lineNum">     943 </span>            :                              uint8_t *aMatchType);
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :     gfxUserFontSet* GetUserFontSet();
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :     // With downloadable fonts, the composition of the font group can change as fonts are downloaded
<span class="lineNum">     948 </span>            :     // for each change in state of the user font set, the generation value is bumped to avoid picking up
<span class="lineNum">     949 </span>            :     // previously created text runs in the text run word cache.  For font groups based on stylesheets
<span class="lineNum">     950 </span>            :     // with no @font-face rule, this always returns 0.
<span class="lineNum">     951 </span>            :     uint64_t GetGeneration();
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :     // generation of the latest fontset rebuild, 0 when no fontset present
<span class="lineNum">     954 </span>            :     uint64_t GetRebuildGeneration();
<a name="955"><span class="lineNum">     955 </span>            : </a>
<span class="lineNum">     956 </span>            :     // used when logging text performance
<span class="lineNum">     957 </span><span class="lineCov">        225 :     gfxTextPerfMetrics *GetTextPerfMetrics() { return mTextPerf; }</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :     // This will call UpdateUserFonts() if the user font set is changed.
<a name="960"><span class="lineNum">     960 </span>            :     void SetUserFontSet(gfxUserFontSet *aUserFontSet);</a>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     void ClearCachedData()</span>
<span class="lineNum">     963 </span>            :     {
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :         mUnderlineOffset = UNDERLINE_OFFSET_NOT_SET;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         mSkipDrawing = false;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         mHyphenWidth = -1;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         mCachedEllipsisTextRun = nullptr;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :     // If there is a user font set, check to see whether the font list or any
<span class="lineNum">     971 </span>            :     // caches need updating.
<span class="lineNum">     972 </span>            :     void UpdateUserFonts();
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :     // search for a specific userfont in the list of fonts
<a name="975"><span class="lineNum">     975 </span>            :     bool ContainsUserFont(const gfxUserFontEntry* aUserFont);</a>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">        101 :     bool ShouldSkipDrawing() const {</span>
<span class="lineNum">     978 </span><span class="lineCov">        101 :         return mSkipDrawing;</span>
<a name="979"><span class="lineNum">     979 </span>            :     }</a>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     class LazyReferenceDrawTargetGetter {</span>
<span class="lineNum">     982 </span>            :     public:
<span class="lineNum">     983 </span>            :       virtual already_AddRefed&lt;DrawTarget&gt; GetRefDrawTarget() = 0;
<span class="lineNum">     984 </span>            :     };
<span class="lineNum">     985 </span>            :     // The gfxFontGroup keeps ownership of this textrun.
<span class="lineNum">     986 </span>            :     // It is only guaranteed to exist until the next call to GetEllipsisTextRun
<span class="lineNum">     987 </span>            :     // (which might use a different appUnitsPerDev value or flags) for the font
<span class="lineNum">     988 </span>            :     // group, or until UpdateUserFonts is called, or the fontgroup is destroyed.
<span class="lineNum">     989 </span>            :     // Get it/use it/forget it :) - don't keep a reference that might go stale.
<span class="lineNum">     990 </span>            :     gfxTextRun* GetEllipsisTextRun(int32_t aAppUnitsPerDevPixel,
<span class="lineNum">     991 </span>            :                                    mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">     992 </span>            :                                    LazyReferenceDrawTargetGetter&amp; aRefDrawTargetGetter);
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            : protected:
<span class="lineNum">     995 </span>            :     // search through pref fonts for a character, return nullptr if no matching pref font
<span class="lineNum">     996 </span>            :     gfxFont* WhichPrefFontSupportsChar(uint32_t aCh);
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :     gfxFont* WhichSystemFontSupportsChar(uint32_t aCh, uint32_t aNextCh,
<span class="lineNum">     999 </span>            :                                          Script aRunScript);
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1002 </span>            :     void ComputeRanges(nsTArray&lt;gfxTextRange&gt;&amp; mRanges,
<span class="lineNum">    1003 </span>            :                        const T *aString, uint32_t aLength,
<span class="lineNum">    1004 </span>            :                        Script aRunScript,
<span class="lineNum">    1005 </span>            :                        mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :     class FamilyFace {
<span class="lineNum">    1008 </span>            :     public:
<span class="lineNum">    1009 </span>            :         FamilyFace() : mFamily(nullptr), mFontEntry(nullptr),
<span class="lineNum">    1010 </span>            :                        mNeedsBold(false), mFontCreated(false),
<span class="lineNum">    1011 </span>            :                        mLoading(false), mInvalid(false),
<span class="lineNum">    1012 </span>            :                        mCheckForFallbackFaces(false)
<span class="lineNum">    1013 </span>            :         { }
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :         FamilyFace(gfxFontFamily* aFamily, gfxFont* aFont)
<span class="lineNum">    1016 </span>            :             : mFamily(aFamily), mNeedsBold(false), mFontCreated(true),
<span class="lineNum">    1017 </span>            :               mLoading(false), mInvalid(false), mCheckForFallbackFaces(false)
<span class="lineNum">    1018 </span>            :         {
<span class="lineNum">    1019 </span>            :             NS_ASSERTION(aFont, &quot;font pointer must not be null&quot;);
<span class="lineNum">    1020 </span>            :             NS_ASSERTION(!aFamily ||
<span class="lineNum">    1021 </span>            :                          aFamily-&gt;ContainsFace(aFont-&gt;GetFontEntry()),
<span class="lineNum">    1022 </span>            :                          &quot;font is not a member of the given family&quot;);
<span class="lineNum">    1023 </span>            :             mFont = aFont;
<span class="lineNum">    1024 </span>            :             NS_ADDREF(aFont);
<a name="1025"><span class="lineNum">    1025 </span>            :         }</a>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineCov">         21 :         FamilyFace(gfxFontFamily* aFamily, gfxFontEntry* aFontEntry,</span>
<span class="lineNum">    1028 </span>            :                    bool aNeedsBold)
<span class="lineNum">    1029 </span><span class="lineCov">         21 :             : mFamily(aFamily), mNeedsBold(aNeedsBold), mFontCreated(false),</span>
<span class="lineNum">    1030 </span><span class="lineCov">         21 :               mLoading(false), mInvalid(false), mCheckForFallbackFaces(false)</span>
<span class="lineNum">    1031 </span>            :         {
<span class="lineNum">    1032 </span><span class="lineCov">         21 :             NS_ASSERTION(aFontEntry, &quot;font entry pointer must not be null&quot;);</span>
<span class="lineNum">    1033 </span><span class="lineCov">         21 :             NS_ASSERTION(!aFamily ||</span>
<span class="lineNum">    1034 </span>            :                          aFamily-&gt;ContainsFace(aFontEntry),
<span class="lineNum">    1035 </span>            :                          &quot;font is not a member of the given family&quot;);
<span class="lineNum">    1036 </span><span class="lineCov">         21 :             mFontEntry = aFontEntry;</span>
<span class="lineNum">    1037 </span><span class="lineCov">         21 :             NS_ADDREF(aFontEntry);</span>
<a name="1038"><span class="lineNum">    1038 </span><span class="lineCov">         21 :         }</span></a>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineCov">         21 :         FamilyFace(const FamilyFace&amp; aOtherFamilyFace)</span>
<span class="lineNum">    1041 </span><span class="lineCov">         21 :             : mFamily(aOtherFamilyFace.mFamily),</span>
<span class="lineNum">    1042 </span><span class="lineCov">         21 :               mNeedsBold(aOtherFamilyFace.mNeedsBold),</span>
<span class="lineNum">    1043 </span><span class="lineCov">         21 :               mFontCreated(aOtherFamilyFace.mFontCreated),</span>
<span class="lineNum">    1044 </span><span class="lineCov">         21 :               mLoading(aOtherFamilyFace.mLoading),</span>
<span class="lineNum">    1045 </span><span class="lineCov">         21 :               mInvalid(aOtherFamilyFace.mInvalid),</span>
<span class="lineNum">    1046 </span><span class="lineCov">        105 :               mCheckForFallbackFaces(aOtherFamilyFace.mCheckForFallbackFaces)</span>
<span class="lineNum">    1047 </span>            :         {
<span class="lineNum">    1048 </span><span class="lineCov">         21 :             if (mFontCreated) {</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                 mFont = aOtherFamilyFace.mFont;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 NS_ADDREF(mFont);</span>
<span class="lineNum">    1051 </span>            :             } else {
<span class="lineNum">    1052 </span><span class="lineCov">         21 :                 mFontEntry = aOtherFamilyFace.mFontEntry;</span>
<span class="lineNum">    1053 </span><span class="lineCov">         21 :                 NS_IF_ADDREF(mFontEntry);</span>
<span class="lineNum">    1054 </span>            :             }
<a name="1055"><span class="lineNum">    1055 </span><span class="lineCov">         21 :         }</span></a>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineCov">         25 :         ~FamilyFace()</span>
<span class="lineNum">    1058 </span><span class="lineCov">         25 :         {</span>
<span class="lineNum">    1059 </span><span class="lineCov">         25 :             if (mFontCreated) {</span>
<span class="lineNum">    1060 </span><span class="lineCov">          1 :                 NS_RELEASE(mFont);</span>
<span class="lineNum">    1061 </span>            :             } else {
<span class="lineNum">    1062 </span><span class="lineCov">         24 :                 NS_IF_RELEASE(mFontEntry);</span>
<span class="lineNum">    1063 </span>            :             }
<span class="lineNum">    1064 </span><span class="lineCov">         25 :         }</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :         FamilyFace&amp; operator=(const FamilyFace&amp; aOther)
<span class="lineNum">    1067 </span>            :         {
<span class="lineNum">    1068 </span>            :             if (mFontCreated) {
<span class="lineNum">    1069 </span>            :                 NS_RELEASE(mFont);
<span class="lineNum">    1070 </span>            :             } else {
<span class="lineNum">    1071 </span>            :                 NS_IF_RELEASE(mFontEntry);
<span class="lineNum">    1072 </span>            :             }
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :             mFamily = aOther.mFamily;
<span class="lineNum">    1075 </span>            :             mNeedsBold = aOther.mNeedsBold;
<span class="lineNum">    1076 </span>            :             mFontCreated = aOther.mFontCreated;
<span class="lineNum">    1077 </span>            :             mLoading = aOther.mLoading;
<span class="lineNum">    1078 </span>            :             mInvalid = aOther.mInvalid;
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :             if (mFontCreated) {
<span class="lineNum">    1081 </span>            :                 mFont = aOther.mFont;
<span class="lineNum">    1082 </span>            :                 NS_ADDREF(mFont);
<span class="lineNum">    1083 </span>            :             } else {
<span class="lineNum">    1084 </span>            :                 mFontEntry = aOther.mFontEntry;
<span class="lineNum">    1085 </span>            :                 NS_IF_ADDREF(mFontEntry);
<span class="lineNum">    1086 </span>            :             }
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :             return *this;
<a name="1089"><span class="lineNum">    1089 </span>            :         }</a>
<a name="1090"><span class="lineNum">    1090 </span>            : </a>
<span class="lineNum">    1091 </span><span class="lineCov">         26 :         gfxFontFamily* Family() const { return mFamily.get(); }</span>
<span class="lineNum">    1092 </span><span class="lineCov">       1959 :         gfxFont* Font() const {</span>
<span class="lineNum">    1093 </span><span class="lineCov">       1959 :             return mFontCreated ? mFont : nullptr;</span>
<a name="1094"><span class="lineNum">    1094 </span>            :         }</a>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineCov">         68 :         gfxFontEntry* FontEntry() const {</span>
<span class="lineNum">    1097 </span><span class="lineCov">         68 :             return mFontCreated ? mFont-&gt;GetFontEntry() : mFontEntry;</span>
<a name="1098"><span class="lineNum">    1098 </span>            :         }</a>
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<span class="lineNum">    1100 </span><span class="lineCov">          6 :         bool NeedsBold() const { return mNeedsBold; }</span>
<span class="lineNum">    1101 </span><span class="lineCov">         19 :         bool IsUserFontContainer() const {</span>
<a name="1102"><span class="lineNum">    1102 </span><span class="lineCov">         19 :             return FontEntry()-&gt;mIsUserFontContainer;</span></a>
<a name="1103"><span class="lineNum">    1103 </span>            :         }</a>
<span class="lineNum">    1104 </span><span class="lineCov">        866 :         bool IsLoading() const { return mLoading; }</span>
<a name="1105"><span class="lineNum">    1105 </span><span class="lineCov">       1959 :         bool IsInvalid() const { return mInvalid; }</span></a>
<a name="1106"><span class="lineNum">    1106 </span>            :         void CheckState(bool&amp; aSkipDrawing);</a>
<a name="1107"><span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         void SetLoading(bool aIsLoading) { mLoading = aIsLoading; }</span></a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         void SetInvalid() { mInvalid = true; }</span></a>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :         bool CheckForFallbackFaces() const { return mCheckForFallbackFaces; }</span>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineCov">          5 :         void SetCheckForFallbackFaces() { mCheckForFallbackFaces = true; }</span></a>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineCov">          6 :         void SetFont(gfxFont* aFont)</span>
<span class="lineNum">    1113 </span>            :         {
<span class="lineNum">    1114 </span><span class="lineCov">          6 :             NS_ASSERTION(aFont, &quot;font pointer must not be null&quot;);</span>
<span class="lineNum">    1115 </span><span class="lineCov">          6 :             NS_ADDREF(aFont);</span>
<span class="lineNum">    1116 </span><span class="lineCov">          6 :             if (mFontCreated) {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                 NS_RELEASE(mFont);</span>
<span class="lineNum">    1118 </span>            :             } else {
<span class="lineNum">    1119 </span><span class="lineCov">          6 :                 NS_IF_RELEASE(mFontEntry);</span>
<span class="lineNum">    1120 </span>            :             }
<span class="lineNum">    1121 </span><span class="lineCov">          6 :             mFont = aFont;</span>
<span class="lineNum">    1122 </span><span class="lineCov">          6 :             mFontCreated = true;</span>
<span class="lineNum">    1123 </span><span class="lineCov">          6 :             mLoading = false;</span>
<span class="lineNum">    1124 </span><span class="lineCov">          6 :         }</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :         bool EqualsUserFont(const gfxUserFontEntry* aUserFont) const;
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :     private:
<span class="lineNum">    1129 </span>            :         RefPtr&lt;gfxFontFamily&gt; mFamily;
<span class="lineNum">    1130 </span>            :         // either a font or a font entry exists
<span class="lineNum">    1131 </span>            :         union {
<span class="lineNum">    1132 </span>            :             gfxFont*            mFont;
<span class="lineNum">    1133 </span>            :             gfxFontEntry*       mFontEntry;
<span class="lineNum">    1134 </span>            :         };
<span class="lineNum">    1135 </span>            :         bool                    mNeedsBold   : 1;
<span class="lineNum">    1136 </span>            :         bool                    mFontCreated : 1;
<span class="lineNum">    1137 </span>            :         bool                    mLoading     : 1;
<span class="lineNum">    1138 </span>            :         bool                    mInvalid     : 1;
<span class="lineNum">    1139 </span>            :         bool                    mCheckForFallbackFaces : 1;
<span class="lineNum">    1140 </span>            :     };
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :     // List of font families, either named or generic.
<span class="lineNum">    1143 </span>            :     // Generic names map to system pref fonts based on language.
<span class="lineNum">    1144 </span>            :     mozilla::FontFamilyList mFamilyList;
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :     // Fontlist containing a font entry for each family found. gfxFont objects
<span class="lineNum">    1147 </span>            :     // are created as needed and userfont loads are initiated when needed.
<span class="lineNum">    1148 </span>            :     // Code should be careful about addressing this array directly.
<span class="lineNum">    1149 </span>            :     nsTArray&lt;FamilyFace&gt; mFonts;
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :     RefPtr&lt;gfxFont&gt; mDefaultFont;
<span class="lineNum">    1152 </span>            :     gfxFontStyle mStyle;
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :     gfxFloat mUnderlineOffset;
<span class="lineNum">    1155 </span>            :     gfxFloat mHyphenWidth;
<span class="lineNum">    1156 </span>            :     gfxFloat mDevToCssSize;
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            :     RefPtr&lt;gfxUserFontSet&gt; mUserFontSet;
<span class="lineNum">    1159 </span>            :     uint64_t mCurrGeneration;  // track the current user font set generation, rebuild font list if needed
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :     gfxTextPerfMetrics *mTextPerf;
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :     // Cache a textrun representing an ellipsis (useful for CSS text-overflow)
<span class="lineNum">    1164 </span>            :     // at a specific appUnitsPerDevPixel size and orientation
<span class="lineNum">    1165 </span>            :     RefPtr&lt;gfxTextRun&gt;   mCachedEllipsisTextRun;
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span>            :     // cache the most recent pref font to avoid general pref font lookup
<span class="lineNum">    1168 </span>            :     RefPtr&lt;gfxFontFamily&gt; mLastPrefFamily;
<span class="lineNum">    1169 </span>            :     RefPtr&lt;gfxFont&gt;       mLastPrefFont;
<span class="lineNum">    1170 </span>            :     eFontPrefLang           mLastPrefLang;       // lang group for last pref font
<span class="lineNum">    1171 </span>            :     eFontPrefLang           mPageLang;
<span class="lineNum">    1172 </span>            :     bool                    mLastPrefFirstFont;  // is this the first font in the list of pref fonts for this lang group?
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     bool                    mSkipDrawing; // hide text while waiting for a font
<span class="lineNum">    1175 </span>            :                                           // download to complete (or fallback
<span class="lineNum">    1176 </span>            :                                           // timer to fire)
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :     /**
<span class="lineNum">    1179 </span>            :      * Textrun creation short-cuts for special cases where we don't need to
<span class="lineNum">    1180 </span>            :      * call a font shaper to generate glyphs.
<span class="lineNum">    1181 </span>            :      */
<span class="lineNum">    1182 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">    1183 </span>            :     MakeEmptyTextRun(const Parameters *aParams,
<span class="lineNum">    1184 </span>            :                      mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1185 </span>            :                      nsTextFrameUtils::Flags aFlags2);
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">    1188 </span>            :     MakeSpaceTextRun(const Parameters *aParams,
<span class="lineNum">    1189 </span>            :                      mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1190 </span>            :                      nsTextFrameUtils::Flags aFlags2);
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :     already_AddRefed&lt;gfxTextRun&gt;
<span class="lineNum">    1193 </span>            :     MakeBlankTextRun(uint32_t aLength, const Parameters *aParams,
<span class="lineNum">    1194 </span>            :                      mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1195 </span>            :                      nsTextFrameUtils::Flags aFlags2);
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            :     // Initialize the list of fonts
<span class="lineNum">    1198 </span>            :     void BuildFontList();
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :     // Get the font at index i within the fontlist.
<span class="lineNum">    1201 </span>            :     // Will initiate userfont load if not already loaded.
<span class="lineNum">    1202 </span>            :     // May return null if userfont not loaded or if font invalid
<span class="lineNum">    1203 </span>            :     gfxFont* GetFontAt(int32_t i, uint32_t aCh = 0x20);
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :     // Whether there's a font loading for a given family in the fontlist
<span class="lineNum">    1206 </span>            :     // for a given character
<span class="lineNum">    1207 </span>            :     bool FontLoadingForFamily(gfxFontFamily* aFamily, uint32_t aCh) const;
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :     // will always return a font or force a shutdown
<span class="lineNum">    1210 </span>            :     gfxFont* GetDefaultFont();
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :     // Init this font group's font metrics. If there no bad fonts, you don't need to call this.
<span class="lineNum">    1213 </span>            :     // But if there are one or more bad fonts which have bad underline offset,
<span class="lineNum">    1214 </span>            :     // you should call this with the *first* bad font.
<span class="lineNum">    1215 </span>            :     void InitMetricsForBadFont(gfxFont* aBadFont);
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :     // Set up the textrun glyphs for an entire text run:
<span class="lineNum">    1218 </span>            :     // find script runs, and then call InitScriptRun for each
<span class="lineNum">    1219 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1220 </span>            :     void InitTextRun(DrawTarget* aDrawTarget,
<span class="lineNum">    1221 </span>            :                      gfxTextRun *aTextRun,
<span class="lineNum">    1222 </span>            :                      const T *aString,
<span class="lineNum">    1223 </span>            :                      uint32_t aLength,
<span class="lineNum">    1224 </span>            :                      gfxMissingFontRecorder *aMFR);
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :     // InitTextRun helper to handle a single script run, by finding font ranges
<span class="lineNum">    1227 </span>            :     // and calling each font's InitTextRun() as appropriate
<span class="lineNum">    1228 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1229 </span>            :     void InitScriptRun(DrawTarget* aDrawTarget,
<span class="lineNum">    1230 </span>            :                        gfxTextRun *aTextRun,
<span class="lineNum">    1231 </span>            :                        const T *aString,
<span class="lineNum">    1232 </span>            :                        uint32_t aScriptRunStart,
<span class="lineNum">    1233 </span>            :                        uint32_t aScriptRunEnd,
<span class="lineNum">    1234 </span>            :                        Script aRunScript,
<span class="lineNum">    1235 </span>            :                        gfxMissingFontRecorder *aMFR);
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            :     // Helper for font-matching:
<span class="lineNum">    1238 </span>            :     // search all faces in a family for a fallback in cases where it's unclear
<span class="lineNum">    1239 </span>            :     // whether the family might have a font for a given character
<span class="lineNum">    1240 </span>            :     gfxFont*
<span class="lineNum">    1241 </span>            :     FindFallbackFaceForChar(gfxFontFamily* aFamily, uint32_t aCh,
<span class="lineNum">    1242 </span>            :                             Script aRunScript);
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            :    // helper methods for looking up fonts
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :     // lookup and add a font with a given name (i.e. *not* a generic!)
<span class="lineNum">    1247 </span>            :     void AddPlatformFont(const nsAString&amp; aName,
<span class="lineNum">    1248 </span>            :                          nsTArray&lt;gfxFontFamily*&gt;&amp; aFamilyList);
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :     // do style selection and add entries to list
<span class="lineNum">    1251 </span>            :     void AddFamilyToFontList(gfxFontFamily* aFamily);
<span class="lineNum">    1252 </span>            : };
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : // A &quot;missing font recorder&quot; is to be used during text-run creation to keep
<span class="lineNum">    1255 </span>            : // a record of any scripts encountered for which font coverage was lacking;
<span class="lineNum">    1256 </span>            : // when Flush() is called, it sends a notification that front-end code can use
<span class="lineNum">    1257 </span>            : // to download fonts on demand (or whatever else it wants to do).
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            : #define GFX_MISSING_FONTS_NOTIFY_PREF &quot;gfx.missing_fonts.notify&quot;
<span class="lineNum">    1260 </span>            : 
<a name="1261"><span class="lineNum">    1261 </span>            : class gfxMissingFontRecorder {</a>
<span class="lineNum">    1262 </span>            : public:
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     gfxMissingFontRecorder()</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :         MOZ_COUNT_CTOR(gfxMissingFontRecorder);</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :         memset(&amp;mMissingFonts, 0, sizeof(mMissingFonts));</span>
<a name="1267"><span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     ~gfxMissingFontRecorder()</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1271 </span>            : #ifdef DEBUG
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; i &lt; kNumScriptBitsWords; i++) {</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :             NS_ASSERTION(mMissingFonts[i] == 0,</span>
<span class="lineNum">    1274 </span>            :                          &quot;failed to flush the missing-font recorder&quot;);
<span class="lineNum">    1275 </span>            :         }
<span class="lineNum">    1276 </span>            : #endif
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         MOZ_COUNT_DTOR(gfxMissingFontRecorder);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     }</span>
<a name="1279"><span class="lineNum">    1279 </span>            : </a>
<span class="lineNum">    1280 </span>            :     // record this script code in our mMissingFonts bitset
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     void RecordScript(mozilla::unicode::Script aScriptCode)</span>
<span class="lineNum">    1282 </span>            :     {
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :         mMissingFonts[static_cast&lt;uint32_t&gt;(aScriptCode) &gt;&gt; 5] |=</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             (1 &lt;&lt; (static_cast&lt;uint32_t&gt;(aScriptCode) &amp; 0x1f));</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :     // send a notification of any missing-scripts that have been
<span class="lineNum">    1288 </span>            :     // recorded, and clear the mMissingFonts set for re-use
<span class="lineNum">    1289 </span>            :     void Flush();
<span class="lineNum">    1290 </span>            : 
<a name="1291"><span class="lineNum">    1291 </span>            :     // forget any missing-scripts that have been recorded up to now;</a>
<span class="lineNum">    1292 </span>            :     // called before discarding a recorder we no longer care about
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     void Clear()</span>
<span class="lineNum">    1294 </span>            :     {
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         memset(&amp;mMissingFonts, 0, sizeof(mMissingFonts));</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : private:
<span class="lineNum">    1299 </span>            :     // Number of 32-bit words needed for the missing-script flags
<span class="lineNum">    1300 </span>            :     static const uint32_t kNumScriptBitsWords =
<span class="lineNum">    1301 </span>            :         ((static_cast&lt;int&gt;(mozilla::unicode::Script::NUM_SCRIPT_CODES) + 31) / 32);
<span class="lineNum">    1302 </span>            :     uint32_t mMissingFonts[kNumScriptBitsWords];
<span class="lineNum">    1303 </span>            : };
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

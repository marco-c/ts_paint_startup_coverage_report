<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/thebes/gfxFont.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/thebes</a> - gfxFont.h<span style="font-size: 80%;"> (source / <a href="gfxFont.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">276</td>
            <td class="headerCovTableEntry">461</td>
            <td class="headerCovTableEntryLo">59.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">102</td>
            <td class="headerCovTableEntry">159</td>
            <td class="headerCovTableEntryLo">64.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=4 et sw=4 tw=80:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef GFX_FONT_H
<span class="lineNum">       8 </span>            : #define GFX_FONT_H
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;gfxTypes.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;gfxFontEntry.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;gfxFontVariations.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;gfxPoint.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;gfxPattern.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsTHashtable.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsHashKeys.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;gfxRect.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsExpirationTracker.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;gfxPlatform.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIAtom.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/HashFunctions.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIMemoryReporter.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIObserver.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;mozilla/TypedEnumBits.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;MainThreadUtils.h&quot;
<span class="lineNum">      30 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      31 </span>            : #include &quot;DrawMode.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsDataHashtable.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;harfbuzz/hb.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsColor.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : typedef struct _cairo cairo_t;
<span class="lineNum">      38 </span>            : typedef struct _cairo_scaled_font cairo_scaled_font_t;
<span class="lineNum">      39 </span>            : //typedef struct gr_face            gr_face;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #ifdef DEBUG
<span class="lineNum">      42 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : class gfxContext;
<span class="lineNum">      46 </span>            : class gfxTextRun;
<span class="lineNum">      47 </span>            : class gfxFont;
<span class="lineNum">      48 </span>            : class gfxGlyphExtents;
<span class="lineNum">      49 </span>            : class gfxShapedText;
<span class="lineNum">      50 </span>            : class gfxShapedWord;
<span class="lineNum">      51 </span>            : class gfxSkipChars;
<span class="lineNum">      52 </span>            : class gfxMathTable;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #define FONT_MAX_SIZE                  2000.0
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : #define NO_FONT_LANGUAGE_OVERRIDE      0
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #define SMALL_CAPS_SCALE_FACTOR        0.8
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : // The skew factor used for synthetic-italic [oblique] fonts;
<span class="lineNum">      61 </span>            : // we use a platform-dependent value to harmonize with the platform's own APIs.
<span class="lineNum">      62 </span>            : #ifdef XP_WIN
<span class="lineNum">      63 </span>            : #define OBLIQUE_SKEW_FACTOR  0.3
<span class="lineNum">      64 </span>            : #elif defined(MOZ_WIDGET_GTK)
<span class="lineNum">      65 </span>            : #define OBLIQUE_SKEW_FACTOR  0.2
<span class="lineNum">      66 </span>            : #else
<span class="lineNum">      67 </span>            : #define OBLIQUE_SKEW_FACTOR  0.25
<span class="lineNum">      68 </span>            : #endif
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : struct gfxTextRunDrawCallbacks;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : namespace mozilla {
<span class="lineNum">      73 </span>            : class SVGContextPaint;
<span class="lineNum">      74 </span>            : namespace gfx {
<span class="lineNum">      75 </span>            : class GlyphRenderingOptions;
<span class="lineNum">      76 </span>            : } // namespace gfx
<a name="77"><span class="lineNum">      77 </span>            : } // namespace mozilla</a>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineCov">         36 : struct gfxFontStyle {</span>
<span class="lineNum">      80 </span>            :     gfxFontStyle();
<span class="lineNum">      81 </span>            :     gfxFontStyle(uint8_t aStyle, uint16_t aWeight, int16_t aStretch,
<span class="lineNum">      82 </span>            :                  gfxFloat aSize, nsIAtom *aLanguage, bool aExplicitLanguage,
<span class="lineNum">      83 </span>            :                  float aSizeAdjust, bool aSystemFont,
<span class="lineNum">      84 </span>            :                  bool aPrinterFont,
<span class="lineNum">      85 </span>            :                  bool aWeightSynthesis, bool aStyleSynthesis,
<span class="lineNum">      86 </span>            :                  uint32_t aLanguageOverride);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     // the language (may be an internal langGroup code rather than an actual
<span class="lineNum">      89 </span>            :     // language code) specified in the document or element's lang property,
<span class="lineNum">      90 </span>            :     // or inferred from the charset
<span class="lineNum">      91 </span>            :     RefPtr&lt;nsIAtom&gt; language;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     // Features are composed of (1) features from style rules (2) features
<span class="lineNum">      94 </span>            :     // from feature settings rules and (3) family-specific features.  (1) and
<span class="lineNum">      95 </span>            :     // (3) are guaranteed to be mutually exclusive
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :     // custom opentype feature settings
<span class="lineNum">      98 </span>            :     nsTArray&lt;gfxFontFeature&gt; featureSettings;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     // Some font-variant property values require font-specific settings
<span class="lineNum">     101 </span>            :     // defined via @font-feature-values rules.  These are resolved after
<span class="lineNum">     102 </span>            :     // font matching occurs.
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     // -- list of value tags for specific alternate features
<span class="lineNum">     105 </span>            :     nsTArray&lt;gfxAlternateValue&gt; alternateValues;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :     // -- object used to look these up once the font is matched
<span class="lineNum">     108 </span>            :     RefPtr&lt;gfxFontFeatureValueSet&gt; featureValueLookup;
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :     // opentype variation settings
<span class="lineNum">     111 </span>            :     nsTArray&lt;gfxFontVariation&gt; variationSettings;
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :     // The logical size of the font, in pixels
<span class="lineNum">     114 </span>            :     gfxFloat size;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :     // The aspect-value (ie., the ratio actualsize:actualxheight) that any
<span class="lineNum">     117 </span>            :     // actual physical font created from this font structure must have when
<span class="lineNum">     118 </span>            :     // rendering or measuring a string. A value of -1.0 means no adjustment
<span class="lineNum">     119 </span>            :     // needs to be done; otherwise the value must be nonnegative.
<span class="lineNum">     120 </span>            :     float sizeAdjust;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     // baseline offset, used when simulating sub/superscript glyphs
<span class="lineNum">     123 </span>            :     float baselineOffset;
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :     // Language system tag, to override document language;
<span class="lineNum">     126 </span>            :     // an OpenType &quot;language system&quot; tag represented as a 32-bit integer
<span class="lineNum">     127 </span>            :     // (see http://www.microsoft.com/typography/otspec/languagetags.htm).
<span class="lineNum">     128 </span>            :     // Normally 0, so font rendering will use the document or element language
<span class="lineNum">     129 </span>            :     // (see above) to control any language-specific rendering, but the author
<span class="lineNum">     130 </span>            :     // can override this for cases where the options implemented in the font
<span class="lineNum">     131 </span>            :     // do not directly match the actual language. (E.g. lang may be Macedonian,
<span class="lineNum">     132 </span>            :     // but the font in use does not explicitly support this; the author can
<span class="lineNum">     133 </span>            :     // use font-language-override to request the Serbian option in the font
<span class="lineNum">     134 </span>            :     // in order to get correct glyph shapes.)
<span class="lineNum">     135 </span>            :     uint32_t languageOverride;
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     // The weight of the font: 100, 200, ... 900.
<span class="lineNum">     138 </span>            :     uint16_t weight;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :     // The stretch of the font (the sum of various NS_FONT_STRETCH_*
<span class="lineNum">     141 </span>            :     // constants; see gfxFontConstants.h).
<span class="lineNum">     142 </span>            :     int8_t stretch;
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     // The style of font (normal, italic, oblique)
<span class="lineNum">     145 </span>            :     uint8_t style;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :     // caps variant (small-caps, petite-caps, etc.)
<span class="lineNum">     148 </span>            :     uint8_t variantCaps;
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :     // sub/superscript variant
<span class="lineNum">     151 </span>            :     uint8_t variantSubSuper;
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :     // Say that this font is a system font and therefore does not
<span class="lineNum">     154 </span>            :     // require certain fixup that we do for fonts from untrusted
<span class="lineNum">     155 </span>            :     // sources.
<span class="lineNum">     156 </span>            :     bool systemFont : 1;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :     // Say that this font is used for print or print preview.
<span class="lineNum">     159 </span>            :     bool printerFont : 1;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     // Used to imitate -webkit-font-smoothing: antialiased
<span class="lineNum">     162 </span>            :     bool useGrayscaleAntialiasing : 1;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     // Whether synthetic styles are allowed
<span class="lineNum">     165 </span>            :     bool allowSyntheticWeight : 1;
<span class="lineNum">     166 </span>            :     bool allowSyntheticStyle : 1;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :     // some variant features require fallback which complicates the shaping
<span class="lineNum">     169 </span>            :     // code, so set up a bool to indicate when shaping with fallback is needed
<span class="lineNum">     170 </span>            :     bool noFallbackVariantFeatures : 1;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     // whether the |language| field comes from explicit lang tagging in the
<span class="lineNum">     173 </span>            :     // document, or was inferred from charset/system locale
<span class="lineNum">     174 </span>            :     bool explicitLanguage : 1;
<span class="lineNum">     175 </span>            : 
<a name="176"><span class="lineNum">     176 </span>            :     // Return the final adjusted font size for the given aspect ratio.</a>
<span class="lineNum">     177 </span>            :     // Not meant to be called when sizeAdjust = -1.0.
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     gfxFloat GetAdjustedSize(gfxFloat aspect) const {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         NS_ASSERTION(sizeAdjust &gt;= 0.0, &quot;Not meant to be called when sizeAdjust = -1.0&quot;);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         gfxFloat adjustedSize = std::max(NS_round(size*(sizeAdjust/aspect)), 1.0);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         return std::min(adjustedSize, FONT_MAX_SIZE);</span>
<a name="182"><span class="lineNum">     182 </span>            :     }</a>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineCov">         22 :     PLDHashNumber Hash() const {</span>
<span class="lineNum">     185 </span><span class="lineCov">         44 :         return ((style + (systemFont &lt;&lt; 7) +</span>
<span class="lineNum">     186 </span><span class="lineCov">         44 :             (weight &lt;&lt; 8)) + uint32_t(size*1000) + uint32_t(sizeAdjust*1000)) ^</span>
<span class="lineNum">     187 </span><span class="lineCov">         22 :             nsISupportsHashKey::HashKey(language);</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     int8_t ComputeWeight() const;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :     // Adjust this style to simulate sub/superscript (as requested in the
<span class="lineNum">     193 </span>            :     // variantSubSuper field) using size and baselineOffset instead.
<a name="194"><span class="lineNum">     194 </span>            :     void AdjustForSubSuperscript(int32_t aAppUnitsPerDevPixel);</a>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineCov">          9 :     bool Equals(const gfxFontStyle&amp; other) const {</span>
<span class="lineNum">     197 </span>            :         return
<span class="lineNum">     198 </span><span class="lineCov">          9 :             (*reinterpret_cast&lt;const uint64_t*&gt;(&amp;size) ==</span>
<span class="lineNum">     199 </span><span class="lineCov">         18 :              *reinterpret_cast&lt;const uint64_t*&gt;(&amp;other.size)) &amp;&amp;</span>
<span class="lineNum">     200 </span><span class="lineCov">         18 :             (style == other.style) &amp;&amp;</span>
<span class="lineNum">     201 </span><span class="lineCov">         18 :             (weight == other.weight) &amp;&amp;</span>
<span class="lineNum">     202 </span><span class="lineCov">         18 :             (stretch == other.stretch) &amp;&amp;</span>
<span class="lineNum">     203 </span><span class="lineCov">         18 :             (variantCaps == other.variantCaps) &amp;&amp;</span>
<span class="lineNum">     204 </span><span class="lineCov">         18 :             (variantSubSuper == other.variantSubSuper) &amp;&amp;</span>
<span class="lineNum">     205 </span><span class="lineCov">         18 :             (allowSyntheticWeight == other.allowSyntheticWeight) &amp;&amp;</span>
<span class="lineNum">     206 </span><span class="lineCov">         18 :             (allowSyntheticStyle == other.allowSyntheticStyle) &amp;&amp;</span>
<span class="lineNum">     207 </span><span class="lineCov">         18 :             (systemFont == other.systemFont) &amp;&amp;</span>
<span class="lineNum">     208 </span><span class="lineCov">         18 :             (printerFont == other.printerFont) &amp;&amp;</span>
<span class="lineNum">     209 </span><span class="lineCov">         18 :             (useGrayscaleAntialiasing == other.useGrayscaleAntialiasing) &amp;&amp;</span>
<span class="lineNum">     210 </span><span class="lineCov">         18 :             (explicitLanguage == other.explicitLanguage) &amp;&amp;</span>
<span class="lineNum">     211 </span><span class="lineCov">         18 :             (language == other.language) &amp;&amp;</span>
<span class="lineNum">     212 </span><span class="lineCov">         18 :             (baselineOffset == other.baselineOffset) &amp;&amp;</span>
<span class="lineNum">     213 </span><span class="lineCov">          9 :             (*reinterpret_cast&lt;const uint32_t*&gt;(&amp;sizeAdjust) ==</span>
<span class="lineNum">     214 </span><span class="lineCov">         18 :              *reinterpret_cast&lt;const uint32_t*&gt;(&amp;other.sizeAdjust)) &amp;&amp;</span>
<span class="lineNum">     215 </span><span class="lineCov">         18 :             (featureSettings == other.featureSettings) &amp;&amp;</span>
<span class="lineNum">     216 </span><span class="lineCov">         18 :             (alternateValues == other.alternateValues) &amp;&amp;</span>
<span class="lineNum">     217 </span><span class="lineCov">         18 :             (featureValueLookup == other.featureValueLookup) &amp;&amp;</span>
<span class="lineNum">     218 </span><span class="lineCov">         27 :             (variationSettings == other.variationSettings) &amp;&amp;</span>
<span class="lineNum">     219 </span><span class="lineCov">         18 :             (languageOverride == other.languageOverride);</span>
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span>            : };
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : /**
<span class="lineNum">     225 </span>            :  * Font cache design:
<span class="lineNum">     226 </span>            :  * 
<span class="lineNum">     227 </span>            :  * The mFonts hashtable contains most fonts, indexed by (gfxFontEntry*, style).
<span class="lineNum">     228 </span>            :  * It does not add a reference to the fonts it contains.
<span class="lineNum">     229 </span>            :  * When a font's refcount decreases to zero, instead of deleting it we
<span class="lineNum">     230 </span>            :  * add it to our expiration tracker.
<span class="lineNum">     231 </span>            :  * The expiration tracker tracks fonts with zero refcount. After a certain
<span class="lineNum">     232 </span>            :  * period of time, such fonts expire and are deleted.
<span class="lineNum">     233 </span>            :  *
<span class="lineNum">     234 </span>            :  * We're using 3 generations with a ten-second generation interval, so
<span class="lineNum">     235 </span>            :  * zero-refcount fonts will be deleted 20-30 seconds after their refcount
<span class="lineNum">     236 </span>            :  * goes to zero, if timer events fire in a timely manner.
<span class="lineNum">     237 </span>            :  *
<span class="lineNum">     238 </span>            :  * The font cache also handles timed expiration of cached ShapedWords
<span class="lineNum">     239 </span>            :  * for &quot;persistent&quot; fonts: it has a repeating timer, and notifies
<span class="lineNum">     240 </span>            :  * each cached font to &quot;age&quot; its shaped words. The words will be released
<span class="lineNum">     241 </span>            :  * by the fonts if they get aged three times without being re-used in the
<span class="lineNum">     242 </span>            :  * meantime.
<span class="lineNum">     243 </span>            :  *
<span class="lineNum">     244 </span>            :  * Note that the ShapedWord timeout is much larger than the font timeout,
<span class="lineNum">     245 </span>            :  * so that in the case of a short-lived font, we'll discard the gfxFont
<span class="lineNum">     246 </span>            :  * completely, with all its words, and avoid the cost of aging the words
<span class="lineNum">     247 </span>            :  * individually. That only happens with longer-lived fonts.
<a name="248"><span class="lineNum">     248 </span>            :  */</a>
<span class="lineNum">     249 </span>            : struct FontCacheSizes {
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     FontCacheSizes()</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         : mFontInstances(0), mShapedWords(0)</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     { }</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :     size_t mFontInstances; // memory used by instances of gfxFont subclasses
<span class="lineNum">     255 </span>            :     size_t mShapedWords; // memory used by the per-font shapedWord caches
<span class="lineNum">     256 </span>            : };
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : class gfxFontCache final : public nsExpirationTracker&lt;gfxFont,3&gt; {
<span class="lineNum">     259 </span>            : public:
<span class="lineNum">     260 </span>            :     enum {
<span class="lineNum">     261 </span>            :         FONT_TIMEOUT_SECONDS = 10,
<span class="lineNum">     262 </span>            :         SHAPED_WORD_TIMEOUT_SECONDS = 60
<span class="lineNum">     263 </span>            :     };
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :     explicit gfxFontCache(nsIEventTarget* aEventTarget);
<span class="lineNum">     266 </span>            :     ~gfxFontCache();
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :     /*
<span class="lineNum">     269 </span>            :      * Get the global gfxFontCache.  You must call Init() before
<a name="270"><span class="lineNum">     270 </span>            :      * calling this method --- the result will not be null.</a>
<span class="lineNum">     271 </span>            :      */
<span class="lineNum">     272 </span><span class="lineCov">         40 :     static gfxFontCache* GetCache() {</span>
<span class="lineNum">     273 </span><span class="lineCov">         40 :         return gGlobalCache;</span>
<span class="lineNum">     274 </span>            :     }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     static nsresult Init();
<span class="lineNum">     277 </span>            :     // It's OK to call this even if Init() has not been called.
<span class="lineNum">     278 </span>            :     static void Shutdown();
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :     // Look up a font in the cache. Returns null if there's nothing matching
<span class="lineNum">     281 </span>            :     // in the cache
<span class="lineNum">     282 </span>            :     gfxFont* Lookup(const gfxFontEntry* aFontEntry,
<span class="lineNum">     283 </span>            :                     const gfxFontStyle* aStyle,
<span class="lineNum">     284 </span>            :                     const gfxCharacterMap* aUnicodeRangeMap);
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     // We created a new font (presumably because Lookup returned null);
<span class="lineNum">     287 </span>            :     // put it in the cache. The font's refcount should be nonzero. It is
<span class="lineNum">     288 </span>            :     // allowable to add a new font even if there is one already in the
<span class="lineNum">     289 </span>            :     // cache with the same key; we'll forget about the old one.
<span class="lineNum">     290 </span>            :     void AddNew(gfxFont *aFont);
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     // The font's refcount has gone to zero; give ownership of it to
<span class="lineNum">     293 </span>            :     // the cache. We delete it if it's not acquired again after a certain
<span class="lineNum">     294 </span>            :     // amount of time.
<span class="lineNum">     295 </span>            :     void NotifyReleased(gfxFont *aFont);
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     // This gets called when the timeout has expired on a zero-refcount
<span class="lineNum">     298 </span>            :     // font; we just delete it.
<span class="lineNum">     299 </span>            :     virtual void NotifyExpired(gfxFont *aFont) override;
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     // Cleans out the hashtable and removes expired fonts waiting for cleanup.
<span class="lineNum">     302 </span>            :     // Other gfxFont objects may be still in use but they will be pushed
<span class="lineNum">     303 </span>            :     // into the expiration queues and removed.
<span class="lineNum">     304 </span>            :     void Flush() {
<span class="lineNum">     305 </span>            :         mFonts.Clear();
<span class="lineNum">     306 </span>            :         AgeAllGenerations();
<span class="lineNum">     307 </span>            :     }
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :     void FlushShapedWordCaches();
<span class="lineNum">     310 </span>            :     void NotifyGlyphsChanged();
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :     void AddSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf,
<span class="lineNum">     313 </span>            :                                 FontCacheSizes* aSizes) const;
<span class="lineNum">     314 </span>            :     void AddSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf,
<span class="lineNum">     315 </span>            :                                 FontCacheSizes* aSizes) const;
<a name="316"><span class="lineNum">     316 </span>            : </a>
<span class="lineNum">     317 </span>            : protected:
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          3 :     class MemoryReporter final : public nsIMemoryReporter</span></a>
<span class="lineNum">     319 </span>            :     {
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         ~MemoryReporter() {}</span>
<span class="lineNum">     321 </span>            :     public:
<span class="lineNum">     322 </span>            :         NS_DECL_ISUPPORTS
<span class="lineNum">     323 </span>            :         NS_DECL_NSIMEMORYREPORTER
<span class="lineNum">     324 </span>            :     };
<a name="325"><span class="lineNum">     325 </span>            : </a>
<span class="lineNum">     326 </span>            :     // Observer for notifications that the font cache cares about
<span class="lineNum">     327 </span><span class="lineCov">          3 :     class Observer final</span>
<a name="328"><span class="lineNum">     328 </span>            :         : public nsIObserver</a>
<span class="lineNum">     329 </span>            :     {
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         ~Observer() {}</span>
<span class="lineNum">     331 </span>            :     public:
<span class="lineNum">     332 </span>            :         NS_DECL_ISUPPORTS
<span class="lineNum">     333 </span>            :         NS_DECL_NSIOBSERVER
<span class="lineNum">     334 </span>            :     };
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :     void DestroyFont(gfxFont *aFont);
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     static gfxFontCache *gGlobalCache;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :     struct Key {
<span class="lineNum">     341 </span>            :         const gfxFontEntry* mFontEntry;
<a name="342"><span class="lineNum">     342 </span>            :         const gfxFontStyle* mStyle;</a>
<span class="lineNum">     343 </span>            :         const gfxCharacterMap* mUnicodeRangeMap;
<span class="lineNum">     344 </span><span class="lineCov">         17 :         Key(const gfxFontEntry* aFontEntry, const gfxFontStyle* aStyle,</span>
<span class="lineNum">     345 </span>            :             const gfxCharacterMap* aUnicodeRangeMap)
<span class="lineNum">     346 </span><span class="lineCov">         17 :             : mFontEntry(aFontEntry), mStyle(aStyle),</span>
<span class="lineNum">     347 </span><span class="lineCov">         17 :               mUnicodeRangeMap(aUnicodeRangeMap)</span>
<span class="lineNum">     348 </span><span class="lineCov">         17 :         {}</span>
<span class="lineNum">     349 </span>            :     };
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :     class HashEntry : public PLDHashEntryHdr {
<span class="lineNum">     352 </span>            :     public:
<span class="lineNum">     353 </span>            :         typedef const Key&amp; KeyType;
<span class="lineNum">     354 </span>            :         typedef const Key* KeyTypePointer;
<span class="lineNum">     355 </span>            : 
<a name="356"><span class="lineNum">     356 </span>            :         // When constructing a new entry in the hashtable, we'll leave this</a>
<span class="lineNum">     357 </span>            :         // blank. The caller of Put() will fill this in.
<a name="358"><span class="lineNum">     358 </span><span class="lineCov">          8 :         explicit HashEntry(KeyTypePointer aStr) : mFont(nullptr) { }</span></a>
<span class="lineNum">     359 </span>            :         HashEntry(const HashEntry&amp; toCopy) : mFont(toCopy.mFont) { }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         ~HashEntry() { }</span>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span>            :         bool KeyEquals(const KeyTypePointer aKey) const;</a>
<span class="lineNum">     363 </span><span class="lineCov">         25 :         static KeyTypePointer KeyToPointer(KeyType aKey) { return &amp;aKey; }</span>
<span class="lineNum">     364 </span><span class="lineCov">         22 :         static PLDHashNumber HashKey(const KeyTypePointer aKey) {</span>
<span class="lineNum">     365 </span><span class="lineCov">         22 :             return mozilla::HashGeneric(aKey-&gt;mStyle-&gt;Hash(), aKey-&gt;mFontEntry,</span>
<span class="lineNum">     366 </span><span class="lineCov">         44 :                                         aKey-&gt;mUnicodeRangeMap);</span>
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span>            :         enum { ALLOW_MEMMOVE = true };
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :         gfxFont* mFont;
<span class="lineNum">     371 </span>            :     };
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :     nsTHashtable&lt;HashEntry&gt; mFonts;
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     static void WordCacheExpirationTimerCallback(nsITimer* aTimer, void* aCache);
<span class="lineNum">     376 </span>            :     nsCOMPtr&lt;nsITimer&gt;      mWordCacheExpirationTimer;
<span class="lineNum">     377 </span>            : };
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : class gfxTextPerfMetrics {
<span class="lineNum">     380 </span>            : public:
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :     struct TextCounts {
<span class="lineNum">     383 </span>            :         uint32_t    numContentTextRuns;
<span class="lineNum">     384 </span>            :         uint32_t    numChromeTextRuns;
<span class="lineNum">     385 </span>            :         uint32_t    numChars;
<span class="lineNum">     386 </span>            :         uint32_t    maxTextRunLen;
<span class="lineNum">     387 </span>            :         uint32_t    wordCacheSpaceRules;
<span class="lineNum">     388 </span>            :         uint32_t    wordCacheLong;
<span class="lineNum">     389 </span>            :         uint32_t    wordCacheHit;
<span class="lineNum">     390 </span>            :         uint32_t    wordCacheMiss;
<span class="lineNum">     391 </span>            :         uint32_t    fallbackPrefs;
<span class="lineNum">     392 </span>            :         uint32_t    fallbackSystem;
<span class="lineNum">     393 </span>            :         uint32_t    textrunConst;
<span class="lineNum">     394 </span>            :         uint32_t    textrunDestr;
<span class="lineNum">     395 </span>            :         uint32_t    genericLookups;
<span class="lineNum">     396 </span>            :     };
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :     uint32_t reflowCount;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :     // counts per reflow operation
<span class="lineNum">     401 </span>            :     TextCounts current;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :     // totals for the lifetime of a document
<a name="404"><span class="lineNum">     404 </span>            :     TextCounts cumulative;</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     gfxTextPerfMetrics() {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         memset(this, 0, sizeof(gfxTextPerfMetrics));</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     }</span>
<a name="409"><span class="lineNum">     409 </span>            : </a>
<span class="lineNum">     410 </span>            :     // add current totals to cumulative ones
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     void Accumulate() {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         if (current.numChars == 0) {</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     414 </span>            :         }
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         cumulative.numContentTextRuns += current.numContentTextRuns;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         cumulative.numChromeTextRuns += current.numChromeTextRuns;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         cumulative.numChars += current.numChars;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         if (current.maxTextRunLen &gt; cumulative.maxTextRunLen) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :             cumulative.maxTextRunLen = current.maxTextRunLen;</span>
<span class="lineNum">     420 </span>            :         }
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         cumulative.wordCacheSpaceRules += current.wordCacheSpaceRules;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         cumulative.wordCacheLong += current.wordCacheLong;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         cumulative.wordCacheHit += current.wordCacheHit;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         cumulative.wordCacheMiss += current.wordCacheMiss;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         cumulative.fallbackPrefs += current.fallbackPrefs;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         cumulative.fallbackSystem += current.fallbackSystem;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         cumulative.textrunConst += current.textrunConst;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         cumulative.textrunDestr += current.textrunDestr;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         cumulative.genericLookups += current.genericLookups;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         memset(&amp;current, 0, sizeof(current));</span>
<span class="lineNum">     431 </span>            :     }
<span class="lineNum">     432 </span>            : };
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            : namespace mozilla {
<span class="lineNum">     435 </span>            : namespace gfx {
<span class="lineNum">     436 </span>            : // Flags that live in the gfxShapedText::mFlags field.
<span class="lineNum">     437 </span>            : // (Note that gfxTextRun has an additional mFlags2 field for use
<span class="lineNum">     438 </span>            : // by textrun clients like nsTextFrame.)
<span class="lineNum">     439 </span>            : enum class ShapedTextFlags : uint16_t {
<span class="lineNum">     440 </span>            :     /**
<span class="lineNum">     441 </span>            :      * When set, the text is RTL.
<span class="lineNum">     442 </span>            :      */
<span class="lineNum">     443 </span>            :     TEXT_IS_RTL                  = 0x0001,
<span class="lineNum">     444 </span>            :     /**
<span class="lineNum">     445 </span>            :      * When set, spacing is enabled and the textrun needs to call GetSpacing
<span class="lineNum">     446 </span>            :      * on the spacing provider.
<span class="lineNum">     447 </span>            :      */
<span class="lineNum">     448 </span>            :     TEXT_ENABLE_SPACING          = 0x0002,
<span class="lineNum">     449 </span>            :     /**
<span class="lineNum">     450 </span>            :      * When set, the text has no characters above 255 and it is stored
<span class="lineNum">     451 </span>            :      * in the textrun in 8-bit format.
<span class="lineNum">     452 </span>            :      */
<span class="lineNum">     453 </span>            :     TEXT_IS_8BIT                 = 0x0004,
<span class="lineNum">     454 </span>            :     /**
<span class="lineNum">     455 </span>            :      * When set, GetHyphenationBreaks may return true for some character
<span class="lineNum">     456 </span>            :      * positions, otherwise it will always return false for all characters.
<span class="lineNum">     457 </span>            :      */
<span class="lineNum">     458 </span>            :     TEXT_ENABLE_HYPHEN_BREAKS    = 0x0008,
<span class="lineNum">     459 </span>            :     /**
<span class="lineNum">     460 </span>            :      * When set, the RunMetrics::mBoundingBox field will be initialized
<span class="lineNum">     461 </span>            :      * properly based on glyph extents, in particular, glyph extents that
<span class="lineNum">     462 </span>            :      * overflow the standard font-box (the box defined by the ascent, descent
<span class="lineNum">     463 </span>            :      * and advance width of the glyph). When not set, it may just be the
<span class="lineNum">     464 </span>            :      * standard font-box even if glyphs overflow.
<span class="lineNum">     465 </span>            :      */
<span class="lineNum">     466 </span>            :     TEXT_NEED_BOUNDING_BOX       = 0x0010,
<span class="lineNum">     467 </span>            :     /**
<span class="lineNum">     468 </span>            :      * When set, optional ligatures are disabled. Ligatures that are
<span class="lineNum">     469 </span>            :      * required for legible text should still be enabled.
<span class="lineNum">     470 </span>            :      */
<span class="lineNum">     471 </span>            :     TEXT_DISABLE_OPTIONAL_LIGATURES = 0x0020,
<span class="lineNum">     472 </span>            :     /**
<span class="lineNum">     473 </span>            :      * When set, the textrun should favour speed of construction over
<span class="lineNum">     474 </span>            :      * quality. This may involve disabling ligatures and/or kerning or
<span class="lineNum">     475 </span>            :      * other effects.
<span class="lineNum">     476 </span>            :      */
<span class="lineNum">     477 </span>            :     TEXT_OPTIMIZE_SPEED          = 0x0040,
<span class="lineNum">     478 </span>            :     /**
<span class="lineNum">     479 </span>            :      * When set, the textrun should discard control characters instead of
<span class="lineNum">     480 </span>            :      * turning them into hexboxes.
<span class="lineNum">     481 </span>            :      */
<span class="lineNum">     482 </span>            :     TEXT_HIDE_CONTROL_CHARACTERS = 0x0080,
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :     /**
<span class="lineNum">     485 </span>            :      * nsTextFrameThebes sets these, but they're defined here rather than
<span class="lineNum">     486 </span>            :      * in nsTextFrameUtils.h because ShapedWord creation/caching also needs
<span class="lineNum">     487 </span>            :      * to check the _INCOMING flag
<span class="lineNum">     488 </span>            :      */
<span class="lineNum">     489 </span>            :     TEXT_TRAILING_ARABICCHAR     = 0x0100,
<span class="lineNum">     490 </span>            :     /**
<span class="lineNum">     491 </span>            :      * When set, the previous character for this textrun was an Arabic
<span class="lineNum">     492 </span>            :      * character.  This is used for the context detection necessary for
<span class="lineNum">     493 </span>            :      * bidi.numeral implementation.
<span class="lineNum">     494 </span>            :      */
<span class="lineNum">     495 </span>            :     TEXT_INCOMING_ARABICCHAR     = 0x0200,
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :     /**
<span class="lineNum">     498 </span>            :      * Set if the textrun should use the OpenType 'math' script.
<span class="lineNum">     499 </span>            :      */
<span class="lineNum">     500 </span>            :     TEXT_USE_MATH_SCRIPT         = 0x0400,
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :     /*
<span class="lineNum">     503 </span>            :      * Bit 0x0800 is currently unused.
<span class="lineNum">     504 </span>            :      */
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     /**
<span class="lineNum">     507 </span>            :      * Field for orientation of the textrun and glyphs within it.
<span class="lineNum">     508 </span>            :      * Possible values of the TEXT_ORIENT_MASK field:
<span class="lineNum">     509 </span>            :      *   TEXT_ORIENT_HORIZONTAL
<span class="lineNum">     510 </span>            :      *   TEXT_ORIENT_VERTICAL_UPRIGHT
<span class="lineNum">     511 </span>            :      *   TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT
<span class="lineNum">     512 </span>            :      *   TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT
<span class="lineNum">     513 </span>            :      *   TEXT_ORIENT_VERTICAL_MIXED
<span class="lineNum">     514 </span>            :      * For all VERTICAL settings, the x and y coordinates of glyph
<span class="lineNum">     515 </span>            :      * positions are exchanged, so that simple advances are vertical.
<span class="lineNum">     516 </span>            :      *
<span class="lineNum">     517 </span>            :      * The MIXED value indicates vertical textRuns for which the CSS
<span class="lineNum">     518 </span>            :      * text-orientation property is 'mixed', but is never used for
<span class="lineNum">     519 </span>            :      * individual glyphRuns; it will be resolved to either UPRIGHT
<span class="lineNum">     520 </span>            :      * or SIDEWAYS_RIGHT according to the UTR50 properties of the
<span class="lineNum">     521 </span>            :      * characters, and separate glyphRuns created for the resulting
<span class="lineNum">     522 </span>            :      * glyph orientations.
<span class="lineNum">     523 </span>            :      */
<span class="lineNum">     524 </span>            :     TEXT_ORIENT_MASK                    = 0x7000,
<span class="lineNum">     525 </span>            :     TEXT_ORIENT_HORIZONTAL              = 0x0000,
<span class="lineNum">     526 </span>            :     TEXT_ORIENT_VERTICAL_UPRIGHT        = 0x1000,
<span class="lineNum">     527 </span>            :     TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT = 0x2000,
<span class="lineNum">     528 </span>            :     TEXT_ORIENT_VERTICAL_MIXED          = 0x3000,
<span class="lineNum">     529 </span>            :     TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT  = 0x4000,
<a name="530"><span class="lineNum">     530 </span>            : };</a>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineCov">       2239 : MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(ShapedTextFlags)</span>
<span class="lineNum">     533 </span>            : } // namespace gfx
<a name="534"><span class="lineNum">     534 </span>            : } // namespace mozilla</a>
<span class="lineNum">     535 </span>            : 
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">          6 : class gfxTextRunFactory {</span></a>
<span class="lineNum">     537 </span>            :     // Used by stylo
<span class="lineNum">     538 </span><span class="lineCov">        161 :     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(gfxTextRunFactory)</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : public:
<span class="lineNum">     541 </span>            :     typedef mozilla::gfx::DrawTarget DrawTarget;
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :     /**
<span class="lineNum">     544 </span>            :      * This record contains all the parameters needed to initialize a textrun.
<span class="lineNum">     545 </span>            :      */
<span class="lineNum">     546 </span>            :     struct Parameters {
<span class="lineNum">     547 </span>            :         // Shape text params suggesting where the textrun will be rendered
<span class="lineNum">     548 </span>            :         DrawTarget   *mDrawTarget;
<span class="lineNum">     549 </span>            :         // Pointer to arbitrary user data (which should outlive the textrun)
<span class="lineNum">     550 </span>            :         void         *mUserData;
<span class="lineNum">     551 </span>            :         // A description of which characters have been stripped from the original
<span class="lineNum">     552 </span>            :         // DOM string to produce the characters in the textrun. May be null
<span class="lineNum">     553 </span>            :         // if that information is not relevant.
<span class="lineNum">     554 </span>            :         gfxSkipChars *mSkipChars;
<span class="lineNum">     555 </span>            :         // A list of where linebreaks are currently placed in the textrun. May
<span class="lineNum">     556 </span>            :         // be null if mInitialBreakCount is zero.
<span class="lineNum">     557 </span>            :         uint32_t     *mInitialBreaks;
<span class="lineNum">     558 </span>            :         uint32_t      mInitialBreakCount;
<span class="lineNum">     559 </span>            :         // The ratio to use to convert device pixels to application layout units
<span class="lineNum">     560 </span>            :         int32_t       mAppUnitsPerDevUnit;
<span class="lineNum">     561 </span>            :     };
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : protected:
<span class="lineNum">     564 </span>            :     // Protected destructor, to discourage deletion outside of Release():
<span class="lineNum">     565 </span>            :     virtual ~gfxTextRunFactory();
<a name="566"><span class="lineNum">     566 </span>            : };</a>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineCov">        213 : struct gfxTextRange {</span>
<span class="lineNum">     569 </span>            :     enum {
<span class="lineNum">     570 </span>            :         // flags for recording the kind of font-matching that was used
<span class="lineNum">     571 </span>            :         kFontGroup      = 0x0001,
<span class="lineNum">     572 </span>            :         kPrefsFallback  = 0x0002,
<a name="573"><span class="lineNum">     573 </span>            :         kSystemFallback = 0x0004</a>
<span class="lineNum">     574 </span>            :     };
<span class="lineNum">     575 </span><span class="lineCov">         71 :     gfxTextRange(uint32_t aStart, uint32_t aEnd,</span>
<span class="lineNum">     576 </span>            :                  gfxFont* aFont, uint8_t aMatchType,
<span class="lineNum">     577 </span>            :                  mozilla::gfx::ShapedTextFlags aOrientation)
<span class="lineNum">     578 </span><span class="lineCov">         71 :         : start(aStart),</span>
<span class="lineNum">     579 </span>            :           end(aEnd),
<span class="lineNum">     580 </span>            :           font(aFont),
<span class="lineNum">     581 </span>            :           matchType(aMatchType),
<a name="582"><span class="lineNum">     582 </span><span class="lineCov">         71 :           orientation(aOrientation)</span></a>
<span class="lineNum">     583 </span><span class="lineCov">         71 :     { }</span>
<span class="lineNum">     584 </span><span class="lineCov">         71 :     uint32_t Length() const { return end - start; }</span>
<span class="lineNum">     585 </span>            :     uint32_t start, end;
<span class="lineNum">     586 </span>            :     RefPtr&lt;gfxFont&gt; font;
<span class="lineNum">     587 </span>            :     uint8_t matchType;
<span class="lineNum">     588 </span>            :     mozilla::gfx::ShapedTextFlags orientation;
<span class="lineNum">     589 </span>            : };
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /**
<span class="lineNum">     592 </span>            :  * gfxFontShaper
<span class="lineNum">     593 </span>            :  *
<span class="lineNum">     594 </span>            :  * This class implements text shaping (character to glyph mapping and
<span class="lineNum">     595 </span>            :  * glyph layout). There is a gfxFontShaper subclass for each text layout
<span class="lineNum">     596 </span>            :  * technology (uniscribe, core text, harfbuzz,....) we support.
<span class="lineNum">     597 </span>            :  *
<span class="lineNum">     598 </span>            :  * The shaper is responsible for setting up glyph data in gfxTextRuns.
<span class="lineNum">     599 </span>            :  *
<span class="lineNum">     600 </span>            :  * A generic, platform-independent shaper relies only on the standard
<span class="lineNum">     601 </span>            :  * gfxFont interface and can work with any concrete subclass of gfxFont.
<span class="lineNum">     602 </span>            :  *
<span class="lineNum">     603 </span>            :  * Platform-specific implementations designed to interface to platform
<span class="lineNum">     604 </span>            :  * shaping APIs such as Uniscribe or CoreText may rely on features of a
<span class="lineNum">     605 </span>            :  * specific font subclass to access native font references
<span class="lineNum">     606 </span>            :  * (such as CTFont, HFONT, DWriteFont, etc).
<span class="lineNum">     607 </span>            :  */
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : class gfxFontShaper {
<span class="lineNum">     610 </span>            : public:
<span class="lineNum">     611 </span>            :     typedef mozilla::gfx::DrawTarget DrawTarget;
<span class="lineNum">     612 </span>            :     typedef mozilla::unicode::Script Script;
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :     enum class RoundingFlags : uint8_t {
<span class="lineNum">     615 </span>            :         kRoundX = 0x01,
<span class="lineNum">     616 </span>            :         kRoundY = 0x02
<a name="617"><span class="lineNum">     617 </span>            :     };</a>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">          2 :     explicit gfxFontShaper(gfxFont *aFont)</span>
<span class="lineNum">     620 </span><span class="lineCov">          2 :         : mFont(aFont)</span>
<span class="lineNum">     621 </span>            :     {
<span class="lineNum">     622 </span><span class="lineCov">          2 :         NS_ASSERTION(aFont, &quot;shaper requires a valid font!&quot;);</span>
<a name="623"><span class="lineNum">     623 </span><span class="lineCov">          2 :     }</span></a>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     virtual ~gfxFontShaper() { }</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :     // Shape a piece of text and store the resulting glyph data into
<span class="lineNum">     628 </span>            :     // aShapedText. Parameters aOffset/aLength indicate the range of
<span class="lineNum">     629 </span>            :     // aShapedText to be updated; aLength is also the length of aText.
<span class="lineNum">     630 </span>            :     virtual bool ShapeText(DrawTarget     *aDrawTarget,
<span class="lineNum">     631 </span>            :                            const char16_t *aText,
<span class="lineNum">     632 </span>            :                            uint32_t        aOffset,
<span class="lineNum">     633 </span>            :                            uint32_t        aLength,
<span class="lineNum">     634 </span>            :                            Script          aScript,
<span class="lineNum">     635 </span>            :                            bool            aVertical,
<span class="lineNum">     636 </span>            :                            RoundingFlags   aRounding,
<a name="637"><span class="lineNum">     637 </span>            :                            gfxShapedText  *aShapedText) = 0;</a>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineCov">        265 :     gfxFont *GetFont() const { return mFont; }</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :     static void
<span class="lineNum">     642 </span>            :     MergeFontFeatures(const gfxFontStyle *aStyle,
<span class="lineNum">     643 </span>            :                       const nsTArray&lt;gfxFontFeature&gt;&amp; aFontFeatures,
<span class="lineNum">     644 </span>            :                       bool aDisableLigatures,
<span class="lineNum">     645 </span>            :                       const nsAString&amp; aFamilyName,
<span class="lineNum">     646 </span>            :                       bool aAddSmallCaps,
<span class="lineNum">     647 </span>            :                       void (*aHandleFeature)(const uint32_t&amp;,
<span class="lineNum">     648 </span>            :                                              uint32_t&amp;, void*),
<span class="lineNum">     649 </span>            :                       void* aHandleFeatureData);
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : protected:
<span class="lineNum">     652 </span>            :     // the font this shaper is working with. The font owns a UniquePtr reference
<span class="lineNum">     653 </span>            :     // to this object, and will destroy it before it dies. Thus, mFont will always
<span class="lineNum">     654 </span>            :     // be valid.
<span class="lineNum">     655 </span>            :     gfxFont* MOZ_NON_OWNING_REF mFont;
<a name="656"><span class="lineNum">     656 </span>            : };</a>
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineCov">        352 : MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(gfxFontShaper::RoundingFlags)</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : /*
<span class="lineNum">     661 </span>            :  * gfxShapedText is an abstract superclass for gfxShapedWord and gfxTextRun.
<span class="lineNum">     662 </span>            :  * These are objects that store a list of zero or more glyphs for each character.
<span class="lineNum">     663 </span>            :  * For each glyph we store the glyph ID, the advance, and possibly x/y-offsets.
<span class="lineNum">     664 </span>            :  * The idea is that a string is rendered by a loop that draws each glyph
<span class="lineNum">     665 </span>            :  * at its designated offset from the current point, then advances the current
<span class="lineNum">     666 </span>            :  * point by the glyph's advance in the direction of the textrun (LTR or RTL).
<span class="lineNum">     667 </span>            :  * Each glyph advance is always rounded to the nearest appunit; this ensures
<span class="lineNum">     668 </span>            :  * consistent results when dividing the text in a textrun into multiple text
<span class="lineNum">     669 </span>            :  * frames (frame boundaries are always aligned to appunits). We optimize
<span class="lineNum">     670 </span>            :  * for the case where a character has a single glyph and zero xoffset and yoffset,
<span class="lineNum">     671 </span>            :  * and the glyph ID and advance are in a reasonable range so we can pack all
<span class="lineNum">     672 </span>            :  * necessary data into 32 bits.
<span class="lineNum">     673 </span>            :  *
<span class="lineNum">     674 </span>            :  * gfxFontShaper can shape text into either a gfxShapedWord (cached by a gfxFont)
<span class="lineNum">     675 </span>            :  * or directly into a gfxTextRun (for cases where we want to shape textruns in
<span class="lineNum">     676 </span>            :  * their entirety rather than using cached words, because there may be layout
<span class="lineNum">     677 </span>            :  * features that depend on the inter-word spaces).
<span class="lineNum">     678 </span>            :  */
<span class="lineNum">     679 </span>            : class gfxShapedText
<span class="lineNum">     680 </span>            : {
<span class="lineNum">     681 </span>            : public:
<a name="682"><span class="lineNum">     682 </span>            :     typedef mozilla::unicode::Script Script;</a>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">        115 :     gfxShapedText(uint32_t aLength, mozilla::gfx::ShapedTextFlags aFlags,</span>
<span class="lineNum">     685 </span>            :                   int32_t aAppUnitsPerDevUnit)
<span class="lineNum">     686 </span><span class="lineCov">        115 :         : mLength(aLength)</span>
<span class="lineNum">     687 </span>            :         , mFlags(aFlags)
<span class="lineNum">     688 </span><span class="lineCov">        115 :         , mAppUnitsPerDevUnit(aAppUnitsPerDevUnit)</span>
<a name="689"><span class="lineNum">     689 </span><span class="lineCov">        115 :     { }</span></a>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineCov">         71 :     virtual ~gfxShapedText() { }</span>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :     /**
<span class="lineNum">     694 </span>            :      * This class records the information associated with a character in the
<span class="lineNum">     695 </span>            :      * input string. It's optimized for the case where there is one glyph
<span class="lineNum">     696 </span>            :      * representing that character alone.
<span class="lineNum">     697 </span>            :      * 
<span class="lineNum">     698 </span>            :      * A character can have zero or more associated glyphs. Each glyph
<span class="lineNum">     699 </span>            :      * has an advance width and an x and y offset.
<span class="lineNum">     700 </span>            :      * A character may be the start of a cluster.
<span class="lineNum">     701 </span>            :      * A character may be the start of a ligature group.
<span class="lineNum">     702 </span>            :      * A character can be &quot;missing&quot;, indicating that the system is unable
<span class="lineNum">     703 </span>            :      * to render the character.
<span class="lineNum">     704 </span>            :      * 
<span class="lineNum">     705 </span>            :      * All characters in a ligature group conceptually share all the glyphs
<span class="lineNum">     706 </span>            :      * associated with the characters in a group.
<span class="lineNum">     707 </span>            :      */
<a name="708"><span class="lineNum">     708 </span>            :     class CompressedGlyph {</a>
<span class="lineNum">     709 </span>            :     public:
<span class="lineNum">     710 </span><span class="lineCov">         92 :         CompressedGlyph() { mValue = 0; }</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :         enum {
<span class="lineNum">     713 </span>            :             // Indicates that a cluster and ligature group starts at this
<span class="lineNum">     714 </span>            :             // character; this character has a single glyph with a reasonable
<span class="lineNum">     715 </span>            :             // advance and zero offsets. A &quot;reasonable&quot; advance
<span class="lineNum">     716 </span>            :             // is one that fits in the available bits (currently 12) (specified
<span class="lineNum">     717 </span>            :             // in appunits).
<span class="lineNum">     718 </span>            :             FLAG_IS_SIMPLE_GLYPH  = 0x80000000U,
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :             // Indicates whether a linebreak is allowed before this character;
<span class="lineNum">     721 </span>            :             // this is a two-bit field that holds a FLAG_BREAK_TYPE_xxx value
<span class="lineNum">     722 </span>            :             // indicating the kind of linebreak (if any) allowed here.
<span class="lineNum">     723 </span>            :             FLAGS_CAN_BREAK_BEFORE = 0x60000000U,
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :             FLAGS_CAN_BREAK_SHIFT = 29,
<span class="lineNum">     726 </span>            :             FLAG_BREAK_TYPE_NONE   = 0,
<span class="lineNum">     727 </span>            :             FLAG_BREAK_TYPE_NORMAL = 1,
<span class="lineNum">     728 </span>            :             FLAG_BREAK_TYPE_HYPHEN = 2,
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :             FLAG_CHAR_IS_SPACE     = 0x10000000U,
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :             // The advance is stored in appunits
<span class="lineNum">     733 </span>            :             ADVANCE_MASK  = 0x0FFF0000U,
<span class="lineNum">     734 </span>            :             ADVANCE_SHIFT = 16,
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :             GLYPH_MASK = 0x0000FFFFU,
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :             // Non-simple glyphs may or may not have glyph data in the
<span class="lineNum">     739 </span>            :             // corresponding mDetailedGlyphs entry. They have the following
<span class="lineNum">     740 </span>            :             // flag bits:
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :             // When NOT set, indicates that this character corresponds to a
<span class="lineNum">     743 </span>            :             // missing glyph and should be skipped (or possibly, render the character
<span class="lineNum">     744 </span>            :             // Unicode value in some special way). If there are glyphs,
<span class="lineNum">     745 </span>            :             // the mGlyphID is actually the UTF16 character code. The bit is
<span class="lineNum">     746 </span>            :             // inverted so we can memset the array to zero to indicate all missing.
<span class="lineNum">     747 </span>            :             FLAG_NOT_MISSING              = 0x01,
<span class="lineNum">     748 </span>            :             FLAG_NOT_CLUSTER_START        = 0x02,
<span class="lineNum">     749 </span>            :             FLAG_NOT_LIGATURE_GROUP_START = 0x04,
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :             FLAG_CHAR_IS_TAB              = 0x08,
<span class="lineNum">     752 </span>            :             FLAG_CHAR_IS_NEWLINE          = 0x10,
<span class="lineNum">     753 </span>            :             // Per CSS Text Decoration Module Level 3, emphasis marks are not
<span class="lineNum">     754 </span>            :             // drawn for any character in Unicode categories Z*, Cc, Cf, and Cn
<span class="lineNum">     755 </span>            :             // which is not combined with any combining characters. This flag is
<span class="lineNum">     756 </span>            :             // set for all those characters except 0x20 whitespace.
<span class="lineNum">     757 </span>            :             FLAG_CHAR_NO_EMPHASIS_MARK    = 0x20,
<span class="lineNum">     758 </span>            :             CHAR_TYPE_FLAGS_MASK          = 0x38,
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :             GLYPH_COUNT_MASK = 0x00FFFF00U,
<span class="lineNum">     761 </span>            :             GLYPH_COUNT_SHIFT = 8
<span class="lineNum">     762 </span>            :         };
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :         // &quot;Simple glyphs&quot; have a simple glyph ID, simple advance and their
<span class="lineNum">     765 </span>            :         // x and y offsets are zero. Also the glyph extents do not overflow
<span class="lineNum">     766 </span>            :         // the font-box defined by the font ascent, descent and glyph advance width.
<span class="lineNum">     767 </span>            :         // These case is optimized to avoid storing DetailedGlyphs.
<a name="768"><span class="lineNum">     768 </span>            : </a>
<span class="lineNum">     769 </span>            :         // Returns true if the glyph ID aGlyph fits into the compressed representation
<span class="lineNum">     770 </span><span class="lineCov">        646 :         static bool IsSimpleGlyphID(uint32_t aGlyph) {</span>
<span class="lineNum">     771 </span><span class="lineCov">        646 :             return (aGlyph &amp; GLYPH_MASK) == aGlyph;</span>
<span class="lineNum">     772 </span>            :         }
<a name="773"><span class="lineNum">     773 </span>            :         // Returns true if the advance aAdvance fits into the compressed representation.</a>
<span class="lineNum">     774 </span>            :         // aAdvance is in appunits.
<span class="lineNum">     775 </span><span class="lineCov">        646 :         static bool IsSimpleAdvance(uint32_t aAdvance) {</span>
<span class="lineNum">     776 </span><span class="lineCov">        646 :             return (aAdvance &amp; (ADVANCE_MASK &gt;&gt; ADVANCE_SHIFT)) == aAdvance;</span>
<a name="777"><span class="lineNum">     777 </span>            :         }</a>
<a name="778"><span class="lineNum">     778 </span>            : </a>
<a name="779"><span class="lineNum">     779 </span><span class="lineCov">       3229 :         bool IsSimpleGlyph() const { return (mValue &amp; FLAG_IS_SIMPLE_GLYPH) != 0; }</span></a>
<span class="lineNum">     780 </span><span class="lineCov">       2224 :         uint32_t GetSimpleAdvance() const { return (mValue &amp; ADVANCE_MASK) &gt;&gt; ADVANCE_SHIFT; }</span>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">       1262 :         uint32_t GetSimpleGlyph() const { return mValue &amp; GLYPH_MASK; }</span></a>
<a name="782"><span class="lineNum">     782 </span>            : </a>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         bool IsMissing() const { return (mValue &amp; (FLAG_NOT_MISSING|FLAG_IS_SIMPLE_GLYPH)) == 0; }</span>
<span class="lineNum">     784 </span><span class="lineCov">        271 :         bool IsClusterStart() const {</span>
<a name="785"><span class="lineNum">     785 </span><span class="lineCov">        271 :             return (mValue &amp; FLAG_IS_SIMPLE_GLYPH) || !(mValue &amp; FLAG_NOT_CLUSTER_START);</span></a>
<span class="lineNum">     786 </span>            :         }
<span class="lineNum">     787 </span><span class="lineCov">        143 :         bool IsLigatureGroupStart() const {</span>
<a name="788"><span class="lineNum">     788 </span><span class="lineCov">        143 :             return (mValue &amp; FLAG_IS_SIMPLE_GLYPH) || !(mValue &amp; FLAG_NOT_LIGATURE_GROUP_START);</span></a>
<span class="lineNum">     789 </span>            :         }
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         bool IsLigatureContinuation() const {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :             return (mValue &amp; FLAG_IS_SIMPLE_GLYPH) == 0 &amp;&amp;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :                 (mValue &amp; (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING)) ==</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                     (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING);</span>
<span class="lineNum">     794 </span>            :         }
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :         // Return true if the original character was a normal (breakable,
<a name="797"><span class="lineNum">     797 </span>            :         // trimmable) space (U+0020). Not true for other characters that</a>
<span class="lineNum">     798 </span>            :         // may happen to map to the space glyph (U+00A0).
<span class="lineNum">     799 </span><span class="lineCov">        105 :         bool CharIsSpace() const {</span>
<span class="lineNum">     800 </span><span class="lineCov">        105 :             return (mValue &amp; FLAG_CHAR_IS_SPACE) != 0;</span>
<a name="801"><span class="lineNum">     801 </span>            :         }</a>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineCov">        208 :         bool CharIsTab() const {</span>
<a name="804"><span class="lineNum">     804 </span><span class="lineCov">        208 :             return !IsSimpleGlyph() &amp;&amp; (mValue &amp; FLAG_CHAR_IS_TAB) != 0;</span></a>
<span class="lineNum">     805 </span>            :         }
<span class="lineNum">     806 </span><span class="lineCov">        208 :         bool CharIsNewline() const {</span>
<a name="807"><span class="lineNum">     807 </span><span class="lineCov">        208 :             return !IsSimpleGlyph() &amp;&amp; (mValue &amp; FLAG_CHAR_IS_NEWLINE) != 0;</span></a>
<span class="lineNum">     808 </span>            :         }
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         bool CharMayHaveEmphasisMark() const {</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :             return !CharIsSpace() &amp;&amp;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                 (IsSimpleGlyph() || !(mValue &amp; FLAG_CHAR_NO_EMPHASIS_MARK));</span>
<a name="812"><span class="lineNum">     812 </span>            :         }</a>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineCov">        325 :         uint32_t CharTypeFlags() const {</span>
<span class="lineNum">     815 </span><span class="lineCov">        325 :             return IsSimpleGlyph() ? 0 : (mValue &amp; CHAR_TYPE_FLAGS_MASK);</span>
<a name="816"><span class="lineNum">     816 </span>            :         }</a>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         void SetClusterStart(bool aIsClusterStart) {</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :             NS_ASSERTION(!IsSimpleGlyph(),</span>
<span class="lineNum">     820 </span>            :                          &quot;can't call SetClusterStart on simple glyphs&quot;);
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :             if (aIsClusterStart) {</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :                 mValue &amp;= ~FLAG_NOT_CLUSTER_START;</span>
<span class="lineNum">     823 </span>            :             } else {
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                 mValue |= FLAG_NOT_CLUSTER_START;</span>
<span class="lineNum">     825 </span>            :             }
<a name="826"><span class="lineNum">     826 </span><span class="lineNoCov">          0 :         }</span></a>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineCov">        569 :         uint8_t CanBreakBefore() const {</span>
<span class="lineNum">     829 </span><span class="lineCov">        569 :             return (mValue &amp; FLAGS_CAN_BREAK_BEFORE) &gt;&gt; FLAGS_CAN_BREAK_SHIFT;</span>
<a name="830"><span class="lineNum">     830 </span>            :         }</a>
<span class="lineNum">     831 </span>            :         // Returns FLAGS_CAN_BREAK_BEFORE if the setting changed, 0 otherwise
<span class="lineNum">     832 </span><span class="lineCov">        154 :         uint32_t SetCanBreakBefore(uint8_t aCanBreakBefore) {</span>
<span class="lineNum">     833 </span><span class="lineCov">        154 :             NS_ASSERTION(aCanBreakBefore &lt;= 2,</span>
<span class="lineNum">     834 </span>            :                          &quot;Bogus break-before value!&quot;);
<span class="lineNum">     835 </span><span class="lineCov">        154 :             uint32_t breakMask = (uint32_t(aCanBreakBefore) &lt;&lt; FLAGS_CAN_BREAK_SHIFT);</span>
<span class="lineNum">     836 </span><span class="lineCov">        154 :             uint32_t toggle = breakMask ^ (mValue &amp; FLAGS_CAN_BREAK_BEFORE);</span>
<span class="lineNum">     837 </span><span class="lineCov">        154 :             mValue ^= toggle;</span>
<span class="lineNum">     838 </span><span class="lineCov">        154 :             return toggle;</span>
<a name="839"><span class="lineNum">     839 </span>            :         }</a>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">        323 :         CompressedGlyph&amp; SetSimpleGlyph(uint32_t aAdvanceAppUnits, uint32_t aGlyph) {</span>
<span class="lineNum">     842 </span><span class="lineCov">        323 :             NS_ASSERTION(IsSimpleAdvance(aAdvanceAppUnits), &quot;Advance overflow&quot;);</span>
<span class="lineNum">     843 </span><span class="lineCov">        323 :             NS_ASSERTION(IsSimpleGlyphID(aGlyph), &quot;Glyph overflow&quot;);</span>
<span class="lineNum">     844 </span><span class="lineCov">        323 :             NS_ASSERTION(!CharTypeFlags(), &quot;Char type flags lost&quot;);</span>
<span class="lineNum">     845 </span><span class="lineCov">        646 :             mValue = (mValue &amp; (FLAGS_CAN_BREAK_BEFORE | FLAG_CHAR_IS_SPACE)) |</span>
<span class="lineNum">     846 </span><span class="lineCov">        323 :                 FLAG_IS_SIMPLE_GLYPH |</span>
<span class="lineNum">     847 </span><span class="lineCov">        646 :                 (aAdvanceAppUnits &lt;&lt; ADVANCE_SHIFT) | aGlyph;</span>
<a name="848"><span class="lineNum">     848 </span><span class="lineCov">        323 :             return *this;</span></a>
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span><span class="lineCov">          2 :         CompressedGlyph&amp; SetComplex(bool aClusterStart, bool aLigatureStart,</span>
<span class="lineNum">     851 </span>            :                 uint32_t aGlyphCount) {
<span class="lineNum">     852 </span><span class="lineCov">          4 :             mValue = (mValue &amp; (FLAGS_CAN_BREAK_BEFORE | FLAG_CHAR_IS_SPACE)) |</span>
<span class="lineNum">     853 </span><span class="lineCov">          2 :                 FLAG_NOT_MISSING |</span>
<span class="lineNum">     854 </span><span class="lineCov">          4 :                 CharTypeFlags() |</span>
<span class="lineNum">     855 </span><span class="lineCov">          2 :                 (aClusterStart ? 0 : FLAG_NOT_CLUSTER_START) |</span>
<span class="lineNum">     856 </span><span class="lineCov">          2 :                 (aLigatureStart ? 0 : FLAG_NOT_LIGATURE_GROUP_START) |</span>
<span class="lineNum">     857 </span><span class="lineCov">          2 :                 (aGlyphCount &lt;&lt; GLYPH_COUNT_SHIFT);</span>
<span class="lineNum">     858 </span><span class="lineCov">          2 :             return *this;</span>
<span class="lineNum">     859 </span>            :         }
<span class="lineNum">     860 </span>            :         /**
<span class="lineNum">     861 </span>            :          * Missing glyphs are treated as ligature group starts; don't mess with
<a name="862"><span class="lineNum">     862 </span>            :          * the cluster-start flag (see bugs 618870 and 619286).</a>
<span class="lineNum">     863 </span>            :          */
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         CompressedGlyph&amp; SetMissing(uint32_t aGlyphCount) {</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :             mValue = (mValue &amp; (FLAGS_CAN_BREAK_BEFORE | FLAG_NOT_CLUSTER_START |</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                                 FLAG_CHAR_IS_SPACE)) |</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :                 CharTypeFlags() |</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :                 (aGlyphCount &lt;&lt; GLYPH_COUNT_SHIFT);</span>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :             return *this;</span></a>
<span class="lineNum">     870 </span>            :         }
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :         uint32_t GetGlyphCount() const {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :             NS_ASSERTION(!IsSimpleGlyph(), &quot;Expected non-simple-glyph&quot;);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :             return (mValue &amp; GLYPH_COUNT_MASK) &gt;&gt; GLYPH_COUNT_SHIFT;</span>
<a name="874"><span class="lineNum">     874 </span>            :         }</a>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineCov">         58 :         void SetIsSpace() {</span>
<a name="877"><span class="lineNum">     877 </span><span class="lineCov">         58 :             mValue |= FLAG_CHAR_IS_SPACE;</span></a>
<span class="lineNum">     878 </span><span class="lineCov">         58 :         }</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         void SetIsTab() {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :             NS_ASSERTION(!IsSimpleGlyph(), &quot;Expected non-simple-glyph&quot;);</span>
<a name="881"><span class="lineNum">     881 </span><span class="lineNoCov">          0 :             mValue |= FLAG_CHAR_IS_TAB;</span></a>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :         void SetIsNewline() {</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :             NS_ASSERTION(!IsSimpleGlyph(), &quot;Expected non-simple-glyph&quot;);</span>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 :             mValue |= FLAG_CHAR_IS_NEWLINE;</span></a>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         void SetNoEmphasisMark() {</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :             NS_ASSERTION(!IsSimpleGlyph(), &quot;Expected non-simple-glyph&quot;);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :             mValue |= FLAG_CHAR_NO_EMPHASIS_MARK;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :     private:
<span class="lineNum">     893 </span>            :         uint32_t mValue;
<span class="lineNum">     894 </span>            :     };
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :     // Accessor for the array of CompressedGlyph records, which will be in
<span class="lineNum">     897 </span>            :     // a different place in gfxShapedWord vs gfxTextRun
<span class="lineNum">     898 </span>            :     virtual const CompressedGlyph *GetCharacterGlyphs() const = 0;
<span class="lineNum">     899 </span>            :     virtual CompressedGlyph *GetCharacterGlyphs() = 0;
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :     /**
<span class="lineNum">     902 </span>            :      * When the glyphs for a character don't fit into a CompressedGlyph record
<span class="lineNum">     903 </span>            :      * in SimpleGlyph format, we use an array of DetailedGlyphs instead.
<span class="lineNum">     904 </span>            :      */
<span class="lineNum">     905 </span>            :     struct DetailedGlyph {
<span class="lineNum">     906 </span>            :         /** The glyphID, or the Unicode character
<span class="lineNum">     907 </span>            :          * if this is a missing glyph */
<span class="lineNum">     908 </span>            :         uint32_t mGlyphID;
<span class="lineNum">     909 </span>            :         /** The advance, x-offset and y-offset of the glyph, in appunits
<span class="lineNum">     910 </span>            :          *  mAdvance is in the text direction (RTL or LTR)
<span class="lineNum">     911 </span>            :          *  mXOffset is always from left to right
<span class="lineNum">     912 </span>            :          *  mYOffset is always from top to bottom */   
<span class="lineNum">     913 </span>            :         int32_t  mAdvance;
<span class="lineNum">     914 </span>            :         float    mXOffset, mYOffset;
<span class="lineNum">     915 </span>            :     };
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     void SetGlyphs(uint32_t aCharIndex, CompressedGlyph aGlyph,
<span class="lineNum">     918 </span>            :                    const DetailedGlyph *aGlyphs);
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :     void SetMissingGlyph(uint32_t aIndex, uint32_t aChar, gfxFont *aFont);
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :     void SetIsSpace(uint32_t aIndex) {
<span class="lineNum">     923 </span>            :         GetCharacterGlyphs()[aIndex].SetIsSpace();
<a name="924"><span class="lineNum">     924 </span>            :     }</a>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineCov">        146 :     bool HasDetailedGlyphs() const {</span>
<span class="lineNum">     927 </span><span class="lineCov">        146 :         return mDetailedGlyphs != nullptr;</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     bool IsLigatureGroupStart(uint32_t aPos) {
<span class="lineNum">     931 </span>            :         NS_ASSERTION(aPos &lt; GetLength(), &quot;aPos out of range&quot;);
<span class="lineNum">     932 </span>            :         return GetCharacterGlyphs()[aPos].IsLigatureGroupStart();
<span class="lineNum">     933 </span>            :     }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :     // NOTE that this must not be called for a character offset that does
<a name="936"><span class="lineNum">     936 </span>            :     // not have any DetailedGlyph records; callers must have verified that</a>
<span class="lineNum">     937 </span>            :     // GetCharacterGlyphs()[aCharIndex].GetGlyphCount() is greater than zero.
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     DetailedGlyph *GetDetailedGlyphs(uint32_t aCharIndex) const {</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         NS_ASSERTION(GetCharacterGlyphs() &amp;&amp; HasDetailedGlyphs() &amp;&amp;</span>
<span class="lineNum">     940 </span>            :                      !GetCharacterGlyphs()[aCharIndex].IsSimpleGlyph() &amp;&amp;
<span class="lineNum">     941 </span>            :                      GetCharacterGlyphs()[aCharIndex].GetGlyphCount() &gt; 0,
<span class="lineNum">     942 </span>            :                      &quot;invalid use of GetDetailedGlyphs; check the caller!&quot;);
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         return mDetailedGlyphs-&gt;Get(aCharIndex);</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :     void AdjustAdvancesForSyntheticBold(float aSynBoldOffset,
<span class="lineNum">     947 </span>            :                                         uint32_t aOffset, uint32_t aLength);
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            :     // Mark clusters in the CompressedGlyph records, starting at aOffset,
<span class="lineNum">     950 </span>            :     // based on the Unicode properties of the text in aString.
<span class="lineNum">     951 </span>            :     // This is also responsible to set the IsSpace flag for space characters.
<span class="lineNum">     952 </span>            :     void SetupClusterBoundaries(uint32_t         aOffset,
<span class="lineNum">     953 </span>            :                                 const char16_t *aString,
<span class="lineNum">     954 </span>            :                                 uint32_t         aLength);
<span class="lineNum">     955 </span>            :     // In 8-bit text, there won't actually be any clusters, but we still need
<span class="lineNum">     956 </span>            :     // the space-marking functionality.
<span class="lineNum">     957 </span>            :     void SetupClusterBoundaries(uint32_t       aOffset,
<span class="lineNum">     958 </span>            :                                 const uint8_t *aString,
<a name="959"><span class="lineNum">     959 </span>            :                                 uint32_t       aLength);</a>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineCov">       1071 :     mozilla::gfx::ShapedTextFlags GetFlags() const {</span>
<span class="lineNum">     962 </span><span class="lineCov">       1071 :         return mFlags;</span>
<a name="963"><span class="lineNum">     963 </span>            :     }</a>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineCov">         88 :     bool IsVertical() const {</span>
<span class="lineNum">     966 </span><span class="lineCov">        176 :         return (GetFlags() &amp; mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_MASK) !=</span>
<span class="lineNum">     967 </span><span class="lineCov">        176 :                 mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_HORIZONTAL;</span>
<a name="968"><span class="lineNum">     968 </span>            :     }</a>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">         48 :     bool UseCenterBaseline() const {</span>
<span class="lineNum">     971 </span>            :         mozilla::gfx::ShapedTextFlags orient =
<span class="lineNum">     972 </span><span class="lineCov">         48 :             GetFlags() &amp; mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_MASK;</span>
<span class="lineNum">     973 </span><span class="lineCov">         48 :         return orient == mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_VERTICAL_MIXED ||</span>
<span class="lineNum">     974 </span><span class="lineCov">         48 :                orient == mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_VERTICAL_UPRIGHT;</span>
<a name="975"><span class="lineNum">     975 </span>            :     }</a>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">        235 :     bool IsRightToLeft() const {</span>
<span class="lineNum">     978 </span><span class="lineCov">        470 :         return (GetFlags() &amp; mozilla::gfx::ShapedTextFlags::TEXT_IS_RTL) ==</span>
<span class="lineNum">     979 </span><span class="lineCov">        470 :                mozilla::gfx::ShapedTextFlags::TEXT_IS_RTL;</span>
<a name="980"><span class="lineNum">     980 </span>            :     }</a>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span><span class="lineCov">         84 :     bool IsSidewaysLeft() const {</span>
<span class="lineNum">     983 </span><span class="lineCov">        168 :         return (GetFlags() &amp; mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_MASK) ==</span>
<span class="lineNum">     984 </span><span class="lineCov">        168 :                mozilla::gfx::ShapedTextFlags::TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT;</span>
<span class="lineNum">     985 </span>            :     }
<span class="lineNum">     986 </span>            : 
<a name="987"><span class="lineNum">     987 </span>            :     // Return true if the logical inline direction is reversed compared to</a>
<span class="lineNum">     988 </span>            :     // normal physical coordinates (i.e. if it is leftwards or upwards)
<span class="lineNum">     989 </span><span class="lineCov">         84 :     bool IsInlineReversed() const {</span>
<span class="lineNum">     990 </span><span class="lineCov">         84 :         return IsSidewaysLeft() != IsRightToLeft();</span>
<a name="991"><span class="lineNum">     991 </span>            :     }</a>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">         66 :     gfxFloat GetDirection() const {</span>
<span class="lineNum">     994 </span><span class="lineCov">         66 :         return IsInlineReversed() ? -1.0f : 1.0f;</span>
<a name="995"><span class="lineNum">     995 </span>            :     }</a>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineCov">         34 :     bool DisableLigatures() const {</span>
<span class="lineNum">     998 </span><span class="lineCov">         68 :         return (GetFlags() &amp;</span>
<span class="lineNum">     999 </span><span class="lineCov">         68 :                 mozilla::gfx::ShapedTextFlags::TEXT_DISABLE_OPTIONAL_LIGATURES) ==</span>
<span class="lineNum">    1000 </span><span class="lineCov">         68 :                mozilla::gfx::ShapedTextFlags::TEXT_DISABLE_OPTIONAL_LIGATURES;</span>
<a name="1001"><span class="lineNum">    1001 </span>            :     }</a>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">        190 :     bool TextIs8Bit() const {</span>
<span class="lineNum">    1004 </span><span class="lineCov">        380 :         return (GetFlags() &amp; mozilla::gfx::ShapedTextFlags::TEXT_IS_8BIT) ==</span>
<span class="lineNum">    1005 </span><span class="lineCov">        380 :                mozilla::gfx::ShapedTextFlags::TEXT_IS_8BIT;</span>
<a name="1006"><span class="lineNum">    1006 </span>            :     }</a>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineCov">        329 :     int32_t GetAppUnitsPerDevUnit() const {</span>
<span class="lineNum">    1009 </span><span class="lineCov">        329 :         return mAppUnitsPerDevUnit;</span>
<a name="1010"><span class="lineNum">    1010 </span>            :     }</a>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineCov">       1747 :     uint32_t GetLength() const {</span>
<span class="lineNum">    1013 </span><span class="lineCov">       1747 :         return mLength;</span>
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            :     bool FilterIfIgnorable(uint32_t aIndex, uint32_t aCh);
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            : protected:
<span class="lineNum">    1019 </span>            :     // Allocate aCount DetailedGlyphs for the given index
<span class="lineNum">    1020 </span>            :     DetailedGlyph *AllocateDetailedGlyphs(uint32_t aCharIndex,
<span class="lineNum">    1021 </span>            :                                           uint32_t aCount);
<span class="lineNum">    1022 </span>            : 
<a name="1023"><span class="lineNum">    1023 </span>            :     // Ensure the glyph on the given index is complex glyph so that we can use</a>
<span class="lineNum">    1024 </span>            :     // it to record specific characters that layout may need to detect.
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     void EnsureComplexGlyph(uint32_t aIndex, CompressedGlyph&amp; aGlyph)</span>
<span class="lineNum">    1026 </span>            :     {
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(GetCharacterGlyphs() + aIndex == &amp;aGlyph);</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         if (aGlyph.IsSimpleGlyph()) {</span>
<span class="lineNum">    1029 </span>            :             DetailedGlyph details = {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                 aGlyph.GetSimpleGlyph(),</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                 (int32_t) aGlyph.GetSimpleAdvance(),</span>
<span class="lineNum">    1032 </span>            :                 0, 0
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :             };</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :             SetGlyphs(aIndex, CompressedGlyph().SetComplex(true, true, 1),</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                       &amp;details);</span>
<span class="lineNum">    1036 </span>            :         }
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :     // For characters whose glyph data does not fit the &quot;simple&quot; glyph criteria
<span class="lineNum">    1040 </span>            :     // in CompressedGlyph, we use a sorted array to store the association
<span class="lineNum">    1041 </span>            :     // between the source character offset and an index into an array 
<span class="lineNum">    1042 </span>            :     // DetailedGlyphs. The CompressedGlyph record includes a count of
<a name="1043"><span class="lineNum">    1043 </span>            :     // the number of DetailedGlyph records that belong to the character,</a>
<span class="lineNum">    1044 </span>            :     // starting at the given index.
<a name="1045"><span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     class DetailedGlyphStore {</span></a>
<span class="lineNum">    1046 </span>            :     public:
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         DetailedGlyphStore()</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :             : mLastUsed(0)</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         { }</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            :         // This is optimized for the most common calling patterns:
<span class="lineNum">    1052 </span>            :         // we rarely need random access to the records, access is most commonly
<span class="lineNum">    1053 </span>            :         // sequential through the textRun, so we record the last-used index
<span class="lineNum">    1054 </span>            :         // and check whether the caller wants the same record again, or the
<span class="lineNum">    1055 </span>            :         // next; if not, it's most likely we're starting over from the start
<span class="lineNum">    1056 </span>            :         // of the run, so we check the first entry before resorting to binary
<span class="lineNum">    1057 </span>            :         // search as a last resort.
<span class="lineNum">    1058 </span>            :         // NOTE that this must not be called for a character offset that does
<span class="lineNum">    1059 </span>            :         // not have any DetailedGlyph records; callers must have verified that
<span class="lineNum">    1060 </span>            :         // mCharacterGlyphs[aOffset].GetGlyphCount() is greater than zero
<a name="1061"><span class="lineNum">    1061 </span>            :         // before calling this, otherwise the assertions here will fire (in a</a>
<span class="lineNum">    1062 </span>            :         // debug build), and we'll probably crash.
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         DetailedGlyph* Get(uint32_t aOffset) {</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :             NS_ASSERTION(mOffsetToIndex.Length() &gt; 0,</span>
<span class="lineNum">    1065 </span>            :                          &quot;no detailed glyph records!&quot;);
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :             DetailedGlyph* details = mDetails.Elements();</span>
<span class="lineNum">    1067 </span>            :             // check common cases (fwd iteration, initial entry, etc) first
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             if (mLastUsed &lt; mOffsetToIndex.Length() - 1 &amp;&amp;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                 aOffset == mOffsetToIndex[mLastUsed + 1].mOffset) {</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                 ++mLastUsed;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :             } else if (aOffset == mOffsetToIndex[0].mOffset) {</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                 mLastUsed = 0;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :             } else if (aOffset == mOffsetToIndex[mLastUsed].mOffset) {</span>
<span class="lineNum">    1074 </span>            :                 // do nothing
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :             } else if (mLastUsed &gt; 0 &amp;&amp;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                        aOffset == mOffsetToIndex[mLastUsed - 1].mOffset) {</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :                 --mLastUsed;</span>
<span class="lineNum">    1078 </span>            :             } else {
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :                 mLastUsed =</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                     mOffsetToIndex.BinaryIndexOf(aOffset, CompareToOffset());</span>
<span class="lineNum">    1081 </span>            :             }
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :             NS_ASSERTION(mLastUsed != nsTArray&lt;DGRec&gt;::NoIndex,</span>
<span class="lineNum">    1083 </span>            :                          &quot;detailed glyph record missing!&quot;);
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :             return details + mOffsetToIndex[mLastUsed].mIndex;</span>
<a name="1085"><span class="lineNum">    1085 </span>            :         }</a>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :         DetailedGlyph* Allocate(uint32_t aOffset, uint32_t aCount) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :             uint32_t detailIndex = mDetails.Length();</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :             DetailedGlyph *details = mDetails.AppendElements(aCount);</span>
<span class="lineNum">    1090 </span>            :             // We normally set up glyph records sequentially, so the common case
<span class="lineNum">    1091 </span>            :             // here is to append new records to the mOffsetToIndex array;
<span class="lineNum">    1092 </span>            :             // test for that before falling back to the InsertElementSorted
<span class="lineNum">    1093 </span>            :             // method.
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :             if (mOffsetToIndex.Length() == 0 ||</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                 aOffset &gt; mOffsetToIndex[mOffsetToIndex.Length() - 1].mOffset) {</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :                 mOffsetToIndex.AppendElement(DGRec(aOffset, detailIndex));</span>
<span class="lineNum">    1097 </span>            :             } else {
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                 mOffsetToIndex.InsertElementSorted(DGRec(aOffset, detailIndex),</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                                                    CompareRecordOffsets());</span>
<span class="lineNum">    1100 </span>            :             }
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             return details;</span>
<a name="1102"><span class="lineNum">    1102 </span>            :         }</a>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :             return aMallocSizeOf(this) +</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                 mDetails.ShallowSizeOfExcludingThis(aMallocSizeOf) +</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                 mOffsetToIndex.ShallowSizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1108 </span>            :         }
<span class="lineNum">    1109 </span>            : 
<a name="1110"><span class="lineNum">    1110 </span>            :     private:</a>
<span class="lineNum">    1111 </span>            :         struct DGRec {
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :             DGRec(const uint32_t&amp; aOffset, const uint32_t&amp; aIndex)</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                 : mOffset(aOffset), mIndex(aIndex) { }</span>
<span class="lineNum">    1114 </span>            :             uint32_t mOffset; // source character offset in the textrun
<span class="lineNum">    1115 </span>            :             uint32_t mIndex;  // index where this char's DetailedGlyphs begin
<span class="lineNum">    1116 </span>            :         };
<a name="1117"><span class="lineNum">    1117 </span>            : </a>
<span class="lineNum">    1118 </span>            :         struct CompareToOffset {
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :             bool Equals(const DGRec&amp; a, const uint32_t&amp; b) const {</span>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                 return a.mOffset == b;</span></a>
<span class="lineNum">    1121 </span>            :             }
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :             bool LessThan(const DGRec&amp; a, const uint32_t&amp; b) const {</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                 return a.mOffset &lt; b;</span>
<span class="lineNum">    1124 </span>            :             }
<span class="lineNum">    1125 </span>            :         };
<a name="1126"><span class="lineNum">    1126 </span>            : </a>
<span class="lineNum">    1127 </span>            :         struct CompareRecordOffsets {
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :             bool Equals(const DGRec&amp; a, const DGRec&amp; b) const {</span>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                 return a.mOffset == b.mOffset;</span></a>
<span class="lineNum">    1130 </span>            :             }
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :             bool LessThan(const DGRec&amp; a, const DGRec&amp; b) const {</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :                 return a.mOffset &lt; b.mOffset;</span>
<span class="lineNum">    1133 </span>            :             }
<span class="lineNum">    1134 </span>            :         };
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :         // Concatenated array of all the DetailedGlyph records needed for the
<span class="lineNum">    1137 </span>            :         // textRun; individual character offsets are associated with indexes
<span class="lineNum">    1138 </span>            :         // into this array via the mOffsetToIndex table.
<span class="lineNum">    1139 </span>            :         nsTArray&lt;DetailedGlyph&gt;     mDetails;
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :         // For each character offset that needs DetailedGlyphs, we record the
<span class="lineNum">    1142 </span>            :         // index in mDetails where the list of glyphs begins. This array is
<span class="lineNum">    1143 </span>            :         // sorted by mOffset.
<span class="lineNum">    1144 </span>            :         nsTArray&lt;DGRec&gt;             mOffsetToIndex;
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :         // Records the most recently used index into mOffsetToIndex, so that
<span class="lineNum">    1147 </span>            :         // we can support sequential access more quickly than just doing
<span class="lineNum">    1148 </span>            :         // a binary search each time.
<span class="lineNum">    1149 </span>            :         nsTArray&lt;DGRec&gt;::index_type mLastUsed;
<span class="lineNum">    1150 </span>            :     };
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :     mozilla::UniquePtr&lt;DetailedGlyphStore&gt;   mDetailedGlyphs;
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :     // Number of char16_t characters and CompressedGlyph glyph records
<span class="lineNum">    1155 </span>            :     uint32_t                        mLength;
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            :     // Shaping flags (direction, ligature-suppression)
<span class="lineNum">    1158 </span>            :     mozilla::gfx::ShapedTextFlags   mFlags;
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :     uint16_t                        mAppUnitsPerDevUnit;
<span class="lineNum">    1161 </span>            : };
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : /*
<span class="lineNum">    1164 </span>            :  * gfxShapedWord: an individual (space-delimited) run of text shaped with a
<span class="lineNum">    1165 </span>            :  * particular font, without regard to external context.
<span class="lineNum">    1166 </span>            :  *
<span class="lineNum">    1167 </span>            :  * The glyph data is copied into gfxTextRuns as needed from the cache of
<a name="1168"><span class="lineNum">    1168 </span>            :  * ShapedWords associated with each gfxFont instance.</a>
<span class="lineNum">    1169 </span>            :  */
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 : class gfxShapedWord final : public gfxShapedText</span>
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span>            : public:
<span class="lineNum">    1173 </span>            :     typedef mozilla::unicode::Script Script;
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            :     // Create a ShapedWord that can hold glyphs for aLength characters,
<span class="lineNum">    1176 </span>            :     // with mCharacterGlyphs sized appropriately.
<span class="lineNum">    1177 </span>            :     //
<span class="lineNum">    1178 </span>            :     // Returns null on allocation failure (does NOT use infallible alloc)
<span class="lineNum">    1179 </span>            :     // so caller must check for success.
<span class="lineNum">    1180 </span>            :     //
<span class="lineNum">    1181 </span>            :     // This does NOT perform shaping, so the returned word contains no
<a name="1182"><span class="lineNum">    1182 </span>            :     // glyph data; the caller must call gfxFont::ShapeText() with appropriate</a>
<span class="lineNum">    1183 </span>            :     // parameters to set up the glyphs.
<span class="lineNum">    1184 </span><span class="lineCov">         30 :     static gfxShapedWord* Create(const uint8_t *aText, uint32_t aLength,</span>
<span class="lineNum">    1185 </span>            :                                  Script aRunScript,
<span class="lineNum">    1186 </span>            :                                  int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    1187 </span>            :                                  mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1188 </span>            :                                  gfxFontShaper::RoundingFlags aRounding) {
<span class="lineNum">    1189 </span><span class="lineCov">         30 :         NS_ASSERTION(aLength &lt;= gfxPlatform::GetPlatform()-&gt;WordCacheCharLimit(),</span>
<span class="lineNum">    1190 </span>            :                      &quot;excessive length for gfxShapedWord!&quot;);
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :         // Compute size needed including the mCharacterGlyphs array
<span class="lineNum">    1193 </span>            :         // and a copy of the original text
<span class="lineNum">    1194 </span>            :         uint32_t size =
<span class="lineNum">    1195 </span>            :             offsetof(gfxShapedWord, mCharGlyphsStorage) +
<span class="lineNum">    1196 </span><span class="lineCov">         30 :             aLength * (sizeof(CompressedGlyph) + sizeof(uint8_t));</span>
<span class="lineNum">    1197 </span><span class="lineCov">         30 :         void *storage = malloc(size);</span>
<span class="lineNum">    1198 </span><span class="lineCov">         30 :         if (!storage) {</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :             return nullptr;</span>
<span class="lineNum">    1200 </span>            :         }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            :         // Construct in the pre-allocated storage, using placement new
<span class="lineNum">    1203 </span>            :         return new (storage) gfxShapedWord(aText, aLength, aRunScript,
<span class="lineNum">    1204 </span>            :                                            aAppUnitsPerDevUnit, aFlags,
<span class="lineNum">    1205 </span><span class="lineCov">         30 :                                            aRounding);</span>
<a name="1206"><span class="lineNum">    1206 </span>            :     }</a>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineCov">         21 :     static gfxShapedWord* Create(const char16_t *aText, uint32_t aLength,</span>
<span class="lineNum">    1209 </span>            :                                  Script aRunScript,
<span class="lineNum">    1210 </span>            :                                  int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    1211 </span>            :                                  mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1212 </span>            :                                  gfxFontShaper::RoundingFlags aRounding) {
<span class="lineNum">    1213 </span><span class="lineCov">         21 :         NS_ASSERTION(aLength &lt;= gfxPlatform::GetPlatform()-&gt;WordCacheCharLimit(),</span>
<span class="lineNum">    1214 </span>            :                      &quot;excessive length for gfxShapedWord!&quot;);
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :         // In the 16-bit version of Create, if the TEXT_IS_8BIT flag is set,
<span class="lineNum">    1217 </span>            :         // then we convert the text to an 8-bit version and call the 8-bit
<span class="lineNum">    1218 </span>            :         // Create function instead.
<span class="lineNum">    1219 </span><span class="lineCov">         21 :         if (aFlags &amp; mozilla::gfx::ShapedTextFlags::TEXT_IS_8BIT) {</span>
<span class="lineNum">    1220 </span><span class="lineCov">         38 :             nsAutoCString narrowText;</span>
<span class="lineNum">    1221 </span><span class="lineCov">         38 :             LossyAppendUTF16toASCII(nsDependentSubstring(aText, aLength),</span>
<span class="lineNum">    1222 </span><span class="lineCov">         19 :                                     narrowText);</span>
<span class="lineNum">    1223 </span><span class="lineCov">         19 :             return Create((const uint8_t*)(narrowText.BeginReading()),</span>
<span class="lineNum">    1224 </span>            :                           aLength, aRunScript, aAppUnitsPerDevUnit, aFlags,
<span class="lineNum">    1225 </span><span class="lineCov">         19 :                           aRounding);</span>
<span class="lineNum">    1226 </span>            :         }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            :         uint32_t size =
<span class="lineNum">    1229 </span>            :             offsetof(gfxShapedWord, mCharGlyphsStorage) +
<span class="lineNum">    1230 </span><span class="lineCov">          2 :             aLength * (sizeof(CompressedGlyph) + sizeof(char16_t));</span>
<span class="lineNum">    1231 </span><span class="lineCov">          2 :         void *storage = malloc(size);</span>
<span class="lineNum">    1232 </span><span class="lineCov">          2 :         if (!storage) {</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             return nullptr;</span>
<span class="lineNum">    1234 </span>            :         }
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span>            :         return new (storage) gfxShapedWord(aText, aLength, aRunScript,
<span class="lineNum">    1237 </span>            :                                            aAppUnitsPerDevUnit, aFlags,
<span class="lineNum">    1238 </span><span class="lineCov">          2 :                                            aRounding);</span>
<span class="lineNum">    1239 </span>            :     }
<span class="lineNum">    1240 </span>            : 
<a name="1241"><span class="lineNum">    1241 </span>            :     // Override operator delete to properly free the object that was</a>
<span class="lineNum">    1242 </span>            :     // allocated via malloc.
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     void operator delete(void* p) {</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         free(p);</span>
<a name="1245"><span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     virtual const CompressedGlyph *GetCharacterGlyphs() const override {</span>
<a name="1248"><span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         return &amp;mCharGlyphsStorage[0];</span></a>
<span class="lineNum">    1249 </span>            :     }
<span class="lineNum">    1250 </span><span class="lineCov">        161 :     virtual CompressedGlyph *GetCharacterGlyphs() override {</span>
<span class="lineNum">    1251 </span><span class="lineCov">        161 :         return &amp;mCharGlyphsStorage[0];</span>
<a name="1252"><span class="lineNum">    1252 </span>            :     }</a>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineCov">         88 :     const uint8_t* Text8Bit() const {</span>
<span class="lineNum">    1255 </span><span class="lineCov">         88 :         NS_ASSERTION(TextIs8Bit(), &quot;invalid use of Text8Bit()&quot;);</span>
<span class="lineNum">    1256 </span><span class="lineCov">         88 :         return reinterpret_cast&lt;const uint8_t*&gt;(mCharGlyphsStorage + GetLength());</span>
<a name="1257"><span class="lineNum">    1257 </span>            :     }</a>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineCov">          7 :     const char16_t* TextUnicode() const {</span>
<span class="lineNum">    1260 </span><span class="lineCov">          7 :         NS_ASSERTION(!TextIs8Bit(), &quot;invalid use of TextUnicode()&quot;);</span>
<span class="lineNum">    1261 </span><span class="lineCov">          7 :         return reinterpret_cast&lt;const char16_t*&gt;(mCharGlyphsStorage + GetLength());</span>
<span class="lineNum">    1262 </span>            :     }
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            :     char16_t GetCharAt(uint32_t aOffset) const {
<span class="lineNum">    1265 </span>            :         NS_ASSERTION(aOffset &lt; GetLength(), &quot;aOffset out of range&quot;);
<span class="lineNum">    1266 </span>            :         return TextIs8Bit() ?
<span class="lineNum">    1267 </span>            :             char16_t(Text8Bit()[aOffset]) : TextUnicode()[aOffset];
<a name="1268"><span class="lineNum">    1268 </span>            :     }</a>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">         95 :     Script GetScript() const {</span>
<span class="lineNum">    1271 </span><span class="lineCov">         95 :         return mScript;</span>
<a name="1272"><span class="lineNum">    1272 </span>            :     }</a>
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span><span class="lineCov">         95 :     gfxFontShaper::RoundingFlags GetRounding() const {</span>
<span class="lineNum">    1275 </span><span class="lineCov">         95 :         return mRounding;</span>
<a name="1276"><span class="lineNum">    1276 </span>            :     }</a>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">         95 :     void ResetAge() {</span>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineCov">         95 :         mAgeCounter = 0;</span></a>
<span class="lineNum">    1280 </span><span class="lineCov">         95 :     }</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     uint32_t IncrementAge() {</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :         return ++mAgeCounter;</span>
<span class="lineNum">    1283 </span>            :     }
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<span class="lineNum">    1285 </span>            :     // Helper used when hashing a word for the shaped-word caches
<span class="lineNum">    1286 </span><span class="lineCov">        802 :     static uint32_t HashMix(uint32_t aHash, char16_t aCh)</span>
<span class="lineNum">    1287 </span>            :     {
<span class="lineNum">    1288 </span><span class="lineCov">        802 :         return (aHash &gt;&gt; 28) ^ (aHash &lt;&lt; 4) ^ aCh;</span>
<span class="lineNum">    1289 </span>            :     }
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            : private:
<span class="lineNum">    1292 </span>            :     // so that gfxTextRun can share our DetailedGlyphStore class
<span class="lineNum">    1293 </span>            :     friend class gfxTextRun;
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<span class="lineNum">    1295 </span>            :     // Construct storage for a ShapedWord, ready to receive glyph data
<span class="lineNum">    1296 </span><span class="lineCov">         30 :     gfxShapedWord(const uint8_t *aText, uint32_t aLength,</span>
<span class="lineNum">    1297 </span>            :                   Script aRunScript,
<span class="lineNum">    1298 </span>            :                   int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    1299 </span>            :                   mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1300 </span>            :                   gfxFontShaper::RoundingFlags aRounding)
<span class="lineNum">    1301 </span><span class="lineCov">         60 :         : gfxShapedText(aLength, aFlags | mozilla::gfx::ShapedTextFlags::TEXT_IS_8BIT,</span>
<span class="lineNum">    1302 </span>            :                         aAppUnitsPerDevUnit)
<span class="lineNum">    1303 </span>            :         , mScript(aRunScript)
<span class="lineNum">    1304 </span>            :         , mRounding(aRounding)
<span class="lineNum">    1305 </span><span class="lineCov">         60 :         , mAgeCounter(0)</span>
<span class="lineNum">    1306 </span>            :     {
<span class="lineNum">    1307 </span><span class="lineCov">         30 :         memset(mCharGlyphsStorage, 0, aLength * sizeof(CompressedGlyph));</span>
<span class="lineNum">    1308 </span><span class="lineCov">         30 :         uint8_t *text = reinterpret_cast&lt;uint8_t*&gt;(&amp;mCharGlyphsStorage[aLength]);</span>
<span class="lineNum">    1309 </span><span class="lineCov">         30 :         memcpy(text, aText, aLength * sizeof(uint8_t));</span>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineCov">         30 :     }</span></a>
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineCov">          2 :     gfxShapedWord(const char16_t *aText, uint32_t aLength,</span>
<span class="lineNum">    1313 </span>            :                   Script aRunScript,
<span class="lineNum">    1314 </span>            :                   int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    1315 </span>            :                   mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1316 </span>            :                   gfxFontShaper::RoundingFlags aRounding)
<span class="lineNum">    1317 </span><span class="lineCov">          2 :         : gfxShapedText(aLength, aFlags, aAppUnitsPerDevUnit)</span>
<span class="lineNum">    1318 </span>            :         , mScript(aRunScript)
<span class="lineNum">    1319 </span>            :         , mRounding(aRounding)
<span class="lineNum">    1320 </span><span class="lineCov">          2 :         , mAgeCounter(0)</span>
<span class="lineNum">    1321 </span>            :     {
<span class="lineNum">    1322 </span><span class="lineCov">          2 :         memset(mCharGlyphsStorage, 0, aLength * sizeof(CompressedGlyph));</span>
<span class="lineNum">    1323 </span><span class="lineCov">          2 :         char16_t *text = reinterpret_cast&lt;char16_t*&gt;(&amp;mCharGlyphsStorage[aLength]);</span>
<span class="lineNum">    1324 </span><span class="lineCov">          2 :         memcpy(text, aText, aLength * sizeof(char16_t));</span>
<span class="lineNum">    1325 </span><span class="lineCov">          2 :         SetupClusterBoundaries(0, aText, aLength);</span>
<span class="lineNum">    1326 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :     Script           mScript;
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            :     gfxFontShaper::RoundingFlags mRounding;
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            :     uint32_t         mAgeCounter;
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            :     // The mCharGlyphsStorage array is actually a variable-size member;
<span class="lineNum">    1335 </span>            :     // when the ShapedWord is created, its size will be increased as necessary
<span class="lineNum">    1336 </span>            :     // to allow the proper number of glyphs to be stored.
<span class="lineNum">    1337 </span>            :     // The original text, in either 8-bit or 16-bit form, will be stored
<span class="lineNum">    1338 </span>            :     // immediately following the CompressedGlyphs.
<span class="lineNum">    1339 </span>            :     CompressedGlyph  mCharGlyphsStorage[1];
<span class="lineNum">    1340 </span>            : };
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            : class GlyphBufferAzure;
<span class="lineNum">    1343 </span>            : struct TextRunDrawParams;
<span class="lineNum">    1344 </span>            : struct FontDrawParams;
<span class="lineNum">    1345 </span>            : struct EmphasisMarkDrawParams;
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            : class gfxFont {
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :     friend class gfxHarfBuzzShaper;
<span class="lineNum">    1350 </span>            :     friend class gfxGraphiteShaper;
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : protected:
<span class="lineNum">    1353 </span>            :     typedef mozilla::gfx::DrawTarget DrawTarget;
<span class="lineNum">    1354 </span>            :     typedef mozilla::unicode::Script Script;
<span class="lineNum">    1355 </span>            :     typedef mozilla::SVGContextPaint SVGContextPaint;
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :     typedef gfxFontShaper::RoundingFlags RoundingFlags;
<a name="1358"><span class="lineNum">    1358 </span>            : </a>
<span class="lineNum">    1359 </span>            : public:
<span class="lineNum">    1360 </span><span class="lineCov">        241 :     nsrefcnt AddRef(void) {</span>
<span class="lineNum">    1361 </span><span class="lineCov">        241 :         NS_PRECONDITION(int32_t(mRefCnt) &gt;= 0, &quot;illegal refcnt&quot;);</span>
<span class="lineNum">    1362 </span><span class="lineCov">        241 :         if (mExpirationState.IsTracked()) {</span>
<span class="lineNum">    1363 </span><span class="lineCov">          8 :             gfxFontCache::GetCache()-&gt;RemoveObject(this);</span>
<span class="lineNum">    1364 </span>            :         }
<span class="lineNum">    1365 </span><span class="lineCov">        241 :         ++mRefCnt;</span>
<span class="lineNum">    1366 </span><span class="lineCov">        241 :         NS_LOG_ADDREF(this, mRefCnt, &quot;gfxFont&quot;, sizeof(*this));</span>
<a name="1367"><span class="lineNum">    1367 </span><span class="lineCov">        241 :         return mRefCnt;</span></a>
<span class="lineNum">    1368 </span>            :     }
<span class="lineNum">    1369 </span><span class="lineCov">        231 :     nsrefcnt Release(void) {</span>
<span class="lineNum">    1370 </span><span class="lineCov">        231 :         NS_PRECONDITION(0 != mRefCnt, &quot;dup release&quot;);</span>
<span class="lineNum">    1371 </span><span class="lineCov">        231 :         --mRefCnt;</span>
<span class="lineNum">    1372 </span><span class="lineCov">        231 :         NS_LOG_RELEASE(this, mRefCnt, &quot;gfxFont&quot;);</span>
<span class="lineNum">    1373 </span><span class="lineCov">        231 :         if (mRefCnt == 0) {</span>
<span class="lineNum">    1374 </span><span class="lineCov">         12 :             NotifyReleased();</span>
<span class="lineNum">    1375 </span>            :             // |this| may have been deleted.
<span class="lineNum">    1376 </span><span class="lineCov">         12 :             return 0;</span>
<span class="lineNum">    1377 </span>            :         }
<span class="lineNum">    1378 </span><span class="lineCov">        219 :         return mRefCnt;</span>
<a name="1379"><span class="lineNum">    1379 </span>            :     }</a>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :     int32_t GetRefCount() { return mRefCnt; }</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            :     // options to specify the kind of AA to be used when creating a font
<span class="lineNum">    1384 </span>            :     typedef enum {
<span class="lineNum">    1385 </span>            :         kAntialiasDefault,
<span class="lineNum">    1386 </span>            :         kAntialiasNone,
<span class="lineNum">    1387 </span>            :         kAntialiasGrayscale,
<span class="lineNum">    1388 </span>            :         kAntialiasSubpixel
<span class="lineNum">    1389 </span>            :     } AntialiasOption;
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : protected:
<span class="lineNum">    1392 </span>            :     nsAutoRefCnt mRefCnt;
<a name="1393"><span class="lineNum">    1393 </span>            :     cairo_scaled_font_t *mScaledFont;</a>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineCov">         12 :     void NotifyReleased() {</span>
<span class="lineNum">    1396 </span><span class="lineCov">         12 :         gfxFontCache *cache = gfxFontCache::GetCache();</span>
<span class="lineNum">    1397 </span><span class="lineCov">         12 :         if (cache) {</span>
<span class="lineNum">    1398 </span>            :             // Don't delete just yet; return the object to the cache for
<span class="lineNum">    1399 </span>            :             // possibly recycling within some time limit
<span class="lineNum">    1400 </span><span class="lineCov">         12 :             cache-&gt;NotifyReleased(this);</span>
<span class="lineNum">    1401 </span>            :         } else {
<span class="lineNum">    1402 </span>            :             // The cache may have already been shut down.
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             delete this;</span>
<span class="lineNum">    1404 </span>            :         }
<span class="lineNum">    1405 </span><span class="lineCov">         12 :     }</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :     gfxFont(const RefPtr&lt;mozilla::gfx::UnscaledFont&gt;&amp; aUnscaledFont,
<span class="lineNum">    1408 </span>            :             gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
<span class="lineNum">    1409 </span>            :             AntialiasOption anAAOption = kAntialiasDefault,
<span class="lineNum">    1410 </span>            :             cairo_scaled_font_t *aScaledFont = nullptr);
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            : public:
<a name="1413"><span class="lineNum">    1413 </span>            :     virtual ~gfxFont();</a>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">         14 :     bool Valid() const {</span>
<span class="lineNum">    1416 </span><span class="lineCov">         14 :         return mIsValid;</span>
<span class="lineNum">    1417 </span>            :     }
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :     // options for the kind of bounding box to return from measurement
<span class="lineNum">    1420 </span>            :     typedef enum {
<span class="lineNum">    1421 </span>            :         LOOSE_INK_EXTENTS,
<span class="lineNum">    1422 </span>            :             // A box that encloses all the painted pixels, and may
<span class="lineNum">    1423 </span>            :             // include sidebearings and/or additional ascent/descent
<span class="lineNum">    1424 </span>            :             // within the glyph cell even if the ink is smaller.
<span class="lineNum">    1425 </span>            :         TIGHT_INK_EXTENTS,
<span class="lineNum">    1426 </span>            :             // A box that tightly encloses all the painted pixels
<span class="lineNum">    1427 </span>            :             // (although actually on Windows, at least, it may be
<span class="lineNum">    1428 </span>            :             // slightly larger than strictly necessary because
<span class="lineNum">    1429 </span>            :             // we can't get precise extents with ClearType).
<span class="lineNum">    1430 </span>            :         TIGHT_HINTED_OUTLINE_EXTENTS
<span class="lineNum">    1431 </span>            :             // A box that tightly encloses the glyph outline,
<span class="lineNum">    1432 </span>            :             // ignoring possible antialiasing pixels that extend
<span class="lineNum">    1433 </span>            :             // beyond this.
<span class="lineNum">    1434 </span>            :             // NOTE: The default implementation of gfxFont::Measure(),
<span class="lineNum">    1435 </span>            :             // which works with the glyph extents cache, does not
<span class="lineNum">    1436 </span>            :             // differentiate between this and TIGHT_INK_EXTENTS.
<span class="lineNum">    1437 </span>            :             // Whether the distinction is important depends on the
<span class="lineNum">    1438 </span>            :             // antialiasing behavior of the platform; currently the
<span class="lineNum">    1439 </span>            :             // distinction is only implemented in the gfxWindowsFont
<span class="lineNum">    1440 </span>            :             // subclass, because of ClearType's tendency to paint
<span class="lineNum">    1441 </span>            :             // outside the hinted outline.
<span class="lineNum">    1442 </span>            :             // Also NOTE: it is relatively expensive to request this,
<span class="lineNum">    1443 </span>            :             // as it does not use cached glyph extents in the font.
<a name="1444"><span class="lineNum">    1444 </span>            :     } BoundingBoxType;</a>
<a name="1445"><span class="lineNum">    1445 </span>            : </a>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     const nsString&amp; GetName() const { return mFontEntry-&gt;Name(); }</span>
<a name="1447"><span class="lineNum">    1447 </span><span class="lineCov">        127 :     const gfxFontStyle *GetStyle() const { return &amp;mStyle; }</span></a>
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span><span class="lineCov">         21 :     virtual cairo_scaled_font_t* GetCairoScaledFont() { return mScaledFont; }</span>
<a name="1450"><span class="lineNum">    1450 </span>            : </a>
<span class="lineNum">    1451 </span>            :     virtual mozilla::UniquePtr&lt;gfxFont&gt;
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     CopyWithAntialiasOption(AntialiasOption anAAOption) {</span>
<span class="lineNum">    1453 </span>            :         // platforms where this actually matters should override
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<a name="1455"><span class="lineNum">    1455 </span>            :     }</a>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineCov">         29 :     gfxFloat GetAdjustedSize() const {</span>
<span class="lineNum">    1458 </span><span class="lineCov">         29 :         return mAdjustedSize &gt; 0.0</span>
<span class="lineNum">    1459 </span><span class="lineCov">         29 :                  ? mAdjustedSize</span>
<span class="lineNum">    1460 </span><span class="lineCov">         29 :                  : (mStyle.sizeAdjust == 0.0 ? 0.0 : mStyle.size);</span>
<a name="1461"><span class="lineNum">    1461 </span>            :     }</a>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :     float FUnitsToDevUnitsFactor() const {</span>
<span class="lineNum">    1464 </span>            :         // check this was set up during font initialization
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         NS_ASSERTION(mFUnitsConvFactor &gt;= 0.0f, &quot;mFUnitsConvFactor not valid&quot;);</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :         return mFUnitsConvFactor;</span>
<span class="lineNum">    1467 </span>            :     }
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :     // check whether this is an sfnt we can potentially use with harfbuzz
<span class="lineNum">    1470 </span>            :     bool FontCanSupportHarfBuzz() {
<span class="lineNum">    1471 </span>            :         return mFontEntry-&gt;HasCmapTable();
<span class="lineNum">    1472 </span>            :     }
<a name="1473"><span class="lineNum">    1473 </span>            : </a>
<span class="lineNum">    1474 </span>            :     // check whether this is an sfnt we can potentially use with Graphite
<span class="lineNum">    1475 </span><span class="lineCov">        105 :     bool FontCanSupportGraphite() {</span>
<span class="lineNum">    1476 </span><span class="lineCov">        105 :         return mFontEntry-&gt;HasGraphiteTables();</span>
<span class="lineNum">    1477 </span>            :     }
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            :     // Whether this is a font that may be doing full-color rendering,
<a name="1480"><span class="lineNum">    1480 </span>            :     // and therefore needs us to use a mask for text-shadow even when</a>
<span class="lineNum">    1481 </span>            :     // we're not actually blurring.
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     bool AlwaysNeedsMaskForShadow() {</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         return mFontEntry-&gt;TryGetColorGlyphs() ||</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                mFontEntry-&gt;TryGetSVGData(this) ||</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :                mFontEntry-&gt;HasFontTable(TRUETYPE_TAG('C','B','D','T')) ||</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :                mFontEntry-&gt;HasFontTable(TRUETYPE_TAG('s','b','i','x'));</span>
<span class="lineNum">    1487 </span>            :     }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            :     // whether a feature is supported by the font (limited to a small set
<span class="lineNum">    1490 </span>            :     // of features for which some form of fallback needs to be implemented)
<span class="lineNum">    1491 </span>            :     bool SupportsFeature(Script aScript, uint32_t aFeatureTag);
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            :     // whether the font supports &quot;real&quot; small caps, petite caps etc.
<span class="lineNum">    1494 </span>            :     // aFallbackToSmallCaps true when petite caps should fallback to small caps
<span class="lineNum">    1495 </span>            :     bool SupportsVariantCaps(Script aScript, uint32_t aVariantCaps,
<span class="lineNum">    1496 </span>            :                              bool&amp; aFallbackToSmallCaps,
<span class="lineNum">    1497 </span>            :                              bool&amp; aSyntheticLowerToSmallCaps,
<span class="lineNum">    1498 </span>            :                              bool&amp; aSyntheticUpperToSmallCaps);
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :     // whether the font supports subscript/superscript feature
<span class="lineNum">    1501 </span>            :     // for fallback, need to verify that all characters in the run
<span class="lineNum">    1502 </span>            :     // have variant substitutions
<span class="lineNum">    1503 </span>            :     bool SupportsSubSuperscript(uint32_t aSubSuperscript,
<span class="lineNum">    1504 </span>            :                                 const uint8_t *aString,
<span class="lineNum">    1505 </span>            :                                 uint32_t aLength,
<span class="lineNum">    1506 </span>            :                                 Script aRunScript);
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            :     bool SupportsSubSuperscript(uint32_t aSubSuperscript,
<span class="lineNum">    1509 </span>            :                                 const char16_t *aString,
<span class="lineNum">    1510 </span>            :                                 uint32_t aLength,
<span class="lineNum">    1511 </span>            :                                 Script aRunScript);
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            :     // Subclasses may choose to look up glyph ids for characters.
<a name="1514"><span class="lineNum">    1514 </span>            :     // If they do not override this, gfxHarfBuzzShaper will fetch the cmap</a>
<span class="lineNum">    1515 </span>            :     // table and use that.
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     virtual bool ProvidesGetGlyph() const {</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1518 </span>            :     }
<a name="1519"><span class="lineNum">    1519 </span>            :     // Map unicode character to glyph ID.</a>
<span class="lineNum">    1520 </span>            :     // Only used if ProvidesGetGlyph() returns true.
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :     virtual uint32_t GetGlyph(uint32_t unicode, uint32_t variation_selector) {</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1523 </span>            :     }
<span class="lineNum">    1524 </span>            :     // Return the horizontal advance of a glyph.
<span class="lineNum">    1525 </span>            :     gfxFloat GetGlyphHAdvance(DrawTarget* aDrawTarget, uint16_t aGID);
<span class="lineNum">    1526 </span>            : 
<a name="1527"><span class="lineNum">    1527 </span>            :     // Return Azure GlyphRenderingOptions for drawing this font.</a>
<span class="lineNum">    1528 </span>            :     virtual already_AddRefed&lt;mozilla::gfx::GlyphRenderingOptions&gt;
<span class="lineNum">    1529 </span><span class="lineCov">         21 :       GetGlyphRenderingOptions(const TextRunDrawParams* aRunParams = nullptr)</span>
<span class="lineNum">    1530 </span><span class="lineCov">         21 :     { return nullptr; }</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :     gfxFloat SynthesizeSpaceWidth(uint32_t aCh);
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            :     // Work out whether cairo will snap inter-glyph spacing to pixels
<span class="lineNum">    1535 </span>            :     // when rendering to the given drawTarget.
<span class="lineNum">    1536 </span>            :     RoundingFlags GetRoundOffsetsToPixels(DrawTarget* aDrawTarget);
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :     // Font metrics
<span class="lineNum">    1539 </span>            :     struct Metrics {
<span class="lineNum">    1540 </span>            :         gfxFloat capHeight;
<span class="lineNum">    1541 </span>            :         gfxFloat xHeight;
<span class="lineNum">    1542 </span>            :         gfxFloat strikeoutSize;
<span class="lineNum">    1543 </span>            :         gfxFloat strikeoutOffset;
<span class="lineNum">    1544 </span>            :         gfxFloat underlineSize;
<span class="lineNum">    1545 </span>            :         gfxFloat underlineOffset;
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            :         gfxFloat internalLeading;
<span class="lineNum">    1548 </span>            :         gfxFloat externalLeading;
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            :         gfxFloat emHeight;
<span class="lineNum">    1551 </span>            :         gfxFloat emAscent;
<span class="lineNum">    1552 </span>            :         gfxFloat emDescent;
<span class="lineNum">    1553 </span>            :         gfxFloat maxHeight;
<span class="lineNum">    1554 </span>            :         gfxFloat maxAscent;
<span class="lineNum">    1555 </span>            :         gfxFloat maxDescent;
<span class="lineNum">    1556 </span>            :         gfxFloat maxAdvance;
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :         gfxFloat aveCharWidth;
<span class="lineNum">    1559 </span>            :         gfxFloat spaceWidth;
<span class="lineNum">    1560 </span>            :         gfxFloat zeroOrAveCharWidth;  // width of '0', or if there is
<span class="lineNum">    1561 </span>            :                                       // no '0' glyph in this font,
<span class="lineNum">    1562 </span>            :                                       // equal to .aveCharWidth
<span class="lineNum">    1563 </span>            :     };
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span>            :     enum Orientation {
<span class="lineNum">    1566 </span>            :         eHorizontal,
<span class="lineNum">    1567 </span>            :         eVertical
<a name="1568"><span class="lineNum">    1568 </span>            :     };</a>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineCov">       1111 :     const Metrics&amp; GetMetrics(Orientation aOrientation)</span>
<span class="lineNum">    1571 </span>            :     {
<span class="lineNum">    1572 </span><span class="lineCov">       1111 :         if (aOrientation == eHorizontal) {</span>
<span class="lineNum">    1573 </span><span class="lineCov">       1111 :             return GetHorizontalMetrics();</span>
<span class="lineNum">    1574 </span>            :         }
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         if (!mVerticalMetrics) {</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :             mVerticalMetrics = CreateVerticalMetrics();</span>
<span class="lineNum">    1577 </span>            :         }
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :         return *mVerticalMetrics;</span>
<span class="lineNum">    1579 </span>            :     }
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            :     /**
<span class="lineNum">    1582 </span>            :      * We let layout specify spacing on either side of any
<span class="lineNum">    1583 </span>            :      * character. We need to specify both before and after
<span class="lineNum">    1584 </span>            :      * spacing so that substring measurement can do the right things.
<span class="lineNum">    1585 </span>            :      * These values are in appunits. They're always an integral number of
<span class="lineNum">    1586 </span>            :      * appunits, but we specify them in floats in case very large spacing
<span class="lineNum">    1587 </span>            :      * values are required.
<span class="lineNum">    1588 </span>            :      */
<span class="lineNum">    1589 </span>            :     struct Spacing {
<span class="lineNum">    1590 </span>            :         gfxFloat mBefore;
<span class="lineNum">    1591 </span>            :         gfxFloat mAfter;
<span class="lineNum">    1592 </span>            :     };
<span class="lineNum">    1593 </span>            :     /**
<span class="lineNum">    1594 </span>            :      * Metrics for a particular string
<a name="1595"><span class="lineNum">    1595 </span>            :      */</a>
<span class="lineNum">    1596 </span>            :     struct RunMetrics {
<span class="lineNum">    1597 </span><span class="lineCov">        120 :         RunMetrics() {</span>
<span class="lineNum">    1598 </span><span class="lineCov">        120 :             mAdvanceWidth = mAscent = mDescent = 0.0;</span>
<span class="lineNum">    1599 </span><span class="lineCov">        120 :         }</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :         void CombineWith(const RunMetrics&amp; aOther, bool aOtherIsOnLeft);
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :         // can be negative (partly due to negative spacing).
<span class="lineNum">    1604 </span>            :         // Advance widths should be additive: the advance width of the
<span class="lineNum">    1605 </span>            :         // (offset1, length1) plus the advance width of (offset1 + length1,
<span class="lineNum">    1606 </span>            :         // length2) should be the advance width of (offset1, length1 + length2)
<span class="lineNum">    1607 </span>            :         gfxFloat mAdvanceWidth;
<span class="lineNum">    1608 </span>            :         
<span class="lineNum">    1609 </span>            :         // For zero-width substrings, these must be zero!
<span class="lineNum">    1610 </span>            :         gfxFloat mAscent;  // always non-negative
<span class="lineNum">    1611 </span>            :         gfxFloat mDescent; // always non-negative
<span class="lineNum">    1612 </span>            :         
<span class="lineNum">    1613 </span>            :         // Bounding box that is guaranteed to include everything drawn.
<span class="lineNum">    1614 </span>            :         // If a tight boundingBox was requested when these metrics were
<span class="lineNum">    1615 </span>            :         // generated, this will tightly wrap the glyphs, otherwise it is
<span class="lineNum">    1616 </span>            :         // &quot;loose&quot; and may be larger than the true bounding box.
<span class="lineNum">    1617 </span>            :         // Coordinates are relative to the baseline left origin, so typically
<span class="lineNum">    1618 </span>            :         // mBoundingBox.y == -mAscent
<span class="lineNum">    1619 </span>            :         gfxRect  mBoundingBox;
<span class="lineNum">    1620 </span>            :     };
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :     /**
<span class="lineNum">    1623 </span>            :      * Draw a series of glyphs to aContext. The direction of aTextRun must
<span class="lineNum">    1624 </span>            :      * be honoured.
<span class="lineNum">    1625 </span>            :      * @param aStart the first character to draw
<span class="lineNum">    1626 </span>            :      * @param aEnd draw characters up to here
<span class="lineNum">    1627 </span>            :      * @param aPt the baseline origin; the left end of the baseline
<span class="lineNum">    1628 </span>            :      * for LTR textruns, the right end for RTL textruns.
<span class="lineNum">    1629 </span>            :      * On return, this will be updated to the other end of the baseline.
<span class="lineNum">    1630 </span>            :      * In application units, really!
<span class="lineNum">    1631 </span>            :      * @param aRunParams record with drawing parameters, see TextRunDrawParams.
<span class="lineNum">    1632 </span>            :      * Particular fields of interest include
<span class="lineNum">    1633 </span>            :      * .spacing  spacing to insert before and after characters (for RTL
<span class="lineNum">    1634 </span>            :      *   glyphs, before-spacing is inserted to the right of characters). There
<span class="lineNum">    1635 </span>            :      *   are aEnd - aStart elements in this array, unless it's null to indicate
<span class="lineNum">    1636 </span>            :      *   that there is no spacing.
<span class="lineNum">    1637 </span>            :      * .drawMode  specifies whether the fill or stroke of the glyph should be
<span class="lineNum">    1638 </span>            :      *   drawn, or if it should be drawn into the current path
<span class="lineNum">    1639 </span>            :      * .contextPaint  information about how to construct the fill and
<span class="lineNum">    1640 </span>            :      *   stroke pattern. Can be nullptr if we are not stroking the text, which
<span class="lineNum">    1641 </span>            :      *   indicates that the current source from context should be used for fill
<span class="lineNum">    1642 </span>            :      * .context  the Thebes graphics context to which we're drawing
<span class="lineNum">    1643 </span>            :      * .dt  Moz2D DrawTarget to which we're drawing
<span class="lineNum">    1644 </span>            :      *
<span class="lineNum">    1645 </span>            :      * Callers guarantee:
<span class="lineNum">    1646 </span>            :      * -- aStart and aEnd are aligned to cluster and ligature boundaries
<span class="lineNum">    1647 </span>            :      * -- all glyphs use this font
<span class="lineNum">    1648 </span>            :      */
<span class="lineNum">    1649 </span>            :     void Draw(const gfxTextRun *aTextRun, uint32_t aStart, uint32_t aEnd,
<span class="lineNum">    1650 </span>            :               gfxPoint *aPt, const TextRunDrawParams&amp; aRunParams,
<span class="lineNum">    1651 </span>            :               mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :     /**
<span class="lineNum">    1654 </span>            :      * Draw the emphasis marks for the given text run. Its prerequisite
<span class="lineNum">    1655 </span>            :      * and output are similiar to the method Draw().
<span class="lineNum">    1656 </span>            :      * @param aPt the baseline origin of the emphasis marks.
<span class="lineNum">    1657 </span>            :      * @param aParams some drawing parameters, see EmphasisMarkDrawParams.
<span class="lineNum">    1658 </span>            :      */
<span class="lineNum">    1659 </span>            :     void DrawEmphasisMarks(const gfxTextRun* aShapedText, gfxPoint* aPt,
<span class="lineNum">    1660 </span>            :                            uint32_t aOffset, uint32_t aCount,
<span class="lineNum">    1661 </span>            :                            const EmphasisMarkDrawParams&amp; aParams);
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span>            :     /**
<span class="lineNum">    1664 </span>            :      * Measure a run of characters. See gfxTextRun::Metrics.
<span class="lineNum">    1665 </span>            :      * @param aTight if false, then return the union of the glyph extents
<span class="lineNum">    1666 </span>            :      * with the font-box for the characters (the rectangle with x=0,width=
<span class="lineNum">    1667 </span>            :      * the advance width for the character run,y=-(font ascent), and height=
<span class="lineNum">    1668 </span>            :      * font ascent + font descent). Otherwise, we must return as tight as possible
<span class="lineNum">    1669 </span>            :      * an approximation to the area actually painted by glyphs.
<span class="lineNum">    1670 </span>            :      * @param aDrawTargetForTightBoundingBox when aTight is true, this must
<span class="lineNum">    1671 </span>            :      * be non-null.
<span class="lineNum">    1672 </span>            :      * @param aSpacing spacing to insert before and after glyphs. The bounding box
<span class="lineNum">    1673 </span>            :      * need not include the spacing itself, but the spacing affects the glyph
<span class="lineNum">    1674 </span>            :      * positions. null if there is no spacing.
<span class="lineNum">    1675 </span>            :      * 
<span class="lineNum">    1676 </span>            :      * Callers guarantee:
<span class="lineNum">    1677 </span>            :      * -- aStart and aEnd are aligned to cluster and ligature boundaries
<span class="lineNum">    1678 </span>            :      * -- all glyphs use this font
<span class="lineNum">    1679 </span>            :      * 
<span class="lineNum">    1680 </span>            :      * The default implementation just uses font metrics and aTextRun's
<span class="lineNum">    1681 </span>            :      * advances, and assumes no characters fall outside the font box. In
<span class="lineNum">    1682 </span>            :      * general this is insufficient, because that assumption is not always true.
<span class="lineNum">    1683 </span>            :      */
<span class="lineNum">    1684 </span>            :     virtual RunMetrics Measure(const gfxTextRun *aTextRun,
<span class="lineNum">    1685 </span>            :                                uint32_t aStart, uint32_t aEnd,
<span class="lineNum">    1686 </span>            :                                BoundingBoxType aBoundingBoxType,
<span class="lineNum">    1687 </span>            :                                DrawTarget* aDrawTargetForTightBoundingBox,
<span class="lineNum">    1688 </span>            :                                Spacing *aSpacing,
<span class="lineNum">    1689 </span>            :                                mozilla::gfx::ShapedTextFlags aOrientation);
<span class="lineNum">    1690 </span>            :     /**
<span class="lineNum">    1691 </span>            :      * Line breaks have been changed at the beginning and/or end of a substring
<span class="lineNum">    1692 </span>            :      * of the text. Reshaping may be required; glyph updating is permitted.
<span class="lineNum">    1693 </span>            :      * @return true if anything was changed, false otherwise
<span class="lineNum">    1694 </span>            :      */
<span class="lineNum">    1695 </span>            :     bool NotifyLineBreaksChanged(gfxTextRun *aTextRun,
<span class="lineNum">    1696 </span>            :                                    uint32_t aStart, uint32_t aLength)
<span class="lineNum">    1697 </span>            :     { return false; }
<a name="1698"><span class="lineNum">    1698 </span>            : </a>
<span class="lineNum">    1699 </span>            :     // Expiration tracking
<span class="lineNum">    1700 </span><span class="lineCov">         28 :     nsExpirationState *GetExpirationState() { return &amp;mExpirationState; }</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span>            :     // Get the glyphID of a space
<span class="lineNum">    1703 </span>            :     virtual uint32_t GetSpaceGlyph() = 0;
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span>            :     gfxGlyphExtents *GetOrCreateGlyphExtents(int32_t aAppUnitsPerDevUnit);
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            :     // You need to call SetupCairoFont on aDrawTarget just before calling this.
<span class="lineNum">    1708 </span>            :     void SetupGlyphExtents(DrawTarget* aDrawTarget, uint32_t aGlyphID,
<span class="lineNum">    1709 </span>            :                            bool aNeedTight, gfxGlyphExtents *aExtents);
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span>            :     // This is called by the default Draw() implementation above.
<a name="1712"><span class="lineNum">    1712 </span>            :     virtual bool SetupCairoFont(DrawTarget* aDrawTarget) = 0;</a>
<span class="lineNum">    1713 </span>            : 
<a name="1714"><span class="lineNum">    1714 </span><span class="lineCov">         21 :     virtual bool AllowSubpixelAA() { return true; }</span></a>
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineCov">         63 :     bool IsSyntheticBold() { return mApplySyntheticBold; }</span>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            :     // Amount by which synthetic bold &quot;fattens&quot; the glyphs:
<span class="lineNum">    1719 </span>            :     // For size S up to a threshold size T, we use (0.25 + 3S / 4T),
<a name="1720"><span class="lineNum">    1720 </span>            :     // so that the result ranges from 0.25 to 1.0; thereafter,</a>
<span class="lineNum">    1721 </span>            :     // simply use (S / T).
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :     gfxFloat GetSyntheticBoldOffset() {</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :         gfxFloat size = GetAdjustedSize();</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :         const gfxFloat threshold = 48.0;</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :         return size &lt; threshold ? (0.25 + 0.75 * size / threshold) :</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :                                   (size / threshold);</span>
<a name="1727"><span class="lineNum">    1727 </span>            :     }</a>
<a name="1728"><span class="lineNum">    1728 </span>            : </a>
<span class="lineNum">    1729 </span><span class="lineCov">        204 :     gfxFontEntry *GetFontEntry() const { return mFontEntry.get(); }</span>
<span class="lineNum">    1730 </span><span class="lineCov">        860 :     bool HasCharacter(uint32_t ch) {</span>
<span class="lineNum">    1731 </span><span class="lineCov">       1720 :         if (!mIsValid ||</span>
<span class="lineNum">    1732 </span><span class="lineCov">        860 :             (mUnicodeRangeMap &amp;&amp; !mUnicodeRangeMap-&gt;test(ch))) {</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1734 </span>            :         }
<span class="lineNum">    1735 </span><span class="lineCov">        860 :         return mFontEntry-&gt;HasCharacter(ch); </span>
<a name="1736"><span class="lineNum">    1736 </span>            :     }</a>
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineCov">         17 :     const gfxCharacterMap* GetUnicodeRangeMap() const {</span>
<span class="lineNum">    1739 </span><span class="lineCov">         17 :         return mUnicodeRangeMap.get();</span>
<a name="1740"><span class="lineNum">    1740 </span>            :     }</a>
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span><span class="lineCov">          8 :     void SetUnicodeRangeMap(gfxCharacterMap* aUnicodeRangeMap) {</span>
<span class="lineNum">    1743 </span><span class="lineCov">          8 :         mUnicodeRangeMap = aUnicodeRangeMap;</span>
<span class="lineNum">    1744 </span><span class="lineCov">          8 :     }</span>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :     uint16_t GetUVSGlyph(uint32_t aCh, uint32_t aVS) {
<span class="lineNum">    1747 </span>            :         if (!mIsValid) {
<span class="lineNum">    1748 </span>            :             return 0;
<span class="lineNum">    1749 </span>            :         }
<span class="lineNum">    1750 </span>            :         return mFontEntry-&gt;GetUVSGlyph(aCh, aVS); 
<span class="lineNum">    1751 </span>            :     }
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1754 </span>            :     bool InitFakeSmallCapsRun(DrawTarget *aDrawTarget,
<span class="lineNum">    1755 </span>            :                               gfxTextRun *aTextRun,
<span class="lineNum">    1756 </span>            :                               const T    *aText,
<span class="lineNum">    1757 </span>            :                               uint32_t    aOffset,
<span class="lineNum">    1758 </span>            :                               uint32_t    aLength,
<span class="lineNum">    1759 </span>            :                               uint8_t     aMatchType,
<span class="lineNum">    1760 </span>            :                               mozilla::gfx::ShapedTextFlags aOrientation,
<span class="lineNum">    1761 </span>            :                               Script      aScript,
<span class="lineNum">    1762 </span>            :                               bool        aSyntheticLower,
<span class="lineNum">    1763 </span>            :                               bool        aSyntheticUpper);
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            :     // call the (virtual) InitTextRun method to do glyph generation/shaping,
<span class="lineNum">    1766 </span>            :     // limiting the length of text passed by processing the run in multiple
<span class="lineNum">    1767 </span>            :     // segments if necessary
<span class="lineNum">    1768 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1769 </span>            :     bool SplitAndInitTextRun(DrawTarget *aDrawTarget,
<span class="lineNum">    1770 </span>            :                              gfxTextRun *aTextRun,
<span class="lineNum">    1771 </span>            :                              const T *aString,
<span class="lineNum">    1772 </span>            :                              uint32_t aRunStart,
<span class="lineNum">    1773 </span>            :                              uint32_t aRunLength,
<span class="lineNum">    1774 </span>            :                              Script aRunScript,
<span class="lineNum">    1775 </span>            :                              bool aVertical);
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span>            :     // Get a ShapedWord representing the given text (either 8- or 16-bit)
<span class="lineNum">    1778 </span>            :     // for use in setting up a gfxTextRun.
<span class="lineNum">    1779 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1780 </span>            :     gfxShapedWord* GetShapedWord(DrawTarget *aDrawTarget,
<span class="lineNum">    1781 </span>            :                                  const T *aText,
<span class="lineNum">    1782 </span>            :                                  uint32_t aLength,
<span class="lineNum">    1783 </span>            :                                  uint32_t aHash,
<span class="lineNum">    1784 </span>            :                                  Script aRunScript,
<span class="lineNum">    1785 </span>            :                                  bool aVertical,
<span class="lineNum">    1786 </span>            :                                  int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    1787 </span>            :                                  mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    1788 </span>            :                                  RoundingFlags aRounding,
<span class="lineNum">    1789 </span>            :                                  gfxTextPerfMetrics *aTextPerf);
<span class="lineNum">    1790 </span>            : 
<a name="1791"><span class="lineNum">    1791 </span>            :     // Ensure the ShapedWord cache is initialized. This MUST be called before</a>
<span class="lineNum">    1792 </span>            :     // any attempt to use GetShapedWord().
<span class="lineNum">    1793 </span><span class="lineCov">         71 :     void InitWordCache() {</span>
<span class="lineNum">    1794 </span><span class="lineCov">         71 :         if (!mWordCache) {</span>
<span class="lineNum">    1795 </span><span class="lineCov">          2 :             mWordCache = mozilla::MakeUnique&lt;nsTHashtable&lt;CacheHashEntry&gt;&gt;();</span>
<span class="lineNum">    1796 </span>            :         }
<span class="lineNum">    1797 </span><span class="lineCov">         71 :     }</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span>            :     // Called by the gfxFontCache timer to increment the age of all the words,
<span class="lineNum">    1800 </span>            :     // so that they'll expire after a sufficient period of non-use
<span class="lineNum">    1801 </span>            :     void AgeCachedWords();
<a name="1802"><span class="lineNum">    1802 </span>            : </a>
<span class="lineNum">    1803 </span>            :     // Discard all cached word records; called on memory-pressure notification.
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :     void ClearCachedWords() {</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :         if (mWordCache) {</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :             mWordCache-&gt;Clear();</span>
<span class="lineNum">    1807 </span>            :         }
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :     // Glyph rendering/geometry has changed, so invalidate data as necessary.
<span class="lineNum">    1811 </span>            :     void NotifyGlyphsChanged();
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :     virtual void AddSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf,
<span class="lineNum">    1814 </span>            :                                         FontCacheSizes* aSizes) const;
<span class="lineNum">    1815 </span>            :     virtual void AddSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf,
<span class="lineNum">    1816 </span>            :                                         FontCacheSizes* aSizes) const;
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span>            :     typedef enum {
<span class="lineNum">    1819 </span>            :         FONT_TYPE_DWRITE,
<span class="lineNum">    1820 </span>            :         FONT_TYPE_GDI,
<span class="lineNum">    1821 </span>            :         FONT_TYPE_FT2,
<span class="lineNum">    1822 </span>            :         FONT_TYPE_MAC,
<span class="lineNum">    1823 </span>            :         FONT_TYPE_OS2,
<span class="lineNum">    1824 </span>            :         FONT_TYPE_CAIRO,
<span class="lineNum">    1825 </span>            :         FONT_TYPE_FONTCONFIG
<span class="lineNum">    1826 </span>            :     } FontType;
<span class="lineNum">    1827 </span>            : 
<a name="1828"><span class="lineNum">    1828 </span>            :     virtual FontType GetType() const = 0;</a>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span><span class="lineCov">         21 :     const RefPtr&lt;mozilla::gfx::UnscaledFont&gt;&amp; GetUnscaledFont() const {</span>
<span class="lineNum">    1831 </span><span class="lineCov">         21 :         return mUnscaledFont;</span>
<a name="1832"><span class="lineNum">    1832 </span>            :     }</a>
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span><span class="lineCov">         21 :     virtual already_AddRefed&lt;mozilla::gfx::ScaledFont&gt; GetScaledFont(DrawTarget* aTarget)</span>
<span class="lineNum">    1835 </span>            :     {
<span class="lineNum">    1836 </span><span class="lineCov">         21 :         return gfxPlatform::GetPlatform()-&gt;GetScaledFontForFont(aTarget, this);</span>
<span class="lineNum">    1837 </span>            :     }
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span>            :     bool KerningDisabled() {
<span class="lineNum">    1840 </span>            :         return mKerningSet &amp;&amp; !mKerningEnabled;
<span class="lineNum">    1841 </span>            :     }
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span>            :     /**
<span class="lineNum">    1844 </span>            :      * Subclass this object to be notified of glyph changes. Delete the object
<span class="lineNum">    1845 </span>            :      * when no longer needed.
<span class="lineNum">    1846 </span>            :      */
<a name="1847"><span class="lineNum">    1847 </span>            :     class GlyphChangeObserver {</a>
<span class="lineNum">    1848 </span>            :     public:
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :         virtual ~GlyphChangeObserver()</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :             if (mFont) {</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :                 mFont-&gt;RemoveGlyphChangeObserver(this);</span>
<span class="lineNum">    1853 </span>            :             }
<a name="1854"><span class="lineNum">    1854 </span><span class="lineNoCov">          0 :         }</span></a>
<span class="lineNum">    1855 </span>            :         // This gets called when the gfxFont dies.
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :         void ForgetFont() { mFont = nullptr; }</span>
<a name="1857"><span class="lineNum">    1857 </span>            :         virtual void NotifyGlyphsChanged() = 0;</a>
<span class="lineNum">    1858 </span>            :     protected:
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :         explicit GlyphChangeObserver(gfxFont *aFont) : mFont(aFont)</span>
<span class="lineNum">    1860 </span>            :         {
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :             mFont-&gt;AddGlyphChangeObserver(this);</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1863 </span>            :         // This pointer is nulled by ForgetFont in the gfxFont's
<span class="lineNum">    1864 </span>            :         // destructor. Before the gfxFont dies.
<span class="lineNum">    1865 </span>            :         gfxFont* MOZ_NON_OWNING_REF mFont;
<span class="lineNum">    1866 </span>            :     };
<a name="1867"><span class="lineNum">    1867 </span>            :     friend class GlyphChangeObserver;</a>
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span><span class="lineCov">          9 :     bool GlyphsMayChange()</span>
<span class="lineNum">    1870 </span>            :     {
<span class="lineNum">    1871 </span>            :         // Currently only fonts with SVG glyphs can have animated glyphs
<span class="lineNum">    1872 </span><span class="lineCov">          9 :         return mFontEntry-&gt;TryGetSVGData(this);</span>
<a name="1873"><span class="lineNum">    1873 </span>            :     }</a>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :     static void DestroySingletons() {</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         delete sScriptTagToCode;</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         delete sDefaultFeatures;</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :     // Call TryGetMathTable() to try and load the Open Type MATH table.
<span class="lineNum">    1881 </span>            :     // If (and ONLY if) TryGetMathTable() has returned true, the MathTable()
<a name="1882"><span class="lineNum">    1882 </span>            :     // method may be called to access the gfxMathTable data.</a>
<span class="lineNum">    1883 </span>            :     bool          TryGetMathTable();
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     gfxMathTable* MathTable() {</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(mMathTable, &quot;A successful call to TryGetMathTable() must be performed before calling this function&quot;);</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :         return mMathTable.get();</span>
<span class="lineNum">    1887 </span>            :     }
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            :     // Return a cloned font resized and offset to simulate sub/superscript
<span class="lineNum">    1890 </span>            :     // glyphs. This does not add a reference to the returned font.
<span class="lineNum">    1891 </span>            :     gfxFont* GetSubSuperscriptFont(int32_t aAppUnitsPerDevPixel);
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            :     /**
<span class="lineNum">    1894 </span>            :      * Return the reference cairo_t object from aDT.
<span class="lineNum">    1895 </span>            :      */
<span class="lineNum">    1896 </span>            :     static cairo_t* RefCairo(mozilla::gfx::DrawTarget* aDT);
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            : protected:
<span class="lineNum">    1899 </span>            :     virtual const Metrics&amp; GetHorizontalMetrics() = 0;
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            :     mozilla::UniquePtr&lt;const Metrics&gt; CreateVerticalMetrics();
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span>            :     // Output a single glyph at *aPt, which is updated by the glyph's advance.
<span class="lineNum">    1904 </span>            :     // Normal glyphs are simply accumulated in aBuffer until it is full and
<span class="lineNum">    1905 </span>            :     // gets flushed, but SVG or color-font glyphs will instead be rendered
<span class="lineNum">    1906 </span>            :     // directly to the destination (found from the buffer's parameters).
<span class="lineNum">    1907 </span>            :     void DrawOneGlyph(uint32_t           aGlyphID,
<span class="lineNum">    1908 </span>            :                       double             aAdvance,
<span class="lineNum">    1909 </span>            :                       gfxPoint          *aPt,
<span class="lineNum">    1910 </span>            :                       GlyphBufferAzure&amp;  aBuffer,
<span class="lineNum">    1911 </span>            :                       bool              *aEmittedGlyphs) const;
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            :     // Output a run of glyphs at *aPt, which is updated to follow the last glyph
<span class="lineNum">    1914 </span>            :     // in the run. This method also takes account of any letter-spacing provided
<span class="lineNum">    1915 </span>            :     // in aRunParams.
<span class="lineNum">    1916 </span>            :     bool DrawGlyphs(const gfxShapedText      *aShapedText,
<span class="lineNum">    1917 </span>            :                     uint32_t                  aOffset, // offset in the textrun
<span class="lineNum">    1918 </span>            :                     uint32_t                  aCount, // length of run to draw
<span class="lineNum">    1919 </span>            :                     gfxPoint                 *aPt,
<span class="lineNum">    1920 </span>            :                     const TextRunDrawParams&amp;  aRunParams,
<span class="lineNum">    1921 </span>            :                     const FontDrawParams&amp;     aFontParams);
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            :     // set the font size and offset used for
<span class="lineNum">    1924 </span>            :     // synthetic subscript/superscript glyphs
<span class="lineNum">    1925 </span>            :     void CalculateSubSuperSizeAndOffset(int32_t aAppUnitsPerDevPixel,
<span class="lineNum">    1926 </span>            :                                         gfxFloat&amp; aSubSuperSizeRatio,
<span class="lineNum">    1927 </span>            :                                         float&amp; aBaselineOffset);
<span class="lineNum">    1928 </span>            : 
<span class="lineNum">    1929 </span>            :     // Return a font that is a &quot;clone&quot; of this one, but reduced to 80% size
<span class="lineNum">    1930 </span>            :     // (and with variantCaps set to normal). This does not add a reference to
<span class="lineNum">    1931 </span>            :     // the returned font.
<span class="lineNum">    1932 </span>            :     gfxFont* GetSmallCapsFont();
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span>            :     // subclasses may provide (possibly hinted) glyph widths (in font units);
<a name="1935"><span class="lineNum">    1935 </span>            :     // if they do not override this, harfbuzz will use unhinted widths</a>
<span class="lineNum">    1936 </span>            :     // derived from the font tables
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :     virtual bool ProvidesGlyphWidths() const {</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1939 </span>            :     }
<span class="lineNum">    1940 </span>            : 
<a name="1941"><span class="lineNum">    1941 </span>            :     // The return value is interpreted as a horizontal advance in 16.16 fixed</a>
<span class="lineNum">    1942 </span>            :     // point format.
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :     virtual int32_t GetGlyphWidth(DrawTarget&amp; aDrawTarget, uint16_t aGID) {</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    1945 </span>            :     }
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            :     bool IsSpaceGlyphInvisible(DrawTarget* aRefDrawTarget,
<span class="lineNum">    1948 </span>            :                                const gfxTextRun* aTextRun);
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            :     void AddGlyphChangeObserver(GlyphChangeObserver *aObserver);
<span class="lineNum">    1951 </span>            :     void RemoveGlyphChangeObserver(GlyphChangeObserver *aObserver);
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span>            :     // whether font contains substitution lookups containing spaces
<span class="lineNum">    1954 </span>            :     bool HasSubstitutionRulesWithSpaceLookups(Script aRunScript);
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            :     // do spaces participate in shaping rules? if so, can't used word cache
<span class="lineNum">    1957 </span>            :     bool SpaceMayParticipateInShaping(Script aRunScript);
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span>            :     // For 8-bit text, expand to 16-bit and then call the following method.
<span class="lineNum">    1960 </span>            :     bool ShapeText(DrawTarget    *aContext,
<span class="lineNum">    1961 </span>            :                    const uint8_t *aText,
<span class="lineNum">    1962 </span>            :                    uint32_t       aOffset, // dest offset in gfxShapedText
<span class="lineNum">    1963 </span>            :                    uint32_t       aLength,
<span class="lineNum">    1964 </span>            :                    Script         aScript,
<span class="lineNum">    1965 </span>            :                    bool           aVertical,
<span class="lineNum">    1966 </span>            :                    RoundingFlags  aRounding,
<span class="lineNum">    1967 </span>            :                    gfxShapedText *aShapedText); // where to store the result
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            :     // Call the appropriate shaper to generate glyphs for aText and store
<span class="lineNum">    1970 </span>            :     // them into aShapedText.
<span class="lineNum">    1971 </span>            :     virtual bool ShapeText(DrawTarget      *aContext,
<span class="lineNum">    1972 </span>            :                            const char16_t *aText,
<span class="lineNum">    1973 </span>            :                            uint32_t         aOffset,
<span class="lineNum">    1974 </span>            :                            uint32_t         aLength,
<span class="lineNum">    1975 </span>            :                            Script           aScript,
<span class="lineNum">    1976 </span>            :                            bool             aVertical,
<span class="lineNum">    1977 </span>            :                            RoundingFlags    aRounding,
<span class="lineNum">    1978 </span>            :                            gfxShapedText   *aShapedText);
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span>            :     // Helper to adjust for synthetic bold and set character-type flags
<span class="lineNum">    1981 </span>            :     // in the shaped text; implementations of ShapeText should call this
<span class="lineNum">    1982 </span>            :     // after glyph shaping has been completed.
<span class="lineNum">    1983 </span>            :     void PostShapingFixup(DrawTarget*     aContext,
<span class="lineNum">    1984 </span>            :                           const char16_t* aText,
<span class="lineNum">    1985 </span>            :                           uint32_t        aOffset, // position within aShapedText
<span class="lineNum">    1986 </span>            :                           uint32_t        aLength,
<span class="lineNum">    1987 </span>            :                           bool            aVertical,
<span class="lineNum">    1988 </span>            :                           gfxShapedText*  aShapedText);
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            :     // Shape text directly into a range within a textrun, without using the
<span class="lineNum">    1991 </span>            :     // font's word cache. Intended for use when the font has layout features
<span class="lineNum">    1992 </span>            :     // that involve space, and therefore require shaping complete runs rather
<span class="lineNum">    1993 </span>            :     // than isolated words, or for long strings that are inefficient to cache.
<span class="lineNum">    1994 </span>            :     // This will split the text on &quot;invalid&quot; characters (tab/newline) that are
<span class="lineNum">    1995 </span>            :     // not handled via normal shaping, but does not otherwise divide up the
<span class="lineNum">    1996 </span>            :     // text.
<span class="lineNum">    1997 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    1998 </span>            :     bool ShapeTextWithoutWordCache(DrawTarget *aDrawTarget,
<span class="lineNum">    1999 </span>            :                                    const T    *aText,
<span class="lineNum">    2000 </span>            :                                    uint32_t    aOffset,
<span class="lineNum">    2001 </span>            :                                    uint32_t    aLength,
<span class="lineNum">    2002 </span>            :                                    Script      aScript,
<span class="lineNum">    2003 </span>            :                                    bool        aVertical,
<span class="lineNum">    2004 </span>            :                                    RoundingFlags aRounding,
<span class="lineNum">    2005 </span>            :                                    gfxTextRun *aTextRun);
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span>            :     // Shape a fragment of text (a run that is known to contain only
<span class="lineNum">    2008 </span>            :     // &quot;valid&quot; characters, no newlines/tabs/other control chars).
<span class="lineNum">    2009 </span>            :     // All non-wordcache shaping goes through here; this is the function
<span class="lineNum">    2010 </span>            :     // that will ensure we don't pass excessively long runs to the various
<span class="lineNum">    2011 </span>            :     // platform shapers.
<span class="lineNum">    2012 </span>            :     template&lt;typename T&gt;
<span class="lineNum">    2013 </span>            :     bool ShapeFragmentWithoutWordCache(DrawTarget *aDrawTarget,
<span class="lineNum">    2014 </span>            :                                        const T    *aText,
<span class="lineNum">    2015 </span>            :                                        uint32_t    aOffset,
<span class="lineNum">    2016 </span>            :                                        uint32_t    aLength,
<span class="lineNum">    2017 </span>            :                                        Script      aScript,
<span class="lineNum">    2018 </span>            :                                        bool        aVertical,
<span class="lineNum">    2019 </span>            :                                        RoundingFlags aRounding,
<span class="lineNum">    2020 </span>            :                                        gfxTextRun *aTextRun);
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     void CheckForFeaturesInvolvingSpace();
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            :     // whether a given feature is included in feature settings from both the
<span class="lineNum">    2025 </span>            :     // font and the style. aFeatureOn set if resolved feature value is non-zero
<span class="lineNum">    2026 </span>            :     bool HasFeatureSet(uint32_t aFeature, bool&amp; aFeatureOn);
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span>            :     // used when analyzing whether a font has space contextual lookups
<span class="lineNum">    2029 </span>            :     static nsDataHashtable&lt;nsUint32HashKey,Script&gt; *sScriptTagToCode;
<span class="lineNum">    2030 </span>            :     static nsTHashtable&lt;nsUint32HashKey&gt;           *sDefaultFeatures;
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            :     RefPtr&lt;gfxFontEntry&gt; mFontEntry;
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            :     struct CacheHashKey {
<span class="lineNum">    2035 </span>            :         union {
<span class="lineNum">    2036 </span>            :             const uint8_t   *mSingle;
<span class="lineNum">    2037 </span>            :             const char16_t *mDouble;
<span class="lineNum">    2038 </span>            :         }                mText;
<span class="lineNum">    2039 </span>            :         uint32_t         mLength;
<span class="lineNum">    2040 </span>            :         mozilla::gfx::ShapedTextFlags mFlags;
<span class="lineNum">    2041 </span>            :         Script           mScript;
<span class="lineNum">    2042 </span>            :         int32_t          mAppUnitsPerDevUnit;
<span class="lineNum">    2043 </span>            :         PLDHashNumber    mHashKey;
<span class="lineNum">    2044 </span>            :         bool             mTextIs8Bit;
<a name="2045"><span class="lineNum">    2045 </span>            :         RoundingFlags    mRounding;</a>
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineCov">         19 :         CacheHashKey(const uint8_t *aText, uint32_t aLength,</span>
<span class="lineNum">    2048 </span>            :                      uint32_t aStringHash,
<span class="lineNum">    2049 </span>            :                      Script aScriptCode, int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    2050 </span>            :                      mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    2051 </span>            :                      RoundingFlags aRounding)
<span class="lineNum">    2052 </span><span class="lineCov">         19 :             : mLength(aLength),</span>
<span class="lineNum">    2053 </span>            :               mFlags(aFlags),
<span class="lineNum">    2054 </span>            :               mScript(aScriptCode),
<span class="lineNum">    2055 </span>            :               mAppUnitsPerDevUnit(aAppUnitsPerDevUnit),
<span class="lineNum">    2056 </span>            :               mHashKey(aStringHash
<span class="lineNum">    2057 </span><span class="lineCov">         19 :                            + static_cast&lt;int32_t&gt;(aScriptCode)</span>
<span class="lineNum">    2058 </span><span class="lineCov">         19 :                            + aAppUnitsPerDevUnit * 0x100</span>
<span class="lineNum">    2059 </span><span class="lineCov">         38 :                            + uint16_t(aFlags) * 0x10000</span>
<span class="lineNum">    2060 </span><span class="lineCov">         19 :                            + int(aRounding)),</span>
<span class="lineNum">    2061 </span>            :               mTextIs8Bit(true),
<span class="lineNum">    2062 </span><span class="lineCov">         38 :               mRounding(aRounding)</span>
<span class="lineNum">    2063 </span>            :         {
<span class="lineNum">    2064 </span><span class="lineCov">         19 :             NS_ASSERTION(aFlags &amp; mozilla::gfx::ShapedTextFlags::TEXT_IS_8BIT,</span>
<span class="lineNum">    2065 </span>            :                          &quot;8-bit flag should have been set&quot;);
<span class="lineNum">    2066 </span><span class="lineCov">         19 :             mText.mSingle = aText;</span>
<a name="2067"><span class="lineNum">    2067 </span><span class="lineCov">         19 :         }</span></a>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span><span class="lineCov">        108 :         CacheHashKey(const char16_t *aText, uint32_t aLength,</span>
<span class="lineNum">    2070 </span>            :                      uint32_t aStringHash,
<span class="lineNum">    2071 </span>            :                      Script aScriptCode, int32_t aAppUnitsPerDevUnit,
<span class="lineNum">    2072 </span>            :                      mozilla::gfx::ShapedTextFlags aFlags,
<span class="lineNum">    2073 </span>            :                      RoundingFlags aRounding)
<span class="lineNum">    2074 </span><span class="lineCov">        108 :             : mLength(aLength),</span>
<span class="lineNum">    2075 </span>            :               mFlags(aFlags),
<span class="lineNum">    2076 </span>            :               mScript(aScriptCode),
<span class="lineNum">    2077 </span>            :               mAppUnitsPerDevUnit(aAppUnitsPerDevUnit),
<span class="lineNum">    2078 </span>            :               mHashKey(aStringHash
<span class="lineNum">    2079 </span><span class="lineCov">        108 :                            + static_cast&lt;int32_t&gt;(aScriptCode)</span>
<span class="lineNum">    2080 </span><span class="lineCov">        108 :                            + aAppUnitsPerDevUnit * 0x100</span>
<span class="lineNum">    2081 </span><span class="lineCov">        216 :                            + uint16_t(aFlags) * 0x10000</span>
<span class="lineNum">    2082 </span><span class="lineCov">        108 :                            + int(aRounding)),</span>
<span class="lineNum">    2083 </span>            :               mTextIs8Bit(false),
<span class="lineNum">    2084 </span><span class="lineCov">        216 :               mRounding(aRounding)</span>
<span class="lineNum">    2085 </span>            :         {
<span class="lineNum">    2086 </span>            :             // We can NOT assert that TEXT_IS_8BIT is false in aFlags here,
<span class="lineNum">    2087 </span>            :             // because this might be an 8bit-only word from a 16-bit textrun,
<span class="lineNum">    2088 </span>            :             // in which case the text we're passed is still in 16-bit form,
<span class="lineNum">    2089 </span>            :             // and we'll have to use an 8-to-16bit comparison in KeyEquals.
<span class="lineNum">    2090 </span><span class="lineCov">        108 :             mText.mDouble = aText;</span>
<span class="lineNum">    2091 </span><span class="lineCov">        108 :         }</span>
<span class="lineNum">    2092 </span>            :     };
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            :     class CacheHashEntry : public PLDHashEntryHdr {
<span class="lineNum">    2095 </span>            :     public:
<span class="lineNum">    2096 </span>            :         typedef const CacheHashKey &amp;KeyType;
<span class="lineNum">    2097 </span>            :         typedef const CacheHashKey *KeyTypePointer;
<span class="lineNum">    2098 </span>            : 
<a name="2099"><span class="lineNum">    2099 </span>            :         // When constructing a new entry in the hashtable, the caller of Put()</a>
<span class="lineNum">    2100 </span>            :         // will fill us in.
<a name="2101"><span class="lineNum">    2101 </span><span class="lineCov">         32 :         explicit CacheHashEntry(KeyTypePointer aKey) { }</span></a>
<span class="lineNum">    2102 </span>            :         CacheHashEntry(const CacheHashEntry&amp; toCopy) { NS_ERROR(&quot;Should not be called&quot;); }
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         ~CacheHashEntry() { }</span>
<span class="lineNum">    2104 </span>            : 
<a name="2105"><span class="lineNum">    2105 </span>            :         bool KeyEquals(const KeyTypePointer aKey) const;</a>
<span class="lineNum">    2106 </span>            : 
<a name="2107"><span class="lineNum">    2107 </span><span class="lineCov">        127 :         static KeyTypePointer KeyToPointer(KeyType aKey) { return &amp;aKey; }</span></a>
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span><span class="lineCov">        127 :         static PLDHashNumber HashKey(const KeyTypePointer aKey) {</span>
<span class="lineNum">    2110 </span><span class="lineCov">        127 :             return aKey-&gt;mHashKey;</span>
<a name="2111"><span class="lineNum">    2111 </span>            :         }</a>
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :         size_t SizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">    2114 </span>            :         {
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :             return aMallocSizeOf(mShapedWord.get());</span>
<span class="lineNum">    2116 </span>            :         }
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            :         enum { ALLOW_MEMMOVE = true };
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span>            :         mozilla::UniquePtr&lt;gfxShapedWord&gt; mShapedWord;
<span class="lineNum">    2121 </span>            :     };
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            :     mozilla::UniquePtr&lt;nsTHashtable&lt;CacheHashEntry&gt; &gt; mWordCache;
<span class="lineNum">    2124 </span>            : 
<span class="lineNum">    2125 </span>            :     static const uint32_t  kShapedWordCacheMaxAge = 3;
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span>            :     bool                       mIsValid;
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span>            :     // use synthetic bolding for environments where this is not supported
<span class="lineNum">    2130 </span>            :     // by the platform
<span class="lineNum">    2131 </span>            :     bool                       mApplySyntheticBold;
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span>            :     bool                       mKerningSet;     // kerning explicitly set?
<span class="lineNum">    2134 </span>            :     bool                       mKerningEnabled; // if set, on or off?
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            :     bool                       mMathInitialized; // TryGetMathTable() called?
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span>            :     nsExpirationState          mExpirationState;
<span class="lineNum">    2139 </span>            :     gfxFontStyle               mStyle;
<span class="lineNum">    2140 </span>            :     nsTArray&lt;mozilla::UniquePtr&lt;gfxGlyphExtents&gt;&gt; mGlyphExtentsArray;
<span class="lineNum">    2141 </span>            :     mozilla::UniquePtr&lt;nsTHashtable&lt;nsPtrHashKey&lt;GlyphChangeObserver&gt;&gt;&gt;
<span class="lineNum">    2142 </span>            :                                mGlyphChangeObservers;
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span>            :     gfxFloat                   mAdjustedSize;
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            :     // Conversion factor from font units to dev units; note that this may be
<span class="lineNum">    2147 </span>            :     // zero (in the degenerate case where mAdjustedSize has become zero).
<span class="lineNum">    2148 </span>            :     // This is OK because we only multiply by this factor, never divide.
<span class="lineNum">    2149 </span>            :     float                      mFUnitsConvFactor;
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span>            :     // the AA setting requested for this font - may affect glyph bounds
<span class="lineNum">    2152 </span>            :     AntialiasOption            mAntialiasOption;
<span class="lineNum">    2153 </span>            : 
<span class="lineNum">    2154 </span>            :     // a copy of the font without antialiasing, if needed for separate
<span class="lineNum">    2155 </span>            :     // measurement by mathml code
<span class="lineNum">    2156 </span>            :     mozilla::UniquePtr&lt;gfxFont&gt;         mNonAAFont;
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span>            :     // we create either or both of these shapers when needed, depending
<span class="lineNum">    2159 </span>            :     // whether the font has graphite tables, and whether graphite shaping
<span class="lineNum">    2160 </span>            :     // is actually enabled
<span class="lineNum">    2161 </span>            :     mozilla::UniquePtr&lt;gfxFontShaper&gt;   mHarfBuzzShaper;
<span class="lineNum">    2162 </span>            :     mozilla::UniquePtr&lt;gfxFontShaper&gt;   mGraphiteShaper;
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span>            :     // if a userfont with unicode-range specified, contains map of *possible*
<span class="lineNum">    2165 </span>            :     // ranges supported by font
<span class="lineNum">    2166 </span>            :     RefPtr&lt;gfxCharacterMap&gt; mUnicodeRangeMap;
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span>            :     RefPtr&lt;mozilla::gfx::UnscaledFont&gt; mUnscaledFont;
<span class="lineNum">    2169 </span>            :     RefPtr&lt;mozilla::gfx::ScaledFont&gt; mAzureScaledFont;
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span>            :     // For vertical metrics, created on demand.
<span class="lineNum">    2172 </span>            :     mozilla::UniquePtr&lt;const Metrics&gt; mVerticalMetrics;
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span>            :     // Table used for MathML layout.
<span class="lineNum">    2175 </span>            :     mozilla::UniquePtr&lt;gfxMathTable&gt; mMathTable;
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            :     // Helper for subclasses that want to initialize standard metrics from the
<span class="lineNum">    2178 </span>            :     // tables of sfnt (TrueType/OpenType) fonts.
<span class="lineNum">    2179 </span>            :     // This will use mFUnitsConvFactor if it is already set, else compute it
<span class="lineNum">    2180 </span>            :     // from mAdjustedSize and the unitsPerEm in the font's 'head' table.
<span class="lineNum">    2181 </span>            :     // Returns TRUE and sets mIsValid=TRUE if successful;
<span class="lineNum">    2182 </span>            :     // Returns TRUE but leaves mIsValid=FALSE if the font seems to be broken.
<span class="lineNum">    2183 </span>            :     // Returns FALSE if the font does not appear to be an sfnt at all,
<span class="lineNum">    2184 </span>            :     // and should be handled (if possible) using other APIs.
<span class="lineNum">    2185 </span>            :     bool InitMetricsFromSfntTables(Metrics&amp; aMetrics);
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span>            :     // Helper to calculate various derived metrics from the results of
<span class="lineNum">    2188 </span>            :     // InitMetricsFromSfntTables or equivalent platform code
<span class="lineNum">    2189 </span>            :     void CalculateDerivedMetrics(Metrics&amp; aMetrics);
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span>            :     // some fonts have bad metrics, this method sanitize them.
<span class="lineNum">    2192 </span>            :     // if this font has bad underline offset, aIsBadUnderlineFont should be true.
<span class="lineNum">    2193 </span>            :     void SanitizeMetrics(Metrics *aMetrics, bool aIsBadUnderlineFont);
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span>            :     bool RenderSVGGlyph(gfxContext *aContext, gfxPoint aPoint,
<span class="lineNum">    2196 </span>            :                         uint32_t aGlyphId, SVGContextPaint* aContextPaint) const;
<span class="lineNum">    2197 </span>            :     bool RenderSVGGlyph(gfxContext *aContext, gfxPoint aPoint,
<span class="lineNum">    2198 </span>            :                         uint32_t aGlyphId, SVGContextPaint* aContextPaint,
<span class="lineNum">    2199 </span>            :                         gfxTextRunDrawCallbacks *aCallbacks,
<span class="lineNum">    2200 </span>            :                         bool&amp; aEmittedGlyphs) const;
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span>            :     bool RenderColorGlyph(DrawTarget* aDrawTarget,
<span class="lineNum">    2203 </span>            :                           gfxContext* aContext,
<span class="lineNum">    2204 </span>            :                           mozilla::gfx::ScaledFont* scaledFont,
<span class="lineNum">    2205 </span>            :                           mozilla::gfx::GlyphRenderingOptions* renderingOptions,
<span class="lineNum">    2206 </span>            :                           mozilla::gfx::DrawOptions drawOptions,
<span class="lineNum">    2207 </span>            :                           const mozilla::gfx::Point&amp; aPoint,
<span class="lineNum">    2208 </span>            :                           uint32_t aGlyphId) const;
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span>            :     // Bug 674909. When synthetic bolding text by drawing twice, need to
<span class="lineNum">    2211 </span>            :     // render using a pixel offset in device pixels, otherwise text
<span class="lineNum">    2212 </span>            :     // doesn't appear bolded, it appears as if a bad text shadow exists
<span class="lineNum">    2213 </span>            :     // when a non-identity transform exists.  Use an offset factor so that
<span class="lineNum">    2214 </span>            :     // the second draw occurs at a constant offset in device pixels.
<span class="lineNum">    2215 </span>            :     // This helper calculates the scale factor we need to apply to the
<span class="lineNum">    2216 </span>            :     // synthetic-bold offset.
<span class="lineNum">    2217 </span>            :     static double CalcXScale(DrawTarget* aDrawTarget);
<span class="lineNum">    2218 </span>            : };
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span>            : // proportion of ascent used for x-height, if unable to read value from font
<span class="lineNum">    2221 </span>            : #define DEFAULT_XHEIGHT_FACTOR 0.56f
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            : // Parameters passed to gfxFont methods for drawing glyphs from a textrun.
<span class="lineNum">    2224 </span>            : // The TextRunDrawParams are set up once per textrun; the FontDrawParams
<a name="2225"><span class="lineNum">    2225 </span>            : // are dependent on the specific font, so they are set per GlyphRun.</a>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineCov">         42 : struct TextRunDrawParams {</span>
<span class="lineNum">    2228 </span>            :     RefPtr&lt;mozilla::gfx::DrawTarget&gt; dt;
<span class="lineNum">    2229 </span>            :     gfxContext              *context;
<span class="lineNum">    2230 </span>            :     gfxFont::Spacing        *spacing;
<span class="lineNum">    2231 </span>            :     gfxTextRunDrawCallbacks *callbacks;
<span class="lineNum">    2232 </span>            :     mozilla::SVGContextPaint *runContextPaint;
<span class="lineNum">    2233 </span>            :     mozilla::gfx::Color      fontSmoothingBGColor;
<span class="lineNum">    2234 </span>            :     gfxFloat                 direction;
<span class="lineNum">    2235 </span>            :     double                   devPerApp;
<span class="lineNum">    2236 </span>            :     nscolor                  textStrokeColor;
<span class="lineNum">    2237 </span>            :     gfxPattern              *textStrokePattern;
<span class="lineNum">    2238 </span>            :     const mozilla::gfx::StrokeOptions *strokeOpts;
<span class="lineNum">    2239 </span>            :     const mozilla::gfx::DrawOptions   *drawOpts;
<span class="lineNum">    2240 </span>            :     DrawMode                 drawMode;
<span class="lineNum">    2241 </span>            :     bool                     isVerticalRun;
<span class="lineNum">    2242 </span>            :     bool                     isRTL;
<span class="lineNum">    2243 </span>            :     bool                     paintSVGGlyphs;
<a name="2244"><span class="lineNum">    2244 </span>            : };</a>
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span><span class="lineCov">         42 : struct FontDrawParams {</span>
<span class="lineNum">    2247 </span>            :     RefPtr&lt;mozilla::gfx::ScaledFont&gt;            scaledFont;
<span class="lineNum">    2248 </span>            :     RefPtr&lt;mozilla::gfx::GlyphRenderingOptions&gt; renderingOptions;
<span class="lineNum">    2249 </span>            :     mozilla::SVGContextPaint *contextPaint;
<span class="lineNum">    2250 </span>            :     mozilla::gfx::Matrix     *passedInvMatrix;
<span class="lineNum">    2251 </span>            :     mozilla::gfx::Matrix      matInv;
<span class="lineNum">    2252 </span>            :     double                    synBoldOnePixelOffset;
<span class="lineNum">    2253 </span>            :     int32_t                   extraStrikes;
<span class="lineNum">    2254 </span>            :     mozilla::gfx::DrawOptions drawOptions;
<span class="lineNum">    2255 </span>            :     bool                      isVerticalFont;
<span class="lineNum">    2256 </span>            :     bool                      haveSVGGlyphs;
<span class="lineNum">    2257 </span>            :     bool                      haveColorGlyphs;
<span class="lineNum">    2258 </span>            : };
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            : struct EmphasisMarkDrawParams {
<span class="lineNum">    2261 </span>            :     gfxContext* context;
<span class="lineNum">    2262 </span>            :     gfxFont::Spacing* spacing;
<span class="lineNum">    2263 </span>            :     gfxTextRun* mark;
<span class="lineNum">    2264 </span>            :     gfxFloat advance;
<span class="lineNum">    2265 </span>            :     gfxFloat direction;
<span class="lineNum">    2266 </span>            :     bool isVertical;
<span class="lineNum">    2267 </span>            : };
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

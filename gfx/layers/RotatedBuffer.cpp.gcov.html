<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/layers/RotatedBuffer.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/layers</a> - RotatedBuffer.cpp<span style="font-size: 80%;"> (source / <a href="RotatedBuffer.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">223</td>
            <td class="headerCovTableEntry">385</td>
            <td class="headerCovTableEntryLo">57.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryMed">85.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;RotatedBuffer.h&quot;
<span class="lineNum">       7 </span>            : #include &lt;sys/types.h&gt;                  // for int32_t
<span class="lineNum">       8 </span>            : #include &lt;algorithm&gt;                    // for max
<span class="lineNum">       9 </span>            : #include &quot;BasicImplData.h&quot;              // for BasicImplData
<span class="lineNum">      10 </span>            : #include &quot;BasicLayersImpl.h&quot;            // for ToData
<span class="lineNum">      11 </span>            : #include &quot;BufferUnrotate.h&quot;             // for BufferUnrotate
<span class="lineNum">      12 </span>            : #include &quot;GeckoProfiler.h&quot;              // for AUTO_PROFILER_LABEL
<span class="lineNum">      13 </span>            : #include &quot;Layers.h&quot;                     // for PaintedLayer, Layer, etc
<span class="lineNum">      14 </span>            : #include &quot;gfxPlatform.h&quot;                // for gfxPlatform
<span class="lineNum">      15 </span>            : #include &quot;gfxPrefs.h&quot;                   // for gfxPrefs
<span class="lineNum">      16 </span>            : #include &quot;gfxUtils.h&quot;                   // for gfxUtils
<span class="lineNum">      17 </span>            : #include &quot;mozilla/ArrayUtils.h&quot;         // for ArrayLength
<span class="lineNum">      18 </span>            : #include &quot;mozilla/gfx/BasePoint.h&quot;      // for BasePoint
<span class="lineNum">      19 </span>            : #include &quot;mozilla/gfx/BaseRect.h&quot;       // for BaseRect
<span class="lineNum">      20 </span>            : #include &quot;mozilla/gfx/BaseSize.h&quot;       // for BaseSize
<span class="lineNum">      21 </span>            : #include &quot;mozilla/gfx/Matrix.h&quot;         // for Matrix
<span class="lineNum">      22 </span>            : #include &quot;mozilla/gfx/Point.h&quot;          // for Point, IntPoint
<span class="lineNum">      23 </span>            : #include &quot;mozilla/gfx/Rect.h&quot;           // for Rect, IntRect
<span class="lineNum">      24 </span>            : #include &quot;mozilla/gfx/Types.h&quot;          // for ExtendMode::ExtendMode::CLAMP, etc
<span class="lineNum">      25 </span>            : #include &quot;mozilla/layers/ShadowLayers.h&quot;  // for ShadowableLayer
<span class="lineNum">      26 </span>            : #include &quot;mozilla/layers/TextureClient.h&quot;  // for TextureClient
<span class="lineNum">      27 </span>            : #include &quot;mozilla/gfx/Point.h&quot;          // for IntSize
<span class="lineNum">      28 </span>            : #include &quot;gfx2DGlue.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsLayoutUtils.h&quot;              // for invalidation debugging
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : namespace mozilla {
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : using namespace gfx;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : namespace layers {
<a name="36"><span class="lineNum">      36 </span>            : </a>
<span class="lineNum">      37 </span>            : IntRect
<span class="lineNum">      38 </span><span class="lineCov">        286 : RotatedBuffer::GetQuadrantRectangle(XSide aXSide, YSide aYSide) const</span>
<span class="lineNum">      39 </span>            : {
<span class="lineNum">      40 </span>            :   // quadrantTranslation is the amount we translate the top-left
<span class="lineNum">      41 </span>            :   // of the quadrant by to get coordinates relative to the layer
<span class="lineNum">      42 </span><span class="lineCov">        286 :   IntPoint quadrantTranslation = -mBufferRotation;</span>
<span class="lineNum">      43 </span><span class="lineCov">        286 :   quadrantTranslation.x += aXSide == LEFT ? mBufferRect.width : 0;</span>
<span class="lineNum">      44 </span><span class="lineCov">        286 :   quadrantTranslation.y += aYSide == TOP ? mBufferRect.height : 0;</span>
<span class="lineNum">      45 </span><span class="lineCov">        286 :   return mBufferRect + quadrantTranslation;</span>
<span class="lineNum">      46 </span>            : }
<a name="47"><span class="lineNum">      47 </span>            : </a>
<span class="lineNum">      48 </span>            : Rect
<span class="lineNum">      49 </span><span class="lineCov">         14 : RotatedBuffer::GetSourceRectangle(XSide aXSide, YSide aYSide) const</span>
<span class="lineNum">      50 </span>            : {
<span class="lineNum">      51 </span><span class="lineCov">         14 :   Rect result;</span>
<span class="lineNum">      52 </span><span class="lineCov">         14 :   if (aXSide == LEFT) {</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     result.x = 0;</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :     result.width = mBufferRotation.x;</span>
<span class="lineNum">      55 </span>            :   } else {
<span class="lineNum">      56 </span><span class="lineCov">         14 :     result.x = mBufferRotation.x;</span>
<span class="lineNum">      57 </span><span class="lineCov">         14 :     result.width = mBufferRect.width - mBufferRotation.x;</span>
<span class="lineNum">      58 </span>            :   }
<span class="lineNum">      59 </span><span class="lineCov">         14 :   if (aYSide == TOP) {</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     result.y = 0;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     result.height = mBufferRotation.y;</span>
<span class="lineNum">      62 </span>            :   } else {
<span class="lineNum">      63 </span><span class="lineCov">         14 :     result.y = mBufferRotation.y;</span>
<span class="lineNum">      64 </span><span class="lineCov">         14 :     result.height = mBufferRect.height - mBufferRotation.y;</span>
<span class="lineNum">      65 </span>            :   }
<span class="lineNum">      66 </span><span class="lineCov">         14 :   return result;</span>
<span class="lineNum">      67 </span>            : }
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : /**
<span class="lineNum">      70 </span>            :  * @param aXSide LEFT means we draw from the left side of the buffer (which
<span class="lineNum">      71 </span>            :  * is drawn on the right side of mBufferRect). RIGHT means we draw from
<span class="lineNum">      72 </span>            :  * the right side of the buffer (which is drawn on the left side of
<span class="lineNum">      73 </span>            :  * mBufferRect).
<span class="lineNum">      74 </span>            :  * @param aYSide TOP means we draw from the top side of the buffer (which
<span class="lineNum">      75 </span>            :  * is drawn on the bottom side of mBufferRect). BOTTOM means we draw from
<span class="lineNum">      76 </span>            :  * the bottom side of the buffer (which is drawn on the top side of
<span class="lineNum">      77 </span>            :  * mBufferRect).
<a name="78"><span class="lineNum">      78 </span>            :  */</a>
<span class="lineNum">      79 </span>            : void
<span class="lineNum">      80 </span><span class="lineCov">         56 : RotatedBuffer::DrawBufferQuadrant(gfx::DrawTarget* aTarget,</span>
<span class="lineNum">      81 </span>            :                                   XSide aXSide, YSide aYSide,
<span class="lineNum">      82 </span>            :                                   ContextSource aSource,
<span class="lineNum">      83 </span>            :                                   float aOpacity,
<span class="lineNum">      84 </span>            :                                   gfx::CompositionOp aOperator,
<span class="lineNum">      85 </span>            :                                   gfx::SourceSurface* aMask,
<span class="lineNum">      86 </span>            :                                   const gfx::Matrix* aMaskTransform) const
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span>            :   // The rectangle that we're going to fill. Basically we're going to
<span class="lineNum">      89 </span>            :   // render the buffer at mBufferRect + quadrantTranslation to get the
<span class="lineNum">      90 </span>            :   // pixels in the right place, but we're only going to paint within
<span class="lineNum">      91 </span>            :   // mBufferRect
<span class="lineNum">      92 </span><span class="lineCov">         56 :   IntRect quadrantRect = GetQuadrantRectangle(aXSide, aYSide);</span>
<span class="lineNum">      93 </span><span class="lineCov">         56 :   IntRect fillRect;</span>
<span class="lineNum">      94 </span><span class="lineCov">         56 :   if (!fillRect.IntersectRect(mBufferRect, quadrantRect))</span>
<span class="lineNum">      95 </span><span class="lineCov">         84 :     return;</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineCov">         14 :   gfx::Point quadrantTranslation(quadrantRect.x, quadrantRect.y);</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">         14 :   MOZ_ASSERT(aSource != BUFFER_BOTH);</span>
<span class="lineNum">     100 </span><span class="lineCov">         28 :   RefPtr&lt;SourceSurface&gt; snapshot = GetSourceSurface(aSource);</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineCov">         14 :   if (!snapshot) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     gfxCriticalError() &lt;&lt; &quot;Invalid snapshot in RotatedBuffer::DrawBufferQuadrant&quot;;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     105 </span>            :   }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   // direct2d is much slower when using OP_SOURCE so use OP_OVER and
<span class="lineNum">     108 </span>            :   // (maybe) a clear instead. Normally we need to draw in a single operation
<span class="lineNum">     109 </span>            :   // (to avoid flickering) but direct2d is ok since it defers rendering.
<span class="lineNum">     110 </span>            :   // We should try abstract this logic in a helper when we have other use
<span class="lineNum">     111 </span>            :   // cases.
<span class="lineNum">     112 </span><span class="lineCov">         42 :   if ((aTarget-&gt;GetBackendType() == BackendType::DIRECT2D ||</span>
<span class="lineNum">     113 </span><span class="lineCov">         14 :        aTarget-&gt;GetBackendType() == BackendType::DIRECT2D1_1) &amp;&amp;</span>
<span class="lineNum">     114 </span>            :       aOperator == CompositionOp::OP_SOURCE) {
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     aOperator = CompositionOp::OP_OVER;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     if (snapshot-&gt;GetFormat() == SurfaceFormat::B8G8R8A8) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       aTarget-&gt;ClearRect(IntRectToRect(fillRect));</span>
<span class="lineNum">     118 </span>            :     }
<span class="lineNum">     119 </span>            :   }
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :   // OP_SOURCE is unbounded in Azure, and we really don't want that behaviour here.
<span class="lineNum">     122 </span>            :   // We also can't do a ClearRect+FillRect since we need the drawing to happen
<span class="lineNum">     123 </span>            :   // as an atomic operation (to prevent flickering).
<span class="lineNum">     124 </span>            :   // We also need this clip in the case where we have a mask, since the mask surface
<span class="lineNum">     125 </span>            :   // might cover more than fillRect, but we only want to touch the pixels inside
<span class="lineNum">     126 </span>            :   // fillRect.
<span class="lineNum">     127 </span><span class="lineCov">         14 :   aTarget-&gt;PushClipRect(IntRectToRect(fillRect));</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineCov">         14 :   if (aMask) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     Matrix oldTransform = aTarget-&gt;GetTransform();</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     // Transform from user -&gt; buffer space.
<span class="lineNum">     133 </span>            :     Matrix transform =
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       Matrix::Translation(quadrantTranslation.x, quadrantTranslation.y);</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     Matrix inverseMask = *aMaskTransform;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     inverseMask.Invert();</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     transform *= oldTransform;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     transform *= inverseMask;</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : #ifdef MOZ_GFX_OPTIMIZE_MOBILE
<span class="lineNum">     143 </span>            :     SurfacePattern source(snapshot, ExtendMode::CLAMP, transform, SamplingFilter::POINT);
<span class="lineNum">     144 </span>            : #else
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     SurfacePattern source(snapshot, ExtendMode::CLAMP, transform);</span>
<span class="lineNum">     146 </span>            : #endif
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     aTarget-&gt;SetTransform(*aMaskTransform);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     aTarget-&gt;MaskSurface(source, aMask, Point(0, 0), DrawOptions(aOpacity, aOperator));</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     aTarget-&gt;SetTransform(oldTransform);</span>
<span class="lineNum">     151 </span>            :   } else {
<span class="lineNum">     152 </span>            : #ifdef MOZ_GFX_OPTIMIZE_MOBILE
<span class="lineNum">     153 </span>            :     DrawSurfaceOptions options(SamplingFilter::POINT);
<span class="lineNum">     154 </span>            : #else
<span class="lineNum">     155 </span><span class="lineCov">         14 :     DrawSurfaceOptions options;</span>
<span class="lineNum">     156 </span>            : #endif
<span class="lineNum">     157 </span><span class="lineCov">         28 :     aTarget-&gt;DrawSurface(snapshot, IntRectToRect(fillRect),</span>
<span class="lineNum">     158 </span><span class="lineCov">         28 :                          GetSourceRectangle(aXSide, aYSide),</span>
<span class="lineNum">     159 </span>            :                          options,
<span class="lineNum">     160 </span><span class="lineCov">         42 :                          DrawOptions(aOpacity, aOperator));</span>
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">         14 :   aTarget-&gt;PopClip();</span>
<span class="lineNum">     164 </span>            : }
<a name="165"><span class="lineNum">     165 </span>            : </a>
<span class="lineNum">     166 </span>            : void
<span class="lineNum">     167 </span><span class="lineCov">         14 : RotatedBuffer::DrawBufferWithRotation(gfx::DrawTarget *aTarget, ContextSource aSource,</span>
<span class="lineNum">     168 </span>            :                                       float aOpacity,
<span class="lineNum">     169 </span>            :                                       gfx::CompositionOp aOperator,
<span class="lineNum">     170 </span>            :                                       gfx::SourceSurface* aMask,
<span class="lineNum">     171 </span>            :                                       const gfx::Matrix* aMaskTransform) const
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span><span class="lineCov">         28 :   AUTO_PROFILER_LABEL(&quot;RotatedBuffer::DrawBufferWithRotation&quot;, GRAPHICS);</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   // See above, in Azure Repeat should always be a safe, even faster choice
<span class="lineNum">     176 </span>            :   // though! Particularly on D2D Repeat should be a lot faster, need to look
<span class="lineNum">     177 </span>            :   // into that. TODO[Bas]
<span class="lineNum">     178 </span><span class="lineCov">         14 :   DrawBufferQuadrant(aTarget, LEFT, TOP, aSource, aOpacity, aOperator, aMask, aMaskTransform);</span>
<span class="lineNum">     179 </span><span class="lineCov">         14 :   DrawBufferQuadrant(aTarget, RIGHT, TOP, aSource, aOpacity, aOperator, aMask, aMaskTransform);</span>
<span class="lineNum">     180 </span><span class="lineCov">         14 :   DrawBufferQuadrant(aTarget, LEFT, BOTTOM, aSource, aOpacity, aOperator, aMask, aMaskTransform);</span>
<span class="lineNum">     181 </span><span class="lineCov">         14 :   DrawBufferQuadrant(aTarget, RIGHT, BOTTOM, aSource, aOpacity, aOperator,aMask, aMaskTransform);</span>
<span class="lineNum">     182 </span><span class="lineCov">         14 : }</span>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<span class="lineNum">     184 </span>            : already_AddRefed&lt;SourceSurface&gt;
<span class="lineNum">     185 </span><span class="lineCov">         13 : SourceRotatedBuffer::GetSourceSurface(ContextSource aSource) const</span>
<span class="lineNum">     186 </span>            : {
<span class="lineNum">     187 </span><span class="lineCov">         26 :   RefPtr&lt;SourceSurface&gt; surf;</span>
<span class="lineNum">     188 </span><span class="lineCov">         13 :   if (aSource == BUFFER_BLACK) {</span>
<span class="lineNum">     189 </span><span class="lineCov">         13 :     surf = mSource;</span>
<span class="lineNum">     190 </span>            :   } else {
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aSource == BUFFER_WHITE);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     surf = mSourceOnWhite;</span>
<span class="lineNum">     193 </span>            :   }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineCov">         13 :   MOZ_ASSERT(surf);</span>
<span class="lineNum">     196 </span><span class="lineCov">         26 :   return surf.forget();</span>
<span class="lineNum">     197 </span>            : }
<a name="198"><span class="lineNum">     198 </span>            : </a>
<span class="lineNum">     199 </span>            : /* static */ bool
<span class="lineNum">     200 </span><span class="lineCov">         13 : RotatedContentBuffer::IsClippingCheap(DrawTarget* aTarget, const nsIntRegion&amp; aRegion)</span>
<span class="lineNum">     201 </span>            : {
<span class="lineNum">     202 </span>            :   // Assume clipping is cheap if the draw target just has an integer
<span class="lineNum">     203 </span>            :   // translation, and the visible region is simple.
<span class="lineNum">     204 </span><span class="lineCov">         52 :   return !aTarget-&gt;GetTransform().HasNonIntegerTranslation() &amp;&amp;</span>
<span class="lineNum">     205 </span><span class="lineCov">         39 :          aRegion.GetNumRects() &lt;= 1;</span>
<span class="lineNum">     206 </span>            : }
<a name="207"><span class="lineNum">     207 </span>            : </a>
<span class="lineNum">     208 </span>            : void
<span class="lineNum">     209 </span><span class="lineNoCov">          0 : RotatedContentBuffer::DrawTo(PaintedLayer* aLayer,</span>
<span class="lineNum">     210 </span>            :                              DrawTarget* aTarget,
<span class="lineNum">     211 </span>            :                              float aOpacity,
<span class="lineNum">     212 </span>            :                              CompositionOp aOp,
<span class="lineNum">     213 </span>            :                              SourceSurface* aMask,
<span class="lineNum">     214 </span>            :                              const Matrix* aMaskTransform)
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   if (!EnsureBuffer()) {</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     218 </span>            :   }
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   bool clipped = false;</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // If the entire buffer is valid, we can just draw the whole thing,
<span class="lineNum">     223 </span>            :   // no need to clip. But we'll still clip if clipping is cheap ---
<span class="lineNum">     224 </span>            :   // that might let us copy a smaller region of the buffer.
<span class="lineNum">     225 </span>            :   // Also clip to the visible region if we're told to.
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   if (!aLayer-&gt;GetValidRegion().Contains(BufferRect()) ||</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       (ToData(aLayer)-&gt;GetClipToVisibleRegion() &amp;&amp;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :        !aLayer-&gt;GetVisibleRegion().ToUnknownRegion().Contains(BufferRect())) ||</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :       IsClippingCheap(aTarget, aLayer-&gt;GetLocalVisibleRegion().ToUnknownRegion())) {</span>
<span class="lineNum">     230 </span>            :     // We don't want to draw invalid stuff, so we need to clip. Might as
<span class="lineNum">     231 </span>            :     // well clip to the smallest area possible --- the visible region.
<span class="lineNum">     232 </span>            :     // Bug 599189 if there is a non-integer-translation transform in aTarget,
<span class="lineNum">     233 </span>            :     // we might sample pixels outside GetLocalVisibleRegion(), which is wrong
<span class="lineNum">     234 </span>            :     // and may cause gray lines.
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     gfxUtils::ClipToRegion(aTarget, aLayer-&gt;GetLocalVisibleRegion().ToUnknownRegion());</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     clipped = true;</span>
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   DrawBufferWithRotation(aTarget, BUFFER_BLACK, aOpacity, aOp, aMask, aMaskTransform);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   if (clipped) {</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     aTarget-&gt;PopClip();</span>
<span class="lineNum">     242 </span>            :   }
<span class="lineNum">     243 </span>            : }
<a name="244"><span class="lineNum">     244 </span>            : </a>
<span class="lineNum">     245 </span>            : DrawTarget*
<span class="lineNum">     246 </span><span class="lineCov">         92 : RotatedContentBuffer::BorrowDrawTargetForQuadrantUpdate(const IntRect&amp; aBounds,</span>
<span class="lineNum">     247 </span>            :                                                         ContextSource aSource,
<span class="lineNum">     248 </span>            :                                                         DrawIterator* aIter)
<span class="lineNum">     249 </span>            : {
<span class="lineNum">     250 </span><span class="lineCov">         92 :   IntRect bounds = aBounds;</span>
<span class="lineNum">     251 </span><span class="lineCov">         92 :   if (aIter) {</span>
<span class="lineNum">     252 </span>            :     // If an iterator was provided, then BeginPaint must have been run with
<span class="lineNum">     253 </span>            :     // PAINT_CAN_DRAW_ROTATED, and the draw region might cover multiple quadrants.
<span class="lineNum">     254 </span>            :     // Iterate over each of them, and return an appropriate buffer each time we find
<span class="lineNum">     255 </span>            :     // one that intersects the draw region. The iterator mCount value tracks which
<span class="lineNum">     256 </span>            :     // quadrants we have considered across multiple calls to this function.
<span class="lineNum">     257 </span><span class="lineCov">         92 :     aIter-&gt;mDrawRegion.SetEmpty();</span>
<span class="lineNum">     258 </span><span class="lineCov">        368 :     while (aIter-&gt;mCount &lt; 4) {</span>
<span class="lineNum">     259 </span><span class="lineCov">        184 :       IntRect quadrant = GetQuadrantRectangle((aIter-&gt;mCount &amp; 1) ? LEFT : RIGHT,</span>
<span class="lineNum">     260 </span><span class="lineCov">        368 :         (aIter-&gt;mCount &amp; 2) ? TOP : BOTTOM);</span>
<span class="lineNum">     261 </span><span class="lineCov">        184 :       aIter-&gt;mDrawRegion.And(aBounds, quadrant);</span>
<span class="lineNum">     262 </span><span class="lineCov">        184 :       aIter-&gt;mCount++;</span>
<span class="lineNum">     263 </span><span class="lineCov">        184 :       if (!aIter-&gt;mDrawRegion.IsEmpty()) {</span>
<span class="lineNum">     264 </span><span class="lineCov">         46 :         break;</span>
<span class="lineNum">     265 </span>            :       }
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineCov">         92 :     if (aIter-&gt;mDrawRegion.IsEmpty()) {</span>
<span class="lineNum">     268 </span><span class="lineCov">         46 :       return nullptr;</span>
<span class="lineNum">     269 </span>            :     }
<span class="lineNum">     270 </span><span class="lineCov">         46 :     bounds = aIter-&gt;mDrawRegion.GetBounds();</span>
<span class="lineNum">     271 </span>            :   }
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineCov">         46 :   if (!EnsureBuffer()) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     275 </span>            :   }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">         46 :   MOZ_ASSERT(!mLoanedDrawTarget, &quot;draw target has been borrowed and not returned&quot;);</span>
<span class="lineNum">     278 </span><span class="lineCov">         46 :   if (aSource == BUFFER_BOTH &amp;&amp; HaveBufferOnWhite()) {</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     if (!EnsureBufferOnWhite()) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid() &amp;&amp; mDTBufferOnWhite &amp;&amp; mDTBufferOnWhite-&gt;IsValid());</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     mLoanedDrawTarget = Factory::CreateDualDrawTarget(mDTBuffer, mDTBufferOnWhite);</span>
<span class="lineNum">     284 </span><span class="lineCov">         46 :   } else if (aSource == BUFFER_WHITE) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if (!EnsureBufferOnWhite()) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     mLoanedDrawTarget = mDTBufferOnWhite;</span>
<span class="lineNum">     289 </span>            :   } else {
<span class="lineNum">     290 </span>            :     // BUFFER_BLACK, or BUFFER_BOTH with a single buffer.
<span class="lineNum">     291 </span><span class="lineCov">         46 :     mLoanedDrawTarget = mDTBuffer;</span>
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   // Figure out which quadrant to draw in
<span class="lineNum">     295 </span><span class="lineCov">         46 :   int32_t xBoundary = mBufferRect.XMost() - mBufferRotation.x;</span>
<span class="lineNum">     296 </span><span class="lineCov">         46 :   int32_t yBoundary = mBufferRect.YMost() - mBufferRotation.y;</span>
<span class="lineNum">     297 </span><span class="lineCov">         46 :   XSide sideX = bounds.XMost() &lt;= xBoundary ? RIGHT : LEFT;</span>
<span class="lineNum">     298 </span><span class="lineCov">         46 :   YSide sideY = bounds.YMost() &lt;= yBoundary ? BOTTOM : TOP;</span>
<span class="lineNum">     299 </span><span class="lineCov">         46 :   IntRect quadrantRect = GetQuadrantRectangle(sideX, sideY);</span>
<span class="lineNum">     300 </span><span class="lineCov">         46 :   NS_ASSERTION(quadrantRect.Contains(bounds), &quot;Messed up quadrants&quot;);</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">         46 :   mLoanedTransform = mLoanedDrawTarget-&gt;GetTransform();</span>
<span class="lineNum">     303 </span><span class="lineCov">        138 :   mLoanedDrawTarget-&gt;SetTransform(Matrix(mLoanedTransform).</span>
<span class="lineNum">     304 </span><span class="lineCov">         46 :                                     PreTranslate(-quadrantRect.x,</span>
<span class="lineNum">     305 </span><span class="lineCov">        138 :                                                  -quadrantRect.y));</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineCov">         46 :   return mLoanedDrawTarget;</span>
<span class="lineNum">     308 </span>            : }
<a name="309"><span class="lineNum">     309 </span>            : </a>
<span class="lineNum">     310 </span>            : void
<span class="lineNum">     311 </span><span class="lineCov">         46 : BorrowDrawTarget::ReturnDrawTarget(gfx::DrawTarget*&amp; aReturned)</span>
<span class="lineNum">     312 </span>            : {
<span class="lineNum">     313 </span><span class="lineCov">         46 :   MOZ_ASSERT(mLoanedDrawTarget);</span>
<span class="lineNum">     314 </span><span class="lineCov">         46 :   MOZ_ASSERT(aReturned == mLoanedDrawTarget);</span>
<span class="lineNum">     315 </span><span class="lineCov">         46 :   if (mLoanedDrawTarget) {</span>
<span class="lineNum">     316 </span><span class="lineCov">         46 :     mLoanedDrawTarget-&gt;SetTransform(mLoanedTransform);</span>
<span class="lineNum">     317 </span><span class="lineCov">         46 :     mLoanedDrawTarget = nullptr;</span>
<span class="lineNum">     318 </span>            :   }
<span class="lineNum">     319 </span><span class="lineCov">         46 :   aReturned = nullptr;</span>
<span class="lineNum">     320 </span><span class="lineCov">         46 : }</span>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<span class="lineNum">     322 </span>            : gfxContentType
<span class="lineNum">     323 </span><span class="lineCov">        103 : RotatedContentBuffer::BufferContentType()</span>
<span class="lineNum">     324 </span>            : {
<span class="lineNum">     325 </span><span class="lineCov">        103 :   if (mBufferProvider || (mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid())) {</span>
<span class="lineNum">     326 </span><span class="lineCov">        103 :     SurfaceFormat format = SurfaceFormat::B8G8R8A8;</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineCov">        103 :     if (mBufferProvider) {</span>
<span class="lineNum">     329 </span><span class="lineCov">        103 :       format = mBufferProvider-&gt;GetFormat();</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     } else if (mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid()) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :       format = mDTBuffer-&gt;GetFormat();</span>
<span class="lineNum">     332 </span>            :     }
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineCov">        103 :     return ContentForFormat(format);</span>
<span class="lineNum">     335 </span>            :   }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   return gfxContentType::SENTINEL;</span>
<span class="lineNum">     337 </span>            : }
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : bool
<span class="lineNum">     340 </span><span class="lineCov">         77 : RotatedContentBuffer::BufferSizeOkFor(const IntSize&amp; aSize)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span><span class="lineCov">        308 :   return (aSize == mBufferRect.Size() ||</span>
<span class="lineNum">     343 </span><span class="lineCov">         15 :           (SizedToVisibleBounds != mBufferSizePolicy &amp;&amp;</span>
<span class="lineNum">     344 </span><span class="lineCov">        164 :            aSize &lt; mBufferRect.Size()));</span>
<span class="lineNum">     345 </span>            : }
<a name="346"><span class="lineNum">     346 </span>            : </a>
<span class="lineNum">     347 </span>            : bool
<span class="lineNum">     348 </span><span class="lineCov">         75 : RotatedContentBuffer::EnsureBuffer()</span>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineCov">         75 :   NS_ASSERTION(!mLoanedDrawTarget, &quot;Loaned draw target must be returned&quot;);</span>
<span class="lineNum">     351 </span><span class="lineCov">         75 :   if (!mDTBuffer || !mDTBuffer-&gt;IsValid()) {</span>
<span class="lineNum">     352 </span><span class="lineCov">         29 :     if (mBufferProvider) {</span>
<span class="lineNum">     353 </span><span class="lineCov">         29 :       mDTBuffer = mBufferProvider-&gt;BorrowDrawTarget();</span>
<span class="lineNum">     354 </span>            :     }
<span class="lineNum">     355 </span>            :   }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">         75 :   NS_WARNING_ASSERTION(mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid(), &quot;no buffer&quot;);</span>
<span class="lineNum">     358 </span><span class="lineCov">         75 :   return !!mDTBuffer;</span>
<span class="lineNum">     359 </span>            : }
<a name="360"><span class="lineNum">     360 </span>            : </a>
<span class="lineNum">     361 </span>            : bool
<span class="lineNum">     362 </span><span class="lineNoCov">          0 : RotatedContentBuffer::EnsureBufferOnWhite()</span>
<span class="lineNum">     363 </span>            : {
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!mLoanedDrawTarget, &quot;Loaned draw target must be returned&quot;);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (!mDTBufferOnWhite) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     if (mBufferProviderOnWhite) {</span>
<span class="lineNum">     367 </span>            :       mDTBufferOnWhite =
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         mBufferProviderOnWhite-&gt;BorrowDrawTarget();</span>
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            :   }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   NS_WARNING_ASSERTION(mDTBufferOnWhite, &quot;no buffer&quot;);</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   return !!mDTBufferOnWhite;</span>
<span class="lineNum">     374 </span>            : }
<a name="375"><span class="lineNum">     375 </span>            : </a>
<span class="lineNum">     376 </span>            : bool
<span class="lineNum">     377 </span><span class="lineCov">        236 : RotatedContentBuffer::HaveBuffer() const</span>
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span><span class="lineCov">        236 :   return mBufferProvider || (mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid());</span>
<span class="lineNum">     380 </span>            : }
<a name="381"><span class="lineNum">     381 </span>            : </a>
<span class="lineNum">     382 </span>            : bool
<span class="lineNum">     383 </span><span class="lineCov">        136 : RotatedContentBuffer::HaveBufferOnWhite() const</span>
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span><span class="lineCov">        136 :   return mBufferProviderOnWhite || (mDTBufferOnWhite &amp;&amp; mDTBufferOnWhite-&gt;IsValid());</span>
<span class="lineNum">     386 </span>            : }
<a name="387"><span class="lineNum">     387 </span>            : </a>
<span class="lineNum">     388 </span>            : static void
<span class="lineNum">     389 </span><span class="lineCov">         56 : WrapRotationAxis(int32_t* aRotationPoint, int32_t aSize)</span>
<span class="lineNum">     390 </span>            : {
<span class="lineNum">     391 </span><span class="lineCov">         56 :   if (*aRotationPoint &lt; 0) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     *aRotationPoint += aSize;</span>
<span class="lineNum">     393 </span><span class="lineCov">         56 :   } else if (*aRotationPoint &gt;= aSize) {</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     *aRotationPoint -= aSize;</span>
<span class="lineNum">     395 </span>            :   }
<span class="lineNum">     396 </span><span class="lineCov">         56 : }</span>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<span class="lineNum">     398 </span>            : static IntRect
<span class="lineNum">     399 </span><span class="lineCov">         26 : ComputeBufferRect(const IntRect&amp; aRequestedRect)</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineCov">         26 :   IntRect rect(aRequestedRect);</span>
<span class="lineNum">     402 </span>            :   // Set a minimum width to guarantee a minimum size of buffers we
<span class="lineNum">     403 </span>            :   // allocate (and work around problems on some platforms with smaller
<span class="lineNum">     404 </span>            :   // dimensions). 64 used to be the magic number needed to work around
<span class="lineNum">     405 </span>            :   // a rendering glitch on b2g (see bug 788411). Now that we don't support
<span class="lineNum">     406 </span>            :   // this device anymore we should be fine with 8 pixels as the minimum.
<span class="lineNum">     407 </span><span class="lineCov">         26 :   rect.width = std::max(aRequestedRect.width, 8);</span>
<span class="lineNum">     408 </span><span class="lineCov">         26 :   return rect;</span>
<span class="lineNum">     409 </span>            : }
<a name="410"><span class="lineNum">     410 </span>            : </a>
<span class="lineNum">     411 </span>            : void
<span class="lineNum">     412 </span><span class="lineNoCov">          0 : RotatedContentBuffer::FlushBuffers()</span>
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   if (mDTBuffer) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     mDTBuffer-&gt;Flush();</span>
<span class="lineNum">     416 </span>            :   }
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   if (mDTBufferOnWhite) {</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     mDTBufferOnWhite-&gt;Flush();</span>
<span class="lineNum">     419 </span>            :   }
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : }</span>
<a name="421"><span class="lineNum">     421 </span>            : </a>
<span class="lineNum">     422 </span>            : RotatedContentBuffer::PaintState
<span class="lineNum">     423 </span><span class="lineCov">         77 : RotatedContentBuffer::BeginPaint(PaintedLayer* aLayer,</span>
<span class="lineNum">     424 </span>            :                                  uint32_t aFlags)
<span class="lineNum">     425 </span>            : {
<span class="lineNum">     426 </span><span class="lineCov">         77 :   PaintState result;</span>
<span class="lineNum">     427 </span>            :   // We need to disable rotation if we're going to be resampled when
<span class="lineNum">     428 </span>            :   // drawing, because we might sample across the rotation boundary.
<span class="lineNum">     429 </span>            :   // Also disable buffer rotation when using webrender.
<span class="lineNum">     430 </span><span class="lineCov">        154 :   bool canHaveRotation = gfxPlatform::BufferRotationEnabled() &amp;&amp;</span>
<span class="lineNum">     431 </span><span class="lineCov">        154 :                          !(aFlags &amp; (PAINT_WILL_RESAMPLE | PAINT_NO_ROTATION)) &amp;&amp;</span>
<span class="lineNum">     432 </span><span class="lineCov">        154 :                          !(aLayer-&gt;Manager()-&gt;AsWebRenderLayerManager());</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">        154 :   nsIntRegion validRegion = aLayer-&gt;GetValidRegion();</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">         77 :   bool canUseOpaqueSurface = aLayer-&gt;CanUseOpaqueSurface();</span>
<span class="lineNum">     437 </span>            :   ContentType layerContentType =
<span class="lineNum">     438 </span><span class="lineCov">         77 :     canUseOpaqueSurface ? gfxContentType::COLOR :</span>
<span class="lineNum">     439 </span><span class="lineCov">         77 :                           gfxContentType::COLOR_ALPHA;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :   SurfaceMode mode;
<span class="lineNum">     442 </span><span class="lineCov">        154 :   nsIntRegion neededRegion;</span>
<span class="lineNum">     443 </span><span class="lineCov">         77 :   IntRect destBufferRect;</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineCov">         77 :   bool canReuseBuffer = HaveBuffer();</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   while (true) {
<span class="lineNum">     448 </span><span class="lineCov">         77 :     mode = aLayer-&gt;GetSurfaceMode();</span>
<span class="lineNum">     449 </span><span class="lineCov">         77 :     neededRegion = aLayer-&gt;GetVisibleRegion().ToUnknownRegion();</span>
<span class="lineNum">     450 </span><span class="lineCov">         77 :     canReuseBuffer &amp;= BufferSizeOkFor(neededRegion.GetBounds().Size());</span>
<span class="lineNum">     451 </span><span class="lineCov">         77 :     result.mContentType = layerContentType;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">         77 :     if (canReuseBuffer) {</span>
<span class="lineNum">     454 </span><span class="lineCov">         51 :       if (mBufferRect.Contains(neededRegion.GetBounds())) {</span>
<span class="lineNum">     455 </span>            :         // We don't need to adjust mBufferRect.
<span class="lineNum">     456 </span><span class="lineCov">         51 :         destBufferRect = mBufferRect;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       } else if (neededRegion.GetBounds().Size() &lt;= mBufferRect.Size()) {</span>
<span class="lineNum">     458 </span>            :         // The buffer's big enough but doesn't contain everything that's
<span class="lineNum">     459 </span>            :         // going to be visible. We'll move it.
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         destBufferRect = IntRect(neededRegion.GetBounds().TopLeft(), mBufferRect.Size());</span>
<span class="lineNum">     461 </span>            :       } else {
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         destBufferRect = neededRegion.GetBounds();</span>
<span class="lineNum">     463 </span>            :       }
<span class="lineNum">     464 </span>            :     } else {
<span class="lineNum">     465 </span>            :       // We won't be reusing the buffer.  Compute a new rect.
<span class="lineNum">     466 </span><span class="lineCov">         26 :       destBufferRect = ComputeBufferRect(neededRegion.GetBounds());</span>
<span class="lineNum">     467 </span>            :     }
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineCov">         77 :     if (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     470 </span>            : #if defined(MOZ_GFX_OPTIMIZE_MOBILE)
<span class="lineNum">     471 </span>            :       mode = SurfaceMode::SURFACE_SINGLE_CHANNEL_ALPHA;
<span class="lineNum">     472 </span>            : #else
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :       if (!aLayer-&gt;GetParent() ||</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :           !aLayer-&gt;GetParent()-&gt;SupportsComponentAlphaChildren() ||</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :           !aLayer-&gt;AsShadowableLayer() ||</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :           !aLayer-&gt;AsShadowableLayer()-&gt;HasShadow()) {</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         mode = SurfaceMode::SURFACE_SINGLE_CHANNEL_ALPHA;</span>
<span class="lineNum">     478 </span>            :       } else {
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         result.mContentType = gfxContentType::COLOR;</span>
<span class="lineNum">     480 </span>            :       }
<span class="lineNum">     481 </span>            : #endif
<span class="lineNum">     482 </span>            :     }
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineCov">        231 :     if ((aFlags &amp; PAINT_WILL_RESAMPLE) &amp;&amp;</span>
<span class="lineNum">     485 </span><span class="lineCov">         77 :         (!neededRegion.GetBounds().IsEqualInterior(destBufferRect) ||</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :          neededRegion.GetNumRects() &gt; 1))</span>
<span class="lineNum">     487 </span>            :     {
<span class="lineNum">     488 </span>            :       // The area we add to neededRegion might not be painted opaquely.
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       if (mode == SurfaceMode::SURFACE_OPAQUE) {</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         result.mContentType = gfxContentType::COLOR_ALPHA;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         mode = SurfaceMode::SURFACE_SINGLE_CHANNEL_ALPHA;</span>
<span class="lineNum">     492 </span>            :       }
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :       // We need to validate the entire buffer, to make sure that only valid
<span class="lineNum">     495 </span>            :       // pixels are sampled.
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :       neededRegion = destBufferRect;</span>
<span class="lineNum">     497 </span>            :     }
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :     // If we have an existing buffer, but the content type has changed or we
<span class="lineNum">     500 </span>            :     // have transitioned into/out of component alpha, then we need to recreate it.
<span class="lineNum">     501 </span><span class="lineCov">        128 :     if (canReuseBuffer &amp;&amp;</span>
<span class="lineNum">     502 </span><span class="lineCov">        102 :         (result.mContentType != BufferContentType() ||</span>
<span class="lineNum">     503 </span><span class="lineCov">         51 :         (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) != HaveBufferOnWhite()))</span>
<span class="lineNum">     504 </span>            :     {
<span class="lineNum">     505 </span>            :       // Restart the decision process; we won't re-enter since we guard on
<span class="lineNum">     506 </span>            :       // being able to re-use the buffer.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :       canReuseBuffer = false;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     509 </span>            :     }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">         77 :     break;</span>
<span class="lineNum">     512 </span>            :   }
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineCov">        129 :   if (HaveBuffer() &amp;&amp;</span>
<span class="lineNum">     515 </span><span class="lineCov">        104 :       (result.mContentType != BufferContentType() ||</span>
<span class="lineNum">     516 </span><span class="lineCov">         52 :       (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) != HaveBufferOnWhite()))</span>
<span class="lineNum">     517 </span>            :   {
<span class="lineNum">     518 </span>            :     // We're effectively clearing the valid region, so we need to draw
<span class="lineNum">     519 </span>            :     // the entire needed region now.
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     canReuseBuffer = false;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     result.mRegionToInvalidate = aLayer-&gt;GetValidRegion();</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     validRegion.SetEmpty();</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     Clear();</span>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : #if defined(MOZ_DUMP_PAINTING)
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     if (nsLayoutUtils::InvalidationDebuggingIsEnabled()) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       if (result.mContentType != BufferContentType()) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         printf_stderr(&quot;Invalidating entire rotated buffer (layer %p): content type changed\n&quot;, aLayer);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       } else if ((mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) != HaveBufferOnWhite()) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         printf_stderr(&quot;Invalidating entire rotated buffer (layer %p): component alpha changed\n&quot;, aLayer);</span>
<span class="lineNum">     531 </span>            :       }
<span class="lineNum">     532 </span>            :     }
<span class="lineNum">     533 </span>            : #endif
<span class="lineNum">     534 </span>            :   }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineCov">         77 :   NS_ASSERTION(destBufferRect.Contains(neededRegion.GetBounds()),</span>
<span class="lineNum">     537 </span>            :                &quot;Destination rect doesn't contain what we need to paint&quot;);
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">         77 :   result.mRegionToDraw.Sub(neededRegion, validRegion);</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span><span class="lineCov">         77 :   if (result.mRegionToDraw.IsEmpty())</span>
<span class="lineNum">     542 </span><span class="lineCov">         44 :     return result;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineCov">         33 :   if (HaveBuffer()) {</span>
<span class="lineNum">     545 </span><span class="lineCov">         29 :     if (LockBuffers()) {</span>
<span class="lineNum">     546 </span>            :       // Do not modify result.mRegionToDraw or result.mContentType after this call.
<span class="lineNum">     547 </span>            :       // Do not modify mBufferRect, mBufferRotation, or mDidSelfCopy,
<span class="lineNum">     548 </span>            :       // or call CreateBuffer before this call.
<span class="lineNum">     549 </span><span class="lineCov">         29 :       FinalizeFrame(result.mRegionToDraw);</span>
<span class="lineNum">     550 </span>            :     } else {
<span class="lineNum">     551 </span>            :       // Abandon everything and redraw it all. Ideally we'd reallocate and copy
<span class="lineNum">     552 </span>            :       // the old to the new and then call FinalizeFrame on the new buffer so that
<span class="lineNum">     553 </span>            :       // we only need to draw the latest bits, but we need a big refactor to support
<span class="lineNum">     554 </span>            :       // that ordering.
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       result.mRegionToDraw = neededRegion;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       canReuseBuffer = false;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       Clear();</span>
<span class="lineNum">     558 </span>            :     }
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineCov">         33 :   IntRect drawBounds = result.mRegionToDraw.GetBounds();</span>
<span class="lineNum">     562 </span><span class="lineCov">         66 :   RefPtr&lt;DrawTarget&gt; destDTBuffer;</span>
<span class="lineNum">     563 </span><span class="lineCov">         66 :   RefPtr&lt;DrawTarget&gt; destDTBufferOnWhite;</span>
<span class="lineNum">     564 </span><span class="lineCov">         33 :   uint32_t bufferFlags = 0;</span>
<span class="lineNum">     565 </span><span class="lineCov">         33 :   if (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     bufferFlags |= BUFFER_COMPONENT_ALPHA;</span>
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span><span class="lineCov">         33 :   if (canReuseBuffer) {</span>
<span class="lineNum">     569 </span><span class="lineCov">         28 :     if (!EnsureBuffer()) {</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       return result;</span>
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span><span class="lineCov">         28 :     IntRect keepArea;</span>
<span class="lineNum">     573 </span><span class="lineCov">         28 :     if (keepArea.IntersectRect(destBufferRect, mBufferRect)) {</span>
<span class="lineNum">     574 </span>            :       // Set mBufferRotation so that the pixels currently in mDTBuffer
<span class="lineNum">     575 </span>            :       // will still be rendered in the right place when mBufferRect
<span class="lineNum">     576 </span>            :       // changes to destBufferRect.
<span class="lineNum">     577 </span>            :       IntPoint newRotation = mBufferRotation +
<span class="lineNum">     578 </span><span class="lineCov">         28 :         (destBufferRect.TopLeft() - mBufferRect.TopLeft());</span>
<span class="lineNum">     579 </span><span class="lineCov">         28 :       WrapRotationAxis(&amp;newRotation.x, mBufferRect.width);</span>
<span class="lineNum">     580 </span><span class="lineCov">         28 :       WrapRotationAxis(&amp;newRotation.y, mBufferRect.height);</span>
<span class="lineNum">     581 </span><span class="lineCov">         28 :       NS_ASSERTION(gfx::IntRect(gfx::IntPoint(0,0), mBufferRect.Size()).Contains(newRotation),</span>
<span class="lineNum">     582 </span>            :                    &quot;newRotation out of bounds&quot;);
<span class="lineNum">     583 </span><span class="lineCov">         28 :       int32_t xBoundary = destBufferRect.XMost() - newRotation.x;</span>
<span class="lineNum">     584 </span><span class="lineCov">         28 :       int32_t yBoundary = destBufferRect.YMost() - newRotation.y;</span>
<span class="lineNum">     585 </span><span class="lineCov">         56 :       bool drawWrapsBuffer = (drawBounds.x &lt; xBoundary &amp;&amp; xBoundary &lt; drawBounds.XMost()) ||</span>
<span class="lineNum">     586 </span><span class="lineCov">         84 :                              (drawBounds.y &lt; yBoundary &amp;&amp; yBoundary &lt; drawBounds.YMost());</span>
<span class="lineNum">     587 </span><span class="lineCov">        112 :       if ((drawWrapsBuffer &amp;&amp; !(aFlags &amp; PAINT_CAN_DRAW_ROTATED)) ||</span>
<span class="lineNum">     588 </span><span class="lineCov">        112 :           (newRotation != IntPoint(0,0) &amp;&amp; !canHaveRotation)) {</span>
<span class="lineNum">     589 </span>            :         // The stuff we need to redraw will wrap around an edge of the
<span class="lineNum">     590 </span>            :         // buffer (and the caller doesn't know how to support that), so
<span class="lineNum">     591 </span>            :         // move the pixels we can keep into a position that lets us
<span class="lineNum">     592 </span>            :         // redraw in just one quadrant.
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         if (mBufferRotation == IntPoint(0,0)) {</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :           IntRect srcRect(IntPoint(0, 0), mBufferRect.Size());</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :           IntPoint dest = mBufferRect.TopLeft() - destBufferRect.TopLeft();</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid());</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :           mDTBuffer-&gt;CopyRect(srcRect, dest);</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :           if (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :             if (!EnsureBufferOnWhite()) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :               return result;</span>
<span class="lineNum">     601 </span>            :             }
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(mDTBufferOnWhite &amp;&amp; mDTBufferOnWhite-&gt;IsValid());</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :             mDTBufferOnWhite-&gt;CopyRect(srcRect, dest);</span>
<span class="lineNum">     604 </span>            :           }
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :           result.mDidSelfCopy = true;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :           mDidSelfCopy = true;</span>
<span class="lineNum">     607 </span>            :           // Don't set destBuffer; we special-case self-copies, and
<span class="lineNum">     608 </span>            :           // just did the necessary work above.
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :           mBufferRect = destBufferRect;</span>
<span class="lineNum">     610 </span>            :         } else {
<span class="lineNum">     611 </span>            :           // With azure and a data surface perform an buffer unrotate
<span class="lineNum">     612 </span>            :           // (SelfCopy).
<span class="lineNum">     613 </span>            :           unsigned char* data;
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :           IntSize size;</span>
<span class="lineNum">     615 </span>            :           int32_t stride;
<span class="lineNum">     616 </span>            :           SurfaceFormat format;
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :           if (mDTBuffer-&gt;LockBits(&amp;data, &amp;size, &amp;stride, &amp;format)) {</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             uint8_t bytesPerPixel = BytesPerPixel(format);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             BufferUnrotate(data,</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                            size.width * bytesPerPixel,</span>
<span class="lineNum">     622 </span>            :                            size.height, stride,
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                            newRotation.x * bytesPerPixel, newRotation.y);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :             mDTBuffer-&gt;ReleaseBits(data);</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :             if (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :               if (!EnsureBufferOnWhite()) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                 return result;</span>
<span class="lineNum">     629 </span>            :               }
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :               MOZ_ASSERT(mDTBufferOnWhite &amp;&amp; mDTBufferOnWhite-&gt;IsValid());</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :               mDTBufferOnWhite-&gt;LockBits(&amp;data, &amp;size, &amp;stride, &amp;format);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :               uint8_t bytesPerPixel = BytesPerPixel(format);</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :               BufferUnrotate(data,</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                              size.width * bytesPerPixel,</span>
<span class="lineNum">     635 </span>            :                              size.height, stride,
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                              newRotation.x * bytesPerPixel, newRotation.y);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :               mDTBufferOnWhite-&gt;ReleaseBits(data);</span>
<span class="lineNum">     638 </span>            :             }
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :             // Buffer unrotate moves all the pixels, note that
<span class="lineNum">     641 </span>            :             // we self copied for SyncBackToFrontBuffer
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :             result.mDidSelfCopy = true;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :             mDidSelfCopy = true;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :             mBufferRect = destBufferRect;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :             mBufferRotation = IntPoint(0, 0);</span>
<span class="lineNum">     646 </span>            :           }
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :           if (!result.mDidSelfCopy) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :             destBufferRect = ComputeBufferRect(neededRegion.GetBounds());</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :             CreateBuffer(result.mContentType, destBufferRect, bufferFlags,</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                          &amp;destDTBuffer, &amp;destDTBufferOnWhite);</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             if (!destDTBuffer ||</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                 (!destDTBufferOnWhite &amp;&amp; (bufferFlags &amp; BUFFER_COMPONENT_ALPHA))) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :               if (Factory::ReasonableSurfaceSize(IntSize(destBufferRect.width, destBufferRect.height))) {</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                 gfxCriticalNote &lt;&lt; &quot;Failed 1 buffer db=&quot; &lt;&lt; hexa(destDTBuffer.get()) &lt;&lt; &quot; dw=&quot; &lt;&lt; hexa(destDTBufferOnWhite.get()) &lt;&lt; &quot; for &quot; &lt;&lt; destBufferRect.x &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.y &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.width &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.height;</span>
<span class="lineNum">     656 </span>            :               }
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :               return result;</span>
<span class="lineNum">     658 </span>            :             }
<span class="lineNum">     659 </span>            :           }
<span class="lineNum">     660 </span>            :         }
<span class="lineNum">     661 </span>            :       } else {
<span class="lineNum">     662 </span><span class="lineCov">         28 :         mBufferRect = destBufferRect;</span>
<span class="lineNum">     663 </span><span class="lineCov">         28 :         mBufferRotation = newRotation;</span>
<span class="lineNum">     664 </span>            :       }
<span class="lineNum">     665 </span>            :     } else {
<span class="lineNum">     666 </span>            :       // No pixels are going to be kept. The whole visible region
<span class="lineNum">     667 </span>            :       // will be redrawn, so we don't need to copy anything, so we don't
<span class="lineNum">     668 </span>            :       // set destBuffer.
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :       mBufferRect = destBufferRect;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :       mBufferRotation = IntPoint(0,0);</span>
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            :   } else {
<span class="lineNum">     673 </span>            :     // The buffer's not big enough, so allocate a new one
<span class="lineNum">     674 </span><span class="lineCov">          5 :     CreateBuffer(result.mContentType, destBufferRect, bufferFlags,</span>
<span class="lineNum">     675 </span><span class="lineCov">         10 :                  &amp;destDTBuffer, &amp;destDTBufferOnWhite);</span>
<span class="lineNum">     676 </span><span class="lineCov">         10 :     if (!destDTBuffer ||</span>
<span class="lineNum">     677 </span><span class="lineCov">         10 :         (!destDTBufferOnWhite &amp;&amp; (bufferFlags &amp; BUFFER_COMPONENT_ALPHA))) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       if (Factory::ReasonableSurfaceSize(IntSize(destBufferRect.width, destBufferRect.height))) {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         gfxCriticalNote &lt;&lt; &quot;Failed 2 buffer db=&quot; &lt;&lt; hexa(destDTBuffer.get()) &lt;&lt; &quot; dw=&quot; &lt;&lt; hexa(destDTBufferOnWhite.get()) &lt;&lt; &quot; for &quot; &lt;&lt; destBufferRect.x &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.y &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.width &lt;&lt; &quot;, &quot; &lt;&lt; destBufferRect.height;</span>
<span class="lineNum">     680 </span>            :       }
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       return result;</span>
<span class="lineNum">     682 </span>            :     }
<span class="lineNum">     683 </span>            :   }
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">         33 :   NS_ASSERTION(!(aFlags &amp; PAINT_WILL_RESAMPLE) || destBufferRect == neededRegion.GetBounds(),</span>
<span class="lineNum">     686 </span>            :                &quot;If we're resampling, we need to validate the entire buffer&quot;);
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :   // If we have no buffered data already, then destBuffer will be a fresh buffer
<span class="lineNum">     689 </span>            :   // and we do not need to clear it below.
<span class="lineNum">     690 </span><span class="lineCov">         33 :   bool isClear = !HaveBuffer();</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">         33 :   if (destDTBuffer) {</span>
<span class="lineNum">     693 </span><span class="lineCov">          5 :     if (!isClear &amp;&amp; (mode != SurfaceMode::SURFACE_COMPONENT_ALPHA || HaveBufferOnWhite())) {</span>
<span class="lineNum">     694 </span>            :       // Copy the bits
<span class="lineNum">     695 </span><span class="lineCov">          1 :       IntPoint offset = -destBufferRect.TopLeft();</span>
<span class="lineNum">     696 </span><span class="lineCov">          1 :       Matrix mat = Matrix::Translation(offset.x, offset.y);</span>
<span class="lineNum">     697 </span><span class="lineCov">          1 :       destDTBuffer-&gt;SetTransform(mat);</span>
<span class="lineNum">     698 </span><span class="lineCov">          1 :       if (!EnsureBuffer()) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     700 </span>            :       }
<span class="lineNum">     701 </span><span class="lineCov">          1 :       MOZ_ASSERT(mDTBuffer &amp;&amp; mDTBuffer-&gt;IsValid(), &quot;Have we got a Thebes buffer for some reason?&quot;);</span>
<span class="lineNum">     702 </span><span class="lineCov">          1 :       DrawBufferWithRotation(destDTBuffer, BUFFER_BLACK, 1.0, CompositionOp::OP_SOURCE);</span>
<span class="lineNum">     703 </span><span class="lineCov">          1 :       destDTBuffer-&gt;SetTransform(Matrix());</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineCov">          1 :       if (mode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         if (!destDTBufferOnWhite || !EnsureBufferOnWhite()) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :           return result;</span>
<span class="lineNum">     708 </span>            :         }
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(mDTBufferOnWhite &amp;&amp; mDTBufferOnWhite-&gt;IsValid(), &quot;Have we got a Thebes buffer for some reason?&quot;);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         destDTBufferOnWhite-&gt;SetTransform(mat);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         DrawBufferWithRotation(destDTBufferOnWhite, BUFFER_WHITE, 1.0, CompositionOp::OP_SOURCE);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         destDTBufferOnWhite-&gt;SetTransform(Matrix());</span>
<span class="lineNum">     713 </span>            :       }
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">          5 :     mDTBuffer = destDTBuffer.forget();</span>
<span class="lineNum">     717 </span><span class="lineCov">          5 :     mDTBufferOnWhite = destDTBufferOnWhite.forget();</span>
<span class="lineNum">     718 </span><span class="lineCov">          5 :     mBufferRect = destBufferRect;</span>
<span class="lineNum">     719 </span><span class="lineCov">          5 :     mBufferRotation = IntPoint(0,0);</span>
<span class="lineNum">     720 </span>            :   }
<span class="lineNum">     721 </span><span class="lineCov">         33 :   NS_ASSERTION(canHaveRotation || mBufferRotation == IntPoint(0,0),</span>
<span class="lineNum">     722 </span>            :                &quot;Rotation disabled, but we have nonzero rotation?&quot;);
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">         66 :   nsIntRegion invalidate;</span>
<span class="lineNum">     725 </span><span class="lineCov">         33 :   invalidate.Sub(aLayer-&gt;GetValidRegion(), destBufferRect);</span>
<span class="lineNum">     726 </span><span class="lineCov">         33 :   result.mRegionToInvalidate.Or(result.mRegionToInvalidate, invalidate);</span>
<span class="lineNum">     727 </span><span class="lineCov">         33 :   result.mClip = DrawRegionClip::DRAW;</span>
<span class="lineNum">     728 </span><span class="lineCov">         33 :   result.mMode = mode;</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">         33 :   return result;</span>
<span class="lineNum">     731 </span>            : }
<a name="732"><span class="lineNum">     732 </span>            : </a>
<span class="lineNum">     733 </span>            : DrawTarget*
<span class="lineNum">     734 </span><span class="lineCov">        110 : RotatedContentBuffer::BorrowDrawTargetForPainting(PaintState&amp; aPaintState,</span>
<span class="lineNum">     735 </span>            :                                                   DrawIterator* aIter /* = nullptr */)
<span class="lineNum">     736 </span>            : {
<span class="lineNum">     737 </span><span class="lineCov">        110 :   if (aPaintState.mMode == SurfaceMode::SURFACE_NONE) {</span>
<span class="lineNum">     738 </span><span class="lineCov">         44 :     return nullptr;</span>
<span class="lineNum">     739 </span>            :   }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">        132 :   DrawTarget* result = BorrowDrawTargetForQuadrantUpdate(aPaintState.mRegionToDraw.GetBounds(),</span>
<span class="lineNum">     742 </span><span class="lineCov">         66 :                                                          BUFFER_BOTH, aIter);</span>
<span class="lineNum">     743 </span><span class="lineCov">         66 :   if (!result) {</span>
<span class="lineNum">     744 </span><span class="lineCov">         33 :     return nullptr;</span>
<span class="lineNum">     745 </span>            :   }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">         33 :   nsIntRegion* drawPtr = &amp;aPaintState.mRegionToDraw;</span>
<span class="lineNum">     748 </span><span class="lineCov">         33 :   if (aIter) {</span>
<span class="lineNum">     749 </span>            :     // The iterators draw region currently only contains the bounds of the region,
<span class="lineNum">     750 </span>            :     // this makes it the precise region.
<span class="lineNum">     751 </span><span class="lineCov">         33 :     aIter-&gt;mDrawRegion.And(aIter-&gt;mDrawRegion, aPaintState.mRegionToDraw);</span>
<span class="lineNum">     752 </span><span class="lineCov">         33 :     drawPtr = &amp;aIter-&gt;mDrawRegion;</span>
<span class="lineNum">     753 </span>            :   }
<span class="lineNum">     754 </span><span class="lineCov">         66 :   if (result-&gt;GetBackendType() == BackendType::DIRECT2D ||</span>
<span class="lineNum">     755 </span><span class="lineCov">         33 :       result-&gt;GetBackendType() == BackendType::DIRECT2D1_1) {</span>
<span class="lineNum">     756 </span>            :     // Simplify the draw region to avoid hitting expensive drawing paths
<span class="lineNum">     757 </span>            :     // for complex regions.
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     drawPtr-&gt;SimplifyOutwardByArea(100 * 100);</span>
<span class="lineNum">     759 </span>            :   }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span><span class="lineCov">         33 :   if (aPaintState.mMode == SurfaceMode::SURFACE_COMPONENT_ALPHA) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     if (!mDTBuffer || !mDTBuffer-&gt;IsValid() ||</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         !mDTBufferOnWhite || !mDTBufferOnWhite-&gt;IsValid()) {</span>
<span class="lineNum">     764 </span>            :       // This can happen in release builds if allocating one of the two buffers
<span class="lineNum">     765 </span>            :       // failed. This in turn can happen if unreasonably large textures are
<span class="lineNum">     766 </span>            :       // requested.
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     768 </span>            :     }
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     for (auto iter = drawPtr-&gt;RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :       const IntRect&amp; rect = iter.Get();</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :       mDTBuffer-&gt;FillRect(Rect(rect.x, rect.y, rect.width, rect.height),</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :                           ColorPattern(Color(0.0, 0.0, 0.0, 1.0)));</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :       mDTBufferOnWhite-&gt;FillRect(Rect(rect.x, rect.y, rect.width, rect.height),</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                                  ColorPattern(Color(1.0, 1.0, 1.0, 1.0)));</span>
<span class="lineNum">     775 </span>            :     }
<span class="lineNum">     776 </span><span class="lineCov">         33 :   } else if (aPaintState.mContentType == gfxContentType::COLOR_ALPHA &amp;&amp; HaveBuffer()) {</span>
<span class="lineNum">     777 </span>            :     // HaveBuffer() =&gt; we have an existing buffer that we must clear
<span class="lineNum">     778 </span><span class="lineCov">         32 :     for (auto iter = drawPtr-&gt;RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     779 </span><span class="lineCov">         16 :       const IntRect&amp; rect = iter.Get();</span>
<span class="lineNum">     780 </span><span class="lineCov">         16 :       result-&gt;ClearRect(Rect(rect.x, rect.y, rect.width, rect.height));</span>
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span>            :   }
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">         33 :   return result;</span>
<span class="lineNum">     785 </span>            : }
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : already_AddRefed&lt;SourceSurface&gt;
<span class="lineNum">     788 </span><span class="lineCov">          1 : RotatedContentBuffer::GetSourceSurface(ContextSource aSource) const</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">          1 :   if (!mDTBuffer || !mDTBuffer-&gt;IsValid()) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     gfxCriticalNote &lt;&lt; &quot;Invalid buffer in RotatedContentBuffer::GetSourceSurface &quot; &lt;&lt; gfx::hexa(mDTBuffer);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     793 </span>            :   }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineCov">          1 :   if (aSource == BUFFER_BLACK) {</span>
<span class="lineNum">     796 </span><span class="lineCov">          1 :     return mDTBuffer-&gt;Snapshot();</span>
<span class="lineNum">     797 </span>            :   } else {
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     if (!mDTBufferOnWhite || !mDTBufferOnWhite-&gt;IsValid()) {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     gfxCriticalNote &lt;&lt; &quot;Invalid buffer on white in RotatedContentBuffer::GetSourceSurface &quot; &lt;&lt; gfx::hexa(mDTBufferOnWhite);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     801 </span>            :     }
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aSource == BUFFER_WHITE);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     return mDTBufferOnWhite-&gt;Snapshot();</span>
<span class="lineNum">     804 </span>            :   }
<span class="lineNum">     805 </span>            : }
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : } // namespace layers
<span class="lineNum">     808 </span>            : } // namespace mozilla
<span class="lineNum">     809 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

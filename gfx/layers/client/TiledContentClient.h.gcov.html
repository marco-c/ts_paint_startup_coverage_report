<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/layers/client/TiledContentClient.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gfx/layers/client</a> - TiledContentClient.h<span style="font-size: 80%;"> (source / <a href="TiledContentClient.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #ifndef MOZILLA_GFX_TILEDCONTENTCLIENT_H
<span class="lineNum">       7 </span>            : #define MOZILLA_GFX_TILEDCONTENTCLIENT_H
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &lt;stddef.h&gt;                     // for size_t
<span class="lineNum">      10 </span>            : #include &lt;stdint.h&gt;                     // for uint16_t
<span class="lineNum">      11 </span>            : #include &lt;algorithm&gt;                    // for swap
<span class="lineNum">      12 </span>            : #include &lt;limits&gt;
<span class="lineNum">      13 </span>            : #include &quot;Layers.h&quot;                     // for LayerManager, etc
<span class="lineNum">      14 </span>            : #include &quot;TiledLayerBuffer.h&quot;           // for TiledLayerBuffer
<span class="lineNum">      15 </span>            : #include &quot;Units.h&quot;                      // for CSSPoint
<span class="lineNum">      16 </span>            : #include &quot;gfxTypes.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/Attributes.h&quot;         // for override
<span class="lineNum">      18 </span>            : #include &quot;mozilla/RefPtr.h&quot;             // for RefPtr
<span class="lineNum">      19 </span>            : #include &quot;mozilla/ipc/Shmem.h&quot;          // for Shmem
<span class="lineNum">      20 </span>            : #include &quot;mozilla/ipc/SharedMemory.h&quot;   // for SharedMemory
<span class="lineNum">      21 </span>            : #include &quot;mozilla/layers/AsyncCompositionManager.h&quot;  // for ViewTransform
<span class="lineNum">      22 </span>            : #include &quot;mozilla/layers/CompositableClient.h&quot;  // for CompositableClient
<span class="lineNum">      23 </span>            : #include &quot;mozilla/layers/CompositorTypes.h&quot;  // for TextureInfo, etc
<span class="lineNum">      24 </span>            : #include &quot;mozilla/layers/LayersMessages.h&quot; // for TileDescriptor
<span class="lineNum">      25 </span>            : #include &quot;mozilla/layers/LayersTypes.h&quot; // for TextureDumpMode
<span class="lineNum">      26 </span>            : #include &quot;mozilla/layers/TextureClient.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mozilla/layers/TextureClientPool.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;ClientLayerManager.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;mozilla/mozalloc.h&quot;           // for operator delete
<span class="lineNum">      30 </span>            : #include &quot;nsISupportsImpl.h&quot;            // for MOZ_COUNT_DTOR
<span class="lineNum">      31 </span>            : #include &quot;nsPoint.h&quot;                    // for nsIntPoint
<span class="lineNum">      32 </span>            : #include &quot;nsRect.h&quot;                     // for mozilla::gfx::IntRect
<span class="lineNum">      33 </span>            : #include &quot;nsRegion.h&quot;                   // for nsIntRegion
<span class="lineNum">      34 </span>            : #include &quot;nsTArray.h&quot;                   // for nsTArray, nsTArray_Impl, etc
<span class="lineNum">      35 </span>            : #include &quot;nsExpirationTracker.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mozilla/layers/ISurfaceAllocator.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : namespace mozilla {
<span class="lineNum">      39 </span>            : namespace layers {
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : class ClientTiledPaintedLayer;
<span class="lineNum">      42 </span>            : class ClientLayerManager;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /**
<span class="lineNum">      45 </span>            :  * Represent a single tile in tiled buffer. The buffer keeps tiles,
<span class="lineNum">      46 </span>            :  * each tile keeps a reference to a texture client and a read-lock. This
<span class="lineNum">      47 </span>            :  * read-lock is used to help implement a copy-on-write mechanism. The tile
<span class="lineNum">      48 </span>            :  * should be locked before being sent to the compositor. The compositor should
<span class="lineNum">      49 </span>            :  * unlock the read-lock as soon as it has finished with the buffer in the
<span class="lineNum">      50 </span>            :  * TextureHost to prevent more textures being created than is necessary.
<span class="lineNum">      51 </span>            :  * Ideal place to store per tile debug information.
<span class="lineNum">      52 </span>            :  */
<span class="lineNum">      53 </span>            : struct TileClient
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span>            :   // Placeholder
<span class="lineNum">      56 </span>            :   TileClient();
<span class="lineNum">      57 </span>            :   ~TileClient();
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   TileClient(const TileClient&amp; o);
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :   TileClient&amp; operator=(const TileClient&amp; o);
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   bool operator== (const TileClient&amp; o) const
<span class="lineNum">      64 </span>            :   {
<span class="lineNum">      65 </span>            :     return mFrontBuffer == o.mFrontBuffer;
<span class="lineNum">      66 </span>            :   }
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :   bool operator!= (const TileClient&amp; o) const
<span class="lineNum">      69 </span>            :   {
<span class="lineNum">      70 </span>            :     return mFrontBuffer != o.mFrontBuffer;
<a name="71"><span class="lineNum">      71 </span>            :   }</a>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   void SetTextureAllocator(TextureClientAllocator* aAllocator)</span>
<span class="lineNum">      74 </span>            :   {
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     mAllocator = aAllocator;</span>
<a name="76"><span class="lineNum">      76 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   bool IsPlaceholderTile() const</span>
<span class="lineNum">      79 </span>            :   {
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     return mBackBuffer == nullptr &amp;&amp; mFrontBuffer == nullptr;</span>
<a name="81"><span class="lineNum">      81 </span>            :   }</a>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   void DiscardBuffers()</span>
<span class="lineNum">      84 </span>            :   {
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     DiscardFrontBuffer();</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     DiscardBackBuffer();</span>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   nsExpirationState *GetExpirationState() { return &amp;mExpirationState; }</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :   TileDescriptor GetTileDescriptor();
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :   /**
<span class="lineNum">      94 </span>            :    * For debugging.
<span class="lineNum">      95 </span>            :    */
<span class="lineNum">      96 </span>            :   void Dump(std::stringstream&amp; aStream);
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   /**
<span class="lineNum">      99 </span>            :   * Swaps the front and back buffers.
<span class="lineNum">     100 </span>            :   */
<a name="101"><span class="lineNum">     101 </span>            :   void Flip();</a>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   void DumpTexture(std::stringstream&amp; aStream, TextureDumpMode aCompress) {</span>
<span class="lineNum">     104 </span>            :     // TODO We should combine the OnWhite/OnBlack here an just output a single image.
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     CompositableClient::DumpTextureClient(aStream, mFrontBuffer, aCompress);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :   /**
<span class="lineNum">     109 </span>            :   * Returns an unlocked TextureClient that can be used for writing new
<span class="lineNum">     110 </span>            :   * data to the tile. This may flip the front-buffer to the back-buffer if
<span class="lineNum">     111 </span>            :   * the front-buffer is still locked by the host, or does not have an
<span class="lineNum">     112 </span>            :   * internal buffer (and so will always be locked).
<span class="lineNum">     113 </span>            :   *
<span class="lineNum">     114 </span>            :   * If getting the back buffer required copying pixels from the front buffer
<span class="lineNum">     115 </span>            :   * then the copied region is stored in aAddPaintedRegion so the host side
<span class="lineNum">     116 </span>            :   * knows to upload it.
<span class="lineNum">     117 </span>            :   *
<span class="lineNum">     118 </span>            :   * If nullptr is returned, aTextureClientOnWhite is undefined.
<span class="lineNum">     119 </span>            :   */
<span class="lineNum">     120 </span>            :   TextureClient* GetBackBuffer(CompositableClient&amp;,
<span class="lineNum">     121 </span>            :                                const nsIntRegion&amp; aDirtyRegion,
<span class="lineNum">     122 </span>            :                                gfxContentType aContent, SurfaceMode aMode,
<span class="lineNum">     123 </span>            :                                nsIntRegion&amp; aAddPaintedRegion,
<span class="lineNum">     124 </span>            :                                RefPtr&lt;TextureClient&gt;* aTextureClientOnWhite);
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   void DiscardFrontBuffer();
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   void DiscardBackBuffer();
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :   /* We wrap the back buffer in a class that disallows assignment
<a name="131"><span class="lineNum">     131 </span>            :    * so that we can track when ever it changes so that we can update</a>
<span class="lineNum">     132 </span>            :    * the expiry tracker for expiring the back buffers */
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   class PrivateProtector {</span>
<span class="lineNum">     134 </span>            :     public:
<span class="lineNum">     135 </span>            :       void Set(TileClient * container, RefPtr&lt;TextureClient&gt;);
<span class="lineNum">     136 </span>            :       void Set(TileClient * container, TextureClient*);
<a name="137"><span class="lineNum">     137 </span>            :       // Implicitly convert to TextureClient* because we can't chain</a>
<a name="138"><span class="lineNum">     138 </span>            :       // implicit conversion that would happen on RefPtr&lt;TextureClient&gt;</a>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :       operator TextureClient*() const { return mBuffer; }</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       RefPtr&lt;TextureClient&gt; operator -&gt;() { return mBuffer; }</span>
<span class="lineNum">     141 </span>            :     private:
<span class="lineNum">     142 </span>            :       PrivateProtector&amp; operator=(const PrivateProtector &amp;);
<span class="lineNum">     143 </span>            :       RefPtr&lt;TextureClient&gt; mBuffer;
<span class="lineNum">     144 </span>            :   } mBackBuffer;
<span class="lineNum">     145 </span>            :   RefPtr&lt;TextureClient&gt; mBackBufferOnWhite;
<span class="lineNum">     146 </span>            :   RefPtr&lt;TextureClient&gt; mFrontBuffer;
<span class="lineNum">     147 </span>            :   RefPtr&lt;TextureClient&gt; mFrontBufferOnWhite;
<span class="lineNum">     148 </span>            :   RefPtr&lt;TextureClientAllocator&gt; mAllocator;
<span class="lineNum">     149 </span>            :   gfx::IntRect mUpdateRect;
<span class="lineNum">     150 </span>            :   bool mWasPlaceholder;
<span class="lineNum">     151 </span>            : #ifdef GFX_TILEDLAYER_DEBUG_OVERLAY
<span class="lineNum">     152 </span>            :   TimeStamp        mLastUpdate;
<span class="lineNum">     153 </span>            : #endif
<span class="lineNum">     154 </span>            :   nsIntRegion mInvalidFront;
<span class="lineNum">     155 </span>            :   nsIntRegion mInvalidBack;
<span class="lineNum">     156 </span>            :   nsExpirationState mExpirationState;
<span class="lineNum">     157 </span>            : private:
<span class="lineNum">     158 </span>            :   // Copies dirty pixels from the front buffer into the back buffer,
<span class="lineNum">     159 </span>            :   // and records the copied region in aAddPaintedRegion.
<span class="lineNum">     160 </span>            :   void ValidateBackBufferFromFront(const nsIntRegion &amp;aDirtyRegion,
<span class="lineNum">     161 </span>            :                                    nsIntRegion&amp; aAddPaintedRegion);
<span class="lineNum">     162 </span>            : };
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /**
<span class="lineNum">     165 </span>            :  * This struct stores all the data necessary to perform a paint so that it
<a name="166"><span class="lineNum">     166 </span>            :  * doesn't need to be recalculated on every repeated transaction.</a>
<span class="lineNum">     167 </span>            :  */
<span class="lineNum">     168 </span><span class="lineNoCov">          0 : struct BasicTiledLayerPaintData {</span>
<span class="lineNum">     169 </span>            :   /*
<span class="lineNum">     170 </span>            :    * The scroll offset of the content from the nearest ancestor layer that
<span class="lineNum">     171 </span>            :    * represents scrollable content with a display port set.
<span class="lineNum">     172 </span>            :    */
<span class="lineNum">     173 </span>            :   ParentLayerPoint mScrollOffset;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   /*
<span class="lineNum">     176 </span>            :    * The scroll offset of the content from the nearest ancestor layer that
<span class="lineNum">     177 </span>            :    * represents scrollable content with a display port set, for the last
<span class="lineNum">     178 </span>            :    * layer update transaction.
<span class="lineNum">     179 </span>            :    */
<span class="lineNum">     180 </span>            :   ParentLayerPoint mLastScrollOffset;
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   /*
<span class="lineNum">     183 </span>            :    * The transform matrix to go from this layer's Layer units to
<span class="lineNum">     184 </span>            :    * the scroll ancestor's ParentLayer units. The &quot;scroll ancestor&quot; is
<span class="lineNum">     185 </span>            :    * the closest ancestor layer which scrolls, and is used to obtain
<span class="lineNum">     186 </span>            :    * the composition bounds that are relevant for this layer.
<span class="lineNum">     187 </span>            :    */
<span class="lineNum">     188 </span>            :   LayerToParentLayerMatrix4x4 mTransformToCompBounds;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   /*
<span class="lineNum">     191 </span>            :    * The critical displayport of the content from the nearest ancestor layer
<span class="lineNum">     192 </span>            :    * that represents scrollable content with a display port set. isNothing()
<span class="lineNum">     193 </span>            :    * if a critical displayport is not set.
<span class="lineNum">     194 </span>            :    */
<span class="lineNum">     195 </span>            :   Maybe&lt;LayerIntRect&gt; mCriticalDisplayPort;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   /*
<span class="lineNum">     198 </span>            :    * The render resolution of the document that the content this layer
<span class="lineNum">     199 </span>            :    * represents is in.
<span class="lineNum">     200 </span>            :    */
<span class="lineNum">     201 </span>            :   CSSToParentLayerScale2D mResolution;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   /*
<span class="lineNum">     204 </span>            :    * The composition bounds of the layer, in Layer coordinates. This is
<span class="lineNum">     205 </span>            :    * used to make sure that tiled updates to regions that are visible to the
<span class="lineNum">     206 </span>            :    * user are grouped coherently.
<span class="lineNum">     207 </span>            :    */
<span class="lineNum">     208 </span>            :   LayerRect mCompositionBounds;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :   /*
<span class="lineNum">     211 </span>            :    * Low precision updates are always executed a tile at a time in repeated
<span class="lineNum">     212 </span>            :    * transactions. This counter is set to 1 on the first transaction of a low
<span class="lineNum">     213 </span>            :    * precision update, and incremented for each subsequent transaction.
<span class="lineNum">     214 </span>            :    */
<span class="lineNum">     215 </span>            :   uint16_t mLowPrecisionPaintCount;
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   /*
<span class="lineNum">     218 </span>            :    * Whether this is the first time this layer is painting
<span class="lineNum">     219 </span>            :    */
<span class="lineNum">     220 </span>            :   bool mFirstPaint : 1;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   /*
<span class="lineNum">     223 </span>            :    * Whether there is further work to complete this paint. This is used to
<span class="lineNum">     224 </span>            :    * determine whether or not to repeat the transaction when painting
<span class="lineNum">     225 </span>            :    * progressively.
<span class="lineNum">     226 </span>            :    */
<span class="lineNum">     227 </span>            :   bool mPaintFinished : 1;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   /*
<span class="lineNum">     230 </span>            :    * Whether or not there is an async transform animation active
<span class="lineNum">     231 </span>            :    */
<span class="lineNum">     232 </span>            :   bool mHasTransformAnimation : 1;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :   /*
<span class="lineNum">     235 </span>            :    * Initializes/clears data to prepare for paint action.
<span class="lineNum">     236 </span>            :    */
<span class="lineNum">     237 </span>            :   void ResetPaintData();
<span class="lineNum">     238 </span>            : };
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : class SharedFrameMetricsHelper
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            : public:
<span class="lineNum">     243 </span>            :   SharedFrameMetricsHelper();
<span class="lineNum">     244 </span>            :   ~SharedFrameMetricsHelper();
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   /**
<span class="lineNum">     247 </span>            :    * This is called by the BasicTileLayer to determine if it is still interested
<span class="lineNum">     248 </span>            :    * in the update of this display-port to continue. We can return true here
<span class="lineNum">     249 </span>            :    * to abort the current update and continue with any subsequent ones. This
<span class="lineNum">     250 </span>            :    * is useful for slow-to-render pages when the display-port starts lagging
<span class="lineNum">     251 </span>            :    * behind enough that continuing to draw it is wasted effort.
<span class="lineNum">     252 </span>            :    */
<span class="lineNum">     253 </span>            :   bool UpdateFromCompositorFrameMetrics(const LayerMetricsWrapper&amp; aLayer,
<span class="lineNum">     254 </span>            :                                         bool aHasPendingNewThebesContent,
<span class="lineNum">     255 </span>            :                                         bool aLowPrecision,
<span class="lineNum">     256 </span>            :                                         AsyncTransform&amp; aViewTransform);
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   /**
<span class="lineNum">     259 </span>            :    * Determines if the compositor's upcoming composition bounds has fallen
<span class="lineNum">     260 </span>            :    * outside of the contents display port. If it has then the compositor
<span class="lineNum">     261 </span>            :    * will start to checker board. Checker boarding is when the compositor
<span class="lineNum">     262 </span>            :    * tries to composite a tile and it is not available. Historically
<span class="lineNum">     263 </span>            :    * a tile with a checker board pattern was used. Now a blank tile is used.
<span class="lineNum">     264 </span>            :    */
<span class="lineNum">     265 </span>            :   bool AboutToCheckerboard(const FrameMetrics&amp; aContentMetrics,
<span class="lineNum">     266 </span>            :                            const FrameMetrics&amp; aCompositorMetrics);
<span class="lineNum">     267 </span>            : private:
<span class="lineNum">     268 </span>            :   bool mLastProgressiveUpdateWasLowPrecision;
<span class="lineNum">     269 </span>            :   bool mProgressiveUpdateWasInDanger;
<span class="lineNum">     270 </span>            : };
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : /**
<span class="lineNum">     273 </span>            :  * Provide an instance of TiledLayerBuffer backed by drawable TextureClients.
<span class="lineNum">     274 </span>            :  * This buffer provides an implementation of ValidateTile using a
<span class="lineNum">     275 </span>            :  * thebes callback and can support painting using a single paint buffer.
<span class="lineNum">     276 </span>            :  * Whether a single paint buffer is used is controlled by
<span class="lineNum">     277 </span>            :  * gfxPrefs::PerTileDrawing().
<span class="lineNum">     278 </span>            :  */
<span class="lineNum">     279 </span>            : class ClientTiledLayerBuffer
<a name="280"><span class="lineNum">     280 </span>            : {</a>
<span class="lineNum">     281 </span>            : public:
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   ClientTiledLayerBuffer(ClientTiledPaintedLayer&amp; aPaintedLayer,</span>
<span class="lineNum">     283 </span>            :                          CompositableClient&amp; aCompositableClient)
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     : mPaintedLayer(aPaintedLayer)</span>
<span class="lineNum">     285 </span>            :     , mCompositableClient(aCompositableClient)
<span class="lineNum">     286 </span>            :     , mLastPaintContentType(gfxContentType::COLOR)
<span class="lineNum">     287 </span>            :     , mLastPaintSurfaceMode(SurfaceMode::SURFACE_OPAQUE)
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     , mWasLastPaintProgressive(false)</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   virtual void PaintThebes(const nsIntRegion&amp; aNewValidRegion,
<span class="lineNum">     292 </span>            :                    const nsIntRegion&amp; aPaintRegion,
<span class="lineNum">     293 </span>            :                    const nsIntRegion&amp; aDirtyRegion,
<span class="lineNum">     294 </span>            :                    LayerManager::DrawPaintedLayerCallback aCallback,
<span class="lineNum">     295 </span>            :                    void* aCallbackData,
<span class="lineNum">     296 </span>            :                    bool aIsProgressive = false) = 0;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :   virtual bool SupportsProgressiveUpdate() = 0;
<span class="lineNum">     299 </span>            :   virtual bool ProgressiveUpdate(const nsIntRegion&amp; aValidRegion,
<span class="lineNum">     300 </span>            :                          const nsIntRegion&amp; aInvalidRegion,
<span class="lineNum">     301 </span>            :                          const nsIntRegion&amp; aOldValidRegion,
<span class="lineNum">     302 </span>            :                          nsIntRegion&amp; aOutDrawnRegion,
<span class="lineNum">     303 </span>            :                          BasicTiledLayerPaintData* aPaintData,
<span class="lineNum">     304 </span>            :                          LayerManager::DrawPaintedLayerCallback aCallback,
<span class="lineNum">     305 </span>            :                          void* aCallbackData) = 0;
<span class="lineNum">     306 </span>            :   virtual void ResetPaintedAndValidState() = 0;
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   virtual const nsIntRegion&amp; GetValidRegion() = 0;
<span class="lineNum">     309 </span>            : 
<a name="310"><span class="lineNum">     310 </span>            :   virtual bool IsLowPrecision() const = 0;</a>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   virtual void Dump(std::stringstream&amp; aStream,</span>
<span class="lineNum">     313 </span>            :                     const char* aPrefix,
<span class="lineNum">     314 </span>            :                     bool aDumpHtml,
<a name="315"><span class="lineNum">     315 </span><span class="lineNoCov">          0 :                     TextureDumpMode aCompress) {}</span></a>
<a name="316"><span class="lineNum">     316 </span>            : </a>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   const CSSToParentLayerScale2D&amp; GetFrameResolution() { return mFrameResolution; }</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   void SetFrameResolution(const CSSToParentLayerScale2D&amp; aResolution) { mFrameResolution = aResolution; }</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   bool HasFormatChanged() const;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : protected:
<span class="lineNum">     323 </span>            :   void UnlockTile(TileClient&amp; aTile);
<span class="lineNum">     324 </span>            :   gfxContentType GetContentType(SurfaceMode* aMode = nullptr) const;
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   ClientTiledPaintedLayer&amp; mPaintedLayer;
<span class="lineNum">     327 </span>            :   CompositableClient&amp; mCompositableClient;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   gfxContentType mLastPaintContentType;
<span class="lineNum">     330 </span>            :   SurfaceMode mLastPaintSurfaceMode;
<span class="lineNum">     331 </span>            :   CSSToParentLayerScale2D mFrameResolution;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :   bool mWasLastPaintProgressive;
<a name="334"><span class="lineNum">     334 </span>            : };</a>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 : class ClientMultiTiledLayerBuffer</span>
<span class="lineNum">     337 </span>            :   : public TiledLayerBuffer&lt;ClientMultiTiledLayerBuffer, TileClient&gt;
<span class="lineNum">     338 </span>            :   , public ClientTiledLayerBuffer
<span class="lineNum">     339 </span>            : {
<span class="lineNum">     340 </span>            :   friend class TiledLayerBuffer&lt;ClientMultiTiledLayerBuffer, TileClient&gt;;
<span class="lineNum">     341 </span>            : public:
<span class="lineNum">     342 </span>            :   ClientMultiTiledLayerBuffer(ClientTiledPaintedLayer&amp; aPaintedLayer,
<span class="lineNum">     343 </span>            :                               CompositableClient&amp; aCompositableClient,
<span class="lineNum">     344 </span>            :                               ClientLayerManager* aManager,
<span class="lineNum">     345 </span>            :                               SharedFrameMetricsHelper* aHelper);
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :   void PaintThebes(const nsIntRegion&amp; aNewValidRegion,
<span class="lineNum">     348 </span>            :                    const nsIntRegion&amp; aPaintRegion,
<span class="lineNum">     349 </span>            :                    const nsIntRegion&amp; aDirtyRegion,
<span class="lineNum">     350 </span>            :                    LayerManager::DrawPaintedLayerCallback aCallback,
<span class="lineNum">     351 </span>            :                    void* aCallbackData,
<a name="352"><span class="lineNum">     352 </span>            :                    bool aIsProgressive = false) override;</a>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   virtual bool SupportsProgressiveUpdate() override { return true; }</span>
<span class="lineNum">     355 </span>            :   /**
<span class="lineNum">     356 </span>            :    * Performs a progressive update of a given tiled buffer.
<span class="lineNum">     357 </span>            :    * See ComputeProgressiveUpdateRegion below for parameter documentation.
<span class="lineNum">     358 </span>            :    * aOutDrawnRegion is an outparameter that contains the region that was
<span class="lineNum">     359 </span>            :    * drawn, and which can now be added to the layer's valid region.
<span class="lineNum">     360 </span>            :    */
<span class="lineNum">     361 </span>            :   bool ProgressiveUpdate(const nsIntRegion&amp; aValidRegion,
<span class="lineNum">     362 </span>            :                          const nsIntRegion&amp; aInvalidRegion,
<span class="lineNum">     363 </span>            :                          const nsIntRegion&amp; aOldValidRegion,
<span class="lineNum">     364 </span>            :                          nsIntRegion&amp; aOutDrawnRegion,
<span class="lineNum">     365 </span>            :                          BasicTiledLayerPaintData* aPaintData,
<span class="lineNum">     366 </span>            :                          LayerManager::DrawPaintedLayerCallback aCallback,
<a name="367"><span class="lineNum">     367 </span>            :                          void* aCallbackData) override;</a>
<span class="lineNum">     368 </span>            :   
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   void ResetPaintedAndValidState() override {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     mPaintedRegion.SetEmpty();</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     mValidRegion.SetEmpty();</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     mTiles.mSize.width = 0;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     mTiles.mSize.height = 0;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     DiscardBuffers();</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     mRetainedTiles.Clear();</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   }</span>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   const nsIntRegion&amp; GetValidRegion() override {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     return TiledLayerBuffer::GetValidRegion();</span>
<a name="381"><span class="lineNum">     381 </span>            :   }</a>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   bool IsLowPrecision() const override {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     return TiledLayerBuffer::IsLowPrecision();</span>
<a name="385"><span class="lineNum">     385 </span>            :   }</a>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   void Dump(std::stringstream&amp; aStream,</span>
<span class="lineNum">     388 </span>            :             const char* aPrefix,
<span class="lineNum">     389 </span>            :             bool aDumpHtml,
<span class="lineNum">     390 </span>            :             TextureDumpMode aCompress) override {
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     TiledLayerBuffer::Dump(aStream, aPrefix, aDumpHtml, aCompress);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   void ReadLock();
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   void Release();
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   void DiscardBuffers();
<span class="lineNum">     399 </span>            : 
<a name="400"><span class="lineNum">     400 </span>            :   SurfaceDescriptorTiles GetSurfaceDescriptorTiles();</a>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   void SetResolution(float aResolution) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     if (mResolution == aResolution) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     405 </span>            :     }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     Update(nsIntRegion(), nsIntRegion(), nsIntRegion());</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     mResolution = aResolution;</span>
<span class="lineNum">     409 </span>            :   }
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : protected:
<span class="lineNum">     412 </span>            :   bool ValidateTile(TileClient&amp; aTile,
<span class="lineNum">     413 </span>            :                     const nsIntPoint&amp; aTileRect,
<span class="lineNum">     414 </span>            :                     const nsIntRegion&amp; dirtyRect);
<span class="lineNum">     415 </span>            :   
<span class="lineNum">     416 </span>            :   void Update(const nsIntRegion&amp; aNewValidRegion,
<span class="lineNum">     417 </span>            :               const nsIntRegion&amp; aPaintRegion,
<span class="lineNum">     418 </span>            :               const nsIntRegion&amp; aDirtyRegion);
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   TileClient GetPlaceholderTile() const { return TileClient(); }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : private:
<span class="lineNum">     423 </span>            :   RefPtr&lt;ClientLayerManager&gt; mManager;
<span class="lineNum">     424 </span>            :   LayerManager::DrawPaintedLayerCallback mCallback;
<span class="lineNum">     425 </span>            :   void* mCallbackData;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   // The region that will be made valid during Update(). Once Update() is
<span class="lineNum">     428 </span>            :   // completed then this is identical to mValidRegion.
<span class="lineNum">     429 </span>            :   nsIntRegion mNewValidRegion;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   SharedFrameMetricsHelper*  mSharedFrameMetricsHelper;
<span class="lineNum">     432 </span>            :   // When using Moz2D's CreateTiledDrawTarget we maintain a list of gfx::Tiles
<span class="lineNum">     433 </span>            :   std::vector&lt;gfx::Tile&gt; mMoz2DTiles;
<span class="lineNum">     434 </span>            :   /**
<span class="lineNum">     435 </span>            :    * While we're adding tiles, this is used to keep track of the position of
<span class="lineNum">     436 </span>            :    * the top-left of the top-left-most tile.  When we come to wrap the tiles in
<span class="lineNum">     437 </span>            :    * TiledDrawTarget we subtract the value of this member from each tile's
<span class="lineNum">     438 </span>            :    * offset so that all the tiles have a positive offset, then add a
<span class="lineNum">     439 </span>            :    * translation to the TiledDrawTarget to compensate.  This is important so
<span class="lineNum">     440 </span>            :    * that the mRect of the TiledDrawTarget is always at a positive x/y
<span class="lineNum">     441 </span>            :    * position, otherwise its GetSize() methods will be broken.
<span class="lineNum">     442 </span>            :    */
<span class="lineNum">     443 </span>            :   gfx::IntPoint mTilingOrigin;
<span class="lineNum">     444 </span>            :   /**
<span class="lineNum">     445 </span>            :    * Calculates the region to update in a single progressive update transaction.
<span class="lineNum">     446 </span>            :    * This employs some heuristics to update the most 'sensible' region to
<span class="lineNum">     447 </span>            :    * update at this point in time, and how large an update should be performed
<span class="lineNum">     448 </span>            :    * at once to maintain visual coherency.
<span class="lineNum">     449 </span>            :    *
<span class="lineNum">     450 </span>            :    * aInvalidRegion is the current invalid region.
<span class="lineNum">     451 </span>            :    * aOldValidRegion is the valid region of mTiledBuffer at the beginning of the
<span class="lineNum">     452 </span>            :    * current transaction.
<span class="lineNum">     453 </span>            :    * aRegionToPaint will be filled with the region to update. This may be empty,
<span class="lineNum">     454 </span>            :    * which indicates that there is no more work to do.
<span class="lineNum">     455 </span>            :    * aIsRepeated should be true if this function has already been called during
<span class="lineNum">     456 </span>            :    * this transaction.
<span class="lineNum">     457 </span>            :    *
<span class="lineNum">     458 </span>            :    * Returns true if it should be called again, false otherwise. In the case
<span class="lineNum">     459 </span>            :    * that aRegionToPaint is empty, this will return aIsRepeated for convenience.
<span class="lineNum">     460 </span>            :    */
<span class="lineNum">     461 </span>            :   bool ComputeProgressiveUpdateRegion(const nsIntRegion&amp; aInvalidRegion,
<span class="lineNum">     462 </span>            :                                       const nsIntRegion&amp; aOldValidRegion,
<span class="lineNum">     463 </span>            :                                       nsIntRegion&amp; aRegionToPaint,
<span class="lineNum">     464 </span>            :                                       BasicTiledLayerPaintData* aPaintData,
<span class="lineNum">     465 </span>            :                                       bool aIsRepeated);
<span class="lineNum">     466 </span>            : };
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : class TiledContentClient : public CompositableClient
<a name="469"><span class="lineNum">     469 </span>            : {</a>
<span class="lineNum">     470 </span>            : public:
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   TiledContentClient(ClientLayerManager* aManager,</span>
<span class="lineNum">     472 </span>            :                      const char* aName = &quot;&quot;)
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     : CompositableClient(aManager-&gt;AsShadowForwarder())</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     , mName(aName)</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   {}</span>
<a name="476"><span class="lineNum">     476 </span>            : </a>
<span class="lineNum">     477 </span>            : protected:
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   ~TiledContentClient()</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : public:
<span class="lineNum">     482 </span>            :   virtual void PrintInfo(std::stringstream&amp; aStream, const char* aPrefix);
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   virtual void Dump(std::stringstream&amp; aStream,
<span class="lineNum">     485 </span>            :                     const char* aPrefix=&quot;&quot;,
<span class="lineNum">     486 </span>            :                     bool aDumpHtml=false,
<a name="487"><span class="lineNum">     487 </span>            :                     TextureDumpMode aCompress=TextureDumpMode::Compress) override;</a>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   virtual TextureInfo GetTextureInfo() const override</span>
<span class="lineNum">     490 </span>            :   {
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     return TextureInfo(CompositableType::CONTENT_TILED);</span>
<span class="lineNum">     492 </span>            :   }
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   virtual ClientTiledLayerBuffer* GetTiledBuffer() = 0;
<span class="lineNum">     496 </span>            :   virtual ClientTiledLayerBuffer* GetLowPrecisionTiledBuffer() = 0;
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   enum TiledBufferType {
<span class="lineNum">     499 </span>            :     TILED_BUFFER,
<span class="lineNum">     500 </span>            :     LOW_PRECISION_TILED_BUFFER
<span class="lineNum">     501 </span>            :   };
<span class="lineNum">     502 </span>            :   virtual void UpdatedBuffer(TiledBufferType aType) = 0;
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : private:
<span class="lineNum">     505 </span>            :   const char* mName;
<span class="lineNum">     506 </span>            : };
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /**
<span class="lineNum">     509 </span>            :  * An implementation of TiledContentClient that supports
<span class="lineNum">     510 </span>            :  * multiple tiles and a low precision buffer.
<span class="lineNum">     511 </span>            :  */
<span class="lineNum">     512 </span>            : class MultiTiledContentClient : public TiledContentClient
<span class="lineNum">     513 </span>            : {
<span class="lineNum">     514 </span>            : public:
<span class="lineNum">     515 </span>            :   MultiTiledContentClient(ClientTiledPaintedLayer&amp; aPaintedLayer,
<span class="lineNum">     516 </span>            :                           ClientLayerManager* aManager);
<a name="517"><span class="lineNum">     517 </span>            : </a>
<span class="lineNum">     518 </span>            : protected:
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   ~MultiTiledContentClient()</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR(MultiTiledContentClient);</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       mTiledBuffer.DiscardBuffers();</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     mLowPrecisionTiledBuffer.DiscardBuffers();</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : public:
<span class="lineNum">     528 </span>            :   void ClearCachedResources() override;
<a name="529"><span class="lineNum">     529 </span>            :   void UpdatedBuffer(TiledBufferType aType) override;</a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   ClientTiledLayerBuffer* GetTiledBuffer() override { return &amp;mTiledBuffer; }</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   ClientTiledLayerBuffer* GetLowPrecisionTiledBuffer() override {</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     if (mHasLowPrecision) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       return &amp;mLowPrecisionTiledBuffer;</span>
<span class="lineNum">     535 </span>            :     }
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     537 </span>            :   }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : private:
<span class="lineNum">     540 </span>            :   SharedFrameMetricsHelper mSharedFrameMetricsHelper;
<span class="lineNum">     541 </span>            :   ClientMultiTiledLayerBuffer mTiledBuffer;
<span class="lineNum">     542 </span>            :   ClientMultiTiledLayerBuffer mLowPrecisionTiledBuffer;
<span class="lineNum">     543 </span>            :   bool mHasLowPrecision;
<span class="lineNum">     544 </span>            : };
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            : } // namespace layers
<span class="lineNum">     547 </span>            : } // namespace mozilla
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

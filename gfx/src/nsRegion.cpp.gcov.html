<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/src/nsRegion.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/src</a> - nsRegion.cpp<span style="font-size: 80%;"> (source / <a href="nsRegion.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">224</td>
            <td class="headerCovTableEntry">528</td>
            <td class="headerCovTableEntryLo">42.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntry">45</td>
            <td class="headerCovTableEntryLo">62.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public</a>
<span class="lineNum">       2 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       3 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;nsRegion.h&quot;
<span class="lineNum">       7 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;gfxUtils.h&quot;
<a name="9"><span class="lineNum">       9 </span>            : #include &quot;mozilla/ToString.h&quot;</a>
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span><span class="lineCov">       1952 : bool nsRegion::Contains(const nsRegion&amp; aRgn) const</span>
<span class="lineNum">      12 </span>            : {
<span class="lineNum">      13 </span>            :   // XXX this could be made faster by iterating over
<span class="lineNum">      14 </span>            :   // both regions at the same time some how
<span class="lineNum">      15 </span><span class="lineCov">       2233 :   for (auto iter = aRgn.RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">      16 </span><span class="lineCov">        495 :     if (!Contains(iter.Get())) {</span>
<span class="lineNum">      17 </span><span class="lineCov">        214 :       return false;</span>
<span class="lineNum">      18 </span>            :     }
<span class="lineNum">      19 </span>            :   }
<span class="lineNum">      20 </span><span class="lineCov">       1738 :   return true;</span>
<a name="21"><span class="lineNum">      21 </span>            : }</a>
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span><span class="lineCov">       1864 : bool nsRegion::Intersects(const nsRect&amp; aRect) const</span>
<span class="lineNum">      24 </span>            : {
<span class="lineNum">      25 </span>            :   // XXX this could be made faster by using pixman_region32_contains_rect
<span class="lineNum">      26 </span><span class="lineCov">       3182 :   for (auto iter = RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">      27 </span><span class="lineCov">       1471 :     if (iter.Get().Intersects(aRect)) {</span>
<span class="lineNum">      28 </span><span class="lineCov">        153 :       return true;</span>
<span class="lineNum">      29 </span>            :     }
<span class="lineNum">      30 </span>            :   }
<span class="lineNum">      31 </span><span class="lineCov">       1711 :   return false;</span>
<a name="32"><span class="lineNum">      32 </span>            : }</a>
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span><span class="lineNoCov">          0 : void nsRegion::Inflate(const nsMargin&amp; aMargin)</span>
<span class="lineNum">      35 </span>            : {
<span class="lineNum">      36 </span>            :   int n;
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :     rect.Inflate(aMargin);</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :     boxes[i] = RectToBox(rect);</span>
<span class="lineNum">      42 </span>            :   }
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :   pixman_region32_t region;
<span class="lineNum">      45 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   pixman_region32_init_rects(&amp;region, boxes, n);</span>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   pixman_region32_fini(&amp;mImpl);</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   mImpl = region;</span>
<a name="50"><span class="lineNum">      50 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span><span class="lineCov">       3065 : void nsRegion::SimplifyOutward (uint32_t aMaxRects)</span>
<span class="lineNum">      53 </span>            : {
<span class="lineNum">      54 </span><span class="lineCov">       3065 :   MOZ_ASSERT(aMaxRects &gt;= 1, &quot;Invalid max rect count&quot;);</span>
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span><span class="lineCov">       3065 :   if (GetNumRects() &lt;= aMaxRects)</span>
<span class="lineNum">      57 </span><span class="lineCov">       3006 :     return;</span>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   pixman_box32_t *boxes;
<span class="lineNum">      60 </span>            :   int n;
<span class="lineNum">      61 </span><span class="lineCov">         59 :   boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   // Try combining rects in horizontal bands into a single rect
<span class="lineNum">      64 </span><span class="lineCov">         59 :   int dest = 0;</span>
<span class="lineNum">      65 </span><span class="lineCov">        288 :   for (int src = 1; src &lt; n; src++)</span>
<span class="lineNum">      66 </span>            :   {
<span class="lineNum">      67 </span>            :     // The goal here is to try to keep groups of rectangles that are vertically
<span class="lineNum">      68 </span>            :     // discontiguous as separate rectangles in the final region. This is
<span class="lineNum">      69 </span>            :     // simple and fast to implement and page contents tend to vary more
<span class="lineNum">      70 </span>            :     // vertically than horizontally (which is why our rectangles are stored
<span class="lineNum">      71 </span>            :     // sorted by y-coordinate, too).
<span class="lineNum">      72 </span>            :     //
<span class="lineNum">      73 </span>            :     // Note: if boxes share y1 because of the canonical representation they
<span class="lineNum">      74 </span>            :     // will share y2
<span class="lineNum">      75 </span><span class="lineCov">        947 :     while ((src &lt; (n)) &amp;&amp; boxes[dest].y1 == boxes[src].y1) {</span>
<span class="lineNum">      76 </span>            :       // merge box[i] and box[i+1]
<span class="lineNum">      77 </span><span class="lineCov">        359 :       boxes[dest].x2 = boxes[src].x2;</span>
<span class="lineNum">      78 </span><span class="lineCov">        359 :       src++;</span>
<span class="lineNum">      79 </span>            :     }
<span class="lineNum">      80 </span><span class="lineCov">        229 :     if (src &lt; n) {</span>
<span class="lineNum">      81 </span><span class="lineCov">        204 :       dest++;</span>
<span class="lineNum">      82 </span><span class="lineCov">        204 :       boxes[dest] = boxes[src];</span>
<span class="lineNum">      83 </span>            :     }
<span class="lineNum">      84 </span>            :   }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineCov">         59 :   uint32_t reducedCount = dest+1;</span>
<span class="lineNum">      87 </span>            :   // pixman has a special representation for
<span class="lineNum">      88 </span>            :   // regions of 1 rectangle. So just use the
<span class="lineNum">      89 </span>            :   // bounds in that case
<span class="lineNum">      90 </span><span class="lineCov">         59 :   if (reducedCount &gt; 1 &amp;&amp; reducedCount &lt;= aMaxRects) {</span>
<span class="lineNum">      91 </span>            :     // reach into pixman and lower the number
<span class="lineNum">      92 </span>            :     // of rects stored in data.
<span class="lineNum">      93 </span><span class="lineCov">         59 :     mImpl.data-&gt;numRects = reducedCount;</span>
<span class="lineNum">      94 </span>            :   } else {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     *this = GetBounds();</span>
<span class="lineNum">      96 </span>            :   }
<span class="lineNum">      97 </span>            : }
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : // compute the covered area difference between two rows.
<span class="lineNum">     100 </span>            : // by iterating over both rows simultaneously and adding up
<a name="101"><span class="lineNum">     101 </span>            : // the additional increase in area caused by extending each</a>
<span class="lineNum">     102 </span>            : // of the rectangles to the combined height of both rows
<span class="lineNum">     103 </span><span class="lineNoCov">          0 : static uint32_t ComputeMergedAreaIncrease(pixman_box32_t *topRects,</span>
<span class="lineNum">     104 </span>            :                                      pixman_box32_t *topRectsEnd,
<span class="lineNum">     105 </span>            :                                      pixman_box32_t *bottomRects,
<span class="lineNum">     106 </span>            :                                      pixman_box32_t *bottomRectsEnd)
<span class="lineNum">     107 </span>            : {
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   uint32_t totalArea = 0;</span>
<span class="lineNum">     109 </span>            :   struct pt {
<span class="lineNum">     110 </span>            :     int32_t x, y;
<span class="lineNum">     111 </span>            :   };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   pt *i = (pt*)topRects;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   pt *end_i = (pt*)topRectsEnd;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   pt *j = (pt*)bottomRects;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   pt *end_j = (pt*)bottomRectsEnd;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   bool top = false;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   bool bottom = false;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   int cur_x = i-&gt;x;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   bool top_next = top;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   bool bottom_next = bottom;</span>
<span class="lineNum">     124 </span>            :   //XXX: we could probably simplify this condition and perhaps move it into the loop below
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   if (j-&gt;x &lt; cur_x) {</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     cur_x = j-&gt;x;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     j++;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     bottom_next = !bottom;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   } else if (j-&gt;x == cur_x) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     i++;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     top_next = !top;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     bottom_next = !bottom;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     j++;</span>
<span class="lineNum">     134 </span>            :   } else {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     top_next = !top;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     i++;</span>
<span class="lineNum">     137 </span>            :   }
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   int topRectsHeight = topRects-&gt;y2 - topRects-&gt;y1;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   int bottomRectsHeight = bottomRects-&gt;y2 - bottomRects-&gt;y1;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   int inbetweenHeight = bottomRects-&gt;y1 - topRects-&gt;y2;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   int width = cur_x;</span>
<span class="lineNum">     143 </span>            :   // top and bottom are the in-status to the left of cur_x
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     if (top &amp;&amp; !bottom) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       totalArea += (inbetweenHeight+bottomRectsHeight)*width;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     } else if (bottom &amp;&amp; !top) {</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       totalArea += (inbetweenHeight+topRectsHeight)*width;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     } else if (bottom &amp;&amp; top) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       totalArea += (inbetweenHeight)*width;</span>
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     top = top_next;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     bottom = bottom_next;</span>
<span class="lineNum">     154 </span>            :     // find the next edge
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     if (i-&gt;x &lt; j-&gt;x) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       top_next = !top;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :       width = i-&gt;x - cur_x;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       cur_x = i-&gt;x;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       i++;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     } else if (j-&gt;x &lt; i-&gt;x) {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       bottom_next = !bottom;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       width = j-&gt;x - cur_x;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       cur_x = j-&gt;x;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       j++;</span>
<span class="lineNum">     165 </span>            :     } else { // i-&gt;x == j-&gt;x
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       top_next = !top;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       bottom_next = !bottom;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       width = i-&gt;x - cur_x;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       cur_x = i-&gt;x;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       i++;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :       j++;</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   } while (i &lt; end_i &amp;&amp; j &lt; end_j);</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   // handle any remaining rects
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   while (i &lt; end_i) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     width = i-&gt;x - cur_x;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     cur_x = i-&gt;x;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     i++;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (top)</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       totalArea += (inbetweenHeight+bottomRectsHeight)*width;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     top = !top;</span>
<span class="lineNum">     183 </span>            :   }
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   while (j &lt; end_j) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     width = j-&gt;x - cur_x;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     cur_x = j-&gt;x;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     j++;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     if (bottom)</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       totalArea += (inbetweenHeight+topRectsHeight)*width;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     bottom = !bottom;</span>
<span class="lineNum">     192 </span>            :   }
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   return totalArea;</span>
<span class="lineNum">     194 </span>            : }
<a name="195"><span class="lineNum">     195 </span>            : </a>
<span class="lineNum">     196 </span>            : static pixman_box32_t *
<span class="lineNum">     197 </span><span class="lineNoCov">          0 : CopyRow(pixman_box32_t *dest_it, pixman_box32_t *src_start, pixman_box32_t *src_end)</span>
<span class="lineNum">     198 </span>            : {
<span class="lineNum">     199 </span>            :     // XXX: std::copy
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     pixman_box32_t *src_it = src_start;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     while (src_it &lt; src_end) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         *dest_it++ = *src_it++;</span>
<span class="lineNum">     203 </span>            :     }
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     return dest_it;</span>
<span class="lineNum">     205 </span>            : }
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : #define WRITE_RECT(x1, x2, y1, y2) \
<span class="lineNum">     209 </span>            :     do {                    \
<span class="lineNum">     210 </span>            :          tmpRect-&gt;x1 = x1;  \
<span class="lineNum">     211 </span>            :          tmpRect-&gt;x2 = x2;  \
<span class="lineNum">     212 </span>            :          tmpRect-&gt;y1 = y1;  \
<span class="lineNum">     213 </span>            :          tmpRect-&gt;y2 = y2;  \
<span class="lineNum">     214 </span>            :          tmpRect++;         \
<span class="lineNum">     215 </span>            :     } while (0)
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : /* If 'r' overlaps the current rect, then expand the current rect to include
<span class="lineNum">     218 </span>            :  * it. Otherwise write the current rect out to tmpRect, and set r as the
<span class="lineNum">     219 </span>            :  * updated current rect. */
<span class="lineNum">     220 </span>            : #define MERGE_RECT(r)                 \
<span class="lineNum">     221 </span>            :     do {                              \
<span class="lineNum">     222 </span>            :       if (r-&gt;x1 &lt;= x2) {              \
<span class="lineNum">     223 </span>            :           if (x2 &lt; r-&gt;x2)             \
<span class="lineNum">     224 </span>            :               x2 = r-&gt;x2;             \
<span class="lineNum">     225 </span>            :       } else {                        \
<span class="lineNum">     226 </span>            :           WRITE_RECT(x1, x2, y1, y2); \
<span class="lineNum">     227 </span>            :           x1 = r-&gt;x1;                 \
<span class="lineNum">     228 </span>            :           x2 = r-&gt;x2;                 \
<span class="lineNum">     229 </span>            :       }                               \
<span class="lineNum">     230 </span>            :       r++;                            \
<span class="lineNum">     231 </span>            :     } while (0)
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /* Can we merge two sets of rects without extra space?
<span class="lineNum">     235 </span>            :  * Yes, but not easily. We can even do it stably
<span class="lineNum">     236 </span>            :  * but we don't need that property.
<span class="lineNum">     237 </span>            :  *
<a name="238"><span class="lineNum">     238 </span>            :  * This is written in the style of pixman_region_union_o */</a>
<span class="lineNum">     239 </span>            : static pixman_box32_t *
<span class="lineNum">     240 </span><span class="lineNoCov">          0 : MergeRects(pixman_box32_t *r1,</span>
<span class="lineNum">     241 </span>            :            pixman_box32_t *r1_end,
<span class="lineNum">     242 </span>            :            pixman_box32_t *r2,
<span class="lineNum">     243 </span>            :            pixman_box32_t *r2_end,
<span class="lineNum">     244 </span>            :            pixman_box32_t *tmpRect)
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span>            :     /* This routine works by maintaining the current
<span class="lineNum">     247 </span>            :      * rectangle in x1,x2,y1,y2 and either merging
<span class="lineNum">     248 </span>            :      * in the left most rectangle if it overlaps or
<span class="lineNum">     249 </span>            :      * outputing the current rectangle and setting
<span class="lineNum">     250 </span>            :      * it to the the left most one */
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     const int y1 = r1-&gt;y1;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     const int y2 = r2-&gt;y2;</span>
<span class="lineNum">     253 </span>            :     int x1;
<span class="lineNum">     254 </span>            :     int x2;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :     /* Find the left-most edge */
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     if (r1-&gt;x1 &lt; r2-&gt;x1) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         x1 = r1-&gt;x1;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :         x2 = r1-&gt;x2;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         r1++;</span>
<span class="lineNum">     261 </span>            :     } else {
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         x1 = r2-&gt;x1;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         x2 = r2-&gt;x2;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         r2++;</span>
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     while (r1 != r1_end &amp;&amp; r2 != r2_end) {</span>
<span class="lineNum">     268 </span>            :         /* Find and merge the left-most rectangle */
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         if (r1-&gt;x1 &lt; r2-&gt;x1)</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :             MERGE_RECT (r1);</span>
<span class="lineNum">     271 </span>            :         else
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :             MERGE_RECT (r2);</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /* Finish up any left overs */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     if (r1 != r1_end) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :             MERGE_RECT (r1);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         } while (r1 != r1_end);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     } else if (r2 != r2_end) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             MERGE_RECT(r2);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         } while (r2 != r2_end);</span>
<span class="lineNum">     284 </span>            :     }
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     /* Finish up the last rectangle */
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     WRITE_RECT(x1, x2, y1, y2);</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     return tmpRect;</span>
<a name="290"><span class="lineNum">     290 </span>            : }</a>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 : void nsRegion::SimplifyOutwardByArea(uint32_t aThreshold)</span>
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :   pixman_box32_t *boxes;
<span class="lineNum">     296 </span>            :   int n;
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   // if we have no rectangles then we're done
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   if (!n)</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   pixman_box32_t *end = boxes + n;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   pixman_box32_t *topRectsEnd = boxes+1;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   pixman_box32_t *topRects = boxes;</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :   // we need some temporary storage for merging both rows of rectangles
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   AutoTArray&lt;pixman_box32_t, 10&gt; tmpStorage;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   tmpStorage.SetCapacity(n);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   pixman_box32_t *tmpRect = tmpStorage.Elements();</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   pixman_box32_t *destRect = boxes;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   pixman_box32_t *rect = tmpRect;</span>
<span class="lineNum">     314 </span>            :   // find the end of the first span of rectangles
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   while (topRectsEnd &lt; end &amp;&amp; topRectsEnd-&gt;y1 == topRects-&gt;y1) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     topRectsEnd++;</span>
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :   // if we only have one row we are done
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   if (topRectsEnd == end)</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   pixman_box32_t *bottomRects = topRectsEnd;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   pixman_box32_t *bottomRectsEnd = bottomRects+1;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     326 </span>            :     // find the end of the bottom span of rectangles
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     while (bottomRectsEnd &lt; end &amp;&amp; bottomRectsEnd-&gt;y1 == bottomRects-&gt;y1) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       bottomRectsEnd++;</span>
<span class="lineNum">     329 </span>            :     }
<span class="lineNum">     330 </span>            :     uint32_t totalArea = ComputeMergedAreaIncrease(topRects, topRectsEnd,
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                                                    bottomRects, bottomRectsEnd);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (totalArea &lt;= aThreshold) {</span>
<span class="lineNum">     334 </span>            :       // merge the rects into tmpRect
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       rect = MergeRects(topRects, topRectsEnd, bottomRects, bottomRectsEnd, tmpRect);</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :       // set topRects to where the newly merged rects will be so that we use them
<span class="lineNum">     338 </span>            :       // as our next set of topRects
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       topRects = destRect;</span>
<span class="lineNum">     340 </span>            :       // copy the merged rects back into the destination
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       topRectsEnd = CopyRow(destRect, tmpRect, rect);</span>
<span class="lineNum">     342 </span>            :     } else {
<span class="lineNum">     343 </span>            :       // copy the unmerged rects
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :       destRect = CopyRow(destRect, topRects, topRectsEnd);</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       topRects = bottomRects;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       topRectsEnd = bottomRectsEnd;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       if (bottomRectsEnd == end) {</span>
<span class="lineNum">     349 </span>            :         // copy the last row when we are done
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         topRectsEnd = CopyRow(destRect, topRects, topRectsEnd);</span>
<span class="lineNum">     351 </span>            :       }
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     bottomRects = bottomRectsEnd;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   } while (bottomRectsEnd != end);</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   uint32_t reducedCount = topRectsEnd - pixman_region32_rectangles(&amp;this-&gt;mImpl, &amp;n);</span>
<span class="lineNum">     358 </span>            :   // pixman has a special representation for
<span class="lineNum">     359 </span>            :   // regions of 1 rectangle. So just use the
<span class="lineNum">     360 </span>            :   // bounds in that case
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   if (reducedCount &gt; 1) {</span>
<span class="lineNum">     362 </span>            :     // reach into pixman and lower the number
<span class="lineNum">     363 </span>            :     // of rects stored in data.
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     this-&gt;mImpl.data-&gt;numRects = reducedCount;</span>
<span class="lineNum">     365 </span>            :   } else {
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     *this = GetBounds();</span>
<span class="lineNum">     367 </span>            :   }
<span class="lineNum">     368 </span>            : }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : 
<a name="371"><span class="lineNum">     371 </span>            : typedef void (*visit_fn)(void *closure, VisitSide side, int x1, int y1, int x2, int y2);</a>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : static bool VisitNextEdgeBetweenRect(visit_fn visit, void *closure, VisitSide side,</span>
<span class="lineNum">     374 </span>            :                                      pixman_box32_t *&amp;r1, pixman_box32_t *&amp;r2, const int y, int &amp;x1)
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span>            :   // check for overlap
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   if (r1-&gt;x2 &gt;= r2-&gt;x1) {</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(r2-&gt;x1 &gt;= x1);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     visit(closure, side, x1, y, r2-&gt;x1, y);</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     // find the rect that ends first or always drop the one that comes first?
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     if (r1-&gt;x2 &lt; r2-&gt;x2) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       x1 = r1-&gt;x2;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       r1++;</span>
<span class="lineNum">     385 </span>            :     } else {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       x1 = r2-&gt;x2;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       r2++;</span>
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     390 </span>            :   } else {
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(r1-&gt;x2 &lt; r2-&gt;x2);</span>
<span class="lineNum">     392 </span>            :     // we handle the corners by just extending the top and bottom edges
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     visit(closure, side, x1, y, r1-&gt;x2+1, y);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     r1++;</span>
<span class="lineNum">     395 </span>            :     // we assign x1 because we can assume that x1 &lt;= r2-&gt;x1 - 1
<span class="lineNum">     396 </span>            :     // However the caller may know better and if so, may update
<span class="lineNum">     397 </span>            :     // x1 to r1-&gt;x1
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     x1 = r2-&gt;x1 - 1;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     400 </span>            :   }
<span class="lineNum">     401 </span>            : }
<span class="lineNum">     402 </span>            : 
<a name="403"><span class="lineNum">     403 </span>            : //XXX: if we need to this can compute the end of the row</a>
<span class="lineNum">     404 </span>            : static void
<span class="lineNum">     405 </span><span class="lineNoCov">          0 : VisitSides(visit_fn visit, void *closure, pixman_box32_t *r, pixman_box32_t *r_end)</span>
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span>            :   // XXX: we can drop LEFT/RIGHT and just use the orientation
<span class="lineNum">     408 </span>            :   // of the line if it makes sense
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   while (r != r_end) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     visit(closure, VisitSide::LEFT, r-&gt;x1, r-&gt;y1, r-&gt;x1, r-&gt;y2);</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     visit(closure, VisitSide::RIGHT, r-&gt;x2, r-&gt;y1, r-&gt;x2, r-&gt;y2);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     r++;</span>
<span class="lineNum">     413 </span>            :   }
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : }</span>
<a name="415"><span class="lineNum">     415 </span>            : </a>
<span class="lineNum">     416 </span>            : static void
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : VisitAbove(visit_fn visit, void *closure, pixman_box32_t *r, pixman_box32_t *r_end)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   while (r != r_end) {</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     visit(closure, VisitSide::TOP, r-&gt;x1-1, r-&gt;y1, r-&gt;x2+1, r-&gt;y1);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     r++;</span>
<span class="lineNum">     422 </span>            :   }
<span class="lineNum">     423 </span><span class="lineNoCov">          0 : }</span>
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : static void
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : VisitBelow(visit_fn visit, void *closure, pixman_box32_t *r, pixman_box32_t *r_end)</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   while (r != r_end) {</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     visit(closure, VisitSide::BOTTOM, r-&gt;x1-1, r-&gt;y2, r-&gt;x2+1, r-&gt;y2);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     r++;</span>
<span class="lineNum">     431 </span>            :   }
<span class="lineNum">     432 </span><span class="lineNoCov">          0 : }</span>
<a name="433"><span class="lineNum">     433 </span>            : </a>
<span class="lineNum">     434 </span>            : static pixman_box32_t *
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : VisitInbetween(visit_fn visit, void *closure, pixman_box32_t *r1,</span>
<span class="lineNum">     436 </span>            :                pixman_box32_t *r1_end,
<span class="lineNum">     437 </span>            :                pixman_box32_t *r2,
<span class="lineNum">     438 </span>            :                pixman_box32_t *r2_end)
<span class="lineNum">     439 </span>            : {
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   const int y = r1-&gt;y2;</span>
<span class="lineNum">     441 </span>            :   int x1;
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   bool overlap = false;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   while (r1 != r1_end &amp;&amp; r2 != r2_end) {</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     if (!overlap) {</span>
<span class="lineNum">     446 </span>            :       /* Find the left-most edge */
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       if (r1-&gt;x1 &lt; r2-&gt;x1) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         x1 = r1-&gt;x1 - 1;</span>
<span class="lineNum">     449 </span>            :       } else {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         x1 = r2-&gt;x1 - 1;</span>
<span class="lineNum">     451 </span>            :       }
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     MOZ_ASSERT((x1 &gt;= (r1-&gt;x1 - 1)) || (x1 &gt;= (r2-&gt;x1 - 1)));</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     if (r1-&gt;x1 &lt; r2-&gt;x1) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       overlap = VisitNextEdgeBetweenRect(visit, closure, VisitSide::BOTTOM, r1, r2, y, x1);</span>
<span class="lineNum">     457 </span>            :     } else {
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       overlap = VisitNextEdgeBetweenRect(visit, closure, VisitSide::TOP, r2, r1, y, x1);</span>
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span>            :   }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :   /* Finish up which ever row has remaining rects*/
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   if (r1 != r1_end) {</span>
<span class="lineNum">     464 </span>            :     // top row
<span class="lineNum">     465 </span>            :     do {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       visit(closure, VisitSide::BOTTOM, x1, y, r1-&gt;x2 + 1, y);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       r1++;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       if (r1 == r1_end)</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       x1 = r1-&gt;x1 - 1;</span>
<span class="lineNum">     471 </span>            :     } while (true);
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   } else if (r2 != r2_end) {</span>
<span class="lineNum">     473 </span>            :     // bottom row
<span class="lineNum">     474 </span>            :     do {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       visit(closure, VisitSide::TOP, x1, y, r2-&gt;x2 + 1, y);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       r2++;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :       if (r2 == r2_end)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       x1 = r2-&gt;x1 - 1;</span>
<span class="lineNum">     480 </span>            :     } while (true);
<span class="lineNum">     481 </span>            :   }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="484"><span class="lineNum">     484 </span>            : }</a>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 : void nsRegion::VisitEdges (visit_fn visit, void *closure)</span>
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span>            :   pixman_box32_t *boxes;
<span class="lineNum">     489 </span>            :   int n;
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // if we have no rectangles then we're done
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   if (!n)</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   pixman_box32_t *end = boxes + n;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   pixman_box32_t *topRectsEnd = boxes + 1;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   pixman_box32_t *topRects = boxes;</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   // find the end of the first span of rectangles
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   while (topRectsEnd &lt; end &amp;&amp; topRectsEnd-&gt;y1 == topRects-&gt;y1) {</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     topRectsEnd++;</span>
<span class="lineNum">     503 </span>            :   }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   // In order to properly handle convex corners we always visit the sides first
<span class="lineNum">     506 </span>            :   // that way when we visit the corners we can pad using the value from the sides
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   VisitSides(visit, closure, topRects, topRectsEnd);</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   VisitAbove(visit, closure, topRects, topRectsEnd);</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   pixman_box32_t *bottomRects = topRects;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   pixman_box32_t *bottomRectsEnd = topRectsEnd;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   if (topRectsEnd != end) {</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     515 </span>            :       // find the next row of rects
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       bottomRects = topRectsEnd;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       bottomRectsEnd = topRectsEnd + 1;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       while (bottomRectsEnd &lt; end &amp;&amp; bottomRectsEnd-&gt;y1 == bottomRects-&gt;y1) {</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         bottomRectsEnd++;</span>
<span class="lineNum">     520 </span>            :       }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       VisitSides(visit, closure, bottomRects, bottomRectsEnd);</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (topRects-&gt;y2 == bottomRects-&gt;y1) {</span>
<span class="lineNum">     525 </span>            :         VisitInbetween(visit, closure, topRects, topRectsEnd,
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                                        bottomRects, bottomRectsEnd);</span>
<span class="lineNum">     527 </span>            :       } else {
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         VisitBelow(visit, closure, topRects, topRectsEnd);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         VisitAbove(visit, closure, bottomRects, bottomRectsEnd);</span>
<span class="lineNum">     530 </span>            :       }
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :       topRects = bottomRects;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       topRectsEnd = bottomRectsEnd;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     } while (bottomRectsEnd != end);</span>
<span class="lineNum">     535 </span>            :   }
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :   // the bottom of the region doesn't touch anything else so we
<span class="lineNum">     538 </span>            :   // can always visit it at the end
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   VisitBelow(visit, closure, bottomRects, bottomRectsEnd);</span>
<span class="lineNum">     540 </span>            : }
<a name="541"><span class="lineNum">     541 </span>            : </a>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 : void nsRegion::SimplifyInward (uint32_t aMaxRects)</span>
<span class="lineNum">     544 </span>            : {
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aMaxRects &gt;= 1, &quot;Invalid max rect count&quot;);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   if (GetNumRects() &lt;= aMaxRects)</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   SetEmpty();</span>
<a name="551"><span class="lineNum">     551 </span>            : }</a>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">         35 : uint64_t nsRegion::Area () const</span>
<span class="lineNum">     554 </span>            : {
<span class="lineNum">     555 </span><span class="lineCov">         35 :   uint64_t area = 0;</span>
<span class="lineNum">     556 </span><span class="lineCov">         35 :   for (auto iter = RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     const nsRect&amp; rect = iter.Get();</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     area += uint64_t(rect.width) * rect.height;</span>
<span class="lineNum">     559 </span>            :   }
<span class="lineNum">     560 </span><span class="lineCov">         35 :   return area;</span>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineCov">        595 : nsRegion&amp; nsRegion::ScaleRoundOut (float aXScale, float aYScale)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span><span class="lineCov">       1189 :   if (mozilla::gfx::FuzzyEqual(aXScale, 1.0f) &amp;&amp;</span>
<span class="lineNum">     566 </span><span class="lineCov">        594 :       mozilla::gfx::FuzzyEqual(aYScale, 1.0f)) {</span>
<span class="lineNum">     567 </span><span class="lineCov">        594 :     return *this;</span>
<span class="lineNum">     568 </span>            :   }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   int n;
<span class="lineNum">     571 </span><span class="lineCov">          1 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">     572 </span><span class="lineCov">          2 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     573 </span><span class="lineCov">          2 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :     rect.ScaleRoundOut(aXScale, aYScale);</span>
<span class="lineNum">     575 </span><span class="lineCov">          1 :     boxes[i] = RectToBox(rect);</span>
<span class="lineNum">     576 </span>            :   }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   pixman_region32_t region;
<span class="lineNum">     579 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     580 </span><span class="lineCov">          1 :   pixman_region32_init_rects(&amp;region, boxes, n);</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">          1 :   pixman_region32_fini(&amp;mImpl);</span>
<span class="lineNum">     583 </span><span class="lineCov">          1 :   mImpl = region;</span>
<span class="lineNum">     584 </span><span class="lineCov">          1 :   return *this;</span>
<a name="585"><span class="lineNum">     585 </span>            : }</a>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineCov">         60 : nsRegion&amp; nsRegion::ScaleInverseRoundOut (float aXScale, float aYScale)</span>
<span class="lineNum">     588 </span>            : {
<span class="lineNum">     589 </span>            :   int n;
<span class="lineNum">     590 </span><span class="lineCov">         60 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">     591 </span><span class="lineCov">        150 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     592 </span><span class="lineCov">        180 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     593 </span><span class="lineCov">         90 :     rect.ScaleInverseRoundOut(aXScale, aYScale);</span>
<span class="lineNum">     594 </span><span class="lineCov">         90 :     boxes[i] = RectToBox(rect);</span>
<span class="lineNum">     595 </span>            :   }
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :   pixman_region32_t region;
<span class="lineNum">     598 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     599 </span><span class="lineCov">         60 :   pixman_region32_init_rects(&amp;region, boxes, n);</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">         60 :   pixman_region32_fini(&amp;mImpl);</span>
<span class="lineNum">     602 </span><span class="lineCov">         60 :   mImpl = region;</span>
<span class="lineNum">     603 </span><span class="lineCov">         60 :   return *this;</span>
<span class="lineNum">     604 </span>            : }
<a name="605"><span class="lineNum">     605 </span>            : </a>
<span class="lineNum">     606 </span>            : static mozilla::gfx::IntRect
<span class="lineNum">     607 </span><span class="lineCov">        247 : TransformRect(const mozilla::gfx::IntRect&amp; aRect, const mozilla::gfx::Matrix4x4&amp; aTransform)</span>
<span class="lineNum">     608 </span>            : {
<span class="lineNum">     609 </span><span class="lineCov">        247 :     if (aRect.IsEmpty()) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         return mozilla::gfx::IntRect();</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineCov">        247 :     mozilla::gfx::RectDouble rect(aRect.x, aRect.y, aRect.width, aRect.height);</span>
<span class="lineNum">     614 </span><span class="lineCov">        247 :     rect = aTransform.TransformAndClipBounds(rect, mozilla::gfx::RectDouble::MaxIntRect());</span>
<span class="lineNum">     615 </span><span class="lineCov">        247 :     rect.RoundOut();</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">        247 :     mozilla::gfx::IntRect intRect;</span>
<span class="lineNum">     618 </span><span class="lineCov">        247 :     if (!gfxUtils::GfxRectToIntRect(ThebesRect(rect), &amp;intRect)) {</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         return mozilla::gfx::IntRect();</span>
<span class="lineNum">     620 </span>            :     }
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">        247 :     return intRect;</span>
<a name="623"><span class="lineNum">     623 </span>            : }</a>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineCov">        418 : nsRegion&amp; nsRegion::Transform (const mozilla::gfx::Matrix4x4 &amp;aTransform)</span>
<span class="lineNum">     626 </span>            : {
<span class="lineNum">     627 </span>            :   int n;
<span class="lineNum">     628 </span><span class="lineCov">        418 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;mImpl, &amp;n);</span>
<span class="lineNum">     629 </span><span class="lineCov">        665 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     630 </span><span class="lineCov">        494 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     631 </span><span class="lineCov">        247 :     boxes[i] = RectToBox(nsIntRegion::ToRect(TransformRect(nsIntRegion::FromRect(rect), aTransform)));</span>
<span class="lineNum">     632 </span>            :   }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   pixman_region32_t region;
<span class="lineNum">     635 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     636 </span><span class="lineCov">        418 :   pixman_region32_init_rects(&amp;region, boxes, n);</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span><span class="lineCov">        418 :   pixman_region32_fini(&amp;mImpl);</span>
<span class="lineNum">     639 </span><span class="lineCov">        418 :   mImpl = region;</span>
<span class="lineNum">     640 </span><span class="lineCov">        418 :   return *this;</span>
<span class="lineNum">     641 </span>            : }
<a name="642"><span class="lineNum">     642 </span>            : </a>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 : nsRegion nsRegion::ScaleToOtherAppUnitsRoundOut (int32_t aFromAPP, int32_t aToAPP) const</span>
<span class="lineNum">     645 </span>            : {
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   if (aFromAPP == aToAPP) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     648 </span>            :   }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :   nsRegion region = *this;</span>
<span class="lineNum">     651 </span>            :   int n;
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     rect = rect.ScaleToOtherAppUnitsRoundOut(aFromAPP, aToAPP);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     boxes[i] = RectToBox(rect);</span>
<span class="lineNum">     657 </span>            :   }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   pixman_region32_t pixmanRegion;
<span class="lineNum">     660 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   pixman_region32_init_rects(&amp;pixmanRegion, boxes, n);</span>
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :   pixman_region32_fini(&amp;region.mImpl);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   region.mImpl = pixmanRegion;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   return region;</span>
<a name="666"><span class="lineNum">     666 </span>            : }</a>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : nsRegion nsRegion::ScaleToOtherAppUnitsRoundIn (int32_t aFromAPP, int32_t aToAPP) const</span>
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   if (aFromAPP == aToAPP) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     672 </span>            :   }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   nsRegion region = *this;</span>
<span class="lineNum">     675 </span>            :   int n;
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     rect = rect.ScaleToOtherAppUnitsRoundIn(aFromAPP, aToAPP);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     boxes[i] = RectToBox(rect);</span>
<span class="lineNum">     681 </span>            :   }
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :   pixman_region32_t pixmanRegion;
<span class="lineNum">     684 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   pixman_region32_init_rects(&amp;pixmanRegion, boxes, n);</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   pixman_region32_fini(&amp;region.mImpl);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   region.mImpl = pixmanRegion;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   return region;</span>
<a name="690"><span class="lineNum">     690 </span>            : }</a>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">         26 : nsIntRegion nsRegion::ToPixels (nscoord aAppUnitsPerPixel, bool aOutsidePixels) const</span>
<span class="lineNum">     693 </span>            : {
<span class="lineNum">     694 </span><span class="lineCov">         52 :   nsRegion region = *this;</span>
<span class="lineNum">     695 </span>            :   int n;
<span class="lineNum">     696 </span><span class="lineCov">         26 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     697 </span><span class="lineCov">         26 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     mozilla::gfx::IntRect deviceRect;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     if (aOutsidePixels)</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       deviceRect = rect.ToOutsidePixels(aAppUnitsPerPixel);</span>
<span class="lineNum">     702 </span>            :     else
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :       deviceRect = rect.ToNearestPixels(aAppUnitsPerPixel);</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     boxes[i] = RectToBox(deviceRect);</span>
<span class="lineNum">     706 </span>            :   }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineCov">         26 :   nsIntRegion intRegion;</span>
<span class="lineNum">     709 </span><span class="lineCov">         26 :   pixman_region32_fini(&amp;intRegion.mImpl.mImpl);</span>
<span class="lineNum">     710 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     711 </span><span class="lineCov">         26 :   pixman_region32_init_rects(&amp;intRegion.mImpl.mImpl, boxes, n);</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">         52 :   return intRegion;</span>
<a name="714"><span class="lineNum">     714 </span>            : }</a>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : nsIntRegion nsRegion::ToOutsidePixels (nscoord aAppUnitsPerPixel) const</span>
<span class="lineNum">     717 </span>            : {
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   return ToPixels(aAppUnitsPerPixel, true);</span>
<a name="719"><span class="lineNum">     719 </span>            : }</a>
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineCov">         26 : nsIntRegion nsRegion::ToNearestPixels (nscoord aAppUnitsPerPixel) const</span>
<span class="lineNum">     722 </span>            : {
<span class="lineNum">     723 </span><span class="lineCov">         26 :   return ToPixels(aAppUnitsPerPixel, false);</span>
<a name="724"><span class="lineNum">     724 </span>            : }</a>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">        159 : nsIntRegion nsRegion::ScaleToNearestPixels (float aScaleX, float aScaleY,</span>
<span class="lineNum">     727 </span>            :                                             nscoord aAppUnitsPerPixel) const
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span><span class="lineCov">        159 :   nsIntRegion result;</span>
<span class="lineNum">     730 </span><span class="lineCov">        318 :   for (auto iter = RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     731 </span>            :     mozilla::gfx::IntRect deviceRect =
<span class="lineNum">     732 </span><span class="lineCov">        159 :       iter.Get().ScaleToNearestPixels(aScaleX, aScaleY, aAppUnitsPerPixel);</span>
<span class="lineNum">     733 </span><span class="lineCov">        159 :     result.Or(result, deviceRect);</span>
<span class="lineNum">     734 </span>            :   }
<span class="lineNum">     735 </span><span class="lineCov">        159 :   return result;</span>
<a name="736"><span class="lineNum">     736 </span>            : }</a>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineCov">        874 : nsIntRegion nsRegion::ScaleToOutsidePixels (float aScaleX, float aScaleY,</span>
<span class="lineNum">     739 </span>            :                                             nscoord aAppUnitsPerPixel) const
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span>            :   // make a copy of the region so that we can mutate it inplace
<span class="lineNum">     742 </span><span class="lineCov">       1748 :   nsRegion region = *this;</span>
<span class="lineNum">     743 </span>            :   int n;
<span class="lineNum">     744 </span><span class="lineCov">        874 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     745 </span><span class="lineCov">        874 :   boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     746 </span><span class="lineCov">       1283 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">     747 </span><span class="lineCov">        818 :     nsRect rect = BoxToRect(boxes[i]);</span>
<span class="lineNum">     748 </span><span class="lineCov">        409 :     mozilla::gfx::IntRect irect = rect.ScaleToOutsidePixels(aScaleX, aScaleY, aAppUnitsPerPixel);</span>
<span class="lineNum">     749 </span><span class="lineCov">        409 :     boxes[i] = RectToBox(irect);</span>
<span class="lineNum">     750 </span>            :   }
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineCov">        874 :   nsIntRegion iRegion;</span>
<span class="lineNum">     753 </span>            :   // clear out the initial pixman_region so that we can replace it below
<span class="lineNum">     754 </span><span class="lineCov">        874 :   pixman_region32_fini(&amp;iRegion.mImpl.mImpl);</span>
<span class="lineNum">     755 </span>            :   // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     756 </span><span class="lineCov">        874 :   pixman_region32_init_rects(&amp;iRegion.mImpl.mImpl, boxes, n);</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">       1748 :   return iRegion;</span>
<a name="759"><span class="lineNum">     759 </span>            : }</a>
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span><span class="lineCov">         26 : nsIntRegion nsRegion::ScaleToInsidePixels (float aScaleX, float aScaleY,</span>
<span class="lineNum">     762 </span>            :                                            nscoord aAppUnitsPerPixel) const
<span class="lineNum">     763 </span>            : {
<span class="lineNum">     764 </span>            :   /* When scaling a rect, walk forward through the rect list up until the y value is greater
<span class="lineNum">     765 </span>            :    * than the current rect's YMost() value.
<span class="lineNum">     766 </span>            :    *
<span class="lineNum">     767 </span>            :    * For each rect found, check if the rects have a touching edge (in unscaled coordinates),
<span class="lineNum">     768 </span>            :    * and if one edge is entirely contained within the other.
<span class="lineNum">     769 </span>            :    *
<span class="lineNum">     770 </span>            :    * If it is, then the contained edge can be moved (in scaled pixels) to ensure that no
<span class="lineNum">     771 </span>            :    * gap exists.
<span class="lineNum">     772 </span>            :    *
<span class="lineNum">     773 </span>            :    * Since this could be potentially expensive - O(n^2), we only attempt this algorithm
<span class="lineNum">     774 </span>            :    * for the first rect.
<span class="lineNum">     775 </span>            :    */
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :   // make a copy of this region so that we can mutate it in place
<span class="lineNum">     778 </span><span class="lineCov">         52 :   nsRegion region = *this;</span>
<span class="lineNum">     779 </span>            :   int n;
<span class="lineNum">     780 </span><span class="lineCov">         26 :   pixman_box32_t *boxes = pixman_region32_rectangles(&amp;region.mImpl, &amp;n);</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">         26 :   nsIntRegion intRegion;</span>
<span class="lineNum">     783 </span><span class="lineCov">         26 :   if (n) {</span>
<span class="lineNum">     784 </span><span class="lineCov">         52 :     nsRect first = BoxToRect(boxes[0]);</span>
<span class="lineNum">     785 </span>            :     mozilla::gfx::IntRect firstDeviceRect =
<span class="lineNum">     786 </span><span class="lineCov">         26 :       first.ScaleToInsidePixels(aScaleX, aScaleY, aAppUnitsPerPixel);</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">         26 :     for (int i=1; i&lt;n; i++) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :       nsRect rect = nsRect(boxes[i].x1, boxes[i].y1,</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           boxes[i].x2 - boxes[i].x1,</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :           boxes[i].y2 - boxes[i].y1);</span>
<span class="lineNum">     792 </span>            :       mozilla::gfx::IntRect deviceRect =
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         rect.ScaleToInsidePixels(aScaleX, aScaleY, aAppUnitsPerPixel);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       if (rect.y &lt;= first.YMost()) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         if (rect.XMost() == first.x &amp;&amp; rect.YMost() &lt;= first.YMost()) {</span>
<span class="lineNum">     797 </span>            :           // rect is touching on the left edge of the first rect and contained within
<span class="lineNum">     798 </span>            :           // the length of its left edge
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :           deviceRect.SetRightEdge(firstDeviceRect.x);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         } else if (rect.x == first.XMost() &amp;&amp; rect.YMost() &lt;= first.YMost()) {</span>
<span class="lineNum">     801 </span>            :           // rect is touching on the right edge of the first rect and contained within
<span class="lineNum">     802 </span>            :           // the length of its right edge
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :           deviceRect.SetLeftEdge(firstDeviceRect.XMost());</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         } else if (rect.y == first.YMost()) {</span>
<span class="lineNum">     805 </span>            :           // The bottom of the first rect is on the same line as the top of rect, but
<span class="lineNum">     806 </span>            :           // they aren't necessarily contained.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :           if (rect.x &lt;= first.x &amp;&amp; rect.XMost() &gt;= first.XMost()) {</span>
<span class="lineNum">     808 </span>            :             // The top of rect contains the bottom of the first rect
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :             firstDeviceRect.SetBottomEdge(deviceRect.y);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :           } else if (rect.x &gt;= first.x &amp;&amp; rect.XMost() &lt;= first.XMost()) {</span>
<span class="lineNum">     811 </span>            :             // The bottom of the first contains the top of rect
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :             deviceRect.SetTopEdge(firstDeviceRect.YMost());</span>
<span class="lineNum">     813 </span>            :           }
<span class="lineNum">     814 </span>            :         }
<span class="lineNum">     815 </span>            :       }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       boxes[i] = RectToBox(deviceRect);</span>
<span class="lineNum">     818 </span>            :     }
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">         26 :     boxes[0] = RectToBox(firstDeviceRect);</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineCov">         26 :     pixman_region32_fini(&amp;intRegion.mImpl.mImpl);</span>
<span class="lineNum">     823 </span>            :     // This will union all of the rectangles and runs in about O(n lg(n))
<span class="lineNum">     824 </span><span class="lineCov">         26 :     pixman_region32_init_rects(&amp;intRegion.mImpl.mImpl, boxes, n);</span>
<span class="lineNum">     825 </span>            :   }
<span class="lineNum">     826 </span><span class="lineCov">         52 :   return intRegion;</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : // A cell's &quot;value&quot; is a pair consisting of
<span class="lineNum">     831 </span>            : // a) the area of the subrectangle it corresponds to, if it's in
<span class="lineNum">     832 </span>            : // aContainingRect and in the region, 0 otherwise
<span class="lineNum">     833 </span>            : // b) the area of the subrectangle it corresponds to, if it's in the region,
<span class="lineNum">     834 </span>            : // 0 otherwise
<span class="lineNum">     835 </span>            : // Addition, subtraction and identity are defined on these values in the
<span class="lineNum">     836 </span>            : // obvious way. Partial order is lexicographic.
<span class="lineNum">     837 </span>            : // A &quot;large negative value&quot; is defined with large negative numbers for both
<span class="lineNum">     838 </span>            : // fields of the pair. This negative value has the property that adding any
<span class="lineNum">     839 </span>            : // number of non-negative values to it always results in a negative value.
<span class="lineNum">     840 </span>            : //
<span class="lineNum">     841 </span>            : // The GetLargestRectangle algorithm works in three phases:
<span class="lineNum">     842 </span>            : //  1) Convert the region into a grid by adding vertical/horizontal lines for
<span class="lineNum">     843 </span>            : //     each edge of each rectangle in the region.
<span class="lineNum">     844 </span>            : //  2) For each rectangle in the region, for each cell it contains, set that
<span class="lineNum">     845 </span>            : //     cells's value as described above.
<span class="lineNum">     846 </span>            : //  3) Calculate the submatrix with the largest sum such that none of its cells
<span class="lineNum">     847 </span>            : //     contain any 0s (empty regions). The rectangle represented by the
<span class="lineNum">     848 </span>            : //     submatrix is the largest rectangle in the region.
<span class="lineNum">     849 </span>            : //
<span class="lineNum">     850 </span>            : // Let k be the number of rectangles in the region.
<span class="lineNum">     851 </span>            : // Let m be the height of the grid generated in step 1.
<span class="lineNum">     852 </span>            : // Let n be the width of the grid generated in step 1.
<span class="lineNum">     853 </span>            : //
<span class="lineNum">     854 </span>            : // Step 1 is O(k) in time and O(m+n) in space for the sparse grid.
<span class="lineNum">     855 </span>            : // Step 2 is O(mn) in time and O(mn) in additional space for the full grid.
<span class="lineNum">     856 </span>            : // Step 3 is O(m^2 n) in time and O(mn) in additional space
<span class="lineNum">     857 </span>            : //
<span class="lineNum">     858 </span>            : // The implementation of steps 1 and 2 are rather straightforward. However our
<span class="lineNum">     859 </span>            : // implementation of step 3 uses dynamic programming to achieve its efficiency.
<span class="lineNum">     860 </span>            : //
<span class="lineNum">     861 </span>            : // Psuedo code for step 3 is as follows where G is the grid from step 1 and A
<span class="lineNum">     862 </span>            : // is the array from step 2:
<span class="lineNum">     863 </span>            : // Phase3 = function (G, A, m, n) {
<span class="lineNum">     864 </span>            : //   let (t,b,l,r,_) = MaxSum2D(A,m,n)
<span class="lineNum">     865 </span>            : //   return rect(G[t],G[l],G[r],G[b]);
<span class="lineNum">     866 </span>            : // }
<span class="lineNum">     867 </span>            : // MaxSum2D = function (A, m, n) {
<span class="lineNum">     868 </span>            : //   S = array(m+1,n+1)
<span class="lineNum">     869 </span>            : //   S[0][i] = 0 for i in [0,n]
<span class="lineNum">     870 </span>            : //   S[j][0] = 0 for j in [0,m]
<span class="lineNum">     871 </span>            : //   S[j][i] = (if A[j-1][i-1] = 0 then some large negative value else A[j-1][i-1])
<span class="lineNum">     872 </span>            : //           + S[j-1][n] + S[j][i-1] - S[j-1][i-1]
<span class="lineNum">     873 </span>            : //
<span class="lineNum">     874 </span>            : //   // top, bottom, left, right, area
<span class="lineNum">     875 </span>            : //   var maxRect = (-1, -1, -1, -1, 0);
<span class="lineNum">     876 </span>            : //
<span class="lineNum">     877 </span>            : //   for all (m',m'') in [0, m]^2 {
<span class="lineNum">     878 </span>            : //     let B = { S[m'][i] - S[m''][i] | 0 &lt;= i &lt;= n }
<span class="lineNum">     879 </span>            : //     let ((l,r),area) = MaxSum1D(B,n+1)
<span class="lineNum">     880 </span>            : //     if (area &gt; maxRect.area) {
<span class="lineNum">     881 </span>            : //       maxRect := (m', m'', l, r, area)
<span class="lineNum">     882 </span>            : //     }
<span class="lineNum">     883 </span>            : //   }
<span class="lineNum">     884 </span>            : //
<span class="lineNum">     885 </span>            : //   return maxRect;
<span class="lineNum">     886 </span>            : // }
<span class="lineNum">     887 </span>            : //
<span class="lineNum">     888 </span>            : // Originally taken from Improved algorithms for the k-maximum subarray problem
<span class="lineNum">     889 </span>            : // for small k - SE Bae, T Takaoka but modified to show the explicit tracking
<span class="lineNum">     890 </span>            : // of indices and we already have the prefix sums from our one call site so
<span class="lineNum">     891 </span>            : // there's no need to construct them.
<span class="lineNum">     892 </span>            : // MaxSum1D = function (A,n) {
<span class="lineNum">     893 </span>            : //   var minIdx = 0;
<span class="lineNum">     894 </span>            : //   var min = 0;
<span class="lineNum">     895 </span>            : //   var maxIndices = (0,0);
<span class="lineNum">     896 </span>            : //   var max = 0;
<span class="lineNum">     897 </span>            : //   for i in range(n) {
<span class="lineNum">     898 </span>            : //     let cand = A[i] - min;
<span class="lineNum">     899 </span>            : //     if (cand &gt; max) {
<span class="lineNum">     900 </span>            : //       max := cand;
<span class="lineNum">     901 </span>            : //       maxIndices := (minIdx, i)
<span class="lineNum">     902 </span>            : //     }
<span class="lineNum">     903 </span>            : //     if (min &gt; A[i]) {
<span class="lineNum">     904 </span>            : //       min := A[i];
<span class="lineNum">     905 </span>            : //       minIdx := i;
<span class="lineNum">     906 </span>            : //     }
<span class="lineNum">     907 </span>            : //   }
<span class="lineNum">     908 </span>            : //   return (minIdx, maxIdx, max);
<span class="lineNum">     909 </span>            : // }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : namespace {
<a name="912"><span class="lineNum">     912 </span>            :   // This class represents a partitioning of an axis delineated by coordinates.</a>
<span class="lineNum">     913 </span>            :   // It internally maintains a sorted array of coordinates.
<span class="lineNum">     914 </span><span class="lineCov">        236 :   class AxisPartition {</span>
<span class="lineNum">     915 </span>            :   public:
<a name="916"><span class="lineNum">     916 </span>            :     // Adds a new partition at the given coordinate to this partitioning. If</a>
<span class="lineNum">     917 </span>            :     // the coordinate is already present in the partitioning, this does nothing.
<span class="lineNum">     918 </span><span class="lineCov">        708 :     void InsertCoord(nscoord c) {</span>
<span class="lineNum">     919 </span><span class="lineCov">        708 :       uint32_t i = mStops.IndexOfFirstElementGt(c);</span>
<span class="lineNum">     920 </span><span class="lineCov">        708 :       if (i == 0 || mStops[i-1] != c) {</span>
<span class="lineNum">     921 </span><span class="lineCov">        472 :         mStops.InsertElementAt(i, c);</span>
<span class="lineNum">     922 </span>            :       }
<span class="lineNum">     923 </span><span class="lineCov">        708 :     }</span>
<span class="lineNum">     924 </span>            : 
<a name="925"><span class="lineNum">     925 </span>            :     // Returns the array index of the given partition point. The partition</a>
<span class="lineNum">     926 </span>            :     // point must already be present in the partitioning.
<span class="lineNum">     927 </span><span class="lineCov">        708 :     int32_t IndexOf(nscoord p) const {</span>
<span class="lineNum">     928 </span><span class="lineCov">        708 :       return mStops.BinaryIndexOf(p);</span>
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<a name="931"><span class="lineNum">     931 </span>            :     // Returns the partition at the given index which must be non-zero and</a>
<span class="lineNum">     932 </span>            :     // less than the number of partitions in this partitioning.
<span class="lineNum">     933 </span><span class="lineCov">        236 :     nscoord StopAt(int32_t index) const {</span>
<span class="lineNum">     934 </span><span class="lineCov">        236 :       return mStops[index];</span>
<span class="lineNum">     935 </span>            :     }
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :     // Returns the size of the gap between the partition at the given index and
<a name="938"><span class="lineNum">     938 </span>            :     // the next partition in this partitioning. If the index is the last index</a>
<span class="lineNum">     939 </span>            :     // in the partitioning, the result is undefined.
<span class="lineNum">     940 </span><span class="lineCov">        472 :     nscoord StopSize(int32_t index) const {</span>
<span class="lineNum">     941 </span><span class="lineCov">        472 :       return mStops[index+1] - mStops[index];</span>
<span class="lineNum">     942 </span>            :     }
<a name="943"><span class="lineNum">     943 </span>            : </a>
<span class="lineNum">     944 </span>            :     // Returns the number of partitions in this partitioning.
<span class="lineNum">     945 </span><span class="lineCov">        118 :     int32_t GetNumStops() const { return mStops.Length(); }</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :   private:
<span class="lineNum">     948 </span>            :     nsTArray&lt;nscoord&gt; mStops;
<span class="lineNum">     949 </span>            :   };
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :   const int64_t kVeryLargeNegativeNumber = 0xffff000000000000ll;
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :   struct SizePair {
<span class="lineNum">     954 </span>            :     int64_t mSizeContainingRect;
<a name="955"><span class="lineNum">     955 </span>            :     int64_t mSize;</a>
<span class="lineNum">     956 </span>            : 
<a name="957"><span class="lineNum">     957 </span><span class="lineCov">       3894 :     SizePair() : mSizeContainingRect(0), mSize(0) {}</span></a>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span><span class="lineCov">        236 :     static SizePair VeryLargeNegative() {</span>
<span class="lineNum">     960 </span><span class="lineCov">        236 :       SizePair result;</span>
<span class="lineNum">     961 </span><span class="lineCov">        236 :       result.mSize = result.mSizeContainingRect = kVeryLargeNegativeNumber;</span>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">        236 :       return result;</span></a>
<span class="lineNum">     963 </span>            :     }
<span class="lineNum">     964 </span><span class="lineCov">       2478 :     bool operator&lt;(const SizePair&amp; aOther) const {</span>
<span class="lineNum">     965 </span><span class="lineCov">       2478 :       if (mSizeContainingRect &lt; aOther.mSizeContainingRect)</span>
<span class="lineNum">     966 </span><span class="lineCov">        590 :         return true;</span>
<span class="lineNum">     967 </span><span class="lineCov">       1888 :       if (mSizeContainingRect &gt; aOther.mSizeContainingRect)</span>
<span class="lineNum">     968 </span><span class="lineCov">        590 :         return false;</span>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">       1298 :       return mSize &lt; aOther.mSize;</span></a>
<span class="lineNum">     970 </span>            :     }
<span class="lineNum">     971 </span><span class="lineCov">       2478 :     bool operator&gt;(const SizePair&amp; aOther) const {</span>
<a name="972"><span class="lineNum">     972 </span><span class="lineCov">       2478 :       return aOther.operator&lt;(*this);</span></a>
<span class="lineNum">     973 </span>            :     }
<span class="lineNum">     974 </span><span class="lineCov">       1062 :     SizePair operator+(const SizePair&amp; aOther) const {</span>
<span class="lineNum">     975 </span><span class="lineCov">       1062 :       SizePair result = *this;</span>
<span class="lineNum">     976 </span><span class="lineCov">       1062 :       result.mSizeContainingRect += aOther.mSizeContainingRect;</span>
<span class="lineNum">     977 </span><span class="lineCov">       1062 :       result.mSize += aOther.mSize;</span>
<a name="978"><span class="lineNum">     978 </span><span class="lineCov">       1062 :       return result;</span></a>
<span class="lineNum">     979 </span>            :     }
<span class="lineNum">     980 </span><span class="lineCov">       3009 :     SizePair operator-(const SizePair&amp; aOther) const {</span>
<span class="lineNum">     981 </span><span class="lineCov">       3009 :       SizePair result = *this;</span>
<span class="lineNum">     982 </span><span class="lineCov">       3009 :       result.mSizeContainingRect -= aOther.mSizeContainingRect;</span>
<span class="lineNum">     983 </span><span class="lineCov">       3009 :       result.mSize -= aOther.mSize;</span>
<span class="lineNum">     984 </span><span class="lineCov">       3009 :       return result;</span>
<span class="lineNum">     985 </span>            :     }
<span class="lineNum">     986 </span>            :   };
<span class="lineNum">     987 </span>            : 
<a name="988"><span class="lineNum">     988 </span>            :   // Returns the sum and indices of the subarray with the maximum sum of the</a>
<span class="lineNum">     989 </span>            :   // given array (A,n), assuming the array is already in prefix sum form.
<span class="lineNum">     990 </span><span class="lineCov">        354 :   SizePair MaxSum1D(const nsTArray&lt;SizePair&gt; &amp;A, int32_t n,</span>
<span class="lineNum">     991 </span>            :                     int32_t *minIdx, int32_t *maxIdx) {
<span class="lineNum">     992 </span>            :     // The min/max indicies of the largest subarray found so far
<span class="lineNum">     993 </span><span class="lineCov">        354 :     SizePair min, max;</span>
<span class="lineNum">     994 </span><span class="lineCov">        354 :     int32_t currentMinIdx = 0;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">        354 :     *minIdx = 0;</span>
<span class="lineNum">     997 </span><span class="lineCov">        354 :     *maxIdx = 0;</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :     // Because we're given the array in prefix sum form, we know the first
<span class="lineNum">    1000 </span>            :     // element is 0
<span class="lineNum">    1001 </span><span class="lineCov">       1416 :     for(int32_t i = 1; i &lt; n; i++) {</span>
<span class="lineNum">    1002 </span><span class="lineCov">       1062 :       SizePair cand = A[i] - min;</span>
<span class="lineNum">    1003 </span><span class="lineCov">       1062 :       if (cand &gt; max) {</span>
<span class="lineNum">    1004 </span><span class="lineCov">        472 :         max = cand;</span>
<span class="lineNum">    1005 </span><span class="lineCov">        472 :         *minIdx = currentMinIdx;</span>
<span class="lineNum">    1006 </span><span class="lineCov">        472 :         *maxIdx = i;</span>
<span class="lineNum">    1007 </span>            :       }
<span class="lineNum">    1008 </span><span class="lineCov">       1062 :       if (min &gt; A[i]) {</span>
<span class="lineNum">    1009 </span><span class="lineCov">        590 :         min = A[i];</span>
<span class="lineNum">    1010 </span><span class="lineCov">        590 :         currentMinIdx = i;</span>
<span class="lineNum">    1011 </span>            :       }
<span class="lineNum">    1012 </span>            :     }
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span><span class="lineCov">        354 :     return max;</span>
<span class="lineNum">    1015 </span>            :   }
<a name="1016"><span class="lineNum">    1016 </span>            : } // namespace</a>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineCov">         59 : nsRect nsRegion::GetLargestRectangle (const nsRect&amp; aContainingRect) const {</span>
<span class="lineNum">    1019 </span><span class="lineCov">         59 :   nsRect bestRect;</span>
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineCov">         59 :   if (GetNumRects() &lt;= 1) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     bestRect = GetBounds();</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     return bestRect;</span>
<span class="lineNum">    1024 </span>            :   }
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span><span class="lineCov">        118 :   AxisPartition xaxis, yaxis;</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :   // Step 1: Calculate the grid lines
<span class="lineNum">    1029 </span><span class="lineCov">        236 :   for (auto iter = RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1030 </span><span class="lineCov">        177 :     const nsRect&amp; rect = iter.Get();</span>
<span class="lineNum">    1031 </span><span class="lineCov">        177 :     xaxis.InsertCoord(rect.x);</span>
<span class="lineNum">    1032 </span><span class="lineCov">        177 :     xaxis.InsertCoord(rect.XMost());</span>
<span class="lineNum">    1033 </span><span class="lineCov">        177 :     yaxis.InsertCoord(rect.y);</span>
<span class="lineNum">    1034 </span><span class="lineCov">        177 :     yaxis.InsertCoord(rect.YMost());</span>
<span class="lineNum">    1035 </span>            :   }
<span class="lineNum">    1036 </span><span class="lineCov">         59 :   if (!aContainingRect.IsEmpty()) {</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     xaxis.InsertCoord(aContainingRect.x);</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     xaxis.InsertCoord(aContainingRect.XMost());</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     yaxis.InsertCoord(aContainingRect.y);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     yaxis.InsertCoord(aContainingRect.YMost());</span>
<span class="lineNum">    1041 </span>            :   }
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :   // Step 2: Fill out the grid with the areas
<span class="lineNum">    1044 </span>            :   // Note: due to the ordering of rectangles in the region, it is not always
<span class="lineNum">    1045 </span>            :   // possible to combine steps 2 and 3 so we don't try to be clever.
<span class="lineNum">    1046 </span><span class="lineCov">         59 :   int32_t matrixHeight = yaxis.GetNumStops() - 1;</span>
<span class="lineNum">    1047 </span><span class="lineCov">         59 :   int32_t matrixWidth = xaxis.GetNumStops() - 1;</span>
<span class="lineNum">    1048 </span><span class="lineCov">         59 :   int32_t matrixSize = matrixHeight * matrixWidth;</span>
<span class="lineNum">    1049 </span><span class="lineCov">        118 :   nsTArray&lt;SizePair&gt; areas(matrixSize);</span>
<span class="lineNum">    1050 </span><span class="lineCov">         59 :   areas.SetLength(matrixSize);</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov">        236 :   for (auto iter = RectIter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1053 </span><span class="lineCov">        177 :     const nsRect&amp; rect = iter.Get();</span>
<span class="lineNum">    1054 </span><span class="lineCov">        177 :     int32_t xstart = xaxis.IndexOf(rect.x);</span>
<span class="lineNum">    1055 </span><span class="lineCov">        177 :     int32_t xend = xaxis.IndexOf(rect.XMost());</span>
<span class="lineNum">    1056 </span><span class="lineCov">        177 :     int32_t y = yaxis.IndexOf(rect.y);</span>
<span class="lineNum">    1057 </span><span class="lineCov">        177 :     int32_t yend = yaxis.IndexOf(rect.YMost());</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">        531 :     for (; y &lt; yend; y++) {</span>
<span class="lineNum">    1060 </span><span class="lineCov">        177 :       nscoord height = yaxis.StopSize(y);</span>
<span class="lineNum">    1061 </span><span class="lineCov">        472 :       for (int32_t x = xstart; x &lt; xend; x++) {</span>
<span class="lineNum">    1062 </span><span class="lineCov">        295 :         nscoord width = xaxis.StopSize(x);</span>
<span class="lineNum">    1063 </span><span class="lineCov">        295 :         int64_t size = width*int64_t(height);</span>
<span class="lineNum">    1064 </span><span class="lineCov">        295 :         if (rect.Intersects(aContainingRect)) {</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :           areas[y*matrixWidth+x].mSizeContainingRect = size;</span>
<span class="lineNum">    1066 </span>            :         }
<span class="lineNum">    1067 </span><span class="lineCov">        295 :         areas[y*matrixWidth+x].mSize = size;</span>
<span class="lineNum">    1068 </span>            :       }
<span class="lineNum">    1069 </span>            :     }
<span class="lineNum">    1070 </span>            :   }
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :   // Step 3: Find the maximum submatrix sum that does not contain a rectangle
<span class="lineNum">    1073 </span>            :   {
<span class="lineNum">    1074 </span>            :     // First get the prefix sum array
<span class="lineNum">    1075 </span><span class="lineCov">         59 :     int32_t m = matrixHeight + 1;</span>
<span class="lineNum">    1076 </span><span class="lineCov">         59 :     int32_t n = matrixWidth + 1;</span>
<span class="lineNum">    1077 </span><span class="lineCov">        118 :     nsTArray&lt;SizePair&gt; pareas(m*n);</span>
<span class="lineNum">    1078 </span><span class="lineCov">         59 :     pareas.SetLength(m*n);</span>
<span class="lineNum">    1079 </span><span class="lineCov">        236 :     for (int32_t y = 1; y &lt; m; y++) {</span>
<span class="lineNum">    1080 </span><span class="lineCov">        708 :       for (int32_t x = 1; x &lt; n; x++) {</span>
<span class="lineNum">    1081 </span><span class="lineCov">        531 :         SizePair area = areas[(y-1)*matrixWidth+x-1];</span>
<span class="lineNum">    1082 </span><span class="lineCov">        531 :         if (!area.mSize) {</span>
<span class="lineNum">    1083 </span><span class="lineCov">        236 :           area = SizePair::VeryLargeNegative();</span>
<span class="lineNum">    1084 </span>            :         }
<span class="lineNum">    1085 </span><span class="lineCov">       1062 :         area = area + pareas[    y*n+x-1]</span>
<span class="lineNum">    1086 </span><span class="lineCov">       1593 :                     + pareas[(y-1)*n+x  ]</span>
<span class="lineNum">    1087 </span><span class="lineCov">       1062 :                     - pareas[(y-1)*n+x-1];</span>
<span class="lineNum">    1088 </span><span class="lineCov">        531 :         pareas[y*n+x] = area;</span>
<span class="lineNum">    1089 </span>            :       }
<span class="lineNum">    1090 </span>            :     }
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :     // No longer need the grid
<span class="lineNum">    1093 </span><span class="lineCov">         59 :     areas.SetLength(0);</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineCov">         59 :     SizePair bestArea;</span>
<span class="lineNum">    1096 </span>            :     struct {
<span class="lineNum">    1097 </span>            :       int32_t left, top, right, bottom;
<span class="lineNum">    1098 </span><span class="lineCov">         59 :     } bestRectIndices = { 0, 0, 0, 0 };</span>
<span class="lineNum">    1099 </span><span class="lineCov">        295 :     for (int32_t m1 = 0; m1 &lt; m; m1++) {</span>
<span class="lineNum">    1100 </span><span class="lineCov">        590 :       for (int32_t m2 = m1+1; m2 &lt; m; m2++) {</span>
<span class="lineNum">    1101 </span><span class="lineCov">        708 :         nsTArray&lt;SizePair&gt; B;</span>
<span class="lineNum">    1102 </span><span class="lineCov">        354 :         B.SetLength(n);</span>
<span class="lineNum">    1103 </span><span class="lineCov">       1770 :         for (int32_t i = 0; i &lt; n; i++) {</span>
<span class="lineNum">    1104 </span><span class="lineCov">       1416 :           B[i] = pareas[m2*n+i] - pareas[m1*n+i];</span>
<span class="lineNum">    1105 </span>            :         }
<span class="lineNum">    1106 </span>            :         int32_t minIdx, maxIdx;
<span class="lineNum">    1107 </span><span class="lineCov">        354 :         SizePair area = MaxSum1D(B, n, &amp;minIdx, &amp;maxIdx);</span>
<span class="lineNum">    1108 </span><span class="lineCov">        354 :         if (area &gt; bestArea) {</span>
<span class="lineNum">    1109 </span><span class="lineCov">        177 :           bestRectIndices.left = minIdx;</span>
<span class="lineNum">    1110 </span><span class="lineCov">        177 :           bestRectIndices.top = m1;</span>
<span class="lineNum">    1111 </span><span class="lineCov">        177 :           bestRectIndices.right = maxIdx;</span>
<span class="lineNum">    1112 </span><span class="lineCov">        177 :           bestRectIndices.bottom = m2;</span>
<span class="lineNum">    1113 </span><span class="lineCov">        177 :           bestArea = area;</span>
<span class="lineNum">    1114 </span>            :         }
<span class="lineNum">    1115 </span>            :       }
<span class="lineNum">    1116 </span>            :     }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">         59 :     bestRect.MoveTo(xaxis.StopAt(bestRectIndices.left),</span>
<span class="lineNum">    1119 </span><span class="lineCov">         59 :                     yaxis.StopAt(bestRectIndices.top));</span>
<span class="lineNum">    1120 </span><span class="lineCov">         59 :     bestRect.SizeTo(xaxis.StopAt(bestRectIndices.right) - bestRect.x,</span>
<span class="lineNum">    1121 </span><span class="lineCov">        118 :                     yaxis.StopAt(bestRectIndices.bottom) - bestRect.y);</span>
<span class="lineNum">    1122 </span>            :   }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">         59 :   return bestRect;</span>
<a name="1125"><span class="lineNum">    1125 </span>            : }</a>
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 : std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const nsRegion&amp; m) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   stream &lt;&lt; &quot;[&quot;;</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :   int n;
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   pixman_box32_t *boxes = pixman_region32_rectangles(const_cast&lt;pixman_region32_t*&gt;(&amp;m.mImpl), &amp;n);</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :   for (int i=0; i&lt;n; i++) {</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     if (i != 0) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       stream &lt;&lt; &quot;; &quot;;</span>
<span class="lineNum">    1135 </span>            :     }
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     stream &lt;&lt; boxes[i].x1 &lt;&lt; &quot;,&quot; &lt;&lt; boxes[i].y1 &lt;&lt; &quot;,&quot; &lt;&lt; boxes[i].x2 &lt;&lt; &quot;,&quot; &lt;&lt; boxes[i].y2;</span>
<span class="lineNum">    1137 </span>            :   }
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   stream &lt;&lt; &quot;]&quot;;</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   return stream;</span>
<span class="lineNum">    1141 </span>            : }
<a name="1142"><span class="lineNum">    1142 </span>            : </a>
<span class="lineNum">    1143 </span>            : nsCString
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 : nsRegion::ToString() const {</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   return nsCString(mozilla::ToString(*this).c_str());</span>
<span class="lineNum">    1146 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

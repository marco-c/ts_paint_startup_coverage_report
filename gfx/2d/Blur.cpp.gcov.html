<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/2d/Blur.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/2d</a> - Blur.cpp<span style="font-size: 80%;"> (source / <a href="Blur.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">81</td>
            <td class="headerCovTableEntry">364</td>
            <td class="headerCovTableEntryLo">22.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryLo">44.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;Blur.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      10 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      11 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;mozilla/CheckedInt.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;2D.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;DataSurfaceHelpers.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;Tools.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #ifdef BUILD_ARM_NEON
<span class="lineNum">      20 </span>            : #include &quot;mozilla/arm.h&quot;
<span class="lineNum">      21 </span>            : #endif
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : using namespace std;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : namespace mozilla {
<span class="lineNum">      26 </span>            : namespace gfx {
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /**
<span class="lineNum">      29 </span>            :  * Helper function to process each row of the box blur.
<span class="lineNum">      30 </span>            :  * It takes care of transposing the data on input or output depending
<span class="lineNum">      31 </span>            :  * on whether we intend a horizontal or vertical blur, and whether we're
<span class="lineNum">      32 </span>            :  * reading from the initial source or writing to the final destination.
<span class="lineNum">      33 </span>            :  * It allows starting or ending anywhere within the row to accomodate
<span class="lineNum">      34 </span>            :  * a skip rect.
<span class="lineNum">      35 </span>            :  */
<a name="36"><span class="lineNum">      36 </span>            : template&lt;bool aTransposeInput, bool aTransposeOutput&gt;</a>
<span class="lineNum">      37 </span>            : static inline void
<span class="lineNum">      38 </span><span class="lineNoCov">          0 : BoxBlurRow(const uint8_t* aInput,</span>
<span class="lineNum">      39 </span>            :            uint8_t* aOutput,
<span class="lineNum">      40 </span>            :            int32_t aLeftLobe,
<span class="lineNum">      41 </span>            :            int32_t aRightLobe,
<span class="lineNum">      42 </span>            :            int32_t aWidth,
<span class="lineNum">      43 </span>            :            int32_t aStride,
<span class="lineNum">      44 </span>            :            int32_t aStart,
<span class="lineNum">      45 </span>            :            int32_t aEnd)
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :   // If the input or output is transposed, then we will move down a row
<span class="lineNum">      48 </span>            :   // for each step, instead of moving over a column. Since these values
<span class="lineNum">      49 </span>            :   // only depend on a template parameter, they will more easily get
<span class="lineNum">      50 </span>            :   // copy-propagated in the non-transposed case, which is why they
<span class="lineNum">      51 </span>            :   // are not passed as parameters.
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   const int32_t inputStep = aTransposeInput ? aStride : 1;</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   const int32_t outputStep = aTransposeOutput ? aStride : 1;</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :   // We need to sample aLeftLobe pixels to the left and aRightLobe pixels
<span class="lineNum">      56 </span>            :   // to the right of the current position, then average them. So this is
<span class="lineNum">      57 </span>            :   // the size of the total width of this filter.
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   const int32_t boxSize = aLeftLobe + aRightLobe + 1;</span>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   // Instead of dividing the pixel sum by boxSize to average, we can just
<span class="lineNum">      61 </span>            :   // compute a scale that will normalize the result so that it can be quickly
<span class="lineNum">      62 </span>            :   // shifted into the desired range.
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   const uint32_t reciprocal = (1 &lt;&lt; 24) / boxSize;</span>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :   // The shift would normally truncate the result, whereas we would rather
<span class="lineNum">      66 </span>            :   // prefer to round the result to the closest increment. By adding 0.5 units
<span class="lineNum">      67 </span>            :   // to the initial sum, we bias the sum so that it will be rounded by the
<span class="lineNum">      68 </span>            :   // truncation instead.
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   uint32_t alphaSum = (boxSize + 1) / 2;</span>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            :   // We process the row with a moving filter, keeping a sum (alphaSum) of
<span class="lineNum">      72 </span>            :   // boxSize pixels. As we move over a pixel, we need to add on a pixel
<span class="lineNum">      73 </span>            :   // from the right extreme of the window that moved into range, and subtract
<span class="lineNum">      74 </span>            :   // off a pixel from the left extreme of window that moved out of range.
<span class="lineNum">      75 </span>            :   // But first, we need to initialization alphaSum to the contents of
<span class="lineNum">      76 </span>            :   // the window before we can get going. If the window moves out of bounds
<span class="lineNum">      77 </span>            :   // of the row, we clamp each sample to be the closest pixel from within
<span class="lineNum">      78 </span>            :   // row bounds, so the 0th and aWidth-1th pixel.
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   int32_t initLeft = aStart - aLeftLobe;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   if (initLeft &lt; 0) {</span>
<span class="lineNum">      81 </span>            :     // If the left lobe samples before the row, add in clamped samples.
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     alphaSum += -initLeft * aInput[0];</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     initLeft = 0;</span>
<span class="lineNum">      84 </span>            :   }
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   int32_t initRight = aStart + boxSize - aLeftLobe;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   if (initRight &gt; aWidth) {</span>
<span class="lineNum">      87 </span>            :     // If the right lobe samples after the row, add in clamped samples.
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     alphaSum += (initRight - aWidth) * aInput[(aWidth - 1) * inputStep];</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     initRight = aWidth;</span>
<span class="lineNum">      90 </span>            :   }
<span class="lineNum">      91 </span>            :   // Finally, add in all the valid, non-clamped samples to fill up the
<span class="lineNum">      92 </span>            :   // rest of the window.
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   const uint8_t* src = &amp;aInput[initLeft * inputStep];</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   const uint8_t* iterEnd = &amp;aInput[initRight * inputStep];</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   #define INIT_ITER \
<span class="lineNum">      97 </span>            :     alphaSum += *src; \
<span class="lineNum">      98 </span>            :     src += inputStep;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :   // We unroll the per-pixel loop here substantially. The amount of work
<span class="lineNum">     101 </span>            :   // done per sample is so small that the cost of a loop condition check
<span class="lineNum">     102 </span>            :   // and a branch can substantially add to or even dominate the performance
<span class="lineNum">     103 </span>            :   // of the loop.
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   while (src + 16 * inputStep &lt;= iterEnd) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     INIT_ITER; INIT_ITER; INIT_ITER; INIT_ITER;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     INIT_ITER; INIT_ITER; INIT_ITER; INIT_ITER;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     INIT_ITER; INIT_ITER; INIT_ITER; INIT_ITER;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     INIT_ITER; INIT_ITER; INIT_ITER; INIT_ITER;</span>
<span class="lineNum">     109 </span>            :   }
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   while (src &lt; iterEnd) {</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     INIT_ITER;</span>
<span class="lineNum">     112 </span>            :   }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :   // Now we start moving the window over the row. We will be accessing
<span class="lineNum">     115 </span>            :   // pixels form aStart - aLeftLobe up to aEnd + aRightLobe, which may be
<span class="lineNum">     116 </span>            :   // out of bounds of the row. To avoid having to check within the inner
<span class="lineNum">     117 </span>            :   // loops if we are in bound, we instead compute the points at which
<span class="lineNum">     118 </span>            :   // we will move out of bounds of the row on the left side (splitLeft)
<span class="lineNum">     119 </span>            :   // and right side (splitRight).
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   int32_t splitLeft = min(max(aLeftLobe, aStart), aEnd);</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   int32_t splitRight = min(max(aWidth - (boxSize - aLeftLobe), aStart), aEnd);</span>
<span class="lineNum">     122 </span>            :   // If the filter window is actually large than the size of the row,
<span class="lineNum">     123 </span>            :   // there will be a middle area of overlap where the leftmost and rightmost
<span class="lineNum">     124 </span>            :   // pixel of the filter will both be outside the row. In this case, we need
<span class="lineNum">     125 </span>            :   // to invert the splits so that splitLeft &lt;= splitRight.
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   if (boxSize &gt; aWidth) {</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     swap(splitLeft, splitRight);</span>
<span class="lineNum">     128 </span>            :   }
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :   // Process all pixels up to splitLeft that would sample before the start of the row.
<span class="lineNum">     131 </span>            :   // Note that because inputStep and outputStep may not be a const 1 value, it is more
<span class="lineNum">     132 </span>            :   // performant to increment pointers here for the source and destination rather than
<span class="lineNum">     133 </span>            :   // use a loop counter, since doing so would entail an expensive multiplication that
<span class="lineNum">     134 </span>            :   // significantly slows down the loop.
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   uint8_t* dst = &amp;aOutput[aStart * outputStep];</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   iterEnd = &amp;aOutput[splitLeft * outputStep];</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   src = &amp;aInput[(aStart + boxSize - aLeftLobe) * inputStep];</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   uint8_t firstVal = aInput[0];</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   #define LEFT_ITER \
<span class="lineNum">     141 </span>            :     *dst = (alphaSum * reciprocal) &gt;&gt; 24; \
<span class="lineNum">     142 </span>            :     alphaSum += *src - firstVal; \
<span class="lineNum">     143 </span>            :     dst += outputStep; \
<span class="lineNum">     144 </span>            :     src += inputStep;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   while (dst + 16 * outputStep &lt;= iterEnd) {</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     LEFT_ITER; LEFT_ITER; LEFT_ITER; LEFT_ITER;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     LEFT_ITER; LEFT_ITER; LEFT_ITER; LEFT_ITER;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     LEFT_ITER; LEFT_ITER; LEFT_ITER; LEFT_ITER;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     LEFT_ITER; LEFT_ITER; LEFT_ITER; LEFT_ITER;</span>
<span class="lineNum">     151 </span>            :   }
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   while (dst &lt; iterEnd) {</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     LEFT_ITER;</span>
<span class="lineNum">     154 </span>            :   }
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   // Process all pixels between splitLeft and splitRight.
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   iterEnd = &amp;aOutput[splitRight * outputStep];</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   if (boxSize &lt;= aWidth) {</span>
<span class="lineNum">     159 </span>            :     // The filter window is smaller than the row size, so the leftmost and rightmost
<span class="lineNum">     160 </span>            :     // samples are both within row bounds.
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     src = &amp;aInput[(splitLeft - aLeftLobe) * inputStep];</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     int32_t boxStep = boxSize * inputStep;</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     #define CENTER_ITER \
<span class="lineNum">     165 </span>            :       *dst = (alphaSum * reciprocal) &gt;&gt; 24; \
<span class="lineNum">     166 </span>            :       alphaSum += src[boxStep] - *src; \
<span class="lineNum">     167 </span>            :       dst += outputStep; \
<span class="lineNum">     168 </span>            :       src += inputStep;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     while (dst +  16 * outputStep &lt;= iterEnd) {</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :       CENTER_ITER; CENTER_ITER; CENTER_ITER; CENTER_ITER;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       CENTER_ITER; CENTER_ITER; CENTER_ITER; CENTER_ITER;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       CENTER_ITER; CENTER_ITER; CENTER_ITER; CENTER_ITER;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       CENTER_ITER; CENTER_ITER; CENTER_ITER; CENTER_ITER;</span>
<span class="lineNum">     175 </span>            :     }
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     while (dst &lt; iterEnd) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :       CENTER_ITER;</span>
<span class="lineNum">     178 </span>            :     }
<span class="lineNum">     179 </span>            :   } else {
<span class="lineNum">     180 </span>            :     // The filter window is larger than the row size, and we're in the area of split
<span class="lineNum">     181 </span>            :     // overlap. So the leftmost and rightmost samples are both out of bounds and need
<span class="lineNum">     182 </span>            :     // to be clamped. We can just precompute the difference here consequently.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     int32_t firstLastDiff = aInput[(aWidth -1) * inputStep] - aInput[0];</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     while (dst &lt; iterEnd) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       *dst = (alphaSum * reciprocal) &gt;&gt; 24;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       alphaSum += firstLastDiff;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       dst += outputStep;</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   // Process all remaining pixels after splitRight that would sample after the row end.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   iterEnd = &amp;aOutput[aEnd * outputStep];</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   src = &amp;aInput[(splitRight - aLeftLobe) * inputStep];</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   uint8_t lastVal = aInput[(aWidth - 1) * inputStep];</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   #define RIGHT_ITER \
<span class="lineNum">     197 </span>            :     *dst = (alphaSum * reciprocal) &gt;&gt; 24; \
<span class="lineNum">     198 </span>            :     alphaSum += lastVal - *src; \
<span class="lineNum">     199 </span>            :     dst += outputStep; \
<span class="lineNum">     200 </span>            :     src += inputStep;
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   while (dst + 16 * outputStep &lt;= iterEnd) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     RIGHT_ITER; RIGHT_ITER; RIGHT_ITER; RIGHT_ITER;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     RIGHT_ITER; RIGHT_ITER; RIGHT_ITER; RIGHT_ITER;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     RIGHT_ITER; RIGHT_ITER; RIGHT_ITER; RIGHT_ITER;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     RIGHT_ITER; RIGHT_ITER; RIGHT_ITER; RIGHT_ITER;</span>
<span class="lineNum">     207 </span>            :   }
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   while (dst &lt; iterEnd) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     RIGHT_ITER;</span>
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : /**
<span class="lineNum">     214 </span>            :  * Box blur involves looking at one pixel, and setting its value to the average
<span class="lineNum">     215 </span>            :  * of its neighbouring pixels. This is meant to provide a 3-pass approximation of a
<span class="lineNum">     216 </span>            :  * Gaussian blur.
<span class="lineNum">     217 </span>            :  * @param aTranspose Whether to transpose the buffer when reading and writing to it.
<span class="lineNum">     218 </span>            :  * @param aData The buffer to be blurred.
<span class="lineNum">     219 </span>            :  * @param aLobes The number of pixels to blend on the left and right for each of 3 passes.
<span class="lineNum">     220 </span>            :  * @param aWidth The number of columns in the buffers.
<span class="lineNum">     221 </span>            :  * @param aRows The number of rows in the buffers.
<span class="lineNum">     222 </span>            :  * @param aStride The stride of the buffer.
<span class="lineNum">     223 </span>            :  */
<a name="224"><span class="lineNum">     224 </span>            : template&lt;bool aTranspose&gt;</a>
<span class="lineNum">     225 </span>            : static void
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : BoxBlur(uint8_t* aData,</span>
<span class="lineNum">     227 </span>            :         const int32_t aLobes[3][2],
<span class="lineNum">     228 </span>            :         int32_t aWidth,
<span class="lineNum">     229 </span>            :         int32_t aRows,
<span class="lineNum">     230 </span>            :         int32_t aStride,
<span class="lineNum">     231 </span>            :         IntRect aSkipRect)
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span>            :   if (aTranspose) {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     swap(aWidth, aRows);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     swap(aSkipRect.x, aSkipRect.y);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     swap(aSkipRect.width, aSkipRect.height);</span>
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aWidth &gt; 0);</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   // All three passes of the box blur that approximate the Gaussian are done
<span class="lineNum">     242 </span>            :   // on each row in turn, so we only need two temporary row buffers to process
<span class="lineNum">     243 </span>            :   // each row, instead of a full-sized buffer. Data moves from the source to the
<span class="lineNum">     244 </span>            :   // first temporary, from the first temporary to the second, then from the second
<span class="lineNum">     245 </span>            :   // back to the destination. This way is more cache-friendly than processing whe
<span class="lineNum">     246 </span>            :   // whole buffer in each pass and thus yields a nice speedup.
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   uint8_t* tmpRow = new (std::nothrow) uint8_t[2 * aWidth];</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   if (!tmpRow) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     250 </span>            :   }
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   uint8_t* tmpRow2 = tmpRow + aWidth;</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   const int32_t stride = aTranspose ? 1 : aStride;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   bool skipRectCoversWholeRow = 0 &gt;= aSkipRect.x &amp;&amp;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                                 aWidth &lt;= aSkipRect.XMost();</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   for (int32_t y = 0; y &lt; aRows; y++) {</span>
<span class="lineNum">     258 </span>            :     // Check whether the skip rect intersects this row. If the skip
<span class="lineNum">     259 </span>            :     // rect covers the whole surface in this row, we can avoid
<span class="lineNum">     260 </span>            :     // this row entirely (and any others along the skip rect).
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     bool inSkipRectY = y &gt;= aSkipRect.y &amp;&amp;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                        y &lt; aSkipRect.YMost();</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if (inSkipRectY &amp;&amp; skipRectCoversWholeRow) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       aData += stride * (aSkipRect.YMost() - y);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       y = aSkipRect.YMost() - 1;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     267 </span>            :     }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :     // Read in data from the source transposed if necessary.
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     BoxBlurRow&lt;aTranspose, false&gt;(aData, tmpRow, aLobes[0][0], aLobes[0][1], aWidth, aStride, 0, aWidth);</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     // For the middle pass, the data is already pre-transposed and does not need to be post-transposed yet.
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     BoxBlurRow&lt;false, false&gt;(tmpRow, tmpRow2, aLobes[1][0], aLobes[1][1], aWidth, aStride, 0, aWidth);</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     // Write back data to the destination transposed if necessary too.
<span class="lineNum">     276 </span>            :     // Make sure not to overwrite the skip rect by only outputting to the
<span class="lineNum">     277 </span>            :     // destination before and after the skip rect, if requested.
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     int32_t skipStart = inSkipRectY ? min(max(aSkipRect.x, 0), aWidth) : aWidth;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     int32_t skipEnd = max(skipStart, aSkipRect.XMost());</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     if (skipStart &gt; 0) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       BoxBlurRow&lt;false, aTranspose&gt;(tmpRow2, aData, aLobes[2][0], aLobes[2][1], aWidth, aStride, 0, skipStart);</span>
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     if (skipEnd &lt; aWidth) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       BoxBlurRow&lt;false, aTranspose&gt;(tmpRow2, aData, aLobes[2][0], aLobes[2][1], aWidth, aStride, skipEnd, aWidth);</span>
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     aData += stride;</span>
<span class="lineNum">     288 </span>            :   }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   delete[] tmpRow;</span>
<a name="291"><span class="lineNum">     291 </span>            : }</a>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineCov">          2 : static void ComputeLobes(int32_t aRadius, int32_t aLobes[3][2])</span>
<span class="lineNum">     294 </span>            : {
<span class="lineNum">     295 </span>            :     int32_t major, minor, final;
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     /* See http://www.w3.org/TR/SVG/filters.html#feGaussianBlur for
<span class="lineNum">     298 </span>            :      * some notes about approximating the Gaussian blur with box-blurs.
<span class="lineNum">     299 </span>            :      * The comments below are in the terminology of that page.
<span class="lineNum">     300 </span>            :      */
<span class="lineNum">     301 </span><span class="lineCov">          2 :     int32_t z = aRadius / 3;</span>
<span class="lineNum">     302 </span><span class="lineCov">          2 :     switch (aRadius % 3) {</span>
<span class="lineNum">     303 </span>            :     case 0:
<span class="lineNum">     304 </span>            :         // aRadius = z*3; choose d = 2*z + 1
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         major = minor = final = z;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     307 </span>            :     case 1:
<span class="lineNum">     308 </span>            :         // aRadius = z*3 + 1
<span class="lineNum">     309 </span>            :         // This is a tricky case since there is no value of d which will
<span class="lineNum">     310 </span>            :         // yield a radius of exactly aRadius. If d is odd, i.e. d=2*k + 1
<span class="lineNum">     311 </span>            :         // for some integer k, then the radius will be 3*k. If d is even,
<span class="lineNum">     312 </span>            :         // i.e. d=2*k, then the radius will be 3*k - 1.
<span class="lineNum">     313 </span>            :         // So we have to choose values that don't match the standard
<span class="lineNum">     314 </span>            :         // algorithm.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         major = z + 1;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         minor = final = z;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     318 </span>            :     case 2:
<span class="lineNum">     319 </span>            :         // aRadius = z*3 + 2; choose d = 2*z + 2
<span class="lineNum">     320 </span><span class="lineCov">          2 :         major = final = z + 1;</span>
<span class="lineNum">     321 </span><span class="lineCov">          2 :         minor = z;</span>
<span class="lineNum">     322 </span><span class="lineCov">          2 :         break;</span>
<span class="lineNum">     323 </span>            :     default:
<span class="lineNum">     324 </span>            :         // Mathematical impossibility!
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(false);</span>
<span class="lineNum">     326 </span>            :         major = minor = final = 0;
<span class="lineNum">     327 </span>            :     }
<span class="lineNum">     328 </span><span class="lineCov">          2 :     MOZ_ASSERT(major + minor + final == aRadius);</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">          2 :     aLobes[0][0] = major;</span>
<span class="lineNum">     331 </span><span class="lineCov">          2 :     aLobes[0][1] = minor;</span>
<span class="lineNum">     332 </span><span class="lineCov">          2 :     aLobes[1][0] = minor;</span>
<span class="lineNum">     333 </span><span class="lineCov">          2 :     aLobes[1][1] = major;</span>
<span class="lineNum">     334 </span><span class="lineCov">          2 :     aLobes[2][0] = final;</span>
<span class="lineNum">     335 </span><span class="lineCov">          2 :     aLobes[2][1] = final;</span>
<span class="lineNum">     336 </span><span class="lineCov">          2 : }</span>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<span class="lineNum">     338 </span>            : static void
<span class="lineNum">     339 </span><span class="lineNoCov">          0 : SpreadHorizontal(uint8_t* aInput,</span>
<span class="lineNum">     340 </span>            :                  uint8_t* aOutput,
<span class="lineNum">     341 </span>            :                  int32_t aRadius,
<span class="lineNum">     342 </span>            :                  int32_t aWidth,
<span class="lineNum">     343 </span>            :                  int32_t aRows,
<span class="lineNum">     344 </span>            :                  int32_t aStride,
<span class="lineNum">     345 </span>            :                  const IntRect&amp; aSkipRect)
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     if (aRadius == 0) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         memcpy(aOutput, aInput, aStride * aRows);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     bool skipRectCoversWholeRow = 0 &gt;= aSkipRect.x &amp;&amp;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                                     aWidth &lt;= aSkipRect.XMost();</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     for (int32_t y = 0; y &lt; aRows; y++) {</span>
<span class="lineNum">     355 </span>            :         // Check whether the skip rect intersects this row. If the skip
<span class="lineNum">     356 </span>            :         // rect covers the whole surface in this row, we can avoid
<span class="lineNum">     357 </span>            :         // this row entirely (and any others along the skip rect).
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         bool inSkipRectY = y &gt;= aSkipRect.y &amp;&amp;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :                              y &lt; aSkipRect.YMost();</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         if (inSkipRectY &amp;&amp; skipRectCoversWholeRow) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             y = aSkipRect.YMost() - 1;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     363 </span>            :         }
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         for (int32_t x = 0; x &lt; aWidth; x++) {</span>
<span class="lineNum">     366 </span>            :             // Check whether we are within the skip rect. If so, go
<span class="lineNum">     367 </span>            :             // to the next point outside the skip rect.
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :             if (inSkipRectY &amp;&amp; x &gt;= aSkipRect.x &amp;&amp;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                 x &lt; aSkipRect.XMost()) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 x = aSkipRect.XMost();</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                 if (x &gt;= aWidth)</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     373 </span>            :             }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :             int32_t sMin = max(x - aRadius, 0);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :             int32_t sMax = min(x + aRadius, aWidth - 1);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :             int32_t v = 0;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             for (int32_t s = sMin; s &lt;= sMax; ++s) {</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 v = max&lt;int32_t&gt;(v, aInput[aStride * y + s]);</span>
<span class="lineNum">     380 </span>            :             }
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             aOutput[aStride * y + x] = v;</span>
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            :     }
<span class="lineNum">     384 </span>            : }
<a name="385"><span class="lineNum">     385 </span>            : </a>
<span class="lineNum">     386 </span>            : static void
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : SpreadVertical(uint8_t* aInput,</span>
<span class="lineNum">     388 </span>            :                uint8_t* aOutput,
<span class="lineNum">     389 </span>            :                int32_t aRadius,
<span class="lineNum">     390 </span>            :                int32_t aWidth,
<span class="lineNum">     391 </span>            :                int32_t aRows,
<span class="lineNum">     392 </span>            :                int32_t aStride,
<span class="lineNum">     393 </span>            :                const IntRect&amp; aSkipRect)
<span class="lineNum">     394 </span>            : {
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     if (aRadius == 0) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         memcpy(aOutput, aInput, aStride * aRows);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     398 </span>            :     }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     bool skipRectCoversWholeColumn = 0 &gt;= aSkipRect.y &amp;&amp;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                                      aRows &lt;= aSkipRect.YMost();</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     for (int32_t x = 0; x &lt; aWidth; x++) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         bool inSkipRectX = x &gt;= aSkipRect.x &amp;&amp;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                            x &lt; aSkipRect.XMost();</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         if (inSkipRectX &amp;&amp; skipRectCoversWholeColumn) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             x = aSkipRect.XMost() - 1;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     408 </span>            :         }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         for (int32_t y = 0; y &lt; aRows; y++) {</span>
<span class="lineNum">     411 </span>            :             // Check whether we are within the skip rect. If so, go
<span class="lineNum">     412 </span>            :             // to the next point outside the skip rect.
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             if (inSkipRectX &amp;&amp; y &gt;= aSkipRect.y &amp;&amp;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                 y &lt; aSkipRect.YMost()) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :                 y = aSkipRect.YMost();</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                 if (y &gt;= aRows)</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     418 </span>            :             }
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             int32_t sMin = max(y - aRadius, 0);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             int32_t sMax = min(y + aRadius, aRows - 1);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :             int32_t v = 0;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :             for (int32_t s = sMin; s &lt;= sMax; ++s) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                 v = max&lt;int32_t&gt;(v, aInput[aStride * s + x]);</span>
<span class="lineNum">     425 </span>            :             }
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             aOutput[aStride * y + x] = v;</span>
<span class="lineNum">     427 </span>            :         }
<span class="lineNum">     428 </span>            :     }
<span class="lineNum">     429 </span>            : }
<a name="430"><span class="lineNum">     430 </span>            : </a>
<span class="lineNum">     431 </span>            : CheckedInt&lt;int32_t&gt;
<span class="lineNum">     432 </span><span class="lineCov">          5 : AlphaBoxBlur::RoundUpToMultipleOf4(int32_t aVal)</span>
<span class="lineNum">     433 </span>            : {
<span class="lineNum">     434 </span><span class="lineCov">          5 :   CheckedInt&lt;int32_t&gt; val(aVal);</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">          5 :   val += 3;</span>
<span class="lineNum">     437 </span><span class="lineCov">          5 :   val /= 4;</span>
<span class="lineNum">     438 </span><span class="lineCov">          5 :   val *= 4;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">          5 :   return val;</span>
<a name="441"><span class="lineNum">     441 </span>            : }</a>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 : AlphaBoxBlur::AlphaBoxBlur(const Rect&amp; aRect,</span>
<span class="lineNum">     444 </span>            :                            const IntSize&amp; aSpreadRadius,
<span class="lineNum">     445 </span>            :                            const IntSize&amp; aBlurRadius,
<span class="lineNum">     446 </span>            :                            const Rect* aDirtyRect,
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                            const Rect* aSkipRect)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   : mSurfaceAllocationSize(0)</span>
<span class="lineNum">     449 </span>            : {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   Init(aRect, aSpreadRadius, aBlurRadius, aDirtyRect, aSkipRect);</span>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">         11 : AlphaBoxBlur::AlphaBoxBlur()</span>
<span class="lineNum">     454 </span><span class="lineCov">         11 :   : mSurfaceAllocationSize(0)</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineCov">         11 : }</span>
<a name="457"><span class="lineNum">     457 </span>            : </a>
<span class="lineNum">     458 </span>            : void
<span class="lineNum">     459 </span><span class="lineCov">          1 : AlphaBoxBlur::Init(const Rect&amp; aRect,</span>
<span class="lineNum">     460 </span>            :                    const IntSize&amp; aSpreadRadius,
<span class="lineNum">     461 </span>            :                    const IntSize&amp; aBlurRadius,
<span class="lineNum">     462 </span>            :                    const Rect* aDirtyRect,
<span class="lineNum">     463 </span>            :                    const Rect* aSkipRect)
<span class="lineNum">     464 </span>            : {
<span class="lineNum">     465 </span><span class="lineCov">          1 :   mSpreadRadius = aSpreadRadius;</span>
<span class="lineNum">     466 </span><span class="lineCov">          1 :   mBlurRadius = aBlurRadius;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">          1 :   Rect rect(aRect);</span>
<span class="lineNum">     469 </span><span class="lineCov">          1 :   rect.Inflate(Size(aBlurRadius + aSpreadRadius));</span>
<span class="lineNum">     470 </span><span class="lineCov">          1 :   rect.RoundOut();</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">          1 :   if (aDirtyRect) {</span>
<span class="lineNum">     473 </span>            :     // If we get passed a dirty rect from layout, we can minimize the
<span class="lineNum">     474 </span>            :     // shadow size and make painting faster.
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     mHasDirtyRect = true;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     mDirtyRect = *aDirtyRect;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     Rect requiredBlurArea = mDirtyRect.Intersect(rect);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     requiredBlurArea.Inflate(Size(aBlurRadius + aSpreadRadius));</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     rect = requiredBlurArea.Intersect(rect);</span>
<span class="lineNum">     480 </span>            :   } else {
<span class="lineNum">     481 </span><span class="lineCov">          1 :     mHasDirtyRect = false;</span>
<span class="lineNum">     482 </span>            :   }
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineCov">          1 :   mRect = TruncatedToInt(rect);</span>
<span class="lineNum">     485 </span><span class="lineCov">          1 :   if (mRect.IsEmpty()) {</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     487 </span>            :   }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineCov">          1 :   if (aSkipRect) {</span>
<span class="lineNum">     490 </span>            :     // If we get passed a skip rect, we can lower the amount of
<span class="lineNum">     491 </span>            :     // blurring/spreading we need to do. We convert it to IntRect to avoid
<span class="lineNum">     492 </span>            :     // expensive int&lt;-&gt;float conversions if we were to use Rect instead.
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     Rect skipRect = *aSkipRect;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     skipRect.Deflate(Size(aBlurRadius + aSpreadRadius));</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     mSkipRect = RoundedIn(skipRect);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     mSkipRect = mSkipRect.Intersect(mRect);</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     if (mSkipRect.IsEqualInterior(mRect))</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     mSkipRect -= mRect.TopLeft();</span>
<span class="lineNum">     501 </span>            :   } else {
<span class="lineNum">     502 </span><span class="lineCov">          1 :     mSkipRect = IntRect(0, 0, 0, 0);</span>
<span class="lineNum">     503 </span>            :   }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineCov">          1 :   CheckedInt&lt;int32_t&gt; stride = RoundUpToMultipleOf4(mRect.width);</span>
<span class="lineNum">     506 </span><span class="lineCov">          1 :   if (stride.isValid()) {</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 :     mStride = stride.value();</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :     // We need to leave room for an additional 3 bytes for a potential overrun
<span class="lineNum">     510 </span>            :     // in our blurring code.
<span class="lineNum">     511 </span><span class="lineCov">          1 :     size_t size = BufferSizeFromStrideAndHeight(mStride, mRect.height, 3);</span>
<span class="lineNum">     512 </span><span class="lineCov">          1 :     if (size != 0) {</span>
<span class="lineNum">     513 </span><span class="lineCov">          1 :       mSurfaceAllocationSize = size;</span>
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span>            :   }
<a name="516"><span class="lineNum">     516 </span>            : }</a>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : AlphaBoxBlur::AlphaBoxBlur(const Rect&amp; aRect,</span>
<span class="lineNum">     519 </span>            :                            int32_t aStride,
<span class="lineNum">     520 </span>            :                            float aSigmaX,
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                            float aSigmaY)</span>
<span class="lineNum">     522 </span>            :   : mRect(TruncatedToInt(aRect)),
<span class="lineNum">     523 </span>            :     mSpreadRadius(),
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     mBlurRadius(CalculateBlurRadius(Point(aSigmaX, aSigmaY))),</span>
<span class="lineNum">     525 </span>            :     mStride(aStride),
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     mSurfaceAllocationSize(0)</span>
<span class="lineNum">     527 </span>            : {
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   IntRect intRect;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   if (aRect.ToIntRect(&amp;intRect)) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     size_t minDataSize = BufferSizeFromStrideAndHeight(intRect.width, intRect.height);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     if (minDataSize != 0) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :       mSurfaceAllocationSize = minDataSize;</span>
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span>            :   }
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : }</span>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">         11 : AlphaBoxBlur::~AlphaBoxBlur()</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span><span class="lineCov">         11 : }</span>
<a name="541"><span class="lineNum">     541 </span>            : </a>
<span class="lineNum">     542 </span>            : IntSize
<span class="lineNum">     543 </span><span class="lineCov">          5 : AlphaBoxBlur::GetSize()</span>
<span class="lineNum">     544 </span>            : {
<span class="lineNum">     545 </span><span class="lineCov">          5 :   IntSize size(mRect.width, mRect.height);</span>
<span class="lineNum">     546 </span><span class="lineCov">          5 :   return size;</span>
<span class="lineNum">     547 </span>            : }
<a name="548"><span class="lineNum">     548 </span>            : </a>
<span class="lineNum">     549 </span>            : int32_t
<span class="lineNum">     550 </span><span class="lineCov">          2 : AlphaBoxBlur::GetStride()</span>
<span class="lineNum">     551 </span>            : {
<span class="lineNum">     552 </span><span class="lineCov">          2 :   return mStride;</span>
<span class="lineNum">     553 </span>            : }
<a name="554"><span class="lineNum">     554 </span>            : </a>
<span class="lineNum">     555 </span>            : IntRect
<span class="lineNum">     556 </span><span class="lineCov">          2 : AlphaBoxBlur::GetRect()</span>
<span class="lineNum">     557 </span>            : {
<span class="lineNum">     558 </span><span class="lineCov">          2 :   return mRect;</span>
<span class="lineNum">     559 </span>            : }
<a name="560"><span class="lineNum">     560 </span>            : </a>
<span class="lineNum">     561 </span>            : Rect*
<span class="lineNum">     562 </span><span class="lineNoCov">          0 : AlphaBoxBlur::GetDirtyRect()</span>
<span class="lineNum">     563 </span>            : {
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   if (mHasDirtyRect) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     return &amp;mDirtyRect;</span>
<span class="lineNum">     566 </span>            :   }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     569 </span>            : }
<a name="570"><span class="lineNum">     570 </span>            : </a>
<span class="lineNum">     571 </span>            : size_t
<span class="lineNum">     572 </span><span class="lineCov">          1 : AlphaBoxBlur::GetSurfaceAllocationSize() const</span>
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span><span class="lineCov">          1 :   return mSurfaceAllocationSize;</span>
<span class="lineNum">     575 </span>            : }
<a name="576"><span class="lineNum">     576 </span>            : </a>
<span class="lineNum">     577 </span>            : void
<span class="lineNum">     578 </span><span class="lineCov">          1 : AlphaBoxBlur::Blur(uint8_t* aData)</span>
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span><span class="lineCov">          1 :   if (!aData) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     582 </span>            :   }
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :   // no need to do all this if not blurring or spreading
<span class="lineNum">     585 </span><span class="lineCov">          1 :   if (mBlurRadius != IntSize(0,0) || mSpreadRadius != IntSize(0,0)) {</span>
<span class="lineNum">     586 </span><span class="lineCov">          1 :     int32_t stride = GetStride();</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">          1 :     IntSize size = GetSize();</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineCov">          1 :     if (mSpreadRadius.width &gt; 0 || mSpreadRadius.height &gt; 0) {</span>
<span class="lineNum">     591 </span>            :       // No need to use CheckedInt here - we have validated it in the constructor.
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       size_t szB = stride * size.height;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :       uint8_t* tmpData = new (std::nothrow) uint8_t[szB];</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       if (!tmpData) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     597 </span>            :       }
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       memset(tmpData, 0, szB);</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       SpreadHorizontal(aData, tmpData, mSpreadRadius.width, size.width, size.height, stride, mSkipRect);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       SpreadVertical(tmpData, aData, mSpreadRadius.height, size.width, size.height, stride, mSkipRect);</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       delete [] tmpData;</span>
<span class="lineNum">     605 </span>            :     }
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :     int32_t horizontalLobes[3][2];
<span class="lineNum">     608 </span><span class="lineCov">          1 :     ComputeLobes(mBlurRadius.width, horizontalLobes);</span>
<span class="lineNum">     609 </span>            :     int32_t verticalLobes[3][2];
<span class="lineNum">     610 </span><span class="lineCov">          1 :     ComputeLobes(mBlurRadius.height, verticalLobes);</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :     // We want to allow for some extra space on the left for alignment reasons.
<span class="lineNum">     613 </span><span class="lineCov">          1 :     int32_t maxLeftLobe = RoundUpToMultipleOf4(horizontalLobes[0][0] + 1).value();</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">          1 :     IntSize integralImageSize(size.width + maxLeftLobe + horizontalLobes[1][1],</span>
<span class="lineNum">     616 </span><span class="lineCov">          2 :                               size.height + verticalLobes[0][0] + verticalLobes[1][1] + 1);</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">          1 :     if ((integralImageSize.width * integralImageSize.height) &gt; (1 &lt;&lt; 24)) {</span>
<span class="lineNum">     619 </span>            :       // Fallback to old blurring code when the surface is so large it may
<span class="lineNum">     620 </span>            :       // overflow our integral image!
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :       if (mBlurRadius.width &gt; 0) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         BoxBlur&lt;false&gt;(aData, horizontalLobes, size.width, size.height, stride, mSkipRect);</span>
<span class="lineNum">     623 </span>            :       }
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       if (mBlurRadius.height &gt; 0) {</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         BoxBlur&lt;true&gt;(aData, verticalLobes, size.width, size.height, stride, mSkipRect);</span>
<span class="lineNum">     626 </span>            :       }
<span class="lineNum">     627 </span>            :     } else {
<span class="lineNum">     628 </span><span class="lineCov">          1 :       size_t integralImageStride = GetAlignedStride&lt;16&gt;(integralImageSize.width, 4);</span>
<span class="lineNum">     629 </span><span class="lineCov">          1 :       if (integralImageStride == 0) {</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     631 </span>            :       }
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :       // We need to leave room for an additional 12 bytes for a maximum overrun
<span class="lineNum">     634 </span>            :       // of 3 pixels in the blurring code.
<span class="lineNum">     635 </span><span class="lineCov">          1 :       size_t bufLen = BufferSizeFromStrideAndHeight(integralImageStride, integralImageSize.height, 12);</span>
<span class="lineNum">     636 </span><span class="lineCov">          1 :       if (bufLen == 0) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     638 </span>            :       }
<span class="lineNum">     639 </span>            :       // bufLen is a byte count, but here we want a multiple of 32-bit ints, so
<span class="lineNum">     640 </span>            :       // we divide by 4.
<span class="lineNum">     641 </span><span class="lineCov">          2 :       AlignedArray&lt;uint32_t&gt; integralImage((bufLen / 4) + ((bufLen % 4) ? 1 : 0));</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">          1 :       if (!integralImage) {</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     645 </span>            :       }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : #ifdef USE_SSE2
<span class="lineNum">     648 </span><span class="lineCov">          1 :       if (Factory::HasSSE2()) {</span>
<span class="lineNum">     649 </span><span class="lineCov">          1 :         BoxBlur_SSE2(aData, horizontalLobes[0][0], horizontalLobes[0][1], verticalLobes[0][0],</span>
<span class="lineNum">     650 </span><span class="lineCov">          1 :                      verticalLobes[0][1], integralImage, integralImageStride);</span>
<span class="lineNum">     651 </span><span class="lineCov">          1 :         BoxBlur_SSE2(aData, horizontalLobes[1][0], horizontalLobes[1][1], verticalLobes[1][0],</span>
<span class="lineNum">     652 </span><span class="lineCov">          1 :                      verticalLobes[1][1], integralImage, integralImageStride);</span>
<span class="lineNum">     653 </span><span class="lineCov">          1 :         BoxBlur_SSE2(aData, horizontalLobes[2][0], horizontalLobes[2][1], verticalLobes[2][0],</span>
<span class="lineNum">     654 </span><span class="lineCov">          1 :                      verticalLobes[2][1], integralImage, integralImageStride);</span>
<span class="lineNum">     655 </span>            :       } else
<span class="lineNum">     656 </span>            : #endif
<span class="lineNum">     657 </span>            : #ifdef BUILD_ARM_NEON
<span class="lineNum">     658 </span>            :       if (mozilla::supports_neon()) {
<span class="lineNum">     659 </span>            :         BoxBlur_NEON(aData, horizontalLobes[0][0], horizontalLobes[0][1], verticalLobes[0][0],
<span class="lineNum">     660 </span>            :                      verticalLobes[0][1], integralImage, integralImageStride);
<span class="lineNum">     661 </span>            :         BoxBlur_NEON(aData, horizontalLobes[1][0], horizontalLobes[1][1], verticalLobes[1][0],
<span class="lineNum">     662 </span>            :                      verticalLobes[1][1], integralImage, integralImageStride);
<span class="lineNum">     663 </span>            :         BoxBlur_NEON(aData, horizontalLobes[2][0], horizontalLobes[2][1], verticalLobes[2][0],
<span class="lineNum">     664 </span>            :                      verticalLobes[2][1], integralImage, integralImageStride);
<span class="lineNum">     665 </span>            :       } else
<span class="lineNum">     666 </span>            : #endif
<span class="lineNum">     667 </span>            :       {
<span class="lineNum">     668 </span>            : #ifdef _MIPS_ARCH_LOONGSON3A
<span class="lineNum">     669 </span>            :         BoxBlur_LS3(aData, horizontalLobes[0][0], horizontalLobes[0][1], verticalLobes[0][0],
<span class="lineNum">     670 </span>            :                      verticalLobes[0][1], integralImage, integralImageStride);
<span class="lineNum">     671 </span>            :         BoxBlur_LS3(aData, horizontalLobes[1][0], horizontalLobes[1][1], verticalLobes[1][0],
<span class="lineNum">     672 </span>            :                      verticalLobes[1][1], integralImage, integralImageStride);
<span class="lineNum">     673 </span>            :         BoxBlur_LS3(aData, horizontalLobes[2][0], horizontalLobes[2][1], verticalLobes[2][0],
<span class="lineNum">     674 </span>            :                      verticalLobes[2][1], integralImage, integralImageStride);
<span class="lineNum">     675 </span>            : #else
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         BoxBlur_C(aData, horizontalLobes[0][0], horizontalLobes[0][1], verticalLobes[0][0],</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                   verticalLobes[0][1], integralImage, integralImageStride);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         BoxBlur_C(aData, horizontalLobes[1][0], horizontalLobes[1][1], verticalLobes[1][0],</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :                   verticalLobes[1][1], integralImage, integralImageStride);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         BoxBlur_C(aData, horizontalLobes[2][0], horizontalLobes[2][1], verticalLobes[2][0],</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :                   verticalLobes[2][1], integralImage, integralImageStride);</span>
<span class="lineNum">     682 </span>            : #endif
<span class="lineNum">     683 </span>            :       }
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span>            :   }
<span class="lineNum">     686 </span>            : }
<a name="687"><span class="lineNum">     687 </span>            : </a>
<span class="lineNum">     688 </span>            : MOZ_ALWAYS_INLINE void
<span class="lineNum">     689 </span><span class="lineNoCov">          0 : GenerateIntegralRow(uint32_t  *aDest, const uint8_t *aSource, uint32_t *aPreviousRow,</span>
<span class="lineNum">     690 </span>            :                     const uint32_t &amp;aSourceWidth, const uint32_t &amp;aLeftInflation, const uint32_t &amp;aRightInflation)
<span class="lineNum">     691 </span>            : {
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   uint32_t currentRowSum = 0;</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   uint32_t pixel = aSource[0];</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   for (uint32_t x = 0; x &lt; aLeftInflation; x++) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     currentRowSum += pixel;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     *aDest++ = currentRowSum + *aPreviousRow++;</span>
<span class="lineNum">     697 </span>            :   }
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   for (uint32_t x = aLeftInflation; x &lt; (aSourceWidth + aLeftInflation); x += 4) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       uint32_t alphaValues = *(uint32_t*)(aSource + (x - aLeftInflation));</span>
<span class="lineNum">     700 </span>            : #if defined WORDS_BIGENDIAN || defined IS_BIG_ENDIAN || defined __BIG_ENDIAN__
<span class="lineNum">     701 </span>            :       currentRowSum += (alphaValues &gt;&gt; 24) &amp; 0xff;
<span class="lineNum">     702 </span>            :       *aDest++ = *aPreviousRow++ + currentRowSum;
<span class="lineNum">     703 </span>            :       currentRowSum += (alphaValues &gt;&gt; 16) &amp; 0xff;
<span class="lineNum">     704 </span>            :       *aDest++ = *aPreviousRow++ + currentRowSum;
<span class="lineNum">     705 </span>            :       currentRowSum += (alphaValues &gt;&gt; 8) &amp; 0xff;
<span class="lineNum">     706 </span>            :       *aDest++ = *aPreviousRow++ + currentRowSum;
<span class="lineNum">     707 </span>            :       currentRowSum += alphaValues &amp; 0xff;
<span class="lineNum">     708 </span>            :       *aDest++ = *aPreviousRow++ + currentRowSum;
<span class="lineNum">     709 </span>            : #else
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       currentRowSum += alphaValues &amp; 0xff;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       *aDest++ = *aPreviousRow++ + currentRowSum;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       alphaValues &gt;&gt;= 8;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       currentRowSum += alphaValues &amp; 0xff;</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       *aDest++ = *aPreviousRow++ + currentRowSum;</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       alphaValues &gt;&gt;= 8;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       currentRowSum += alphaValues &amp; 0xff;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       *aDest++ = *aPreviousRow++ + currentRowSum;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       alphaValues &gt;&gt;= 8;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       currentRowSum += alphaValues &amp; 0xff;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       *aDest++ = *aPreviousRow++ + currentRowSum;</span>
<span class="lineNum">     721 </span>            : #endif
<span class="lineNum">     722 </span>            :   }
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   pixel = aSource[aSourceWidth - 1];</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   for (uint32_t x = (aSourceWidth + aLeftInflation); x &lt; (aSourceWidth + aLeftInflation + aRightInflation); x++) {</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     currentRowSum += pixel;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     *aDest++ = currentRowSum + *aPreviousRow++;</span>
<span class="lineNum">     727 </span>            :   }
<span class="lineNum">     728 </span><span class="lineNoCov">          0 : }</span>
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : MOZ_ALWAYS_INLINE void
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : GenerateIntegralImage_C(int32_t aLeftInflation, int32_t aRightInflation,</span>
<span class="lineNum">     732 </span>            :                         int32_t aTopInflation, int32_t aBottomInflation,
<span class="lineNum">     733 </span>            :                         uint32_t *aIntegralImage, size_t aIntegralImageStride,
<span class="lineNum">     734 </span>            :                         uint8_t *aSource, int32_t aSourceStride, const IntSize &amp;aSize)
<span class="lineNum">     735 </span>            : {
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   uint32_t stride32bit = aIntegralImageStride / 4;</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   IntSize integralImageSize(aSize.width + aLeftInflation + aRightInflation,</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                             aSize.height + aTopInflation + aBottomInflation);</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   memset(aIntegralImage, 0, aIntegralImageStride);</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   GenerateIntegralRow(aIntegralImage, aSource, aIntegralImage,</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                       aSize.width, aLeftInflation, aRightInflation);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   for (int y = 1; y &lt; aTopInflation + 1; y++) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     GenerateIntegralRow(aIntegralImage + (y * stride32bit), aSource, aIntegralImage + (y - 1) * stride32bit,</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                         aSize.width, aLeftInflation, aRightInflation);</span>
<span class="lineNum">     748 </span>            :   }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   for (int y = aTopInflation + 1; y &lt; (aSize.height + aTopInflation); y++) {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     GenerateIntegralRow(aIntegralImage + (y * stride32bit), aSource + aSourceStride * (y - aTopInflation),</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                         aIntegralImage + (y - 1) * stride32bit, aSize.width, aLeftInflation, aRightInflation);</span>
<span class="lineNum">     753 </span>            :   }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :   if (aBottomInflation) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     for (int y = (aSize.height + aTopInflation); y &lt; integralImageSize.height; y++) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       GenerateIntegralRow(aIntegralImage + (y * stride32bit), aSource + ((aSize.height - 1) * aSourceStride),</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                           aIntegralImage + (y - 1) * stride32bit,</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                           aSize.width, aLeftInflation, aRightInflation);</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span>            :   }
<span class="lineNum">     762 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : /**
<span class="lineNum">     765 </span>            :  * Attempt to do an in-place box blur using an integral image.
<a name="766"><span class="lineNum">     766 </span>            :  */</a>
<span class="lineNum">     767 </span>            : void
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : AlphaBoxBlur::BoxBlur_C(uint8_t* aData,</span>
<span class="lineNum">     769 </span>            :                         int32_t aLeftLobe,
<span class="lineNum">     770 </span>            :                         int32_t aRightLobe,
<span class="lineNum">     771 </span>            :                         int32_t aTopLobe,
<span class="lineNum">     772 </span>            :                         int32_t aBottomLobe,
<span class="lineNum">     773 </span>            :                         uint32_t *aIntegralImage,
<span class="lineNum">     774 </span>            :                         size_t aIntegralImageStride)
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   IntSize size = GetSize();</span>
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(size.width &gt; 0);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :   // Our 'left' or 'top' lobe will include the current pixel. i.e. when
<span class="lineNum">     781 </span>            :   // looking at an integral image the value of a pixel at 'x,y' is calculated
<span class="lineNum">     782 </span>            :   // using the value of the integral image values above/below that.
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   aLeftLobe++;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   aTopLobe++;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   int32_t boxSize = (aLeftLobe + aRightLobe) * (aTopLobe + aBottomLobe);</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(boxSize &gt; 0);</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   if (boxSize == 1) {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     791 </span>            :   }
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   int32_t stride32bit = aIntegralImageStride / 4;</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   int32_t leftInflation = RoundUpToMultipleOf4(aLeftLobe).value();</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   GenerateIntegralImage_C(leftInflation, aRightLobe, aTopLobe, aBottomLobe,</span>
<span class="lineNum">     798 </span>            :                           aIntegralImage, aIntegralImageStride, aData,
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :                           mStride, size);</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   uint32_t reciprocal = uint32_t((uint64_t(1) &lt;&lt; 32) / boxSize);</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   uint32_t *innerIntegral = aIntegralImage + (aTopLobe * stride32bit) + leftInflation;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :   // Storing these locally makes this about 30% faster! Presumably the compiler
<span class="lineNum">     806 </span>            :   // can't be sure we're not altering the member variables in this loop.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   IntRect skipRect = mSkipRect;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   uint8_t *data = aData;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   int32_t stride = mStride;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   for (int32_t y = 0; y &lt; size.height; y++) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     bool inSkipRectY = y &gt; skipRect.y &amp;&amp; y &lt; skipRect.YMost();</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     uint32_t *topLeftBase = innerIntegral + ((y - aTopLobe) * stride32bit - aLeftLobe);</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     uint32_t *topRightBase = innerIntegral + ((y - aTopLobe) * stride32bit + aRightLobe);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     uint32_t *bottomRightBase = innerIntegral + ((y + aBottomLobe) * stride32bit + aRightLobe);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     uint32_t *bottomLeftBase = innerIntegral + ((y + aBottomLobe) * stride32bit - aLeftLobe);</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     for (int32_t x = 0; x &lt; size.width; x++) {</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       if (inSkipRectY &amp;&amp; x &gt; skipRect.x &amp;&amp; x &lt; skipRect.XMost()) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         x = skipRect.XMost() - 1;</span>
<span class="lineNum">     821 </span>            :         // Trigger early jump on coming loop iterations, this will be reset
<span class="lineNum">     822 </span>            :         // next line anyway.
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         inSkipRectY = false;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     825 </span>            :       }
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :       int32_t topLeft = topLeftBase[x];</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       int32_t topRight = topRightBase[x];</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       int32_t bottomRight = bottomRightBase[x];</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :       int32_t bottomLeft = bottomLeftBase[x];</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :       uint32_t value = bottomRight - topRight - bottomLeft;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       value += topLeft;</span>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :       data[stride * y + x] = (uint64_t(reciprocal) * value + (uint64_t(1) &lt;&lt; 31)) &gt;&gt; 32;</span>
<span class="lineNum">     835 </span>            :     }
<span class="lineNum">     836 </span>            :   }
<span class="lineNum">     837 </span>            : }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /**
<span class="lineNum">     840 </span>            :  * Compute the box blur size (which we're calling the blur radius) from
<span class="lineNum">     841 </span>            :  * the standard deviation.
<span class="lineNum">     842 </span>            :  *
<span class="lineNum">     843 </span>            :  * Much of this, the 3 * sqrt(2 * pi) / 4, is the known value for
<span class="lineNum">     844 </span>            :  * approximating a Gaussian using box blurs.  This yields quite a good
<span class="lineNum">     845 </span>            :  * approximation for a Gaussian.  Then we multiply this by 1.5 since our
<span class="lineNum">     846 </span>            :  * code wants the radius of the entire triple-box-blur kernel instead of
<span class="lineNum">     847 </span>            :  * the diameter of an individual box blur.  For more details, see:
<span class="lineNum">     848 </span>            :  *   http://www.w3.org/TR/SVG11/filters.html#feGaussianBlurElement
<span class="lineNum">     849 </span>            :  *   https://bugzilla.mozilla.org/show_bug.cgi?id=590039#c19
<span class="lineNum">     850 </span>            :  */
<span class="lineNum">     851 </span>            : static const Float GAUSSIAN_SCALE_FACTOR = Float((3 * sqrt(2 * M_PI) / 4) * 1.5);
<a name="852"><span class="lineNum">     852 </span>            : </a>
<span class="lineNum">     853 </span>            : IntSize
<span class="lineNum">     854 </span><span class="lineCov">        102 : AlphaBoxBlur::CalculateBlurRadius(const Point&amp; aStd)</span>
<span class="lineNum">     855 </span>            : {
<span class="lineNum">     856 </span><span class="lineCov">        102 :     IntSize size(static_cast&lt;int32_t&gt;(floor(aStd.x * GAUSSIAN_SCALE_FACTOR + 0.5f)),</span>
<span class="lineNum">     857 </span><span class="lineCov">        204 :                  static_cast&lt;int32_t&gt;(floor(aStd.y * GAUSSIAN_SCALE_FACTOR + 0.5f)));</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineCov">        102 :     return size;</span>
<span class="lineNum">     860 </span>            : }
<a name="861"><span class="lineNum">     861 </span>            : </a>
<span class="lineNum">     862 </span>            : Float
<span class="lineNum">     863 </span><span class="lineNoCov">          0 : AlphaBoxBlur::CalculateBlurSigma(int32_t aBlurRadius)</span>
<span class="lineNum">     864 </span>            : {
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   return aBlurRadius / GAUSSIAN_SCALE_FACTOR;</span>
<span class="lineNum">     866 </span>            : }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : } // namespace gfx
<span class="lineNum">     869 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

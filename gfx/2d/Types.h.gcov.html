<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/2d/Types.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/2d</a> - Types.h<span style="font-size: 80%;"> (source / <a href="Types.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">43</td>
            <td class="headerCovTableEntryMed">79.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryMed">86.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #ifndef MOZILLA_GFX_TYPES_H_
<span class="lineNum">       7 </span>            : #define MOZILLA_GFX_TYPES_H_
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/EndianUtils.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/MacroArgs.h&quot; // for MOZ_CONCAT
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : namespace mozilla {
<span class="lineNum">      16 </span>            : namespace gfx {
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : typedef float Float;
<span class="lineNum">      19 </span>            : typedef double Double;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : enum class SurfaceType : int8_t {
<span class="lineNum">      22 </span>            :   DATA, /* Data surface - bitmap in memory */
<span class="lineNum">      23 </span>            :   D2D1_BITMAP, /* Surface wrapping a ID2D1Bitmap */
<span class="lineNum">      24 </span>            :   D2D1_DRAWTARGET, /* Surface made from a D2D draw target */
<span class="lineNum">      25 </span>            :   CAIRO, /* Surface wrapping a cairo surface */
<span class="lineNum">      26 </span>            :   CAIRO_IMAGE, /* Data surface wrapping a cairo image surface */
<span class="lineNum">      27 </span>            :   COREGRAPHICS_IMAGE, /* Surface wrapping a CoreGraphics Image */
<span class="lineNum">      28 </span>            :   COREGRAPHICS_CGCONTEXT, /* Surface wrapping a CG context */
<span class="lineNum">      29 </span>            :   SKIA, /* Surface wrapping a Skia bitmap */
<span class="lineNum">      30 </span>            :   DUAL_DT, /* Snapshot of a dual drawtarget */
<span class="lineNum">      31 </span>            :   D2D1_1_IMAGE, /* A D2D 1.1 ID2D1Image SourceSurface */
<span class="lineNum">      32 </span>            :   RECORDING, /* Surface used for recording */
<span class="lineNum">      33 </span>            :   TILED, /* Surface from a tiled DrawTarget */
<span class="lineNum">      34 </span>            :   DATA_SHARED, /* Data surface using shared memory */
<span class="lineNum">      35 </span>            : };
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : enum class SurfaceFormat : int8_t {
<span class="lineNum">      38 </span>            :   // The following values are named to reflect layout of colors in memory, from
<span class="lineNum">      39 </span>            :   // lowest byte to highest byte. The 32-bit value layout depends on machine
<span class="lineNum">      40 </span>            :   // endianness.
<span class="lineNum">      41 </span>            :   //               in-memory            32-bit LE value   32-bit BE value
<span class="lineNum">      42 </span>            :   B8G8R8A8,     // [BB, GG, RR, AA]     0xAARRGGBB        0xBBGGRRAA
<span class="lineNum">      43 </span>            :   B8G8R8X8,     // [BB, GG, RR, 00]     0x00RRGGBB        0xBBGGRR00
<span class="lineNum">      44 </span>            :   R8G8B8A8,     // [RR, GG, BB, AA]     0xAABBGGRR        0xRRGGBBAA
<span class="lineNum">      45 </span>            :   R8G8B8X8,     // [RR, GG, BB, 00]     0x00BBGGRR        0xRRGGBB00
<span class="lineNum">      46 </span>            :   A8R8G8B8,     // [AA, RR, GG, BB]     0xBBGGRRAA        0xAARRGGBB
<span class="lineNum">      47 </span>            :   X8R8G8B8,     // [00, RR, GG, BB]     0xBBGGRR00        0x00RRGGBB
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   R8G8B8,
<span class="lineNum">      50 </span>            :   B8G8R8,
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :   // The _UINT16 suffix here indicates that the name reflects the layout when
<span class="lineNum">      53 </span>            :   // viewed as a uint16_t value. In memory these values are stored using native
<span class="lineNum">      54 </span>            :   // endianness.
<span class="lineNum">      55 </span>            :   R5G6B5_UINT16,                    // 0bRRRRRGGGGGGBBBBB
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :   // This one is a single-byte, so endianness isn't an issue.
<span class="lineNum">      58 </span>            :   A8,
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   R8G8,
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   // These ones are their own special cases.
<span class="lineNum">      63 </span>            :   YUV,
<span class="lineNum">      64 </span>            :   NV12,
<span class="lineNum">      65 </span>            :   YUV422,
<span class="lineNum">      66 </span>            :   HSV,
<span class="lineNum">      67 </span>            :   Lab,
<span class="lineNum">      68 </span>            :   Depth,
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :   // This represents the unknown format.
<span class="lineNum">      71 </span>            :   UNKNOWN,
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :   // The following values are endian-independent synonyms. The _UINT32 suffix
<span class="lineNum">      74 </span>            :   // indicates that the name reflects the layout when viewed as a uint32_t
<span class="lineNum">      75 </span>            :   // value.
<span class="lineNum">      76 </span>            : #if MOZ_LITTLE_ENDIAN
<span class="lineNum">      77 </span>            :   A8R8G8B8_UINT32 = B8G8R8A8,       // 0xAARRGGBB
<span class="lineNum">      78 </span>            :   X8R8G8B8_UINT32 = B8G8R8X8        // 0x00RRGGBB
<span class="lineNum">      79 </span>            : #elif MOZ_BIG_ENDIAN
<span class="lineNum">      80 </span>            :   A8R8G8B8_UINT32 = A8R8G8B8,       // 0xAARRGGBB
<span class="lineNum">      81 </span>            :   X8R8G8B8_UINT32 = X8R8G8B8        // 0x00RRGGBB
<span class="lineNum">      82 </span>            : #else
<span class="lineNum">      83 </span>            : # error &quot;bad endianness&quot;
<span class="lineNum">      84 </span>            : #endif
<a name="85"><span class="lineNum">      85 </span>            : };</a>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineCov">         63 : inline bool IsOpaque(SurfaceFormat aFormat)</span>
<span class="lineNum">      88 </span>            : {
<span class="lineNum">      89 </span><span class="lineCov">         63 :   switch (aFormat) {</span>
<span class="lineNum">      90 </span>            :   case SurfaceFormat::B8G8R8X8:
<span class="lineNum">      91 </span>            :   case SurfaceFormat::R8G8B8X8:
<span class="lineNum">      92 </span>            :   case SurfaceFormat::R5G6B5_UINT16:
<span class="lineNum">      93 </span>            :   case SurfaceFormat::YUV:
<span class="lineNum">      94 </span>            :   case SurfaceFormat::NV12:
<span class="lineNum">      95 </span>            :   case SurfaceFormat::YUV422:
<span class="lineNum">      96 </span><span class="lineCov">          5 :     return true;</span>
<span class="lineNum">      97 </span>            :   default:
<span class="lineNum">      98 </span><span class="lineCov">         58 :     return false;</span>
<span class="lineNum">      99 </span>            :   }
<span class="lineNum">     100 </span>            : }
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : enum class FilterType : int8_t {
<span class="lineNum">     103 </span>            :   BLEND = 0,
<span class="lineNum">     104 </span>            :   TRANSFORM,
<span class="lineNum">     105 </span>            :   MORPHOLOGY,
<span class="lineNum">     106 </span>            :   COLOR_MATRIX,
<span class="lineNum">     107 </span>            :   FLOOD,
<span class="lineNum">     108 </span>            :   TILE,
<span class="lineNum">     109 </span>            :   TABLE_TRANSFER,
<span class="lineNum">     110 </span>            :   DISCRETE_TRANSFER,
<span class="lineNum">     111 </span>            :   LINEAR_TRANSFER,
<span class="lineNum">     112 </span>            :   GAMMA_TRANSFER,
<span class="lineNum">     113 </span>            :   CONVOLVE_MATRIX,
<span class="lineNum">     114 </span>            :   DISPLACEMENT_MAP,
<span class="lineNum">     115 </span>            :   TURBULENCE,
<span class="lineNum">     116 </span>            :   ARITHMETIC_COMBINE,
<span class="lineNum">     117 </span>            :   COMPOSITE,
<span class="lineNum">     118 </span>            :   DIRECTIONAL_BLUR,
<span class="lineNum">     119 </span>            :   GAUSSIAN_BLUR,
<span class="lineNum">     120 </span>            :   POINT_DIFFUSE,
<span class="lineNum">     121 </span>            :   POINT_SPECULAR,
<span class="lineNum">     122 </span>            :   SPOT_DIFFUSE,
<span class="lineNum">     123 </span>            :   SPOT_SPECULAR,
<span class="lineNum">     124 </span>            :   DISTANT_DIFFUSE,
<span class="lineNum">     125 </span>            :   DISTANT_SPECULAR,
<span class="lineNum">     126 </span>            :   CROP,
<span class="lineNum">     127 </span>            :   PREMULTIPLY,
<span class="lineNum">     128 </span>            :   UNPREMULTIPLY
<span class="lineNum">     129 </span>            : };
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : enum class DrawTargetType : int8_t {
<span class="lineNum">     132 </span>            :   SOFTWARE_RASTER = 0,
<span class="lineNum">     133 </span>            :   HARDWARE_RASTER,
<span class="lineNum">     134 </span>            :   VECTOR
<span class="lineNum">     135 </span>            : };
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : enum class BackendType : int8_t {
<span class="lineNum">     138 </span>            :   NONE = 0,
<span class="lineNum">     139 </span>            :   DIRECT2D, // Used for version independent D2D objects.
<span class="lineNum">     140 </span>            :   CAIRO,
<span class="lineNum">     141 </span>            :   SKIA,
<span class="lineNum">     142 </span>            :   RECORDING,
<span class="lineNum">     143 </span>            :   DIRECT2D1_1,
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   // Add new entries above this line.
<span class="lineNum">     146 </span>            :   BACKEND_LAST
<span class="lineNum">     147 </span>            : };
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : enum class FontType : int8_t {
<span class="lineNum">     150 </span>            :   DWRITE,
<span class="lineNum">     151 </span>            :   GDI,
<span class="lineNum">     152 </span>            :   MAC,
<span class="lineNum">     153 </span>            :   SKIA,
<span class="lineNum">     154 </span>            :   CAIRO,
<span class="lineNum">     155 </span>            :   COREGRAPHICS,
<span class="lineNum">     156 </span>            :   FONTCONFIG,
<span class="lineNum">     157 </span>            :   FREETYPE
<span class="lineNum">     158 </span>            : };
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : enum class NativeSurfaceType : int8_t {
<span class="lineNum">     161 </span>            :   D3D10_TEXTURE,
<span class="lineNum">     162 </span>            :   CAIRO_CONTEXT,
<span class="lineNum">     163 </span>            :   CGCONTEXT,
<span class="lineNum">     164 </span>            :   CGCONTEXT_ACCELERATED,
<span class="lineNum">     165 </span>            :   OPENGL_TEXTURE
<span class="lineNum">     166 </span>            : };
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : enum class NativeFontType : int8_t {
<span class="lineNum">     169 </span>            :   DWRITE_FONT_FACE,
<span class="lineNum">     170 </span>            :   GDI_FONT_FACE,
<span class="lineNum">     171 </span>            :   MAC_FONT_FACE,
<span class="lineNum">     172 </span>            :   SKIA_FONT_FACE,
<span class="lineNum">     173 </span>            :   CAIRO_FONT_FACE
<span class="lineNum">     174 </span>            : };
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : enum class FontStyle : int8_t {
<span class="lineNum">     177 </span>            :   NORMAL,
<span class="lineNum">     178 </span>            :   ITALIC,
<span class="lineNum">     179 </span>            :   BOLD,
<span class="lineNum">     180 </span>            :   BOLD_ITALIC
<span class="lineNum">     181 </span>            : };
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : enum class FontHinting : int8_t {
<span class="lineNum">     184 </span>            :   NONE,
<span class="lineNum">     185 </span>            :   LIGHT,
<span class="lineNum">     186 </span>            :   NORMAL,
<span class="lineNum">     187 </span>            :   FULL
<span class="lineNum">     188 </span>            : };
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : enum class CompositionOp : int8_t {
<span class="lineNum">     191 </span>            :   OP_OVER,
<span class="lineNum">     192 </span>            :   OP_ADD,
<span class="lineNum">     193 </span>            :   OP_ATOP,
<span class="lineNum">     194 </span>            :   OP_OUT,
<span class="lineNum">     195 </span>            :   OP_IN,
<span class="lineNum">     196 </span>            :   OP_SOURCE,
<span class="lineNum">     197 </span>            :   OP_DEST_IN,
<span class="lineNum">     198 </span>            :   OP_DEST_OUT,
<span class="lineNum">     199 </span>            :   OP_DEST_OVER,
<span class="lineNum">     200 </span>            :   OP_DEST_ATOP,
<span class="lineNum">     201 </span>            :   OP_XOR,
<span class="lineNum">     202 </span>            :   OP_MULTIPLY,
<span class="lineNum">     203 </span>            :   OP_SCREEN,
<span class="lineNum">     204 </span>            :   OP_OVERLAY,
<span class="lineNum">     205 </span>            :   OP_DARKEN,
<span class="lineNum">     206 </span>            :   OP_LIGHTEN,
<span class="lineNum">     207 </span>            :   OP_COLOR_DODGE,
<span class="lineNum">     208 </span>            :   OP_COLOR_BURN,
<span class="lineNum">     209 </span>            :   OP_HARD_LIGHT,
<span class="lineNum">     210 </span>            :   OP_SOFT_LIGHT,
<span class="lineNum">     211 </span>            :   OP_DIFFERENCE,
<span class="lineNum">     212 </span>            :   OP_EXCLUSION,
<span class="lineNum">     213 </span>            :   OP_HUE,
<span class="lineNum">     214 </span>            :   OP_SATURATION,
<span class="lineNum">     215 </span>            :   OP_COLOR,
<span class="lineNum">     216 </span>            :   OP_LUMINOSITY,
<span class="lineNum">     217 </span>            :   OP_COUNT
<span class="lineNum">     218 </span>            : };
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : enum class Axis : int8_t {
<span class="lineNum">     221 </span>            :   X_AXIS,
<span class="lineNum">     222 </span>            :   Y_AXIS,
<span class="lineNum">     223 </span>            :   BOTH
<span class="lineNum">     224 </span>            : };
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : enum class ExtendMode : int8_t {
<span class="lineNum">     227 </span>            :   CLAMP,    // Do not repeat
<span class="lineNum">     228 </span>            :   REPEAT,   // Repeat in both axis
<span class="lineNum">     229 </span>            :   REPEAT_X, // Only X axis
<span class="lineNum">     230 </span>            :   REPEAT_Y, // Only Y axis
<span class="lineNum">     231 </span>            :   REFLECT   // Mirror the image
<span class="lineNum">     232 </span>            : };
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : enum class FillRule : int8_t {
<span class="lineNum">     235 </span>            :   FILL_WINDING,
<span class="lineNum">     236 </span>            :   FILL_EVEN_ODD
<span class="lineNum">     237 </span>            : };
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : enum class AntialiasMode : int8_t {
<span class="lineNum">     240 </span>            :   NONE,
<span class="lineNum">     241 </span>            :   GRAY,
<span class="lineNum">     242 </span>            :   SUBPIXEL,
<span class="lineNum">     243 </span>            :   DEFAULT
<span class="lineNum">     244 </span>            : };
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : // See https://en.wikipedia.org/wiki/Texture_filtering
<span class="lineNum">     247 </span>            : enum class SamplingFilter : int8_t {
<span class="lineNum">     248 </span>            :   GOOD,
<span class="lineNum">     249 </span>            :   LINEAR,
<span class="lineNum">     250 </span>            :   POINT,
<span class="lineNum">     251 </span>            :   SENTINEL  // one past the last valid value
<span class="lineNum">     252 </span>            : };
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : enum class PatternType : int8_t {
<span class="lineNum">     255 </span>            :   COLOR,
<span class="lineNum">     256 </span>            :   SURFACE,
<span class="lineNum">     257 </span>            :   LINEAR_GRADIENT,
<span class="lineNum">     258 </span>            :   RADIAL_GRADIENT
<span class="lineNum">     259 </span>            : };
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : enum class JoinStyle : int8_t {
<span class="lineNum">     262 </span>            :   BEVEL,
<span class="lineNum">     263 </span>            :   ROUND,
<span class="lineNum">     264 </span>            :   MITER, //!&lt; Mitered if within the miter limit, else, if the backed supports
<span class="lineNum">     265 </span>            :          //!&lt; it (D2D), the miter is clamped. If the backend does not support
<span class="lineNum">     266 </span>            :          //!&lt; miter clamping the behavior is as for MITER_OR_BEVEL.
<span class="lineNum">     267 </span>            :   MITER_OR_BEVEL //!&lt; Mitered if within the miter limit, else beveled.
<span class="lineNum">     268 </span>            : };
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : enum class CapStyle : int8_t {
<span class="lineNum">     271 </span>            :   BUTT,
<span class="lineNum">     272 </span>            :   ROUND,
<span class="lineNum">     273 </span>            :   SQUARE
<span class="lineNum">     274 </span>            : };
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : enum class SamplingBounds : int8_t {
<span class="lineNum">     277 </span>            :   UNBOUNDED,
<span class="lineNum">     278 </span>            :   BOUNDED
<span class="lineNum">     279 </span>            : };
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : // Moz2d version for SVG mask types
<span class="lineNum">     282 </span>            : enum class LuminanceType : int8_t {
<span class="lineNum">     283 </span>            :   LUMINANCE,
<span class="lineNum">     284 </span>            :   LINEARRGB,
<span class="lineNum">     285 </span>            : };
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : /* Color is stored in non-premultiplied form */
<span class="lineNum">     288 </span>            : struct Color
<a name="289"><span class="lineNum">     289 </span>            : {</a>
<span class="lineNum">     290 </span>            : public:
<span class="lineNum">     291 </span><span class="lineCov">       1445 :   Color()</span>
<a name="292"><span class="lineNum">     292 </span><span class="lineCov">       1445 :     : r(0.0f), g(0.0f), b(0.0f), a(0.0f)</span></a>
<span class="lineNum">     293 </span><span class="lineCov">       1445 :   {}</span>
<span class="lineNum">     294 </span><span class="lineCov">        855 :   Color(Float aR, Float aG, Float aB, Float aA)</span>
<a name="295"><span class="lineNum">     295 </span><span class="lineCov">        855 :     : r(aR), g(aG), b(aB), a(aA)</span></a>
<span class="lineNum">     296 </span><span class="lineCov">        855 :   {}</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   Color(Float aR, Float aG, Float aB)</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     : r(aR), g(aG), b(aB), a(1.0f)</span>
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 :   {}</span></a>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">        589 :   static Color FromABGR(uint32_t aColor)</span>
<span class="lineNum">     302 </span>            :   {
<span class="lineNum">     303 </span><span class="lineCov">        589 :     Color newColor(((aColor &gt;&gt; 0) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     304 </span><span class="lineCov">        589 :                    ((aColor &gt;&gt; 8) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     305 </span><span class="lineCov">        589 :                    ((aColor &gt;&gt; 16) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     306 </span><span class="lineCov">       2356 :                    ((aColor &gt;&gt; 24) &amp; 0xff) * (1.0f / 255.0f));</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">        589 :     return newColor;</span>
<span class="lineNum">     309 </span>            :   }
<span class="lineNum">     310 </span>            : 
<a name="311"><span class="lineNum">     311 </span>            :   // The &quot;Unusual&quot; prefix is to avoid unintentionally using this function when</a>
<span class="lineNum">     312 </span>            :   // FromABGR(), which is much more common, is needed.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   static Color UnusualFromARGB(uint32_t aColor)</span>
<span class="lineNum">     314 </span>            :   {
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     Color newColor(((aColor &gt;&gt; 16) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                    ((aColor &gt;&gt; 8) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                    ((aColor &gt;&gt; 0) &amp; 0xff) * (1.0f / 255.0f),</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                    ((aColor &gt;&gt; 24) &amp; 0xff) * (1.0f / 255.0f));</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     return newColor;</span>
<a name="321"><span class="lineNum">     321 </span>            :   }</a>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineCov">        510 :   uint32_t ToABGR() const</span>
<span class="lineNum">     324 </span>            :   {
<span class="lineNum">     325 </span><span class="lineCov">       1020 :     return uint32_t(r * 255.0f) | uint32_t(g * 255.0f) &lt;&lt; 8 |</span>
<span class="lineNum">     326 </span><span class="lineCov">       1020 :            uint32_t(b * 255.0f) &lt;&lt; 16 | uint32_t(a * 255.0f) &lt;&lt; 24;</span>
<span class="lineNum">     327 </span>            :   }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // The &quot;Unusual&quot; prefix is to avoid unintentionally using this function when
<span class="lineNum">     330 </span>            :   // ToABGR(), which is much more common, is needed.
<span class="lineNum">     331 </span>            :   uint32_t UnusualToARGB() const
<span class="lineNum">     332 </span>            :   {
<span class="lineNum">     333 </span>            :     return uint32_t(b * 255.0f) | uint32_t(g * 255.0f) &lt;&lt; 8 |
<span class="lineNum">     334 </span>            :            uint32_t(r * 255.0f) &lt;&lt; 16 | uint32_t(a * 255.0f) &lt;&lt; 24;
<a name="335"><span class="lineNum">     335 </span>            :   }</a>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">        271 :   bool operator==(const Color&amp; aColor) const {</span>
<span class="lineNum">     338 </span><span class="lineCov">        271 :     return r == aColor.r &amp;&amp; g == aColor.g &amp;&amp; b == aColor.b &amp;&amp; a == aColor.a;</span>
<a name="339"><span class="lineNum">     339 </span>            :   }</a>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineCov">         92 :   bool operator!=(const Color&amp; aColor) const {</span>
<span class="lineNum">     342 </span><span class="lineCov">         92 :     return !(*this == aColor);</span>
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   Float r, g, b, a;
<a name="346"><span class="lineNum">     346 </span>            : };</a>
<span class="lineNum">     347 </span>            : 
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">         97 : struct GradientStop</span></a>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineCov">         20 :   bool operator&lt;(const GradientStop&amp; aOther) const {</span>
<span class="lineNum">     351 </span><span class="lineCov">         20 :     return offset &lt; aOther.offset;</span>
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   Float offset;
<span class="lineNum">     355 </span>            :   Color color;
<span class="lineNum">     356 </span>            : };
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : enum class JobStatus {
<span class="lineNum">     359 </span>            :     Complete,
<span class="lineNum">     360 </span>            :     Wait,
<span class="lineNum">     361 </span>            :     Yield,
<span class="lineNum">     362 </span>            :     Error
<span class="lineNum">     363 </span>            : };
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : } // namespace gfx
<span class="lineNum">     366 </span>            : } // namespace mozilla
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : // XXX: temporary
<span class="lineNum">     369 </span>            : typedef mozilla::gfx::SurfaceFormat gfxImageFormat;
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : #if defined(XP_WIN) &amp;&amp; defined(MOZ_GFX)
<span class="lineNum">     372 </span>            : #ifdef GFX2D_INTERNAL
<span class="lineNum">     373 </span>            : #define GFX2D_API __declspec(dllexport)
<span class="lineNum">     374 </span>            : #else
<span class="lineNum">     375 </span>            : #define GFX2D_API __declspec(dllimport)
<span class="lineNum">     376 </span>            : #endif
<span class="lineNum">     377 </span>            : #else
<span class="lineNum">     378 </span>            : #define GFX2D_API
<span class="lineNum">     379 </span>            : #endif
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : namespace mozilla {
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : // Side constants for use in various places.
<span class="lineNum">     384 </span>            : enum Side { eSideTop, eSideRight, eSideBottom, eSideLeft };
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : enum SideBits {
<span class="lineNum">     387 </span>            :   eSideBitsNone   = 0,
<span class="lineNum">     388 </span>            :   eSideBitsTop    = 1 &lt;&lt; eSideTop,
<span class="lineNum">     389 </span>            :   eSideBitsRight  = 1 &lt;&lt; eSideRight,
<span class="lineNum">     390 </span>            :   eSideBitsBottom = 1 &lt;&lt; eSideBottom,
<span class="lineNum">     391 </span>            :   eSideBitsLeft   = 1 &lt;&lt; eSideLeft,
<span class="lineNum">     392 </span>            :   eSideBitsTopBottom = eSideBitsTop  | eSideBitsBottom,
<span class="lineNum">     393 </span>            :   eSideBitsLeftRight = eSideBitsLeft | eSideBitsRight,
<span class="lineNum">     394 </span>            :   eSideBitsAll = eSideBitsTopBottom | eSideBitsLeftRight
<span class="lineNum">     395 </span>            : };
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : // Creates a for loop that walks over the four mozilla::Side values.
<span class="lineNum">     398 </span>            : // We use an int32_t helper variable (instead of a Side) for our loop counter,
<span class="lineNum">     399 </span>            : // to avoid triggering undefined behavior just before we exit the loop (at
<span class="lineNum">     400 </span>            : // which point the counter is incremented beyond the largest valid Side value).
<span class="lineNum">     401 </span>            : #define NS_FOR_CSS_SIDES(var_)                                           \
<span class="lineNum">     402 </span>            :   int32_t MOZ_CONCAT(var_,__LINE__) = mozilla::eSideTop;                 \
<span class="lineNum">     403 </span>            :   for (mozilla::Side var_;                                               \
<span class="lineNum">     404 </span>            :        MOZ_CONCAT(var_,__LINE__) &lt;= mozilla::eSideLeft &amp;&amp;                \
<span class="lineNum">     405 </span>            :          ((var_ = mozilla::Side(MOZ_CONCAT(var_,__LINE__))), true);      \
<span class="lineNum">     406 </span>            :        ++MOZ_CONCAT(var_,__LINE__))
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : static inline Side&amp; operator++(Side&amp; side) {
<span class="lineNum">     409 </span>            :   MOZ_ASSERT(side &gt;= eSideTop &amp;&amp; side &lt;= eSideLeft,
<span class="lineNum">     410 </span>            :              &quot;Out of range side&quot;);
<span class="lineNum">     411 </span>            :   side = Side(side + 1);
<span class="lineNum">     412 </span>            :   return side;
<span class="lineNum">     413 </span>            : }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : enum Corner {
<span class="lineNum">     416 </span>            :   // This order is important!
<span class="lineNum">     417 </span>            :   eCornerTopLeft = 0,
<span class="lineNum">     418 </span>            :   eCornerTopRight = 1,
<span class="lineNum">     419 </span>            :   eCornerBottomRight = 2,
<span class="lineNum">     420 </span>            :   eCornerBottomLeft = 3
<span class="lineNum">     421 </span>            : };
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : // RectCornerRadii::radii depends on this value. It is not being added to
<span class="lineNum">     424 </span>            : // Corner because we want to lift the responsibility to handle it in the
<span class="lineNum">     425 </span>            : // switch-case.
<span class="lineNum">     426 </span>            : constexpr int eCornerCount = 4;
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : // Creates a for loop that walks over the four mozilla::Corner values. This
<span class="lineNum">     429 </span>            : // implementation uses the same technique as NS_FOR_CSS_SIDES.
<span class="lineNum">     430 </span>            : #define NS_FOR_CSS_FULL_CORNERS(var_)                                   \
<span class="lineNum">     431 </span>            :   int32_t MOZ_CONCAT(var_,__LINE__) = mozilla::eCornerTopLeft;          \
<span class="lineNum">     432 </span>            :   for (mozilla::Corner var_;                                            \
<span class="lineNum">     433 </span>            :        MOZ_CONCAT(var_,__LINE__) &lt;= mozilla::eCornerBottomLeft &amp;&amp;       \
<span class="lineNum">     434 </span>            :          (var_ = mozilla::Corner(MOZ_CONCAT(var_,__LINE__)), true);     \
<span class="lineNum">     435 </span>            :        ++MOZ_CONCAT(var_,__LINE__))
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : static inline Corner operator++(Corner&amp; aCorner) {
<span class="lineNum">     438 </span>            :   MOZ_ASSERT(aCorner &gt;= eCornerTopLeft &amp;&amp; aCorner &lt;= eCornerBottomLeft,
<span class="lineNum">     439 </span>            :              &quot;Out of range corner!&quot;);
<span class="lineNum">     440 </span>            :   aCorner = Corner(aCorner + 1);
<span class="lineNum">     441 </span>            :   return aCorner;
<span class="lineNum">     442 </span>            : }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : // Indices into &quot;half corner&quot; arrays (nsStyleCorners e.g.)
<span class="lineNum">     445 </span>            : enum HalfCorner {
<span class="lineNum">     446 </span>            :   // This order is important!
<span class="lineNum">     447 </span>            :   eCornerTopLeftX = 0,
<span class="lineNum">     448 </span>            :   eCornerTopLeftY = 1,
<span class="lineNum">     449 </span>            :   eCornerTopRightX = 2,
<span class="lineNum">     450 </span>            :   eCornerTopRightY = 3,
<span class="lineNum">     451 </span>            :   eCornerBottomRightX = 4,
<span class="lineNum">     452 </span>            :   eCornerBottomRightY = 5,
<span class="lineNum">     453 </span>            :   eCornerBottomLeftX = 6,
<span class="lineNum">     454 </span>            :   eCornerBottomLeftY = 7
<span class="lineNum">     455 </span>            : };
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : // Creates a for loop that walks over the eight mozilla::HalfCorner values.
<span class="lineNum">     458 </span>            : // This implementation uses the same technique as NS_FOR_CSS_SIDES.
<span class="lineNum">     459 </span>            : #define NS_FOR_CSS_HALF_CORNERS(var_)                                   \
<span class="lineNum">     460 </span>            :   int32_t MOZ_CONCAT(var_,__LINE__) = mozilla::eCornerTopLeftX;         \
<span class="lineNum">     461 </span>            :   for (mozilla::HalfCorner var_;                                        \
<span class="lineNum">     462 </span>            :        MOZ_CONCAT(var_,__LINE__) &lt;= mozilla::eCornerBottomLeftY &amp;&amp;      \
<span class="lineNum">     463 </span>            :          (var_ = mozilla::HalfCorner(MOZ_CONCAT(var_,__LINE__)), true); \
<span class="lineNum">     464 </span>            :        ++MOZ_CONCAT(var_,__LINE__))
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : static inline HalfCorner operator++(HalfCorner&amp; aHalfCorner) {
<span class="lineNum">     467 </span>            :   MOZ_ASSERT(aHalfCorner &gt;= eCornerTopLeftX &amp;&amp; aHalfCorner &lt;= eCornerBottomLeftY,
<span class="lineNum">     468 </span>            :              &quot;Out of range half corner!&quot;);
<span class="lineNum">     469 </span>            :   aHalfCorner = HalfCorner(aHalfCorner + 1);
<span class="lineNum">     470 </span>            :   return aHalfCorner;
<span class="lineNum">     471 </span>            : }
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : // The result of these conversion functions are exhaustively checked in
<a name="474"><span class="lineNum">     474 </span>            : // nsStyleCoord.cpp, which also serves as usage examples.</a>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">       3776 : constexpr bool HalfCornerIsX(HalfCorner aHalfCorner)</span>
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineCov">       3776 :   return !(aHalfCorner % 2);</span>
<span class="lineNum">     479 </span>            : }
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : constexpr Corner HalfToFullCorner(HalfCorner aHalfCorner)
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span>            :   return Corner(aHalfCorner / 2);
<a name="484"><span class="lineNum">     484 </span>            : }</a>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">       1496 : constexpr HalfCorner FullToHalfCorner(Corner aCorner, bool aIsVertical)</span>
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span><span class="lineCov">       1496 :   return HalfCorner(aCorner * 2 + aIsVertical);</span>
<a name="489"><span class="lineNum">     489 </span>            : }</a>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">       1912 : constexpr bool SideIsVertical(Side aSide)</span>
<span class="lineNum">     492 </span>            : {
<span class="lineNum">     493 </span><span class="lineCov">       1912 :   return aSide % 2;</span>
<span class="lineNum">     494 </span>            : }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : // @param aIsSecond when true, return the clockwise second of the two
<span class="lineNum">     497 </span>            : // corners associated with aSide. For example, with aSide = eSideBottom the
<span class="lineNum">     498 </span>            : // result is eCornerBottomRight when aIsSecond is false, and
<span class="lineNum">     499 </span>            : // eCornerBottomLeft when aIsSecond is true.
<span class="lineNum">     500 </span>            : constexpr Corner SideToFullCorner(Side aSide, bool aIsSecond)
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span>            :   return Corner((aSide + aIsSecond) % 4);
<span class="lineNum">     503 </span>            : }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : // @param aIsSecond see SideToFullCorner.
<span class="lineNum">     506 </span>            : // @param aIsParallel return the half-corner that is parallel with aSide
<span class="lineNum">     507 </span>            : // when aIsParallel is true. For example with aSide=eSideTop, aIsSecond=true
<span class="lineNum">     508 </span>            : // the result is eCornerTopRightX when aIsParallel is true, and
<span class="lineNum">     509 </span>            : // eCornerTopRightY when aIsParallel is false (because &quot;X&quot; is parallel with
<a name="510"><span class="lineNum">     510 </span>            : // eSideTop/eSideBottom, similarly &quot;Y&quot; is parallel with</a>
<span class="lineNum">     511 </span>            : // eSideLeft/eSideRight)
<span class="lineNum">     512 </span><span class="lineCov">       5888 : constexpr HalfCorner SideToHalfCorner(Side aSide, bool aIsSecond,</span>
<span class="lineNum">     513 </span>            :                                       bool aIsParallel)
<span class="lineNum">     514 </span>            : {
<span class="lineNum">     515 </span><span class="lineCov">       5888 :   return HalfCorner(((aSide + aIsSecond) * 2 + (aSide + !aIsParallel) % 2) % 8);</span>
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : } // namespace mozilla
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : #endif /* MOZILLA_GFX_TYPES_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

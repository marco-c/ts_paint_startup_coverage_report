<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/2d/PathHelpers.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gfx/2d</a> - PathHelpers.h<span style="font-size: 80%;"> (source / <a href="PathHelpers.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntry">133</td>
            <td class="headerCovTableEntryLo">49.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntryLo">43.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #ifndef MOZILLA_GFX_PATHHELPERS_H_
<span class="lineNum">       7 </span>            : #define MOZILLA_GFX_PATHHELPERS_H_
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;2D.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;UserData.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : namespace mozilla {
<span class="lineNum">      15 </span>            : namespace gfx {
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : // Kappa constant for 90-degree angle
<span class="lineNum">      18 </span>            : const Float kKappaFactor = 0.55191497064665766025f;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : // Calculate kappa constant for partial curve. The sign of angle in the
<a name="21"><span class="lineNum">      21 </span>            : // tangent will actually ensure this is negative for a counter clockwise</a>
<span class="lineNum">      22 </span>            : // sweep, so changing signs later isn't needed.
<span class="lineNum">      23 </span><span class="lineNoCov">          0 : inline Float ComputeKappaFactor(Float aAngle)</span>
<span class="lineNum">      24 </span>            : {
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :   return (4.0f / 3.0f) * tanf(aAngle / 4.0f);</span>
<span class="lineNum">      26 </span>            : }
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /**
<span class="lineNum">      29 </span>            :  * Draws a partial arc &lt;= 90 degrees given exact start and end points.
<span class="lineNum">      30 </span>            :  * Assumes that it is continuing from an already specified start point.
<a name="31"><span class="lineNum">      31 </span>            :  */</a>
<span class="lineNum">      32 </span>            : template &lt;typename T&gt;
<span class="lineNum">      33 </span><span class="lineNoCov">          0 : inline void PartialArcToBezier(T* aSink,</span>
<span class="lineNum">      34 </span>            :                                const Point&amp; aStartOffset, const Point&amp; aEndOffset,
<span class="lineNum">      35 </span>            :                                const Matrix&amp; aTransform,
<span class="lineNum">      36 </span>            :                                Float aKappaFactor = kKappaFactor)
<span class="lineNum">      37 </span>            : {
<span class="lineNum">      38 </span>            :   Point cp1 =
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     aStartOffset + Point(-aStartOffset.y, aStartOffset.x) * aKappaFactor;</span>
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :   Point cp2 =
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :     aEndOffset + Point(aEndOffset.y, -aEndOffset.x) * aKappaFactor;</span>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   aSink-&gt;BezierTo(aTransform.TransformPoint(cp1),</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :                   aTransform.TransformPoint(cp2),</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :                   aTransform.TransformPoint(aEndOffset));</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /**
<span class="lineNum">      50 </span>            :  * Draws an acute arc (&lt;= 90 degrees) given exact start and end points.
<span class="lineNum">      51 </span>            :  * Specialized version avoiding kappa calculation.
<a name="52"><span class="lineNum">      52 </span>            :  */</a>
<span class="lineNum">      53 </span>            : template &lt;typename T&gt;
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : inline void AcuteArcToBezier(T* aSink,</span>
<span class="lineNum">      55 </span>            :                              const Point&amp; aOrigin, const Size&amp; aRadius,
<span class="lineNum">      56 </span>            :                              const Point&amp; aStartPoint, const Point&amp; aEndPoint,
<span class="lineNum">      57 </span>            :                              Float aKappaFactor = kKappaFactor)
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   aSink-&gt;LineTo(aStartPoint);</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   if (!aRadius.IsEmpty()) {</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     Float kappaX = aKappaFactor * aRadius.width / aRadius.height;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :     Float kappaY = aKappaFactor * aRadius.height / aRadius.width;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     Point startOffset = aStartPoint - aOrigin;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     Point endOffset = aEndPoint - aOrigin;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     aSink-&gt;BezierTo(aStartPoint + Point(-startOffset.y * kappaX, startOffset.x * kappaY),</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :                     aEndPoint + Point(endOffset.y * kappaX, -endOffset.x * kappaY),</span>
<span class="lineNum">      67 </span>            :                     aEndPoint);
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   } else if (aEndPoint != aStartPoint) {</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     aSink-&gt;LineTo(aEndPoint);</span>
<span class="lineNum">      70 </span>            :   }
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /**
<span class="lineNum">      74 </span>            :  * Draws an acute arc (&lt;= 90 degrees) given exact start and end points.
<a name="75"><span class="lineNum">      75 </span>            :  */</a>
<span class="lineNum">      76 </span>            : template &lt;typename T&gt;
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : inline void AcuteArcToBezier(T* aSink,</span>
<span class="lineNum">      78 </span>            :                              const Point&amp; aOrigin, const Size&amp; aRadius,
<span class="lineNum">      79 </span>            :                              const Point&amp; aStartPoint, const Point&amp; aEndPoint,
<span class="lineNum">      80 </span>            :                              Float aStartAngle, Float aEndAngle)
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   AcuteArcToBezier(aSink, aOrigin, aRadius, aStartPoint, aEndPoint,</span>
<span class="lineNum">      83 </span>            :                    ComputeKappaFactor(aEndAngle - aStartAngle));
<span class="lineNum">      84 </span><span class="lineNoCov">          0 : }</span>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<span class="lineNum">      86 </span>            : template &lt;typename T&gt;
<span class="lineNum">      87 </span><span class="lineNoCov">          0 : void ArcToBezier(T* aSink, const Point &amp;aOrigin, const Size &amp;aRadius,</span>
<span class="lineNum">      88 </span>            :                  float aStartAngle, float aEndAngle, bool aAntiClockwise,
<span class="lineNum">      89 </span>            :                  float aRotation = 0.0f)
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   Float sweepDirection = aAntiClockwise ? -1.0f : 1.0f;</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :   // Calculate the total arc we're going to sweep.
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   Float arcSweepLeft = (aEndAngle - aStartAngle) * sweepDirection;</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   // Clockwise we always sweep from the smaller to the larger angle, ccw
<span class="lineNum">      97 </span>            :   // it's vice versa.
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   if (arcSweepLeft &lt; 0) {</span>
<span class="lineNum">      99 </span>            :     // Rerverse sweep is modulo'd into range rather than clamped.
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     arcSweepLeft = Float(2.0f * M_PI) + fmodf(arcSweepLeft, Float(2.0f * M_PI));</span>
<span class="lineNum">     101 </span>            :     // Recalculate the start angle to land closer to end angle.
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     aStartAngle = aEndAngle - arcSweepLeft * sweepDirection;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   } else if (arcSweepLeft &gt; Float(2.0f * M_PI)) {</span>
<span class="lineNum">     104 </span>            :     // Sweeping more than 2 * pi is a full circle.
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     arcSweepLeft = Float(2.0f * M_PI);</span>
<span class="lineNum">     106 </span>            :   }
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   Float currentStartAngle = aStartAngle;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   Point currentStartOffset(cosf(aStartAngle), sinf(aStartAngle));</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   Matrix transform = Matrix::Scaling(aRadius.width, aRadius.height);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   if (aRotation != 0.0f) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     transform *= Matrix::Rotation(aRotation);</span>
<span class="lineNum">     113 </span>            :   }
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   transform.PostTranslate(aOrigin);</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   aSink-&gt;LineTo(transform.TransformPoint(currentStartOffset));</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   while (arcSweepLeft &gt; 0) {</span>
<span class="lineNum">     118 </span>            :     Float currentEndAngle =
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       currentStartAngle + std::min(arcSweepLeft, Float(M_PI / 2.0f)) * sweepDirection;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     Point currentEndOffset(cosf(currentEndAngle), sinf(currentEndAngle));</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     PartialArcToBezier(aSink, currentStartOffset, currentEndOffset, transform,</span>
<span class="lineNum">     123 </span>            :                        ComputeKappaFactor(currentEndAngle - currentStartAngle));
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :     // We guarantee here the current point is the start point of the next
<span class="lineNum">     126 </span>            :     // curve segment.
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     arcSweepLeft -= Float(M_PI / 2.0f);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     currentStartAngle = currentEndAngle;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     currentStartOffset = currentEndOffset;</span>
<span class="lineNum">     130 </span>            :   }
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : /* This is basically the ArcToBezier with the parameters for drawing a circle
<span class="lineNum">     134 </span>            :  * inlined which vastly simplifies it and avoids a bunch of transcedental function
<a name="135"><span class="lineNum">     135 </span>            :  * calls which should make it faster. */</a>
<span class="lineNum">     136 </span>            : template &lt;typename T&gt;
<span class="lineNum">     137 </span><span class="lineNoCov">          0 : void EllipseToBezier(T* aSink, const Point &amp;aOrigin, const Size &amp;aRadius)</span>
<span class="lineNum">     138 </span>            : {
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   Matrix transform(aRadius.width, 0, 0, aRadius.height, aOrigin.x, aOrigin.y);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   Point currentStartOffset(1, 0);</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   aSink-&gt;LineTo(transform.TransformPoint(currentStartOffset));</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; 4; i++) {</span>
<span class="lineNum">     145 </span>            :     // cos(x+pi/2) == -sin(x)
<span class="lineNum">     146 </span>            :     // sin(x+pi/2) == cos(x)
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     Point currentEndOffset(-currentStartOffset.y, currentStartOffset.x);</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     PartialArcToBezier(aSink, currentStartOffset, currentEndOffset, transform);</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :     // We guarantee here the current point is the start point of the next
<span class="lineNum">     152 </span>            :     // curve segment.
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     currentStartOffset = currentEndOffset;</span>
<span class="lineNum">     154 </span>            :   }
<span class="lineNum">     155 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /**
<span class="lineNum">     158 </span>            :  * Appends a path represending a rectangle to the path being built by
<span class="lineNum">     159 </span>            :  * aPathBuilder.
<span class="lineNum">     160 </span>            :  *
<span class="lineNum">     161 </span>            :  * aRect           The rectangle to append.
<span class="lineNum">     162 </span>            :  * aDrawClockwise  If set to true, the path will start at the left of the top
<span class="lineNum">     163 </span>            :  *                 left edge and draw clockwise. If set to false the path will
<span class="lineNum">     164 </span>            :  *                 start at the right of the top left edge and draw counter-
<span class="lineNum">     165 </span>            :  *                 clockwise.
<span class="lineNum">     166 </span>            :  */
<span class="lineNum">     167 </span>            : GFX2D_API void AppendRectToPath(PathBuilder* aPathBuilder,
<span class="lineNum">     168 </span>            :                                 const Rect&amp; aRect,
<span class="lineNum">     169 </span>            :                                 bool aDrawClockwise = true);
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : inline already_AddRefed&lt;Path&gt; MakePathForRect(const DrawTarget&amp; aDrawTarget,
<span class="lineNum">     172 </span>            :                                           const Rect&amp; aRect,
<span class="lineNum">     173 </span>            :                                           bool aDrawClockwise = true)
<span class="lineNum">     174 </span>            : {
<span class="lineNum">     175 </span>            :   RefPtr&lt;PathBuilder&gt; builder = aDrawTarget.CreatePathBuilder();
<span class="lineNum">     176 </span>            :   AppendRectToPath(builder, aRect, aDrawClockwise);
<span class="lineNum">     177 </span>            :   return builder-&gt;Finish();
<span class="lineNum">     178 </span>            : }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : struct RectCornerRadii {
<a name="181"><span class="lineNum">     181 </span>            :   Size radii[eCornerCount];</a>
<span class="lineNum">     182 </span>            : 
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">        567 :   RectCornerRadii() {}</span></a>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineCov">          9 :   explicit RectCornerRadii(Float radius) {</span>
<span class="lineNum">     186 </span><span class="lineCov">         45 :     NS_FOR_CSS_FULL_CORNERS(i) {</span>
<span class="lineNum">     187 </span><span class="lineCov">         36 :       radii[i].SizeTo(radius, radius);</span>
<span class="lineNum">     188 </span>            :     }
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">          9 :   }</span></a>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineCov">          4 :   explicit RectCornerRadii(Float radiusX, Float radiusY) {</span>
<span class="lineNum">     192 </span><span class="lineCov">         20 :     NS_FOR_CSS_FULL_CORNERS(i) {</span>
<span class="lineNum">     193 </span><span class="lineCov">         16 :       radii[i].SizeTo(radiusX, radiusY);</span>
<span class="lineNum">     194 </span>            :     }
<span class="lineNum">     195 </span><span class="lineCov">          4 :   }</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   RectCornerRadii(Float tl, Float tr, Float br, Float bl) {
<span class="lineNum">     198 </span>            :     radii[eCornerTopLeft].SizeTo(tl, tl);
<span class="lineNum">     199 </span>            :     radii[eCornerTopRight].SizeTo(tr, tr);
<span class="lineNum">     200 </span>            :     radii[eCornerBottomRight].SizeTo(br, br);
<span class="lineNum">     201 </span>            :     radii[eCornerBottomLeft].SizeTo(bl, bl);
<span class="lineNum">     202 </span>            :   }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :   RectCornerRadii(const Size&amp; tl, const Size&amp; tr,
<span class="lineNum">     205 </span>            :                   const Size&amp; br, const Size&amp; bl) {
<span class="lineNum">     206 </span>            :     radii[eCornerTopLeft] = tl;
<span class="lineNum">     207 </span>            :     radii[eCornerTopRight] = tr;
<span class="lineNum">     208 </span>            :     radii[eCornerBottomRight] = br;
<span class="lineNum">     209 </span>            :     radii[eCornerBottomLeft] = bl;
<a name="210"><span class="lineNum">     210 </span>            :   }</a>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineCov">       3559 :   const Size&amp; operator[](size_t aCorner) const {</span>
<span class="lineNum">     213 </span><span class="lineCov">       3559 :     return radii[aCorner];</span>
<a name="214"><span class="lineNum">     214 </span>            :   }</a>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineCov">       1223 :   Size&amp; operator[](size_t aCorner) {</span>
<span class="lineNum">     217 </span><span class="lineCov">       1223 :     return radii[aCorner];</span>
<a name="218"><span class="lineNum">     218 </span>            :   }</a>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineCov">          8 :   bool operator==(const RectCornerRadii&amp; aOther) const {</span>
<span class="lineNum">     221 </span><span class="lineCov">         64 :     return TopLeft() == aOther.TopLeft() &amp;&amp;</span>
<span class="lineNum">     222 </span><span class="lineCov">         56 :            TopRight() == aOther.TopRight() &amp;&amp;</span>
<span class="lineNum">     223 </span><span class="lineCov">         88 :            BottomRight() == aOther.BottomRight() &amp;&amp;</span>
<span class="lineNum">     224 </span><span class="lineCov">         40 :            BottomLeft() == aOther.BottomLeft();</span>
<a name="225"><span class="lineNum">     225 </span>            :   }</a>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineCov">          9 :   bool AreRadiiSame() const {</span>
<span class="lineNum">     228 </span><span class="lineCov">         72 :     return TopLeft() == TopRight() &amp;&amp;</span>
<span class="lineNum">     229 </span><span class="lineCov">         90 :            TopLeft() == BottomRight() &amp;&amp;</span>
<span class="lineNum">     230 </span><span class="lineCov">         45 :            TopLeft() == BottomLeft();</span>
<a name="231"><span class="lineNum">     231 </span>            :   }</a>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineCov">          9 :   void Scale(Float aXScale, Float aYScale) {</span>
<span class="lineNum">     234 </span><span class="lineCov">         45 :     NS_FOR_CSS_FULL_CORNERS(i) {</span>
<span class="lineNum">     235 </span><span class="lineCov">         36 :       radii[i].Scale(aXScale, aYScale);</span>
<span class="lineNum">     236 </span>            :     }
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">          9 :   }</span></a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<span class="lineNum">     239 </span><span class="lineCov">        472 :   const Size TopLeft() const { return radii[eCornerTopLeft]; }</span>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :   Size&amp; TopLeft() { return radii[eCornerTopLeft]; }</span></a>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineCov">        310 :   const Size TopRight() const { return radii[eCornerTopRight]; }</span>
<a name="243"><span class="lineNum">     243 </span>            :   Size&amp; TopRight() { return radii[eCornerTopRight]; }</a>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineCov">        310 :   const Size BottomRight() const { return radii[eCornerBottomRight]; }</span>
<a name="246"><span class="lineNum">     246 </span>            :   Size&amp; BottomRight() { return radii[eCornerBottomRight]; }</a>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov">        310 :   const Size BottomLeft() const { return radii[eCornerBottomLeft]; }</span>
<a name="249"><span class="lineNum">     249 </span>            :   Size&amp; BottomLeft() { return radii[eCornerBottomLeft]; }</a>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">        429 :   bool IsEmpty() const {</span>
<span class="lineNum">     252 </span><span class="lineCov">       2571 :     return TopLeft().IsEmpty() &amp;&amp; TopRight().IsEmpty() &amp;&amp;</span>
<span class="lineNum">     253 </span><span class="lineCov">       2571 :            BottomRight().IsEmpty() &amp;&amp; BottomLeft().IsEmpty();</span>
<span class="lineNum">     254 </span>            :   }
<span class="lineNum">     255 </span>            : };
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /**
<span class="lineNum">     258 </span>            :  * Appends a path represending a rounded rectangle to the path being built by
<span class="lineNum">     259 </span>            :  * aPathBuilder.
<span class="lineNum">     260 </span>            :  *
<span class="lineNum">     261 </span>            :  * aRect           The rectangle to append.
<span class="lineNum">     262 </span>            :  * aCornerRadii    Contains the radii of the top-left, top-right, bottom-right
<span class="lineNum">     263 </span>            :  *                 and bottom-left corners, in that order.
<span class="lineNum">     264 </span>            :  * aDrawClockwise  If set to true, the path will start at the left of the top
<span class="lineNum">     265 </span>            :  *                 left edge and draw clockwise. If set to false the path will
<span class="lineNum">     266 </span>            :  *                 start at the right of the top left edge and draw counter-
<span class="lineNum">     267 </span>            :  *                 clockwise.
<span class="lineNum">     268 </span>            :  */
<span class="lineNum">     269 </span>            : GFX2D_API void AppendRoundedRectToPath(PathBuilder* aPathBuilder,
<span class="lineNum">     270 </span>            :                                        const Rect&amp; aRect,
<span class="lineNum">     271 </span>            :                                        const RectCornerRadii&amp; aRadii,
<a name="272"><span class="lineNum">     272 </span>            :                                        bool aDrawClockwise = true);</a>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineCov">         22 : inline already_AddRefed&lt;Path&gt; MakePathForRoundedRect(const DrawTarget&amp; aDrawTarget,</span>
<span class="lineNum">     275 </span>            :                                                  const Rect&amp; aRect,
<span class="lineNum">     276 </span>            :                                                  const RectCornerRadii&amp; aRadii,
<span class="lineNum">     277 </span>            :                                                  bool aDrawClockwise = true)
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span><span class="lineCov">         44 :   RefPtr&lt;PathBuilder&gt; builder = aDrawTarget.CreatePathBuilder();</span>
<span class="lineNum">     280 </span><span class="lineCov">         22 :   AppendRoundedRectToPath(builder, aRect, aRadii, aDrawClockwise);</span>
<span class="lineNum">     281 </span><span class="lineCov">         44 :   return builder-&gt;Finish();</span>
<span class="lineNum">     282 </span>            : }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : /**
<span class="lineNum">     285 </span>            :  * Appends a path represending an ellipse to the path being built by
<span class="lineNum">     286 </span>            :  * aPathBuilder.
<span class="lineNum">     287 </span>            :  *
<span class="lineNum">     288 </span>            :  * The ellipse extends aDimensions.width / 2.0 in the horizontal direction
<span class="lineNum">     289 </span>            :  * from aCenter, and aDimensions.height / 2.0 in the vertical direction.
<span class="lineNum">     290 </span>            :  */
<span class="lineNum">     291 </span>            : GFX2D_API void AppendEllipseToPath(PathBuilder* aPathBuilder,
<span class="lineNum">     292 </span>            :                                    const Point&amp; aCenter,
<a name="293"><span class="lineNum">     293 </span>            :                                    const Size&amp; aDimensions);</a>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 : inline already_AddRefed&lt;Path&gt; MakePathForEllipse(const DrawTarget&amp; aDrawTarget,</span>
<span class="lineNum">     296 </span>            :                                              const Point&amp; aCenter,
<span class="lineNum">     297 </span>            :                                              const Size&amp; aDimensions)
<span class="lineNum">     298 </span>            : {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   RefPtr&lt;PathBuilder&gt; builder = aDrawTarget.CreatePathBuilder();</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   AppendEllipseToPath(builder, aCenter, aDimensions);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   return builder-&gt;Finish();</span>
<span class="lineNum">     302 </span>            : }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /**
<span class="lineNum">     305 </span>            :  * If aDrawTarget's transform only contains a translation, and if this line is
<span class="lineNum">     306 </span>            :  * a horizontal or vertical line, this function will snap the line's vertices
<span class="lineNum">     307 </span>            :  * to align with the device pixel grid so that stroking the line with a one
<span class="lineNum">     308 </span>            :  * pixel wide stroke will result in a crisp line that is not antialiased over
<span class="lineNum">     309 </span>            :  * two pixels across its width.
<span class="lineNum">     310 </span>            :  *
<span class="lineNum">     311 </span>            :  * @return Returns true if this function snaps aRect's vertices, else returns
<span class="lineNum">     312 </span>            :  *   false.
<span class="lineNum">     313 </span>            :  */
<span class="lineNum">     314 </span>            : GFX2D_API bool SnapLineToDevicePixelsForStroking(Point&amp; aP1, Point&amp; aP2,
<span class="lineNum">     315 </span>            :                                                  const DrawTarget&amp; aDrawTarget,
<span class="lineNum">     316 </span>            :                                                  Float aLineWidth);
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /**
<span class="lineNum">     319 </span>            :  * This function paints each edge of aRect separately, snapping the edges using
<span class="lineNum">     320 </span>            :  * SnapLineToDevicePixelsForStroking. Stroking the edges as separate paths
<span class="lineNum">     321 </span>            :  * helps ensure not only that the stroke spans a single row of device pixels if
<span class="lineNum">     322 </span>            :  * possible, but also that the ends of stroke dashes start and end on device
<span class="lineNum">     323 </span>            :  * pixels too.
<span class="lineNum">     324 </span>            :  */
<span class="lineNum">     325 </span>            : GFX2D_API void StrokeSnappedEdgesOfRect(const Rect&amp; aRect,
<span class="lineNum">     326 </span>            :                                         DrawTarget&amp; aDrawTarget,
<span class="lineNum">     327 </span>            :                                         const ColorPattern&amp; aColor,
<span class="lineNum">     328 </span>            :                                         const StrokeOptions&amp; aStrokeOptions);
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /**
<span class="lineNum">     331 </span>            :  * Return the margin, in device space, by which a stroke can extend beyond the
<span class="lineNum">     332 </span>            :  * rendered shape.
<span class="lineNum">     333 </span>            :  * @param  aStrokeOptions The stroke options that the stroke is drawn with.
<span class="lineNum">     334 </span>            :  * @param  aTransform     The user space to device space transform.
<span class="lineNum">     335 </span>            :  * @return                The stroke margin.
<span class="lineNum">     336 </span>            :  */
<span class="lineNum">     337 </span>            : GFX2D_API Margin MaxStrokeExtents(const StrokeOptions&amp; aStrokeOptions,
<span class="lineNum">     338 </span>            :                                   const Matrix&amp; aTransform);
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : extern UserDataKey sDisablePixelSnapping;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /**
<span class="lineNum">     343 </span>            :  * If aDrawTarget's transform only contains a translation or, if
<span class="lineNum">     344 </span>            :  * aAllowScaleOr90DegreeRotate is true, and/or a scale/90 degree rotation, this
<span class="lineNum">     345 </span>            :  * function will convert aRect to device space and snap it to device pixels.
<span class="lineNum">     346 </span>            :  * This function returns true if aRect is modified, otherwise it returns false.
<span class="lineNum">     347 </span>            :  *
<span class="lineNum">     348 </span>            :  * Note that the snapping is such that filling the rect using a DrawTarget
<span class="lineNum">     349 </span>            :  * which has the identity matrix as its transform will result in crisp edges.
<span class="lineNum">     350 </span>            :  * (That is, aRect will have integer values, aligning its edges between pixel
<span class="lineNum">     351 </span>            :  * boundaries.)  If on the other hand you stroking the rect with an odd valued
<span class="lineNum">     352 </span>            :  * stroke width then the edges of the stroke will be antialiased (assuming an
<span class="lineNum">     353 </span>            :  * AntialiasMode that does antialiasing).
<span class="lineNum">     354 </span>            :  *
<span class="lineNum">     355 </span>            :  * Empty snaps are those which result in a rectangle of 0 area.  If they are
<span class="lineNum">     356 </span>            :  * disallowed, an axis is left unsnapped if the rounding process results in a
<a name="357"><span class="lineNum">     357 </span>            :  * length of 0.</a>
<span class="lineNum">     358 </span>            :  */
<span class="lineNum">     359 </span><span class="lineCov">         59 : inline bool UserToDevicePixelSnapped(Rect&amp; aRect, const DrawTarget&amp; aDrawTarget,</span>
<span class="lineNum">     360 </span>            :                                      bool aAllowScaleOr90DegreeRotate = false,
<span class="lineNum">     361 </span>            :                                      bool aAllowEmptySnaps = true)
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineCov">         59 :   if (aDrawTarget.GetUserData(&amp;sDisablePixelSnapping)) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     365 </span>            :   }
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineCov">         59 :   Matrix mat = aDrawTarget.GetTransform();</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineCov">         59 :   const Float epsilon = 0.0000001f;</span>
<span class="lineNum">     370 </span>            : #define WITHIN_E(a,b) (fabs((a)-(b)) &lt; epsilon)
<span class="lineNum">     371 </span><span class="lineCov">         59 :   if (!aAllowScaleOr90DegreeRotate &amp;&amp;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       (!WITHIN_E(mat._11, 1.f) || !WITHIN_E(mat._22, 1.f) ||</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :        !WITHIN_E(mat._12, 0.f) || !WITHIN_E(mat._21, 0.f))) {</span>
<span class="lineNum">     374 </span>            :     // We have non-translation, but only translation is allowed.
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     376 </span>            :   }
<span class="lineNum">     377 </span>            : #undef WITHIN_E
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">         59 :   Point p1 = mat.TransformPoint(aRect.TopLeft());</span>
<span class="lineNum">     380 </span><span class="lineCov">         59 :   Point p2 = mat.TransformPoint(aRect.TopRight());</span>
<span class="lineNum">     381 </span><span class="lineCov">         59 :   Point p3 = mat.TransformPoint(aRect.BottomRight());</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   // Check that the rectangle is axis-aligned. For an axis-aligned rectangle,
<span class="lineNum">     384 </span>            :   // two opposite corners define the entire rectangle. So check if
<span class="lineNum">     385 </span>            :   // the axis-aligned rectangle with opposite corners p1 and p3
<span class="lineNum">     386 </span>            :   // define an axis-aligned rectangle whose other corners are p2 and p4.
<span class="lineNum">     387 </span>            :   // We actually only need to check one of p2 and p4, since an affine
<span class="lineNum">     388 </span>            :   // transform maps parallelograms to parallelograms.
<span class="lineNum">     389 </span><span class="lineCov">         59 :   if (p2 == Point(p1.x, p3.y) || p2 == Point(p3.x, p1.y)) {</span>
<span class="lineNum">     390 </span><span class="lineCov">         59 :       Point p1r = p1;</span>
<span class="lineNum">     391 </span><span class="lineCov">         59 :       Point p3r = p3;</span>
<span class="lineNum">     392 </span><span class="lineCov">         59 :       p1r.Round();</span>
<span class="lineNum">     393 </span><span class="lineCov">         59 :       p3r.Round();</span>
<span class="lineNum">     394 </span><span class="lineCov">         59 :       if (aAllowEmptySnaps || p1r.x != p3r.x) {</span>
<span class="lineNum">     395 </span><span class="lineCov">         59 :           p1.x = p1r.x;</span>
<span class="lineNum">     396 </span><span class="lineCov">         59 :           p3.x = p3r.x;</span>
<span class="lineNum">     397 </span>            :       }
<span class="lineNum">     398 </span><span class="lineCov">         59 :       if (aAllowEmptySnaps || p1r.y != p3r.y) {</span>
<span class="lineNum">     399 </span><span class="lineCov">         59 :           p1.y = p1r.y;</span>
<span class="lineNum">     400 </span><span class="lineCov">         59 :           p3.y = p3r.y;</span>
<span class="lineNum">     401 </span>            :       }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineCov">         59 :       aRect.MoveTo(Point(std::min(p1.x, p3.x), std::min(p1.y, p3.y)));</span>
<span class="lineNum">     404 </span><span class="lineCov">        118 :       aRect.SizeTo(Size(std::max(p1.x, p3.x) - aRect.X(),</span>
<span class="lineNum">     405 </span><span class="lineCov">        118 :                         std::max(p1.y, p3.y) - aRect.Y()));</span>
<span class="lineNum">     406 </span><span class="lineCov">         59 :       return true;</span>
<span class="lineNum">     407 </span>            :   }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     410 </span>            : }
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : /**
<span class="lineNum">     413 </span>            :  * This function has the same behavior as UserToDevicePixelSnapped except that
<a name="414"><span class="lineNum">     414 </span>            :  * aRect is not transformed to device space.</a>
<span class="lineNum">     415 </span>            :  */
<span class="lineNum">     416 </span><span class="lineCov">         59 : inline bool MaybeSnapToDevicePixels(Rect&amp; aRect, const DrawTarget&amp; aDrawTarget,</span>
<span class="lineNum">     417 </span>            :                                     bool aAllowScaleOr90DegreeRotate = false,
<span class="lineNum">     418 </span>            :                                     bool aAllowEmptySnaps = true)
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span><span class="lineCov">         59 :   if (UserToDevicePixelSnapped(aRect, aDrawTarget,</span>
<span class="lineNum">     421 </span>            :                                aAllowScaleOr90DegreeRotate, aAllowEmptySnaps)) {
<span class="lineNum">     422 </span>            :     // Since UserToDevicePixelSnapped returned true we know there is no
<span class="lineNum">     423 </span>            :     // rotation/skew in 'mat', so we can just use TransformBounds() here.
<span class="lineNum">     424 </span><span class="lineCov">         59 :     Matrix mat = aDrawTarget.GetTransform();</span>
<span class="lineNum">     425 </span><span class="lineCov">         59 :     mat.Invert();</span>
<span class="lineNum">     426 </span><span class="lineCov">         59 :     aRect = mat.TransformBounds(aRect);</span>
<span class="lineNum">     427 </span><span class="lineCov">         59 :     return true;</span>
<span class="lineNum">     428 </span>            :   }
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     430 </span>            : }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : } // namespace gfx
<span class="lineNum">     433 </span>            : } // namespace mozilla
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : #endif /* MOZILLA_GFX_PATHHELPERS_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

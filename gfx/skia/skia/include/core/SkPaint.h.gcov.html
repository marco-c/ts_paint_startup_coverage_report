<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/include/core/SkPaint.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/include/core</a> - SkPaint.h<span style="font-size: 80%;"> (source / <a href="SkPaint.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntry">75</td>
            <td class="headerCovTableEntryHi">92.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntryHi">93.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2006 The Android Open Source Project
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #ifndef SkPaint_DEFINED
<span class="lineNum">       9 </span>            : #define SkPaint_DEFINED
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;SkBlendMode.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SkColor.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SkFilterQuality.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;SkMatrix.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SkRefCnt.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : class SkAutoDescriptor;
<span class="lineNum">      18 </span>            : class SkAutoGlyphCache;
<span class="lineNum">      19 </span>            : class SkColorFilter;
<span class="lineNum">      20 </span>            : class SkData;
<span class="lineNum">      21 </span>            : class SkDescriptor;
<span class="lineNum">      22 </span>            : class SkDrawLooper;
<span class="lineNum">      23 </span>            : class SkReadBuffer;
<span class="lineNum">      24 </span>            : class SkWriteBuffer;
<span class="lineNum">      25 </span>            : class SkGlyph;
<span class="lineNum">      26 </span>            : struct SkRect;
<span class="lineNum">      27 </span>            : class SkGlyphCache;
<span class="lineNum">      28 </span>            : class SkImageFilter;
<span class="lineNum">      29 </span>            : class SkMaskFilter;
<span class="lineNum">      30 </span>            : class SkPath;
<span class="lineNum">      31 </span>            : class SkPathEffect;
<span class="lineNum">      32 </span>            : struct SkPoint;
<span class="lineNum">      33 </span>            : class SkRasterizer;
<span class="lineNum">      34 </span>            : struct SkScalerContextEffects;
<span class="lineNum">      35 </span>            : class SkShader;
<span class="lineNum">      36 </span>            : class SkSurfaceProps;
<span class="lineNum">      37 </span>            : class SkTextBlob;
<span class="lineNum">      38 </span>            : class SkTypeface;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : /** \class SkPaint
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :     The SkPaint class holds the style and color information about how to draw
<span class="lineNum">      43 </span>            :     geometries, text and bitmaps.
<span class="lineNum">      44 </span>            : */
<span class="lineNum">      45 </span>            : class SK_API SkPaint {
<span class="lineNum">      46 </span>            : public:
<span class="lineNum">      47 </span>            :     SkPaint();
<span class="lineNum">      48 </span>            :     SkPaint(const SkPaint&amp; paint);
<span class="lineNum">      49 </span>            :     SkPaint(SkPaint&amp;&amp; paint);
<span class="lineNum">      50 </span>            :     ~SkPaint();
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :     SkPaint&amp; operator=(const SkPaint&amp;);
<span class="lineNum">      53 </span>            :     SkPaint&amp; operator=(SkPaint&amp;&amp;);
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :     /** operator== may give false negatives: two paints that draw equivalently
<span class="lineNum">      56 </span>            :         may return false.  It will never give false positives: two paints that
<span class="lineNum">      57 </span>            :         are not equivalent always return false.
<span class="lineNum">      58 </span>            :     */
<span class="lineNum">      59 </span>            :     SK_API friend bool operator==(const SkPaint&amp; a, const SkPaint&amp; b);
<span class="lineNum">      60 </span>            :     friend bool operator!=(const SkPaint&amp; a, const SkPaint&amp; b) {
<span class="lineNum">      61 </span>            :         return !(a == b);
<span class="lineNum">      62 </span>            :     }
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :     /** getHash() is a shallow hash, with the same limitations as operator==.
<span class="lineNum">      65 </span>            :      *  If operator== returns true for two paints, getHash() returns the same value for each.
<span class="lineNum">      66 </span>            :      */
<span class="lineNum">      67 </span>            :     uint32_t getHash() const;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :     void flatten(SkWriteBuffer&amp;) const;
<span class="lineNum">      70 </span>            :     void unflatten(SkReadBuffer&amp;);
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :     /** Restores the paint to its initial settings.
<span class="lineNum">      73 </span>            :     */
<span class="lineNum">      74 </span>            :     void reset();
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :     /** Specifies the level of hinting to be performed. These names are taken
<span class="lineNum">      77 </span>            :         from the Gnome/Cairo names for the same. They are translated into
<span class="lineNum">      78 </span>            :         Freetype concepts the same as in cairo-ft-font.c:
<span class="lineNum">      79 </span>            :            kNo_Hinting     -&gt; FT_LOAD_NO_HINTING
<span class="lineNum">      80 </span>            :            kSlight_Hinting -&gt; FT_LOAD_TARGET_LIGHT
<span class="lineNum">      81 </span>            :            kNormal_Hinting -&gt; &lt;default, no option&gt;
<span class="lineNum">      82 </span>            :            kFull_Hinting   -&gt; &lt;same as kNormalHinting, unless we are rendering
<span class="lineNum">      83 </span>            :                               subpixel glyphs, in which case TARGET_LCD or
<span class="lineNum">      84 </span>            :                               TARGET_LCD_V is used&gt;
<span class="lineNum">      85 </span>            :     */
<span class="lineNum">      86 </span>            :     enum Hinting {
<span class="lineNum">      87 </span>            :         kNo_Hinting            = 0,
<span class="lineNum">      88 </span>            :         kSlight_Hinting        = 1,
<span class="lineNum">      89 </span>            :         kNormal_Hinting        = 2,     //!&lt; this is the default
<span class="lineNum">      90 </span>            :         kFull_Hinting          = 3
<a name="91"><span class="lineNum">      91 </span>            :     };</a>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span><span class="lineCov">         21 :     Hinting getHinting() const {</span>
<span class="lineNum">      94 </span><span class="lineCov">         21 :         return static_cast&lt;Hinting&gt;(fBitfields.fHinting);</span>
<span class="lineNum">      95 </span>            :     }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :     void setHinting(Hinting hintingLevel);
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :     /** Specifies the bit values that are stored in the paint's flags.
<span class="lineNum">     100 </span>            :     */
<span class="lineNum">     101 </span>            :     enum Flags {
<span class="lineNum">     102 </span>            :         kAntiAlias_Flag       = 0x01,   //!&lt; mask to enable antialiasing
<span class="lineNum">     103 </span>            :         kDither_Flag          = 0x04,   //!&lt; mask to enable dithering
<span class="lineNum">     104 </span>            :         kFakeBoldText_Flag    = 0x20,   //!&lt; mask to enable fake-bold text
<span class="lineNum">     105 </span>            :         kLinearText_Flag      = 0x40,   //!&lt; mask to enable linear-text
<span class="lineNum">     106 </span>            :         kSubpixelText_Flag    = 0x80,   //!&lt; mask to enable subpixel text positioning
<span class="lineNum">     107 </span>            :         kDevKernText_Flag     = 0x100,  //!&lt; mask to enable device kerning text
<span class="lineNum">     108 </span>            :         kLCDRenderText_Flag   = 0x200,  //!&lt; mask to enable subpixel glyph renderering
<span class="lineNum">     109 </span>            :         kEmbeddedBitmapText_Flag = 0x400, //!&lt; mask to enable embedded bitmap strikes
<span class="lineNum">     110 </span>            :         kAutoHinting_Flag     = 0x800,  //!&lt; mask to force Freetype's autohinter
<span class="lineNum">     111 </span>            :         kVerticalText_Flag    = 0x1000,
<span class="lineNum">     112 </span>            :         kGenA8FromLCD_Flag    = 0x2000, // hack for GDI -- do not use if you can help it
<span class="lineNum">     113 </span>            :         // when adding extra flags, note that the fFlags member is specified
<span class="lineNum">     114 </span>            :         // with a bit-width and you'll have to expand it.
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :         kAllFlags = 0xFFFF,
<span class="lineNum">     117 </span>            :     };
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #ifdef SK_BUILD_FOR_ANDROID_FRAMEWORK
<span class="lineNum">     120 </span>            :     enum ReserveFlags {
<span class="lineNum">     121 </span>            :         // These are not used by paint, but the bits are reserved for private use by the
<span class="lineNum">     122 </span>            :         // android framework.
<span class="lineNum">     123 </span>            :         kUnderlineText_ReserveFlag   = 0x08,   //!&lt; mask to enable underline text
<span class="lineNum">     124 </span>            :         kStrikeThruText_ReserveFlag  = 0x10,   //!&lt; mask to enable strike-thru text
<span class="lineNum">     125 </span>            :     };
<span class="lineNum">     126 </span>            : #endif
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     /** Return the paint's flags. Use the Flag enum to test flag values.
<a name="129"><span class="lineNum">     129 </span>            :         @return the paint's flags (see enums ending in _Flag for bit masks)</a>
<span class="lineNum">     130 </span>            :     */
<span class="lineNum">     131 </span><span class="lineCov">        964 :     uint32_t getFlags() const { return fBitfields.fFlags; }</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     /** Set the paint's flags. Use the Flag enum to specific flag values.
<span class="lineNum">     134 </span>            :         @param flags    The new flag bits for the paint (see Flags enum)
<span class="lineNum">     135 </span>            :     */
<span class="lineNum">     136 </span>            :     void setFlags(uint32_t flags);
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     /** Helper for getFlags(), returning true if kAntiAlias_Flag bit is set
<a name="139"><span class="lineNum">     139 </span>            :         @return true if the antialias bit is set in the paint's flags.</a>
<span class="lineNum">     140 </span>            :         */
<span class="lineNum">     141 </span><span class="lineCov">        666 :     bool isAntiAlias() const {</span>
<span class="lineNum">     142 </span><span class="lineCov">        666 :         return SkToBool(this-&gt;getFlags() &amp; kAntiAlias_Flag);</span>
<span class="lineNum">     143 </span>            :     }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :     /** Helper for setFlags(), setting or clearing the kAntiAlias_Flag bit
<span class="lineNum">     146 </span>            :         @param aa   true to enable antialiasing, false to disable it
<span class="lineNum">     147 </span>            :         */
<span class="lineNum">     148 </span>            :     void setAntiAlias(bool aa);
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :     /** Helper for getFlags(), returning true if kDither_Flag bit is set
<a name="151"><span class="lineNum">     151 </span>            :         @return true if the dithering bit is set in the paint's flags.</a>
<span class="lineNum">     152 </span>            :         */
<span class="lineNum">     153 </span><span class="lineCov">         25 :     bool isDither() const {</span>
<span class="lineNum">     154 </span><span class="lineCov">         25 :         return SkToBool(this-&gt;getFlags() &amp; kDither_Flag);</span>
<span class="lineNum">     155 </span>            :     }
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :     /** Helper for setFlags(), setting or clearing the kDither_Flag bit
<span class="lineNum">     158 </span>            :         @param dither   true to enable dithering, false to disable it
<span class="lineNum">     159 </span>            :         */
<span class="lineNum">     160 </span>            :     void setDither(bool dither);
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :     /** Helper for getFlags(), returning true if kLinearText_Flag bit is set
<a name="163"><span class="lineNum">     163 </span>            :         @return true if the lineartext bit is set in the paint's flags</a>
<span class="lineNum">     164 </span>            :     */
<span class="lineNum">     165 </span><span class="lineCov">         21 :     bool isLinearText() const {</span>
<span class="lineNum">     166 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kLinearText_Flag);</span>
<span class="lineNum">     167 </span>            :     }
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :     /** Helper for setFlags(), setting or clearing the kLinearText_Flag bit
<span class="lineNum">     170 </span>            :         @param linearText true to set the linearText bit in the paint's flags,
<span class="lineNum">     171 </span>            :                           false to clear it.
<span class="lineNum">     172 </span>            :     */
<span class="lineNum">     173 </span>            :     void setLinearText(bool linearText);
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :     /** Helper for getFlags(), returning true if kSubpixelText_Flag bit is set
<a name="176"><span class="lineNum">     176 </span>            :         @return true if the lineartext bit is set in the paint's flags</a>
<span class="lineNum">     177 </span>            :     */
<span class="lineNum">     178 </span><span class="lineCov">         21 :     bool isSubpixelText() const {</span>
<span class="lineNum">     179 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kSubpixelText_Flag);</span>
<span class="lineNum">     180 </span>            :     }
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :     /**
<span class="lineNum">     183 </span>            :      *  Helper for setFlags(), setting or clearing the kSubpixelText_Flag.
<span class="lineNum">     184 </span>            :      *  @param subpixelText true to set the subpixelText bit in the paint's
<span class="lineNum">     185 </span>            :      *                      flags, false to clear it.
<span class="lineNum">     186 </span>            :      */
<a name="187"><span class="lineNum">     187 </span>            :     void setSubpixelText(bool subpixelText);</a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineCov">         21 :     bool isLCDRenderText() const {</span>
<span class="lineNum">     190 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kLCDRenderText_Flag);</span>
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     /**
<span class="lineNum">     194 </span>            :      *  Helper for setFlags(), setting or clearing the kLCDRenderText_Flag.
<span class="lineNum">     195 </span>            :      *  Note: antialiasing must also be on for lcd rendering
<span class="lineNum">     196 </span>            :      *  @param lcdText true to set the LCDRenderText bit in the paint's flags,
<span class="lineNum">     197 </span>            :      *                 false to clear it.
<span class="lineNum">     198 </span>            :      */
<a name="199"><span class="lineNum">     199 </span>            :     void setLCDRenderText(bool lcdText);</a>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineCov">         21 :     bool isEmbeddedBitmapText() const {</span>
<span class="lineNum">     202 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kEmbeddedBitmapText_Flag);</span>
<span class="lineNum">     203 </span>            :     }
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :     /** Helper for setFlags(), setting or clearing the kEmbeddedBitmapText_Flag bit
<span class="lineNum">     206 </span>            :         @param useEmbeddedBitmapText true to set the kEmbeddedBitmapText bit in the paint's flags,
<span class="lineNum">     207 </span>            :                                      false to clear it.
<span class="lineNum">     208 </span>            :     */
<a name="209"><span class="lineNum">     209 </span>            :     void setEmbeddedBitmapText(bool useEmbeddedBitmapText);</a>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">         21 :     bool isAutohinted() const {</span>
<span class="lineNum">     212 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kAutoHinting_Flag);</span>
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :     /** Helper for setFlags(), setting or clearing the kAutoHinting_Flag bit
<span class="lineNum">     216 </span>            :         @param useAutohinter true to set the kEmbeddedBitmapText bit in the
<span class="lineNum">     217 </span>            :                                   paint's flags,
<span class="lineNum">     218 </span>            :                              false to clear it.
<span class="lineNum">     219 </span>            :     */
<a name="220"><span class="lineNum">     220 </span>            :     void setAutohinted(bool useAutohinter);</a>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineCov">         21 :     bool isVerticalText() const {</span>
<span class="lineNum">     223 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kVerticalText_Flag);</span>
<span class="lineNum">     224 </span>            :     }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     /**
<span class="lineNum">     227 </span>            :      *  Helper for setting or clearing the kVerticalText_Flag bit in
<span class="lineNum">     228 </span>            :      *  setFlags(...).
<span class="lineNum">     229 </span>            :      *
<span class="lineNum">     230 </span>            :      *  If this bit is set, then advances are treated as Y values rather than
<span class="lineNum">     231 </span>            :      *  X values, and drawText will places its glyphs vertically rather than
<span class="lineNum">     232 </span>            :      *  horizontally.
<span class="lineNum">     233 </span>            :      */
<span class="lineNum">     234 </span>            :     void setVerticalText(bool);
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :     /** Helper for getFlags(), returns true if kFakeBoldText_Flag bit is set
<a name="237"><span class="lineNum">     237 </span>            :         @return true if the kFakeBoldText_Flag bit is set in the paint's flags.</a>
<span class="lineNum">     238 </span>            :     */
<span class="lineNum">     239 </span><span class="lineCov">         42 :     bool isFakeBoldText() const {</span>
<span class="lineNum">     240 </span><span class="lineCov">         42 :         return SkToBool(this-&gt;getFlags() &amp; kFakeBoldText_Flag);</span>
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     /** Helper for setFlags(), setting or clearing the kFakeBoldText_Flag bit
<span class="lineNum">     244 </span>            :         @param fakeBoldText true to set the kFakeBoldText_Flag bit in the paint's
<span class="lineNum">     245 </span>            :                             flags, false to clear it.
<span class="lineNum">     246 </span>            :     */
<span class="lineNum">     247 </span>            :     void setFakeBoldText(bool fakeBoldText);
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :     /** Helper for getFlags(), returns true if kDevKernText_Flag bit is set
<a name="250"><span class="lineNum">     250 </span>            :         @return true if the kernText bit is set in the paint's flags.</a>
<span class="lineNum">     251 </span>            :     */
<span class="lineNum">     252 </span><span class="lineCov">         21 :     bool isDevKernText() const {</span>
<span class="lineNum">     253 </span><span class="lineCov">         21 :         return SkToBool(this-&gt;getFlags() &amp; kDevKernText_Flag);</span>
<span class="lineNum">     254 </span>            :     }
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :     /** Helper for setFlags(), setting or clearing the kKernText_Flag bit
<span class="lineNum">     257 </span>            :         @param kernText true to set the kKernText_Flag bit in the paint's
<span class="lineNum">     258 </span>            :                             flags, false to clear it.
<span class="lineNum">     259 </span>            :     */
<span class="lineNum">     260 </span>            :     void setDevKernText(bool devKernText);
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :     /**
<span class="lineNum">     263 </span>            :      *  Return the filter level. This affects the quality (and performance) of
<a name="264"><span class="lineNum">     264 </span>            :      *  drawing scaled images.</a>
<span class="lineNum">     265 </span>            :      */
<span class="lineNum">     266 </span><span class="lineCov">        426 :     SkFilterQuality getFilterQuality() const {</span>
<span class="lineNum">     267 </span><span class="lineCov">        426 :         return (SkFilterQuality)fBitfields.fFilterQuality;</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :     /**
<span class="lineNum">     271 </span>            :      *  Set the filter quality. This affects the quality (and performance) of
<span class="lineNum">     272 </span>            :      *  drawing scaled images.
<span class="lineNum">     273 </span>            :      */
<span class="lineNum">     274 </span>            :     void setFilterQuality(SkFilterQuality quality);
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     /** Styles apply to rect, oval, path, and text.
<span class="lineNum">     277 </span>            :         Bitmaps are always drawn in &quot;fill&quot;, and lines are always drawn in
<span class="lineNum">     278 </span>            :         &quot;stroke&quot;.
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :         Note: strokeandfill implicitly draws the result with
<span class="lineNum">     281 </span>            :         SkPath::kWinding_FillType, so if the original path is even-odd, the
<span class="lineNum">     282 </span>            :         results may not appear the same as if it was drawn twice, filled and
<span class="lineNum">     283 </span>            :         then stroked.
<span class="lineNum">     284 </span>            :     */
<span class="lineNum">     285 </span>            :     enum Style {
<span class="lineNum">     286 </span>            :         kFill_Style,            //!&lt; fill the geometry
<span class="lineNum">     287 </span>            :         kStroke_Style,          //!&lt; stroke the geometry
<span class="lineNum">     288 </span>            :         kStrokeAndFill_Style,   //!&lt; fill and stroke the geometry
<span class="lineNum">     289 </span>            :     };
<span class="lineNum">     290 </span>            :     enum {
<span class="lineNum">     291 </span>            :         kStyleCount = kStrokeAndFill_Style + 1
<span class="lineNum">     292 </span>            :     };
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :     /** Return the paint's style, used for controlling how primitives'
<span class="lineNum">     295 </span>            :         geometries are interpreted (except for drawBitmap, which always assumes
<span class="lineNum">     296 </span>            :         kFill_Style).
<a name="297"><span class="lineNum">     297 </span>            :         @return the paint's Style</a>
<span class="lineNum">     298 </span>            :     */
<span class="lineNum">     299 </span><span class="lineCov">       1185 :     Style getStyle() const { return (Style)fBitfields.fStyle; }</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     /** Set the paint's style, used for controlling how primitives'
<span class="lineNum">     302 </span>            :         geometries are interpreted (except for drawBitmap, which always assumes
<span class="lineNum">     303 </span>            :         Fill).
<span class="lineNum">     304 </span>            :         @param style    The new style to set in the paint
<span class="lineNum">     305 </span>            :     */
<span class="lineNum">     306 </span>            :     void setStyle(Style style);
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     /** Return the paint's color. Note that the color is a 32bit value
<span class="lineNum">     309 </span>            :         containing alpha as well as r,g,b. This 32bit value is not
<span class="lineNum">     310 </span>            :         premultiplied, meaning that its alpha can be any value, regardless of
<span class="lineNum">     311 </span>            :         the values of r,g,b.
<a name="312"><span class="lineNum">     312 </span>            :         @return the paint's color (and alpha).</a>
<span class="lineNum">     313 </span>            :     */
<span class="lineNum">     314 </span><span class="lineCov">        779 :     SkColor getColor() const { return fColor; }</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :     /** Set the paint's color. Note that the color is a 32bit value containing
<span class="lineNum">     317 </span>            :         alpha as well as r,g,b. This 32bit value is not premultiplied, meaning
<span class="lineNum">     318 </span>            :         that its alpha can be any value, regardless of the values of r,g,b.
<span class="lineNum">     319 </span>            :         @param color    The new color (including alpha) to set in the paint.
<span class="lineNum">     320 </span>            :     */
<span class="lineNum">     321 </span>            :     void setColor(SkColor color);
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     /** Helper to getColor() that just returns the color's alpha value.
<a name="324"><span class="lineNum">     324 </span>            :         @return the alpha component of the paint's color.</a>
<span class="lineNum">     325 </span>            :         */
<span class="lineNum">     326 </span><span class="lineCov">        914 :     uint8_t getAlpha() const { return SkToU8(SkColorGetA(fColor)); }</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     /** Helper to setColor(), that only assigns the color's alpha value,
<span class="lineNum">     329 </span>            :         leaving its r,g,b values unchanged.
<span class="lineNum">     330 </span>            :         @param a    set the alpha component (0..255) of the paint's color.
<span class="lineNum">     331 </span>            :     */
<span class="lineNum">     332 </span>            :     void setAlpha(U8CPU a);
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     /** Helper to setColor(), that takes a,r,g,b and constructs the color value
<span class="lineNum">     335 </span>            :         using SkColorSetARGB()
<span class="lineNum">     336 </span>            :         @param a    The new alpha component (0..255) of the paint's color.
<span class="lineNum">     337 </span>            :         @param r    The new red component (0..255) of the paint's color.
<span class="lineNum">     338 </span>            :         @param g    The new green component (0..255) of the paint's color.
<span class="lineNum">     339 </span>            :         @param b    The new blue component (0..255) of the paint's color.
<span class="lineNum">     340 </span>            :     */
<span class="lineNum">     341 </span>            :     void setARGB(U8CPU a, U8CPU r, U8CPU g, U8CPU b);
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :     /** Return the width for stroking.
<span class="lineNum">     344 </span>            :         &lt;p /&gt;
<span class="lineNum">     345 </span>            :         A value of 0 strokes in hairline mode.
<span class="lineNum">     346 </span>            :         Hairlines always draw 1-pixel wide, regardless of the matrix.
<span class="lineNum">     347 </span>            :         @return the paint's stroke width, used whenever the paint's style is
<a name="348"><span class="lineNum">     348 </span>            :                 Stroke or StrokeAndFill.</a>
<span class="lineNum">     349 </span>            :     */
<span class="lineNum">     350 </span><span class="lineCov">        297 :     SkScalar getStrokeWidth() const { return fWidth; }</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :     /** Set the width for stroking.
<span class="lineNum">     353 </span>            :         Pass 0 to stroke in hairline mode.
<span class="lineNum">     354 </span>            :         Hairlines always draw 1-pixel wide, regardless of the matrix.
<span class="lineNum">     355 </span>            :         @param width set the paint's stroke width, used whenever the paint's
<span class="lineNum">     356 </span>            :                      style is Stroke or StrokeAndFill.
<span class="lineNum">     357 </span>            :     */
<span class="lineNum">     358 </span>            :     void setStrokeWidth(SkScalar width);
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :     /** Return the paint's stroke miter value. This is used to control the
<span class="lineNum">     361 </span>            :         behavior of miter joins when the joins angle is sharp.
<span class="lineNum">     362 </span>            :         @return the paint's miter limit, used whenever the paint's style is
<a name="363"><span class="lineNum">     363 </span>            :                 Stroke or StrokeAndFill.</a>
<span class="lineNum">     364 </span>            :     */
<span class="lineNum">     365 </span><span class="lineCov">         30 :     SkScalar getStrokeMiter() const { return fMiterLimit; }</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :     /** Set the paint's stroke miter value. This is used to control the
<span class="lineNum">     368 </span>            :         behavior of miter joins when the joins angle is sharp. This value must
<span class="lineNum">     369 </span>            :         be &gt;= 0.
<span class="lineNum">     370 </span>            :         @param miter    set the miter limit on the paint, used whenever the
<span class="lineNum">     371 </span>            :                         paint's style is Stroke or StrokeAndFill.
<span class="lineNum">     372 </span>            :     */
<span class="lineNum">     373 </span>            :     void setStrokeMiter(SkScalar miter);
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     /** Cap enum specifies the settings for the paint's strokecap. This is the
<span class="lineNum">     376 </span>            :         treatment that is applied to the beginning and end of each non-closed
<span class="lineNum">     377 </span>            :         contour (e.g. lines).
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :         If the cap is round or square, the caps are drawn when the contour has
<span class="lineNum">     380 </span>            :         a zero length. Zero length contours can be created by following moveTo
<span class="lineNum">     381 </span>            :         with a lineTo at the same point, or a moveTo followed by a close.
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :         A dash with an on interval of zero also creates a zero length contour.
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :         The zero length contour draws the square cap without rotation, since
<span class="lineNum">     386 </span>            :         the no direction can be inferred.
<span class="lineNum">     387 </span>            :     */
<span class="lineNum">     388 </span>            :     enum Cap {
<span class="lineNum">     389 </span>            :         kButt_Cap,      //!&lt; begin/end contours with no extension
<span class="lineNum">     390 </span>            :         kRound_Cap,     //!&lt; begin/end contours with a semi-circle extension
<span class="lineNum">     391 </span>            :         kSquare_Cap,    //!&lt; begin/end contours with a half square extension
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :         kLast_Cap = kSquare_Cap,
<span class="lineNum">     394 </span>            :         kDefault_Cap = kButt_Cap
<span class="lineNum">     395 </span>            :     };
<span class="lineNum">     396 </span>            :     static constexpr int kCapCount = kLast_Cap + 1;
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :     /** Join enum specifies the settings for the paint's strokejoin. This is
<span class="lineNum">     399 </span>            :         the treatment that is applied to corners in paths and rectangles.
<span class="lineNum">     400 </span>            :     */
<span class="lineNum">     401 </span>            :     enum Join {
<span class="lineNum">     402 </span>            :         kMiter_Join,    //!&lt; connect path segments with a sharp join
<span class="lineNum">     403 </span>            :         kRound_Join,    //!&lt; connect path segments with a round join
<span class="lineNum">     404 </span>            :         kBevel_Join,    //!&lt; connect path segments with a flat bevel join
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :         kLast_Join = kBevel_Join,
<span class="lineNum">     407 </span>            :         kDefault_Join = kMiter_Join
<span class="lineNum">     408 </span>            :     };
<span class="lineNum">     409 </span>            :     static constexpr int kJoinCount = kLast_Join + 1;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :     /** Return the paint's stroke cap type, controlling how the start and end
<span class="lineNum">     412 </span>            :         of stroked lines and paths are treated.
<span class="lineNum">     413 </span>            :         @return the line cap style for the paint, used whenever the paint's
<a name="414"><span class="lineNum">     414 </span>            :                 style is Stroke or StrokeAndFill.</a>
<span class="lineNum">     415 </span>            :     */
<span class="lineNum">     416 </span><span class="lineCov">         28 :     Cap getStrokeCap() const { return (Cap)fBitfields.fCapType; }</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :     /** Set the paint's stroke cap type.
<span class="lineNum">     419 </span>            :         @param cap  set the paint's line cap style, used whenever the paint's
<span class="lineNum">     420 </span>            :                     style is Stroke or StrokeAndFill.
<span class="lineNum">     421 </span>            :     */
<span class="lineNum">     422 </span>            :     void setStrokeCap(Cap cap);
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :     /** Return the paint's stroke join type.
<span class="lineNum">     425 </span>            :         @return the paint's line join style, used whenever the paint's style is
<a name="426"><span class="lineNum">     426 </span>            :                 Stroke or StrokeAndFill.</a>
<span class="lineNum">     427 </span>            :     */
<span class="lineNum">     428 </span><span class="lineCov">         30 :     Join getStrokeJoin() const { return (Join)fBitfields.fJoinType; }</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     /** Set the paint's stroke join type.
<span class="lineNum">     431 </span>            :         @param join set the paint's line join style, used whenever the paint's
<span class="lineNum">     432 </span>            :                     style is Stroke or StrokeAndFill.
<span class="lineNum">     433 </span>            :     */
<span class="lineNum">     434 </span>            :     void setStrokeJoin(Join join);
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :     /**
<span class="lineNum">     437 </span>            :      *  Applies any/all effects (patheffect, stroking) to src, returning the
<span class="lineNum">     438 </span>            :      *  result in dst. The result is that drawing src with this paint will be
<span class="lineNum">     439 </span>            :      *  the same as drawing dst with a default paint (at least from the
<span class="lineNum">     440 </span>            :      *  geometric perspective).
<span class="lineNum">     441 </span>            :      *
<span class="lineNum">     442 </span>            :      *  @param src  input path
<span class="lineNum">     443 </span>            :      *  @param dst  output path (may be the same as src)
<span class="lineNum">     444 </span>            :      *  @param cullRect If not null, the dst path may be culled to this rect.
<span class="lineNum">     445 </span>            :      *  @param resScale If &gt; 1, increase precision, else if (0 &lt; res &lt; 1) reduce precision
<span class="lineNum">     446 </span>            :      *              in favor of speed/size.
<span class="lineNum">     447 </span>            :      *  @return     true if the path should be filled, or false if it should be
<span class="lineNum">     448 </span>            :      *              drawn with a hairline (width == 0)
<span class="lineNum">     449 </span>            :      */
<span class="lineNum">     450 </span>            :     bool getFillPath(const SkPath&amp; src, SkPath* dst, const SkRect* cullRect,
<a name="451"><span class="lineNum">     451 </span>            :                      SkScalar resScale = 1) const;</a>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     bool getFillPath(const SkPath&amp; src, SkPath* dst) const {</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         return this-&gt;getFillPath(src, dst, NULL, 1);</span>
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :     /** Get the paint's shader object.
<span class="lineNum">     458 </span>            :         &lt;p /&gt;
<span class="lineNum">     459 </span>            :       The shader's reference count is not affected.
<a name="460"><span class="lineNum">     460 </span>            :         @return the paint's shader (or NULL)</a>
<span class="lineNum">     461 </span>            :     */
<span class="lineNum">     462 </span><span class="lineCov">        828 :     SkShader* getShader() const { return fShader.get(); }</span>
<span class="lineNum">     463 </span>            :     sk_sp&lt;SkShader&gt; refShader() const;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :     /** Set or clear the shader object.
<span class="lineNum">     466 </span>            :      *  Shaders specify the source color(s) for what is being drawn. If a paint
<span class="lineNum">     467 </span>            :      *  has no shader, then the paint's color is used. If the paint has a
<span class="lineNum">     468 </span>            :      *  shader, then the shader's color(s) are use instead, but they are
<span class="lineNum">     469 </span>            :      *  modulated by the paint's alpha. This makes it easy to create a shader
<span class="lineNum">     470 </span>            :      *  once (e.g. bitmap tiling or gradient) and then change its transparency
<span class="lineNum">     471 </span>            :      *  w/o having to modify the original shader... only the paint's alpha needs
<span class="lineNum">     472 </span>            :      *  to be modified.
<span class="lineNum">     473 </span>            :      *
<span class="lineNum">     474 </span>            :      *  There is an exception to this only-respect-paint's-alpha rule: If the shader only generates
<span class="lineNum">     475 </span>            :      *  alpha (e.g. SkShader::CreateBitmapShader(bitmap, ...) where bitmap's colortype is kAlpha_8)
<span class="lineNum">     476 </span>            :      *  then the shader will use the paint's entire color to &quot;colorize&quot; its output (modulating the
<span class="lineNum">     477 </span>            :      *  bitmap's alpha with the paint's color+alpha).
<span class="lineNum">     478 </span>            :      *
<span class="lineNum">     479 </span>            :      *  Pass NULL to clear any previous shader.
<span class="lineNum">     480 </span>            :      *  As a convenience, the parameter passed is also returned.
<span class="lineNum">     481 </span>            :      *  If a previous shader exists, its reference count is decremented.
<span class="lineNum">     482 </span>            :      *  If shader is not NULL, its reference count is incremented.
<span class="lineNum">     483 </span>            :      *  @param shader   May be NULL. The shader to be installed in the paint
<span class="lineNum">     484 </span>            :      */
<span class="lineNum">     485 </span>            :     void setShader(sk_sp&lt;SkShader&gt;);
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :     /** Get the paint's colorfilter. If there is a colorfilter, its reference
<span class="lineNum">     488 </span>            :         count is not changed.
<a name="489"><span class="lineNum">     489 </span>            :         @return the paint's colorfilter (or NULL)</a>
<span class="lineNum">     490 </span>            :     */
<span class="lineNum">     491 </span><span class="lineCov">        946 :     SkColorFilter* getColorFilter() const { return fColorFilter.get(); }</span>
<span class="lineNum">     492 </span>            :     sk_sp&lt;SkColorFilter&gt; refColorFilter() const;
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :     /** Set or clear the paint's colorfilter.
<span class="lineNum">     495 </span>            :         &lt;p /&gt;
<span class="lineNum">     496 </span>            :         If the paint already has a filter, its reference count is decremented.
<span class="lineNum">     497 </span>            :         If filter is not NULL, its reference count is incremented.
<span class="lineNum">     498 </span>            :         @param filter   May be NULL. The filter to be installed in the paint
<span class="lineNum">     499 </span>            :     */
<a name="500"><span class="lineNum">     500 </span>            :     void setColorFilter(sk_sp&lt;SkColorFilter&gt;);</a>
<a name="501"><span class="lineNum">     501 </span>            : </a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">        948 :     SkBlendMode getBlendMode() const { return (SkBlendMode)fBlendMode; }</span></a>
<span class="lineNum">     503 </span><span class="lineCov">        122 :     bool isSrcOver() const { return (SkBlendMode)fBlendMode == SkBlendMode::kSrcOver; }</span>
<span class="lineNum">     504 </span><span class="lineCov">        441 :     void setBlendMode(SkBlendMode mode) { fBlendMode = (unsigned)mode; }</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     /** Get the paint's patheffect object.
<span class="lineNum">     507 </span>            :         &lt;p /&gt;
<span class="lineNum">     508 </span>            :       The patheffect reference count is not affected.
<a name="509"><span class="lineNum">     509 </span>            :         @return the paint's patheffect (or NULL)</a>
<span class="lineNum">     510 </span>            :     */
<span class="lineNum">     511 </span><span class="lineCov">        766 :     SkPathEffect* getPathEffect() const { return fPathEffect.get(); }</span>
<span class="lineNum">     512 </span>            :     sk_sp&lt;SkPathEffect&gt; refPathEffect() const;
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     /** Set or clear the patheffect object.
<span class="lineNum">     515 </span>            :         &lt;p /&gt;
<span class="lineNum">     516 </span>            :         Pass NULL to clear any previous patheffect.
<span class="lineNum">     517 </span>            :         As a convenience, the parameter passed is also returned.
<span class="lineNum">     518 </span>            :         If a previous patheffect exists, its reference count is decremented.
<span class="lineNum">     519 </span>            :         If patheffect is not NULL, its reference count is incremented.
<span class="lineNum">     520 </span>            :         @param effect   May be NULL. The new patheffect to be installed in the
<span class="lineNum">     521 </span>            :                         paint
<span class="lineNum">     522 </span>            :         @return         effect
<span class="lineNum">     523 </span>            :     */
<span class="lineNum">     524 </span>            :     void setPathEffect(sk_sp&lt;SkPathEffect&gt;);
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :     /** Get the paint's maskfilter object.
<span class="lineNum">     527 </span>            :         &lt;p /&gt;
<span class="lineNum">     528 </span>            :       The maskfilter reference count is not affected.
<a name="529"><span class="lineNum">     529 </span>            :         @return the paint's maskfilter (or NULL)</a>
<span class="lineNum">     530 </span>            :     */
<span class="lineNum">     531 </span><span class="lineCov">       1471 :     SkMaskFilter* getMaskFilter() const { return fMaskFilter.get(); }</span>
<span class="lineNum">     532 </span>            :     sk_sp&lt;SkMaskFilter&gt; refMaskFilter() const;
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :     /** Set or clear the maskfilter object.
<span class="lineNum">     535 </span>            :         &lt;p /&gt;
<span class="lineNum">     536 </span>            :         Pass NULL to clear any previous maskfilter.
<span class="lineNum">     537 </span>            :         As a convenience, the parameter passed is also returned.
<span class="lineNum">     538 </span>            :         If a previous maskfilter exists, its reference count is decremented.
<span class="lineNum">     539 </span>            :         If maskfilter is not NULL, its reference count is incremented.
<span class="lineNum">     540 </span>            :         @param maskfilter   May be NULL. The new maskfilter to be installed in
<span class="lineNum">     541 </span>            :                             the paint
<span class="lineNum">     542 </span>            :         @return             maskfilter
<span class="lineNum">     543 </span>            :     */
<span class="lineNum">     544 </span>            :     void setMaskFilter(sk_sp&lt;SkMaskFilter&gt;);
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :     // These attributes are for text/fonts
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :     /** Get the paint's typeface object.
<span class="lineNum">     549 </span>            :         &lt;p /&gt;
<span class="lineNum">     550 </span>            :         The typeface object identifies which font to use when drawing or
<span class="lineNum">     551 </span>            :         measuring text. The typeface reference count is not affected.
<a name="552"><span class="lineNum">     552 </span>            :         @return the paint's typeface (or NULL)</a>
<span class="lineNum">     553 </span>            :     */
<span class="lineNum">     554 </span><span class="lineCov">         63 :     SkTypeface* getTypeface() const { return fTypeface.get(); }</span>
<span class="lineNum">     555 </span>            :     sk_sp&lt;SkTypeface&gt; refTypeface() const;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :     /** Set or clear the typeface object.
<span class="lineNum">     558 </span>            :         &lt;p /&gt;
<span class="lineNum">     559 </span>            :         Pass NULL to clear any previous typeface.
<span class="lineNum">     560 </span>            :         As a convenience, the parameter passed is also returned.
<span class="lineNum">     561 </span>            :         If a previous typeface exists, its reference count is decremented.
<span class="lineNum">     562 </span>            :         If typeface is not NULL, its reference count is incremented.
<span class="lineNum">     563 </span>            :         @param typeface May be NULL. The new typeface to be installed in the
<span class="lineNum">     564 </span>            :                         paint
<span class="lineNum">     565 </span>            :         @return         typeface
<span class="lineNum">     566 </span>            :     */
<span class="lineNum">     567 </span>            :     void setTypeface(sk_sp&lt;SkTypeface&gt;);
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     /** Get the paint's rasterizer (or NULL).
<span class="lineNum">     570 </span>            :         &lt;p /&gt;
<span class="lineNum">     571 </span>            :         The raster controls how paths/text are turned into alpha masks.
<a name="572"><span class="lineNum">     572 </span>            :         @return the paint's rasterizer (or NULL)</a>
<span class="lineNum">     573 </span>            :     */
<span class="lineNum">     574 </span><span class="lineCov">        740 :     SkRasterizer* getRasterizer() const { return fRasterizer.get(); }</span>
<span class="lineNum">     575 </span>            :     sk_sp&lt;SkRasterizer&gt; refRasterizer() const;
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :     /** Set or clear the rasterizer object.
<span class="lineNum">     578 </span>            :         &lt;p /&gt;
<span class="lineNum">     579 </span>            :         Pass NULL to clear any previous rasterizer.
<span class="lineNum">     580 </span>            :         As a convenience, the parameter passed is also returned.
<span class="lineNum">     581 </span>            :         If a previous rasterizer exists in the paint, its reference count is
<span class="lineNum">     582 </span>            :         decremented. If rasterizer is not NULL, its reference count is
<span class="lineNum">     583 </span>            :         incremented.
<span class="lineNum">     584 </span>            :         @param rasterizer May be NULL. The new rasterizer to be installed in
<span class="lineNum">     585 </span>            :                           the paint.
<span class="lineNum">     586 </span>            :         @return           rasterizer
<span class="lineNum">     587 </span>            :     */
<a name="588"><span class="lineNum">     588 </span>            :     void setRasterizer(sk_sp&lt;SkRasterizer&gt;);</a>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineCov">       1766 :     SkImageFilter* getImageFilter() const { return fImageFilter.get(); }</span>
<span class="lineNum">     591 </span>            :     sk_sp&lt;SkImageFilter&gt; refImageFilter() const;
<span class="lineNum">     592 </span>            :     void setImageFilter(sk_sp&lt;SkImageFilter&gt;);
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :     /**
<span class="lineNum">     595 </span>            :      *  Return the paint's SkDrawLooper (if any). Does not affect the looper's
<a name="596"><span class="lineNum">     596 </span>            :      *  reference count.</a>
<span class="lineNum">     597 </span>            :      */
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     SkDrawLooper* getDrawLooper() const { return fDrawLooper.get(); }</span>
<a name="599"><span class="lineNum">     599 </span>            :     sk_sp&lt;SkDrawLooper&gt; refDrawLooper() const;</a>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">       1264 :     SkDrawLooper* getLooper() const { return fDrawLooper.get(); }</span>
<span class="lineNum">     602 </span>            :     /**
<span class="lineNum">     603 </span>            :      *  Set or clear the looper object.
<span class="lineNum">     604 </span>            :      *  &lt;p /&gt;
<span class="lineNum">     605 </span>            :      *  Pass NULL to clear any previous looper.
<span class="lineNum">     606 </span>            :      *  If a previous looper exists in the paint, its reference count is
<span class="lineNum">     607 </span>            :      *  decremented. If looper is not NULL, its reference count is
<span class="lineNum">     608 </span>            :      *  incremented.
<span class="lineNum">     609 </span>            :      *  @param looper May be NULL. The new looper to be installed in the paint.
<span class="lineNum">     610 </span>            :      */
<span class="lineNum">     611 </span>            :     void setDrawLooper(sk_sp&lt;SkDrawLooper&gt;);
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     void setLooper(sk_sp&lt;SkDrawLooper&gt;);
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :     enum Align {
<span class="lineNum">     616 </span>            :         kLeft_Align,
<span class="lineNum">     617 </span>            :         kCenter_Align,
<span class="lineNum">     618 </span>            :         kRight_Align,
<span class="lineNum">     619 </span>            :     };
<span class="lineNum">     620 </span>            :     enum {
<span class="lineNum">     621 </span>            :         kAlignCount = 3
<span class="lineNum">     622 </span>            :     };
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :     /** Return the paint's Align value for drawing text.
<a name="625"><span class="lineNum">     625 </span>            :         @return the paint's Align value for drawing text.</a>
<span class="lineNum">     626 </span>            :     */
<span class="lineNum">     627 </span><span class="lineCov">         21 :     Align   getTextAlign() const { return (Align)fBitfields.fTextAlign; }</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     /** Set the paint's text alignment.
<span class="lineNum">     630 </span>            :         @param align set the paint's Align value for drawing text.
<span class="lineNum">     631 </span>            :     */
<span class="lineNum">     632 </span>            :     void    setTextAlign(Align align);
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :     /** Return the paint's text size.
<a name="635"><span class="lineNum">     635 </span>            :         @return the paint's text size.</a>
<span class="lineNum">     636 </span>            :     */
<span class="lineNum">     637 </span><span class="lineCov">         21 :     SkScalar getTextSize() const { return fTextSize; }</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :     /** Set the paint's text size. This value must be &gt; 0
<span class="lineNum">     640 </span>            :         @param textSize set the paint's text size.
<span class="lineNum">     641 </span>            :     */
<span class="lineNum">     642 </span>            :     void setTextSize(SkScalar textSize);
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :     /** Return the paint's horizontal scale factor for text. The default value
<span class="lineNum">     645 </span>            :         is 1.0.
<a name="646"><span class="lineNum">     646 </span>            :         @return the paint's scale factor in X for drawing/measuring text</a>
<span class="lineNum">     647 </span>            :     */
<span class="lineNum">     648 </span><span class="lineCov">         21 :     SkScalar getTextScaleX() const { return fTextScaleX; }</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :     /** Set the paint's horizontal scale factor for text. The default value
<span class="lineNum">     651 </span>            :         is 1.0. Values &gt; 1.0 will stretch the text wider. Values &lt; 1.0 will
<span class="lineNum">     652 </span>            :         stretch the text narrower.
<span class="lineNum">     653 </span>            :         @param scaleX   set the paint's scale factor in X for drawing/measuring
<span class="lineNum">     654 </span>            :                         text.
<span class="lineNum">     655 </span>            :     */
<span class="lineNum">     656 </span>            :     void setTextScaleX(SkScalar scaleX);
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            :     /** Return the paint's horizontal skew factor for text. The default value
<span class="lineNum">     659 </span>            :         is 0.
<a name="660"><span class="lineNum">     660 </span>            :         @return the paint's skew factor in X for drawing text.</a>
<span class="lineNum">     661 </span>            :     */
<span class="lineNum">     662 </span><span class="lineCov">         21 :     SkScalar getTextSkewX() const { return fTextSkewX; }</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     /** Set the paint's horizontal skew factor for text. The default value
<span class="lineNum">     665 </span>            :         is 0. For approximating oblique text, use values around -0.25.
<span class="lineNum">     666 </span>            :         @param skewX set the paint's skew factor in X for drawing text.
<span class="lineNum">     667 </span>            :     */
<span class="lineNum">     668 </span>            :     void setTextSkewX(SkScalar skewX);
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :     /** Describes how to interpret the text parameters that are passed to paint
<span class="lineNum">     671 </span>            :         methods like measureText() and getTextWidths().
<span class="lineNum">     672 </span>            :     */
<span class="lineNum">     673 </span>            :     enum TextEncoding {
<span class="lineNum">     674 </span>            :         kUTF8_TextEncoding,     //!&lt; the text parameters are UTF8
<span class="lineNum">     675 </span>            :         kUTF16_TextEncoding,    //!&lt; the text parameters are UTF16
<span class="lineNum">     676 </span>            :         kUTF32_TextEncoding,    //!&lt; the text parameters are UTF32
<span class="lineNum">     677 </span>            :         kGlyphID_TextEncoding   //!&lt; the text parameters are glyph indices
<a name="678"><span class="lineNum">     678 </span>            :     };</a>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineCov">         21 :     TextEncoding getTextEncoding() const {</span>
<span class="lineNum">     681 </span><span class="lineCov">         21 :       return (TextEncoding)fBitfields.fTextEncoding;</span>
<span class="lineNum">     682 </span>            :     }
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :     void setTextEncoding(TextEncoding encoding);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :     struct FontMetrics {
<span class="lineNum">     687 </span>            :         /** Flags which indicate the confidence level of various metrics.
<span class="lineNum">     688 </span>            :             A set flag indicates that the metric may be trusted.
<span class="lineNum">     689 </span>            :         */
<span class="lineNum">     690 </span>            :         enum FontMetricsFlags {
<span class="lineNum">     691 </span>            :             kUnderlineThicknessIsValid_Flag = 1 &lt;&lt; 0,
<span class="lineNum">     692 </span>            :             kUnderlinePositionIsValid_Flag = 1 &lt;&lt; 1,
<span class="lineNum">     693 </span>            :         };
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :         uint32_t    fFlags;       //!&lt; Bit field to identify which values are unknown
<span class="lineNum">     696 </span>            :         SkScalar    fTop;       //!&lt; The greatest distance above the baseline for any glyph (will be &lt;= 0)
<span class="lineNum">     697 </span>            :         SkScalar    fAscent;    //!&lt; The recommended distance above the baseline (will be &lt;= 0)
<span class="lineNum">     698 </span>            :         SkScalar    fDescent;   //!&lt; The recommended distance below the baseline (will be &gt;= 0)
<span class="lineNum">     699 </span>            :         SkScalar    fBottom;    //!&lt; The greatest distance below the baseline for any glyph (will be &gt;= 0)
<span class="lineNum">     700 </span>            :         SkScalar    fLeading;   //!&lt; The recommended distance to add between lines of text (will be &gt;= 0)
<span class="lineNum">     701 </span>            :         SkScalar    fAvgCharWidth;  //!&lt; the average character width (&gt;= 0)
<span class="lineNum">     702 </span>            :         SkScalar    fMaxCharWidth;  //!&lt; the max character width (&gt;= 0)
<span class="lineNum">     703 </span>            :         SkScalar    fXMin;      //!&lt; The minimum bounding box x value for all glyphs
<span class="lineNum">     704 </span>            :         SkScalar    fXMax;      //!&lt; The maximum bounding box x value for all glyphs
<span class="lineNum">     705 </span>            :         SkScalar    fXHeight;   //!&lt; The height of an 'x' in px, or 0 if no 'x' in face
<span class="lineNum">     706 </span>            :         SkScalar    fCapHeight;  //!&lt; The cap height (&gt; 0), or 0 if cannot be determined.
<span class="lineNum">     707 </span>            :         SkScalar    fUnderlineThickness; //!&lt; underline thickness, or 0 if cannot be determined
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :         /**  Underline Position - position of the top of the Underline stroke
<span class="lineNum">     710 </span>            :                 relative to the baseline, this can have following values
<span class="lineNum">     711 </span>            :                 - Negative - means underline should be drawn above baseline.
<span class="lineNum">     712 </span>            :                 - Positive - means below baseline.
<span class="lineNum">     713 </span>            :                 - Zero     - mean underline should be drawn on baseline.
<span class="lineNum">     714 </span>            :          */
<span class="lineNum">     715 </span>            :         SkScalar    fUnderlinePosition; //!&lt; underline position, or 0 if cannot be determined
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :         /**  If the fontmetrics has a valid underline thickness, return true, and set the
<span class="lineNum">     718 </span>            :                 thickness param to that value. If it doesn't return false and ignore the
<span class="lineNum">     719 </span>            :                 thickness param.
<span class="lineNum">     720 </span>            :         */
<span class="lineNum">     721 </span>            :         bool hasUnderlineThickness(SkScalar* thickness) const {
<span class="lineNum">     722 </span>            :             if (SkToBool(fFlags &amp; kUnderlineThicknessIsValid_Flag)) {
<span class="lineNum">     723 </span>            :                 *thickness = fUnderlineThickness;
<span class="lineNum">     724 </span>            :                 return true;
<span class="lineNum">     725 </span>            :             }
<span class="lineNum">     726 </span>            :             return false;
<span class="lineNum">     727 </span>            :         }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :         /**  If the fontmetrics has a valid underline position, return true, and set the
<span class="lineNum">     730 </span>            :                 position param to that value. If it doesn't return false and ignore the
<span class="lineNum">     731 </span>            :                 position param.
<span class="lineNum">     732 </span>            :         */
<span class="lineNum">     733 </span>            :         bool hasUnderlinePosition(SkScalar* position) const {
<span class="lineNum">     734 </span>            :             if (SkToBool(fFlags &amp; kUnderlinePositionIsValid_Flag)) {
<span class="lineNum">     735 </span>            :                 *position = fUnderlinePosition;
<span class="lineNum">     736 </span>            :                 return true;
<span class="lineNum">     737 </span>            :             }
<span class="lineNum">     738 </span>            :             return false;
<span class="lineNum">     739 </span>            :         }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :     };
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :     /** Return the recommend spacing between lines (which will be
<span class="lineNum">     744 </span>            :         fDescent - fAscent + fLeading).
<span class="lineNum">     745 </span>            :         If metrics is not null, return in it the font metrics for the
<span class="lineNum">     746 </span>            :         typeface/pointsize/etc. currently set in the paint.
<span class="lineNum">     747 </span>            :         @param metrics      If not null, returns the font metrics for the
<span class="lineNum">     748 </span>            :                             current typeface/pointsize/etc setting in this
<span class="lineNum">     749 </span>            :                             paint.
<span class="lineNum">     750 </span>            :         @param scale        If not 0, return width as if the canvas were scaled
<span class="lineNum">     751 </span>            :                             by this value
<span class="lineNum">     752 </span>            :         @param return the recommended spacing between lines
<span class="lineNum">     753 </span>            :     */
<span class="lineNum">     754 </span>            :     SkScalar getFontMetrics(FontMetrics* metrics, SkScalar scale = 0) const;
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :     /** Return the recommend line spacing. This will be
<span class="lineNum">     757 </span>            :         fDescent - fAscent + fLeading
<span class="lineNum">     758 </span>            :     */
<span class="lineNum">     759 </span>            :     SkScalar getFontSpacing() const { return this-&gt;getFontMetrics(NULL, 0); }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :     /** Convert the specified text into glyph IDs, returning the number of
<span class="lineNum">     762 </span>            :         glyphs ID written. If glyphs is NULL, it is ignore and only the count
<span class="lineNum">     763 </span>            :         is returned.
<span class="lineNum">     764 </span>            :     */
<span class="lineNum">     765 </span>            :     int textToGlyphs(const void* text, size_t byteLength,
<span class="lineNum">     766 </span>            :                      SkGlyphID glyphs[]) const;
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :     /** Return true if all of the specified text has a corresponding non-zero
<span class="lineNum">     769 </span>            :         glyph ID. If any of the code-points in the text are not supported in
<span class="lineNum">     770 </span>            :         the typeface (i.e. the glyph ID would be zero), then return false.
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :         If the text encoding for the paint is kGlyph_TextEncoding, then this
<span class="lineNum">     773 </span>            :         returns true if all of the specified glyph IDs are non-zero.
<span class="lineNum">     774 </span>            :      */
<span class="lineNum">     775 </span>            :     bool containsText(const void* text, size_t byteLength) const;
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :     /** Convert the glyph array into Unichars. Unconvertable glyphs are mapped
<span class="lineNum">     778 </span>            :         to zero. Note: this does not look at the text-encoding setting in the
<span class="lineNum">     779 </span>            :         paint, only at the typeface.
<span class="lineNum">     780 </span>            :     */
<span class="lineNum">     781 </span>            :     void glyphsToUnichars(const SkGlyphID glyphs[], int count, SkUnichar text[]) const;
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :     /** Return the number of drawable units in the specified text buffer.
<span class="lineNum">     784 </span>            :         This looks at the current TextEncoding field of the paint. If you also
<span class="lineNum">     785 </span>            :         want to have the text converted into glyph IDs, call textToGlyphs
<a name="786"><span class="lineNum">     786 </span>            :         instead.</a>
<span class="lineNum">     787 </span>            :     */
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     int countText(const void* text, size_t byteLength) const {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         return this-&gt;textToGlyphs(text, byteLength, NULL);</span>
<span class="lineNum">     790 </span>            :     }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :     /** Return the width of the text. This will return the vertical measure
<span class="lineNum">     793 </span>            :      *  if isVerticalText() is true, in which case the returned value should
<span class="lineNum">     794 </span>            :      *  be treated has a height instead of a width.
<span class="lineNum">     795 </span>            :      *
<span class="lineNum">     796 </span>            :      *  @param text         The text to be measured
<span class="lineNum">     797 </span>            :      *  @param length       Number of bytes of text to measure
<span class="lineNum">     798 </span>            :      *  @param bounds       If not NULL, returns the bounds of the text,
<span class="lineNum">     799 </span>            :      *                      relative to (0, 0).
<span class="lineNum">     800 </span>            :      *  @return             The advance width of the text
<span class="lineNum">     801 </span>            :      */
<span class="lineNum">     802 </span>            :     SkScalar measureText(const void* text, size_t length, SkRect* bounds) const;
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :     /** Return the width of the text. This will return the vertical measure
<span class="lineNum">     805 </span>            :      *  if isVerticalText() is true, in which case the returned value should
<span class="lineNum">     806 </span>            :      *  be treated has a height instead of a width.
<span class="lineNum">     807 </span>            :      *
<span class="lineNum">     808 </span>            :      *  @param text     Address of the text
<span class="lineNum">     809 </span>            :      *  @param length   Number of bytes of text to measure
<span class="lineNum">     810 </span>            :      *  @return         The advance width of the text
<span class="lineNum">     811 </span>            :      */
<span class="lineNum">     812 </span>            :     SkScalar measureText(const void* text, size_t length) const {
<span class="lineNum">     813 </span>            :         return this-&gt;measureText(text, length, NULL);
<span class="lineNum">     814 </span>            :     }
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :     /** Return the number of bytes of text that were measured. If
<span class="lineNum">     817 </span>            :      *  isVerticalText() is true, then the vertical advances are used for
<span class="lineNum">     818 </span>            :      *  the measurement.
<span class="lineNum">     819 </span>            :      *
<span class="lineNum">     820 </span>            :      *  @param text     The text to be measured
<span class="lineNum">     821 </span>            :      *  @param length   Number of bytes of text to measure
<span class="lineNum">     822 </span>            :      *  @param maxWidth Maximum width. Only the subset of text whose accumulated
<span class="lineNum">     823 </span>            :      *                  widths are &lt;= maxWidth are measured.
<span class="lineNum">     824 </span>            :      *  @param measuredWidth Optional. If non-null, this returns the actual
<span class="lineNum">     825 </span>            :      *                  width of the measured text.
<span class="lineNum">     826 </span>            :      *  @return         The number of bytes of text that were measured. Will be
<span class="lineNum">     827 </span>            :      *                  &lt;= length.
<span class="lineNum">     828 </span>            :      */
<span class="lineNum">     829 </span>            :     size_t  breakText(const void* text, size_t length, SkScalar maxWidth,
<span class="lineNum">     830 </span>            :                       SkScalar* measuredWidth = NULL) const;
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     /** Return the advances for the text. These will be vertical advances if
<span class="lineNum">     833 </span>            :      *  isVerticalText() returns true.
<span class="lineNum">     834 </span>            :      *
<span class="lineNum">     835 </span>            :      *  @param text         the text
<span class="lineNum">     836 </span>            :      *  @param byteLength   number of bytes to of text
<span class="lineNum">     837 </span>            :      *  @param widths       If not null, returns the array of advances for
<span class="lineNum">     838 </span>            :      *                      the glyphs. If not NULL, must be at least a large
<span class="lineNum">     839 </span>            :      *                      as the number of unichars in the specified text.
<span class="lineNum">     840 </span>            :      *  @param bounds       If not null, returns the bounds for each of
<span class="lineNum">     841 </span>            :      *                      character, relative to (0, 0)
<span class="lineNum">     842 </span>            :      *  @return the number of unichars in the specified text.
<span class="lineNum">     843 </span>            :      */
<span class="lineNum">     844 </span>            :     int getTextWidths(const void* text, size_t byteLength, SkScalar widths[],
<span class="lineNum">     845 </span>            :                       SkRect bounds[] = NULL) const;
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     /** Return the path (outline) for the specified text.
<span class="lineNum">     848 </span>            :      *  Note: just like SkCanvas::drawText, this will respect the Align setting
<span class="lineNum">     849 </span>            :      *        in the paint.
<span class="lineNum">     850 </span>            :      *
<span class="lineNum">     851 </span>            :      *  @param text         the text
<span class="lineNum">     852 </span>            :      *  @param length       number of bytes of text
<span class="lineNum">     853 </span>            :      *  @param x            The x-coordinate of the origin of the text.
<span class="lineNum">     854 </span>            :      *  @param y            The y-coordinate of the origin of the text.
<span class="lineNum">     855 </span>            :      *  @param path         The outline of the text.
<span class="lineNum">     856 </span>            :      */
<span class="lineNum">     857 </span>            :     void getTextPath(const void* text, size_t length, SkScalar x, SkScalar y,
<span class="lineNum">     858 </span>            :                      SkPath* path) const;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :     /** Return the path (outline) for the specified text.
<span class="lineNum">     861 </span>            :      *  Note: just like SkCanvas::drawText, this will respect the Align setting
<span class="lineNum">     862 </span>            :      *        in the paint.
<span class="lineNum">     863 </span>            :      *
<span class="lineNum">     864 </span>            :      *  @param text         the text
<span class="lineNum">     865 </span>            :      *  @param length       number of bytes of text
<span class="lineNum">     866 </span>            :      *  @param pos          array of positions, used to position each character
<span class="lineNum">     867 </span>            :      *  @param path         The outline of the text.
<span class="lineNum">     868 </span>            :      */
<span class="lineNum">     869 </span>            :     void getPosTextPath(const void* text, size_t length,
<span class="lineNum">     870 </span>            :                         const SkPoint pos[], SkPath* path) const;
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :     /** Return the number of intervals that intersect the intercept along the axis of the advance.
<span class="lineNum">     873 </span>            :      *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
<span class="lineNum">     874 </span>            :      *  the string. The caller may pass nullptr for intervals to determine the size of the interval
<span class="lineNum">     875 </span>            :      *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
<span class="lineNum">     876 </span>            :      *  intervals are cached by glyph to improve performance for multiple calls.
<span class="lineNum">     877 </span>            :      *  This permits constructing an underline that skips the descenders. 
<span class="lineNum">     878 </span>            :      *
<span class="lineNum">     879 </span>            :      *  @param text         the text
<span class="lineNum">     880 </span>            :      *  @param length       number of bytes of text
<span class="lineNum">     881 </span>            :      *  @param x            The x-coordinate of the origin of the text.
<span class="lineNum">     882 </span>            :      *  @param y            The y-coordinate of the origin of the text.
<span class="lineNum">     883 </span>            :      *  @param bounds       The lower and upper line parallel to the advance.
<span class="lineNum">     884 </span>            :      *  @param array        If not null, the found intersections.
<span class="lineNum">     885 </span>            :      *
<span class="lineNum">     886 </span>            :      *  @return             The number of intersections, which may be zero.
<span class="lineNum">     887 </span>            :      */
<span class="lineNum">     888 </span>            :     int getTextIntercepts(const void* text, size_t length, SkScalar x, SkScalar y,
<span class="lineNum">     889 </span>            :                           const SkScalar bounds[2], SkScalar* intervals) const;
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :     /** Return the number of intervals that intersect the intercept along the axis of the advance.
<span class="lineNum">     892 </span>            :      *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
<span class="lineNum">     893 </span>            :      *  string. The caller may pass nullptr for intervals to determine the size of the interval
<span class="lineNum">     894 </span>            :      *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
<span class="lineNum">     895 </span>            :      *  intervals are cached by glyph to improve performance for multiple calls.
<span class="lineNum">     896 </span>            :      *  This permits constructing an underline that skips the descenders. 
<span class="lineNum">     897 </span>            :      *
<span class="lineNum">     898 </span>            :      *  @param text         the text
<span class="lineNum">     899 </span>            :      *  @param length       number of bytes of text
<span class="lineNum">     900 </span>            :      *  @param pos          array of positions, used to position each character
<span class="lineNum">     901 </span>            :      *  @param bounds       The lower and upper line parallel to the advance.
<span class="lineNum">     902 </span>            :      *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
<span class="lineNum">     903 </span>            :      *
<span class="lineNum">     904 </span>            :      *  @return             The number of intersections, which may be zero.
<span class="lineNum">     905 </span>            :      */
<span class="lineNum">     906 </span>            :     int getPosTextIntercepts(const void* text, size_t length, const SkPoint pos[],
<span class="lineNum">     907 </span>            :                              const SkScalar bounds[2], SkScalar* intervals) const;
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :     /** Return the number of intervals that intersect the intercept along the axis of the advance.
<span class="lineNum">     910 </span>            :      *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
<span class="lineNum">     911 </span>            :      *  string. The caller may pass nullptr for intervals to determine the size of the interval
<span class="lineNum">     912 </span>            :      *  array, or may conservatively pre-allocate an array with length * 2 entries. The computed
<span class="lineNum">     913 </span>            :      *  intervals are cached by glyph to improve performance for multiple calls.
<span class="lineNum">     914 </span>            :      *  This permits constructing an underline that skips the descenders.
<span class="lineNum">     915 </span>            :      *
<span class="lineNum">     916 </span>            :      *  @param text         The text.
<span class="lineNum">     917 </span>            :      *  @param length       Number of bytes of text.
<span class="lineNum">     918 </span>            :      *  @param xpos         Array of x-positions, used to position each character.
<span class="lineNum">     919 </span>            :      *  @param constY       The shared Y coordinate for all of the positions.
<span class="lineNum">     920 </span>            :      *  @param bounds       The lower and upper line parallel to the advance.
<span class="lineNum">     921 </span>            :      *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
<span class="lineNum">     922 </span>            :      *
<span class="lineNum">     923 </span>            :      *  @return             The number of intersections, which may be zero.
<span class="lineNum">     924 </span>            :      */
<span class="lineNum">     925 </span>            :     int getPosTextHIntercepts(const void* text, size_t length, const SkScalar xpos[],
<span class="lineNum">     926 </span>            :                               SkScalar constY, const SkScalar bounds[2], SkScalar* intervals) const;
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :     /** Return the number of intervals that intersect the intercept along the axis of the advance.
<span class="lineNum">     929 </span>            :      *  The return count is zero or a multiple of two, and is at most the number of glyphs * 2 in
<span class="lineNum">     930 </span>            :      *  text blob. The caller may pass nullptr for intervals to determine the size of the interval
<span class="lineNum">     931 </span>            :      *  array. The computed intervals are cached by glyph to improve performance for multiple calls.
<span class="lineNum">     932 </span>            :      *  This permits constructing an underline that skips the descenders.
<span class="lineNum">     933 </span>            :      *
<span class="lineNum">     934 </span>            :      *  @param blob         The text blob.
<span class="lineNum">     935 </span>            :      *  @param bounds       The lower and upper line parallel to the advance.
<span class="lineNum">     936 </span>            :      *  @param array        If not null, the glyph bounds contained by the advance parallel lines.
<span class="lineNum">     937 </span>            :      *
<span class="lineNum">     938 </span>            :      *  @return             The number of intersections, which may be zero.
<span class="lineNum">     939 </span>            :      */
<span class="lineNum">     940 </span>            :     int getTextBlobIntercepts(const SkTextBlob* blob, const SkScalar bounds[2],
<span class="lineNum">     941 </span>            :                               SkScalar* intervals) const;
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            :     /**
<span class="lineNum">     944 </span>            :      *  Return a rectangle that represents the union of the bounds of all
<span class="lineNum">     945 </span>            :      *  of the glyphs, but each one positioned at (0,0). This may be conservatively large, and
<span class="lineNum">     946 </span>            :      *  will not take into account any hinting, but will respect any text-scale-x or text-skew-x
<span class="lineNum">     947 </span>            :      *  on this paint.
<span class="lineNum">     948 </span>            :      */
<span class="lineNum">     949 </span>            :     SkRect getFontBounds() const;
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :     // returns true if the paint's settings (e.g. xfermode + alpha) resolve to
<span class="lineNum">     952 </span>            :     // mean that we need not draw at all (e.g. SrcOver + 0-alpha)
<span class="lineNum">     953 </span>            :     bool nothingToDraw() const;
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :     ///////////////////////////////////////////////////////////////////////////
<span class="lineNum">     956 </span>            :     // would prefer to make these private...
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :     /** Returns true if the current paint settings allow for fast computation of
<span class="lineNum">     959 </span>            :      bounds (i.e. there is nothing complex like a patheffect that would make
<span class="lineNum">     960 </span>            :      the bounds computation expensive.
<span class="lineNum">     961 </span>            :      */
<span class="lineNum">     962 </span>            :     bool canComputeFastBounds() const;
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :     /** Only call this if canComputeFastBounds() returned true. This takes a
<span class="lineNum">     965 </span>            :      raw rectangle (the raw bounds of a shape), and adjusts it for stylistic
<span class="lineNum">     966 </span>            :      effects in the paint (e.g. stroking). If needed, it uses the storage
<span class="lineNum">     967 </span>            :      rect parameter. It returns the adjusted bounds that can then be used
<span class="lineNum">     968 </span>            :      for quickReject tests.
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :      The returned rect will either be orig or storage, thus the caller
<span class="lineNum">     971 </span>            :      should not rely on storage being set to the result, but should always
<span class="lineNum">     972 </span>            :      use the retured value. It is legal for orig and storage to be the same
<span class="lineNum">     973 </span>            :      rect.
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            :      e.g.
<span class="lineNum">     976 </span>            :      if (paint.canComputeFastBounds()) {
<span class="lineNum">     977 </span>            :      SkRect r, storage;
<span class="lineNum">     978 </span>            :      path.computeBounds(&amp;r, SkPath::kFast_BoundsType);
<span class="lineNum">     979 </span>            :      const SkRect&amp; fastR = paint.computeFastBounds(r, &amp;storage);
<span class="lineNum">     980 </span>            :      if (canvas-&gt;quickReject(fastR, ...)) {
<span class="lineNum">     981 </span>            :      // don't draw the path
<span class="lineNum">     982 </span>            :      }
<a name="983"><span class="lineNum">     983 </span>            :      }</a>
<span class="lineNum">     984 </span>            :      */
<span class="lineNum">     985 </span><span class="lineCov">        393 :     const SkRect&amp; computeFastBounds(const SkRect&amp; orig, SkRect* storage) const {</span>
<span class="lineNum">     986 </span><span class="lineCov">        393 :         SkPaint::Style style = this-&gt;getStyle();</span>
<span class="lineNum">     987 </span>            :         // ultra fast-case: filling with no effects that affect geometry
<span class="lineNum">     988 </span><span class="lineCov">        393 :         if (kFill_Style == style) {</span>
<span class="lineNum">     989 </span><span class="lineCov">        391 :             uintptr_t effects = reinterpret_cast&lt;uintptr_t&gt;(this-&gt;getLooper());</span>
<span class="lineNum">     990 </span><span class="lineCov">        391 :             effects |= reinterpret_cast&lt;uintptr_t&gt;(this-&gt;getMaskFilter());</span>
<span class="lineNum">     991 </span><span class="lineCov">        391 :             effects |= reinterpret_cast&lt;uintptr_t&gt;(this-&gt;getPathEffect());</span>
<span class="lineNum">     992 </span><span class="lineCov">        391 :             effects |= reinterpret_cast&lt;uintptr_t&gt;(this-&gt;getImageFilter());</span>
<span class="lineNum">     993 </span><span class="lineCov">        391 :             if (!effects) {</span>
<span class="lineNum">     994 </span><span class="lineCov">        391 :                 return orig;</span>
<span class="lineNum">     995 </span>            :             }
<span class="lineNum">     996 </span>            :         }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineCov">          2 :         return this-&gt;doComputeFastBounds(orig, storage, style);</span>
<a name="999"><span class="lineNum">     999 </span>            :     }</a>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineCov">         13 :     const SkRect&amp; computeFastStrokeBounds(const SkRect&amp; orig,</span>
<span class="lineNum">    1002 </span>            :                                           SkRect* storage) const {
<span class="lineNum">    1003 </span><span class="lineCov">         13 :         return this-&gt;doComputeFastBounds(orig, storage, kStroke_Style);</span>
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :     // Take the style explicitly, so the caller can force us to be stroked
<span class="lineNum">    1007 </span>            :     // without having to make a copy of the paint just to change that field.
<span class="lineNum">    1008 </span>            :     const SkRect&amp; doComputeFastBounds(const SkRect&amp; orig, SkRect* storage,
<span class="lineNum">    1009 </span>            :                                       Style) const;
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :     /**
<a name="1012"><span class="lineNum">    1012 </span>            :      *  Return a matrix that applies the paint's text values: size, scale, skew</a>
<span class="lineNum">    1013 </span>            :      */
<span class="lineNum">    1014 </span><span class="lineCov">         23 :     static SkMatrix* SetTextMatrix(SkMatrix* matrix, SkScalar size,</span>
<span class="lineNum">    1015 </span>            :                                    SkScalar scaleX, SkScalar skewX) {
<span class="lineNum">    1016 </span><span class="lineCov">         23 :         matrix-&gt;setScale(size * scaleX, size);</span>
<span class="lineNum">    1017 </span><span class="lineCov">         23 :         if (skewX) {</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :             matrix-&gt;postSkew(skewX, 0);</span>
<span class="lineNum">    1019 </span>            :         }
<span class="lineNum">    1020 </span><span class="lineCov">         23 :         return matrix;</span>
<a name="1021"><span class="lineNum">    1021 </span>            :     }</a>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineCov">         21 :     SkMatrix* setTextMatrix(SkMatrix* matrix) const {</span>
<span class="lineNum">    1024 </span><span class="lineCov">         21 :         return SetTextMatrix(matrix, fTextSize, fTextScaleX, fTextSkewX);</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :     typedef const SkGlyph&amp; (*GlyphCacheProc)(SkGlyphCache*, const char**);
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            :     SK_TO_STRING_NONVIRT()
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            : private:
<span class="lineNum">    1032 </span>            :     sk_sp&lt;SkTypeface&gt;     fTypeface;
<span class="lineNum">    1033 </span>            :     sk_sp&lt;SkPathEffect&gt;   fPathEffect;
<span class="lineNum">    1034 </span>            :     sk_sp&lt;SkShader&gt;       fShader;
<span class="lineNum">    1035 </span>            :     sk_sp&lt;SkMaskFilter&gt;   fMaskFilter;
<span class="lineNum">    1036 </span>            :     sk_sp&lt;SkColorFilter&gt;  fColorFilter;
<span class="lineNum">    1037 </span>            :     sk_sp&lt;SkRasterizer&gt;   fRasterizer;
<span class="lineNum">    1038 </span>            :     sk_sp&lt;SkDrawLooper&gt;   fDrawLooper;
<span class="lineNum">    1039 </span>            :     sk_sp&lt;SkImageFilter&gt;  fImageFilter;
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :     SkScalar        fTextSize;
<span class="lineNum">    1042 </span>            :     SkScalar        fTextScaleX;
<span class="lineNum">    1043 </span>            :     SkScalar        fTextSkewX;
<span class="lineNum">    1044 </span>            :     SkColor         fColor;
<span class="lineNum">    1045 </span>            :     SkScalar        fWidth;
<span class="lineNum">    1046 </span>            :     SkScalar        fMiterLimit;
<span class="lineNum">    1047 </span>            :     uint32_t        fBlendMode; // just need 5-6 bits
<span class="lineNum">    1048 </span>            :     union {
<span class="lineNum">    1049 </span>            :         struct {
<span class="lineNum">    1050 </span>            :             // all of these bitfields should add up to 32
<span class="lineNum">    1051 </span>            :             unsigned        fFlags : 16;
<span class="lineNum">    1052 </span>            :             unsigned        fTextAlign : 2;
<span class="lineNum">    1053 </span>            :             unsigned        fCapType : 2;
<span class="lineNum">    1054 </span>            :             unsigned        fJoinType : 2;
<span class="lineNum">    1055 </span>            :             unsigned        fStyle : 2;
<span class="lineNum">    1056 </span>            :             unsigned        fTextEncoding : 2;  // 3 values
<span class="lineNum">    1057 </span>            :             unsigned        fHinting : 2;
<span class="lineNum">    1058 </span>            :             unsigned        fFilterQuality : 2;
<span class="lineNum">    1059 </span>            :             //unsigned      fFreeBits : 2;
<span class="lineNum">    1060 </span>            :         } fBitfields;
<span class="lineNum">    1061 </span>            :         uint32_t fBitfieldsUInt;
<span class="lineNum">    1062 </span>            :     };
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :     static GlyphCacheProc GetGlyphCacheProc(TextEncoding encoding,
<span class="lineNum">    1065 </span>            :                                             bool isDevKern,
<span class="lineNum">    1066 </span>            :                                             bool needFullMetrics);
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :     SkScalar measure_text(SkGlyphCache*, const char* text, size_t length,
<span class="lineNum">    1069 </span>            :                           int* count, SkRect* bounds) const;
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :     enum ScalerContextFlags : uint32_t {
<span class="lineNum">    1072 </span>            :         kNone_ScalerContextFlags = 0,
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :         kFakeGamma_ScalerContextFlag = 1 &lt;&lt; 0,
<span class="lineNum">    1075 </span>            :         kBoostContrast_ScalerContextFlag = 1 &lt;&lt; 1,
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            :         kFakeGammaAndBoostContrast_ScalerContextFlags =
<span class="lineNum">    1078 </span>            :             kFakeGamma_ScalerContextFlag | kBoostContrast_ScalerContextFlag,
<span class="lineNum">    1079 </span>            :     };
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :     /*
<span class="lineNum">    1082 </span>            :      * Allocs an SkDescriptor on the heap and return it to the caller as a refcnted
<span class="lineNum">    1083 </span>            :      * SkData.  Caller is responsible for managing the lifetime of this object.
<span class="lineNum">    1084 </span>            :      */
<span class="lineNum">    1085 </span>            :     void getScalerContextDescriptor(SkScalerContextEffects*, SkAutoDescriptor*,
<span class="lineNum">    1086 </span>            :                                     const SkSurfaceProps&amp; surfaceProps,
<span class="lineNum">    1087 </span>            :                                     uint32_t scalerContextFlags, const SkMatrix*) const;
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :     SkGlyphCache* detachCache(const SkSurfaceProps* surfaceProps, uint32_t scalerContextFlags,
<span class="lineNum">    1090 </span>            :                               const SkMatrix*) const;
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :     void descriptorProc(const SkSurfaceProps* surfaceProps, uint32_t scalerContextFlags,
<span class="lineNum">    1093 </span>            :                         const SkMatrix* deviceMatrix,
<span class="lineNum">    1094 </span>            :                         void (*proc)(SkTypeface*, const SkScalerContextEffects&amp;,
<span class="lineNum">    1095 </span>            :                                      const SkDescriptor*, void*),
<span class="lineNum">    1096 </span>            :                         void* context) const;
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            :     /*
<span class="lineNum">    1099 </span>            :      * The luminance color is used to determine which Gamma Canonical color to map to.  This is
<span class="lineNum">    1100 </span>            :      * really only used by backends which want to cache glyph masks, and need some way to know if
<span class="lineNum">    1101 </span>            :      * they need to generate new masks based off a given color.
<span class="lineNum">    1102 </span>            :      */
<span class="lineNum">    1103 </span>            :     SkColor computeLuminanceColor() const;
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span>            :     enum {
<span class="lineNum">    1106 </span>            :         /*  This is the size we use when we ask for a glyph's path. We then
<span class="lineNum">    1107 </span>            :          *  post-transform it as we draw to match the request.
<span class="lineNum">    1108 </span>            :          *  This is done to try to re-use cache entries for the path.
<span class="lineNum">    1109 </span>            :          *
<span class="lineNum">    1110 </span>            :          *  This value is somewhat arbitrary. In theory, it could be 1, since
<span class="lineNum">    1111 </span>            :          *  we store paths as floats. However, we get the path from the font
<span class="lineNum">    1112 </span>            :          *  scaler, and it may represent its paths as fixed-point (or 26.6),
<span class="lineNum">    1113 </span>            :          *  so we shouldn't ask for something too big (might overflow 16.16)
<span class="lineNum">    1114 </span>            :          *  or too small (underflow 26.6).
<span class="lineNum">    1115 </span>            :          *
<span class="lineNum">    1116 </span>            :          *  This value could track kMaxSizeForGlyphCache, assuming the above
<span class="lineNum">    1117 </span>            :          *  constraints, but since we ask for unhinted paths, the two values
<span class="lineNum">    1118 </span>            :          *  need not match per-se.
<span class="lineNum">    1119 </span>            :          */
<span class="lineNum">    1120 </span>            :         kCanonicalTextSizeForPaths  = 64,
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :         /*
<span class="lineNum">    1123 </span>            :          *  Above this size (taking into account CTM and textSize), we never use
<span class="lineNum">    1124 </span>            :          *  the cache for bits or metrics (we might overflow), so we just ask
<span class="lineNum">    1125 </span>            :          *  for a caononical size and post-transform that.
<span class="lineNum">    1126 </span>            :          */
<span class="lineNum">    1127 </span>            :         kMaxSizeForGlyphCache       = 256,
<span class="lineNum">    1128 </span>            :     };
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :     static bool TooBigToUseCache(const SkMatrix&amp; ctm, const SkMatrix&amp; textM);
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :     // Set flags/hinting/textSize up to use for drawing text as paths.
<span class="lineNum">    1133 </span>            :     // Returns scale factor to restore the original textSize, since will will
<span class="lineNum">    1134 </span>            :     // have change it to kCanonicalTextSizeForPaths.
<a name="1135"><span class="lineNum">    1135 </span>            :     SkScalar setupForAsPaths();</a>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineCov">         21 :     static SkScalar MaxCacheSize2() {</span>
<span class="lineNum">    1138 </span>            :         static const SkScalar kMaxSize = SkIntToScalar(kMaxSizeForGlyphCache);
<span class="lineNum">    1139 </span>            :         static const SkScalar kMag2Max = kMaxSize * kMaxSize;
<span class="lineNum">    1140 </span><span class="lineCov">         21 :         return kMag2Max;</span>
<span class="lineNum">    1141 </span>            :     }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            :     friend class SkAutoGlyphCache;
<span class="lineNum">    1144 </span>            :     friend class SkAutoGlyphCacheNoGamma;
<span class="lineNum">    1145 </span>            :     friend class SkCanvas;
<span class="lineNum">    1146 </span>            :     friend class SkDraw;
<span class="lineNum">    1147 </span>            :     friend class SkPDFDevice;
<span class="lineNum">    1148 </span>            :     friend class GrAtlasTextBlob;
<span class="lineNum">    1149 </span>            :     friend class GrAtlasTextContext;
<span class="lineNum">    1150 </span>            :     friend class GrStencilAndCoverTextContext;
<span class="lineNum">    1151 </span>            :     friend class GrPathRendering;
<span class="lineNum">    1152 </span>            :     friend class GrTextUtils;
<span class="lineNum">    1153 </span>            :     friend class GrGLPathRendering;
<span class="lineNum">    1154 </span>            :     friend class SkScalerContext;
<span class="lineNum">    1155 </span>            :     friend class SkTextBaseIter;
<span class="lineNum">    1156 </span>            :     friend class SkCanonicalizePaint;
<span class="lineNum">    1157 </span>            : };
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

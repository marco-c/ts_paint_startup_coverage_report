<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/gpu/GrRenderTargetContext.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/gpu</a> - GrRenderTargetContext.cpp<span style="font-size: 80%;"> (source / <a href="GrRenderTargetContext.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">910</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">55</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2015 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;GrRenderTargetContext.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;GrAppliedClip.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;GrColor.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;GrContextPriv.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;GrDrawingManager.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;GrFixedClip.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;GrGpuResourcePriv.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;GrPathRenderer.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;GrPipelineBuilder.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;GrRenderTarget.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;GrRenderTargetContextPriv.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;GrRenderTargetPriv.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;GrResourceProvider.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;GrStencilAttachment.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;SkLatticeIter.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;SkMatrixPriv.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;SkSurfacePriv.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;effects/GrRRectEffect.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;instanced/InstancedRendering.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;ops/GrClearOp.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;ops/GrClearStencilClipOp.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;ops/GrDrawOp.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;ops/GrDrawAtlasOp.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;ops/GrDrawVerticesOp.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;ops/GrLatticeOp.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;ops/GrOp.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;ops/GrOvalOpFactory.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;ops/GrRectOpFactory.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;ops/GrRegionOp.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;ops/GrShadowRRectOp.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;ops/GrStencilPathOp.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;text/GrAtlasTextContext.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;text/GrStencilAndCoverTextContext.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;../private/GrAuditTrail.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #define ASSERT_OWNED_RESOURCE(R) SkASSERT(!(R) || (R)-&gt;getContext() == this-&gt;drawingManager()-&gt;getContext())
<span class="lineNum">      44 </span>            : #define ASSERT_SINGLE_OWNER \
<span class="lineNum">      45 </span>            :     SkDEBUGCODE(GrSingleOwner::AutoEnforce debug_SingleOwner(this-&gt;singleOwner());)
<span class="lineNum">      46 </span>            : #define ASSERT_SINGLE_OWNER_PRIV \
<span class="lineNum">      47 </span>            :     SkDEBUGCODE(GrSingleOwner::AutoEnforce debug_SingleOwner(fRenderTargetContext-&gt;singleOwner());)
<span class="lineNum">      48 </span>            : #define RETURN_IF_ABANDONED        if (this-&gt;drawingManager()-&gt;wasAbandoned()) { return; }
<span class="lineNum">      49 </span>            : #define RETURN_IF_ABANDONED_PRIV   if (fRenderTargetContext-&gt;drawingManager()-&gt;wasAbandoned()) { return; }
<span class="lineNum">      50 </span>            : #define RETURN_FALSE_IF_ABANDONED  if (this-&gt;drawingManager()-&gt;wasAbandoned()) { return false; }
<span class="lineNum">      51 </span>            : #define RETURN_FALSE_IF_ABANDONED_PRIV  if (fRenderTargetContext-&gt;drawingManager()-&gt;wasAbandoned()) { return false; }
<span class="lineNum">      52 </span>            : #define RETURN_NULL_IF_ABANDONED   if (this-&gt;drawingManager()-&gt;wasAbandoned()) { return nullptr; }
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : using gr_instanced::InstancedRendering;
<span class="lineNum">      55 </span>            : 
<a name="56"><span class="lineNum">      56 </span>            : class AutoCheckFlush {</a>
<span class="lineNum">      57 </span>            : public:
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     AutoCheckFlush(GrDrawingManager* drawingManager) : fDrawingManager(drawingManager) {</span>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 :         SkASSERT(fDrawingManager);</span></a>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     ~AutoCheckFlush() { fDrawingManager-&gt;flushIfNecessary(); }</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : private:
<span class="lineNum">      64 </span>            :     GrDrawingManager* fDrawingManager;
<a name="65"><span class="lineNum">      65 </span>            : };</a>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : bool GrRenderTargetContext::wasAbandoned() const {</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     return this-&gt;drawingManager()-&gt;wasAbandoned();</span>
<span class="lineNum">      69 </span>            : }
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : // In MDB mode the reffing of the 'getLastOpList' call's result allows in-progress
<span class="lineNum">      72 </span>            : // GrOpLists to be picked up and added to by renderTargetContexts lower in the call
<a name="73"><span class="lineNum">      73 </span>            : // stack. When this occurs with a closed GrOpList, a new one will be allocated</a>
<span class="lineNum">      74 </span>            : // when the renderTargetContext attempts to use it (via getOpList).
<span class="lineNum">      75 </span><span class="lineNoCov">          0 : GrRenderTargetContext::GrRenderTargetContext(GrContext* context,</span>
<span class="lineNum">      76 </span>            :                                              GrDrawingManager* drawingMgr,
<span class="lineNum">      77 </span>            :                                              sk_sp&lt;GrRenderTargetProxy&gt; rtp,
<span class="lineNum">      78 </span>            :                                              sk_sp&lt;SkColorSpace&gt; colorSpace,
<span class="lineNum">      79 </span>            :                                              const SkSurfaceProps* surfaceProps,
<span class="lineNum">      80 </span>            :                                              GrAuditTrail* auditTrail,
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :                                              GrSingleOwner* singleOwner)</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     : GrSurfaceContext(context, drawingMgr, std::move(colorSpace), auditTrail, singleOwner)</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     , fRenderTargetProxy(std::move(rtp))</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     , fOpList(SkSafeRef(fRenderTargetProxy-&gt;getLastRenderTargetOpList()))</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     , fInstancedPipelineInfo(fRenderTargetProxy.get())</span>
<span class="lineNum">      86 </span>            :     , fColorXformFromSRGB(nullptr)
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     , fSurfaceProps(SkSurfacePropsCopyOrDefault(surfaceProps)) {</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     if (fColorSpace) {</span>
<span class="lineNum">      89 </span>            :         // sRGB sources are very common (SkColor, etc...), so we cache that gamut transformation
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         auto srgbColorSpace = SkColorSpace::MakeSRGB();</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :         fColorXformFromSRGB = GrColorSpaceXform::Make(srgbColorSpace.get(), fColorSpace.get());</span>
<span class="lineNum">      92 </span>            :     }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : }</span>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<span class="lineNum">      96 </span>            : #ifdef SK_DEBUG
<span class="lineNum">      97 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::validate() const {</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     SkASSERT(fRenderTargetProxy);</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     fRenderTargetProxy-&gt;validate(fContext);</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     if (fOpList &amp;&amp; !fOpList-&gt;isClosed()) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         SkASSERT(fRenderTargetProxy-&gt;getLastOpList() == fOpList);</span>
<span class="lineNum">     103 </span>            :     }
<span class="lineNum">     104 </span><span class="lineNoCov">          0 : }</span>
<a name="105"><span class="lineNum">     105 </span>            : #endif</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : GrRenderTargetContext::~GrRenderTargetContext() {</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     SkSafeUnref(fOpList);</span>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span><span class="lineNoCov">          0 : GrTextureProxy* GrRenderTargetContext::asTextureProxy() {</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     return fRenderTargetProxy-&gt;asTextureProxy();</span>
<a name="114"><span class="lineNum">     114 </span>            : }</a>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 : sk_sp&lt;GrTextureProxy&gt; GrRenderTargetContext::asTextureProxyRef() {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     return sk_ref_sp(fRenderTargetProxy-&gt;asTextureProxy());</span>
<a name="118"><span class="lineNum">     118 </span>            : }</a>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : GrRenderTargetOpList* GrRenderTargetContext::getOpList() {</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     if (!fOpList || fOpList-&gt;isClosed()) {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         fOpList = this-&gt;drawingManager()-&gt;newOpList(fRenderTargetProxy.get());</span>
<span class="lineNum">     126 </span>            :     }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     return fOpList;</span>
<span class="lineNum">     129 </span>            : }
<a name="130"><span class="lineNum">     130 </span>            : </a>
<span class="lineNum">     131 </span>            : // TODO: move this (and GrTextContext::copy) to GrSurfaceContext?
<span class="lineNum">     132 </span><span class="lineNoCov">          0 : bool GrRenderTargetContext::onCopy(GrSurfaceProxy* srcProxy,</span>
<span class="lineNum">     133 </span>            :                                    const SkIRect&amp; srcRect,
<span class="lineNum">     134 </span>            :                                    const SkIPoint&amp; dstPoint) {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     RETURN_FALSE_IF_ABANDONED</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::onCopy&quot;);</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     return this-&gt;getOpList()-&gt;copySurface(fContext-&gt;resourceProvider(),</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :                                           fRenderTargetProxy.get(), srcProxy, srcRect, dstPoint);</span>
<a name="142"><span class="lineNum">     142 </span>            : }</a>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawText(const GrClip&amp; clip, const SkPaint&amp; skPaint,</span>
<span class="lineNum">     145 </span>            :                                      const SkMatrix&amp; viewMatrix, const char text[],
<span class="lineNum">     146 </span>            :                                      size_t byteLength, SkScalar x, SkScalar y,
<span class="lineNum">     147 </span>            :                                      const SkIRect&amp; clipBounds) {
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawText&quot;);</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     GrAtlasTextContext* atlasTextContext = this-&gt;drawingManager()-&gt;getAtlasTextContext();</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     atlasTextContext-&gt;drawText(fContext, this, clip, skPaint, viewMatrix, fSurfaceProps, text,</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :                                byteLength, x, y, clipBounds);</span>
<a name="156"><span class="lineNum">     156 </span>            : }</a>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawPosText(const GrClip&amp; clip, const SkPaint&amp; paint,</span>
<span class="lineNum">     159 </span>            :                                         const SkMatrix&amp; viewMatrix, const char text[],
<span class="lineNum">     160 </span>            :                                         size_t byteLength, const SkScalar pos[],
<span class="lineNum">     161 </span>            :                                         int scalarsPerPosition, const SkPoint&amp; offset,
<span class="lineNum">     162 </span>            :                                         const SkIRect&amp; clipBounds) {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawPosText&quot;);</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     GrAtlasTextContext* atlasTextContext = this-&gt;drawingManager()-&gt;getAtlasTextContext();</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     atlasTextContext-&gt;drawPosText(fContext, this, clip, paint, viewMatrix, fSurfaceProps, text,</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :                                   byteLength, pos, scalarsPerPosition, offset, clipBounds);</span>
<a name="171"><span class="lineNum">     171 </span>            : }</a>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawTextBlob(const GrClip&amp; clip, const SkPaint&amp; paint,</span>
<span class="lineNum">     174 </span>            :                                          const SkMatrix&amp; viewMatrix, const SkTextBlob* blob,
<span class="lineNum">     175 </span>            :                                          SkScalar x, SkScalar y, SkDrawFilter* filter,
<span class="lineNum">     176 </span>            :                                          const SkIRect&amp; clipBounds) {
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawTextBlob&quot;);</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     GrAtlasTextContext* atlasTextContext = this-&gt;drawingManager()-&gt;getAtlasTextContext();</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     atlasTextContext-&gt;drawTextBlob(fContext, this, clip, paint, viewMatrix, fSurfaceProps, blob, x,</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :                                    y, filter, clipBounds);</span>
<a name="185"><span class="lineNum">     185 </span>            : }</a>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::discard() {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::discard&quot;);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     this-&gt;getOpList()-&gt;discard(this);</span>
<a name="196"><span class="lineNum">     196 </span>            : }</a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::clear(const SkIRect* rect,</span>
<span class="lineNum">     199 </span>            :                                   const GrColor color,
<span class="lineNum">     200 </span>            :                                   bool canIgnoreRect) {
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::clear&quot;);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     this-&gt;internalClear(rect ? GrFixedClip(*rect) : GrFixedClip::Disabled(), color, canIgnoreRect);</span>
<a name="208"><span class="lineNum">     208 </span>            : }</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : void GrRenderTargetContextPriv::absClear(const SkIRect* clearRect, const GrColor color) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED_PRIV</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     215 </span>            :                               &quot;GrRenderTargetContext::absClear&quot;);
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     SkIRect rtRect = SkIRect::MakeWH(fRenderTargetContext-&gt;fRenderTargetProxy-&gt;worstCaseWidth(</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :                                             *fRenderTargetContext-&gt;caps()),</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                                      fRenderTargetContext-&gt;fRenderTargetProxy-&gt;worstCaseHeight(</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                                             *fRenderTargetContext-&gt;caps()));</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if (clearRect) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         if (clearRect-&gt;contains(rtRect)) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             clearRect = nullptr; // full screen</span>
<span class="lineNum">     227 </span>            :         } else {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :             if (!rtRect.intersect(*clearRect)) {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     230 </span>            :             }
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span>            :     }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     // TODO: in a post-MDB world this should be handled at the OpList level.
<span class="lineNum">     235 </span>            :     // An op-list that is initially cleared and has no other ops should receive an
<span class="lineNum">     236 </span>            :     // extra draw.
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     if (fRenderTargetContext-&gt;fContext-&gt;caps()-&gt;useDrawInsteadOfClear()) {</span>
<span class="lineNum">     238 </span>            :         // This works around a driver bug with clear by drawing a rect instead.
<span class="lineNum">     239 </span>            :         // The driver will ignore a clear if it is the only thing rendered to a
<span class="lineNum">     240 </span>            :         // target before the target is read.
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         GrPaint paint;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         paint.setColor4f(GrColor4f::FromGrColor(color));</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         paint.setXPFactory(GrPorterDuffXPFactory::Get(SkBlendMode::kSrc));</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :         // We don't call drawRect() here to avoid the cropping to the, possibly smaller,
<span class="lineNum">     246 </span>            :         // RenderTargetProxy bounds
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         fRenderTargetContext-&gt;drawNonAAFilledRect(GrNoClip(), std::move(paint), SkMatrix::I(),</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                                                   SkRect::Make(rtRect), nullptr, nullptr, nullptr,</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                                                   GrAAType::kNone);</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :     } else {
<span class="lineNum">     252 </span>            :         // This path doesn't handle coalescing of full screen clears b.c. it
<span class="lineNum">     253 </span>            :         // has to clear the entire render target - not just the content area.
<span class="lineNum">     254 </span>            :         // It could be done but will take more finagling.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrOp&gt; op(GrClearOp::Make(rtRect, color, fRenderTargetContext, !clearRect));</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         if (!op) {</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     258 </span>            :         }
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :         fRenderTargetContext-&gt;getOpList()-&gt;addOp(std::move(op), fRenderTargetContext);</span>
<span class="lineNum">     260 </span>            :     }
<a name="261"><span class="lineNum">     261 </span>            : }</a>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 : void GrRenderTargetContextPriv::clear(const GrFixedClip&amp; clip,</span>
<span class="lineNum">     264 </span>            :                                       const GrColor color,
<span class="lineNum">     265 </span>            :                                       bool canIgnoreClip) {
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED_PRIV</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     270 </span>            :                               &quot;GrRenderTargetContextPriv::clear&quot;);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     fRenderTargetContext-&gt;internalClear(clip, color, canIgnoreClip);</span>
<a name="274"><span class="lineNum">     274 </span>            : }</a>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::internalClear(const GrFixedClip&amp; clip,</span>
<span class="lineNum">     277 </span>            :                                           const GrColor color,
<span class="lineNum">     278 </span>            :                                           bool canIgnoreClip) {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     bool isFull = false;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     if (!clip.hasWindowRectangles()) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         isFull = !clip.scissorEnabled() ||</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                  (canIgnoreClip &amp;&amp; fContext-&gt;caps()-&gt;fullClearIsFree()) ||</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                  clip.scissorRect().contains(SkIRect::MakeWH(this-&gt;width(), this-&gt;height()));</span>
<span class="lineNum">     284 </span>            :     }
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     if (fContext-&gt;caps()-&gt;useDrawInsteadOfClear()) {</span>
<span class="lineNum">     287 </span>            :         // This works around a driver bug with clear by drawing a rect instead.
<span class="lineNum">     288 </span>            :         // The driver will ignore a clear if it is the only thing rendered to a
<span class="lineNum">     289 </span>            :         // target before the target is read.
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         SkIRect clearRect = SkIRect::MakeWH(this-&gt;width(), this-&gt;height());</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         if (isFull) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :             this-&gt;discard();</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         } else if (!clearRect.intersect(clip.scissorRect())) {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     295 </span>            :         }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         GrPaint paint;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         paint.setColor4f(GrColor4f::FromGrColor(color));</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         paint.setXPFactory(GrPorterDuffXPFactory::Get(SkBlendMode::kSrc));</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         this-&gt;drawRect(clip, std::move(paint), GrAA::kNo, SkMatrix::I(), SkRect::Make(clearRect));</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     } else if (isFull) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         this-&gt;getOpList()-&gt;fullClear(this, color);</span>
<span class="lineNum">     304 </span>            :     } else {
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrOp&gt; op(GrClearOp::Make(clip, color, this));</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         if (!op) {</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     308 </span>            :         }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         this-&gt;getOpList()-&gt;addOp(std::move(op), this);</span>
<span class="lineNum">     310 </span>            :     }
<a name="311"><span class="lineNum">     311 </span>            : }</a>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawPaint(const GrClip&amp; clip,</span>
<span class="lineNum">     314 </span>            :                                       GrPaint&amp;&amp; paint,
<span class="lineNum">     315 </span>            :                                       const SkMatrix&amp; viewMatrix) {
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawPaint&quot;);</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     // set rect to be big enough to fill the space, but not super-huge, so we
<span class="lineNum">     322 </span>            :     // don't overflow fixed-point implementations
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     SkRect r = fRenderTargetProxy-&gt;getBoundsRect();</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     SkRRect rrect;</span>
<span class="lineNum">     327 </span>            :     GrAA aa;
<span class="lineNum">     328 </span>            :     // Check if we can replace a clipRRect()/drawPaint() with a drawRRect(). We only do the
<span class="lineNum">     329 </span>            :     // transformation for non-rect rrects. Rects caused a performance regression on an Android
<span class="lineNum">     330 </span>            :     // test that needs investigation. We also skip cases where there are fragment processors
<span class="lineNum">     331 </span>            :     // because they may depend on having correct local coords and this path draws in device space
<span class="lineNum">     332 </span>            :     // without a local matrix.
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (!paint.numTotalFragmentProcessors() &amp;&amp; clip.isRRect(r, &amp;rrect, &amp;aa) &amp;&amp; !rrect.isRect()) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         this-&gt;drawRRect(GrNoClip(), std::move(paint), aa, SkMatrix::I(), rrect,</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :                         GrStyle::SimpleFill());</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     337 </span>            :     }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     bool isPerspective = viewMatrix.hasPerspective();</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     // We attempt to map r by the inverse matrix and draw that. mapRect will
<span class="lineNum">     343 </span>            :     // map the four corners and bound them with a new rect. This will not
<span class="lineNum">     344 </span>            :     // produce a correct result for some perspective matrices.
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     if (!isPerspective) {</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         if (!SkMatrixPriv::InverseMapRect(viewMatrix, &amp;r, r)) {</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             SkDebugf(&quot;Could not invert matrix\n&quot;);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     349 </span>            :         }
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         this-&gt;drawRect(clip, std::move(paint), GrAA::kNo, viewMatrix, r);</span>
<span class="lineNum">     351 </span>            :     } else {
<span class="lineNum">     352 </span>            :         SkMatrix localMatrix;
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         if (!viewMatrix.invert(&amp;localMatrix)) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :             SkDebugf(&quot;Could not invert matrix\n&quot;);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     356 </span>            :         }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         this-&gt;drawNonAAFilledRect(clip, std::move(paint), SkMatrix::I(), r, nullptr, &amp;localMatrix,</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                                   nullptr, GrAAType::kNone);</span>
<span class="lineNum">     362 </span>            :     }
<a name="363"><span class="lineNum">     363 </span>            : }</a>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 : static inline bool rect_contains_inclusive(const SkRect&amp; rect, const SkPoint&amp; point) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     return point.fX &gt;= rect.fLeft &amp;&amp; point.fX &lt;= rect.fRight &amp;&amp;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :            point.fY &gt;= rect.fTop &amp;&amp; point.fY &lt;= rect.fBottom;</span>
<a name="368"><span class="lineNum">     368 </span>            : }</a>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : static bool view_matrix_ok_for_aa_fill_rect(const SkMatrix&amp; viewMatrix) {</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     return viewMatrix.preservesRightAngles();</span>
<span class="lineNum">     372 </span>            : }
<span class="lineNum">     373 </span>            : 
<a name="374"><span class="lineNum">     374 </span>            : // Attempts to crop a rect and optional local rect to the clip boundaries.</a>
<span class="lineNum">     375 </span>            : // Returns false if the draw can be skipped entirely.
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : static bool crop_filled_rect(int width, int height, const GrClip&amp; clip,</span>
<span class="lineNum">     377 </span>            :                              const SkMatrix&amp; viewMatrix, SkRect* rect,
<span class="lineNum">     378 </span>            :                              SkRect* localRect = nullptr) {
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     if (!viewMatrix.rectStaysRect()) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :     SkIRect clipDevBounds;
<span class="lineNum">     384 </span>            :     SkRect clipBounds;
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     clip.getConservativeBounds(width, height, &amp;clipDevBounds);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     if (!SkMatrixPriv::InverseMapRect(viewMatrix, &amp;clipBounds, SkRect::Make(clipDevBounds))) {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     389 </span>            :     }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     if (localRect) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         if (!rect-&gt;intersects(clipBounds)) {</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     394 </span>            :         }
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         const SkScalar dx = localRect-&gt;width() / rect-&gt;width();</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         const SkScalar dy = localRect-&gt;height() / rect-&gt;height();</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         if (clipBounds.fLeft &gt; rect-&gt;fLeft) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :             localRect-&gt;fLeft += (clipBounds.fLeft - rect-&gt;fLeft) * dx;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :             rect-&gt;fLeft = clipBounds.fLeft;</span>
<span class="lineNum">     400 </span>            :         }
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         if (clipBounds.fTop &gt; rect-&gt;fTop) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :             localRect-&gt;fTop += (clipBounds.fTop - rect-&gt;fTop) * dy;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             rect-&gt;fTop = clipBounds.fTop;</span>
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         if (clipBounds.fRight &lt; rect-&gt;fRight) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             localRect-&gt;fRight -= (rect-&gt;fRight - clipBounds.fRight) * dx;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :             rect-&gt;fRight = clipBounds.fRight;</span>
<span class="lineNum">     408 </span>            :         }
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         if (clipBounds.fBottom &lt; rect-&gt;fBottom) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             localRect-&gt;fBottom -= (rect-&gt;fBottom - clipBounds.fBottom) * dy;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :             rect-&gt;fBottom = clipBounds.fBottom;</span>
<span class="lineNum">     412 </span>            :         }
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     return rect-&gt;intersect(clipBounds);</span>
<a name="417"><span class="lineNum">     417 </span>            : }</a>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : bool GrRenderTargetContext::drawFilledRect(const GrClip&amp; clip,</span>
<span class="lineNum">     420 </span>            :                                            GrPaint&amp;&amp; paint,
<span class="lineNum">     421 </span>            :                                            GrAA aa,
<span class="lineNum">     422 </span>            :                                            const SkMatrix&amp; viewMatrix,
<span class="lineNum">     423 </span>            :                                            const SkRect&amp; rect,
<span class="lineNum">     424 </span>            :                                            const GrUserStencilSettings* ss) {
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     SkRect croppedRect = rect;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     if (!crop_filled_rect(this-&gt;width(), this-&gt;height(), clip, viewMatrix, &amp;croppedRect)) {</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     428 </span>            :     }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport() &amp;&amp;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         (!ss || ss-&gt;isDisabled(false))) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrDrawOp&gt; op = ir-&gt;recordRect(croppedRect, viewMatrix, std::move(paint), aa,</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                                                       fInstancedPipelineInfo);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(clip, std::move(op));</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     438 </span>            :         }
<span class="lineNum">     439 </span>            :     }
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">     442 </span>            :         // The fill path can handle rotation but not skew.
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         if (view_matrix_ok_for_aa_fill_rect(viewMatrix)) {</span>
<span class="lineNum">     444 </span>            :             SkRect devBoundRect;
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :             viewMatrix.mapRect(&amp;devBoundRect, croppedRect);</span>
<span class="lineNum">     446 </span>            :             std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                     GrRectOpFactory::MakeAAFill(paint, viewMatrix, rect, croppedRect, devBoundRect);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :             if (op) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                 GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 if (ss) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                     pipelineBuilder.setUserStencil(ss);</span>
<span class="lineNum">     452 </span>            :                 }
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     455 </span>            :             }
<span class="lineNum">     456 </span>            :         }
<span class="lineNum">     457 </span>            :     } else {
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         this-&gt;drawNonAAFilledRect(clip, std::move(paint), viewMatrix, croppedRect, nullptr, nullptr,</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                                   ss, aaType);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     461 </span>            :     }
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="464"><span class="lineNum">     464 </span>            : }</a>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawRect(const GrClip&amp; clip,</span>
<span class="lineNum">     467 </span>            :                                      GrPaint&amp;&amp; paint,
<span class="lineNum">     468 </span>            :                                      GrAA aa,
<span class="lineNum">     469 </span>            :                                      const SkMatrix&amp; viewMatrix,
<span class="lineNum">     470 </span>            :                                      const SkRect&amp; rect,
<span class="lineNum">     471 </span>            :                                      const GrStyle* style) {
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     if (!style) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         style = &amp;GrStyle::SimpleFill();</span>
<span class="lineNum">     474 </span>            :     }
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawRect&quot;);</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     // Path effects should've been devolved to a path in SkGpuDevice
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     SkASSERT(!style-&gt;pathEffect());</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     const SkStrokeRec&amp; stroke = style-&gt;strokeRec();</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     if (stroke.getStyle() == SkStrokeRec::kFill_Style) {</span>
<span class="lineNum">     487 </span>            :         
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         if (!fContext-&gt;caps()-&gt;useDrawInsteadOfClear()) {</span>
<span class="lineNum">     489 </span>            :             // Check if this is a full RT draw and can be replaced with a clear. We don't bother
<span class="lineNum">     490 </span>            :             // checking cases where the RT is fully inside a stroke.
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :             SkRect rtRect = fRenderTargetProxy-&gt;getBoundsRect();</span>
<span class="lineNum">     492 </span>            :             // Does the clip contain the entire RT?
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             if (clip.quickContains(rtRect)) {</span>
<span class="lineNum">     494 </span>            :                 SkMatrix invM;
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                 if (!viewMatrix.invert(&amp;invM)) {</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">     497 </span>            :                 }
<span class="lineNum">     498 </span>            :                 // Does the rect bound the RT?
<span class="lineNum">     499 </span>            :                 SkPoint srcSpaceRTQuad[4];
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :                 invM.mapRectToQuad(srcSpaceRTQuad, rtRect);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 if (rect_contains_inclusive(rect, srcSpaceRTQuad[0]) &amp;&amp;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                     rect_contains_inclusive(rect, srcSpaceRTQuad[1]) &amp;&amp;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                     rect_contains_inclusive(rect, srcSpaceRTQuad[2]) &amp;&amp;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                     rect_contains_inclusive(rect, srcSpaceRTQuad[3])) {</span>
<span class="lineNum">     505 </span>            :                     // Will it blend?
<span class="lineNum">     506 </span>            :                     GrColor clearColor;
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :                     if (paint.isConstantBlendedColor(&amp;clearColor)) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                         this-&gt;clear(nullptr, clearColor, true);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     510 </span>            :                     }
<span class="lineNum">     511 </span>            :                 }
<span class="lineNum">     512 </span>            :             }
<span class="lineNum">     513 </span>            :         }
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         if (this-&gt;drawFilledRect(clip, std::move(paint), aa, viewMatrix, rect, nullptr)) {</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     517 </span>            :         }
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     } else if (stroke.getStyle() == SkStrokeRec::kStroke_Style ||</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                stroke.getStyle() == SkStrokeRec::kHairline_Style) {</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         if ((!rect.width() || !rect.height()) &amp;&amp;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :             SkStrokeRec::kHairline_Style != stroke.getStyle()) {</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :             SkScalar r = stroke.getWidth() / 2;</span>
<span class="lineNum">     523 </span>            :             // TODO: Move these stroke-&gt;fill fallbacks to GrShape?
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :             switch (stroke.getJoin()) {</span>
<span class="lineNum">     525 </span>            :                 case SkPaint::kMiter_Join:
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                     this-&gt;drawRect(</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                             clip, std::move(paint), aa, viewMatrix,</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                             {rect.fLeft - r, rect.fTop - r, rect.fRight + r, rect.fBottom + r},</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                             &amp;GrStyle::SimpleFill());</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">     531 </span>            :                 case SkPaint::kRound_Join:
<span class="lineNum">     532 </span>            :                     // Raster draws nothing when both dimensions are empty.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                     if (rect.width() || rect.height()){</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                         SkRRect rrect = SkRRect::MakeRectXY(rect.makeOutset(r, r), r, r);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                         this-&gt;drawRRect(clip, std::move(paint), aa, viewMatrix, rrect,</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                                         GrStyle::SimpleFill());</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     538 </span>            :                     }
<span class="lineNum">     539 </span>            :                 case SkPaint::kBevel_Join:
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                     if (!rect.width()) {</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :                         this-&gt;drawRect(clip, std::move(paint), aa, viewMatrix,</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                                        {rect.fLeft - r, rect.fTop, rect.fRight + r, rect.fBottom},</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                                        &amp;GrStyle::SimpleFill());</span>
<span class="lineNum">     544 </span>            :                     } else {
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                         this-&gt;drawRect(clip, std::move(paint), aa, viewMatrix,</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                                        {rect.fLeft, rect.fTop - r, rect.fRight, rect.fBottom + r},</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                                        &amp;GrStyle::SimpleFill());</span>
<span class="lineNum">     548 </span>            :                     }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">     550 </span>            :                 }
<span class="lineNum">     551 </span>            :         }
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         bool snapToPixelCenters = false;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op;</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         GrColor color = paint.getColor();</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">     559 </span>            :             // The stroke path needs the rect to remain axis aligned (no rotation or skew).
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :             if (viewMatrix.rectStaysRect()) {</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                 op = GrRectOpFactory::MakeAAStroke(color, viewMatrix, rect, stroke);</span>
<span class="lineNum">     562 </span>            :             }
<span class="lineNum">     563 </span>            :         } else {
<span class="lineNum">     564 </span>            :             // Depending on sub-pixel coordinates and the particular GPU, we may lose a corner of
<span class="lineNum">     565 </span>            :             // hairline rects. We jam all the vertices to pixel centers to avoid this, but not
<span class="lineNum">     566 </span>            :             // when MSAA is enabled because it can cause ugly artifacts.
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :             snapToPixelCenters = stroke.getStyle() == SkStrokeRec::kHairline_Style &amp;&amp;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :                                  !fRenderTargetProxy-&gt;isUnifiedMultisampled();</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :             op = GrRectOpFactory::MakeNonAAStroke(color, viewMatrix, rect, stroke,</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                                                   snapToPixelCenters);</span>
<span class="lineNum">     571 </span>            :         }
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :             GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :             pipelineBuilder.setSnapVerticesToPixelCenters(snapToPixelCenters);</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :             this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     578 </span>            :         }
<span class="lineNum">     579 </span>            :     }
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     path.addRect(rect);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewMatrix, path, *style);</span>
<a name="585"><span class="lineNum">     585 </span>            : }</a>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 : int GrRenderTargetContextPriv::maxWindowRectangles() const {</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     return fRenderTargetContext-&gt;fRenderTargetProxy-&gt;maxWindowRectangles(</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                                                     *fRenderTargetContext-&gt;fContext-&gt;caps());</span>
<a name="590"><span class="lineNum">     590 </span>            : }</a>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 : void GrRenderTargetContextPriv::clearStencilClip(const GrFixedClip&amp; clip, bool insideStencilMask) {</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED_PRIV</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     597 </span>            :                               &quot;GrRenderTargetContextPriv::clearStencilClip&quot;);
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :     std::unique_ptr&lt;GrOp&gt; op(GrClearStencilClipOp::Make(clip, insideStencilMask,
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                                                         fRenderTargetContext));</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     if (!op) {</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     605 </span>            :     }
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     fRenderTargetContext-&gt;getOpList()-&gt;addOp(std::move(op), fRenderTargetContext);</span>
<a name="607"><span class="lineNum">     607 </span>            : }</a>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 : void GrRenderTargetContextPriv::stencilPath(const GrClip&amp; clip,</span>
<span class="lineNum">     610 </span>            :                                             GrAAType aaType,
<span class="lineNum">     611 </span>            :                                             const SkMatrix&amp; viewMatrix,
<span class="lineNum">     612 </span>            :                                             const GrPath* path) {
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED_PRIV</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     617 </span>            :                               &quot;GrRenderTargetContext::stencilPath&quot;);
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     SkASSERT(aaType != GrAAType::kCoverage);</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     bool useHWAA = GrAATypeIsHW(aaType);</span>
<span class="lineNum">     622 </span>            :     // TODO: extract portions of checkDraw that are relevant to path stenciling.
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     SkASSERT(path);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     SkASSERT(fRenderTargetContext-&gt;caps()-&gt;shaderCaps()-&gt;pathRenderingSupport());</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :     // FIXME: Use path bounds instead of this WAR once
<span class="lineNum">     627 </span>            :     // https://bugs.chromium.org/p/skia/issues/detail?id=5640 is resolved.
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     SkRect bounds = SkRect::MakeIWH(fRenderTargetContext-&gt;width(), fRenderTargetContext-&gt;height());</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :     // Setup clip
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     GrAppliedClip appliedClip;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     if (!clip.apply(fRenderTargetContext-&gt;fContext, fRenderTargetContext, useHWAA, true,</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                     &amp;appliedClip, &amp;bounds)) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     635 </span>            :     }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     // Coverage AA does not make sense when rendering to the stencil buffer. The caller should never
<span class="lineNum">     638 </span>            :     // attempt this in a situation that would require coverage AA.
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     SkASSERT(!appliedClip.clipCoverageFragmentProcessor());</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     GrRenderTarget* rt = fRenderTargetContext-&gt;accessRenderTarget();</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     if (!rt) {</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span>            :     GrStencilAttachment* stencilAttachment =
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :             fRenderTargetContext-&gt;fContext-&gt;resourceProvider()-&gt;attachStencilAttachment(rt);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     if (!stencilAttachment) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;ERROR creating stencil attachment. Draw skipped.\n&quot;);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     650 </span>            :     }
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     std::unique_ptr&lt;GrOp&gt; op = GrStencilPathOp::Make(viewMatrix,
<span class="lineNum">     653 </span>            :                                                      useHWAA,
<span class="lineNum">     654 </span>            :                                                      path-&gt;getFillType(),
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                                                      appliedClip.hasStencilClip(),</span>
<span class="lineNum">     656 </span>            :                                                      stencilAttachment-&gt;bits(),
<span class="lineNum">     657 </span>            :                                                      appliedClip.scissorState(),
<span class="lineNum">     658 </span>            :                                                      fRenderTargetContext,
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                                                      path);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     if (!op) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     662 </span>            :     }
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     op-&gt;setClippedBounds(bounds);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     fRenderTargetContext-&gt;getOpList()-&gt;addOp(std::move(op), fRenderTargetContext);</span>
<a name="665"><span class="lineNum">     665 </span>            : }</a>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 : void GrRenderTargetContextPriv::stencilRect(const GrClip&amp; clip,</span>
<span class="lineNum">     668 </span>            :                                             const GrUserStencilSettings* ss,
<span class="lineNum">     669 </span>            :                                             GrAAType aaType,
<span class="lineNum">     670 </span>            :                                             const SkMatrix&amp; viewMatrix,
<span class="lineNum">     671 </span>            :                                             const SkRect&amp; rect) {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED_PRIV</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     676 </span>            :                               &quot;GrRenderTargetContext::stencilRect&quot;);
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     SkASSERT(GrAAType::kCoverage != aaType);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     GrPaint paint;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     paint.setXPFactory(GrDisableColorXPFactory::Get());</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     fRenderTargetContext-&gt;drawNonAAFilledRect(clip, std::move(paint), viewMatrix, rect, nullptr,</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :                                               nullptr, ss, aaType);</span>
<a name="685"><span class="lineNum">     685 </span>            : }</a>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : bool GrRenderTargetContextPriv::drawAndStencilRect(const GrClip&amp; clip,</span>
<span class="lineNum">     688 </span>            :                                                    const GrUserStencilSettings* ss,
<span class="lineNum">     689 </span>            :                                                    SkRegion::Op op,
<span class="lineNum">     690 </span>            :                                                    bool invert,
<span class="lineNum">     691 </span>            :                                                    GrAA aa,
<span class="lineNum">     692 </span>            :                                                    const SkMatrix&amp; viewMatrix,
<span class="lineNum">     693 </span>            :                                                    const SkRect&amp; rect) {
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     RETURN_FALSE_IF_ABANDONED_PRIV</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">     698 </span>            :                               &quot;GrRenderTargetContext::drawAndStencilRect&quot;);
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     GrPaint paint;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     paint.setCoverageSetOpXPFactory(op, invert);</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     if (fRenderTargetContext-&gt;drawFilledRect(clip, std::move(paint), aa, viewMatrix, rect, ss)) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     707 </span>            :     }
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     path.addRect(rect);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     return this-&gt;drawAndStencilPath(clip, ss, op, invert, aa, viewMatrix, path);</span>
<a name="712"><span class="lineNum">     712 </span>            : }</a>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::fillRectToRect(const GrClip&amp; clip,</span>
<span class="lineNum">     715 </span>            :                                            GrPaint&amp;&amp; paint,
<span class="lineNum">     716 </span>            :                                            GrAA aa,
<span class="lineNum">     717 </span>            :                                            const SkMatrix&amp; viewMatrix,
<span class="lineNum">     718 </span>            :                                            const SkRect&amp; rectToDraw,
<span class="lineNum">     719 </span>            :                                            const SkRect&amp; localRect) {
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::fillRectToRect&quot;);</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     SkRect croppedRect = rectToDraw;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     SkRect croppedLocalRect = localRect;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     if (!crop_filled_rect(this-&gt;width(), this-&gt;height(), clip, viewMatrix,</span>
<span class="lineNum">     728 </span>            :                           &amp;croppedRect, &amp;croppedLocalRect)) {
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     730 </span>            :     }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport()) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrDrawOp&gt; op(ir-&gt;recordRect(croppedRect, viewMatrix, std::move(paint),</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :                                                     croppedLocalRect, aa, fInstancedPipelineInfo));</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(clip, std::move(op));</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     741 </span>            :         }
<span class="lineNum">     742 </span>            :     }
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage != aaType) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         this-&gt;drawNonAAFilledRect(clip, std::move(paint), viewMatrix, croppedRect,</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                                   &amp;croppedLocalRect, nullptr, nullptr, aaType);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     if (view_matrix_ok_for_aa_fill_rect(viewMatrix)) {</span>
<span class="lineNum">     752 </span>            :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrAAFillRectOp::MakeWithLocalRect(
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                 paint.getColor(), viewMatrix, croppedRect, croppedLocalRect);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     757 </span>            :     }
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :     SkMatrix viewAndUnLocalMatrix;
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     if (!viewAndUnLocalMatrix.setRectToRect(localRect, rectToDraw, SkMatrix::kFill_ScaleToFit)) {</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;fillRectToRect called with empty local matrix.\n&quot;);</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     763 </span>            :     }
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     viewAndUnLocalMatrix.postConcat(viewMatrix);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     path.addRect(localRect);</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewAndUnLocalMatrix, path, GrStyle());</span>
<a name="770"><span class="lineNum">     770 </span>            : }</a>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::fillRectWithLocalMatrix(const GrClip&amp; clip,</span>
<span class="lineNum">     773 </span>            :                                                     GrPaint&amp;&amp; paint,
<span class="lineNum">     774 </span>            :                                                     GrAA aa,
<span class="lineNum">     775 </span>            :                                                     const SkMatrix&amp; viewMatrix,
<span class="lineNum">     776 </span>            :                                                     const SkRect&amp; rectToDraw,
<span class="lineNum">     777 </span>            :                                                     const SkMatrix&amp; localMatrix) {
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::fillRectWithLocalMatrix&quot;);</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     SkRect croppedRect = rectToDraw;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     if (!crop_filled_rect(this-&gt;width(), this-&gt;height(), clip, viewMatrix, &amp;croppedRect)) {</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     786 </span>            :     }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport()) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         std::unique_ptr&lt;GrDrawOp&gt; op(ir-&gt;recordRect(croppedRect, viewMatrix, std::move(paint),</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                                                     localMatrix, aa, fInstancedPipelineInfo));</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(clip, std::move(op));</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     797 </span>            :         }
<span class="lineNum">     798 </span>            :     }
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage != aaType) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         this-&gt;drawNonAAFilledRect(clip, std::move(paint), viewMatrix, croppedRect, nullptr,</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                                   &amp;localMatrix, nullptr, aaType);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     805 </span>            :     }
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     if (view_matrix_ok_for_aa_fill_rect(viewMatrix)) {</span>
<span class="lineNum">     808 </span>            :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 GrAAFillRectOp::Make(paint.getColor(), viewMatrix, localMatrix, croppedRect);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :         this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :     SkMatrix viewAndUnLocalMatrix;
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     if (!localMatrix.invert(&amp;viewAndUnLocalMatrix)) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;fillRectWithLocalMatrix called with degenerate local matrix.\n&quot;);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     819 </span>            :     }
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     viewAndUnLocalMatrix.postConcat(viewMatrix);</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     path.addRect(rectToDraw);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     path.transform(localMatrix);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewAndUnLocalMatrix, path, GrStyle());</span>
<a name="827"><span class="lineNum">     827 </span>            : }</a>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawVertices(const GrClip&amp; clip,</span>
<span class="lineNum">     830 </span>            :                                          GrPaint&amp;&amp; paint,
<span class="lineNum">     831 </span>            :                                          const SkMatrix&amp; viewMatrix,
<span class="lineNum">     832 </span>            :                                          GrPrimitiveType primitiveType,
<span class="lineNum">     833 </span>            :                                          int vertexCount,
<span class="lineNum">     834 </span>            :                                          const SkPoint positions[],
<span class="lineNum">     835 </span>            :                                          const SkPoint texCoords[],
<span class="lineNum">     836 </span>            :                                          const uint32_t colors[],
<span class="lineNum">     837 </span>            :                                          const uint16_t indices[],
<span class="lineNum">     838 </span>            :                                          int indexCount,
<span class="lineNum">     839 </span>            :                                          ColorArrayType colorArrayType) {
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawVertices&quot;);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     // TODO clients should give us bounds
<span class="lineNum">     848 </span>            :     SkRect bounds;
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if (!bounds.setBoundsCheck(positions, vertexCount)) {</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;drawVertices call empty bounds\n&quot;);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     852 </span>            :     }
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrDrawVerticesOp::Make(
<span class="lineNum">     855 </span>            :             paint.getColor(), primitiveType, viewMatrix, positions, vertexCount, indices,
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :             indexCount, colors, texCoords, bounds, colorArrayType);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     if (!op) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<a name="862"><span class="lineNum">     862 </span>            : }</a>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawVertices(const GrClip&amp; clip,</span>
<span class="lineNum">     865 </span>            :                                          GrPaint&amp;&amp; paint,
<span class="lineNum">     866 </span>            :                                          const SkMatrix&amp; viewMatrix,
<span class="lineNum">     867 </span>            :                                          sk_sp&lt;SkVertices&gt; vertices) {
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawVertices&quot;);</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     SkASSERT(vertices);</span>
<span class="lineNum">     876 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :             GrDrawVerticesOp::Make(paint.getColor(), std::move(vertices), viewMatrix);</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     if (!op) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     883 </span>            : }
<span class="lineNum">     884 </span>            : 
<a name="885"><span class="lineNum">     885 </span>            : ///////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawAtlas(const GrClip&amp; clip,</span>
<span class="lineNum">     888 </span>            :                                       GrPaint&amp;&amp; paint,
<span class="lineNum">     889 </span>            :                                       const SkMatrix&amp; viewMatrix,
<span class="lineNum">     890 </span>            :                                       int spriteCount,
<span class="lineNum">     891 </span>            :                                       const SkRSXform xform[],
<span class="lineNum">     892 </span>            :                                       const SkRect texRect[],
<span class="lineNum">     893 </span>            :                                       const SkColor colors[]) {
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawAtlas&quot;);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             GrDrawAtlasOp::Make(paint.getColor(), viewMatrix, spriteCount, xform, texRect, colors);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">     905 </span>            : }
<span class="lineNum">     906 </span>            : 
<a name="907"><span class="lineNum">     907 </span>            : ///////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawRRect(const GrClip&amp; origClip,</span>
<span class="lineNum">     910 </span>            :                                       GrPaint&amp;&amp; paint,
<span class="lineNum">     911 </span>            :                                       GrAA aa,
<span class="lineNum">     912 </span>            :                                       const SkMatrix&amp; viewMatrix,
<span class="lineNum">     913 </span>            :                                       const SkRRect&amp; rrect,
<span class="lineNum">     914 </span>            :                                       const GrStyle&amp; style) {
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawRRect&quot;);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     if (rrect.isEmpty()) {</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :        return;</span>
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     GrNoClip noclip;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     const GrClip* clip = &amp;origClip;</span>
<span class="lineNum">     925 </span>            : #ifdef SK_BUILD_FOR_ANDROID_FRAMEWORK
<span class="lineNum">     926 </span>            :     // The Android framework frequently clips rrects to themselves where the clip is non-aa and the
<span class="lineNum">     927 </span>            :     // draw is aa. Since our lower level clip code works from op bounds, which are SkRects, it
<span class="lineNum">     928 </span>            :     // doesn't detect that the clip can be ignored (modulo antialiasing). The following test
<span class="lineNum">     929 </span>            :     // attempts to mitigate the stencil clip cost but will only help when the entire clip stack
<span class="lineNum">     930 </span>            :     // can be ignored. We'd prefer to fix this in the framework by removing the clips calls.
<span class="lineNum">     931 </span>            :     SkRRect devRRect;
<span class="lineNum">     932 </span>            :     if (rrect.transform(viewMatrix, &amp;devRRect) &amp;&amp; clip-&gt;quickContains(devRRect)) {
<span class="lineNum">     933 </span>            :         clip = &amp;noclip;
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span>            : #endif
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     SkASSERT(!style.pathEffect()); // this should've been devolved to a path in SkGpuDevice</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     const SkStrokeRec stroke = style.strokeRec();</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport() &amp;&amp;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :         stroke.isFillStyle()) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">     944 </span>            :         std::unique_ptr&lt;GrDrawOp&gt; op(
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                 ir-&gt;recordRRect(rrect, viewMatrix, std::move(paint), aa, fInstancedPipelineInfo));</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(*clip, std::move(op));</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     949 </span>            :         }
<span class="lineNum">     950 </span>            :     }
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         const GrShaderCaps* shaderCaps = fContext-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">     955 </span>            :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">     956 </span>            :                 GrOvalOpFactory::MakeRRectOp(paint.getColor(),
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                                              paint.usesDistanceVectorField(),</span>
<span class="lineNum">     958 </span>            :                                              viewMatrix,
<span class="lineNum">     959 </span>            :                                              rrect,
<span class="lineNum">     960 </span>            :                                              stroke,
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                                              shaderCaps);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :             this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), *clip, std::move(op));</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     966 </span>            :         }
<span class="lineNum">     967 </span>            :     }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     path.addRRect(rrect);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(*clip, std::move(paint), aa, viewMatrix, path, style);</span>
<span class="lineNum">     973 </span>            : }
<span class="lineNum">     974 </span>            : 
<a name="975"><span class="lineNum">     975 </span>            : ///////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawShadowRRect(const GrClip&amp; clip,</span>
<span class="lineNum">     978 </span>            :                                             GrPaint&amp;&amp; paint,
<span class="lineNum">     979 </span>            :                                             const SkMatrix&amp; viewMatrix,
<span class="lineNum">     980 </span>            :                                             const SkRRect&amp; rrect,
<span class="lineNum">     981 </span>            :                                             SkScalar blurRadius,
<span class="lineNum">     982 </span>            :                                             const GrStyle&amp; style) {
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawShadowRRect&quot;);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     if (rrect.isEmpty()) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     989 </span>            :     }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     SkASSERT(!style.pathEffect()); // this should've been devolved to a path in SkGpuDevice</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     const SkStrokeRec stroke = style.strokeRec();</span>
<span class="lineNum">     995 </span>            :     // TODO: add instancing support?
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     const GrShaderCaps* shaderCaps = fContext-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">     998 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrShadowRRectOp::Make(
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :             paint.getColor(), viewMatrix, rrect, blurRadius, stroke, shaderCaps);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     if (op) {</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span>            : }
<span class="lineNum">    1006 </span>            : 
<a name="1007"><span class="lineNum">    1007 </span>            : ///////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 : bool GrRenderTargetContext::drawFilledDRRect(const GrClip&amp; clip,</span>
<span class="lineNum">    1010 </span>            :                                              GrPaint&amp;&amp; paint,
<span class="lineNum">    1011 </span>            :                                              GrAA aa,
<span class="lineNum">    1012 </span>            :                                              const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1013 </span>            :                                              const SkRRect&amp; origOuter,
<span class="lineNum">    1014 </span>            :                                              const SkRRect&amp; origInner) {
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     SkASSERT(!origInner.isEmpty());</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     SkASSERT(!origOuter.isEmpty());</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport()) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">    1020 </span>            :         std::unique_ptr&lt;GrDrawOp&gt; op(ir-&gt;recordDRRect(
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                 origOuter, origInner, viewMatrix, std::move(paint), aa, fInstancedPipelineInfo));</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(clip, std::move(op));</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    1025 </span>            :         }
<span class="lineNum">    1026 </span>            :     }
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :     GrPrimitiveEdgeType innerEdgeType, outerEdgeType;
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :         innerEdgeType = kInverseFillAA_GrProcessorEdgeType;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :         outerEdgeType = kFillAA_GrProcessorEdgeType;</span>
<span class="lineNum">    1034 </span>            :     } else {
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         innerEdgeType = kInverseFillBW_GrProcessorEdgeType;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :         outerEdgeType = kFillBW_GrProcessorEdgeType;</span>
<span class="lineNum">    1037 </span>            :     }
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     SkTCopyOnFirstWrite&lt;SkRRect&gt; inner(origInner), outer(origOuter);</span>
<span class="lineNum">    1040 </span>            :     SkMatrix inverseVM;
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     if (!viewMatrix.isIdentity()) {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         if (!origInner.transform(viewMatrix, inner.writable())) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1044 </span>            :         }
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :         if (!origOuter.transform(viewMatrix, outer.writable())) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1047 </span>            :         }
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         if (!viewMatrix.invert(&amp;inverseVM)) {</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1050 </span>            :         }
<span class="lineNum">    1051 </span>            :     } else {
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :         inverseVM.reset();</span>
<span class="lineNum">    1053 </span>            :     }
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :     // TODO these need to be a geometry processors
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     sk_sp&lt;GrFragmentProcessor&gt; innerEffect(GrRRectEffect::Make(innerEdgeType, *inner));</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     if (!innerEffect) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1059 </span>            :     }
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     sk_sp&lt;GrFragmentProcessor&gt; outerEffect(GrRRectEffect::Make(outerEdgeType, *outer));</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     if (!outerEffect) {</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1064 </span>            :     }
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     paint.addCoverageFragmentProcessor(std::move(innerEffect));</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     paint.addCoverageFragmentProcessor(std::move(outerEffect));</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     SkRect bounds = outer-&gt;getBounds();</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         bounds.outset(SK_ScalarHalf, SK_ScalarHalf);</span>
<span class="lineNum">    1072 </span>            :     }
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     this-&gt;fillRectWithLocalMatrix(clip, std::move(paint), GrAA::kNo, SkMatrix::I(), bounds,</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                                   inverseVM);</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1077"><span class="lineNum">    1077 </span>            : }</a>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawDRRect(const GrClip&amp; clip,</span>
<span class="lineNum">    1080 </span>            :                                        GrPaint&amp;&amp; paint,
<span class="lineNum">    1081 </span>            :                                        GrAA aa,
<span class="lineNum">    1082 </span>            :                                        const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1083 </span>            :                                        const SkRRect&amp; outer,
<span class="lineNum">    1084 </span>            :                                        const SkRRect&amp; inner) {
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawDRRect&quot;);</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     SkASSERT(!outer.isEmpty());</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     SkASSERT(!inner.isEmpty());</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     if (this-&gt;drawFilledDRRect(clip, std::move(paint), aa, viewMatrix, outer, inner)) {</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     path.addRRect(inner);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     path.addRRect(outer);</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :     path.setFillType(SkPath::kEvenOdd_FillType);</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewMatrix, path, GrStyle::SimpleFill());</span>
<span class="lineNum">    1106 </span>            : }
<span class="lineNum">    1107 </span>            : 
<a name="1108"><span class="lineNum">    1108 </span>            : ///////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 : static inline bool is_int(float x) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     return x == (float) sk_float_round2int(x);</span>
<a name="1112"><span class="lineNum">    1112 </span>            : }</a>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawRegion(const GrClip&amp; clip,</span>
<span class="lineNum">    1115 </span>            :                                        GrPaint&amp;&amp; paint,
<span class="lineNum">    1116 </span>            :                                        GrAA aa,
<span class="lineNum">    1117 </span>            :                                        const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1118 </span>            :                                        const SkRegion&amp; region,
<span class="lineNum">    1119 </span>            :                                        const GrStyle&amp; style) {
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawRegion&quot;);</span>
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     if (GrAA::kYes == aa) {</span>
<span class="lineNum">    1126 </span>            :         // GrRegionOp performs no antialiasing but is much faster, so here we check the matrix
<span class="lineNum">    1127 </span>            :         // to see whether aa is really required.
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         if (!SkToBool(viewMatrix.getType() &amp; ~(SkMatrix::kTranslate_Mask)) &amp;&amp;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :             is_int(viewMatrix.getTranslateX()) &amp;&amp;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             is_int(viewMatrix.getTranslateY())) {</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :             aa = GrAA::kNo;</span>
<span class="lineNum">    1132 </span>            :         }
<span class="lineNum">    1133 </span>            :     }
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     bool complexStyle = !style.isSimpleFill();</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     if (complexStyle || GrAA::kYes == aa) {</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         SkPath path;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         region.getBoundaryPath(&amp;path);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         return this-&gt;drawPath(clip, std::move(paint), aa, viewMatrix, path, style);</span>
<span class="lineNum">    1139 </span>            :     }
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrRegionOp::Make(paint.getColor(), viewMatrix, region);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<a name="1144"><span class="lineNum">    1144 </span>            : }</a>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawOval(const GrClip&amp; clip,</span>
<span class="lineNum">    1147 </span>            :                                      GrPaint&amp;&amp; paint,
<span class="lineNum">    1148 </span>            :                                      GrAA aa,
<span class="lineNum">    1149 </span>            :                                      const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1150 </span>            :                                      const SkRect&amp; oval,
<span class="lineNum">    1151 </span>            :                                      const GrStyle&amp; style) {
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawOval&quot;);</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     if (oval.isEmpty()) {</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :        return;</span>
<span class="lineNum">    1159 </span>            :     }
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     SkASSERT(!style.pathEffect()); // this should've been devolved to a path in SkGpuDevice</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :     const SkStrokeRec&amp; stroke = style.strokeRec();</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     if (GrCaps::InstancedSupport::kNone != fContext-&gt;caps()-&gt;instancedSupport() &amp;&amp;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         stroke.isFillStyle()) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         InstancedRendering* ir = this-&gt;getOpList()-&gt;instancedRendering();</span>
<span class="lineNum">    1169 </span>            :         std::unique_ptr&lt;GrDrawOp&gt; op(
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                 ir-&gt;recordOval(oval, viewMatrix, std::move(paint), aa, fInstancedPipelineInfo));</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :             this-&gt;addDrawOp(clip, std::move(op));</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1174 </span>            :         }
<span class="lineNum">    1175 </span>            :     }
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         const GrShaderCaps* shaderCaps = fContext-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">    1180 </span>            :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                 GrOvalOpFactory::MakeOvalOp(paint.getColor(), viewMatrix, oval, stroke, shaderCaps);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :             GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :             this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1186 </span>            :         }
<span class="lineNum">    1187 </span>            :     }
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     path.setIsVolatile(true);</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :     path.addOval(oval);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewMatrix, path, style);</span>
<a name="1193"><span class="lineNum">    1193 </span>            : }</a>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawArc(const GrClip&amp; clip,</span>
<span class="lineNum">    1196 </span>            :                                     GrPaint&amp;&amp; paint,
<span class="lineNum">    1197 </span>            :                                     GrAA aa,
<span class="lineNum">    1198 </span>            :                                     const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1199 </span>            :                                     const SkRect&amp; oval,
<span class="lineNum">    1200 </span>            :                                     SkScalar startAngle,
<span class="lineNum">    1201 </span>            :                                     SkScalar sweepAngle,
<span class="lineNum">    1202 </span>            :                                     bool useCenter,
<span class="lineNum">    1203 </span>            :                                     const GrStyle&amp; style) {
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawArc&quot;);</span>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType) {</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :         const GrShaderCaps* shaderCaps = fContext-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">    1214 </span>            :         std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrOvalOpFactory::MakeArcOp(paint.getColor(),
<span class="lineNum">    1215 </span>            :                                                                             viewMatrix,
<span class="lineNum">    1216 </span>            :                                                                             oval,
<span class="lineNum">    1217 </span>            :                                                                             startAngle,
<span class="lineNum">    1218 </span>            :                                                                             sweepAngle,
<span class="lineNum">    1219 </span>            :                                                                             useCenter,
<span class="lineNum">    1220 </span>            :                                                                             style,
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                                                                             shaderCaps);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         if (op) {</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :             GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :             this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1226 </span>            :         }
<span class="lineNum">    1227 </span>            :     }
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     SkPath path;</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     SkPathPriv::CreateDrawArcPath(&amp;path, oval, startAngle, sweepAngle, useCenter,</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :                                   style.isSimpleFill());</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewMatrix, path, style);</span>
<a name="1232"><span class="lineNum">    1232 </span>            : }</a>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawImageLattice(const GrClip&amp; clip,</span>
<span class="lineNum">    1235 </span>            :                                              GrPaint&amp;&amp; paint,
<span class="lineNum">    1236 </span>            :                                              const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1237 </span>            :                                              int imageWidth,
<span class="lineNum">    1238 </span>            :                                              int imageHeight,
<span class="lineNum">    1239 </span>            :                                              std::unique_ptr&lt;SkLatticeIter&gt; iter,
<span class="lineNum">    1240 </span>            :                                              const SkRect&amp; dst) {
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawImageLattice&quot;);</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrLatticeOp::MakeNonAA(
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :             paint.getColor(), viewMatrix, imageWidth, imageHeight, std::move(iter), dst);</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), GrAAType::kNone);</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<a name="1253"><span class="lineNum">    1253 </span>            : }</a>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::prepareForExternalIO() {</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::prepareForExternalIO&quot;);</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     this-&gt;drawingManager()-&gt;prepareSurfaceForExternalIO(fRenderTargetProxy.get());</span>
<a name="1262"><span class="lineNum">    1262 </span>            : }</a>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawNonAAFilledRect(const GrClip&amp; clip,</span>
<span class="lineNum">    1265 </span>            :                                                 GrPaint&amp;&amp; paint,
<span class="lineNum">    1266 </span>            :                                                 const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1267 </span>            :                                                 const SkRect&amp; rect,
<span class="lineNum">    1268 </span>            :                                                 const SkRect* localRect,
<span class="lineNum">    1269 </span>            :                                                 const SkMatrix* localMatrix,
<span class="lineNum">    1270 </span>            :                                                 const GrUserStencilSettings* ss,
<span class="lineNum">    1271 </span>            :                                                 GrAAType hwOrNoneAAType) {
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     SkASSERT(GrAAType::kCoverage != hwOrNoneAAType);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :     SkASSERT(hwOrNoneAAType == GrAAType::kNone || this-&gt;isStencilBufferMultisampled());</span>
<span class="lineNum">    1274 </span>            :     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrRectOpFactory::MakeNonAAFill(
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :             paint.getColor(), viewMatrix, rect, localRect, localMatrix);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :     GrPipelineBuilder pipelineBuilder(std::move(paint), hwOrNoneAAType);</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :     if (ss) {</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         pipelineBuilder.setUserStencil(ss);</span>
<span class="lineNum">    1279 </span>            :     }
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 : }</span>
<a name="1282"><span class="lineNum">    1282 </span>            : </a>
<span class="lineNum">    1283 </span>            : // Can 'path' be drawn as a pair of filled nested rectangles?
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 : static bool fills_as_nested_rects(const SkMatrix&amp; viewMatrix, const SkPath&amp; path, SkRect rects[2]) {</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :     if (path.isInverseFillType()) {</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1288 </span>            :     }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            :     // TODO: this restriction could be lifted if we were willing to apply
<span class="lineNum">    1291 </span>            :     // the matrix to all the points individually rather than just to the rect
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     if (!viewMatrix.rectStaysRect()) {</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1294 </span>            :     }
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            :     SkPath::Direction dirs[2];
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     if (!path.isNestedFillRects(rects, dirs)) {</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     if (SkPath::kWinding_FillType == path.getFillType() &amp;&amp; dirs[0] == dirs[1]) {</span>
<span class="lineNum">    1302 </span>            :         // The two rects need to be wound opposite to each other
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1304 </span>            :     }
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :     // Right now, nested rects where the margin is not the same width
<span class="lineNum">    1307 </span>            :     // all around do not render correctly
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     const SkScalar* outer = rects[0].asScalars();</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     const SkScalar* inner = rects[1].asScalars();</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     bool allEq = true;</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     SkScalar margin = SkScalarAbs(outer[0] - inner[0]);</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     bool allGoE1 = margin &gt;= SK_Scalar1;</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     for (int i = 1; i &lt; 4; ++i) {</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         SkScalar temp = SkScalarAbs(outer[i] - inner[i]);</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         if (temp &lt; SK_Scalar1) {</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :             allGoE1 = false;</span>
<span class="lineNum">    1320 </span>            :         }
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         if (!SkScalarNearlyEqual(margin, temp)) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :             allEq = false;</span>
<span class="lineNum">    1323 </span>            :         }
<span class="lineNum">    1324 </span>            :     }
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     return allEq || allGoE1;</span>
<a name="1327"><span class="lineNum">    1327 </span>            : }</a>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::drawPath(const GrClip&amp; clip,</span>
<span class="lineNum">    1330 </span>            :                                      GrPaint&amp;&amp; paint,
<span class="lineNum">    1331 </span>            :                                      GrAA aa,
<span class="lineNum">    1332 </span>            :                                      const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1333 </span>            :                                      const SkPath&amp; path,
<span class="lineNum">    1334 </span>            :                                      const GrStyle&amp; style) {
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::drawPath&quot;);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :     if (path.isEmpty()) {</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :        if (path.isInverseFillType()) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :            this-&gt;drawPaint(clip, std::move(paint), viewMatrix);</span>
<span class="lineNum">    1343 </span>            :        }
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :        return;</span>
<span class="lineNum">    1345 </span>            :     }
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(this-&gt;drawingManager());</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :     if (GrAAType::kCoverage == aaType &amp;&amp; !style.pathEffect()) {</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :         if (style.isSimpleFill() &amp;&amp; !path.isConvex()) {</span>
<span class="lineNum">    1352 </span>            :             // Concave AA paths are expensive - try to avoid them for special cases
<span class="lineNum">    1353 </span>            :             SkRect rects[2];
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :             if (fills_as_nested_rects(viewMatrix, path, rects)) {</span>
<span class="lineNum">    1356 </span>            :                 std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op =
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :                         GrRectOpFactory::MakeAAFillNestedRects(paint.getColor(), viewMatrix, rects);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :                 if (op) {</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :                     GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :                     this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1361 </span>            :                 }
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1363 </span>            :             }
<span class="lineNum">    1364 </span>            :         }
<span class="lineNum">    1365 </span>            :         SkRect ovalRect;
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :         bool isOval = path.isOval(&amp;ovalRect);</span>
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :         if (isOval &amp;&amp; !path.isInverseFillType()) {</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :             const GrShaderCaps* shaderCaps = fContext-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">    1370 </span>            :             std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op = GrOvalOpFactory::MakeOvalOp(
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :                     paint.getColor(), viewMatrix, ovalRect, style.strokeRec(), shaderCaps);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :             if (op) {</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :                 GrPipelineBuilder pipelineBuilder(std::move(paint), aaType);</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                 this-&gt;addLegacyMeshDrawOp(std::move(pipelineBuilder), clip, std::move(op));</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1376 </span>            :             }
<span class="lineNum">    1377 </span>            :         }
<span class="lineNum">    1378 </span>            :     }
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            :     // Note that internalDrawPath may sw-rasterize the path into a scratch texture.
<span class="lineNum">    1381 </span>            :     // Scratch textures can be recycled after they are returned to the texture
<span class="lineNum">    1382 </span>            :     // cache. This presents a potential hazard for buffered drawing. However,
<span class="lineNum">    1383 </span>            :     // the writePixels that uploads to the scratch will perform a flush so we're
<span class="lineNum">    1384 </span>            :     // OK.
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     this-&gt;internalDrawPath(clip, std::move(paint), aa, viewMatrix, path, style);</span>
<a name="1386"><span class="lineNum">    1386 </span>            : }</a>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 : bool GrRenderTargetContextPriv::drawAndStencilPath(const GrClip&amp; clip,</span>
<span class="lineNum">    1389 </span>            :                                                    const GrUserStencilSettings* ss,
<span class="lineNum">    1390 </span>            :                                                    SkRegion::Op op,
<span class="lineNum">    1391 </span>            :                                                    bool invert,
<span class="lineNum">    1392 </span>            :                                                    GrAA aa,
<span class="lineNum">    1393 </span>            :                                                    const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1394 </span>            :                                                    const SkPath&amp; path) {
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     RETURN_FALSE_IF_ABANDONED_PRIV</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fRenderTargetContext-&gt;fAuditTrail,</span>
<span class="lineNum">    1399 </span>            :                               &quot;GrRenderTargetContextPriv::drawAndStencilPath&quot;);
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     if (path.isEmpty() &amp;&amp; path.isInverseFillType()) {</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         this-&gt;drawAndStencilRect(clip, ss, op, invert, GrAA::kNo, SkMatrix::I(),</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :                                  SkRect::MakeIWH(fRenderTargetContext-&gt;width(),</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                                                  fRenderTargetContext-&gt;height()));</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1406 </span>            :     }
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     AutoCheckFlush acf(fRenderTargetContext-&gt;drawingManager());</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :     // An Assumption here is that path renderer would use some form of tweaking
<span class="lineNum">    1411 </span>            :     // the src color (either the input alpha or in the frag shader) to implement
<span class="lineNum">    1412 </span>            :     // aa. If we have some future driver-mojo path AA that can do the right
<span class="lineNum">    1413 </span>            :     // thing WRT to the blend then we'll need some query on the PR.
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     GrAAType aaType = fRenderTargetContext-&gt;decideAAType(aa);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     bool hasUserStencilSettings = !ss-&gt;isUnused();</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     GrShape shape(path, GrStyle::SimpleFill());</span>
<span class="lineNum">    1418 </span>            :     GrPathRenderer::CanDrawPathArgs canDrawArgs;
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     canDrawArgs.fShaderCaps =</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :         fRenderTargetContext-&gt;drawingManager()-&gt;getContext()-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     canDrawArgs.fViewMatrix = &amp;viewMatrix;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     canDrawArgs.fShape = &amp;shape;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :     canDrawArgs.fAAType = aaType;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :     canDrawArgs.fHasUserStencilSettings = hasUserStencilSettings;</span>
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :     // Don't allow the SW renderer
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     GrPathRenderer* pr = fRenderTargetContext-&gt;drawingManager()-&gt;getPathRenderer(</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :             canDrawArgs, false, GrPathRendererChain::DrawType::kStencilAndColor);</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     if (!pr) {</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1431 </span>            :     }
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     GrPaint paint;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     paint.setCoverageSetOpXPFactory(op, invert);</span>
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            :     GrPathRenderer::DrawPathArgs args{
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :             fRenderTargetContext-&gt;drawingManager()-&gt;getContext(),</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :             std::move(paint),</span>
<span class="lineNum">    1439 </span>            :             ss,
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :             fRenderTargetContext,</span>
<span class="lineNum">    1441 </span>            :             &amp;clip,
<span class="lineNum">    1442 </span>            :             &amp;viewMatrix,
<span class="lineNum">    1443 </span>            :             &amp;shape,
<span class="lineNum">    1444 </span>            :             aaType,
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :             fRenderTargetContext-&gt;isGammaCorrect()};</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     pr-&gt;drawPath(args);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1448"><span class="lineNum">    1448 </span>            : }</a>
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 : SkBudgeted GrRenderTargetContextPriv::isBudgeted() const {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER_PRIV</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     if (fRenderTargetContext-&gt;wasAbandoned()) {</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :         return SkBudgeted::kNo;</span>
<span class="lineNum">    1455 </span>            :     }
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(fRenderTargetContext-&gt;validate();)</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     return fRenderTargetContext-&gt;fRenderTargetProxy-&gt;isBudgeted();</span>
<a name="1460"><span class="lineNum">    1460 </span>            : }</a>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 : void GrRenderTargetContext::internalDrawPath(const GrClip&amp; clip,</span>
<span class="lineNum">    1463 </span>            :                                              GrPaint&amp;&amp; paint,
<span class="lineNum">    1464 </span>            :                                              GrAA aa,
<span class="lineNum">    1465 </span>            :                                              const SkMatrix&amp; viewMatrix,
<span class="lineNum">    1466 </span>            :                                              const SkPath&amp; path,
<span class="lineNum">    1467 </span>            :                                              const GrStyle&amp; style) {
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     RETURN_IF_ABANDONED</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     SkASSERT(!path.isEmpty());</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     GrShape shape;</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     GrAAType aaType = this-&gt;decideAAType(aa, /*allowMixedSamples*/ true);</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :     if (style.isSimpleHairline() &amp;&amp; aaType == GrAAType::kMixedSamples) {</span>
<span class="lineNum">    1475 </span>            :         // NVPR cannot handle hairlines, so this will would get picked up by a different stencil and
<span class="lineNum">    1476 </span>            :         // cover path renderer (i.e. default path renderer). The hairline renderer produces much
<span class="lineNum">    1477 </span>            :         // smoother hairlines than MSAA.
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         aaType = GrAAType::kCoverage;</span>
<span class="lineNum">    1479 </span>            :     }
<span class="lineNum">    1480 </span>            :     GrPathRenderer::CanDrawPathArgs canDrawArgs;
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :     canDrawArgs.fShaderCaps = this-&gt;drawingManager()-&gt;getContext()-&gt;caps()-&gt;shaderCaps();</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     canDrawArgs.fViewMatrix = &amp;viewMatrix;</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :     canDrawArgs.fShape = &amp;shape;</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :     canDrawArgs.fHasUserStencilSettings = false;</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            :     GrPathRenderer* pr;
<span class="lineNum">    1487 </span>            :     static constexpr GrPathRendererChain::DrawType kType = GrPathRendererChain::DrawType::kColor;
<span class="lineNum">    1488 </span>            :     do {
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :         shape = GrShape(path, style);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         if (shape.isEmpty()) {</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1492 </span>            :         }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         canDrawArgs.fAAType = aaType;</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :         // Try a 1st time without applying any of the style to the geometry (and barring sw)
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :         pr = this-&gt;drawingManager()-&gt;getPathRenderer(canDrawArgs, false, kType);</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :         SkScalar styleScale =  GrStyle::MatrixToScaleFactor(viewMatrix);</span>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         if (!pr &amp;&amp; shape.style().pathEffect()) {</span>
<span class="lineNum">    1501 </span>            :             // It didn't work above, so try again with the path effect applied.
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :             shape = shape.applyStyle(GrStyle::Apply::kPathEffectOnly, styleScale);</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :             if (shape.isEmpty()) {</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1505 </span>            :             }
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :             pr = this-&gt;drawingManager()-&gt;getPathRenderer(canDrawArgs, false, kType);</span>
<span class="lineNum">    1507 </span>            :         }
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :         if (!pr) {</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :             if (shape.style().applies()) {</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :                 shape = shape.applyStyle(GrStyle::Apply::kPathEffectAndStrokeRec, styleScale);</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                 if (shape.isEmpty()) {</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1513 </span>            :                 }
<span class="lineNum">    1514 </span>            :             }
<span class="lineNum">    1515 </span>            :             // This time, allow SW renderer
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :             pr = this-&gt;drawingManager()-&gt;getPathRenderer(canDrawArgs, true, kType);</span>
<span class="lineNum">    1517 </span>            :         }
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :         if (!pr &amp;&amp; GrAATypeIsHW(aaType)) {</span>
<span class="lineNum">    1519 </span>            :             // There are exceptional cases where we may wind up falling back to coverage based AA
<span class="lineNum">    1520 </span>            :             // when the target is MSAA (e.g. through disabling path renderers via GrContextOptions).
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :             aaType = GrAAType::kCoverage;</span>
<span class="lineNum">    1522 </span>            :         } else {
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1525 </span>            :     } while(true);
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     if (!pr) {</span>
<span class="lineNum">    1528 </span>            : #ifdef SK_DEBUG
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;Unable to find path renderer compatible with path.\n&quot;);</span>
<span class="lineNum">    1530 </span>            : #endif
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1532 </span>            :     }
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :     GrPathRenderer::DrawPathArgs args{this-&gt;drawingManager()-&gt;getContext(),</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :                                       std::move(paint),</span>
<span class="lineNum">    1536 </span>            :                                       &amp;GrUserStencilSettings::kUnused,
<span class="lineNum">    1537 </span>            :                                       this,
<span class="lineNum">    1538 </span>            :                                       &amp;clip,
<span class="lineNum">    1539 </span>            :                                       &amp;viewMatrix,
<span class="lineNum">    1540 </span>            :                                       &amp;shape,
<span class="lineNum">    1541 </span>            :                                       aaType,
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :                                       this-&gt;isGammaCorrect()};</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     pr-&gt;drawPath(args);</span>
<a name="1544"><span class="lineNum">    1544 </span>            : }</a>
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 : static void op_bounds(SkRect* bounds, const GrOp* op) {</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :     *bounds = op-&gt;bounds();</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :     if (op-&gt;hasZeroArea()) {</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :         if (op-&gt;hasAABloat()) {</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :             bounds-&gt;outset(0.5f, 0.5f);</span>
<span class="lineNum">    1551 </span>            :         } else {
<span class="lineNum">    1552 </span>            :             // We don't know which way the particular GPU will snap lines or points at integer
<span class="lineNum">    1553 </span>            :             // coords. So we ensure that the bounds is large enough for either snap.
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :             SkRect before = *bounds;</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :             bounds-&gt;roundOut(bounds);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :             if (bounds-&gt;fLeft == before.fLeft) {</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :                 bounds-&gt;fLeft -= 1;</span>
<span class="lineNum">    1558 </span>            :             }
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :             if (bounds-&gt;fTop == before.fTop) {</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                 bounds-&gt;fTop -= 1;</span>
<span class="lineNum">    1561 </span>            :             }
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :             if (bounds-&gt;fRight == before.fRight) {</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :                 bounds-&gt;fRight += 1;</span>
<span class="lineNum">    1564 </span>            :             }
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :             if (bounds-&gt;fBottom == before.fBottom) {</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :                 bounds-&gt;fBottom += 1;</span>
<span class="lineNum">    1567 </span>            :             }
<span class="lineNum">    1568 </span>            :         }
<span class="lineNum">    1569 </span>            :     }
<a name="1570"><span class="lineNum">    1570 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 : uint32_t GrRenderTargetContext::addDrawOp(const GrClip&amp; clip, std::unique_ptr&lt;GrDrawOp&gt; op) {</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     if (this-&gt;drawingManager()-&gt;wasAbandoned()) {</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1576 </span>            :     }
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::addDrawOp&quot;);</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :     // Setup clip
<span class="lineNum">    1581 </span>            :     SkRect bounds;
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     op_bounds(&amp;bounds, op.get());</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     GrAppliedClip appliedClip;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     GrDrawOp::FixedFunctionFlags fixedFunctionFlags = op-&gt;fixedFunctionFlags();</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     if (!clip.apply(fContext, this, fixedFunctionFlags &amp; GrDrawOp::FixedFunctionFlags::kUsesHWAA,</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                     fixedFunctionFlags &amp; GrDrawOp::FixedFunctionFlags::kUsesStencil, &amp;appliedClip,</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                     &amp;bounds)) {</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1589 </span>            :     }
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            :     // This forces instantiation of the render target.
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     GrRenderTarget* rt = this-&gt;accessRenderTarget();</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :     if (!rt) {</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1595 </span>            :     }
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     if (fixedFunctionFlags &amp; GrDrawOp::FixedFunctionFlags::kUsesStencil ||</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :         appliedClip.hasStencilClip()) {</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         if (!fContext-&gt;resourceProvider()-&gt;attachStencilAttachment(rt)) {</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :             SkDebugf(&quot;ERROR creating stencil attachment. Draw skipped.\n&quot;);</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :             return SK_InvalidUniqueID;</span>
<span class="lineNum">    1602 </span>            :         }
<span class="lineNum">    1603 </span>            :     }
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     GrXferProcessor::DstTexture dstTexture;</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :     if (op-&gt;xpRequiresDstTexture(*this-&gt;caps(), &amp;appliedClip)) {</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :         if (!this-&gt;setupDstTexture(fRenderTargetProxy.get(), clip, op-&gt;bounds(), &amp;dstTexture)) {</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :             return SK_InvalidUniqueID;</span>
<span class="lineNum">    1609 </span>            :         }
<span class="lineNum">    1610 </span>            :     }
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     op-&gt;setClippedBounds(bounds);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     return this-&gt;getOpList()-&gt;addOp(std::move(op), this, std::move(appliedClip), dstTexture);</span>
<a name="1614"><span class="lineNum">    1614 </span>            : }</a>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 : uint32_t GrRenderTargetContext::addLegacyMeshDrawOp(GrPipelineBuilder&amp;&amp; pipelineBuilder,</span>
<span class="lineNum">    1617 </span>            :                                                     const GrClip&amp; clip,
<span class="lineNum">    1618 </span>            :                                                     std::unique_ptr&lt;GrLegacyMeshDrawOp&gt; op) {
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     ASSERT_SINGLE_OWNER</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     if (this-&gt;drawingManager()-&gt;wasAbandoned()) {</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1622 </span>            :     }
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :     SkDEBUGCODE(this-&gt;validate();)</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     GR_AUDIT_TRAIL_AUTO_FRAME(fAuditTrail, &quot;GrRenderTargetContext::addLegacyMeshDrawOp&quot;);</span>
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :     // Setup clip
<span class="lineNum">    1627 </span>            :     SkRect bounds;
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     op_bounds(&amp;bounds, op.get());</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     GrAppliedClip appliedClip;</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     if (!clip.apply(fContext, this, pipelineBuilder.isHWAntialias(),</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :                     pipelineBuilder.hasUserStencilSettings(), &amp;appliedClip, &amp;bounds)) {</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1633 </span>            :     }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :     // This forces instantiation of the render target. Pipeline creation is moving to flush time
<span class="lineNum">    1636 </span>            :     // by which point instantiation must have occurred anyway.
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     GrRenderTarget* rt = this-&gt;accessRenderTarget();</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     if (!rt) {</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :         return SK_InvalidUniqueID;</span>
<span class="lineNum">    1640 </span>            :     }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     GrResourceProvider* resourceProvider = fContext-&gt;resourceProvider();</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :     bool usesStencil = pipelineBuilder.hasUserStencilSettings() || appliedClip.hasStencilClip();</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :     if (usesStencil) {</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :         if (!resourceProvider-&gt;attachStencilAttachment(this-&gt;accessRenderTarget())) {</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :             SkDebugf(&quot;ERROR creating stencil attachment. Draw skipped.\n&quot;);</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :             return SK_InvalidUniqueID;</span>
<span class="lineNum">    1648 </span>            :         }
<span class="lineNum">    1649 </span>            :     }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :     bool isMixedSamples = fRenderTargetProxy-&gt;isMixedSampled() &amp;&amp;</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :                           (pipelineBuilder.isHWAntialias() || usesStencil);</span>
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span>            :     GrColor overrideColor;
<span class="lineNum">    1655 </span>            :     GrProcessorSet::Analysis analysis = op-&gt;analyzeUpdateAndRecordProcessors(
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :             &amp;pipelineBuilder, &amp;appliedClip, isMixedSamples, *this-&gt;caps(), &amp;overrideColor);</span>
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     GrPipeline::InitArgs args;</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :     pipelineBuilder.getPipelineInitArgs(&amp;args);</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :     args.fAppliedClip = &amp;appliedClip;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     args.fRenderTarget = rt;</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :     args.fCaps = this-&gt;caps();</span>
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :     if (analysis.requiresDstTexture()) {</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :         if (!this-&gt;setupDstTexture(fRenderTargetProxy.get(), clip, bounds, &amp;args.fDstTexture)) {</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :             return SK_InvalidUniqueID;</span>
<span class="lineNum">    1667 </span>            :         }
<span class="lineNum">    1668 </span>            :     }
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     op-&gt;initPipeline(args, analysis, overrideColor);</span>
<span class="lineNum">    1670 </span>            :     // TODO: We need to add pipeline dependencies on textures, etc before recording this op.
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     op-&gt;setClippedBounds(bounds);</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     return this-&gt;getOpList()-&gt;addOp(std::move(op), this);</span>
<a name="1673"><span class="lineNum">    1673 </span>            : }</a>
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 : bool GrRenderTargetContext::setupDstTexture(GrRenderTargetProxy* rtProxy, const GrClip&amp; clip,</span>
<span class="lineNum">    1676 </span>            :                                             const SkRect&amp; opBounds,
<span class="lineNum">    1677 </span>            :                                             GrXferProcessor::DstTexture* dstTexture) {
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     if (this-&gt;caps()-&gt;textureBarrierSupport()) {</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :         if (GrTextureProxy* texProxy = rtProxy-&gt;asTextureProxy()) {</span>
<span class="lineNum">    1680 </span>            :             // MDB TODO: remove this instantiation. Blocked on making DstTexture be proxy-based
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :             sk_sp&lt;GrTexture&gt; tex(sk_ref_sp(texProxy-&gt;instantiate(fContext-&gt;resourceProvider())));</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :             if (!tex) {</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                 SkDebugf(&quot;setupDstTexture: instantiation of src texture failed.\n&quot;);</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :                 return false;  // We have bigger problems now</span>
<span class="lineNum">    1685 </span>            :             }
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span>            :             // The render target is a texture, so we can read from it directly in the shader. The XP
<span class="lineNum">    1688 </span>            :             // will be responsible to detect this situation and request a texture barrier.
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :             dstTexture-&gt;setTexture(std::move(tex));</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :             dstTexture-&gt;setOffset(0, 0);</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    1692 </span>            :         }
<span class="lineNum">    1693 </span>            :     }
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     SkIRect copyRect = SkIRect::MakeWH(rtProxy-&gt;width(), rtProxy-&gt;height());</span>
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            :     SkIRect clippedRect;
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :     clip.getConservativeBounds(rtProxy-&gt;width(), rtProxy-&gt;height(), &amp;clippedRect);</span>
<span class="lineNum">    1699 </span>            :     SkIRect drawIBounds;
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     opBounds.roundOut(&amp;drawIBounds);</span>
<span class="lineNum">    1701 </span>            :     // Cover up for any precision issues by outsetting the op bounds a pixel in each direction.
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :     drawIBounds.outset(1, 1);</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     if (!clippedRect.intersect(drawIBounds)) {</span>
<span class="lineNum">    1704 </span>            : #ifdef SK_DEBUG
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :         GrCapsDebugf(this-&gt;caps(), &quot;setupDstTexture: Missed an early reject bailing on draw.&quot;);</span>
<span class="lineNum">    1706 </span>            : #endif
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1708 </span>            :     }
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :     // MSAA consideration: When there is support for reading MSAA samples in the shader we could
<span class="lineNum">    1711 </span>            :     // have per-sample dst values by making the copy multisampled.
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     GrSurfaceDesc desc;</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :     bool rectsMustMatch = false;</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :     bool disallowSubrect = false;</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :     if (!this-&gt;caps()-&gt;initDescForDstCopy(rtProxy, &amp;desc, &amp;rectsMustMatch, &amp;disallowSubrect)) {</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :         desc.fOrigin = kBottomLeft_GrSurfaceOrigin;</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :         desc.fFlags = kRenderTarget_GrSurfaceFlag;</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :         desc.fConfig = rtProxy-&gt;config();</span>
<span class="lineNum">    1719 </span>            :     }
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :     if (!disallowSubrect) {</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :         copyRect = clippedRect;</span>
<span class="lineNum">    1723 </span>            :     }
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :     SkIPoint dstPoint, dstOffset;
<span class="lineNum">    1726 </span>            :     SkBackingFit fit;
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     if (rectsMustMatch) {</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :         SkASSERT(desc.fOrigin == rtProxy-&gt;origin());</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :         desc.fWidth = rtProxy-&gt;width();</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :         desc.fHeight = rtProxy-&gt;height();</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :         dstPoint = {copyRect.fLeft, copyRect.fTop};</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :         dstOffset = {0, 0};</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :         fit = SkBackingFit::kExact;</span>
<span class="lineNum">    1734 </span>            :     } else {
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :         desc.fWidth = copyRect.width();</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :         desc.fHeight = copyRect.height();</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :         dstPoint = {0, 0};</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :         dstOffset = {copyRect.fLeft, copyRect.fTop};</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :         fit = SkBackingFit::kApprox;</span>
<span class="lineNum">    1740 </span>            :     }
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     sk_sp&lt;GrSurfaceContext&gt; sContext = fContext-&gt;contextPriv().makeDeferredSurfaceContext(</span>
<span class="lineNum">    1743 </span>            :                                                                                 desc,
<span class="lineNum">    1744 </span>            :                                                                                 fit,
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :                                                                                 SkBudgeted::kYes);</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :     if (!sContext) {</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;setupDstTexture: surfaceContext creation failed.\n&quot;);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1749 </span>            :     }
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     if (!sContext-&gt;copy(rtProxy, copyRect, dstPoint)) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;setupDstTexture: copy failed.\n&quot;);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1754 </span>            :     }
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :     GrTextureProxy* copyProxy = sContext-&gt;asTextureProxy();</span>
<span class="lineNum">    1757 </span>            :     // MDB TODO: remove this instantiation once DstTexture is proxy-backed
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     sk_sp&lt;GrTexture&gt; copy(sk_ref_sp(copyProxy-&gt;instantiate(fContext-&gt;resourceProvider())));</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :     if (!copy) {</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :         SkDebugf(&quot;setupDstTexture: instantiation of copied texture failed.\n&quot;);</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1762 </span>            :     }
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :     dstTexture-&gt;setTexture(std::move(copy));</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     dstTexture-&gt;setOffset(dstOffset);</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1767 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

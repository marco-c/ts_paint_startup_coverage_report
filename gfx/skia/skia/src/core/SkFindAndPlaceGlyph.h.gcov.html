<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/core/SkFindAndPlaceGlyph.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/core</a> - SkFindAndPlaceGlyph.h<span style="font-size: 80%;"> (source / <a href="SkFindAndPlaceGlyph.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">101</td>
            <td class="headerCovTableEntry">260</td>
            <td class="headerCovTableEntryLo">38.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">58</td>
            <td class="headerCovTableEntry">285</td>
            <td class="headerCovTableEntryLo">20.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2015 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #ifndef SkFindAndPositionGlyph_DEFINED
<span class="lineNum">       9 </span>            : #define SkFindAndPositionGlyph_DEFINED
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;SkAutoKern.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SkGlyph.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SkGlyphCache.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;SkPaint.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SkTemplates.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;SkUtils.h&quot;
<span class="lineNum">      17 </span>            : #include &lt;utility&gt;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : // Calculate a type with the same size as the max of all the Ts.
<span class="lineNum">      20 </span>            : // This must be top level because the is no specialization of inner classes.
<span class="lineNum">      21 </span>            : template&lt;typename... Ts&gt; struct SkMaxSizeOf;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : template&lt;&gt;
<span class="lineNum">      24 </span>            : struct SkMaxSizeOf&lt;&gt; {
<span class="lineNum">      25 </span>            :     static const size_t value = 0;
<span class="lineNum">      26 </span>            : };
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : template&lt;typename H, typename... Ts&gt;
<span class="lineNum">      29 </span>            : struct SkMaxSizeOf&lt;H, Ts...&gt; {
<span class="lineNum">      30 </span>            :     static const size_t value =
<span class="lineNum">      31 </span>            :         sizeof(H) &gt;= SkMaxSizeOf&lt;Ts...&gt;::value ? sizeof(H) : SkMaxSizeOf&lt;Ts...&gt;::value;
<span class="lineNum">      32 </span>            : };
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : // This is a temporary helper function to work around a bug in the code generation
<span class="lineNum">      36 </span>            : // for aarch64 (arm) on GCC 4.9. This bug does not show up on other platforms, so it
<span class="lineNum">      37 </span>            : // seems to be an aarch64 backend problem.
<span class="lineNum">      38 </span>            : //
<span class="lineNum">      39 </span>            : // GCC 4.9 on ARM64 does not generate the proper constructor code for PositionReader or
<span class="lineNum">      40 </span>            : // GlyphFindAndPlace. The vtable is not set properly without adding the fixme code.
<span class="lineNum">      41 </span>            : // The implementation is in SkDraw.cpp.
<span class="lineNum">      42 </span>            : extern void FixGCC49Arm64Bug(int v);
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : class SkFindAndPlaceGlyph {
<span class="lineNum">      45 </span>            : public:
<span class="lineNum">      46 </span>            :     template&lt;typename ProcessOneGlyph&gt;
<span class="lineNum">      47 </span>            :     static void ProcessText(
<span class="lineNum">      48 </span>            :         SkPaint::TextEncoding, const char text[], size_t byteLength,
<span class="lineNum">      49 </span>            :         SkPoint offset, const SkMatrix&amp; matrix, SkPaint::Align textAlignment,
<span class="lineNum">      50 </span>            :         SkGlyphCache* cache, ProcessOneGlyph&amp;&amp; processOneGlyph);
<span class="lineNum">      51 </span>            :     // ProcessPosText handles all cases for finding and positioning glyphs. It has a very large
<span class="lineNum">      52 </span>            :     // multiplicity. It figures out the glyph, position and rounding and pass those parameters to
<span class="lineNum">      53 </span>            :     // processOneGlyph.
<span class="lineNum">      54 </span>            :     //
<span class="lineNum">      55 </span>            :     // The routine processOneGlyph passed in by the client has the following signature:
<span class="lineNum">      56 </span>            :     // void f(const SkGlyph&amp; glyph, SkPoint position, SkPoint rounding);
<span class="lineNum">      57 </span>            :     //
<span class="lineNum">      58 </span>            :     // * Sub-pixel positioning (2) - use sub-pixel positioning.
<span class="lineNum">      59 </span>            :     // * Text alignment (3) - text alignment with respect to the glyph's width.
<span class="lineNum">      60 </span>            :     // * Matrix type (3) - special cases for translation and X-coordinate scaling.
<span class="lineNum">      61 </span>            :     // * Components per position (2) - the positions vector can have a common Y with different
<span class="lineNum">      62 </span>            :     //   Xs, or XY-pairs.
<span class="lineNum">      63 </span>            :     // * Axis Alignment (for sub-pixel positioning) (3) - when using sub-pixel positioning, round
<span class="lineNum">      64 </span>            :     //   to a whole coordinate instead of using sub-pixel positioning.
<span class="lineNum">      65 </span>            :     // The number of variations is 108 for sub-pixel and 36 for full-pixel.
<span class="lineNum">      66 </span>            :     // This routine handles all of them using inline polymorphic variable (no heap allocation).
<span class="lineNum">      67 </span>            :     template&lt;typename ProcessOneGlyph&gt;
<span class="lineNum">      68 </span>            :     static void ProcessPosText(
<span class="lineNum">      69 </span>            :         SkPaint::TextEncoding, const char text[], size_t byteLength,
<span class="lineNum">      70 </span>            :         SkPoint offset, const SkMatrix&amp; matrix, const SkScalar pos[], int scalarsPerPosition,
<span class="lineNum">      71 </span>            :         SkPaint::Align textAlignment,
<span class="lineNum">      72 </span>            :         SkGlyphCache* cache, ProcessOneGlyph&amp;&amp; processOneGlyph);
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : private:
<span class="lineNum">      75 </span>            :     // UntaggedVariant is a pile of memory that can hold one of the Ts. It provides a way
<span class="lineNum">      76 </span>            :     // to initialize that memory in a typesafe way.
<span class="lineNum">      77 </span>            :     template&lt;typename... Ts&gt;
<a name="78"><span class="lineNum">      78 </span>            :     class UntaggedVariant {</a>
<span class="lineNum">      79 </span>            :     public:
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">         84 :         UntaggedVariant() { }</span></a>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineCov">         84 :         ~UntaggedVariant() { }</span>
<span class="lineNum">      83 </span>            :         UntaggedVariant(const UntaggedVariant&amp;) = delete;
<span class="lineNum">      84 </span>            :         UntaggedVariant&amp; operator=(const UntaggedVariant&amp;) = delete;
<span class="lineNum">      85 </span>            :         UntaggedVariant(UntaggedVariant&amp;&amp;) = delete;
<span class="lineNum">      86 </span>            :         UntaggedVariant&amp; operator=(UntaggedVariant&amp;&amp;) = delete;
<a name="87"><span class="lineNum">      87 </span>            : </a>
<span class="lineNum">      88 </span>            :         template&lt;typename Variant, typename... Args&gt;
<span class="lineNum">      89 </span><span class="lineCov">         84 :         void initialize(Args&amp;&amp;... args) {</span>
<span class="lineNum">      90 </span>            :             SkASSERT(sizeof(Variant) &lt;= sizeof(fSpace));
<span class="lineNum">      91 </span>            :         #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
<span class="lineNum">      92 </span>            :             #define alignof __alignof
<span class="lineNum">      93 </span>            :         #endif
<span class="lineNum">      94 </span>            :             SkASSERT(alignof(Variant) &lt;= alignof(Space));
<span class="lineNum">      95 </span><span class="lineCov">         84 :             new(&amp;fSpace) Variant(std::forward&lt;Args&gt;(args)...);</span>
<span class="lineNum">      96 </span><span class="lineCov">         84 :         }</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :     private:
<span class="lineNum">      99 </span>            :         typedef SkAlignedSStorage&lt;SkMaxSizeOf&lt;Ts...&gt;::value&gt; Space;
<span class="lineNum">     100 </span>            :         Space fSpace;
<span class="lineNum">     101 </span>            :     };
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :     // PolymorphicVariant holds subclasses of Base without slicing. Ts must be subclasses of Base.
<span class="lineNum">     104 </span>            :     template&lt;typename Base, typename... Ts&gt;
<span class="lineNum">     105 </span>            :     class PolymorphicVariant {
<span class="lineNum">     106 </span>            :     public:
<span class="lineNum">     107 </span>            :         typedef UntaggedVariant&lt;Ts...&gt; Variants;
<a name="108"><span class="lineNum">     108 </span>            : </a>
<span class="lineNum">     109 </span>            :         template&lt;typename Initializer&gt;
<span class="lineNum">     110 </span><span class="lineCov">         84 :         PolymorphicVariant(Initializer&amp;&amp; initializer) {</span>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">         84 :             initializer(&amp;fVariants);</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">         84 :         }</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineCov">         84 :         ~PolymorphicVariant() { get()-&gt;~Base(); }</span></a>
<span class="lineNum">     114 </span><span class="lineCov">       1897 :         Base* get() const { return reinterpret_cast&lt;Base*&gt;(&amp;fVariants); }</span>
<span class="lineNum">     115 </span><span class="lineCov">       1813 :         Base* operator-&gt;() const { return get(); }</span>
<span class="lineNum">     116 </span>            :         Base&amp; operator*() const { return *get(); }
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :     private:
<span class="lineNum">     119 </span>            :         mutable Variants fVariants;
<span class="lineNum">     120 </span>            :     };
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     // GlyphFinderInterface is the polymorphic base for classes that parse a stream of chars into
<span class="lineNum">     123 </span>            :     // the right UniChar (or GlyphID) and lookup up the glyph on the cache. The concrete
<a name="124"><span class="lineNum">     124 </span>            :     // implementations are: Utf8GlyphFinder, Utf16GlyphFinder, Utf32GlyphFinder,</a>
<span class="lineNum">     125 </span>            :     // and GlyphIdGlyphFinder.
<a name="126"><span class="lineNum">     126 </span><span class="lineCov">         21 :     class GlyphFinderInterface {</span></a>
<span class="lineNum">     127 </span>            :     public:
<span class="lineNum">     128 </span><span class="lineCov">         21 :         virtual ~GlyphFinderInterface() {}</span>
<span class="lineNum">     129 </span>            :         virtual const SkGlyph&amp; lookupGlyph(const char** text) = 0;
<span class="lineNum">     130 </span>            :         virtual const SkGlyph&amp; lookupGlyphXY(const char** text, SkFixed x, SkFixed y) = 0;
<a name="131"><span class="lineNum">     131 </span>            :     };</a>
<span class="lineNum">     132 </span>            : 
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :     class UtfNGlyphFinder : public GlyphFinderInterface {</span></a>
<span class="lineNum">     134 </span>            :     public:
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :         UtfNGlyphFinder(SkGlyphCache* cache) : fCache(cache) { SkASSERT(cache != nullptr); }</span></a>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         const SkGlyph&amp; lookupGlyph(const char** text) override {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :             SkASSERT(text != nullptr);</span>
<a name="139"><span class="lineNum">     139 </span><span class="lineNoCov">          0 :             return fCache-&gt;getUnicharMetrics(nextUnichar(text));</span></a>
<span class="lineNum">     140 </span>            :         }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         const SkGlyph&amp; lookupGlyphXY(const char** text, SkFixed x, SkFixed y) override {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :             SkASSERT(text != nullptr);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :             return fCache-&gt;getUnicharMetrics(nextUnichar(text), x, y);</span>
<span class="lineNum">     144 </span>            :         }
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     private:
<span class="lineNum">     147 </span>            :         virtual SkUnichar nextUnichar(const char** text) = 0;
<span class="lineNum">     148 </span>            :         SkGlyphCache* fCache;
<a name="149"><span class="lineNum">     149 </span>            :     };</a>
<span class="lineNum">     150 </span>            : 
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :     class Utf8GlyphFinder final : public UtfNGlyphFinder {</span></a>
<span class="lineNum">     152 </span>            :     public:
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         Utf8GlyphFinder(SkGlyphCache* cache) : UtfNGlyphFinder(cache) { }</span>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<span class="lineNum">     155 </span>            :     private:
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         SkUnichar nextUnichar(const char** text) override { return SkUTF8_NextUnichar(text); }</span>
<a name="157"><span class="lineNum">     157 </span>            :     };</a>
<span class="lineNum">     158 </span>            : 
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :     class Utf16GlyphFinder final : public UtfNGlyphFinder {</span></a>
<span class="lineNum">     160 </span>            :     public:
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :         Utf16GlyphFinder(SkGlyphCache* cache) : UtfNGlyphFinder(cache) { }</span>
<a name="162"><span class="lineNum">     162 </span>            : </a>
<span class="lineNum">     163 </span>            :     private:
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :         SkUnichar nextUnichar(const char** text) override {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :             return SkUTF16_NextUnichar((const uint16_t**)text);</span>
<span class="lineNum">     166 </span>            :         }
<a name="167"><span class="lineNum">     167 </span>            :     };</a>
<span class="lineNum">     168 </span>            : 
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :     class Utf32GlyphFinder final : public UtfNGlyphFinder {</span></a>
<span class="lineNum">     170 </span>            :     public:
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         Utf32GlyphFinder(SkGlyphCache* cache) : UtfNGlyphFinder(cache) { }</span>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<span class="lineNum">     173 </span>            :     private:
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         SkUnichar nextUnichar(const char** text) override {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :             const int32_t* ptr = *(const int32_t**)text;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :             SkUnichar uni = *ptr++;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :             *text = (const char*)ptr;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :             return uni;</span>
<span class="lineNum">     179 </span>            :         }
<a name="180"><span class="lineNum">     180 </span>            :     };</a>
<span class="lineNum">     181 </span>            : 
<a name="182"><span class="lineNum">     182 </span><span class="lineCov">         21 :     class GlyphIdGlyphFinder final : public GlyphFinderInterface {</span></a>
<span class="lineNum">     183 </span>            :     public:
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">         21 :         GlyphIdGlyphFinder(SkGlyphCache* cache) : fCache(cache) { SkASSERT(cache != nullptr); }</span></a>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineCov">        448 :         const SkGlyph&amp; lookupGlyph(const char** text) override {</span>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">        448 :             return fCache-&gt;getGlyphIDMetrics(nextGlyphId(text));</span></a>
<span class="lineNum">     188 </span>            :         }
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         const SkGlyph&amp; lookupGlyphXY(const char** text, SkFixed x, SkFixed y) override {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :             return fCache-&gt;getGlyphIDMetrics(nextGlyphId(text), x, y);</span>
<span class="lineNum">     191 </span>            :         }
<a name="192"><span class="lineNum">     192 </span>            : </a>
<span class="lineNum">     193 </span>            :     private:
<span class="lineNum">     194 </span><span class="lineCov">        448 :         uint16_t nextGlyphId(const char** text) {</span>
<span class="lineNum">     195 </span><span class="lineCov">        448 :             SkASSERT(text != nullptr);</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineCov">        448 :             const uint16_t* ptr = *(const uint16_t**)text;</span>
<span class="lineNum">     198 </span><span class="lineCov">        448 :             uint16_t glyphID = *ptr;</span>
<span class="lineNum">     199 </span><span class="lineCov">        448 :             ptr += 1;</span>
<span class="lineNum">     200 </span><span class="lineCov">        448 :             *text = (const char*)ptr;</span>
<span class="lineNum">     201 </span><span class="lineCov">        448 :             return glyphID;</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span>            :         SkGlyphCache* fCache;
<span class="lineNum">     204 </span>            :     };
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :     typedef PolymorphicVariant&lt;
<span class="lineNum">     207 </span>            :         GlyphFinderInterface,
<span class="lineNum">     208 </span>            :         Utf8GlyphFinder,
<span class="lineNum">     209 </span>            :         Utf16GlyphFinder,
<span class="lineNum">     210 </span>            :         Utf32GlyphFinder,
<a name="211"><span class="lineNum">     211 </span>            :         GlyphIdGlyphFinder&gt; LookupGlyphVariant;</a>
<span class="lineNum">     212 </span>            : 
<a name="213"><span class="lineNum">     213 </span><span class="lineCov">         21 :     class LookupGlyph : public LookupGlyphVariant {</span></a>
<span class="lineNum">     214 </span>            :     public:
<a name="215"><span class="lineNum">     215 </span><span class="lineCov">         21 :         LookupGlyph(SkPaint::TextEncoding encoding, SkGlyphCache* cache)</span></a>
<span class="lineNum">     216 </span><span class="lineCov">         21 :             : LookupGlyphVariant(</span>
<span class="lineNum">     217 </span><span class="lineCov">         21 :             [&amp;](LookupGlyphVariant::Variants* to_init) {</span>
<span class="lineNum">     218 </span><span class="lineCov">         21 :                 switch(encoding) {</span>
<span class="lineNum">     219 </span>            :                     case SkPaint::kUTF8_TextEncoding:
<span class="lineNum">     220 </span><span class="lineCov">         21 :                         to_init-&gt;initialize&lt;Utf8GlyphFinder&gt;(cache);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     222 </span>            :                     case SkPaint::kUTF16_TextEncoding:
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                         to_init-&gt;initialize&lt;Utf16GlyphFinder&gt;(cache);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     225 </span>            :                     case SkPaint::kUTF32_TextEncoding:
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                         to_init-&gt;initialize&lt;Utf32GlyphFinder&gt;(cache);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     228 </span>            :                     case SkPaint::kGlyphID_TextEncoding:
<span class="lineNum">     229 </span><span class="lineCov">         21 :                         to_init-&gt;initialize&lt;GlyphIdGlyphFinder&gt;(cache);</span>
<span class="lineNum">     230 </span><span class="lineCov">         21 :                         break;</span>
<span class="lineNum">     231 </span>            :                 }
<span class="lineNum">     232 </span><span class="lineCov">         21 :             }</span>
<span class="lineNum">     233 </span><span class="lineCov">         21 :         ) { }</span>
<span class="lineNum">     234 </span>            :     };
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :     // PositionReaderInterface reads a point from the pos vector.
<a name="237"><span class="lineNum">     237 </span>            :     // * HorizontalPositions - assumes a common Y for many X values.</a>
<span class="lineNum">     238 </span>            :     // * ArbitraryPositions - a list of (X,Y) pairs.
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">         21 :     class PositionReaderInterface {</span></a>
<span class="lineNum">     240 </span>            :     public:
<span class="lineNum">     241 </span><span class="lineCov">         21 :         virtual ~PositionReaderInterface() { }</span>
<span class="lineNum">     242 </span>            :         virtual SkPoint nextPoint() = 0;
<span class="lineNum">     243 </span>            :         // This is only here to fix a GCC 4.9 aarch64 code gen bug.
<span class="lineNum">     244 </span>            :         // See comment at the top of the file.
<span class="lineNum">     245 </span>            :         virtual int forceUseForBug() = 0;
<a name="246"><span class="lineNum">     246 </span>            :     };</a>
<span class="lineNum">     247 </span>            : 
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :     class HorizontalPositions final : public PositionReaderInterface {</span></a>
<span class="lineNum">     249 </span>            :     public:
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         explicit HorizontalPositions(const SkScalar* positions)</span>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :             : fPositions(positions) { }</span></a>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         SkPoint nextPoint() override {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :             SkScalar x = *fPositions++;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             return {x, 0};</span>
<a name="256"><span class="lineNum">     256 </span>            :         }</a>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         int forceUseForBug() override { return 1; }</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     private:
<span class="lineNum">     261 </span>            :         const SkScalar* fPositions;
<a name="262"><span class="lineNum">     262 </span>            :     };</a>
<span class="lineNum">     263 </span>            : 
<a name="264"><span class="lineNum">     264 </span><span class="lineCov">         21 :     class ArbitraryPositions final : public PositionReaderInterface {</span></a>
<span class="lineNum">     265 </span>            :     public:
<span class="lineNum">     266 </span><span class="lineCov">         21 :         explicit ArbitraryPositions(const SkScalar* positions)</span>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">         21 :             : fPositions(positions) { }</span></a>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineCov">        448 :         SkPoint nextPoint() override {</span>
<span class="lineNum">     270 </span><span class="lineCov">        448 :             SkPoint to_return{fPositions[0], fPositions[1]};</span>
<span class="lineNum">     271 </span><span class="lineCov">        448 :             fPositions += 2;</span>
<span class="lineNum">     272 </span><span class="lineCov">        448 :             return to_return;</span>
<a name="273"><span class="lineNum">     273 </span>            :         }</a>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineCov">         21 :         int forceUseForBug() override { return 2; }</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     private:
<span class="lineNum">     278 </span>            :         const SkScalar* fPositions;
<span class="lineNum">     279 </span>            :     };
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :     typedef PolymorphicVariant&lt;PositionReaderInterface, HorizontalPositions, ArbitraryPositions&gt;
<span class="lineNum">     282 </span>            :         PositionReader;
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :     // MapperInterface given a point map it through the matrix. There are several shortcut
<span class="lineNum">     285 </span>            :     // variants.
<span class="lineNum">     286 </span>            :     // * TranslationMapper - assumes a translation only matrix.
<a name="287"><span class="lineNum">     287 </span>            :     // * XScaleMapper - assumes an X scaling and a translation.</a>
<span class="lineNum">     288 </span>            :     // * GeneralMapper - Does all other matricies.
<a name="289"><span class="lineNum">     289 </span><span class="lineCov">         21 :     class MapperInterface {</span></a>
<span class="lineNum">     290 </span>            :     public:
<span class="lineNum">     291 </span><span class="lineCov">         21 :         virtual ~MapperInterface() { }</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :         virtual SkPoint map(SkPoint position) const = 0;
<a name="294"><span class="lineNum">     294 </span>            :     };</a>
<span class="lineNum">     295 </span>            : 
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :     class TranslationMapper final : public MapperInterface {</span></a>
<span class="lineNum">     297 </span>            :     public:
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         TranslationMapper(const SkMatrix&amp; matrix, const SkPoint origin)</span>
<a name="299"><span class="lineNum">     299 </span><span class="lineNoCov">          0 :             : fTranslate(matrix.mapXY(origin.fX, origin.fY)) { }</span></a>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         SkPoint map(SkPoint position) const override {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :             return position + fTranslate;</span>
<span class="lineNum">     303 </span>            :         }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :     private:
<span class="lineNum">     306 </span>            :         const SkPoint fTranslate;
<a name="307"><span class="lineNum">     307 </span>            :     };</a>
<span class="lineNum">     308 </span>            : 
<a name="309"><span class="lineNum">     309 </span><span class="lineNoCov">          0 :     class XScaleMapper final : public MapperInterface {</span></a>
<span class="lineNum">     310 </span>            :     public:
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         XScaleMapper(const SkMatrix&amp; matrix, const SkPoint origin)</span>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :             : fTranslate(matrix.mapXY(origin.fX, origin.fY)), fXScale(matrix.getScaleX()) { }</span></a>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         SkPoint map(SkPoint position) const override {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             return {fXScale * position.fX + fTranslate.fX, fTranslate.fY};</span>
<span class="lineNum">     316 </span>            :         }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :     private:
<span class="lineNum">     319 </span>            :         const SkPoint fTranslate;
<span class="lineNum">     320 </span>            :         const SkScalar fXScale;
<span class="lineNum">     321 </span>            :     };
<a name="322"><span class="lineNum">     322 </span>            : </a>
<span class="lineNum">     323 </span>            :     // The caller must keep matrix alive while this class is used.
<a name="324"><span class="lineNum">     324 </span><span class="lineCov">         21 :     class GeneralMapper final : public MapperInterface {</span></a>
<span class="lineNum">     325 </span>            :     public:
<span class="lineNum">     326 </span><span class="lineCov">         21 :         GeneralMapper(const SkMatrix&amp; matrix, const SkPoint origin)</span>
<a name="327"><span class="lineNum">     327 </span><span class="lineCov">         21 :             : fOrigin(origin), fMatrix(matrix), fMapProc(matrix.getMapXYProc()) { }</span></a>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineCov">        448 :         SkPoint map(SkPoint position) const override {</span>
<span class="lineNum">     330 </span>            :             SkPoint result;
<span class="lineNum">     331 </span><span class="lineCov">        448 :             fMapProc(fMatrix, position.fX + fOrigin.fX, position.fY + fOrigin.fY, &amp;result);</span>
<span class="lineNum">     332 </span><span class="lineCov">        448 :             return result;</span>
<span class="lineNum">     333 </span>            :         }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     private:
<span class="lineNum">     336 </span>            :         const SkPoint fOrigin;
<span class="lineNum">     337 </span>            :         const SkMatrix&amp; fMatrix;
<span class="lineNum">     338 </span>            :         const SkMatrix::MapXYProc fMapProc;
<span class="lineNum">     339 </span>            :     };
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :     typedef PolymorphicVariant&lt;
<span class="lineNum">     342 </span>            :         MapperInterface, TranslationMapper, XScaleMapper, GeneralMapper&gt; Mapper;
<a name="343"><span class="lineNum">     343 </span>            : </a>
<span class="lineNum">     344 </span>            :     // TextAlignmentAdjustment handles shifting the glyph based on its width.
<span class="lineNum">     345 </span><span class="lineCov">        422 :     static SkPoint TextAlignmentAdjustment(SkPaint::Align textAlignment, const SkGlyph&amp; glyph) {</span>
<span class="lineNum">     346 </span><span class="lineCov">        422 :         switch (textAlignment) {</span>
<span class="lineNum">     347 </span>            :             case SkPaint::kLeft_Align:
<span class="lineNum">     348 </span><span class="lineCov">        422 :                 return {0.0f, 0.0f};</span>
<span class="lineNum">     349 </span>            :             case SkPaint::kCenter_Align:
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                 return {SkFloatToScalar(glyph.fAdvanceX) / 2,</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                         SkFloatToScalar(glyph.fAdvanceY) / 2};</span>
<span class="lineNum">     352 </span>            :             case SkPaint::kRight_Align:
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                 return {SkFloatToScalar(glyph.fAdvanceX),</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                         SkFloatToScalar(glyph.fAdvanceY)};</span>
<span class="lineNum">     355 </span>            :         }
<span class="lineNum">     356 </span>            :         // Even though the entire enum is covered above, MVSC doesn't think so. Make it happy.
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         SkFAIL(&quot;Should never get here.&quot;);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         return {0.0f, 0.0f};</span>
<span class="lineNum">     359 </span>            :     }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :     // The &quot;call&quot; to SkFixedToScalar is actually a macro. It's macros all the way down.
<span class="lineNum">     362 </span>            :     // Needs to be a macro because you can't have a const float unless you make it constexpr.
<span class="lineNum">     363 </span>            :     #define kSubpixelRounding (SkFixedToScalar(SkGlyph::kSubpixelRound))
<span class="lineNum">     364 </span>            : 
<a name="365"><span class="lineNum">     365 </span>            :     // The SubpixelPositionRounding function returns a point suitable for rounding a sub-pixel</a>
<span class="lineNum">     366 </span>            :     // positioned glyph.
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     static SkPoint SubpixelPositionRounding(SkAxisAlignment axisAlignment) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         switch (axisAlignment) {</span>
<span class="lineNum">     369 </span>            :             case kX_SkAxisAlignment:
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                 return {kSubpixelRounding, SK_ScalarHalf};</span>
<span class="lineNum">     371 </span>            :             case kY_SkAxisAlignment:
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                 return {SK_ScalarHalf, kSubpixelRounding};</span>
<span class="lineNum">     373 </span>            :             case kNone_SkAxisAlignment:
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                 return {kSubpixelRounding, kSubpixelRounding};</span>
<span class="lineNum">     375 </span>            :         }
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         SkFAIL(&quot;Should not get here.&quot;);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         return {0.0f, 0.0f};</span>
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :     // The SubpixelAlignment function produces a suitable position for the glyph cache to
<a name="381"><span class="lineNum">     381 </span>            :     // produce the correct sub-pixel alignment. If a position is aligned with an axis a shortcut</a>
<span class="lineNum">     382 </span>            :     // of 0 is used for the sub-pixel position.
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     static SkIPoint SubpixelAlignment(SkAxisAlignment axisAlignment, SkPoint position) {</span>
<span class="lineNum">     384 </span>            :         // Only the fractional part of position.fX and position.fY matter, because the result of
<span class="lineNum">     385 </span>            :         // this function will just be passed to FixedToSub.
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         switch (axisAlignment) {</span>
<span class="lineNum">     387 </span>            :             case kX_SkAxisAlignment:
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                 return {SkScalarToFixed(SkScalarFraction(position.fX) + kSubpixelRounding), 0};</span>
<span class="lineNum">     389 </span>            :             case kY_SkAxisAlignment:
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 return {0, SkScalarToFixed(SkScalarFraction(position.fY) + kSubpixelRounding)};</span>
<span class="lineNum">     391 </span>            :             case kNone_SkAxisAlignment:
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :                 return {SkScalarToFixed(SkScalarFraction(position.fX) + kSubpixelRounding),</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                         SkScalarToFixed(SkScalarFraction(position.fY) + kSubpixelRounding)};</span>
<span class="lineNum">     394 </span>            :         }
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         SkFAIL(&quot;Should not get here.&quot;);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         return {0, 0};</span>
<span class="lineNum">     397 </span>            :     }
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     #undef kSubpixelRounding
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :     // GlyphFindAndPlaceInterface given the text and position finds the correct glyph and does
<span class="lineNum">     402 </span>            :     // glyph specific position adjustment. The findAndPositionGlyph method takes text and
<span class="lineNum">     403 </span>            :     // position and calls processOneGlyph with the correct glyph, final position and rounding
<a name="404"><span class="lineNum">     404 </span>            :     // terms. The final position is not rounded yet and is the responsibility of processOneGlyph.</a>
<span class="lineNum">     405 </span>            :     template&lt;typename ProcessOneGlyph&gt;
<a name="406"><span class="lineNum">     406 </span><span class="lineCov">         21 :     class GlyphFindAndPlaceInterface : SkNoncopyable {</span></a>
<span class="lineNum">     407 </span>            :     public:
<span class="lineNum">     408 </span><span class="lineCov">         21 :         virtual ~GlyphFindAndPlaceInterface() { }</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :         // findAndPositionGlyph calculates the position of the glyph, finds the glyph, and
<span class="lineNum">     411 </span>            :         // returns the position of where the next glyph will be using the glyph's advance and
<span class="lineNum">     412 </span>            :         // possibly kerning. The returned position is used by drawText, but ignored by drawPosText.
<span class="lineNum">     413 </span>            :         // The compiler should prune all this calculation if the return value is not used.
<span class="lineNum">     414 </span>            :         //
<span class="lineNum">     415 </span>            :         // This should be a pure virtual, but some versions of GCC &lt;= 4.8 have a bug that causes a
<a name="416"><span class="lineNum">     416 </span>            :         // compile error.</a>
<span class="lineNum">     417 </span>            :         // See GCC bug: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60277
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         virtual SkPoint findAndPositionGlyph(</span>
<span class="lineNum">     419 </span>            :             const char** text, SkPoint position, ProcessOneGlyph&amp;&amp; processOneGlyph) {
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             SkFAIL(&quot;Should never get here.&quot;);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             return {0.0f, 0.0f};</span>
<span class="lineNum">     422 </span>            :         }
<span class="lineNum">     423 </span>            :     };
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     // GlyphFindAndPlaceSubpixel handles finding and placing glyphs when sub-pixel positioning is
<span class="lineNum">     426 </span>            :     // requested. After it has found and placed the glyph it calls the templated function
<span class="lineNum">     427 </span>            :     // ProcessOneGlyph in order to actually perform an action.
<a name="428"><span class="lineNum">     428 </span>            :     template&lt;typename ProcessOneGlyph, SkPaint::Align kTextAlignment,</a>
<span class="lineNum">     429 </span>            :              SkAxisAlignment kAxisAlignment&gt;
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :     class GlyphFindAndPlaceSubpixel final : public GlyphFindAndPlaceInterface&lt;ProcessOneGlyph&gt; {</span></a>
<span class="lineNum">     431 </span>            :     public:
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         GlyphFindAndPlaceSubpixel(LookupGlyph&amp; glyphFinder)</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             : fGlyphFinder(glyphFinder) {</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :             FixGCC49Arm64Bug(1);</span>
<a name="435"><span class="lineNum">     435 </span><span class="lineNoCov">          0 :         }</span></a>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         SkPoint findAndPositionGlyph(</span>
<span class="lineNum">     438 </span>            :             const char** text, SkPoint position, ProcessOneGlyph&amp;&amp; processOneGlyph) override {
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :             if (kTextAlignment != SkPaint::kLeft_Align) {
<span class="lineNum">     441 </span>            :                 // Get the width of an un-sub-pixel positioned glyph for calculating the
<span class="lineNum">     442 </span>            :                 // alignment. This is not needed for kLeftAlign because its adjustment is
<span class="lineNum">     443 </span>            :                 // always {0, 0}.
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                 const char* tempText = *text;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 const SkGlyph &amp;metricGlyph = fGlyphFinder-&gt;lookupGlyph(&amp;tempText);</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :                 if (metricGlyph.fWidth &lt;= 0) {</span>
<span class="lineNum">     448 </span>            :                     // Exiting early, be sure to update text pointer.
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                     *text = tempText;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                     return position + SkPoint{SkFloatToScalar(metricGlyph.fAdvanceX),</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                                               SkFloatToScalar(metricGlyph.fAdvanceY)};</span>
<span class="lineNum">     452 </span>            :                 }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :                 // Adjust the final position by the alignment adjustment.
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 position -= TextAlignmentAdjustment(kTextAlignment, metricGlyph);</span>
<span class="lineNum">     456 </span>            :             }
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :             // Find the glyph.
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :             SkIPoint lookupPosition = SkScalarsAreFinite(position.fX, position.fY)</span>
<span class="lineNum">     460 </span>            :                                       ? SubpixelAlignment(kAxisAlignment, position)
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                                       : SkIPoint{0, 0};</span>
<span class="lineNum">     462 </span>            :             const SkGlyph&amp; renderGlyph =
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                 fGlyphFinder-&gt;lookupGlyphXY(text, lookupPosition.fX, lookupPosition.fY);</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :             // If the glyph has no width (no pixels) then don't bother processing it.
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             if (renderGlyph.fWidth &gt; 0) {</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 processOneGlyph(renderGlyph, position,</span>
<span class="lineNum">     468 </span>            :                                 SubpixelPositionRounding(kAxisAlignment));
<span class="lineNum">     469 </span>            :             }
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :             return position + SkPoint{SkFloatToScalar(renderGlyph.fAdvanceX),</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                                       SkFloatToScalar(renderGlyph.fAdvanceY)};</span>
<span class="lineNum">     472 </span>            :         }
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :     private:
<span class="lineNum">     475 </span>            :         LookupGlyph&amp; fGlyphFinder;
<span class="lineNum">     476 </span>            :     };
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :     enum SelectKerning {
<span class="lineNum">     479 </span>            :         kNoKerning = false,
<span class="lineNum">     480 </span>            :         kUseKerning = true
<span class="lineNum">     481 </span>            :     };
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :     // GlyphFindAndPlaceFullPixel handles finding and placing glyphs when no sub-pixel
<span class="lineNum">     484 </span>            :     // positioning is requested. The kUseKerning argument should be true for drawText, and false
<a name="485"><span class="lineNum">     485 </span>            :     // for drawPosText.</a>
<span class="lineNum">     486 </span>            :     template&lt;typename ProcessOneGlyph, SkPaint::Align kTextAlignment, SelectKerning kUseKerning&gt;
<a name="487"><span class="lineNum">     487 </span><span class="lineCov">         21 :     class GlyphFindAndPlaceFullPixel final : public GlyphFindAndPlaceInterface&lt;ProcessOneGlyph&gt; {</span></a>
<span class="lineNum">     488 </span>            :     public:
<span class="lineNum">     489 </span><span class="lineCov">         21 :         GlyphFindAndPlaceFullPixel(LookupGlyph&amp; glyphFinder)</span>
<span class="lineNum">     490 </span><span class="lineCov">         21 :             : fGlyphFinder(glyphFinder) {</span>
<span class="lineNum">     491 </span><span class="lineCov">         21 :             FixGCC49Arm64Bug(2);</span>
<span class="lineNum">     492 </span>            :             // Kerning can only be used with SkPaint::kLeft_Align
<span class="lineNum">     493 </span>            :             static_assert(!kUseKerning || SkPaint::kLeft_Align == kTextAlignment,
<span class="lineNum">     494 </span>            :                           &quot;Kerning can only be used with left aligned text.&quot;);
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">         21 :         }</span></a>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineCov">        448 :         SkPoint findAndPositionGlyph(</span>
<span class="lineNum">     498 </span>            :             const char** text, SkPoint position, ProcessOneGlyph&amp;&amp; processOneGlyph) override {
<span class="lineNum">     499 </span><span class="lineCov">        448 :             SkPoint finalPosition = position;</span>
<span class="lineNum">     500 </span><span class="lineCov">        448 :             const SkGlyph&amp; glyph = fGlyphFinder-&gt;lookupGlyph(text);</span>
<span class="lineNum">     501 </span>            :             if (kUseKerning) {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                 finalPosition += {fAutoKern.adjust(glyph), 0.0f};</span>
<span class="lineNum">     503 </span>            :             }
<span class="lineNum">     504 </span><span class="lineCov">        448 :             if (glyph.fWidth &gt; 0) {</span>
<span class="lineNum">     505 </span><span class="lineCov">        422 :                 finalPosition -= TextAlignmentAdjustment(kTextAlignment, glyph);</span>
<span class="lineNum">     506 </span><span class="lineCov">        422 :                 processOneGlyph(glyph, finalPosition, {SK_ScalarHalf, SK_ScalarHalf});</span>
<span class="lineNum">     507 </span>            :             }
<span class="lineNum">     508 </span><span class="lineCov">       1344 :             return finalPosition + SkPoint{SkFloatToScalar(glyph.fAdvanceX),</span>
<span class="lineNum">     509 </span><span class="lineCov">       1344 :                                            SkFloatToScalar(glyph.fAdvanceY)};</span>
<span class="lineNum">     510 </span>            :         }
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :     private:
<span class="lineNum">     513 </span>            :         LookupGlyph&amp; fGlyphFinder;
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :         SkAutoKern fAutoKern;
<span class="lineNum">     516 </span>            :     };
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     // GlyphFindAndPlace is a large variant that encapsulates the multiple types of finding and
<span class="lineNum">     519 </span>            :     // placing a glyph. There are three factors that go into the different factors.
<span class="lineNum">     520 </span>            :     // * Is sub-pixel positioned - a boolean that says whether to use sub-pixel positioning.
<span class="lineNum">     521 </span>            :     // * Text alignment - indicates if the glyph should be placed to the right, centered or left
<span class="lineNum">     522 </span>            :     //   of a given position.
<span class="lineNum">     523 </span>            :     // * Axis alignment - indicates if the glyphs final sub-pixel position should be rounded to a
<span class="lineNum">     524 </span>            :     //   whole pixel if the glyph is aligned with an axis. This is only used for sub-pixel
<span class="lineNum">     525 </span>            :     //   positioning and allows the baseline to look crisp.
<span class="lineNum">     526 </span>            :     template&lt;typename ProcessOneGlyph&gt;
<span class="lineNum">     527 </span>            :     using GlyphFindAndPlace = PolymorphicVariant&lt;
<span class="lineNum">     528 </span>            :         GlyphFindAndPlaceInterface&lt;ProcessOneGlyph&gt;,
<span class="lineNum">     529 </span>            :         // Subpixel
<span class="lineNum">     530 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kLeft_Align,   kNone_SkAxisAlignment&gt;,
<span class="lineNum">     531 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kLeft_Align,   kX_SkAxisAlignment   &gt;,
<span class="lineNum">     532 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kLeft_Align,   kY_SkAxisAlignment   &gt;,
<span class="lineNum">     533 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kCenter_Align, kNone_SkAxisAlignment&gt;,
<span class="lineNum">     534 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kCenter_Align, kX_SkAxisAlignment   &gt;,
<span class="lineNum">     535 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kCenter_Align, kY_SkAxisAlignment   &gt;,
<span class="lineNum">     536 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kRight_Align,  kNone_SkAxisAlignment&gt;,
<span class="lineNum">     537 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kRight_Align,  kX_SkAxisAlignment   &gt;,
<span class="lineNum">     538 </span>            :         GlyphFindAndPlaceSubpixel&lt;ProcessOneGlyph,  SkPaint::kRight_Align,  kY_SkAxisAlignment   &gt;,
<span class="lineNum">     539 </span>            :         // Full pixel
<span class="lineNum">     540 </span>            :         GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph, SkPaint::kLeft_Align,   kNoKerning&gt;,
<span class="lineNum">     541 </span>            :         GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph, SkPaint::kCenter_Align, kNoKerning&gt;,
<span class="lineNum">     542 </span>            :         GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph, SkPaint::kRight_Align,  kNoKerning&gt;
<span class="lineNum">     543 </span>            :     &gt;;
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :     // InitSubpixel is a helper function for initializing all the variants of
<a name="546"><span class="lineNum">     546 </span>            :     // GlyphFindAndPlaceSubpixel.</a>
<span class="lineNum">     547 </span>            :     template&lt;typename ProcessOneGlyph, SkPaint::Align kTextAlignment&gt;
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     static void InitSubpixel(</span>
<span class="lineNum">     549 </span>            :         typename GlyphFindAndPlace&lt;ProcessOneGlyph&gt;::Variants* to_init,
<span class="lineNum">     550 </span>            :         SkAxisAlignment axisAlignment,
<span class="lineNum">     551 </span>            :         LookupGlyph&amp; glyphFinder) {
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         switch (axisAlignment) {</span>
<span class="lineNum">     553 </span>            :             case kX_SkAxisAlignment:
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                 to_init-&gt;template initialize&lt;GlyphFindAndPlaceSubpixel&lt;</span>
<span class="lineNum">     555 </span>            :                     ProcessOneGlyph, kTextAlignment, kX_SkAxisAlignment&gt;&gt;(glyphFinder);
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     557 </span>            :             case kNone_SkAxisAlignment:
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 to_init-&gt;template initialize&lt;GlyphFindAndPlaceSubpixel&lt;</span>
<span class="lineNum">     559 </span>            :                     ProcessOneGlyph, kTextAlignment, kNone_SkAxisAlignment&gt;&gt;(glyphFinder);
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     561 </span>            :             case kY_SkAxisAlignment:
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :                 to_init-&gt;template initialize&lt;GlyphFindAndPlaceSubpixel&lt;</span>
<span class="lineNum">     563 </span>            :                     ProcessOneGlyph, kTextAlignment, kY_SkAxisAlignment&gt;&gt;(glyphFinder);
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     565 </span>            :         }
<a name="566"><span class="lineNum">     566 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     static SkPoint MeasureText(LookupGlyph&amp; glyphFinder, const char text[], size_t byteLength) {</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         SkScalar    x = 0, y = 0;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         const char* stop = text + byteLength;</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         SkAutoKern  autokern;</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         while (text &lt; stop) {</span>
<span class="lineNum">     575 </span>            :             // don't need x, y here, since all subpixel variants will have the
<span class="lineNum">     576 </span>            :             // same advance
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :             const SkGlyph&amp; glyph = glyphFinder-&gt;lookupGlyph(&amp;text);</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :             x += autokern.adjust(glyph) + SkFloatToScalar(glyph.fAdvanceX);</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :             y += SkFloatToScalar(glyph.fAdvanceY);</span>
<span class="lineNum">     581 </span>            :         }
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         SkASSERT(text == stop);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         return {x, y};</span>
<span class="lineNum">     584 </span>            :     }
<span class="lineNum">     585 </span>            : };
<a name="586"><span class="lineNum">     586 </span>            : </a>
<span class="lineNum">     587 </span>            : template&lt;typename ProcessOneGlyph&gt;
<span class="lineNum">     588 </span><span class="lineCov">         21 : inline void SkFindAndPlaceGlyph::ProcessPosText(</span>
<span class="lineNum">     589 </span>            :     SkPaint::TextEncoding textEncoding, const char text[], size_t byteLength,
<span class="lineNum">     590 </span>            :     SkPoint offset, const SkMatrix&amp; matrix, const SkScalar pos[], int scalarsPerPosition,
<span class="lineNum">     591 </span>            :     SkPaint::Align textAlignment,
<span class="lineNum">     592 </span>            :     SkGlyphCache* cache, ProcessOneGlyph&amp;&amp; processOneGlyph) {
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">         21 :     SkAxisAlignment axisAlignment = cache-&gt;getScalerContext()-&gt;computeAxisAlignmentForHText();</span>
<span class="lineNum">     595 </span><span class="lineCov">         21 :     uint32_t mtype = matrix.getType();</span>
<span class="lineNum">     596 </span><span class="lineCov">         42 :     LookupGlyph glyphFinder(textEncoding, cache);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :     // Specialized code for handling the most common case for blink. The while loop is totally
<span class="lineNum">     599 </span>            :     // de-virtualized.
<span class="lineNum">     600 </span><span class="lineCov">         42 :     if (scalarsPerPosition == 1</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         &amp;&amp; textAlignment == SkPaint::kLeft_Align</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         &amp;&amp; axisAlignment == kX_SkAxisAlignment</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         &amp;&amp; cache-&gt;isSubpixel()</span>
<span class="lineNum">     604 </span><span class="lineCov">         21 :         &amp;&amp; mtype &lt;= SkMatrix::kTranslate_Mask) {</span>
<span class="lineNum">     605 </span>            :         typedef GlyphFindAndPlaceSubpixel&lt;
<span class="lineNum">     606 </span>            :             ProcessOneGlyph, SkPaint::kLeft_Align, kX_SkAxisAlignment&gt; Positioner;
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         HorizontalPositions positions{pos};</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         TranslationMapper mapper{matrix, offset};</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         Positioner positioner(glyphFinder);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         const char* cursor = text;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         const char* stop = text + byteLength;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         while (cursor &lt; stop) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :             SkPoint mappedPoint = mapper.TranslationMapper::map(</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 positions.HorizontalPositions::nextPoint());</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :             positioner.Positioner::findAndPositionGlyph(</span>
<span class="lineNum">     616 </span>            :                 &amp;cursor, mappedPoint, std::forward&lt;ProcessOneGlyph&gt;(processOneGlyph));
<span class="lineNum">     617 </span>            :         }
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     619 </span>            :     }
<a name="620"><span class="lineNum">     620 </span>            : </a>
<span class="lineNum">     621 </span>            :     PositionReader positionReader{
<span class="lineNum">     622 </span><span class="lineCov">         21 :         [&amp;](PositionReader::Variants* to_init) {</span>
<span class="lineNum">     623 </span><span class="lineCov">         21 :             if (2 == scalarsPerPosition) {</span>
<span class="lineNum">     624 </span><span class="lineCov">         21 :                 to_init-&gt;initialize&lt;ArbitraryPositions&gt;(pos);</span>
<span class="lineNum">     625 </span>            :             } else {
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                 to_init-&gt;initialize&lt;HorizontalPositions&gt;(pos);</span>
<span class="lineNum">     627 </span>            :             }
<span class="lineNum">     628 </span><span class="lineCov">         21 :             positionReader-&gt;forceUseForBug();</span>
<span class="lineNum">     629 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">     630 </span><span class="lineCov">         42 :     };</span>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<span class="lineNum">     632 </span>            :     Mapper mapper{
<span class="lineNum">     633 </span><span class="lineCov">         21 :         [&amp;](Mapper::Variants* to_init) {</span>
<span class="lineNum">     634 </span><span class="lineCov">         21 :             if (mtype &amp; (SkMatrix::kAffine_Mask | SkMatrix::kPerspective_Mask)</span>
<span class="lineNum">     635 </span><span class="lineCov">         21 :                 || scalarsPerPosition == 2) {</span>
<span class="lineNum">     636 </span><span class="lineCov">         21 :                 to_init-&gt;initialize&lt;GeneralMapper&gt;(matrix, offset);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :             } else if (mtype &amp; SkMatrix::kScale_Mask) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                 to_init-&gt;initialize&lt;XScaleMapper&gt;(matrix, offset);</span>
<span class="lineNum">     639 </span>            :             } else {
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                 to_init-&gt;initialize&lt;TranslationMapper&gt;(matrix, offset);</span>
<span class="lineNum">     641 </span>            :             }
<span class="lineNum">     642 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">     643 </span><span class="lineCov">         42 :     };</span>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<span class="lineNum">     645 </span>            :     GlyphFindAndPlace&lt;ProcessOneGlyph&gt; findAndPosition {
<span class="lineNum">     646 </span><span class="lineCov">         21 :         [&amp;](typename GlyphFindAndPlace&lt;ProcessOneGlyph&gt;::Variants* to_init) {</span>
<span class="lineNum">     647 </span><span class="lineCov">         21 :             if (cache-&gt;isSubpixel()) {</span>
<span class="lineNum">     648 </span><span class="lineCov">         21 :                 switch (textAlignment) {</span>
<span class="lineNum">     649 </span>            :                     case SkPaint::kLeft_Align:
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                         InitSubpixel&lt;ProcessOneGlyph, SkPaint::kLeft_Align&gt;(</span>
<span class="lineNum">     651 </span><span class="lineCov">         21 :                             to_init, axisAlignment, glyphFinder);</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     653 </span>            :                     case SkPaint::kCenter_Align:
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                         InitSubpixel&lt;ProcessOneGlyph, SkPaint::kCenter_Align&gt;(</span>
<span class="lineNum">     655 </span>            :                             to_init, axisAlignment, glyphFinder);
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     657 </span>            :                     case SkPaint::kRight_Align:
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                         InitSubpixel&lt;ProcessOneGlyph, SkPaint::kRight_Align&gt;(</span>
<span class="lineNum">     659 </span>            :                             to_init, axisAlignment, glyphFinder);
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     661 </span>            :                 }
<span class="lineNum">     662 </span>            :             } else {
<span class="lineNum">     663 </span><span class="lineCov">         21 :                 switch (textAlignment) {</span>
<span class="lineNum">     664 </span>            :                     case SkPaint::kLeft_Align:
<span class="lineNum">     665 </span><span class="lineCov">         21 :                         to_init-&gt;template initialize&lt;</span>
<span class="lineNum">     666 </span>            :                             GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph,
<span class="lineNum">     667 </span>            :                             SkPaint::kLeft_Align, kNoKerning&gt;&gt;(glyphFinder);
<span class="lineNum">     668 </span><span class="lineCov">         21 :                         break;</span>
<span class="lineNum">     669 </span>            :                     case SkPaint::kCenter_Align:
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                         to_init-&gt;template initialize&lt;</span>
<span class="lineNum">     671 </span>            :                             GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph,
<span class="lineNum">     672 </span>            :                             SkPaint::kCenter_Align, kNoKerning&gt;&gt;(glyphFinder);
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     674 </span>            :                     case SkPaint::kRight_Align:
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :                         to_init-&gt;template initialize&lt;</span>
<span class="lineNum">     676 </span>            :                             GlyphFindAndPlaceFullPixel&lt;ProcessOneGlyph,
<span class="lineNum">     677 </span>            :                             SkPaint::kRight_Align, kNoKerning&gt;&gt;(glyphFinder);
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     679 </span>            :                 }
<span class="lineNum">     680 </span>            :             }
<span class="lineNum">     681 </span><span class="lineCov">         21 :         }</span>
<span class="lineNum">     682 </span><span class="lineCov">         42 :     };</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">         21 :     const char* stop = text + byteLength;</span>
<span class="lineNum">     685 </span><span class="lineCov">        917 :     while (text &lt; stop) {</span>
<span class="lineNum">     686 </span><span class="lineCov">        448 :         SkPoint mappedPoint = mapper-&gt;map(positionReader-&gt;nextPoint());</span>
<span class="lineNum">     687 </span><span class="lineCov">        448 :         findAndPosition-&gt;findAndPositionGlyph(</span>
<span class="lineNum">     688 </span>            :             &amp;text, mappedPoint, std::forward&lt;ProcessOneGlyph&gt;(processOneGlyph));
<span class="lineNum">     689 </span>            :     }
<span class="lineNum">     690 </span>            : }
<a name="691"><span class="lineNum">     691 </span>            : </a>
<span class="lineNum">     692 </span>            : template&lt;typename ProcessOneGlyph&gt;
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : inline void SkFindAndPlaceGlyph::ProcessText(</span>
<span class="lineNum">     694 </span>            :     SkPaint::TextEncoding textEncoding, const char text[], size_t byteLength,
<span class="lineNum">     695 </span>            :     SkPoint offset, const SkMatrix&amp; matrix, SkPaint::Align textAlignment,
<span class="lineNum">     696 </span>            :     SkGlyphCache* cache, ProcessOneGlyph&amp;&amp; processOneGlyph) {
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :     // transform the starting point
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     matrix.mapPoints(&amp;offset, 1);</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     LookupGlyph glyphFinder(textEncoding, cache);</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :     // need to measure first
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     if (textAlignment != SkPaint::kLeft_Align) {</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         SkVector stop = MeasureText(glyphFinder, text, byteLength);</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         if (textAlignment == SkPaint::kCenter_Align) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :             stop *= SK_ScalarHalf;</span>
<span class="lineNum">     709 </span>            :         }
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         offset -= stop;</span>
<span class="lineNum">     711 </span>            :     }
<a name="712"><span class="lineNum">     712 </span>            : </a>
<span class="lineNum">     713 </span>            :     GlyphFindAndPlace&lt;ProcessOneGlyph&gt; findAndPosition{
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         [&amp;](typename GlyphFindAndPlace&lt;ProcessOneGlyph&gt;::Variants* to_init) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :             if (cache-&gt;isSubpixel()) {</span>
<span class="lineNum">     716 </span>            :                 SkAxisAlignment axisAlignment =
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                     cache-&gt;getScalerContext()-&gt;computeAxisAlignmentForHText();</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                 InitSubpixel&lt;ProcessOneGlyph, SkPaint::kLeft_Align&gt;(</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                     to_init, axisAlignment, glyphFinder);</span>
<span class="lineNum">     720 </span>            :             } else {
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :                 to_init-&gt;template initialize&lt;</span>
<span class="lineNum">     722 </span>            :                     GlyphFindAndPlaceFullPixel&lt;
<span class="lineNum">     723 </span>            :                         ProcessOneGlyph, SkPaint::kLeft_Align, kUseKerning&gt;&gt;(glyphFinder);
<span class="lineNum">     724 </span>            :             }
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     const char* stop = text + byteLength;</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     SkPoint current = offset;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     while (text &lt; stop) {</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :         current =</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :             findAndPosition-&gt;findAndPositionGlyph(</span>
<span class="lineNum">     733 </span>            :                 &amp;text, current, std::forward&lt;ProcessOneGlyph&gt;(processOneGlyph));
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :     }
<span class="lineNum">     736 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            : #endif  // SkFindAndPositionGlyph_DEFINED
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

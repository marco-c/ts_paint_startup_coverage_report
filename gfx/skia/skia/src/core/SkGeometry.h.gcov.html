<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/core/SkGeometry.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/core</a> - SkGeometry.h<span style="font-size: 80%;"> (source / <a href="SkGeometry.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">87</td>
            <td class="headerCovTableEntryLo">39.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryLo">52.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2006 The Android Open Source Project
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #ifndef SkGeometry_DEFINED
<span class="lineNum">       9 </span>            : #define SkGeometry_DEFINED
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;SkMatrix.h&quot;
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;SkNx.h&quot;</a>
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span><span class="lineCov">       2713 : static inline Sk2s from_point(const SkPoint&amp; point) {</span>
<span class="lineNum">      15 </span><span class="lineCov">       2713 :     return Sk2s::Load(&amp;point);</span>
<a name="16"><span class="lineNum">      16 </span>            : }</a>
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span><span class="lineCov">        426 : static inline SkPoint to_point(const Sk2s&amp; x) {</span>
<span class="lineNum">      19 </span>            :     SkPoint point;
<span class="lineNum">      20 </span>            :     x.store(&amp;point);
<span class="lineNum">      21 </span><span class="lineCov">        426 :     return point;</span>
<a name="22"><span class="lineNum">      22 </span>            : }</a>
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span><span class="lineCov">        418 : static Sk2s times_2(const Sk2s&amp; value) {</span>
<span class="lineNum">      25 </span><span class="lineCov">        418 :     return value + value;</span>
<span class="lineNum">      26 </span>            : }
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /** Given a quadratic equation Ax^2 + Bx + C = 0, return 0, 1, 2 roots for the
<span class="lineNum">      29 </span>            :     equation.
<span class="lineNum">      30 </span>            : */
<span class="lineNum">      31 </span>            : int SkFindUnitQuadRoots(SkScalar A, SkScalar B, SkScalar C, SkScalar roots[2]);
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : SkPoint SkEvalQuadAt(const SkPoint src[3], SkScalar t);
<span class="lineNum">      36 </span>            : SkPoint SkEvalQuadTangentAt(const SkPoint src[3], SkScalar t);
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /** Set pt to the point on the src quadratic specified by t. t must be
<span class="lineNum">      39 </span>            :     0 &lt;= t &lt;= 1.0
<span class="lineNum">      40 </span>            : */
<span class="lineNum">      41 </span>            : void SkEvalQuadAt(const SkPoint src[3], SkScalar t, SkPoint* pt, SkVector* tangent = nullptr);
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /** Given a src quadratic bezier, chop it at the specified t value,
<span class="lineNum">      44 </span>            :     where 0 &lt; t &lt; 1, and return the two new quadratics in dst:
<span class="lineNum">      45 </span>            :     dst[0..2] and dst[2..4]
<span class="lineNum">      46 </span>            : */
<span class="lineNum">      47 </span>            : void SkChopQuadAt(const SkPoint src[3], SkPoint dst[5], SkScalar t);
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /** Given a src quadratic bezier, chop it at the specified t == 1/2,
<span class="lineNum">      50 </span>            :     The new quads are returned in dst[0..2] and dst[2..4]
<span class="lineNum">      51 </span>            : */
<span class="lineNum">      52 </span>            : void SkChopQuadAtHalf(const SkPoint src[3], SkPoint dst[5]);
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /** Given the 3 coefficients for a quadratic bezier (either X or Y values), look
<span class="lineNum">      55 </span>            :     for extrema, and return the number of t-values that are found that represent
<span class="lineNum">      56 </span>            :     these extrema. If the quadratic has no extrema betwee (0..1) exclusive, the
<span class="lineNum">      57 </span>            :     function returns 0.
<span class="lineNum">      58 </span>            :     Returned count      tValues[]
<span class="lineNum">      59 </span>            :     0                   ignored
<span class="lineNum">      60 </span>            :     1                   0 &lt; tValues[0] &lt; 1
<span class="lineNum">      61 </span>            : */
<span class="lineNum">      62 </span>            : int SkFindQuadExtrema(SkScalar a, SkScalar b, SkScalar c, SkScalar tValues[1]);
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : /** Given 3 points on a quadratic bezier, chop it into 1, 2 beziers such that
<span class="lineNum">      65 </span>            :     the resulting beziers are monotonic in Y. This is called by the scan converter.
<span class="lineNum">      66 </span>            :     Depending on what is returned, dst[] is treated as follows
<span class="lineNum">      67 </span>            :     0   dst[0..2] is the original quad
<span class="lineNum">      68 </span>            :     1   dst[0..2] and dst[2..4] are the two new quads
<span class="lineNum">      69 </span>            : */
<span class="lineNum">      70 </span>            : int SkChopQuadAtYExtrema(const SkPoint src[3], SkPoint dst[5]);
<span class="lineNum">      71 </span>            : int SkChopQuadAtXExtrema(const SkPoint src[3], SkPoint dst[5]);
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /** Given 3 points on a quadratic bezier, if the point of maximum
<span class="lineNum">      74 </span>            :     curvature exists on the segment, returns the t value for this
<span class="lineNum">      75 </span>            :     point along the curve. Otherwise it will return a value of 0.
<span class="lineNum">      76 </span>            : */
<span class="lineNum">      77 </span>            : SkScalar SkFindQuadMaxCurvature(const SkPoint src[3]);
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /** Given 3 points on a quadratic bezier, divide it into 2 quadratics
<span class="lineNum">      80 </span>            :     if the point of maximum curvature exists on the quad segment.
<span class="lineNum">      81 </span>            :     Depending on what is returned, dst[] is treated as follows
<span class="lineNum">      82 </span>            :     1   dst[0..2] is the original quad
<span class="lineNum">      83 </span>            :     2   dst[0..2] and dst[2..4] are the two new quads
<span class="lineNum">      84 </span>            :     If dst == null, it is ignored and only the count is returned.
<span class="lineNum">      85 </span>            : */
<span class="lineNum">      86 </span>            : int SkChopQuadAtMaxCurvature(const SkPoint src[3], SkPoint dst[5]);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /** Given 3 points on a quadratic bezier, use degree elevation to
<span class="lineNum">      89 </span>            :     convert it into the cubic fitting the same curve. The new cubic
<span class="lineNum">      90 </span>            :     curve is returned in dst[0..3].
<span class="lineNum">      91 </span>            : */
<span class="lineNum">      92 </span>            : SK_API void SkConvertQuadToCubic(const SkPoint src[3], SkPoint dst[4]);
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : /** Set pt to the point on the src cubic specified by t. t must be
<span class="lineNum">      97 </span>            :     0 &lt;= t &lt;= 1.0
<span class="lineNum">      98 </span>            : */
<span class="lineNum">      99 </span>            : void SkEvalCubicAt(const SkPoint src[4], SkScalar t, SkPoint* locOrNull,
<span class="lineNum">     100 </span>            :                    SkVector* tangentOrNull, SkVector* curvatureOrNull);
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : /** Given a src cubic bezier, chop it at the specified t value,
<span class="lineNum">     103 </span>            :     where 0 &lt; t &lt; 1, and return the two new cubics in dst:
<span class="lineNum">     104 </span>            :     dst[0..3] and dst[3..6]
<span class="lineNum">     105 </span>            : */
<span class="lineNum">     106 </span>            : void SkChopCubicAt(const SkPoint src[4], SkPoint dst[7], SkScalar t);
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /** Given a src cubic bezier, chop it at the specified t values,
<span class="lineNum">     109 </span>            :     where 0 &lt; t &lt; 1, and return the new cubics in dst:
<span class="lineNum">     110 </span>            :     dst[0..3],dst[3..6],...,dst[3*t_count..3*(t_count+1)]
<span class="lineNum">     111 </span>            : */
<span class="lineNum">     112 </span>            : void SkChopCubicAt(const SkPoint src[4], SkPoint dst[], const SkScalar t[],
<span class="lineNum">     113 </span>            :                    int t_count);
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /** Given a src cubic bezier, chop it at the specified t == 1/2,
<span class="lineNum">     116 </span>            :     The new cubics are returned in dst[0..3] and dst[3..6]
<span class="lineNum">     117 </span>            : */
<span class="lineNum">     118 </span>            : void SkChopCubicAtHalf(const SkPoint src[4], SkPoint dst[7]);
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : /** Given the 4 coefficients for a cubic bezier (either X or Y values), look
<span class="lineNum">     121 </span>            :     for extrema, and return the number of t-values that are found that represent
<span class="lineNum">     122 </span>            :     these extrema. If the cubic has no extrema betwee (0..1) exclusive, the
<span class="lineNum">     123 </span>            :     function returns 0.
<span class="lineNum">     124 </span>            :     Returned count      tValues[]
<span class="lineNum">     125 </span>            :     0                   ignored
<span class="lineNum">     126 </span>            :     1                   0 &lt; tValues[0] &lt; 1
<span class="lineNum">     127 </span>            :     2                   0 &lt; tValues[0] &lt; tValues[1] &lt; 1
<span class="lineNum">     128 </span>            : */
<span class="lineNum">     129 </span>            : int SkFindCubicExtrema(SkScalar a, SkScalar b, SkScalar c, SkScalar d,
<span class="lineNum">     130 </span>            :                        SkScalar tValues[2]);
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : /** Given 4 points on a cubic bezier, chop it into 1, 2, 3 beziers such that
<span class="lineNum">     133 </span>            :     the resulting beziers are monotonic in Y. This is called by the scan converter.
<span class="lineNum">     134 </span>            :     Depending on what is returned, dst[] is treated as follows
<span class="lineNum">     135 </span>            :     0   dst[0..3] is the original cubic
<span class="lineNum">     136 </span>            :     1   dst[0..3] and dst[3..6] are the two new cubics
<span class="lineNum">     137 </span>            :     2   dst[0..3], dst[3..6], dst[6..9] are the three new cubics
<span class="lineNum">     138 </span>            :     If dst == null, it is ignored and only the count is returned.
<span class="lineNum">     139 </span>            : */
<span class="lineNum">     140 </span>            : int SkChopCubicAtYExtrema(const SkPoint src[4], SkPoint dst[10]);
<span class="lineNum">     141 </span>            : int SkChopCubicAtXExtrema(const SkPoint src[4], SkPoint dst[10]);
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : /** Given a cubic bezier, return 0, 1, or 2 t-values that represent the
<span class="lineNum">     144 </span>            :     inflection points.
<span class="lineNum">     145 </span>            : */
<span class="lineNum">     146 </span>            : int SkFindCubicInflections(const SkPoint src[4], SkScalar tValues[2]);
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /** Return 1 for no chop, 2 for having chopped the cubic at a single
<span class="lineNum">     149 </span>            :     inflection point, 3 for having chopped at 2 inflection points.
<span class="lineNum">     150 </span>            :     dst will hold the resulting 1, 2, or 3 cubics.
<span class="lineNum">     151 </span>            : */
<span class="lineNum">     152 </span>            : int SkChopCubicAtInflections(const SkPoint src[4], SkPoint dst[10]);
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : int SkFindCubicMaxCurvature(const SkPoint src[4], SkScalar tValues[3]);
<span class="lineNum">     155 </span>            : int SkChopCubicAtMaxCurvature(const SkPoint src[4], SkPoint dst[13],
<span class="lineNum">     156 </span>            :                               SkScalar tValues[3] = nullptr);
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : bool SkChopMonoCubicAtX(SkPoint src[4], SkScalar y, SkPoint dst[7]);
<span class="lineNum">     159 </span>            : bool SkChopMonoCubicAtY(SkPoint src[4], SkScalar x, SkPoint dst[7]);
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : enum SkCubicType {
<span class="lineNum">     162 </span>            :     kSerpentine_SkCubicType,
<span class="lineNum">     163 </span>            :     kCusp_SkCubicType,
<span class="lineNum">     164 </span>            :     kLoop_SkCubicType,
<span class="lineNum">     165 </span>            :     kQuadratic_SkCubicType,
<span class="lineNum">     166 </span>            :     kLine_SkCubicType,
<span class="lineNum">     167 </span>            :     kPoint_SkCubicType
<span class="lineNum">     168 </span>            : };
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : /** Returns the cubic classification. Pass scratch storage for computing inflection data,
<span class="lineNum">     171 </span>            :     which can be used with additional work to find the loop intersections and so on.
<span class="lineNum">     172 </span>            : */
<span class="lineNum">     173 </span>            : SkCubicType SkClassifyCubic(const SkPoint p[4], SkScalar inflection[3]);
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : enum SkRotationDirection {
<span class="lineNum">     178 </span>            :     kCW_SkRotationDirection,
<span class="lineNum">     179 </span>            :     kCCW_SkRotationDirection
<span class="lineNum">     180 </span>            : };
<a name="181"><span class="lineNum">     181 </span>            : </a>
<a name="182"><span class="lineNum">     182 </span>            : struct SkConic {</a>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     SkConic() {}</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     SkConic(const SkPoint&amp; p0, const SkPoint&amp; p1, const SkPoint&amp; p2, SkScalar w) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         fPts[0] = p0;</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         fPts[1] = p1;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         fPts[2] = p2;</span>
<a name="188"><span class="lineNum">     188 </span><span class="lineNoCov">          0 :         fW = w;</span></a>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     SkConic(const SkPoint pts[3], SkScalar w) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         memcpy(fPts, pts, sizeof(fPts));</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         fW = w;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :     SkPoint  fPts[3];
<a name="196"><span class="lineNum">     196 </span>            :     SkScalar fW;</a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     void set(const SkPoint pts[3], SkScalar w) {</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         memcpy(fPts, pts, 3 * sizeof(SkPoint));</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         fW = w;</span>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     void set(const SkPoint&amp; p0, const SkPoint&amp; p1, const SkPoint&amp; p2, SkScalar w) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         fPts[0] = p0;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :         fPts[1] = p1;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         fPts[2] = p2;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         fW = w;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :     /**
<span class="lineNum">     211 </span>            :      *  Given a t-value [0...1] return its position and/or tangent.
<span class="lineNum">     212 </span>            :      *  If pos is not null, return its position at the t-value.
<span class="lineNum">     213 </span>            :      *  If tangent is not null, return its tangent at the t-value. NOTE the
<span class="lineNum">     214 </span>            :      *  tangent value's length is arbitrary, and only its direction should
<span class="lineNum">     215 </span>            :      *  be used.
<span class="lineNum">     216 </span>            :      */
<span class="lineNum">     217 </span>            :     void evalAt(SkScalar t, SkPoint* pos, SkVector* tangent = nullptr) const;
<span class="lineNum">     218 </span>            :     bool SK_WARN_UNUSED_RESULT chopAt(SkScalar t, SkConic dst[2]) const;
<span class="lineNum">     219 </span>            :     void chopAt(SkScalar t1, SkScalar t2, SkConic* dst) const;
<span class="lineNum">     220 </span>            :     void chop(SkConic dst[2]) const;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     SkPoint evalAt(SkScalar t) const;
<span class="lineNum">     223 </span>            :     SkVector evalTangentAt(SkScalar t) const;
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     void computeAsQuadError(SkVector* err) const;
<span class="lineNum">     226 </span>            :     bool asQuadTol(SkScalar tol) const;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :     /**
<span class="lineNum">     229 </span>            :      *  return the power-of-2 number of quads needed to approximate this conic
<span class="lineNum">     230 </span>            :      *  with a sequence of quads. Will be &gt;= 0.
<span class="lineNum">     231 </span>            :      */
<span class="lineNum">     232 </span>            :     int computeQuadPOW2(SkScalar tol) const;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     /**
<span class="lineNum">     235 </span>            :      *  Chop this conic into N quads, stored continguously in pts[], where
<span class="lineNum">     236 </span>            :      *  N = 1 &lt;&lt; pow2. The amount of storage needed is (1 + 2 * N)
<span class="lineNum">     237 </span>            :      */
<span class="lineNum">     238 </span>            :     int SK_WARN_UNUSED_RESULT chopIntoQuadsPOW2(SkPoint pts[], int pow2) const;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     bool findXExtrema(SkScalar* t) const;
<span class="lineNum">     241 </span>            :     bool findYExtrema(SkScalar* t) const;
<span class="lineNum">     242 </span>            :     bool chopAtXExtrema(SkConic dst[2]) const;
<span class="lineNum">     243 </span>            :     bool chopAtYExtrema(SkConic dst[2]) const;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :     void computeTightBounds(SkRect* bounds) const;
<span class="lineNum">     246 </span>            :     void computeFastBounds(SkRect* bounds) const;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :     /** Find the parameter value where the conic takes on its maximum curvature.
<span class="lineNum">     249 </span>            :      *
<span class="lineNum">     250 </span>            :      *  @param t   output scalar for max curvature.  Will be unchanged if
<span class="lineNum">     251 </span>            :      *             max curvature outside 0..1 range.
<span class="lineNum">     252 </span>            :      *
<span class="lineNum">     253 </span>            :      *  @return  true if max curvature found inside 0..1 range, false otherwise
<span class="lineNum">     254 </span>            :      */
<span class="lineNum">     255 </span>            : //    bool findMaxCurvature(SkScalar* t) const;  // unimplemented
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :     static SkScalar TransformW(const SkPoint[3], SkScalar w, const SkMatrix&amp;);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :     enum {
<span class="lineNum">     260 </span>            :         kMaxConicsForArc = 5
<span class="lineNum">     261 </span>            :     };
<span class="lineNum">     262 </span>            :     static int BuildUnitArc(const SkVector&amp; start, const SkVector&amp; stop, SkRotationDirection,
<span class="lineNum">     263 </span>            :                             const SkMatrix*, SkConic conics[kMaxConicsForArc]);
<span class="lineNum">     264 </span>            : };
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : // inline helpers are contained in a namespace to avoid external leakage to fragile SkNx members
<span class="lineNum">     267 </span>            : namespace {
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : /**
<span class="lineNum">     270 </span>            :  *  use for : eval(t) == A * t^2 + B * t + C
<a name="271"><span class="lineNum">     271 </span>            :  */</a>
<span class="lineNum">     272 </span>            : struct SkQuadCoeff {
<a name="273"><span class="lineNum">     273 </span><span class="lineCov">        192 :     SkQuadCoeff() {}</span></a>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     SkQuadCoeff(const Sk2s&amp; A, const Sk2s&amp; B, const Sk2s&amp; C)</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         : fA(A)</span>
<span class="lineNum">     277 </span>            :         , fB(B)
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         , fC(C)</span>
<span class="lineNum">     279 </span>            :     {
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">         48 :     SkQuadCoeff(const SkPoint src[3]) {</span>
<span class="lineNum">     283 </span><span class="lineCov">         16 :         fC = from_point(src[0]);</span>
<span class="lineNum">     284 </span><span class="lineCov">         16 :         Sk2s P1 = from_point(src[1]);</span>
<span class="lineNum">     285 </span><span class="lineCov">         16 :         Sk2s P2 = from_point(src[2]);</span>
<span class="lineNum">     286 </span><span class="lineCov">         32 :         fB = times_2(P1 - fC);</span>
<span class="lineNum">     287 </span><span class="lineCov">         48 :         fA = P2 - times_2(P1) + fC;</span>
<a name="288"><span class="lineNum">     288 </span><span class="lineCov">         16 :     }</span></a>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineCov">         64 :     Sk2s eval(SkScalar t) {</span>
<span class="lineNum">     291 </span>            :         Sk2s tt(t);
<span class="lineNum">     292 </span><span class="lineCov">         64 :         return eval(tt);</span>
<a name="293"><span class="lineNum">     293 </span>            :     }</a>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">         64 :     Sk2s eval(const Sk2s&amp; tt) {</span>
<span class="lineNum">     296 </span><span class="lineCov">        320 :         return (fA * tt + fB) * tt + fC;</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :     Sk2s fA;
<span class="lineNum">     300 </span>            :     Sk2s fB;
<span class="lineNum">     301 </span>            :     Sk2s fC;
<span class="lineNum">     302 </span>            : };
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            : struct SkConicCoeff {
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     SkConicCoeff(const SkConic&amp; conic) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         Sk2s p0 = from_point(conic.fPts[0]);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         Sk2s p1 = from_point(conic.fPts[1]);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         Sk2s p2 = from_point(conic.fPts[2]);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         Sk2s ww(conic.fW);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         Sk2s p1w = p1 * ww;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         fNumer.fC = p0;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         fNumer.fA = p2 - times_2(p1w) + p0;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         fNumer.fB = times_2(p1w - p0);</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         fDenom.fC = Sk2s(1);</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         fDenom.fB = times_2(ww - fDenom.fC);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         fDenom.fA = Sk2s(0) - fDenom.fB;</span>
<a name="319"><span class="lineNum">     319 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     Sk2s eval(SkScalar t) {</span>
<span class="lineNum">     322 </span>            :         Sk2s tt(t);
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         Sk2s numer = fNumer.eval(tt);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         Sk2s denom = fDenom.eval(tt);</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         return numer / denom;</span>
<span class="lineNum">     326 </span>            :     }
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     SkQuadCoeff fNumer;
<span class="lineNum">     329 </span>            :     SkQuadCoeff fDenom;
<span class="lineNum">     330 </span>            : };
<a name="331"><span class="lineNum">     331 </span>            : </a>
<span class="lineNum">     332 </span>            : struct SkCubicCoeff {
<span class="lineNum">     333 </span><span class="lineCov">       1160 :     SkCubicCoeff(const SkPoint src[4]) {</span>
<span class="lineNum">     334 </span><span class="lineCov">        290 :         Sk2s P0 = from_point(src[0]);</span>
<span class="lineNum">     335 </span><span class="lineCov">        290 :         Sk2s P1 = from_point(src[1]);</span>
<span class="lineNum">     336 </span><span class="lineCov">        290 :         Sk2s P2 = from_point(src[2]);</span>
<span class="lineNum">     337 </span><span class="lineCov">        290 :         Sk2s P3 = from_point(src[3]);</span>
<span class="lineNum">     338 </span>            :         Sk2s three(3);
<span class="lineNum">     339 </span><span class="lineCov">       1160 :         fA = P3 + three * (P1 - P2) - P0;</span>
<span class="lineNum">     340 </span><span class="lineCov">       1160 :         fB = three * (P2 - times_2(P1) + P0);</span>
<span class="lineNum">     341 </span><span class="lineCov">        580 :         fC = three * (P1 - P0);</span>
<span class="lineNum">     342 </span><span class="lineCov">        290 :         fD = P0;</span>
<a name="343"><span class="lineNum">     343 </span><span class="lineCov">        290 :     }</span></a>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineCov">        290 :     Sk2s eval(SkScalar t) {</span>
<span class="lineNum">     346 </span>            :         Sk2s tt(t);
<span class="lineNum">     347 </span><span class="lineCov">        290 :         return eval(tt);</span>
<a name="348"><span class="lineNum">     348 </span>            :     }</a>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineCov">        290 :     Sk2s eval(const Sk2s&amp; t) {</span>
<span class="lineNum">     351 </span><span class="lineCov">       2030 :         return ((fA * t + fB) * t + fC) * t + fD;</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :     Sk2s fA;
<span class="lineNum">     355 </span>            :     Sk2s fB;
<span class="lineNum">     356 </span>            :     Sk2s fC;
<span class="lineNum">     357 </span>            :     Sk2s fD;
<span class="lineNum">     358 </span>            : };
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : #include &quot;SkTemplates.h&quot;
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /**
<a name="365"><span class="lineNum">     365 </span>            :  *  Help class to allocate storage for approximating a conic with N quads.</a>
<span class="lineNum">     366 </span>            :  */
<a name="367"><span class="lineNum">     367 </span><span class="lineCov">         66 : class SkAutoConicToQuads {</span></a>
<span class="lineNum">     368 </span>            : public:
<span class="lineNum">     369 </span><span class="lineCov">         66 :     SkAutoConicToQuads() : fQuadCount(0) {}</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :     /**
<span class="lineNum">     372 </span>            :      *  Given a conic and a tolerance, return the array of points for the
<span class="lineNum">     373 </span>            :      *  approximating quad(s). Call countQuads() to know the number of quads
<span class="lineNum">     374 </span>            :      *  represented in these points.
<span class="lineNum">     375 </span>            :      *
<span class="lineNum">     376 </span>            :      *  The quads are allocated to share end-points. e.g. if there are 4 quads,
<span class="lineNum">     377 </span>            :      *  there will be 9 points allocated as follows
<span class="lineNum">     378 </span>            :      *      quad[0] == pts[0..2]
<span class="lineNum">     379 </span>            :      *      quad[1] == pts[2..4]
<span class="lineNum">     380 </span>            :      *      quad[2] == pts[4..6]
<a name="381"><span class="lineNum">     381 </span>            :      *      quad[3] == pts[6..8]</a>
<span class="lineNum">     382 </span>            :      */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     const SkPoint* computeQuads(const SkConic&amp; conic, SkScalar tol) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         int pow2 = conic.computeQuadPOW2(tol);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         fQuadCount = 1 &lt;&lt; pow2;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         SkPoint* pts = fStorage.reset(1 + 2 * fQuadCount);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         fQuadCount = conic.chopIntoQuadsPOW2(pts, pow2);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         return pts;</span>
<a name="389"><span class="lineNum">     389 </span>            :     }</a>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     const SkPoint* computeQuads(const SkPoint pts[3], SkScalar weight,</span>
<span class="lineNum">     392 </span>            :                                 SkScalar tol) {
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         SkConic conic;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         conic.set(pts, weight);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         return computeQuads(conic, tol);</span>
<a name="396"><span class="lineNum">     396 </span>            :     }</a>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     int countQuads() const { return fQuadCount; }</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : private:
<span class="lineNum">     401 </span>            :     enum {
<span class="lineNum">     402 </span>            :         kQuadCount = 8, // should handle most conics
<span class="lineNum">     403 </span>            :         kPointCount = 1 + 2 * kQuadCount,
<span class="lineNum">     404 </span>            :     };
<span class="lineNum">     405 </span>            :     SkAutoSTMalloc&lt;kPointCount, SkPoint&gt; fStorage;
<span class="lineNum">     406 </span>            :     int fQuadCount; // #quads for current usage
<span class="lineNum">     407 </span>            : };
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/pathops/SkPathOpsQuad.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/pathops</a> - SkPathOpsQuad.cpp<span style="font-size: 80%;"> (source / <a href="SkPathOpsQuad.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntry">211</td>
            <td class="headerCovTableEntryLo">10.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryLo">8.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2012 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : #include &quot;SkIntersections.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;SkLineParameters.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;SkPathOpsCubic.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;SkPathOpsCurve.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;SkPathOpsQuad.h&quot;
<a name="12"><span class="lineNum">      12 </span>            : </a>
<span class="lineNum">      13 </span>            : // from blackpawn.com/texts/pointinpoly
<span class="lineNum">      14 </span><span class="lineNoCov">          0 : static bool pointInTriangle(const SkDPoint fPts[3], const SkDPoint&amp; test) {</span>
<span class="lineNum">      15 </span><span class="lineNoCov">          0 :     SkDVector v0 = fPts[2] - fPts[0];</span>
<span class="lineNum">      16 </span><span class="lineNoCov">          0 :     SkDVector v1 = fPts[1] - fPts[0];</span>
<span class="lineNum">      17 </span><span class="lineNoCov">          0 :     SkDVector v2 = test - fPts[0];</span>
<span class="lineNum">      18 </span><span class="lineNoCov">          0 :     double dot00 = v0.dot(v0);</span>
<span class="lineNum">      19 </span><span class="lineNoCov">          0 :     double dot01 = v0.dot(v1);</span>
<span class="lineNum">      20 </span><span class="lineNoCov">          0 :     double dot02 = v0.dot(v2);</span>
<span class="lineNum">      21 </span><span class="lineNoCov">          0 :     double dot11 = v1.dot(v1);</span>
<span class="lineNum">      22 </span><span class="lineNoCov">          0 :     double dot12 = v1.dot(v2);</span>
<span class="lineNum">      23 </span>            :     // Compute barycentric coordinates
<span class="lineNum">      24 </span><span class="lineNoCov">          0 :     double invDenom = 1 / (dot00 * dot11 - dot01 * dot01);</span>
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :     double u = (dot11 * dot02 - dot01 * dot12) * invDenom;</span>
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :     double v = (dot00 * dot12 - dot01 * dot02) * invDenom;</span>
<span class="lineNum">      27 </span>            :     // Check if point is in triangle
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :     return u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; u + v &lt; 1;</span>
<a name="29"><span class="lineNum">      29 </span>            : }</a>
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span><span class="lineNoCov">          0 : static bool matchesEnd(const SkDPoint fPts[3], const SkDPoint&amp; test) {</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :     return fPts[0] == test || fPts[2] == test;</span>
<span class="lineNum">      33 </span>            : }
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /* started with at_most_end_pts_in_common from SkDQuadIntersection.cpp */
<span class="lineNum">      36 </span>            : // Do a quick reject by rotating all points relative to a line formed by
<span class="lineNum">      37 </span>            : // a pair of one quad's points. If the 2nd quad's points
<span class="lineNum">      38 </span>            : // are on the line or on the opposite side from the 1st quad's 'odd man', the
<span class="lineNum">      39 </span>            : // curves at most intersect at the endpoints.
<span class="lineNum">      40 </span>            : /* if returning true, check contains true if quad's hull collapsed, making the cubic linear
<a name="41"><span class="lineNum">      41 </span>            :    if returning false, check contains true if the the quad pair have only the end point in common</a>
<span class="lineNum">      42 </span>            : */
<span class="lineNum">      43 </span><span class="lineNoCov">          0 : bool SkDQuad::hullIntersects(const SkDQuad&amp; q2, bool* isLinear) const {</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :     bool linear = true;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :     for (int oddMan = 0; oddMan &lt; kPointCount; ++oddMan) {</span>
<span class="lineNum">      46 </span>            :         const SkDPoint* endPt[2];
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :         this-&gt;otherPts(oddMan, endPt);</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :         double origX = endPt[0]-&gt;fX;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :         double origY = endPt[0]-&gt;fY;</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :         double adj = endPt[1]-&gt;fX - origX;</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :         double opp = endPt[1]-&gt;fY - origY;</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :         double sign = (fPts[oddMan].fY - origY) * adj - (fPts[oddMan].fX - origX) * opp;</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :         if (approximately_zero(sign)) {</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">      55 </span>            :         }
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         linear = false;</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :         bool foundOutlier = false;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :         for (int n = 0; n &lt; kPointCount; ++n) {</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :             double test = (q2[n].fY - origY) * adj - (q2[n].fX - origX) * opp;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :             if (test * sign &gt; 0 &amp;&amp; !precisely_zero(test)) {</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :                 foundOutlier = true;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">      63 </span>            :             }
<span class="lineNum">      64 </span>            :         }
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         if (!foundOutlier) {</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">      67 </span>            :         }
<span class="lineNum">      68 </span>            :     }
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     if (linear &amp;&amp; !matchesEnd(fPts, q2.fPts[0]) &amp;&amp; !matchesEnd(fPts, q2.fPts[2])) {</span>
<span class="lineNum">      70 </span>            :         // if the end point of the opposite quad is inside the hull that is nearly a line,
<span class="lineNum">      71 </span>            :         // then representing the quad as a line may cause the intersection to be missed.
<span class="lineNum">      72 </span>            :         // Check to see if the endpoint is in the triangle.
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         if (pointInTriangle(fPts, q2.fPts[0]) || pointInTriangle(fPts, q2.fPts[2])) {</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :             linear = false;</span>
<span class="lineNum">      75 </span>            :         }
<span class="lineNum">      76 </span>            :     }
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     *isLinear = linear;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="79"><span class="lineNum">      79 </span>            : }</a>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : bool SkDQuad::hullIntersects(const SkDConic&amp; conic, bool* isLinear) const {</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     return conic.hullIntersects(*this, isLinear);</span>
<a name="83"><span class="lineNum">      83 </span>            : }</a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 : bool SkDQuad::hullIntersects(const SkDCubic&amp; cubic, bool* isLinear) const {</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     return cubic.hullIntersects(*this, isLinear);</span>
<span class="lineNum">      87 </span>            : }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : /* bit twiddling for finding the off curve index (x&amp;~m is the pair in [0,1,2] excluding oddMan)
<span class="lineNum">      90 </span>            : oddMan    opp   x=oddMan^opp  x=x-oddMan  m=x&gt;&gt;2   x&amp;~m
<span class="lineNum">      91 </span>            :     0       1         1            1         0       1
<span class="lineNum">      92 </span>            :             2         2            2         0       2
<span class="lineNum">      93 </span>            :     1       1         0           -1        -1       0
<span class="lineNum">      94 </span>            :             2         3            2         0       2
<span class="lineNum">      95 </span>            :     2       1         3            1         0       1
<a name="96"><span class="lineNum">      96 </span>            :             2         0           -2        -1       0</a>
<span class="lineNum">      97 </span>            : */
<span class="lineNum">      98 </span><span class="lineNoCov">          0 : void SkDQuad::otherPts(int oddMan, const SkDPoint* endPt[2]) const {</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     for (int opp = 1; opp &lt; kPointCount; ++opp) {</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :         int end = (oddMan ^ opp) - oddMan;  // choose a value not equal to oddMan</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         end &amp;= ~(end &gt;&gt; 2);  // if the value went negative, set it to zero</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         endPt[opp - 1] = &amp;fPts[end];</span>
<span class="lineNum">     103 </span>            :     }
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineCov">         33 : int SkDQuad::AddValidTs(double s[], int realRoots, double* t) {</span>
<span class="lineNum">     107 </span><span class="lineCov">         33 :     int foundRoots = 0;</span>
<span class="lineNum">     108 </span><span class="lineCov">        130 :     for (int index = 0; index &lt; realRoots; ++index) {</span>
<span class="lineNum">     109 </span><span class="lineCov">         97 :         double tValue = s[index];</span>
<span class="lineNum">     110 </span><span class="lineCov">         97 :         if (approximately_zero_or_more(tValue) &amp;&amp; approximately_one_or_less(tValue)) {</span>
<span class="lineNum">     111 </span><span class="lineCov">         33 :             if (approximately_less_than_zero(tValue)) {</span>
<span class="lineNum">     112 </span><span class="lineCov">          3 :                 tValue = 0;</span>
<span class="lineNum">     113 </span><span class="lineCov">         30 :             } else if (approximately_greater_than_one(tValue)) {</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                 tValue = 1;</span>
<span class="lineNum">     115 </span>            :             }
<span class="lineNum">     116 </span><span class="lineCov">         33 :             for (int idx2 = 0; idx2 &lt; foundRoots; ++idx2) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :                 if (approximately_equal(t[idx2], tValue)) {</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :                     goto nextRoot;</span>
<span class="lineNum">     119 </span>            :                 }
<span class="lineNum">     120 </span>            :             }
<span class="lineNum">     121 </span><span class="lineCov">         33 :             t[foundRoots++] = tValue;</span>
<span class="lineNum">     122 </span>            :         }
<span class="lineNum">     123 </span>            : nextRoot:
<span class="lineNum">     124 </span>            :         {}
<span class="lineNum">     125 </span>            :     }
<span class="lineNum">     126 </span><span class="lineCov">         33 :     return foundRoots;</span>
<span class="lineNum">     127 </span>            : }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : // note: caller expects multiple results to be sorted smaller first
<span class="lineNum">     130 </span>            : // note: http://en.wikipedia.org/wiki/Loss_of_significance has an interesting
<span class="lineNum">     131 </span>            : //  analysis of the quadratic equation, suggesting why the following looks at
<a name="132"><span class="lineNum">     132 </span>            : //  the sign of B -- and further suggesting that the greatest loss of precision</a>
<span class="lineNum">     133 </span>            : //  is in b squared less two a c
<span class="lineNum">     134 </span><span class="lineNoCov">          0 : int SkDQuad::RootsValidT(double A, double B, double C, double t[2]) {</span>
<span class="lineNum">     135 </span>            :     double s[2];
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     int realRoots = RootsReal(A, B, C, s);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     int foundRoots = AddValidTs(s, realRoots, t);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     return foundRoots;</span>
<span class="lineNum">     139 </span>            : }
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : /*
<span class="lineNum">     142 </span>            : Numeric Solutions (5.6) suggests to solve the quadratic by computing
<span class="lineNum">     143 </span>            :        Q = -1/2(B + sgn(B)Sqrt(B^2 - 4 A C))
<span class="lineNum">     144 </span>            : and using the roots
<span class="lineNum">     145 </span>            :       t1 = Q / A
<span class="lineNum">     146 </span>            :       t2 = C / Q
<a name="147"><span class="lineNum">     147 </span>            : */</a>
<span class="lineNum">     148 </span>            : // this does not discard real roots &lt;= 0 or &gt;= 1
<span class="lineNum">     149 </span><span class="lineCov">          1 : int SkDQuad::RootsReal(const double A, const double B, const double C, double s[2]) {</span>
<span class="lineNum">     150 </span><span class="lineCov">          1 :     const double p = B / (2 * A);</span>
<span class="lineNum">     151 </span><span class="lineCov">          1 :     const double q = C / A;</span>
<span class="lineNum">     152 </span><span class="lineCov">          1 :     if (!A || (approximately_zero(A) &amp;&amp; (approximately_zero_inverse(p)</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             || approximately_zero_inverse(q)))) {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         if (approximately_zero(B)) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             s[0] = 0;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :             return C == 0;</span>
<span class="lineNum">     157 </span>            :         }
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         s[0] = -C / B;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span>            :     /* normal form: x^2 + px + q = 0 */
<span class="lineNum">     162 </span><span class="lineCov">          1 :     const double p2 = p * p;</span>
<span class="lineNum">     163 </span><span class="lineCov">          1 :     if (!AlmostDequalUlps(p2, q) &amp;&amp; p2 &lt; q) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span><span class="lineCov">          1 :     double sqrt_D = 0;</span>
<span class="lineNum">     167 </span><span class="lineCov">          1 :     if (p2 &gt; q) {</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :         sqrt_D = sqrt(p2 - q);</span>
<span class="lineNum">     169 </span>            :     }
<span class="lineNum">     170 </span><span class="lineCov">          1 :     s[0] = sqrt_D - p;</span>
<span class="lineNum">     171 </span><span class="lineCov">          1 :     s[1] = -sqrt_D - p;</span>
<span class="lineNum">     172 </span><span class="lineCov">          1 :     return 1 + !AlmostDequalUlps(s[0], s[1]);</span>
<a name="173"><span class="lineNum">     173 </span>            : }</a>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : bool SkDQuad::isLinear(int startIndex, int endIndex) const {</span>
<span class="lineNum">     176 </span>            :     SkLineParameters lineParameters;
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     lineParameters.quadEndPoints(*this, startIndex, endIndex);</span>
<span class="lineNum">     178 </span>            :     // FIXME: maybe it's possible to avoid this and compare non-normalized
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     lineParameters.normalize();</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     double distance = lineParameters.controlPtDistance(*this);</span>
<span class="lineNum">     181 </span>            :     double tiniest = SkTMin(SkTMin(SkTMin(SkTMin(SkTMin(fPts[0].fX, fPts[0].fY),
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :             fPts[1].fX), fPts[1].fY), fPts[2].fX), fPts[2].fY);</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     double largest = SkTMax(SkTMax(SkTMax(SkTMax(SkTMax(fPts[0].fX, fPts[0].fY),</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :             fPts[1].fX), fPts[1].fY), fPts[2].fX), fPts[2].fY);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     largest = SkTMax(largest, -tiniest);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     return approximately_zero_when_compared_to(distance, largest);</span>
<a name="187"><span class="lineNum">     187 </span>            : }</a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : SkDVector SkDQuad::dxdyAtT(double t) const {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     double a = t - 1;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     double b = 1 - 2 * t;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     double c = t;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     SkDVector result = { a * fPts[0].fX + b * fPts[1].fX + c * fPts[2].fX,</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :             a * fPts[0].fY + b * fPts[1].fY + c * fPts[2].fY };</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     if (result.fX == 0 &amp;&amp; result.fY == 0) {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         if (zero_or_one(t)) {</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :             result = fPts[2] - fPts[0];</span>
<span class="lineNum">     198 </span>            :         } else {
<span class="lineNum">     199 </span>            :             // incomplete
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :             SkDebugf(&quot;!q&quot;);</span>
<span class="lineNum">     201 </span>            :         }
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     204 </span>            : }
<a name="205"><span class="lineNum">     205 </span>            : </a>
<span class="lineNum">     206 </span>            : // OPTIMIZE: assert if caller passes in t == 0 / t == 1 ?
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : SkDPoint SkDQuad::ptAtT(double t) const {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     if (0 == t) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         return fPts[0];</span>
<span class="lineNum">     210 </span>            :     }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (1 == t) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         return fPts[2];</span>
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     double one_t = 1 - t;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     double a = one_t * one_t;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     double b = 2 * one_t * t;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     double c = t * t;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     SkDPoint result = { a * fPts[0].fX + b * fPts[1].fX + c * fPts[2].fX,</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :             a * fPts[0].fY + b * fPts[1].fY + c * fPts[2].fY };</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="221"><span class="lineNum">     221 </span>            : }</a>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : static double interp_quad_coords(const double* src, double t) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if (0 == t) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         return src[0];</span>
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     if (1 == t) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         return src[4];</span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     double ab = SkDInterp(src[0], src[2], t);</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     double bc = SkDInterp(src[2], src[4], t);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     double abc = SkDInterp(ab, bc, t);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     return abc;</span>
<a name="234"><span class="lineNum">     234 </span>            : }</a>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : bool SkDQuad::monotonicInX() const {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     return between(fPts[0].fX, fPts[1].fX, fPts[2].fX);</span>
<a name="238"><span class="lineNum">     238 </span>            : }</a>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 : bool SkDQuad::monotonicInY() const {</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     return between(fPts[0].fY, fPts[1].fY, fPts[2].fY);</span>
<span class="lineNum">     242 </span>            : }
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : /*
<span class="lineNum">     245 </span>            : Given a quadratic q, t1, and t2, find a small quadratic segment.
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : The new quadratic is defined by A, B, and C, where
<span class="lineNum">     248 </span>            :  A = c[0]*(1 - t1)*(1 - t1) + 2*c[1]*t1*(1 - t1) + c[2]*t1*t1
<span class="lineNum">     249 </span>            :  C = c[3]*(1 - t1)*(1 - t1) + 2*c[2]*t1*(1 - t1) + c[1]*t1*t1
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : To find B, compute the point halfway between t1 and t2:
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : q(at (t1 + t2)/2) == D
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : Next, compute where D must be if we know the value of B:
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : _12 = A/2 + B/2
<span class="lineNum">     258 </span>            : 12_ = B/2 + C/2
<span class="lineNum">     259 </span>            : 123 = A/4 + B/2 + C/4
<span class="lineNum">     260 </span>            :     = D
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : Group the known values on one side:
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : B   = D*2 - A/2 - C/2
<span class="lineNum">     265 </span>            : */
<a name="266"><span class="lineNum">     266 </span>            : </a>
<span class="lineNum">     267 </span>            : // OPTIMIZE? : special case  t1 = 1 &amp;&amp; t2 = 0
<span class="lineNum">     268 </span><span class="lineNoCov">          0 : SkDQuad SkDQuad::subDivide(double t1, double t2) const {</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     if (0 == t1 &amp;&amp; 1 == t2) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         return *this;</span>
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span>            :     SkDQuad dst;
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     double ax = dst[0].fX = interp_quad_coords(&amp;fPts[0].fX, t1);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     double ay = dst[0].fY = interp_quad_coords(&amp;fPts[0].fY, t1);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     double dx = interp_quad_coords(&amp;fPts[0].fX, (t1 + t2) / 2);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     double dy = interp_quad_coords(&amp;fPts[0].fY, (t1 + t2) / 2);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     double cx = dst[2].fX = interp_quad_coords(&amp;fPts[0].fX, t2);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     double cy = dst[2].fY = interp_quad_coords(&amp;fPts[0].fY, t2);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     /* bx = */ dst[1].fX = 2 * dx - (ax + cx) / 2;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     /* by = */ dst[1].fY = 2 * dy - (ay + cy) / 2;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     return dst;</span>
<a name="282"><span class="lineNum">     282 </span>            : }</a>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : void SkDQuad::align(int endIndex, SkDPoint* dstPt) const {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     if (fPts[endIndex].fX == fPts[1].fX) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         dstPt-&gt;fX = fPts[endIndex].fX;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     if (fPts[endIndex].fY == fPts[1].fY) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         dstPt-&gt;fY = fPts[endIndex].fY;</span>
<span class="lineNum">     290 </span>            :     }
<a name="291"><span class="lineNum">     291 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineNoCov">          0 : SkDPoint SkDQuad::subDivide(const SkDPoint&amp; a, const SkDPoint&amp; c, double t1, double t2) const {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     SkASSERT(t1 != t2);</span>
<span class="lineNum">     295 </span>            :     SkDPoint b;
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     SkDQuad sub = subDivide(t1, t2);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     SkDLine b0 = {{a, sub[1] + (a - sub[0])}};</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     SkDLine b1 = {{c, sub[1] + (c - sub[2])}};</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     SkIntersections i;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     i.intersectRay(b0, b1);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     if (i.used() == 1 &amp;&amp; i[0][0] &gt;= 0 &amp;&amp; i[1][0] &gt;= 0) {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         b = i.pt(0);</span>
<span class="lineNum">     303 </span>            :     } else {
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         SkASSERT(i.used() &lt;= 2);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         return SkDPoint::Mid(b0[1], b1[1]);</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     if (t1 == 0 || t2 == 0) {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         align(0, &amp;b);</span>
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     if (t1 == 1 || t2 == 1) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         align(2, &amp;b);</span>
<span class="lineNum">     312 </span>            :     }
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     if (AlmostBequalUlps(b.fX, a.fX)) {</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         b.fX = a.fX;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     } else if (AlmostBequalUlps(b.fX, c.fX)) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         b.fX = c.fX;</span>
<span class="lineNum">     317 </span>            :     }
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (AlmostBequalUlps(b.fY, a.fY)) {</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :         b.fY = a.fY;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     } else if (AlmostBequalUlps(b.fY, c.fY)) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         b.fY = c.fY;</span>
<span class="lineNum">     322 </span>            :     }
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     return b;</span>
<span class="lineNum">     324 </span>            : }
<a name="325"><span class="lineNum">     325 </span>            : </a>
<span class="lineNum">     326 </span>            : /* classic one t subdivision */
<span class="lineNum">     327 </span><span class="lineNoCov">          0 : static void interp_quad_coords(const double* src, double* dst, double t) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     double ab = SkDInterp(src[0], src[2], t);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     double bc = SkDInterp(src[2], src[4], t);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     dst[0] = src[0];</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     dst[2] = ab;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     dst[4] = SkDInterp(ab, bc, t);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     dst[6] = bc;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     dst[8] = src[4];</span>
<a name="335"><span class="lineNum">     335 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : SkDQuadPair SkDQuad::chopAt(double t) const</span>
<span class="lineNum">     338 </span>            : {
<span class="lineNum">     339 </span>            :     SkDQuadPair dst;
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     interp_quad_coords(&amp;fPts[0].fX, &amp;dst.pts[0].fX, t);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     interp_quad_coords(&amp;fPts[0].fY, &amp;dst.pts[0].fY, t);</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     return dst;</span>
<a name="343"><span class="lineNum">     343 </span>            : }</a>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 : static int valid_unit_divide(double numer, double denom, double* ratio)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     if (numer &lt; 0) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         numer = -numer;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         denom = -denom;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     if (denom == 0 || numer == 0 || numer &gt;= denom) {</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     double r = numer / denom;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (r == 0) {  // catch underflow if numer &lt;&lt;&lt;&lt; denom</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     357 </span>            :     }
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     *ratio = r;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     360 </span>            : }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : /** Quad'(t) = At + B, where
<span class="lineNum">     363 </span>            :     A = 2(a - 2b + c)
<span class="lineNum">     364 </span>            :     B = 2(b - a)
<a name="365"><span class="lineNum">     365 </span>            :     Solve for t, only if it fits between 0 &lt; t &lt; 1</a>
<span class="lineNum">     366 </span>            : */
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : int SkDQuad::FindExtrema(const double src[], double tValue[1]) {</span>
<span class="lineNum">     368 </span>            :     /*  At + B == 0
<span class="lineNum">     369 </span>            :         t = -B / A
<span class="lineNum">     370 </span>            :     */
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     double a = src[0];</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     double b = src[2];</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     double c = src[4];</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     return valid_unit_divide(a - b, a - b - b + c, tValue);</span>
<span class="lineNum">     375 </span>            : }
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : /* Parameterization form, given A*t*t + 2*B*t*(1-t) + C*(1-t)*(1-t)
<span class="lineNum">     378 </span>            :  *
<span class="lineNum">     379 </span>            :  * a = A - 2*B +   C
<span class="lineNum">     380 </span>            :  * b =     2*B - 2*C
<a name="381"><span class="lineNum">     381 </span>            :  * c =             C</a>
<span class="lineNum">     382 </span>            :  */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 : void SkDQuad::SetABC(const double* quad, double* a, double* b, double* c) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     *a = quad[0];      // a = A</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     *b = 2 * quad[2];  // b =     2*B</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     *c = quad[4];      // c =             C</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     *b -= *c;          // b =     2*B -   C</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     *a -= *b;          // a = A - 2*B +   C</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     *b -= *c;          // b =     2*B - 2*C</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

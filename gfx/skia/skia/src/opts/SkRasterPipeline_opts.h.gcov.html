<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/skia/skia/src/opts/SkRasterPipeline_opts.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">gfx/skia/skia/src/opts</a> - SkRasterPipeline_opts.h<span style="font-size: 80%;"> (source / <a href="SkRasterPipeline_opts.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">656</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">181</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright 2016 Google Inc.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       5 </span>            :  * found in the LICENSE file.
<span class="lineNum">       6 </span>            :  */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #ifndef SkRasterPipeline_opts_DEFINED
<span class="lineNum">       9 </span>            : #define SkRasterPipeline_opts_DEFINED
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;SkColorPriv.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;SkColorLookUpTable.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;SkColorSpaceXform_A2B.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;SkColorSpaceXformPriv.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;SkHalf.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;SkMSAN.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;SkPM4f.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;SkPM4fPriv.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;SkRasterPipeline.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;SkShader.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;SkSRGB.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;../jumper/SkJumper.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : namespace {
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :     static constexpr int N = 4;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :     using SkNf = SkNx&lt;N, float&gt;;
<span class="lineNum">      29 </span>            :     using SkNi = SkNx&lt;N, int32_t&gt;;
<span class="lineNum">      30 </span>            :     using SkNu = SkNx&lt;N, uint32_t&gt;;
<span class="lineNum">      31 </span>            :     using SkNh = SkNx&lt;N, uint16_t&gt;;
<span class="lineNum">      32 </span>            :     using SkNb = SkNx&lt;N, uint8_t&gt;;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            :     using Fn = void(SK_VECTORCALL *)(size_t x_tail, void** p, SkNf,SkNf,SkNf,SkNf,
<span class="lineNum">      35 </span>            :                                                               SkNf,SkNf,SkNf,SkNf);
<span class="lineNum">      36 </span>            :     // x_tail encodes two values x and tail as x*N+tail, where 0 &lt;= tail &lt; N.
<span class="lineNum">      37 </span>            :     // x is the induction variable we're walking along, incrementing by N each step.
<span class="lineNum">      38 </span>            :     // tail == 0 means work with a full N pixels; otherwise use only the low tail pixels.
<span class="lineNum">      39 </span>            :     //
<span class="lineNum">      40 </span>            :     // p is our program, a sequence of Fn to call interlaced with any void* context pointers.  E.g.
<span class="lineNum">      41 </span>            :     //    &amp;load_8888
<span class="lineNum">      42 </span>            :     //    (src ptr)
<span class="lineNum">      43 </span>            :     //    &amp;from_srgb
<span class="lineNum">      44 </span>            :     //    &amp;move_src_dst
<span class="lineNum">      45 </span>            :     //    &amp;load_f16
<span class="lineNum">      46 </span>            :     //    (dst ptr)
<span class="lineNum">      47 </span>            :     //    &amp;swap
<span class="lineNum">      48 </span>            :     //    &amp;srcover
<span class="lineNum">      49 </span>            :     //    &amp;store_f16
<span class="lineNum">      50 </span>            :     //    (dst ptr)
<span class="lineNum">      51 </span>            :     //    &amp;just_return
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : }  // namespace
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #define SI static inline
<a name="56"><span class="lineNum">      56 </span>            : </a>
<span class="lineNum">      57 </span>            : // Basically, return *(*ptr)++, maybe faster than the compiler can do it.
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : SI void* load_and_increment(void*** ptr) {</span>
<span class="lineNum">      59 </span>            :     // We do this often enough that it's worth hyper-optimizing.
<span class="lineNum">      60 </span>            :     // x86 can do this in one instruction if ptr is in rsi.
<span class="lineNum">      61 </span>            :     // (This is why p is the second argument to Fn: it's passed in rsi.)
<span class="lineNum">      62 </span>            : #if defined(__GNUC__) &amp;&amp; defined(__x86_64__)
<span class="lineNum">      63 </span>            :     void* rax;
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     __asm__(&quot;lodsq&quot; : &quot;=a&quot;(rax), &quot;+S&quot;(*ptr));</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     return rax;</span>
<span class="lineNum">      66 </span>            : #else
<span class="lineNum">      67 </span>            :     return *(*ptr)++;
<span class="lineNum">      68 </span>            : #endif
<span class="lineNum">      69 </span>            : }
<span class="lineNum">      70 </span>            : 
<a name="71"><span class="lineNum">      71 </span>            : // Stages are logically a pipeline, and physically are contiguous in an array.</a>
<span class="lineNum">      72 </span>            : // To get to the next stage, we just increment our pointer to the next array element.
<span class="lineNum">      73 </span><span class="lineNoCov">          0 : SI void SK_VECTORCALL next(size_t x_tail, void** p, SkNf  r, SkNf  g, SkNf  b, SkNf  a,</span>
<span class="lineNum">      74 </span>            :                                                     SkNf dr, SkNf dg, SkNf db, SkNf da) {
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     auto next = (Fn)load_and_increment(&amp;p);</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     next(x_tail,p, r,g,b,a, dr,dg,db,da);</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      78 </span>            : 
<a name="79"><span class="lineNum">      79 </span>            : // Stages defined below always call next.</a>
<span class="lineNum">      80 </span>            : // This is always the last stage, a backstop that actually returns to the caller when done.
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : SI void SK_VECTORCALL just_return(size_t, void**, SkNf, SkNf, SkNf, SkNf,</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :                                                   SkNf, SkNf, SkNf, SkNf) {}</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : #define STAGE(name)                                                                      \
<span class="lineNum">      85 </span>            :     static SK_ALWAYS_INLINE void name##_kernel(size_t x, size_t tail,                    \
<span class="lineNum">      86 </span>            :                                                SkNf&amp;  r, SkNf&amp;  g, SkNf&amp;  b, SkNf&amp;  a,   \
<span class="lineNum">      87 </span>            :                                                SkNf&amp; dr, SkNf&amp; dg, SkNf&amp; db, SkNf&amp; da);  \
<span class="lineNum">      88 </span>            :     SI void SK_VECTORCALL name(size_t x_tail, void** p,                                  \
<span class="lineNum">      89 </span>            :                                SkNf  r, SkNf  g, SkNf  b, SkNf  a,                       \
<span class="lineNum">      90 </span>            :                                SkNf dr, SkNf dg, SkNf db, SkNf da) {                     \
<span class="lineNum">      91 </span>            :         name##_kernel(x_tail/N, x_tail%N, r,g,b,a, dr,dg,db,da);                         \
<span class="lineNum">      92 </span>            :         next(x_tail,p, r,g,b,a, dr,dg,db,da);                                            \
<span class="lineNum">      93 </span>            :     }                                                                                    \
<span class="lineNum">      94 </span>            :     static SK_ALWAYS_INLINE void name##_kernel(size_t x, size_t tail,                    \
<span class="lineNum">      95 </span>            :                                                SkNf&amp;  r, SkNf&amp;  g, SkNf&amp;  b, SkNf&amp;  a,   \
<span class="lineNum">      96 </span>            :                                                SkNf&amp; dr, SkNf&amp; dg, SkNf&amp; db, SkNf&amp; da)
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : #define STAGE_CTX(name, Ctx)                                                             \
<span class="lineNum">      99 </span>            :     static SK_ALWAYS_INLINE void name##_kernel(Ctx ctx, size_t x, size_t tail,           \
<span class="lineNum">     100 </span>            :                                                SkNf&amp;  r, SkNf&amp;  g, SkNf&amp;  b, SkNf&amp;  a,   \
<span class="lineNum">     101 </span>            :                                                SkNf&amp; dr, SkNf&amp; dg, SkNf&amp; db, SkNf&amp; da);  \
<span class="lineNum">     102 </span>            :     SI void SK_VECTORCALL name(size_t x_tail, void** p,                                  \
<span class="lineNum">     103 </span>            :                                SkNf  r, SkNf  g, SkNf  b, SkNf  a,                       \
<span class="lineNum">     104 </span>            :                                SkNf dr, SkNf dg, SkNf db, SkNf da) {                     \
<span class="lineNum">     105 </span>            :         auto ctx = (Ctx)load_and_increment(&amp;p);                                          \
<span class="lineNum">     106 </span>            :         name##_kernel(ctx, x_tail/N, x_tail%N, r,g,b,a, dr,dg,db,da);                    \
<span class="lineNum">     107 </span>            :         next(x_tail,p, r,g,b,a, dr,dg,db,da);                                            \
<span class="lineNum">     108 </span>            :     }                                                                                    \
<span class="lineNum">     109 </span>            :     static SK_ALWAYS_INLINE void name##_kernel(Ctx ctx, size_t x, size_t tail,           \
<span class="lineNum">     110 </span>            :                                                SkNf&amp;  r, SkNf&amp;  g, SkNf&amp;  b, SkNf&amp;  a,   \
<span class="lineNum">     111 </span>            :                                                SkNf&amp; dr, SkNf&amp; dg, SkNf&amp; db, SkNf&amp; da)
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : // Many xfermodes apply the same logic to each channel.
<span class="lineNum">     114 </span>            : #define RGBA_XFERMODE(name)                                                     \
<span class="lineNum">     115 </span>            :     static SK_ALWAYS_INLINE SkNf name##_kernel(const SkNf&amp; s, const SkNf&amp; sa,   \
<span class="lineNum">     116 </span>            :                                                const SkNf&amp; d, const SkNf&amp; da);  \
<span class="lineNum">     117 </span>            :     SI void SK_VECTORCALL name(size_t x_tail, void** p,                         \
<span class="lineNum">     118 </span>            :                                SkNf  r, SkNf  g, SkNf  b, SkNf  a,              \
<span class="lineNum">     119 </span>            :                                SkNf dr, SkNf dg, SkNf db, SkNf da) {            \
<span class="lineNum">     120 </span>            :         r = name##_kernel(r,a,dr,da);                                           \
<span class="lineNum">     121 </span>            :         g = name##_kernel(g,a,dg,da);                                           \
<span class="lineNum">     122 </span>            :         b = name##_kernel(b,a,db,da);                                           \
<span class="lineNum">     123 </span>            :         a = name##_kernel(a,a,da,da);                                           \
<span class="lineNum">     124 </span>            :         next(x_tail,p, r,g,b,a, dr,dg,db,da);                                   \
<span class="lineNum">     125 </span>            :     }                                                                           \
<span class="lineNum">     126 </span>            :     static SK_ALWAYS_INLINE SkNf name##_kernel(const SkNf&amp; s, const SkNf&amp; sa,   \
<span class="lineNum">     127 </span>            :                                                const SkNf&amp; d, const SkNf&amp; da)
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : // Most of the rest apply the same logic to color channels and use srcover's alpha logic.
<span class="lineNum">     130 </span>            : #define RGB_XFERMODE(name)                                                      \
<span class="lineNum">     131 </span>            :     static SK_ALWAYS_INLINE SkNf name##_kernel(const SkNf&amp; s, const SkNf&amp; sa,   \
<span class="lineNum">     132 </span>            :                                                const SkNf&amp; d, const SkNf&amp; da);  \
<span class="lineNum">     133 </span>            :     SI void SK_VECTORCALL name(size_t x_tail, void** p,                         \
<span class="lineNum">     134 </span>            :                                SkNf  r, SkNf  g, SkNf  b, SkNf  a,              \
<span class="lineNum">     135 </span>            :                                SkNf dr, SkNf dg, SkNf db, SkNf da) {            \
<span class="lineNum">     136 </span>            :         r = name##_kernel(r,a,dr,da);                                           \
<span class="lineNum">     137 </span>            :         g = name##_kernel(g,a,dg,da);                                           \
<span class="lineNum">     138 </span>            :         b = name##_kernel(b,a,db,da);                                           \
<span class="lineNum">     139 </span>            :         a = a + (da * (1.0f-a));                                                \
<span class="lineNum">     140 </span>            :         next(x_tail,p, r,g,b,a, dr,dg,db,da);                                   \
<span class="lineNum">     141 </span>            :     }                                                                           \
<span class="lineNum">     142 </span>            :     static SK_ALWAYS_INLINE SkNf name##_kernel(const SkNf&amp; s, const SkNf&amp; sa,   \
<span class="lineNum">     143 </span>            :                                                const SkNf&amp; d, const SkNf&amp; da)
<a name="144"><span class="lineNum">     144 </span>            : </a>
<span class="lineNum">     145 </span>            : template &lt;typename T&gt;
<span class="lineNum">     146 </span><span class="lineNoCov">          0 : SI SkNx&lt;N,T&gt; load(size_t tail, const T* src) {</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     148 </span>            :         T buf[8];
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         memset(buf, 0, 8*sizeof(T));</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         switch (tail &amp; (N-1)) {</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :             case 7: buf[6] = src[6];</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :             case 6: buf[5] = src[5];</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             case 5: buf[4] = src[4];</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             case 4: buf[3] = src[3];</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             case 3: buf[2] = src[2];</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :             case 2: buf[1] = src[1];</span>
<span class="lineNum">     157 </span>            :         }
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         buf[0] = src[0];</span>
<span class="lineNum">     159 </span>            :         return SkNx&lt;N,T&gt;::Load(buf);
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     return SkNx&lt;N,T&gt;::Load(src);</span>
<a name="162"><span class="lineNum">     162 </span>            : }</a>
<span class="lineNum">     163 </span>            : template &lt;typename T&gt;
<span class="lineNum">     164 </span><span class="lineNoCov">          0 : SI SkNx&lt;N,T&gt; gather(size_t tail, const T* src, const SkNi&amp; offset) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         T buf[8] = {0};</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         switch (tail &amp; (N-1)) {</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :             case 7: buf[6] = src[offset[6]];</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :             case 6: buf[5] = src[offset[5]];</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :             case 5: buf[4] = src[offset[4]];</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :             case 4: buf[3] = src[offset[3]];</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :             case 3: buf[2] = src[offset[2]];</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :             case 2: buf[1] = src[offset[1]];</span>
<span class="lineNum">     174 </span>            :         }
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         buf[0] = src[offset[0]];</span>
<span class="lineNum">     176 </span>            :         return SkNx&lt;N,T&gt;::Load(buf);
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            :     T buf[8];
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; N; i++) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         buf[i] = src[offset[i]];</span>
<span class="lineNum">     181 </span>            :     }
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     return SkNx&lt;N,T&gt;::Load(buf);</span>
<a name="183"><span class="lineNum">     183 </span>            : }</a>
<span class="lineNum">     184 </span>            : template &lt;typename T&gt;
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : SI void store(size_t tail, const SkNx&lt;N,T&gt;&amp; v, T* dst) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         switch (tail &amp; (N-1)) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :             case 7: dst[6] = v[6];</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :             case 6: dst[5] = v[5];</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :             case 5: dst[4] = v[4];</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :             case 4: dst[3] = v[3];</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :             case 3: dst[2] = v[2];</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :             case 2: dst[1] = v[1];</span>
<span class="lineNum">     194 </span>            :         }
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         dst[0] = v[0];</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     197 </span>            :     }
<span class="lineNum">     198 </span>            :     v.store(dst);
<a name="199"><span class="lineNum">     199 </span>            : }</a>
<span class="lineNum">     200 </span>            : 
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 : SI SkNf SkNf_fma(const SkNf&amp; f, const SkNf&amp; m, const SkNf&amp; a) { return SkNx_fma(f,m,a); }</span></a>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : SI SkNi SkNf_round(const SkNf&amp; x, const SkNf&amp; scale) {</span>
<span class="lineNum">     204 </span>            :     // Every time I try, _mm_cvtps_epi32 benches as slower than using FMA and _mm_cvttps_epi32.  :/
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     return SkNx_cast&lt;int&gt;(SkNf_fma(x,scale, 0.5f));</span>
<a name="206"><span class="lineNum">     206 </span>            : }</a>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 : SI SkNf SkNf_from_byte(const SkNi&amp; x) {</span>
<span class="lineNum">     209 </span>            :     // Same trick as in store_8888: 0x470000BB == 32768.0f + BB/256.0f for all bytes BB.
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     auto v = 0x47000000 | x;</span>
<span class="lineNum">     211 </span>            :     // Read this as (pun_float(v) - 32768.0f) * (256/255.0f), redistributed to be an FMA.
<a name="212"><span class="lineNum">     212 </span><span class="lineNoCov">          0 :     return SkNf_fma(SkNf::Load(&amp;v), 256/255.0f, -32768*256/255.0f);</span></a>
<a name="213"><span class="lineNum">     213 </span>            : }</a>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 : SI SkNf SkNf_from_byte(const SkNu&amp; x) { return SkNf_from_byte(SkNi::Load(&amp;x)); }</span>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 : SI SkNf SkNf_from_byte(const SkNb&amp; x) { return SkNf_from_byte(SkNx_cast&lt;int&gt;(x)); }</span></a>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 : SI void from_8888(const SkNu&amp; _8888, SkNf* r, SkNf* g, SkNf* b, SkNf* a) {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     *r = SkNf_from_byte((_8888      ) &amp; 0xff);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     *g = SkNf_from_byte((_8888 &gt;&gt;  8) &amp; 0xff);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     *b = SkNf_from_byte((_8888 &gt;&gt; 16) &amp; 0xff);</span>
<a name="221"><span class="lineNum">     221 </span><span class="lineNoCov">          0 :     *a = SkNf_from_byte((_8888 &gt;&gt; 24)       );</span></a>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : SI void from_4444(const SkNh&amp; _4444, SkNf* r, SkNf* g, SkNf* b, SkNf* a) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     auto _32_bit = SkNx_cast&lt;int&gt;(_4444);</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     *r = SkNx_cast&lt;float&gt;(_32_bit &amp; (0xF &lt;&lt; SK_R4444_SHIFT)) * (1.0f / (0xF &lt;&lt; SK_R4444_SHIFT));</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     *g = SkNx_cast&lt;float&gt;(_32_bit &amp; (0xF &lt;&lt; SK_G4444_SHIFT)) * (1.0f / (0xF &lt;&lt; SK_G4444_SHIFT));</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     *b = SkNx_cast&lt;float&gt;(_32_bit &amp; (0xF &lt;&lt; SK_B4444_SHIFT)) * (1.0f / (0xF &lt;&lt; SK_B4444_SHIFT));</span>
<a name="229"><span class="lineNum">     229 </span><span class="lineNoCov">          0 :     *a = SkNx_cast&lt;float&gt;(_32_bit &amp; (0xF &lt;&lt; SK_A4444_SHIFT)) * (1.0f / (0xF &lt;&lt; SK_A4444_SHIFT));</span></a>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : SI void from_565(const SkNh&amp; _565, SkNf* r, SkNf* g, SkNf* b) {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     auto _32_bit = SkNx_cast&lt;int&gt;(_565);</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     *r = SkNx_cast&lt;float&gt;(_32_bit &amp; SK_R16_MASK_IN_PLACE) * (1.0f / SK_R16_MASK_IN_PLACE);</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     *g = SkNx_cast&lt;float&gt;(_32_bit &amp; SK_G16_MASK_IN_PLACE) * (1.0f / SK_G16_MASK_IN_PLACE);</span>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :     *b = SkNx_cast&lt;float&gt;(_32_bit &amp; SK_B16_MASK_IN_PLACE) * (1.0f / SK_B16_MASK_IN_PLACE);</span></a>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : SI void from_f16(const void* px, SkNf* r, SkNf* g, SkNf* b, SkNf* a) {</span>
<span class="lineNum">     239 </span>            :     SkNh rh, gh, bh, ah;
<span class="lineNum">     240 </span>            :     SkNh::Load4(px, &amp;rh, &amp;gh, &amp;bh, &amp;ah);
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     *r = SkHalfToFloat_finite_ftz(rh);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     *g = SkHalfToFloat_finite_ftz(gh);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     *b = SkHalfToFloat_finite_ftz(bh);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     *a = SkHalfToFloat_finite_ftz(ah);</span>
<a name="246"><span class="lineNum">     246 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 : STAGE(clamp_0) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     a = SkNf::Max(a, 0.0f);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     r = SkNf::Max(r, 0.0f);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     g = SkNf::Max(g, 0.0f);</span>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :     b = SkNf::Max(b, 0.0f);</span></a>
<span class="lineNum">     253 </span>            : }
<span class="lineNum">     254 </span><span class="lineNoCov">          0 : STAGE(clamp_1) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     a = SkNf::Min(a, 1.0f);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     r = SkNf::Min(r, 1.0f);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     g = SkNf::Min(g, 1.0f);</span>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :     b = SkNf::Min(b, 1.0f);</span></a>
<span class="lineNum">     259 </span>            : }
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : STAGE(clamp_a) {</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     a = SkNf::Min(a, 1.0f);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     r = SkNf::Min(r, a);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     g = SkNf::Min(g, a);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     b = SkNf::Min(b, a);</span>
<a name="265"><span class="lineNum">     265 </span>            : }</a>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : STAGE(unpremul) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     auto scale = (a == 0.0f).thenElse(0.0f, 1.0f/a);</span>
<span class="lineNum">     269 </span>            :     r *= scale;
<span class="lineNum">     270 </span>            :     g *= scale;
<a name="271"><span class="lineNum">     271 </span>            :     b *= scale;</a>
<span class="lineNum">     272 </span>            : }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 : STAGE(premul) {</span>
<span class="lineNum">     274 </span>            :     r *= a;
<span class="lineNum">     275 </span>            :     g *= a;
<span class="lineNum">     276 </span>            :     b *= a;
<a name="277"><span class="lineNum">     277 </span>            : }</a>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : STAGE_CTX(set_rgb, const float*) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     r = ctx[0];</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     g = ctx[1];</span>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :     b = ctx[2];</span></a>
<span class="lineNum">     283 </span>            : }
<a name="284"><span class="lineNum">     284 </span><span class="lineNoCov">          0 : STAGE(swap_rb) { SkTSwap(r,b); }</span></a>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : STAGE(move_src_dst) {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     dr = r;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     dg = g;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     db = b;</span>
<a name="290"><span class="lineNum">     290 </span><span class="lineNoCov">          0 :     da = a;</span></a>
<span class="lineNum">     291 </span>            : }
<span class="lineNum">     292 </span><span class="lineNoCov">          0 : STAGE(move_dst_src) {</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     r = dr;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     g = dg;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     b = db;</span>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :     a = da;</span></a>
<span class="lineNum">     297 </span>            : }
<span class="lineNum">     298 </span><span class="lineNoCov">          0 : STAGE(swap) {</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     SkTSwap(r,dr);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     SkTSwap(g,dg);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     SkTSwap(b,db);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     SkTSwap(a,da);</span>
<a name="303"><span class="lineNum">     303 </span>            : }</a>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : STAGE(from_srgb) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     r = sk_linear_from_srgb_math(r);</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     g = sk_linear_from_srgb_math(g);</span>
<a name="308"><span class="lineNum">     308 </span><span class="lineNoCov">          0 :     b = sk_linear_from_srgb_math(b);</span></a>
<span class="lineNum">     309 </span>            : }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 : STAGE(to_srgb) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     r = sk_linear_to_srgb_needs_round(r);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     g = sk_linear_to_srgb_needs_round(g);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     b = sk_linear_to_srgb_needs_round(b);</span>
<a name="314"><span class="lineNum">     314 </span>            : }</a>
<a name="315"><span class="lineNum">     315 </span>            : </a>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 : STAGE(from_2dot2) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     auto from_2dot2 = [](const SkNf&amp; x) {</span>
<span class="lineNum">     318 </span>            :         // x^(141/64) = x^(2.20312) is a great approximation of the true value, x^(2.2).
<span class="lineNum">     319 </span>            :         // (note: x^(35/16) = x^(2.1875) is an okay one as well and would be quicker)
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         auto x16 = x.rsqrt().rsqrt().rsqrt().rsqrt();   // x^(1/16) = x^(4/64);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         auto x64 = x16.rsqrt().rsqrt();                 // x^(1/64)</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :         // x^(141/64) = x^(128/64) * x^(12/64) * x^(1/64)
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         return SkNf::Max((x*x) * (x16*x16*x16) * (x64), 0.0f);</span>
<span class="lineNum">     325 </span>            :     };
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     r = from_2dot2(r);</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     g = from_2dot2(g);</span>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :     b = from_2dot2(b);</span></a>
<a name="330"><span class="lineNum">     330 </span>            : }</a>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 : STAGE(to_2dot2) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     auto to_2dot2 = [](const SkNf&amp; x) {</span>
<span class="lineNum">     333 </span>            :         // x^(29/64) is a very good approximation of the true value, x^(1/2.2).
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         auto x2  = x.rsqrt(),                            // x^(-1/2)</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :              x32 = x2.rsqrt().rsqrt().rsqrt().rsqrt(),   // x^(-1/32)</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :              x64 = x32.rsqrt();                          // x^(+1/64)</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :         // 29 = 32 - 2 - 1
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         return SkNf::Max(x2.invert() * x32 * x64.invert(), 0.0f); // Watch out for NaN.</span>
<span class="lineNum">     340 </span>            :     };
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     r = to_2dot2(r);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     g = to_2dot2(g);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     b = to_2dot2(b);</span>
<span class="lineNum">     345 </span>            : }
<a name="346"><span class="lineNum">     346 </span>            : </a>
<span class="lineNum">     347 </span>            : // The default shader produces a constant color (from the SkPaint).
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : STAGE_CTX(constant_color, const SkPM4f*) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     r = ctx-&gt;r();</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     g = ctx-&gt;g();</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     b = ctx-&gt;b();</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     a = ctx-&gt;a();</span>
<span class="lineNum">     353 </span>            : }
<a name="354"><span class="lineNum">     354 </span>            : </a>
<span class="lineNum">     355 </span>            : // Set up registers with values relevant to shaders.
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : STAGE_CTX(seed_shader, const int*) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     int y = *ctx;</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :     static const float dx[] = { 0,1,2,3,4,5,6,7 };
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     r = x + 0.5f + SkNf::Load(dx);  // dst pixel center x coordinates</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     g = y + 0.5f;                   // dst pixel center y coordinate(s)</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     b = 1.0f;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     a = 0.0f;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     dr = dg = db = da = 0.0f;</span>
<span class="lineNum">     365 </span>            : }
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : // s' = sc for a scalar c.
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : STAGE_CTX(scale_1_float, const float*) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     SkNf c = *ctx;</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :     r *= c;
<span class="lineNum">     372 </span>            :     g *= c;
<span class="lineNum">     373 </span>            :     b *= c;
<span class="lineNum">     374 </span>            :     a *= c;
<a name="375"><span class="lineNum">     375 </span>            : }</a>
<span class="lineNum">     376 </span>            : // s' = sc for 8-bit c.
<span class="lineNum">     377 </span><span class="lineNoCov">          0 : STAGE_CTX(scale_u8, const uint8_t**) {</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     SkNf c = SkNf_from_byte(load(tail, ptr));</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     r = r*c;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     g = g*c;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     b = b*c;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     a = a*c;</span>
<a name="385"><span class="lineNum">     385 </span>            : }</a>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : SI SkNf lerp(const SkNf&amp; from, const SkNf&amp; to, const SkNf&amp; cov) {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     return SkNf_fma(to-from, cov, from);</span>
<span class="lineNum">     389 </span>            : }
<a name="390"><span class="lineNum">     390 </span>            : </a>
<span class="lineNum">     391 </span>            : // s' = d(1-c) + sc, for a scalar c.
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : STAGE_CTX(lerp_1_float, const float*) {</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     SkNf c = *ctx;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     r = lerp(dr, r, c);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     g = lerp(dg, g, c);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     b = lerp(db, b, c);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     a = lerp(da, a, c);</span>
<span class="lineNum">     399 </span>            : }
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : // s' = d(1-c) + sc for 8-bit c.
<span class="lineNum">     402 </span><span class="lineNoCov">          0 : STAGE_CTX(lerp_u8, const uint8_t**) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     SkNf c = SkNf_from_byte(load(tail, ptr));</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     r = lerp(dr, r, c);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     g = lerp(dg, g, c);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     b = lerp(db, b, c);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     a = lerp(da, a, c);</span>
<span class="lineNum">     410 </span>            : }
<a name="411"><span class="lineNum">     411 </span>            : </a>
<span class="lineNum">     412 </span>            : // s' = d(1-c) + sc for 565 c.
<span class="lineNum">     413 </span><span class="lineNoCov">          0 : STAGE_CTX(lerp_565, const uint16_t**) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     415 </span>            :     SkNf cr, cg, cb;
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     from_565(load(tail, ptr), &amp;cr, &amp;cg, &amp;cb);</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     r = lerp(dr, r, cr);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     g = lerp(dg, g, cg);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     b = lerp(db, b, cb);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     a = 1.0f;</span>
<a name="422"><span class="lineNum">     422 </span>            : }</a>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineNoCov">          0 : STAGE_CTX(load_a8, const uint8_t**) {</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     r = g = b = 0.0f;</span>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :     a = SkNf_from_byte(load(tail, ptr));</span></a>
<span class="lineNum">     428 </span>            : }
<span class="lineNum">     429 </span><span class="lineNoCov">          0 : STAGE_CTX(store_a8, uint8_t**) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     store(tail, SkNx_cast&lt;uint8_t&gt;(SkNf_round(255.0f, a)), ptr);</span>
<a name="432"><span class="lineNum">     432 </span>            : }</a>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 : STAGE_CTX(load_g8, const uint8_t**) {</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     r = g = b = SkNf_from_byte(load(tail, ptr));</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     a = 1.0f;</span>
<a name="438"><span class="lineNum">     438 </span>            : }</a>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 : STAGE_CTX(load_565, const uint16_t**) {</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     from_565(load(tail, ptr), &amp;r,&amp;g,&amp;b);</span>
<a name="443"><span class="lineNum">     443 </span><span class="lineNoCov">          0 :     a = 1.0f;</span></a>
<span class="lineNum">     444 </span>            : }
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : STAGE_CTX(store_565, uint16_t**) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     store(tail, SkNx_cast&lt;uint16_t&gt;( SkNf_round(r, SK_R16_MASK) &lt;&lt; SK_R16_SHIFT</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                                    | SkNf_round(g, SK_G16_MASK) &lt;&lt; SK_G16_SHIFT</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                                    | SkNf_round(b, SK_B16_MASK) &lt;&lt; SK_B16_SHIFT), ptr);</span>
<a name="450"><span class="lineNum">     450 </span>            : }</a>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : STAGE_CTX(load_4444, const uint16_t**) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<a name="454"><span class="lineNum">     454 </span><span class="lineNoCov">          0 :     from_4444(load(tail, ptr), &amp;r,&amp;g,&amp;b,&amp;a);</span></a>
<span class="lineNum">     455 </span>            : }
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : STAGE_CTX(store_4444, uint16_t**) {</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     store(tail, SkNx_cast&lt;uint16_t&gt;( SkNf_round(r, 0xF) &lt;&lt; SK_R4444_SHIFT</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                                    | SkNf_round(g, 0xF) &lt;&lt; SK_G4444_SHIFT</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                                    | SkNf_round(b, 0xF) &lt;&lt; SK_B4444_SHIFT</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                                    | SkNf_round(a, 0xF) &lt;&lt; SK_A4444_SHIFT), ptr);</span>
<a name="462"><span class="lineNum">     462 </span>            : }</a>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineNoCov">          0 : STAGE_CTX(load_f16, const uint64_t**) {</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     468 </span>            :     SkNx&lt;N, uint64_t&gt; px;
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :         px = load(tail, ptr);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         src = &amp;px;</span>
<span class="lineNum">     472 </span>            :     }
<a name="473"><span class="lineNum">     473 </span><span class="lineNoCov">          0 :     from_f16(src, &amp;r, &amp;g, &amp;b, &amp;a);</span></a>
<span class="lineNum">     474 </span>            : }
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : STAGE_CTX(store_f16, uint64_t**) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :     SkNx&lt;N, uint64_t&gt; px;
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     SkNh::Store4(tail ? (void*)&amp;px : (void*)ptr, SkFloatToHalf_finite_ftz(r),</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                                                  SkFloatToHalf_finite_ftz(g),</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                                                  SkFloatToHalf_finite_ftz(b),</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                                                  SkFloatToHalf_finite_ftz(a));</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         store(tail, px, ptr);</span>
<span class="lineNum">     485 </span>            :     }
<a name="486"><span class="lineNum">     486 </span>            : }</a>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 : STAGE_CTX(load_f32, const SkPM4f**) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     492 </span>            :     SkNx&lt;N, SkPM4f&gt; px;
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         px = load(tail, ptr);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         src = &amp;px;</span>
<span class="lineNum">     496 </span>            :     }
<a name="497"><span class="lineNum">     497 </span>            :     SkNf::Load4(src, &amp;r, &amp;g, &amp;b, &amp;a);</a>
<span class="lineNum">     498 </span>            : }
<span class="lineNum">     499 </span><span class="lineNoCov">          0 : STAGE_CTX(store_f32, SkPM4f**) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :     SkNx&lt;N, SkPM4f&gt; px;
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     SkNf::Store4(tail ? (void*)&amp;px : (void*)ptr, r,g,b,a);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         store(tail, px, ptr);</span>
<span class="lineNum">     506 </span>            :     }
<span class="lineNum">     507 </span>            : }
<a name="508"><span class="lineNum">     508 </span>            : </a>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 : STAGE_CTX(load_8888, const uint32_t**) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<a name="512"><span class="lineNum">     512 </span><span class="lineNoCov">          0 :     from_8888(load(tail, ptr), &amp;r, &amp;g, &amp;b, &amp;a);</span></a>
<a name="513"><span class="lineNum">     513 </span>            : }</a>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 : STAGE_CTX(store_8888, uint32_t**) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     auto byte = [](const SkNf&amp; x, int ix) {</span>
<span class="lineNum">     516 </span>            :         // Here's a neat trick: 0x47000000 == 32768.0f, and 0x470000ff == 32768.0f + (255/256.0f).
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         auto v = SkNf_fma(255/256.0f, x, 32768.0f);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         switch (ix) {</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :             case 0: return SkNi::Load(&amp;v) &amp; 0xff;  // R</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :             case 3: return SkNi::Load(&amp;v) &lt;&lt; 24;   // A</span>
<span class="lineNum">     521 </span>            :         }
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :         return (SkNi::Load(&amp;v) &amp; 0xff) &lt;&lt; (8*ix);  // B or G</span>
<span class="lineNum">     523 </span>            :     };
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     store(tail, byte(r,0)|byte(g,1)|byte(b,2)|byte(a,3), (int*)ptr);</span>
<a name="527"><span class="lineNum">     527 </span>            : }</a>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 : STAGE_CTX(load_u16_be, const uint64_t**) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     532 </span>            :     SkNx&lt;N, uint64_t&gt; px;
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         px = load(tail, ptr);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :         src = &amp;px;</span>
<span class="lineNum">     536 </span>            :     }
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :     SkNh rh, gh, bh, ah;
<span class="lineNum">     539 </span>            :     SkNh::Load4(src, &amp;rh, &amp;gh, &amp;bh, &amp;ah);
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     r = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((rh &lt;&lt; 8) | (rh &gt;&gt; 8));</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     g = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((gh &lt;&lt; 8) | (gh &gt;&gt; 8));</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     b = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((bh &lt;&lt; 8) | (bh &gt;&gt; 8));</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     a = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((ah &lt;&lt; 8) | (ah &gt;&gt; 8));</span>
<a name="544"><span class="lineNum">     544 </span>            : }</a>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 : STAGE_CTX(load_rgb_u16_be, const uint16_t**) {</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + 3*x;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     uint16_t buf[N*3] = {0};</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         memcpy(buf, src, tail*3*sizeof(uint16_t));</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         src = buf;</span>
<span class="lineNum">     553 </span>            :     }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            :     SkNh rh, gh, bh;
<span class="lineNum">     556 </span>            :     SkNh::Load3(src, &amp;rh, &amp;gh, &amp;bh);
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     r = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((rh &lt;&lt; 8) | (rh &gt;&gt; 8));</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     g = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((gh &lt;&lt; 8) | (gh &gt;&gt; 8));</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     b = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((bh &lt;&lt; 8) | (bh &gt;&gt; 8));</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     a = 1.0f;</span>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : STAGE_CTX(store_u16_be, uint64_t**) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     auto to_u16_be = [](const SkNf&amp; x) {</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         SkNh x16 = SkNx_cast&lt;uint16_t&gt;(65535.0f * x);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         return (x16 &lt;&lt; 8) | (x16 &gt;&gt; 8);</span>
<span class="lineNum">     567 </span>            :     };
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     auto ptr = *ctx + x;</span>
<span class="lineNum">     570 </span>            :     SkNx&lt;N, uint64_t&gt; px;
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     SkNh::Store4(tail ? (void*)&amp;px : (void*)ptr, to_u16_be(r),</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                                                  to_u16_be(g),</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                                                  to_u16_be(b),</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                                                  to_u16_be(a));</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         store(tail, px, ptr);</span>
<span class="lineNum">     577 </span>            :     }
<a name="578"><span class="lineNum">     578 </span>            : }</a>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 : STAGE_CTX(load_tables, const LoadTablesContext*) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     auto ptr = (const uint32_t*)ctx-&gt;fSrc + x;</span>
<a name="582"><span class="lineNum">     582 </span>            : </a>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     SkNu rgba = load(tail, ptr);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     auto to_int = [](const SkNu&amp; v) { return SkNi::Load(&amp;v); };</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     r = gather(tail, ctx-&gt;fR, to_int((rgba &gt;&gt;  0) &amp; 0xff));</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     g = gather(tail, ctx-&gt;fG, to_int((rgba &gt;&gt;  8) &amp; 0xff));</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     b = gather(tail, ctx-&gt;fB, to_int((rgba &gt;&gt; 16) &amp; 0xff));</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     a = SkNf_from_byte(rgba &gt;&gt; 24);</span>
<a name="589"><span class="lineNum">     589 </span>            : }</a>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 : STAGE_CTX(load_tables_u16_be, const LoadTablesContext*) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     auto ptr = (const uint64_t*)ctx-&gt;fSrc + x;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     594 </span>            :     SkNx&lt;N, uint64_t&gt; px;
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         px = load(tail, ptr);</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         src = &amp;px;</span>
<span class="lineNum">     598 </span>            :     }
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :     SkNh rh, gh, bh, ah;
<span class="lineNum">     601 </span>            :     SkNh::Load4(src, &amp;rh, &amp;gh, &amp;bh, &amp;ah);
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     // ctx-&gt;fSrc is big-endian, so &quot;&amp; 0xff&quot; grabs the 8 most significant bits of each component.
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     r = gather(tail, ctx-&gt;fR, SkNx_cast&lt;int&gt;(rh &amp; 0xff));</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     g = gather(tail, ctx-&gt;fG, SkNx_cast&lt;int&gt;(gh &amp; 0xff));</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     b = gather(tail, ctx-&gt;fB, SkNx_cast&lt;int&gt;(bh &amp; 0xff));</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     a = (1.0f / 65535.0f) * SkNx_cast&lt;float&gt;((ah &lt;&lt; 8) | (ah &gt;&gt; 8));</span>
<a name="608"><span class="lineNum">     608 </span>            : }</a>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineNoCov">          0 : STAGE_CTX(load_tables_rgb_u16_be, const LoadTablesContext*) {</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     auto ptr = (const uint16_t*)ctx-&gt;fSrc + 3*x;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     const void* src = ptr;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     uint16_t buf[N*3] = {0};</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     if (tail) {</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         memcpy(buf, src, tail*3*sizeof(uint16_t));</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         src = buf;</span>
<span class="lineNum">     617 </span>            :     }
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :     SkNh rh, gh, bh;
<span class="lineNum">     620 </span>            :     SkNh::Load3(src, &amp;rh, &amp;gh, &amp;bh);
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :     // ctx-&gt;fSrc is big-endian, so &quot;&amp; 0xff&quot; grabs the 8 most significant bits of each component.
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     r = gather(tail, ctx-&gt;fR, SkNx_cast&lt;int&gt;(rh &amp; 0xff));</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     g = gather(tail, ctx-&gt;fG, SkNx_cast&lt;int&gt;(gh &amp; 0xff));</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     b = gather(tail, ctx-&gt;fB, SkNx_cast&lt;int&gt;(bh &amp; 0xff));</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     a = 1.0f;</span>
<a name="627"><span class="lineNum">     627 </span>            : }</a>
<span class="lineNum">     628 </span>            : 
<a name="629"><span class="lineNum">     629 </span><span class="lineNoCov">          0 : SI SkNf inv(const SkNf&amp; x) { return 1.0f - x; }</span></a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(clear)    { return 0.0f; }</span></a>
<a name="632"><span class="lineNum">     632 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(srcatop)  { return s*da + d*inv(sa); }</span></a>
<a name="633"><span class="lineNum">     633 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(srcin)    { return s * da; }</span></a>
<a name="634"><span class="lineNum">     634 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(srcout)   { return s * inv(da); }</span></a>
<a name="635"><span class="lineNum">     635 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(srcover)  { return SkNf_fma(d, inv(sa), s); }</span></a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(dstatop)  { return srcatop_kernel(d,da,s,sa); }</span></a>
<a name="637"><span class="lineNum">     637 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(dstin)    { return srcin_kernel  (d,da,s,sa); }</span></a>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(dstout)   { return srcout_kernel (d,da,s,sa); }</span>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(dstover)  { return srcover_kernel(d,da,s,sa); }</span></a>
<a name="640"><span class="lineNum">     640 </span>            : </a>
<a name="641"><span class="lineNum">     641 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(modulate) { return s*d; }</span></a>
<a name="642"><span class="lineNum">     642 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(multiply) { return s*inv(da) + d*inv(sa) + s*d; }</span></a>
<a name="643"><span class="lineNum">     643 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(plus_)    { return s + d; }</span></a>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(screen)   { return s + d - s*d; }</span>
<a name="645"><span class="lineNum">     645 </span><span class="lineNoCov">          0 : RGBA_XFERMODE(xor_)     { return s*inv(da) + d*inv(sa); }</span></a>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 : RGB_XFERMODE(colorburn) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     return (d == da  ).thenElse(d + s*inv(da),</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :            (s == 0.0f).thenElse(s + d*inv(sa),</span>
<a name="650"><span class="lineNum">     650 </span><span class="lineNoCov">          0 :                                 sa*(da - SkNf::Min(da, (da-d)*sa/s)) + s*inv(da) + d*inv(sa)));</span></a>
<span class="lineNum">     651 </span>            : }
<span class="lineNum">     652 </span><span class="lineNoCov">          0 : RGB_XFERMODE(colordodge) {</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     return (d == 0.0f).thenElse(d + s*inv(da),</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :            (s == sa  ).thenElse(s + d*inv(sa),</span>
<a name="655"><span class="lineNum">     655 </span><span class="lineNoCov">          0 :                                 sa*SkNf::Min(da, (d*sa)/(sa - s)) + s*inv(da) + d*inv(sa)));</span></a>
<a name="656"><span class="lineNum">     656 </span>            : }</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineNoCov">          0 : RGB_XFERMODE(darken)     { return s + d - SkNf::Max(s*da, d*sa); }</span></a>
<a name="658"><span class="lineNum">     658 </span><span class="lineNoCov">          0 : RGB_XFERMODE(difference) { return s + d - 2.0f*SkNf::Min(s*da,d*sa); }</span></a>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 : RGB_XFERMODE(exclusion)  { return s + d - 2.0f*s*d; }</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 : RGB_XFERMODE(hardlight) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     return s*inv(da) + d*inv(sa)</span>
<a name="662"><span class="lineNum">     662 </span><span class="lineNoCov">          0 :          + (2.0f*s &lt;= sa).thenElse(2.0f*s*d, sa*da - 2.0f*(da-d)*(sa-s));</span></a>
<a name="663"><span class="lineNum">     663 </span>            : }</a>
<a name="664"><span class="lineNum">     664 </span><span class="lineNoCov">          0 : RGB_XFERMODE(lighten) { return s + d - SkNf::Min(s*da, d*sa); }</span></a>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 : RGB_XFERMODE(overlay) { return hardlight_kernel(d,da,s,sa); }</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 : RGB_XFERMODE(softlight) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     SkNf m  = (da &gt; 0.0f).thenElse(d / da, 0.0f),</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :          s2 = 2.0f*s,</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :          m4 = 4.0f*m;</span>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :     // The logic forks three ways:
<span class="lineNum">     672 </span>            :     //    1. dark src?
<span class="lineNum">     673 </span>            :     //    2. light src, dark dst?
<span class="lineNum">     674 </span>            :     //    3. light src, light dst?
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     SkNf darkSrc = d*(sa + (s2 - sa)*(1.0f - m)),     // Used in case 1.</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :          darkDst = (m4*m4 + m4)*(m - 1.0f) + 7.0f*m,  // Used in case 2.</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :          liteDst = m.rsqrt().invert() - m,            // Used in case 3.</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :          liteSrc = d*sa + da*(s2 - sa) * (4.0f*d &lt;= da).thenElse(darkDst, liteDst);  // 2 or 3?</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     return s*inv(da) + d*inv(sa) + (s2 &lt;= sa).thenElse(darkSrc, liteSrc);  // 1 or (2 or 3)?</span>
<a name="680"><span class="lineNum">     680 </span>            : }</a>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 : STAGE(luminance_to_alpha) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     a = SK_LUM_COEFF_R*r + SK_LUM_COEFF_G*g + SK_LUM_COEFF_B*b;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     r = g = b = 0;</span>
<a name="685"><span class="lineNum">     685 </span>            : }</a>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : STAGE(rgb_to_hsl) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     auto max = SkNf::Max(SkNf::Max(r, g), b);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     auto min = SkNf::Min(SkNf::Min(r, g), b);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     auto l = 0.5f * (max + min);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     auto d = max - min;</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     auto d_inv = 1.0f/d;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     auto s = (max == min).thenElse(0.0f,</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         d/(l &gt; 0.5f).thenElse(2.0f - max - min, max + min));</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     SkNf h = (max != r).thenElse(0.0f,</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         (g - b)*d_inv + (g &lt; b).thenElse(6.0f, 0.0f));</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     h = (max == g).thenElse((b - r)*d_inv + 2.0f, h);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     h = (max == b).thenElse((r - g)*d_inv + 4.0f, h);</span>
<span class="lineNum">     700 </span>            :     h *= (1/6.0f);
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     h = (max == min).thenElse(0.0f, h);</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     r = h;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     g = s;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     b = l;</span>
<a name="707"><span class="lineNum">     707 </span>            : }</a>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 : STAGE(hsl_to_rgb) {</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     auto h = r;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     auto s = g;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     auto l = b;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     auto q = (l &lt; 0.5f).thenElse(l*(1.0f + s), l + s - l*s);</span>
<a name="714"><span class="lineNum">     714 </span><span class="lineNoCov">          0 :     auto p = 2.0f*l - q;</span></a>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     auto hue_to_rgb = [](const SkNf&amp; p, const SkNf&amp; q, const SkNf&amp; t) {</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         auto t2 = (t &lt; 0.0f).thenElse(t + 1.0f, (t &gt; 1.0f).thenElse(t - 1.0f, t));</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :         return (t2 &lt; (1/6.0f)).thenElse(</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :             p + (q - p)*6.0f*t, (t2 &lt; (3/6.0f)).thenElse(</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                 q, (t2 &lt; (4/6.0f)).thenElse(</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :                     p + (q - p)*((4/6.0f) - t2)*6.0f, p)));</span>
<span class="lineNum">     722 </span>            :     };
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     r = (s == 0.f).thenElse(l, hue_to_rgb(p, q, h + (1/3.0f)));</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     g = (s == 0.f).thenElse(l, hue_to_rgb(p, q, h));</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     b = (s == 0.f).thenElse(l, hue_to_rgb(p, q, h - (1/3.0f)));</span>
<a name="727"><span class="lineNum">     727 </span>            : }</a>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 : STAGE_CTX(matrix_2x3, const float*) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     auto m = ctx;</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     auto R = SkNf_fma(r,m[0], SkNf_fma(g,m[2], m[4])),</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :          G = SkNf_fma(r,m[1], SkNf_fma(g,m[3], m[5]));</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     r = R;</span>
<a name="735"><span class="lineNum">     735 </span><span class="lineNoCov">          0 :     g = G;</span></a>
<span class="lineNum">     736 </span>            : }
<span class="lineNum">     737 </span><span class="lineNoCov">          0 : STAGE_CTX(matrix_3x4, const float*) {</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     auto m = ctx;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     auto R = SkNf_fma(r,m[0], SkNf_fma(g,m[3], SkNf_fma(b,m[6], m[ 9]))),</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :          G = SkNf_fma(r,m[1], SkNf_fma(g,m[4], SkNf_fma(b,m[7], m[10]))),</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :          B = SkNf_fma(r,m[2], SkNf_fma(g,m[5], SkNf_fma(b,m[8], m[11])));</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     r = R;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     g = G;</span>
<a name="745"><span class="lineNum">     745 </span><span class="lineNoCov">          0 :     b = B;</span></a>
<span class="lineNum">     746 </span>            : }
<span class="lineNum">     747 </span><span class="lineNoCov">          0 : STAGE_CTX(matrix_4x5, const float*) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     auto m = ctx;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     auto R = SkNf_fma(r,m[0], SkNf_fma(g,m[4], SkNf_fma(b,m[ 8], SkNf_fma(a,m[12], m[16])))),</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :          G = SkNf_fma(r,m[1], SkNf_fma(g,m[5], SkNf_fma(b,m[ 9], SkNf_fma(a,m[13], m[17])))),</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :          B = SkNf_fma(r,m[2], SkNf_fma(g,m[6], SkNf_fma(b,m[10], SkNf_fma(a,m[14], m[18])))),</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :          A = SkNf_fma(r,m[3], SkNf_fma(g,m[7], SkNf_fma(b,m[11], SkNf_fma(a,m[15], m[19]))));</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     r = R;</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     g = G;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     b = B;</span>
<a name="757"><span class="lineNum">     757 </span><span class="lineNoCov">          0 :     a = A;</span></a>
<span class="lineNum">     758 </span>            : }
<span class="lineNum">     759 </span><span class="lineNoCov">          0 : STAGE_CTX(matrix_perspective, const float*) {</span>
<span class="lineNum">     760 </span>            :     // N.B. unlike the matrix_NxM stages, this takes a row-major matrix.
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     auto m = ctx;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     auto R = SkNf_fma(r,m[0], SkNf_fma(g,m[1], m[2])),</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :          G = SkNf_fma(r,m[3], SkNf_fma(g,m[4], m[5])),</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :          Z = SkNf_fma(r,m[6], SkNf_fma(g,m[7], m[8]));</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     r = R * Z.invert();</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     g = G * Z.invert();</span>
<a name="768"><span class="lineNum">     768 </span>            : }</a>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineNoCov">          0 : SI SkNf parametric(const SkNf&amp; v, const SkColorSpaceTransferFn&amp; p) {</span>
<span class="lineNum">     771 </span>            :     float result[N];   // Unconstrained powf() doesn't vectorize well...
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; N; i++) {</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         float s = v[i];</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         result[i] = (s &lt;= p.fD) ? p.fC * s + p.fF</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :                                 : powf(s * p.fA + p.fB, p.fG) + p.fE;</span>
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span>            :     // Clamp the output to [0, 1].
<span class="lineNum">     778 </span>            :     // Max(NaN, 0) = 0, but Max(0, NaN) = NaN, so we want this exact order to ensure NaN =&gt; 0
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :     return SkNf::Min(SkNf::Max(SkNf::Load(result), 0.0f), 1.0f);</span></a>
<a name="780"><span class="lineNum">     780 </span>            : }</a>
<a name="781"><span class="lineNum">     781 </span><span class="lineNoCov">          0 : STAGE_CTX(parametric_r, const SkColorSpaceTransferFn*) { r = parametric(r, *ctx); }</span></a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 : STAGE_CTX(parametric_g, const SkColorSpaceTransferFn*) { g = parametric(g, *ctx); }</span></a>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 : STAGE_CTX(parametric_b, const SkColorSpaceTransferFn*) { b = parametric(b, *ctx); }</span>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 : STAGE_CTX(parametric_a, const SkColorSpaceTransferFn*) { a = parametric(a, *ctx); }</span></a>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 : SI SkNf table(const SkNf&amp; v, const SkTableTransferFn&amp; table) {</span>
<span class="lineNum">     787 </span>            :     float result[N];
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; N; i++) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         result[i] = interp_lut(v[i], table.fData, table.fSize);</span>
<span class="lineNum">     790 </span>            :     }
<span class="lineNum">     791 </span>            :     // no need to clamp - tables are by-design [0,1] -&gt; [0,1]
<a name="792"><span class="lineNum">     792 </span><span class="lineNoCov">          0 :     return SkNf::Load(result);</span></a>
<a name="793"><span class="lineNum">     793 </span>            : }</a>
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 : STAGE_CTX(table_r, const SkTableTransferFn*) { r = table(r, *ctx); }</span></a>
<a name="795"><span class="lineNum">     795 </span><span class="lineNoCov">          0 : STAGE_CTX(table_g, const SkTableTransferFn*) { g = table(g, *ctx); }</span></a>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : STAGE_CTX(table_b, const SkTableTransferFn*) { b = table(b, *ctx); }</span>
<a name="797"><span class="lineNum">     797 </span><span class="lineNoCov">          0 : STAGE_CTX(table_a, const SkTableTransferFn*) { a = table(a, *ctx); }</span></a>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineNoCov">          0 : STAGE_CTX(color_lookup_table, const SkColorLookUpTable*) {</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     const SkColorLookUpTable* colorLUT = ctx;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     SkASSERT(3 == colorLUT-&gt;inputChannels() || 4 == colorLUT-&gt;inputChannels());</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     SkASSERT(3 == colorLUT-&gt;outputChannels());</span>
<span class="lineNum">     803 </span>            :     float result[3][N];
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; N; ++i) {</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         const float in[4] = { r[i], g[i], b[i], a[i] };</span>
<span class="lineNum">     806 </span>            :         float out[3];
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         colorLUT-&gt;interp(out, in);</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         for (int j = 0; j &lt; colorLUT-&gt;outputChannels(); ++j) {</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :             result[j][i] = out[j];</span>
<span class="lineNum">     810 </span>            :         }
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     r = SkNf::Load(result[0]);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     g = SkNf::Load(result[1]);</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     b = SkNf::Load(result[2]);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     if (4 == colorLUT-&gt;inputChannels()) {</span>
<span class="lineNum">     816 </span>            :         // we must set the pixel to opaque, as the alpha channel was used
<span class="lineNum">     817 </span>            :         // as input before this.
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         a = 1.f;</span>
<span class="lineNum">     819 </span>            :     }
<a name="820"><span class="lineNum">     820 </span>            : }</a>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 : STAGE(lab_to_xyz) {</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     const auto lab_l = r * 100.0f;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     const auto lab_a = g * 255.0f - 128.0f;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     const auto lab_b = b * 255.0f - 128.0f;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     auto Y = (lab_l + 16.0f) * (1/116.0f);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     auto X = lab_a * (1/500.0f) + Y;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     auto Z = Y - (lab_b * (1/200.0f));</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     const auto X3 = X*X*X;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     X = (X3 &gt; 0.008856f).thenElse(X3, (X - (16/116.0f)) * (1/7.787f));</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     const auto Y3 = Y*Y*Y;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :     Y = (Y3 &gt; 0.008856f).thenElse(Y3, (Y - (16/116.0f)) * (1/7.787f));</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     const auto Z3 = Z*Z*Z;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     Z = (Z3 &gt; 0.008856f).thenElse(Z3, (Z - (16/116.0f)) * (1/7.787f));</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :     // adjust to D50 illuminant
<span class="lineNum">     838 </span>            :     X *= 0.96422f;
<span class="lineNum">     839 </span>            :     Y *= 1.00000f;
<span class="lineNum">     840 </span>            :     Z *= 0.82521f;
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     r = X;</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     g = Y;</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     b = Z;</span>
<a name="845"><span class="lineNum">     845 </span>            : }</a>
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span><span class="lineNoCov">          0 : SI SkNf assert_in_tile(const SkNf&amp; v, float limit) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; N; i++) {</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :         SkASSERT(0 &lt;= v[i] &amp;&amp; v[i] &lt; limit);</span>
<span class="lineNum">     850 </span>            :     }
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     return v;</span>
<a name="852"><span class="lineNum">     852 </span>            : }</a>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineNoCov">          0 : SI SkNf ulp_before(float v) {</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     SkASSERT(v &gt; 0);</span>
<span class="lineNum">     856 </span>            :     SkNf vs(v);
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     SkNu uvs = SkNu::Load(&amp;vs) - 1;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     return SkNf::Load(&amp;uvs);</span>
<a name="859"><span class="lineNum">     859 </span>            : }</a>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 : SI SkNf clamp(const SkNf&amp; v, float limit) {</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     SkNf result = SkNf::Max(0, SkNf::Min(v, ulp_before(limit)));</span>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :     return assert_in_tile(result, limit);</span></a>
<span class="lineNum">     864 </span>            : }
<span class="lineNum">     865 </span><span class="lineNoCov">          0 : SI SkNf repeat(const SkNf&amp; v, float limit) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     SkNf result = v - (v/limit).floor()*limit;</span>
<span class="lineNum">     867 </span>            :     // For small negative v, (v/limit).floor()*limit can dominate v in the subtraction,
<span class="lineNum">     868 </span>            :     // which leaves result == limit.  We want result &lt; limit, so clamp it one ULP.
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     result = SkNf::Min(result, ulp_before(limit));</span>
<a name="870"><span class="lineNum">     870 </span><span class="lineNoCov">          0 :     return assert_in_tile(result, limit);</span></a>
<span class="lineNum">     871 </span>            : }
<span class="lineNum">     872 </span><span class="lineNoCov">          0 : SI SkNf mirror(const SkNf&amp; v, float l/*imit*/) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     SkNf result = ((v - l) - ((v - l) / (2*l)).floor()*(2*l) - l).abs();</span>
<span class="lineNum">     874 </span>            :     // Same deal as repeat.
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     result = SkNf::Min(result, ulp_before(l));</span>
<a name="876"><span class="lineNum">     876 </span><span class="lineNoCov">          0 :     return assert_in_tile(result, l);</span></a>
<a name="877"><span class="lineNum">     877 </span>            : }</a>
<a name="878"><span class="lineNum">     878 </span><span class="lineNoCov">          0 : STAGE_CTX( clamp_x, const float*) { r = clamp (r, *ctx); }</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 : STAGE_CTX(repeat_x, const float*) { r = repeat(r, *ctx); }</span></a>
<a name="880"><span class="lineNum">     880 </span><span class="lineNoCov">          0 : STAGE_CTX(mirror_x, const float*) { r = mirror(r, *ctx); }</span></a>
<a name="881"><span class="lineNum">     881 </span><span class="lineNoCov">          0 : STAGE_CTX( clamp_y, const float*) { g = clamp (g, *ctx); }</span></a>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : STAGE_CTX(repeat_y, const float*) { g = repeat(g, *ctx); }</span>
<a name="883"><span class="lineNum">     883 </span><span class="lineNoCov">          0 : STAGE_CTX(mirror_y, const float*) { g = mirror(g, *ctx); }</span></a>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 : STAGE_CTX(save_xy, SkJumper_SamplerCtx*) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     r.store(ctx-&gt;x);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     g.store(ctx-&gt;y);</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :     // Whether bilinear or bicubic, all sample points have the same fractional offset (fx,fy).
<a name="890"><span class="lineNum">     890 </span>            :     // They're either the 4 corners of a logical 1x1 pixel or the 16 corners of a 3x3 grid</a>
<span class="lineNum">     891 </span>            :     // surrounding (x,y), all (0.5,0.5) off-center.
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     auto fract = [](const SkNf&amp; v) { return v - v.floor(); };</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     fract(r + 0.5f).store(ctx-&gt;fx);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     fract(g + 0.5f).store(ctx-&gt;fy);</span>
<a name="895"><span class="lineNum">     895 </span>            : }</a>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineNoCov">          0 : STAGE_CTX(accumulate, const SkJumper_SamplerCtx*) {</span>
<span class="lineNum">     898 </span>            :     // Bilinear and bicubic filtering are both separable, so we'll end up with independent
<span class="lineNum">     899 </span>            :     // scale contributions in x and y that we multiply together to get each pixel's scale factor.
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     auto scale = SkNf::Load(ctx-&gt;scalex) * SkNf::Load(ctx-&gt;scaley);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     dr = SkNf_fma(scale, r, dr);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     dg = SkNf_fma(scale, g, dg);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     db = SkNf_fma(scale, b, db);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     da = SkNf_fma(scale, a, da);</span>
<span class="lineNum">     905 </span>            : }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            : // In bilinear interpolation, the 4 pixels at +/- 0.5 offsets from the sample pixel center
<span class="lineNum">     908 </span>            : // are combined in direct proportion to their area overlapping that logical query pixel.
<span class="lineNum">     909 </span>            : // At positive offsets, the x-axis contribution to that rectangular area is fx; (1-fx)
<a name="910"><span class="lineNum">     910 </span>            : // at negative x offsets.  The y-axis is treated symmetrically.</a>
<span class="lineNum">     911 </span>            : template &lt;int Scale&gt;
<span class="lineNum">     912 </span><span class="lineNoCov">          0 : SI void bilinear_x(SkJumper_SamplerCtx* ctx, SkNf* x) {</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     *x = SkNf::Load(ctx-&gt;x) + Scale*0.5f;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     auto fx = SkNf::Load(ctx-&gt;fx);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     (Scale &gt; 0 ? fx : (1.0f - fx)).store(ctx-&gt;scalex);</span>
<a name="916"><span class="lineNum">     916 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     917 </span>            : template &lt;int Scale&gt;
<span class="lineNum">     918 </span><span class="lineNoCov">          0 : SI void bilinear_y(SkJumper_SamplerCtx* ctx, SkNf* y) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     *y = SkNf::Load(ctx-&gt;y) + Scale*0.5f;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :     auto fy = SkNf::Load(ctx-&gt;fy);</span>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :     (Scale &gt; 0 ? fy : (1.0f - fy)).store(ctx-&gt;scaley);</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 : }</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 : STAGE_CTX(bilinear_nx, SkJumper_SamplerCtx*) { bilinear_x&lt;-1&gt;(ctx, &amp;r); }</span></a>
<a name="924"><span class="lineNum">     924 </span><span class="lineNoCov">          0 : STAGE_CTX(bilinear_px, SkJumper_SamplerCtx*) { bilinear_x&lt;+1&gt;(ctx, &amp;r); }</span></a>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 : STAGE_CTX(bilinear_ny, SkJumper_SamplerCtx*) { bilinear_y&lt;-1&gt;(ctx, &amp;g); }</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 : STAGE_CTX(bilinear_py, SkJumper_SamplerCtx*) { bilinear_y&lt;+1&gt;(ctx, &amp;g); }</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : // In bilinear interpolation, the 16 pixels at +/- 0.5 and +/- 1.5 offsets from the sample
<span class="lineNum">     930 </span>            : // pixel center are combined with a non-uniform cubic filter, with high filter values near
<span class="lineNum">     931 </span>            : // the center and lower values farther away.
<span class="lineNum">     932 </span>            : //
<span class="lineNum">     933 </span>            : // We break this filter function into two parts, one for near +/- 0.5 offsets,
<span class="lineNum">     934 </span>            : // and one for far +/- 1.5 offsets.
<a name="935"><span class="lineNum">     935 </span>            : //</a>
<span class="lineNum">     936 </span>            : // See GrBicubicEffect for details about this particular Mitchell-Netravali filter.
<span class="lineNum">     937 </span><span class="lineNoCov">          0 : SI SkNf bicubic_near(const SkNf&amp; t) {</span>
<span class="lineNum">     938 </span>            :     // 1/18 + 9/18t + 27/18t^2 - 21/18t^3 == t ( t ( -21/18t + 27/18) + 9/18) + 1/18
<a name="939"><span class="lineNum">     939 </span><span class="lineNoCov">          0 :     return SkNf_fma(t, SkNf_fma(t, SkNf_fma(-21/18.0f, t, 27/18.0f), 9/18.0f), 1/18.0f);</span></a>
<span class="lineNum">     940 </span>            : }
<span class="lineNum">     941 </span><span class="lineNoCov">          0 : SI SkNf bicubic_far(const SkNf&amp; t) {</span>
<span class="lineNum">     942 </span>            :     // 0/18 + 0/18*t - 6/18t^2 + 7/18t^3 == t^2 (7/18t - 6/18)
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     return (t*t)*SkNf_fma(7/18.0f, t, -6/18.0f);</span>
<span class="lineNum">     944 </span>            : }
<a name="945"><span class="lineNum">     945 </span>            : </a>
<span class="lineNum">     946 </span>            : template &lt;int Scale&gt;
<span class="lineNum">     947 </span><span class="lineNoCov">          0 : SI void bicubic_x(SkJumper_SamplerCtx* ctx, SkNf* x) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     *x = SkNf::Load(ctx-&gt;x) + Scale*0.5f;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     auto fx = SkNf::Load(ctx-&gt;fx);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     if (Scale == -3) { return bicubic_far (1.0f - fx).store(ctx-&gt;scalex); }</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     if (Scale == -1) { return bicubic_near(1.0f - fx).store(ctx-&gt;scalex); }</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     if (Scale == +1) { return bicubic_near(       fx).store(ctx-&gt;scalex); }</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if (Scale == +3) { return bicubic_far (       fx).store(ctx-&gt;scalex); }</span>
<span class="lineNum">     954 </span>            :     SkDEBUGFAIL(&quot;unreachable&quot;);
<a name="955"><span class="lineNum">     955 </span>            : }</a>
<span class="lineNum">     956 </span>            : template &lt;int Scale&gt;
<span class="lineNum">     957 </span><span class="lineNoCov">          0 : SI void bicubic_y(SkJumper_SamplerCtx* ctx, SkNf* y) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     *y = SkNf::Load(ctx-&gt;y) + Scale*0.5f;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     auto fy = SkNf::Load(ctx-&gt;fy);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     if (Scale == -3) { return bicubic_far (1.0f - fy).store(ctx-&gt;scaley); }</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     if (Scale == -1) { return bicubic_near(1.0f - fy).store(ctx-&gt;scaley); }</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     if (Scale == +1) { return bicubic_near(       fy).store(ctx-&gt;scaley); }</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     if (Scale == +3) { return bicubic_far (       fy).store(ctx-&gt;scaley); }</span>
<a name="964"><span class="lineNum">     964 </span>            :     SkDEBUGFAIL(&quot;unreachable&quot;);</a>
<a name="965"><span class="lineNum">     965 </span>            : }</a>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_n3x, SkJumper_SamplerCtx*) { bicubic_x&lt;-3&gt;(ctx, &amp;r); }</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_n1x, SkJumper_SamplerCtx*) { bicubic_x&lt;-1&gt;(ctx, &amp;r); }</span></a>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_p1x, SkJumper_SamplerCtx*) { bicubic_x&lt;+1&gt;(ctx, &amp;r); }</span>
<a name="969"><span class="lineNum">     969 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_p3x, SkJumper_SamplerCtx*) { bicubic_x&lt;+3&gt;(ctx, &amp;r); }</span></a>
<a name="970"><span class="lineNum">     970 </span>            : </a>
<a name="971"><span class="lineNum">     971 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_n3y, SkJumper_SamplerCtx*) { bicubic_y&lt;-3&gt;(ctx, &amp;g); }</span></a>
<a name="972"><span class="lineNum">     972 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_n1y, SkJumper_SamplerCtx*) { bicubic_y&lt;-1&gt;(ctx, &amp;g); }</span></a>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_p1y, SkJumper_SamplerCtx*) { bicubic_y&lt;+1&gt;(ctx, &amp;g); }</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 : STAGE_CTX(bicubic_p3y, SkJumper_SamplerCtx*) { bicubic_y&lt;+3&gt;(ctx, &amp;g); }</span>
<span class="lineNum">     975 </span>            : 
<a name="976"><span class="lineNum">     976 </span>            : </a>
<span class="lineNum">     977 </span>            : template &lt;typename T&gt;
<span class="lineNum">     978 </span><span class="lineNoCov">          0 : SI SkNi offset_and_ptr(T** ptr, const SkJumper_GatherCtx* ctx, const SkNf&amp; x, const SkNf&amp; y) {</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     SkNi ix = SkNx_cast&lt;int&gt;(x),</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :          iy = SkNx_cast&lt;int&gt;(y);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     SkNi offset = iy*ctx-&gt;stride + ix;</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     *ptr = (const T*)ctx-&gt;pixels;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     return offset;</span>
<a name="985"><span class="lineNum">     985 </span>            : }</a>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_a8, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">     988 </span>            :     const uint8_t* p;
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     r = g = b = 0.0f;</span>
<a name="992"><span class="lineNum">     992 </span><span class="lineNoCov">          0 :     a = SkNf_from_byte(gather(tail, p, offset));</span></a>
<span class="lineNum">     993 </span>            : }
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_i8, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">     995 </span>            :     const uint8_t* p;
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     SkNi ix = SkNx_cast&lt;int&gt;(gather(tail, p, offset));</span>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :     from_8888(gather(tail, ctx-&gt;ctable, ix), &amp;r, &amp;g, &amp;b, &amp;a);</span></a>
<span class="lineNum">    1000 </span>            : }
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_g8, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">    1002 </span>            :     const uint8_t* p;
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     r = g = b = SkNf_from_byte(gather(tail, p, offset));</span>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     a = 1.0f;</span></a>
<span class="lineNum">    1007 </span>            : }
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_565, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">    1009 </span>            :     const uint16_t* p;
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     from_565(gather(tail, p, offset), &amp;r, &amp;g, &amp;b);</span>
<a name="1013"><span class="lineNum">    1013 </span><span class="lineNoCov">          0 :     a = 1.0f;</span></a>
<span class="lineNum">    1014 </span>            : }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_4444, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">    1016 </span>            :     const uint16_t* p;
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">    1018 </span>            : 
<a name="1019"><span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     from_4444(gather(tail, p, offset), &amp;r, &amp;g, &amp;b, &amp;a);</span></a>
<span class="lineNum">    1020 </span>            : }
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_8888, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">    1022 </span>            :     const uint32_t* p;
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">    1024 </span>            : 
<a name="1025"><span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     from_8888(gather(tail, p, offset), &amp;r, &amp;g, &amp;b, &amp;a);</span></a>
<span class="lineNum">    1026 </span>            : }
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 : STAGE_CTX(gather_f16, const SkJumper_GatherCtx*) {</span>
<span class="lineNum">    1028 </span>            :     const uint64_t* p;
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     SkNi offset = offset_and_ptr(&amp;p, ctx, r, g);</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     auto px = gather(tail, p, offset);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     from_f16(&amp;px, &amp;r, &amp;g, &amp;b, &amp;a);</span>
<a name="1033"><span class="lineNum">    1033 </span>            : }</a>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 : STAGE_CTX(linear_gradient, const SkPM4f*) {</span>
<span class="lineNum">    1036 </span>            :     struct Stop { float pos; float f[4], b[4]; };
<span class="lineNum">    1037 </span>            :     struct Ctx { size_t n; Stop *stops; float start[4]; };
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     auto c = (const Ctx*)ctx;</span>
<span class="lineNum">    1040 </span>            :     SkNf fr = 0, fg = 0, fb = 0, fa = 0;
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     SkNf br = c-&gt;start[0],</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :          bg = c-&gt;start[1],</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :          bb = c-&gt;start[2],</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :          ba = c-&gt;start[3];</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     auto t = r;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; c-&gt;n; i++) {</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         fr = (t &lt; c-&gt;stops[i].pos).thenElse(fr, c-&gt;stops[i].f[0]);</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :         fg = (t &lt; c-&gt;stops[i].pos).thenElse(fg, c-&gt;stops[i].f[1]);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         fb = (t &lt; c-&gt;stops[i].pos).thenElse(fb, c-&gt;stops[i].f[2]);</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         fa = (t &lt; c-&gt;stops[i].pos).thenElse(fa, c-&gt;stops[i].f[3]);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :         br = (t &lt; c-&gt;stops[i].pos).thenElse(br, c-&gt;stops[i].b[0]);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :         bg = (t &lt; c-&gt;stops[i].pos).thenElse(bg, c-&gt;stops[i].b[1]);</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :         bb = (t &lt; c-&gt;stops[i].pos).thenElse(bb, c-&gt;stops[i].b[2]);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         ba = (t &lt; c-&gt;stops[i].pos).thenElse(ba, c-&gt;stops[i].b[3]);</span>
<span class="lineNum">    1055 </span>            :     }
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     r = SkNf_fma(t, fr, br);</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     g = SkNf_fma(t, fg, bg);</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     b = SkNf_fma(t, fb, bb);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     a = SkNf_fma(t, fa, ba);</span>
<a name="1061"><span class="lineNum">    1061 </span>            : }</a>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 : STAGE_CTX(linear_gradient_2stops, const SkPM4f*) {</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     auto t = r;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     SkPM4f c0 = ctx[0],</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         dc = ctx[1];</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     r = SkNf_fma(t, dc.r(), c0.r());</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     g = SkNf_fma(t, dc.g(), c0.g());</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     b = SkNf_fma(t, dc.b(), c0.b());</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     a = SkNf_fma(t, dc.a(), c0.a());</span>
<a name="1072"><span class="lineNum">    1072 </span>            : }</a>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 : STAGE_CTX(byte_tables, const void*) {</span>
<span class="lineNum">    1075 </span>            :     struct Tables { const uint8_t *r, *g, *b, *a; };
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     auto tables = (const Tables*)ctx;</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     r = SkNf_from_byte(gather(tail, tables-&gt;r, SkNf_round(255.0f, r)));</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     g = SkNf_from_byte(gather(tail, tables-&gt;g, SkNf_round(255.0f, g)));</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     b = SkNf_from_byte(gather(tail, tables-&gt;b, SkNf_round(255.0f, b)));</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     a = SkNf_from_byte(gather(tail, tables-&gt;a, SkNf_round(255.0f, a)));</span>
<a name="1082"><span class="lineNum">    1082 </span>            : }</a>
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : STAGE_CTX(byte_tables_rgb, const void*) {</span>
<span class="lineNum">    1085 </span>            :     struct Tables { const uint8_t *r, *g, *b; int n; };
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     auto tables = (const Tables*)ctx;</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     float scale = tables-&gt;n - 1;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     r = SkNf_from_byte(gather(tail, tables-&gt;r, SkNf_round(scale, r)));</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     g = SkNf_from_byte(gather(tail, tables-&gt;g, SkNf_round(scale, g)));</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     b = SkNf_from_byte(gather(tail, tables-&gt;b, SkNf_round(scale, b)));</span>
<a name="1092"><span class="lineNum">    1092 </span>            : }</a>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 : STAGE_CTX(shader_adapter, SkShader::Context*) {</span>
<span class="lineNum">    1095 </span>            :     SkPM4f buf[N];
<span class="lineNum">    1096 </span>            :     static_assert(sizeof(buf) == sizeof(r) + sizeof(g) + sizeof(b) + sizeof(a), &quot;&quot;);
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     ctx-&gt;shadeSpan4f(x, (int)g[0], buf, N);</span>
<span class="lineNum">    1098 </span>            :     SkNf::Load4(buf, &amp;r, &amp;g, &amp;b, &amp;a);
<a name="1099"><span class="lineNum">    1099 </span>            : }</a>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 : SI Fn enum_to_Fn(SkRasterPipeline::StockStage st) {</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     switch (st) {</span>
<span class="lineNum">    1103 </span>            :     #define M(stage) case SkRasterPipeline::stage: return stage;
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         SK_RASTER_PIPELINE_STAGES(M)</span>
<span class="lineNum">    1105 </span>            :     #undef M
<span class="lineNum">    1106 </span>            :     }
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     SkASSERT(false);</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     return just_return;</span>
<span class="lineNum">    1109 </span>            : }
<span class="lineNum">    1110 </span>            : 
<a name="1111"><span class="lineNum">    1111 </span>            : namespace {</a>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     static void build_program(void** program, const SkRasterPipeline::Stage* stages, int nstages) {</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; nstages; i++) {</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :             *program++ = (void*)enum_to_Fn(stages[i].stage);</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :             if (stages[i].ctx) {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                 *program++ = stages[i].ctx;</span>
<span class="lineNum">    1118 </span>            :             }
<span class="lineNum">    1119 </span>            :         }
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         *program++ = (void*)just_return;</span>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     static void run_program(void** program, size_t x, size_t n) {</span>
<span class="lineNum">    1124 </span>            :         SkNf u;  // fastest to start uninitialized.
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         auto start = (Fn)load_and_increment(&amp;program);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :         while (n &gt;= N) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :             start(x*N, program, u,u,u,u, u,u,u,u);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :             x += N;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             n -= N;</span>
<span class="lineNum">    1131 </span>            :         }
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         if (n) {</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :             start(x*N+n, program, u,u,u,u, u,u,u,u);</span>
<span class="lineNum">    1134 </span>            :         }
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :     // Compiled manages its memory manually because it's not safe to use
<a name="1138"><span class="lineNum">    1138 </span>            :     // std::vector, SkTDArray, etc without setting us up for big ODR violations.</a>
<span class="lineNum">    1139 </span>            :     struct Compiled {
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :         Compiled(const SkRasterPipeline::Stage* stages, int nstages) {</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :             int slots = nstages + 1;  // One extra for just_return.</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; nstages; i++) {</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 if (stages[i].ctx) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                     slots++;</span>
<span class="lineNum">    1145 </span>            :                 }
<span class="lineNum">    1146 </span>            :             }
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :             fProgram = (void**)sk_malloc_throw(slots * sizeof(void*));</span>
<a name="1148"><span class="lineNum">    1148 </span><span class="lineNoCov">          0 :             build_program(fProgram, stages, nstages);</span></a>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :         ~Compiled() { sk_free(fProgram); }</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :         Compiled(const Compiled&amp; o) {
<span class="lineNum">    1153 </span>            :             int slots = 0;
<span class="lineNum">    1154 </span>            :             while (o.fProgram[slots++] != (void*)just_return);
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :             fProgram = (void**)sk_malloc_throw(slots * sizeof(void*));
<span class="lineNum">    1157 </span>            :             memcpy(fProgram, o.fProgram, slots * sizeof(void*));
<a name="1158"><span class="lineNum">    1158 </span>            :         }</a>
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         void operator()(size_t x, size_t n) {</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             run_program(fProgram, x, n);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :         void** fProgram;
<span class="lineNum">    1165 </span>            :     };
<span class="lineNum">    1166 </span>            : }
<span class="lineNum">    1167 </span>            : 
<a name="1168"><span class="lineNum">    1168 </span>            : namespace SK_OPTS_NS {</a>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     SI void run_pipeline(size_t x, size_t n,</span>
<span class="lineNum">    1171 </span>            :                          const SkRasterPipeline::Stage* stages, int nstages) {
<span class="lineNum">    1172 </span>            :         static const int kStackMax = 256;
<span class="lineNum">    1173 </span>            :         // Worst case is nstages stages with nstages context pointers, and just_return.
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         if (2*nstages+1 &lt;= kStackMax) {</span>
<span class="lineNum">    1175 </span>            :             void* program[kStackMax];
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :             build_program(program, stages, nstages);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :             run_program(program, x,n);</span>
<span class="lineNum">    1178 </span>            :         } else {
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             Compiled{stages,nstages}(x,n);</span>
<span class="lineNum">    1180 </span>            :         }
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            : }  // namespace SK_OPTS_NS
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            : #undef SI
<span class="lineNum">    1186 </span>            : #undef STAGE
<span class="lineNum">    1187 </span>            : #undef STAGE_CTX
<span class="lineNum">    1188 </span>            : #undef RGBA_XFERMODE
<span class="lineNum">    1189 </span>            : #undef RGB_XFERMODE
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : #endif//SkRasterPipeline_opts_DEFINED
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

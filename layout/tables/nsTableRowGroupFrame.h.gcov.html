<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/tables/nsTableRowGroupFrame.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/tables</a> - nsTableRowGroupFrame.h<span style="font-size: 80%;"> (source / <a href="nsTableRowGroupFrame.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : #ifndef nsTableRowGroupFrame_h__
<span class="lineNum">       6 </span>            : #define nsTableRowGroupFrame_h__
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;nscore.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsContainerFrame.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsIAtom.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsILineIterator.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsTableFrame.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/WritingModes.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : class nsTableRowFrame;
<span class="lineNum">      18 </span>            : namespace mozilla {
<span class="lineNum">      19 </span>            : struct TableRowGroupReflowInput;
<span class="lineNum">      20 </span>            : } // namespace mozilla
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #define MIN_ROWS_NEEDING_CURSOR 20
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : /**
<span class="lineNum">      25 </span>            :  * nsTableRowGroupFrame is the frame that maps row groups
<span class="lineNum">      26 </span>            :  * (HTML tags THEAD, TFOOT, and TBODY). This class cannot be reused
<span class="lineNum">      27 </span>            :  * outside of an nsTableFrame.  It assumes that its parent is an nsTableFrame, and
<span class="lineNum">      28 </span>            :  * its children are nsTableRowFrames.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * @see nsTableFrame
<span class="lineNum">      31 </span>            :  * @see nsTableRowFrame
<span class="lineNum">      32 </span>            :  */
<span class="lineNum">      33 </span>            : class nsTableRowGroupFrame final
<span class="lineNum">      34 </span>            :   : public nsContainerFrame
<span class="lineNum">      35 </span>            :   , public nsILineIterator
<span class="lineNum">      36 </span>            : {
<span class="lineNum">      37 </span>            :   using TableRowGroupReflowInput = mozilla::TableRowGroupReflowInput;
<span class="lineNum">      38 </span>            : 
<a name="39"><span class="lineNum">      39 </span>            : public:</a>
<span class="lineNum">      40 </span>            :   NS_DECL_QUERYFRAME
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   NS_DECL_FRAMEARENA_HELPERS(nsTableRowGroupFrame)</span>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :   /** instantiate a new instance of nsTableRowFrame.
<span class="lineNum">      44 </span>            :     * @param aPresShell the pres shell for this frame
<span class="lineNum">      45 </span>            :     *
<span class="lineNum">      46 </span>            :     * @return           the frame that was created
<span class="lineNum">      47 </span>            :     */
<span class="lineNum">      48 </span>            :   friend nsTableRowGroupFrame* NS_NewTableRowGroupFrame(nsIPresShell* aPresShell,
<span class="lineNum">      49 </span>            :                                                         nsStyleContext* aContext);
<span class="lineNum">      50 </span>            :   virtual ~nsTableRowGroupFrame();
<a name="51"><span class="lineNum">      51 </span>            : </a>
<span class="lineNum">      52 </span>            :   // nsIFrame overrides
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   virtual void Init(nsIContent*       aContent,</span>
<span class="lineNum">      54 </span>            :                     nsContainerFrame* aParent,
<span class="lineNum">      55 </span>            :                     nsIFrame*         aPrevInFlow) override
<span class="lineNum">      56 </span>            :   {
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     nsContainerFrame::Init(aContent, aParent, aPrevInFlow);</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     if (!aPrevInFlow) {</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :       mWritingMode = GetTableFrame()-&gt;GetWritingMode();</span>
<span class="lineNum">      60 </span>            :     }
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   virtual void DestroyFrom(nsIFrame* aDestructRoot) override;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :   /** @see nsIFrame::DidSetStyleContext */
<span class="lineNum">      66 </span>            :   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext) override;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :   virtual void AppendFrames(ChildListID     aListID,
<span class="lineNum">      69 </span>            :                             nsFrameList&amp;    aFrameList) override;
<span class="lineNum">      70 </span>            :   virtual void InsertFrames(ChildListID     aListID,
<span class="lineNum">      71 </span>            :                             nsIFrame*       aPrevFrame,
<span class="lineNum">      72 </span>            :                             nsFrameList&amp;    aFrameList) override;
<span class="lineNum">      73 </span>            :   virtual void RemoveFrame(ChildListID     aListID,
<span class="lineNum">      74 </span>            :                            nsIFrame*       aOldFrame) override;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :   virtual nsMargin GetUsedMargin() const override;
<span class="lineNum">      77 </span>            :   virtual nsMargin GetUsedBorder() const override;
<span class="lineNum">      78 </span>            :   virtual nsMargin GetUsedPadding() const override;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   virtual void BuildDisplayList(nsDisplayListBuilder*   aBuilder,
<span class="lineNum">      81 </span>            :                                 const nsRect&amp;           aDirtyRect,
<span class="lineNum">      82 </span>            :                                 const nsDisplayListSet&amp; aLists) override;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :    /** calls Reflow for all of its child rows.
<span class="lineNum">      85 </span>            :     * Rows are all set to the same isize and stacked in the block direction.
<span class="lineNum">      86 </span>            :     * &lt;P&gt; rows are not split unless absolutely necessary.
<span class="lineNum">      87 </span>            :     *
<span class="lineNum">      88 </span>            :     * @param aDesiredSize isize set to isize of rows, bsize set to
<span class="lineNum">      89 </span>            :     *                     sum of bsize of rows that fit in AvailableBSize.
<span class="lineNum">      90 </span>            :     *
<span class="lineNum">      91 </span>            :     * @see nsIFrame::Reflow
<span class="lineNum">      92 </span>            :     */
<span class="lineNum">      93 </span>            :   virtual void Reflow(nsPresContext*           aPresContext,
<span class="lineNum">      94 </span>            :                       ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">      95 </span>            :                       const ReflowInput&amp; aReflowInput,
<span class="lineNum">      96 </span>            :                       nsReflowStatus&amp;          aStatus) override;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   virtual bool ComputeCustomOverflow(nsOverflowAreas&amp; aOverflowAreas) override;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : #ifdef DEBUG_FRAME_DUMP
<span class="lineNum">     101 </span>            :   virtual nsresult GetFrameName(nsAString&amp; aResult) const override;
<span class="lineNum">     102 </span>            : #endif
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :   nsTableRowFrame* GetFirstRow();
<a name="105"><span class="lineNum">     105 </span>            :   nsTableRowFrame* GetLastRow();</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   nsTableFrame* GetTableFrame() const</span>
<span class="lineNum">     108 </span>            :   {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     nsIFrame* parent = GetParent();</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(parent &amp;&amp; parent-&gt;IsTableFrame());</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     return static_cast&lt;nsTableFrame*&gt;(parent);</span>
<span class="lineNum">     112 </span>            :   }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :   /** return the number of child rows (not necessarily == number of child frames) */
<span class="lineNum">     115 </span>            :   int32_t GetRowCount();
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   /** return the table-relative row index of the first row in this rowgroup.
<span class="lineNum">     118 </span>            :     * if there are no rows, -1 is returned.
<span class="lineNum">     119 </span>            :     */
<span class="lineNum">     120 </span>            :   int32_t GetStartRowIndex();
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   /** Adjust the row indices of all rows  whose index is &gt;= aRowIndex.
<span class="lineNum">     123 </span>            :     * @param aRowIndex   - start adjusting with this index
<span class="lineNum">     124 </span>            :     * @param aAdjustment - shift the row index by this amount
<span class="lineNum">     125 </span>            :     */
<span class="lineNum">     126 </span>            :   void AdjustRowIndices(int32_t   aRowIndex,
<span class="lineNum">     127 </span>            :                         int32_t   anAdjustment);
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :   // See nsTableFrame.h
<span class="lineNum">     130 </span>            :   int32_t GetAdjustmentForStoredIndex(int32_t aStoredIndex);
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :   /* mark rows starting from aStartRowFrame to the next 'aNumRowsToRemove-1'
<span class="lineNum">     133 </span>            :    * number of rows as deleted
<span class="lineNum">     134 </span>            :    */
<span class="lineNum">     135 </span>            :   void MarkRowsAsDeleted(nsTableRowFrame&amp; aStartRowFrame,
<span class="lineNum">     136 </span>            :                          int32_t          aNumRowsToDelete);
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // See nsTableFrame.h
<span class="lineNum">     139 </span>            :   void AddDeletedRowIndex(int32_t aDeletedRowStoredIndex);
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   /**
<span class="lineNum">     143 </span>            :    * Used for header and footer row group frames that are repeated when
<span class="lineNum">     144 </span>            :    * splitting a table frame.
<span class="lineNum">     145 </span>            :    *
<span class="lineNum">     146 </span>            :    * Performs any table specific initialization
<span class="lineNum">     147 </span>            :    *
<span class="lineNum">     148 </span>            :    * @param aHeaderFooterFrame the original header or footer row group frame
<span class="lineNum">     149 </span>            :    * that was repeated
<span class="lineNum">     150 </span>            :    */
<span class="lineNum">     151 </span>            :   nsresult  InitRepeatedFrame(nsTableRowGroupFrame* aHeaderFooterFrame);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   /**
<span class="lineNum">     155 </span>            :    * Get the total bsize of all the row rects
<span class="lineNum">     156 </span>            :    */
<span class="lineNum">     157 </span>            :   nscoord GetBSizeBasis(const ReflowInput&amp; aReflowInput);
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :   mozilla::LogicalMargin GetBCBorderWidth(mozilla::WritingMode aWM);
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   /**
<span class="lineNum">     162 </span>            :    * Gets inner border widths before collapsing with cell borders
<span class="lineNum">     163 </span>            :    * Caller must get bstart border from previous row group or from table
<span class="lineNum">     164 </span>            :    * GetContinuousBCBorderWidth will not overwrite aBorder.BStart()
<span class="lineNum">     165 </span>            :    * see nsTablePainter about continuous borders
<span class="lineNum">     166 </span>            :    */
<span class="lineNum">     167 </span>            :   void GetContinuousBCBorderWidth(mozilla::WritingMode aWM,
<span class="lineNum">     168 </span>            :                                   mozilla::LogicalMargin&amp; aBorder);
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   /**
<span class="lineNum">     171 </span>            :    * Sets full border widths before collapsing with cell borders
<span class="lineNum">     172 </span>            :    * @param aForSide - side to set; only IEnd, IStart, BEnd are valid
<span class="lineNum">     173 </span>            :    */
<span class="lineNum">     174 </span>            :   void SetContinuousBCBorderWidth(mozilla::LogicalSide aForSide,
<span class="lineNum">     175 </span>            :                                   BCPixelSize aPixelValue);
<span class="lineNum">     176 </span>            :   /**
<span class="lineNum">     177 </span>            :     * Adjust to the effect of visibility:collapse on the row group and
<span class="lineNum">     178 </span>            :     * its children
<span class="lineNum">     179 </span>            :     * @return              additional shift bstart-wards that should be applied
<span class="lineNum">     180 </span>            :     *                      to subsequent rowgroups due to rows and this
<span class="lineNum">     181 </span>            :     *                      rowgroup being collapsed
<span class="lineNum">     182 </span>            :     * @param aBTotalOffset the total amount that the rowgroup is shifted
<span class="lineNum">     183 </span>            :     * @param aISize        new isize of the rowgroup
<span class="lineNum">     184 </span>            :     * @param aWM           the table's writing mode
<span class="lineNum">     185 </span>            :     */
<span class="lineNum">     186 </span>            :   nscoord CollapseRowGroupIfNecessary(nscoord aBTotalOffset,
<span class="lineNum">     187 </span>            :                                       nscoord aISize,
<span class="lineNum">     188 </span>            :                                       mozilla::WritingMode aWM);
<span class="lineNum">     189 </span>            : 
<a name="190"><span class="lineNum">     190 </span>            : // nsILineIterator methods</a>
<span class="lineNum">     191 </span>            : public:
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   virtual void DisposeLineIterator() override { }</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   // The table row is the equivalent to a line in block layout.
<span class="lineNum">     195 </span>            :   // The nsILineIterator assumes that a line resides in a block, this role is
<span class="lineNum">     196 </span>            :   // fullfilled by the row group. Rows in table are counted relative to the
<span class="lineNum">     197 </span>            :   // table. The row index of row corresponds to the cellmap coordinates. The
<span class="lineNum">     198 </span>            :   // line index with respect to a row group can be computed by substracting the
<span class="lineNum">     199 </span>            :   // row index of the first row in the row group.
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   /** Get the number of rows in a row group
<span class="lineNum">     202 </span>            :     * @return the number of lines in a row group
<span class="lineNum">     203 </span>            :     */
<span class="lineNum">     204 </span>            :   virtual int32_t GetNumLines() override;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   /** @see nsILineIterator.h GetDirection
<span class="lineNum">     207 </span>            :     * @return true if the table is rtl
<span class="lineNum">     208 </span>            :     */
<span class="lineNum">     209 </span>            :   virtual bool GetDirection() override;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :   /** Return structural information about a line.
<span class="lineNum">     212 </span>            :     * @param aLineNumber       - the index of the row relative to the row group
<span class="lineNum">     213 </span>            :     *                            If the line-number is invalid then
<span class="lineNum">     214 </span>            :     *                            aFirstFrameOnLine will be nullptr and
<span class="lineNum">     215 </span>            :     *                            aNumFramesOnLine will be zero.
<span class="lineNum">     216 </span>            :     * @param aFirstFrameOnLine - the first cell frame that originates in row
<span class="lineNum">     217 </span>            :     *                            with a rowindex that matches a line number
<span class="lineNum">     218 </span>            :     * @param aNumFramesOnLine  - return the numbers of cells originating in
<span class="lineNum">     219 </span>            :     *                            this row
<span class="lineNum">     220 </span>            :     * @param aLineBounds       - rect of the row
<span class="lineNum">     221 </span>            :     */
<span class="lineNum">     222 </span>            :   NS_IMETHOD GetLine(int32_t aLineNumber,
<span class="lineNum">     223 </span>            :                      nsIFrame** aFirstFrameOnLine,
<span class="lineNum">     224 </span>            :                      int32_t* aNumFramesOnLine,
<span class="lineNum">     225 </span>            :                      nsRect&amp; aLineBounds) override;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   /** Given a frame that's a child of the rowgroup, find which line its on.
<span class="lineNum">     228 </span>            :     * @param aFrame       - frame, should be a row
<span class="lineNum">     229 </span>            :     * @param aStartLine   - minimal index to return
<span class="lineNum">     230 </span>            :     * @return               row index relative to the row group if this a row
<span class="lineNum">     231 </span>            :     *                       frame and the index is at least aStartLine.
<span class="lineNum">     232 </span>            :     *                       -1 if the frame cannot be found.
<span class="lineNum">     233 </span>            :     */
<span class="lineNum">     234 </span>            :   virtual int32_t FindLineContaining(nsIFrame* aFrame, int32_t aStartLine = 0) override;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   /** Find the orginating cell frame on a row that is the nearest to the
<span class="lineNum">     237 </span>            :     * inline-dir coordinate of aPos.
<span class="lineNum">     238 </span>            :     * @param aLineNumber          - the index of the row relative to the row group
<span class="lineNum">     239 </span>            :     * @param aPos                 - coordinate in twips relative to the
<span class="lineNum">     240 </span>            :     *                               origin of the row group
<span class="lineNum">     241 </span>            :     * @param aFrameFound          - pointer to the cellframe
<span class="lineNum">     242 </span>            :     * @param aPosIsBeforeFirstFrame - the point is before the first originating
<span class="lineNum">     243 </span>            :     *                               cellframe
<span class="lineNum">     244 </span>            :     * @param aPosIsAfterLastFrame   - the point is after the last originating
<span class="lineNum">     245 </span>            :     *                               cellframe
<span class="lineNum">     246 </span>            :     */
<span class="lineNum">     247 </span>            :   NS_IMETHOD FindFrameAt(int32_t aLineNumber,
<span class="lineNum">     248 </span>            :                          nsPoint aPos,
<span class="lineNum">     249 </span>            :                          nsIFrame** aFrameFound,
<span class="lineNum">     250 </span>            :                          bool* aPosIsBeforeFirstFrame,
<span class="lineNum">     251 </span>            :                          bool* aPosIsAfterLastFrame) override;
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :    /** Check whether visual and logical order of cell frames within a line are
<span class="lineNum">     254 </span>            :      * identical. As the layout will reorder them this is always the case
<span class="lineNum">     255 </span>            :      * @param aLine        - the index of the row relative to the table
<span class="lineNum">     256 </span>            :      * @param aIsReordered - returns false
<span class="lineNum">     257 </span>            :      * @param aFirstVisual - if the table is rtl first originating cell frame
<span class="lineNum">     258 </span>            :      * @param aLastVisual  - if the table is rtl last originating cell frame
<span class="lineNum">     259 </span>            :      */
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   NS_IMETHOD CheckLineOrder(int32_t                  aLine,
<span class="lineNum">     262 </span>            :                             bool                     *aIsReordered,
<span class="lineNum">     263 </span>            :                             nsIFrame                 **aFirstVisual,
<span class="lineNum">     264 </span>            :                             nsIFrame                 **aLastVisual) override;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   /** Find the next originating cell frame that originates in the row.
<span class="lineNum">     267 </span>            :     * @param aFrame      - cell frame to start with, will return the next cell
<span class="lineNum">     268 </span>            :     *                      originating in a row
<span class="lineNum">     269 </span>            :     * @param aLineNumber - the index of the row relative to the table
<span class="lineNum">     270 </span>            :     */
<span class="lineNum">     271 </span>            :   NS_IMETHOD GetNextSiblingOnLine(nsIFrame*&amp; aFrame, int32_t aLineNumber) override;
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :   // row cursor methods to speed up searching for the row(s)
<span class="lineNum">     274 </span>            :   // containing a point. The basic idea is that we set the cursor
<span class="lineNum">     275 </span>            :   // property if the rows' y and yMosts are non-decreasing (considering only
<span class="lineNum">     276 </span>            :   // rows with nonempty overflowAreas --- empty overflowAreas never participate
<span class="lineNum">     277 </span>            :   // in event handling or painting), and the rowgroup has sufficient number of
<span class="lineNum">     278 </span>            :   // rows. The cursor property points to a &quot;recently used&quot; row. If we get a
<span class="lineNum">     279 </span>            :   // series of requests that work on rows &quot;near&quot; the cursor, then we can find
<span class="lineNum">     280 </span>            :   // those nearby rows quickly by starting our search at the cursor.
<a name="281"><span class="lineNum">     281 </span>            :   // This code is based on the line cursor code in nsBlockFrame. It's more general</a>
<span class="lineNum">     282 </span>            :   // though, and could be extracted and used elsewhere.
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   struct FrameCursorData {</span>
<span class="lineNum">     284 </span>            :     nsTArray&lt;nsIFrame*&gt; mFrames;
<span class="lineNum">     285 </span>            :     uint32_t            mCursorIndex;
<span class="lineNum">     286 </span>            :     nscoord             mOverflowAbove;
<a name="287"><span class="lineNum">     287 </span>            :     nscoord             mOverflowBelow;</a>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     FrameCursorData()</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       : mFrames(MIN_ROWS_NEEDING_CURSOR), mCursorIndex(0), mOverflowAbove(0),</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         mOverflowBelow(0) {}</span>
<span class="lineNum">     292 </span>            : 
<a name="293"><span class="lineNum">     293 </span>            :     bool AppendFrame(nsIFrame* aFrame);</a>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     void FinishBuildingCursor() {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       mFrames.Compact();</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     298 </span>            :   };
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :   // Clear out row cursor because we're disturbing the rows (e.g., Reflow)
<span class="lineNum">     301 </span>            :   void ClearRowCursor();
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   /**
<span class="lineNum">     304 </span>            :    * Get the first row that might contain y-coord 'aY', or nullptr if you must search
<span class="lineNum">     305 </span>            :    * all rows.
<span class="lineNum">     306 </span>            :    * The actual row returned might not contain 'aY', but if not, it is guaranteed
<span class="lineNum">     307 </span>            :    * to be before any row which does contain 'aY'.
<span class="lineNum">     308 </span>            :    * aOverflowAbove is the maximum over all rows of -row.GetOverflowRect().y.
<span class="lineNum">     309 </span>            :    * To find all rows that intersect the vertical interval aY/aYMost, call
<span class="lineNum">     310 </span>            :    * GetFirstRowContaining(aY, &amp;overflowAbove), and then iterate through all
<span class="lineNum">     311 </span>            :    * rows until reaching a row where row-&gt;GetRect().y - overflowAbove &gt;= aYMost.
<span class="lineNum">     312 </span>            :    * That row and all subsequent rows cannot intersect the interval.
<span class="lineNum">     313 </span>            :    */
<span class="lineNum">     314 </span>            :   nsIFrame* GetFirstRowContaining(nscoord aY, nscoord* aOverflowAbove);
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :   /**
<span class="lineNum">     317 </span>            :    * Set up the row cursor. After this, call AppendFrame for every
<span class="lineNum">     318 </span>            :    * child frame in sibling order. Ensure that the child frame y and YMost values
<span class="lineNum">     319 </span>            :    * form non-decreasing sequences (should always be true for table rows);
<span class="lineNum">     320 </span>            :    * if this is violated, call ClearRowCursor(). If we return nullptr, then we
<span class="lineNum">     321 </span>            :    * decided not to use a cursor or we already have one set up.
<span class="lineNum">     322 </span>            :    */
<a name="323"><span class="lineNum">     323 </span>            :   FrameCursorData* SetupRowCursor();</a>
<span class="lineNum">     324 </span>            : 
<a name="325"><span class="lineNum">     325 </span><span class="lineNoCov">          0 :   virtual nsILineIterator* GetLineIterator() override { return this; }</span></a>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   virtual bool IsFrameOfType(uint32_t aFlags) const override</span>
<span class="lineNum">     328 </span>            :   {
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     return nsContainerFrame::IsFrameOfType(aFlags &amp; ~(nsIFrame::eTablePart));</span>
<span class="lineNum">     330 </span>            :   }
<span class="lineNum">     331 </span>            : 
<a name="332"><span class="lineNum">     332 </span>            :   virtual void InvalidateFrame(uint32_t aDisplayItemKey = 0) override;</a>
<span class="lineNum">     333 </span>            :   virtual void InvalidateFrameWithRect(const nsRect&amp; aRect, uint32_t aDisplayItemKey = 0) override;
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   virtual void InvalidateFrameForRemoval() override { InvalidateFrameSubtree(); }</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : protected:
<span class="lineNum">     337 </span>            :   explicit nsTableRowGroupFrame(nsStyleContext* aContext);
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   void InitChildReflowInput(nsPresContext&amp;     aPresContext,
<span class="lineNum">     340 </span>            :                             bool               aBorderCollapse,
<span class="lineNum">     341 </span>            :                             ReflowInput&amp; aReflowInput);
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   virtual LogicalSides GetLogicalSkipSides(const ReflowInput* aReflowInput = nullptr) const override;
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   void PlaceChild(nsPresContext*         aPresContext,
<span class="lineNum">     346 </span>            :                   TableRowGroupReflowInput&amp; aReflowInput,
<span class="lineNum">     347 </span>            :                   nsIFrame*              aKidFrame,
<span class="lineNum">     348 </span>            :                   mozilla::WritingMode   aWM,
<span class="lineNum">     349 </span>            :                   const mozilla::LogicalPoint&amp; aKidPosition,
<span class="lineNum">     350 </span>            :                   const nsSize&amp;          aContainerSize,
<span class="lineNum">     351 </span>            :                   ReflowOutput&amp;   aDesiredSize,
<span class="lineNum">     352 </span>            :                   const nsRect&amp;          aOriginalKidRect,
<span class="lineNum">     353 </span>            :                   const nsRect&amp;          aOriginalKidVisualOverflow);
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :   void CalculateRowBSizes(nsPresContext*           aPresContext,
<span class="lineNum">     356 </span>            :                           ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     357 </span>            :                           const ReflowInput&amp; aReflowInput);
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   void DidResizeRows(ReflowOutput&amp; aDesiredSize);
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   void SlideChild(TableRowGroupReflowInput&amp; aReflowInput,
<span class="lineNum">     362 </span>            :                   nsIFrame*              aKidFrame);
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   /**
<span class="lineNum">     365 </span>            :    * Reflow the frames we've already created
<span class="lineNum">     366 </span>            :    *
<span class="lineNum">     367 </span>            :    * @param   aPresContext presentation context to use
<span class="lineNum">     368 </span>            :    * @param   aReflowInput current inline state
<span class="lineNum">     369 </span>            :    */
<span class="lineNum">     370 </span>            :   void ReflowChildren(nsPresContext*         aPresContext,
<span class="lineNum">     371 </span>            :                       ReflowOutput&amp;   aDesiredSize,
<span class="lineNum">     372 </span>            :                       TableRowGroupReflowInput&amp; aReflowInput,
<span class="lineNum">     373 </span>            :                       nsReflowStatus&amp;        aStatus,
<span class="lineNum">     374 </span>            :                       bool*                aPageBreakBeforeEnd = nullptr);
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   nsresult SplitRowGroup(nsPresContext*           aPresContext,
<span class="lineNum">     377 </span>            :                          ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     378 </span>            :                          const ReflowInput&amp; aReflowInput,
<span class="lineNum">     379 </span>            :                          nsTableFrame*            aTableFrame,
<span class="lineNum">     380 </span>            :                          nsReflowStatus&amp;          aStatus,
<span class="lineNum">     381 </span>            :                          bool                     aRowForcedPageBreak);
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   void SplitSpanningCells(nsPresContext&amp;           aPresContext,
<span class="lineNum">     384 </span>            :                           const ReflowInput&amp; aReflowInput,
<span class="lineNum">     385 </span>            :                           nsTableFrame&amp;            aTableFrame,
<span class="lineNum">     386 </span>            :                           nsTableRowFrame&amp;         aFirstRow,
<span class="lineNum">     387 </span>            :                           nsTableRowFrame&amp;         aLastRow,
<span class="lineNum">     388 </span>            :                           bool                     aFirstRowIsTopOfPage,
<span class="lineNum">     389 </span>            :                           nscoord                  aSpanningRowBottom,
<span class="lineNum">     390 </span>            :                           nsTableRowFrame*&amp;        aContRowFrame,
<span class="lineNum">     391 </span>            :                           nsTableRowFrame*&amp;        aFirstTruncatedRow,
<span class="lineNum">     392 </span>            :                           nscoord&amp;                 aDesiredHeight);
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   void CreateContinuingRowFrame(nsPresContext&amp; aPresContext,
<span class="lineNum">     395 </span>            :                                 nsIFrame&amp;      aRowFrame,
<span class="lineNum">     396 </span>            :                                 nsIFrame**     aContRowFrame);
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   bool IsSimpleRowFrame(nsTableFrame* aTableFrame,
<span class="lineNum">     399 </span>            :                         nsTableRowFrame* aRowFrame);
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :   void GetNextRowSibling(nsIFrame** aRowFrame);
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :   void UndoContinuedRow(nsPresContext*   aPresContext,
<span class="lineNum">     404 </span>            :                         nsTableRowFrame* aRow);
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : private:
<span class="lineNum">     407 </span>            :   // border widths in pixels in the collapsing border model
<span class="lineNum">     408 </span>            :   BCPixelSize mIEndContBorderWidth;
<span class="lineNum">     409 </span>            :   BCPixelSize mBEndContBorderWidth;
<span class="lineNum">     410 </span>            :   BCPixelSize mIStartContBorderWidth;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : public:
<span class="lineNum">     413 </span>            :   bool IsRepeatable() const;
<span class="lineNum">     414 </span>            :   void SetRepeatable(bool aRepeatable);
<span class="lineNum">     415 </span>            :   bool HasStyleBSize() const;
<span class="lineNum">     416 </span>            :   void SetHasStyleBSize(bool aValue);
<span class="lineNum">     417 </span>            :   bool HasInternalBreakBefore() const;
<span class="lineNum">     418 </span>            :   bool HasInternalBreakAfter() const;
<span class="lineNum">     419 </span>            : };
<a name="420"><span class="lineNum">     420 </span>            : </a>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineNoCov">          0 : inline bool nsTableRowGroupFrame::IsRepeatable() const</span>
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   return HasAnyStateBits(NS_ROWGROUP_REPEATABLE);</span>
<a name="425"><span class="lineNum">     425 </span>            : }</a>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span><span class="lineNoCov">          0 : inline void nsTableRowGroupFrame::SetRepeatable(bool aRepeatable)</span>
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   if (aRepeatable) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     AddStateBits(NS_ROWGROUP_REPEATABLE);</span>
<span class="lineNum">     431 </span>            :   } else {
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     RemoveStateBits(NS_ROWGROUP_REPEATABLE);</span>
<span class="lineNum">     433 </span>            :   }
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 : inline bool nsTableRowGroupFrame::HasStyleBSize() const</span>
<span class="lineNum">     437 </span>            : {
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   return HasAnyStateBits(NS_ROWGROUP_HAS_STYLE_BSIZE);</span>
<a name="439"><span class="lineNum">     439 </span>            : }</a>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : inline void nsTableRowGroupFrame::SetHasStyleBSize(bool aValue)</span>
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   if (aValue) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     AddStateBits(NS_ROWGROUP_HAS_STYLE_BSIZE);</span>
<span class="lineNum">     445 </span>            :   } else {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     RemoveStateBits(NS_ROWGROUP_HAS_STYLE_BSIZE);</span>
<span class="lineNum">     447 </span>            :   }
<span class="lineNum">     448 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : inline void
<span class="lineNum">     451 </span>            : nsTableRowGroupFrame::GetContinuousBCBorderWidth(mozilla::WritingMode aWM,
<span class="lineNum">     452 </span>            :                                                  mozilla::LogicalMargin&amp; aBorder)
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span>            :   int32_t aPixelsToTwips = nsPresContext::AppUnitsPerCSSPixel();
<span class="lineNum">     455 </span>            :   aBorder.IEnd(aWM) = BC_BORDER_START_HALF_COORD(aPixelsToTwips,
<span class="lineNum">     456 </span>            :                                                  mIEndContBorderWidth);
<span class="lineNum">     457 </span>            :   aBorder.BEnd(aWM) = BC_BORDER_START_HALF_COORD(aPixelsToTwips,
<span class="lineNum">     458 </span>            :                                                  mBEndContBorderWidth);
<span class="lineNum">     459 </span>            :   aBorder.IStart(aWM) = BC_BORDER_END_HALF_COORD(aPixelsToTwips,
<span class="lineNum">     460 </span>            :                                                  mIStartContBorderWidth);
<span class="lineNum">     461 </span>            : }
<span class="lineNum">     462 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

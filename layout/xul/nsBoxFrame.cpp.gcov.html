<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/xul/nsBoxFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/xul</a> - nsBoxFrame.cpp<span style="font-size: 80%;"> (source / <a href="nsBoxFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">457</td>
            <td class="headerCovTableEntry">640</td>
            <td class="headerCovTableEntryLo">71.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntryLo">69.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=2 sw=2 et tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : //
<span class="lineNum">       8 </span>            : // Eric Vaughan
<span class="lineNum">       9 </span>            : // Netscape Communications
<span class="lineNum">      10 </span>            : //
<span class="lineNum">      11 </span>            : // See documentation in associated header file
<span class="lineNum">      12 </span>            : //
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : // How boxes layout
<span class="lineNum">      15 </span>            : // ----------------
<span class="lineNum">      16 </span>            : // Boxes layout a bit differently than html. html does a bottom up layout. Where boxes do a top down.
<span class="lineNum">      17 </span>            : // 1) First thing a box does it goes out and askes each child for its min, max, and preferred sizes.
<span class="lineNum">      18 </span>            : // 2) It then adds them up to determine its size.
<span class="lineNum">      19 </span>            : // 3) If the box was asked to layout it self intrinically it will layout its children at their preferred size
<span class="lineNum">      20 </span>            : //    otherwise it will layout the child at the size it was told to. It will squeeze or stretch its children if
<span class="lineNum">      21 </span>            : //    Necessary.
<span class="lineNum">      22 </span>            : //
<span class="lineNum">      23 </span>            : // However there is a catch. Some html components like block frames can not determine their preferred size.
<span class="lineNum">      24 </span>            : // this is their size if they were laid out intrinsically. So the box will flow the child to determine this can
<span class="lineNum">      25 </span>            : // cache the value.
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // Boxes and Incremental Reflow
<span class="lineNum">      28 </span>            : // ----------------------------
<span class="lineNum">      29 </span>            : // Boxes layout out top down by adding up their children's min, max, and preferred sizes. Only problem is if a incremental
<span class="lineNum">      30 </span>            : // reflow occurs. The preferred size of a child deep in the hierarchy could change. And this could change
<span class="lineNum">      31 </span>            : // any number of syblings around the box. Basically any children in the reflow chain must have their caches cleared
<span class="lineNum">      32 </span>            : // so when asked for there current size they can relayout themselves.
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;nsBoxFrame.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;nsBoxLayoutState.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;mozilla/dom/Touch.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;mozilla/Move.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;nsStyleContext.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;nsPlaceholderFrame.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;nsNameSpaceManager.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;nsIContent.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;nsHTMLParts.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;nsViewManager.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;nsView.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;nsCSSRendering.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;nsBoxLayout.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;nsSprocketLayout.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;nsIScrollableFrame.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;nsWidgetsCID.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;nsCSSAnonBoxes.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;nsContainerFrame.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;nsIDOMElement.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nsITheme.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;nsTransform2D.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;mozilla/EventStateManager.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;nsIDOMEvent.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;nsDisplayList.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;nsThemeConstants.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;nsSliderFrame.h&quot;
<span class="lineNum">      70 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : // Needed for Print Preview
<span class="lineNum">      73 </span>            : #include &quot;nsIURI.h&quot;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : #include &quot;mozilla/TouchEvents.h&quot;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : using namespace mozilla;
<span class="lineNum">      78 </span>            : using namespace mozilla::dom;
<span class="lineNum">      79 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : //define DEBUG_REDRAW
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : #define DEBUG_SPRING_SIZE 8
<span class="lineNum">      84 </span>            : #define DEBUG_BORDER_SIZE 2
<span class="lineNum">      85 </span>            : #define COIL_SIZE 8
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : //#define TEST_SANITY
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : #ifdef DEBUG_rods
<span class="lineNum">      90 </span>            : //#define DO_NOISY_REFLOW
<span class="lineNum">      91 </span>            : #endif
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">      94 </span>            : bool nsBoxFrame::gDebug = false;
<span class="lineNum">      95 </span>            : nsIFrame* nsBoxFrame::mDebugChild = nullptr;
<span class="lineNum">      96 </span>            : #endif
<a name="97"><span class="lineNum">      97 </span>            : </a>
<span class="lineNum">      98 </span>            : nsIFrame*
<span class="lineNum">      99 </span><span class="lineNoCov">          0 : NS_NewBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, bool aIsRoot, nsBoxLayout* aLayoutManager)</span>
<span class="lineNum">     100 </span>            : {
<span class="lineNum">     101 </span>            :   return new (aPresShell) nsBoxFrame(aContext, nsBoxFrame::kClassID,
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                                      aIsRoot, aLayoutManager);</span>
<span class="lineNum">     103 </span>            : }
<a name="104"><span class="lineNum">     104 </span>            : </a>
<span class="lineNum">     105 </span>            : nsIFrame*
<span class="lineNum">     106 </span><span class="lineCov">        105 : NS_NewBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)</span>
<span class="lineNum">     107 </span>            : {
<span class="lineNum">     108 </span><span class="lineCov">        105 :   return new (aPresShell) nsBoxFrame(aContext);</span>
<a name="109"><span class="lineNum">     109 </span>            : }</a>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span><span class="lineCov">        105 : NS_IMPL_FRAMEARENA_HELPERS(nsBoxFrame)</span>
<a name="112"><span class="lineNum">     112 </span>            : </a>
<span class="lineNum">     113 </span>            : #ifdef DEBUG
<span class="lineNum">     114 </span><span class="lineCov">       5714 : NS_QUERYFRAME_HEAD(nsBoxFrame)</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsBoxFrame)</span>
<span class="lineNum">     116 </span><span class="lineCov">       5714 : NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)</span>
<a name="117"><span class="lineNum">     117 </span>            : #endif</a>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineCov">        232 : nsBoxFrame::nsBoxFrame(nsStyleContext* aContext,</span>
<span class="lineNum">     120 </span>            :                        ClassID aID,
<span class="lineNum">     121 </span>            :                        bool aIsRoot,
<span class="lineNum">     122 </span><span class="lineCov">        232 :                        nsBoxLayout* aLayoutManager)</span>
<span class="lineNum">     123 </span>            :   : nsContainerFrame(aContext, aID)
<span class="lineNum">     124 </span>            :   , mFlex(0)
<span class="lineNum">     125 </span><span class="lineCov">        232 :   , mAscent(0)</span>
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span><span class="lineCov">        232 :   mState |= NS_STATE_IS_HORIZONTAL;</span>
<span class="lineNum">     128 </span><span class="lineCov">        232 :   mState |= NS_STATE_AUTO_STRETCH;</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span><span class="lineCov">        232 :   if (aIsRoot)</span>
<span class="lineNum">     131 </span><span class="lineCov">          2 :      mState |= NS_STATE_IS_ROOT;</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineCov">        232 :   mValign = vAlign_Top;</span>
<span class="lineNum">     134 </span><span class="lineCov">        232 :   mHalign = hAlign_Left;</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :   // if no layout manager specified us the static sprocket layout
<span class="lineNum">     137 </span><span class="lineCov">        464 :   nsCOMPtr&lt;nsBoxLayout&gt; layout = aLayoutManager;</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineCov">        232 :   if (layout == nullptr) {</span>
<span class="lineNum">     140 </span><span class="lineCov">        232 :     NS_NewSprocketLayout(layout);</span>
<span class="lineNum">     141 </span>            :   }
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">        232 :   SetXULLayoutManager(layout);</span>
<a name="144"><span class="lineNum">     144 </span><span class="lineCov">        232 : }</span></a>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineCov">         56 : nsBoxFrame::~nsBoxFrame()</span>
<span class="lineNum">     147 </span>            : {
<span class="lineNum">     148 </span><span class="lineCov">         56 : }</span>
<a name="149"><span class="lineNum">     149 </span>            : </a>
<span class="lineNum">     150 </span>            : void
<span class="lineNum">     151 </span><span class="lineCov">        232 : nsBoxFrame::SetInitialChildList(ChildListID     aListID,</span>
<span class="lineNum">     152 </span>            :                                 nsFrameList&amp;    aChildList)
<span class="lineNum">     153 </span>            : {
<span class="lineNum">     154 </span><span class="lineCov">        232 :   nsContainerFrame::SetInitialChildList(aListID, aChildList);</span>
<span class="lineNum">     155 </span><span class="lineCov">        232 :   if (aListID == kPrincipalList) {</span>
<span class="lineNum">     156 </span>            :     // initialize our list of infos.
<span class="lineNum">     157 </span><span class="lineCov">        464 :     nsBoxLayoutState state(PresContext());</span>
<span class="lineNum">     158 </span><span class="lineCov">        232 :     CheckBoxOrder();</span>
<span class="lineNum">     159 </span><span class="lineCov">        232 :     if (mLayoutManager)</span>
<span class="lineNum">     160 </span><span class="lineCov">        224 :       mLayoutManager-&gt;ChildrenSet(this, state, mFrames.FirstChild());</span>
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span><span class="lineCov">        232 : }</span>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<span class="lineNum">     164 </span>            : /* virtual */ void
<span class="lineNum">     165 </span><span class="lineCov">        623 : nsBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)</span>
<span class="lineNum">     166 </span>            : {
<span class="lineNum">     167 </span><span class="lineCov">        623 :   nsContainerFrame::DidSetStyleContext(aOldStyleContext);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :   // The values that CacheAttributes() computes depend on our style,
<span class="lineNum">     170 </span>            :   // so we need to recompute them here...
<span class="lineNum">     171 </span><span class="lineCov">        623 :   CacheAttributes();</span>
<span class="lineNum">     172 </span><span class="lineCov">        623 : }</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /**
<span class="lineNum">     175 </span>            :  * Initialize us. This is a good time to get the alignment of the box
<a name="176"><span class="lineNum">     176 </span>            :  */</a>
<span class="lineNum">     177 </span>            : void
<span class="lineNum">     178 </span><span class="lineCov">        232 : nsBoxFrame::Init(nsIContent*       aContent,</span>
<span class="lineNum">     179 </span>            :                  nsContainerFrame* aParent,
<span class="lineNum">     180 </span>            :                  nsIFrame*         aPrevInFlow)
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span><span class="lineCov">        232 :   nsContainerFrame::Init(aContent, aParent, aPrevInFlow);</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineCov">        232 :   if (GetStateBits() &amp; NS_FRAME_FONT_INFLATION_CONTAINER) {</span>
<span class="lineNum">     185 </span><span class="lineCov">        226 :     AddStateBits(NS_FRAME_FONT_INFLATION_FLOW_ROOT);</span>
<span class="lineNum">     186 </span>            :   }
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineCov">        232 :   MarkIntrinsicISizesDirty();</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">        232 :   CacheAttributes();</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     193 </span>            :     // if we are root and this
<span class="lineNum">     194 </span>            :   if (mState &amp; NS_STATE_IS_ROOT) {
<span class="lineNum">     195 </span>            :     GetDebugPref();
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span>            : #endif
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineCov">        232 :   UpdateMouseThrough();</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   // register access key
<span class="lineNum">     202 </span><span class="lineCov">        232 :   RegUnregAccessKey(true);</span>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">        232 : }</span></a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineCov">        200 : void nsBoxFrame::UpdateMouseThrough()</span>
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span><span class="lineCov">        200 :   if (mContent) {</span>
<span class="lineNum">     208 </span>            :     static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     209 </span>            :       {&amp;nsGkAtoms::never, &amp;nsGkAtoms::always, nullptr};
<span class="lineNum">     210 </span><span class="lineCov">        400 :     switch (mContent-&gt;FindAttrValueIn(kNameSpaceID_None,</span>
<span class="lineNum">     211 </span><span class="lineCov">        200 :               nsGkAtoms::mousethrough, strings, eCaseMatters)) {</span>
<span class="lineNum">     212 </span><span class="lineCov">          1 :       case 0: AddStateBits(NS_FRAME_MOUSE_THROUGH_NEVER); break;</span>
<span class="lineNum">     213 </span><span class="lineCov">          3 :       case 1: AddStateBits(NS_FRAME_MOUSE_THROUGH_ALWAYS); break;</span>
<span class="lineNum">     214 </span>            :       case 2: {
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         RemoveStateBits(NS_FRAME_MOUSE_THROUGH_ALWAYS);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         RemoveStateBits(NS_FRAME_MOUSE_THROUGH_NEVER);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     218 </span>            :       }
<span class="lineNum">     219 </span>            :     }
<span class="lineNum">     220 </span>            :   }
<span class="lineNum">     221 </span><span class="lineCov">        200 : }</span>
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : void
<span class="lineNum">     224 </span><span class="lineCov">        855 : nsBoxFrame::CacheAttributes()</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :   /*
<span class="lineNum">     227 </span>            :   printf(&quot;Caching: &quot;);
<span class="lineNum">     228 </span>            :   XULDumpBox(stdout);
<span class="lineNum">     229 </span>            :   printf(&quot;\n&quot;);
<span class="lineNum">     230 </span>            :    */
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineCov">        855 :   mValign = vAlign_Top;</span>
<span class="lineNum">     233 </span><span class="lineCov">        855 :   mHalign = hAlign_Left;</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineCov">        855 :   bool orient = false;</span>
<span class="lineNum">     236 </span><span class="lineCov">        855 :   GetInitialOrientation(orient);</span>
<span class="lineNum">     237 </span><span class="lineCov">        855 :   if (orient)</span>
<span class="lineNum">     238 </span><span class="lineCov">        572 :     mState |= NS_STATE_IS_HORIZONTAL;</span>
<span class="lineNum">     239 </span>            :   else
<span class="lineNum">     240 </span><span class="lineCov">        283 :     mState &amp;= ~NS_STATE_IS_HORIZONTAL;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineCov">        855 :   bool normal = true;</span>
<span class="lineNum">     243 </span><span class="lineCov">        855 :   GetInitialDirection(normal);</span>
<span class="lineNum">     244 </span><span class="lineCov">        855 :   if (normal)</span>
<span class="lineNum">     245 </span><span class="lineCov">        855 :     mState |= NS_STATE_IS_DIRECTION_NORMAL;</span>
<span class="lineNum">     246 </span>            :   else
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     mState &amp;= ~NS_STATE_IS_DIRECTION_NORMAL;</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineCov">        855 :   GetInitialVAlignment(mValign);</span>
<span class="lineNum">     250 </span><span class="lineCov">        855 :   GetInitialHAlignment(mHalign);</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineCov">        855 :   bool equalSize = false;</span>
<span class="lineNum">     253 </span><span class="lineCov">        855 :   GetInitialEqualSize(equalSize);</span>
<span class="lineNum">     254 </span><span class="lineCov">        855 :   if (equalSize)</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         mState |= NS_STATE_EQUAL_SIZE;</span>
<span class="lineNum">     256 </span>            :     else
<span class="lineNum">     257 </span><span class="lineCov">        855 :         mState &amp;= ~NS_STATE_EQUAL_SIZE;</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineCov">        855 :   bool autostretch = !!(mState &amp; NS_STATE_AUTO_STRETCH);</span>
<span class="lineNum">     260 </span><span class="lineCov">        855 :   GetInitialAutoStretch(autostretch);</span>
<span class="lineNum">     261 </span><span class="lineCov">        855 :   if (autostretch)</span>
<span class="lineNum">     262 </span><span class="lineCov">        611 :         mState |= NS_STATE_AUTO_STRETCH;</span>
<span class="lineNum">     263 </span>            :      else
<span class="lineNum">     264 </span><span class="lineCov">        244 :         mState &amp;= ~NS_STATE_AUTO_STRETCH;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     268 </span>            :   bool debug = mState &amp; NS_STATE_SET_TO_DEBUG;
<span class="lineNum">     269 </span>            :   bool debugSet = GetInitialDebug(debug);
<span class="lineNum">     270 </span>            :   if (debugSet) {
<span class="lineNum">     271 </span>            :         mState |= NS_STATE_DEBUG_WAS_SET;
<span class="lineNum">     272 </span>            :         if (debug)
<span class="lineNum">     273 </span>            :             mState |= NS_STATE_SET_TO_DEBUG;
<span class="lineNum">     274 </span>            :         else
<span class="lineNum">     275 </span>            :             mState &amp;= ~NS_STATE_SET_TO_DEBUG;
<span class="lineNum">     276 </span>            :   } else {
<span class="lineNum">     277 </span>            :         mState &amp;= ~NS_STATE_DEBUG_WAS_SET;
<span class="lineNum">     278 </span>            :   }
<span class="lineNum">     279 </span>            : #endif
<span class="lineNum">     280 </span><span class="lineCov">        855 : }</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     283 </span>            : bool
<span class="lineNum">     284 </span>            : nsBoxFrame::GetInitialDebug(bool&amp; aDebug)
<span class="lineNum">     285 </span>            : {
<span class="lineNum">     286 </span>            :   if (!GetContent())
<span class="lineNum">     287 </span>            :     return false;
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :   static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     290 </span>            :     {&amp;nsGkAtoms::_false, &amp;nsGkAtoms::_true, nullptr};
<span class="lineNum">     291 </span>            :   int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None,
<span class="lineNum">     292 </span>            :       nsGkAtoms::debug, strings, eCaseMatters);
<span class="lineNum">     293 </span>            :   if (index &gt;= 0) {
<span class="lineNum">     294 </span>            :     aDebug = index == 1;
<span class="lineNum">     295 </span>            :     return true;
<span class="lineNum">     296 </span>            :   }
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :   return false;
<span class="lineNum">     299 </span>            : }
<span class="lineNum">     300 </span>            : #endif
<a name="301"><span class="lineNum">     301 </span>            : </a>
<span class="lineNum">     302 </span>            : bool
<span class="lineNum">     303 </span><span class="lineCov">        856 : nsBoxFrame::GetInitialHAlignment(nsBoxFrame::Halignment&amp; aHalign)</span>
<span class="lineNum">     304 </span>            : {
<span class="lineNum">     305 </span><span class="lineCov">        856 :   if (!GetContent())</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :   // XXXdwh Everything inside this if statement is deprecated code.
<span class="lineNum">     309 </span>            :   static nsIContent::AttrValuesArray alignStrings[] =
<span class="lineNum">     310 </span>            :     {&amp;nsGkAtoms::left, &amp;nsGkAtoms::right, nullptr};
<span class="lineNum">     311 </span>            :   static const Halignment alignValues[] = {hAlign_Left, hAlign_Right};
<span class="lineNum">     312 </span><span class="lineCov">       1712 :   int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,</span>
<span class="lineNum">     313 </span><span class="lineCov">       1712 :       alignStrings, eCaseMatters);</span>
<span class="lineNum">     314 </span><span class="lineCov">        856 :   if (index &gt;= 0) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     aHalign = alignValues[index];</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :   // Now that the deprecated stuff is out of the way, we move on to check the appropriate
<span class="lineNum">     320 </span>            :   // attribute.  For horizontal boxes, we are checking the PACK attribute.  For vertical boxes
<span class="lineNum">     321 </span>            :   // we are checking the ALIGN attribute.
<span class="lineNum">     322 </span><span class="lineCov">        856 :   nsIAtom* attrName = IsXULHorizontal() ? nsGkAtoms::pack : nsGkAtoms::align;</span>
<span class="lineNum">     323 </span>            :   static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     324 </span>            :     {&amp;nsGkAtoms::_empty, &amp;nsGkAtoms::start, &amp;nsGkAtoms::center, &amp;nsGkAtoms::end, nullptr};
<span class="lineNum">     325 </span>            :   static const Halignment values[] =
<span class="lineNum">     326 </span>            :     {hAlign_Left/*not used*/, hAlign_Left, hAlign_Center, hAlign_Right};
<span class="lineNum">     327 </span><span class="lineCov">        856 :   index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, attrName,</span>
<span class="lineNum">     328 </span><span class="lineCov">        856 :       strings, eCaseMatters);</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">        856 :   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {</span>
<span class="lineNum">     331 </span>            :     // The attr was present but had a nonsensical value. Revert to the default.
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     333 </span>            :   }
<span class="lineNum">     334 </span><span class="lineCov">        856 :   if (index &gt; 0) {</span>
<span class="lineNum">     335 </span><span class="lineCov">         19 :     aHalign = values[index];</span>
<span class="lineNum">     336 </span><span class="lineCov">         19 :     return true;</span>
<span class="lineNum">     337 </span>            :   }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   // Now that we've checked for the attribute it's time to check CSS.  For
<span class="lineNum">     340 </span>            :   // horizontal boxes we're checking PACK.  For vertical boxes we are checking
<span class="lineNum">     341 </span>            :   // ALIGN.
<span class="lineNum">     342 </span><span class="lineCov">        837 :   const nsStyleXUL* boxInfo = StyleXUL();</span>
<span class="lineNum">     343 </span><span class="lineCov">        837 :   if (IsXULHorizontal()) {</span>
<span class="lineNum">     344 </span><span class="lineCov">        566 :     switch (boxInfo-&gt;mBoxPack) {</span>
<span class="lineNum">     345 </span>            :       case StyleBoxPack::Start:
<span class="lineNum">     346 </span><span class="lineCov">        439 :         aHalign = nsBoxFrame::hAlign_Left;</span>
<span class="lineNum">     347 </span><span class="lineCov">        439 :         return true;</span>
<span class="lineNum">     348 </span>            :       case StyleBoxPack::Center:
<span class="lineNum">     349 </span><span class="lineCov">        127 :         aHalign = nsBoxFrame::hAlign_Center;</span>
<span class="lineNum">     350 </span><span class="lineCov">        127 :         return true;</span>
<span class="lineNum">     351 </span>            :       case StyleBoxPack::End:
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         aHalign = nsBoxFrame::hAlign_Right;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     354 </span>            :       default: // Nonsensical value. Just bail.
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span>            :   }
<span class="lineNum">     358 </span>            :   else {
<span class="lineNum">     359 </span><span class="lineCov">        271 :     switch (boxInfo-&gt;mBoxAlign) {</span>
<span class="lineNum">     360 </span>            :       case StyleBoxAlign::Start:
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         aHalign = nsBoxFrame::hAlign_Left;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     363 </span>            :       case StyleBoxAlign::Center:
<span class="lineNum">     364 </span><span class="lineCov">          3 :         aHalign = nsBoxFrame::hAlign_Center;</span>
<span class="lineNum">     365 </span><span class="lineCov">          3 :         return true;</span>
<span class="lineNum">     366 </span>            :       case StyleBoxAlign::End:
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         aHalign = nsBoxFrame::hAlign_Right;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     369 </span>            :       default: // Nonsensical value. Just bail.
<span class="lineNum">     370 </span><span class="lineCov">        268 :         return false;</span>
<span class="lineNum">     371 </span>            :     }
<span class="lineNum">     372 </span>            :   }
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   return false;
<span class="lineNum">     375 </span>            : }
<a name="376"><span class="lineNum">     376 </span>            : </a>
<span class="lineNum">     377 </span>            : bool
<span class="lineNum">     378 </span><span class="lineCov">        856 : nsBoxFrame::GetInitialVAlignment(nsBoxFrame::Valignment&amp; aValign)</span>
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span><span class="lineCov">        856 :   if (!GetContent())</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   static nsIContent::AttrValuesArray valignStrings[] =
<span class="lineNum">     384 </span>            :     {&amp;nsGkAtoms::top, &amp;nsGkAtoms::baseline, &amp;nsGkAtoms::middle, &amp;nsGkAtoms::bottom, nullptr};
<span class="lineNum">     385 </span>            :   static const Valignment valignValues[] =
<span class="lineNum">     386 </span>            :     {vAlign_Top, vAlign_BaseLine, vAlign_Middle, vAlign_Bottom};
<span class="lineNum">     387 </span><span class="lineCov">       1712 :   int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::valign,</span>
<span class="lineNum">     388 </span><span class="lineCov">       1712 :       valignStrings, eCaseMatters);</span>
<span class="lineNum">     389 </span><span class="lineCov">        856 :   if (index &gt;= 0) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     aValign = valignValues[index];</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     392 </span>            :   }
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // Now that the deprecated stuff is out of the way, we move on to check the appropriate
<span class="lineNum">     395 </span>            :   // attribute.  For horizontal boxes, we are checking the ALIGN attribute.  For vertical boxes
<span class="lineNum">     396 </span>            :   // we are checking the PACK attribute.
<span class="lineNum">     397 </span><span class="lineCov">        856 :   nsIAtom* attrName = IsXULHorizontal() ? nsGkAtoms::align : nsGkAtoms::pack;</span>
<span class="lineNum">     398 </span>            :   static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     399 </span>            :     {&amp;nsGkAtoms::_empty, &amp;nsGkAtoms::start, &amp;nsGkAtoms::center,
<span class="lineNum">     400 </span>            :      &amp;nsGkAtoms::baseline, &amp;nsGkAtoms::end, nullptr};
<span class="lineNum">     401 </span>            :   static const Valignment values[] =
<span class="lineNum">     402 </span>            :     {vAlign_Top/*not used*/, vAlign_Top, vAlign_Middle, vAlign_BaseLine, vAlign_Bottom};
<span class="lineNum">     403 </span><span class="lineCov">        856 :   index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, attrName,</span>
<span class="lineNum">     404 </span><span class="lineCov">        856 :       strings, eCaseMatters);</span>
<span class="lineNum">     405 </span><span class="lineCov">        856 :   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {</span>
<span class="lineNum">     406 </span>            :     // The attr was present but had a nonsensical value. Revert to the default.
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     408 </span>            :   }
<span class="lineNum">     409 </span><span class="lineCov">        856 :   if (index &gt; 0) {</span>
<span class="lineNum">     410 </span><span class="lineCov">         54 :     aValign = values[index];</span>
<span class="lineNum">     411 </span><span class="lineCov">         54 :     return true;</span>
<span class="lineNum">     412 </span>            :   }
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :   // Now that we've checked for the attribute it's time to check CSS.  For
<span class="lineNum">     415 </span>            :   // horizontal boxes we're checking ALIGN.  For vertical boxes we are checking
<span class="lineNum">     416 </span>            :   // PACK.
<span class="lineNum">     417 </span><span class="lineCov">        802 :   const nsStyleXUL* boxInfo = StyleXUL();</span>
<span class="lineNum">     418 </span><span class="lineCov">        802 :   if (IsXULHorizontal()) {</span>
<span class="lineNum">     419 </span><span class="lineCov">        526 :     switch (boxInfo-&gt;mBoxAlign) {</span>
<span class="lineNum">     420 </span>            :       case StyleBoxAlign::Start:
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         aValign = nsBoxFrame::vAlign_Top;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     423 </span>            :       case StyleBoxAlign::Center:
<span class="lineNum">     424 </span><span class="lineCov">        180 :         aValign = nsBoxFrame::vAlign_Middle;</span>
<span class="lineNum">     425 </span><span class="lineCov">        180 :         return true;</span>
<span class="lineNum">     426 </span>            :       case StyleBoxAlign::Baseline:
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         aValign = nsBoxFrame::vAlign_BaseLine;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     429 </span>            :       case StyleBoxAlign::End:
<span class="lineNum">     430 </span><span class="lineCov">          2 :         aValign = nsBoxFrame::vAlign_Bottom;</span>
<span class="lineNum">     431 </span><span class="lineCov">          2 :         return true;</span>
<span class="lineNum">     432 </span>            :       default: // Nonsensical value. Just bail.
<span class="lineNum">     433 </span><span class="lineCov">        344 :         return false;</span>
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span>            :   }
<span class="lineNum">     436 </span>            :   else {
<span class="lineNum">     437 </span><span class="lineCov">        276 :     switch (boxInfo-&gt;mBoxPack) {</span>
<span class="lineNum">     438 </span>            :       case StyleBoxPack::Start:
<span class="lineNum">     439 </span><span class="lineCov">        273 :         aValign = nsBoxFrame::vAlign_Top;</span>
<span class="lineNum">     440 </span><span class="lineCov">        273 :         return true;</span>
<span class="lineNum">     441 </span>            :       case StyleBoxPack::Center:
<span class="lineNum">     442 </span><span class="lineCov">          3 :         aValign = nsBoxFrame::vAlign_Middle;</span>
<span class="lineNum">     443 </span><span class="lineCov">          3 :         return true;</span>
<span class="lineNum">     444 </span>            :       case StyleBoxPack::End:
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         aValign = nsBoxFrame::vAlign_Bottom;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     447 </span>            :       default: // Nonsensical value. Just bail.
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span>            :   }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   return false;
<span class="lineNum">     453 </span>            : }
<a name="454"><span class="lineNum">     454 </span>            : </a>
<span class="lineNum">     455 </span>            : void
<span class="lineNum">     456 </span><span class="lineCov">        853 : nsBoxFrame::GetInitialOrientation(bool&amp; aIsHorizontal)</span>
<span class="lineNum">     457 </span>            : {
<span class="lineNum">     458 </span>            :  // see if we are a vertical or horizontal box.
<span class="lineNum">     459 </span><span class="lineCov">        853 :   if (!GetContent())</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :   // Check the style system first.
<span class="lineNum">     463 </span><span class="lineCov">        853 :   const nsStyleXUL* boxInfo = StyleXUL();</span>
<span class="lineNum">     464 </span><span class="lineCov">        853 :   if (boxInfo-&gt;mBoxOrient == StyleBoxOrient::Horizontal) {</span>
<span class="lineNum">     465 </span><span class="lineCov">        590 :     aIsHorizontal = true;</span>
<span class="lineNum">     466 </span>            :   } else {
<span class="lineNum">     467 </span><span class="lineCov">        263 :     aIsHorizontal = false;</span>
<span class="lineNum">     468 </span>            :   }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :   // Now see if we have an attribute.  The attribute overrides
<span class="lineNum">     471 </span>            :   // the style system value.
<span class="lineNum">     472 </span>            :   static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     473 </span>            :     {&amp;nsGkAtoms::vertical, &amp;nsGkAtoms::horizontal, nullptr};
<span class="lineNum">     474 </span><span class="lineCov">       1706 :   int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::orient,</span>
<span class="lineNum">     475 </span><span class="lineCov">       1706 :       strings, eCaseMatters);</span>
<span class="lineNum">     476 </span><span class="lineCov">        853 :   if (index &gt;= 0) {</span>
<span class="lineNum">     477 </span><span class="lineCov">         86 :     aIsHorizontal = index == 1;</span>
<span class="lineNum">     478 </span>            :   }
<span class="lineNum">     479 </span>            : }
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : void
<span class="lineNum">     482 </span><span class="lineCov">        856 : nsBoxFrame::GetInitialDirection(bool&amp; aIsNormal)</span>
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span><span class="lineCov">        856 :   if (!GetContent())</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineCov">        856 :   if (IsXULHorizontal()) {</span>
<span class="lineNum">     488 </span>            :     // For horizontal boxes only, we initialize our value based off the CSS 'direction' property.
<span class="lineNum">     489 </span>            :     // This means that BiDI users will end up with horizontally inverted chrome.
<span class="lineNum">     490 </span><span class="lineCov">        573 :     aIsNormal = (StyleVisibility()-&gt;mDirection == NS_STYLE_DIRECTION_LTR); // If text runs RTL then so do we.</span>
<span class="lineNum">     491 </span>            :   }
<span class="lineNum">     492 </span>            :   else
<span class="lineNum">     493 </span><span class="lineCov">        283 :     aIsNormal = true; // Assume a normal direction in the vertical case.</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :   // Now check the style system to see if we should invert aIsNormal.
<span class="lineNum">     496 </span><span class="lineCov">        856 :   const nsStyleXUL* boxInfo = StyleXUL();</span>
<span class="lineNum">     497 </span><span class="lineCov">        856 :   if (boxInfo-&gt;mBoxDirection == StyleBoxDirection::Reverse) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     aIsNormal = !aIsNormal; // Invert our direction.</span>
<span class="lineNum">     499 </span>            :   }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :   // Now see if we have an attribute.  The attribute overrides
<span class="lineNum">     502 </span>            :   // the style system value.
<span class="lineNum">     503 </span><span class="lineCov">        856 :   if (IsXULHorizontal()) {</span>
<span class="lineNum">     504 </span>            :     static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     505 </span>            :       {&amp;nsGkAtoms::reverse, &amp;nsGkAtoms::ltr, &amp;nsGkAtoms::rtl, nullptr};
<span class="lineNum">     506 </span><span class="lineCov">       1146 :     int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,</span>
<span class="lineNum">     507 </span><span class="lineCov">       1146 :         strings, eCaseMatters);</span>
<span class="lineNum">     508 </span><span class="lineCov">        573 :     if (index &gt;= 0) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       bool values[] = {!aIsNormal, true, false};</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :       aIsNormal = values[index];</span>
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span><span class="lineCov">        283 :   } else if (GetContent()-&gt;AttrValueIs(kNameSpaceID_None, nsGkAtoms::dir,</span>
<span class="lineNum">     513 </span>            :                                        nsGkAtoms::reverse, eCaseMatters)) {
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     aIsNormal = !aIsNormal;</span>
<span class="lineNum">     515 </span>            :   }
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : /* Returns true if it was set.
<a name="519"><span class="lineNum">     519 </span>            :  */</a>
<span class="lineNum">     520 </span>            : bool
<span class="lineNum">     521 </span><span class="lineCov">        856 : nsBoxFrame::GetInitialEqualSize(bool&amp; aEqualSize)</span>
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span>            :  // see if we are a vertical or horizontal box.
<span class="lineNum">     524 </span><span class="lineCov">        856 :   if (!GetContent())</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :      return false;</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">        856 :   if (GetContent()-&gt;AttrValueIs(kNameSpaceID_None, nsGkAtoms::equalsize,</span>
<span class="lineNum">     528 </span>            :                            nsGkAtoms::always, eCaseMatters)) {
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     aEqualSize = true;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     531 </span>            :   }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineCov">        856 :   return false;</span>
<span class="lineNum">     534 </span>            : }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : /* Returns true if it was set.
<a name="537"><span class="lineNum">     537 </span>            :  */</a>
<span class="lineNum">     538 </span>            : bool
<span class="lineNum">     539 </span><span class="lineCov">        856 : nsBoxFrame::GetInitialAutoStretch(bool&amp; aStretch)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span><span class="lineCov">        856 :   if (!GetContent())</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :      return false;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :   // Check the align attribute.
<span class="lineNum">     545 </span>            :   static nsIContent::AttrValuesArray strings[] =
<span class="lineNum">     546 </span>            :     {&amp;nsGkAtoms::_empty, &amp;nsGkAtoms::stretch, nullptr};
<span class="lineNum">     547 </span><span class="lineCov">       1712 :   int32_t index = GetContent()-&gt;FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,</span>
<span class="lineNum">     548 </span><span class="lineCov">       1712 :       strings, eCaseMatters);</span>
<span class="lineNum">     549 </span><span class="lineCov">        856 :   if (index != nsIContent::ATTR_MISSING &amp;&amp; index != 0) {</span>
<span class="lineNum">     550 </span><span class="lineCov">         59 :     aStretch = index == 1;</span>
<span class="lineNum">     551 </span><span class="lineCov">         59 :     return true;</span>
<span class="lineNum">     552 </span>            :   }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   // Check the CSS box-align property.
<span class="lineNum">     555 </span><span class="lineCov">        797 :   const nsStyleXUL* boxInfo = StyleXUL();</span>
<span class="lineNum">     556 </span><span class="lineCov">        797 :   aStretch = (boxInfo-&gt;mBoxAlign == StyleBoxAlign::Stretch);</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineCov">        797 :   return true;</span>
<span class="lineNum">     559 </span>            : }
<a name="560"><span class="lineNum">     560 </span>            : </a>
<span class="lineNum">     561 </span>            : void
<span class="lineNum">     562 </span><span class="lineCov">         32 : nsBoxFrame::DidReflow(nsPresContext*           aPresContext,</span>
<span class="lineNum">     563 </span>            :                       const ReflowInput*  aReflowInput,
<span class="lineNum">     564 </span>            :                       nsDidReflowStatus         aStatus)
<span class="lineNum">     565 </span>            : {
<span class="lineNum">     566 </span>            :   nsFrameState preserveBits =
<span class="lineNum">     567 </span><span class="lineCov">         32 :     mState &amp; (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">     568 </span><span class="lineCov">         32 :   nsFrame::DidReflow(aPresContext, aReflowInput, aStatus);</span>
<span class="lineNum">     569 </span><span class="lineCov">         32 :   mState |= preserveBits;</span>
<span class="lineNum">     570 </span><span class="lineCov">         32 : }</span>
<a name="571"><span class="lineNum">     571 </span>            : </a>
<span class="lineNum">     572 </span>            : bool
<span class="lineNum">     573 </span><span class="lineCov">        438 : nsBoxFrame::HonorPrintBackgroundSettings()</span>
<span class="lineNum">     574 </span>            : {
<span class="lineNum">     575 </span><span class="lineCov">        756 :   return (!mContent || !mContent-&gt;IsInNativeAnonymousSubtree()) &amp;&amp;</span>
<span class="lineNum">     576 </span><span class="lineCov">        756 :     nsContainerFrame::HonorPrintBackgroundSettings();</span>
<span class="lineNum">     577 </span>            : }
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            : #ifdef DO_NOISY_REFLOW
<span class="lineNum">     580 </span>            : static int myCounter = 0;
<span class="lineNum">     581 </span>            : static void printSize(char * aDesc, nscoord aSize)
<span class="lineNum">     582 </span>            : {
<span class="lineNum">     583 </span>            :   printf(&quot; %s: &quot;, aDesc);
<span class="lineNum">     584 </span>            :   if (aSize == NS_UNCONSTRAINEDSIZE) {
<span class="lineNum">     585 </span>            :     printf(&quot;UC&quot;);
<span class="lineNum">     586 </span>            :   } else {
<span class="lineNum">     587 </span>            :     printf(&quot;%d&quot;, aSize);
<span class="lineNum">     588 </span>            :   }
<span class="lineNum">     589 </span>            : }
<span class="lineNum">     590 </span>            : #endif
<a name="591"><span class="lineNum">     591 </span>            : </a>
<span class="lineNum">     592 </span>            : /* virtual */ nscoord
<span class="lineNum">     593 </span><span class="lineCov">          8 : nsBoxFrame::GetMinISize(gfxContext *aRenderingContext)</span>
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span>            :   nscoord result;
<span class="lineNum">     596 </span><span class="lineCov">         16 :   DISPLAY_MIN_WIDTH(this, result);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">         16 :   nsBoxLayoutState state(PresContext(), aRenderingContext);</span>
<span class="lineNum">     599 </span><span class="lineCov">          8 :   nsSize minSize = GetXULMinSize(state);</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   // GetXULMinSize returns border-box width, and we want to return content
<span class="lineNum">     602 </span>            :   // width.  Since Reflow uses the reflow state's border and padding, we
<span class="lineNum">     603 </span>            :   // actually just want to subtract what GetXULMinSize added, which is the
<span class="lineNum">     604 </span>            :   // result of GetXULBorderAndPadding.
<span class="lineNum">     605 </span><span class="lineCov">          8 :   nsMargin bp;</span>
<span class="lineNum">     606 </span><span class="lineCov">          8 :   GetXULBorderAndPadding(bp);</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineCov">          8 :   result = minSize.width - bp.LeftRight();</span>
<span class="lineNum">     609 </span><span class="lineCov">          8 :   result = std::max(result, 0);</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineCov">         16 :   return result;</span>
<span class="lineNum">     612 </span>            : }
<a name="613"><span class="lineNum">     613 </span>            : </a>
<span class="lineNum">     614 </span>            : /* virtual */ nscoord
<span class="lineNum">     615 </span><span class="lineCov">          7 : nsBoxFrame::GetPrefISize(gfxContext *aRenderingContext)</span>
<span class="lineNum">     616 </span>            : {
<span class="lineNum">     617 </span>            :   nscoord result;
<span class="lineNum">     618 </span><span class="lineCov">         14 :   DISPLAY_PREF_WIDTH(this, result);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">         14 :   nsBoxLayoutState state(PresContext(), aRenderingContext);</span>
<span class="lineNum">     621 </span><span class="lineCov">          7 :   nsSize prefSize = GetXULPrefSize(state);</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   // GetXULPrefSize returns border-box width, and we want to return content
<span class="lineNum">     624 </span>            :   // width.  Since Reflow uses the reflow state's border and padding, we
<span class="lineNum">     625 </span>            :   // actually just want to subtract what GetXULPrefSize added, which is the
<span class="lineNum">     626 </span>            :   // result of GetXULBorderAndPadding.
<span class="lineNum">     627 </span><span class="lineCov">          7 :   nsMargin bp;</span>
<span class="lineNum">     628 </span><span class="lineCov">          7 :   GetXULBorderAndPadding(bp);</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineCov">          7 :   result = prefSize.width - bp.LeftRight();</span>
<span class="lineNum">     631 </span><span class="lineCov">          7 :   result = std::max(result, 0);</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">         14 :   return result;</span>
<span class="lineNum">     634 </span>            : }
<a name="635"><span class="lineNum">     635 </span>            : </a>
<span class="lineNum">     636 </span>            : void
<span class="lineNum">     637 </span><span class="lineCov">         32 : nsBoxFrame::Reflow(nsPresContext*          aPresContext,</span>
<span class="lineNum">     638 </span>            :                    ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">     639 </span>            :                    const ReflowInput&amp; aReflowInput,
<span class="lineNum">     640 </span>            :                    nsReflowStatus&amp;          aStatus)
<span class="lineNum">     641 </span>            : {
<span class="lineNum">     642 </span><span class="lineCov">         32 :   MarkInReflow();</span>
<span class="lineNum">     643 </span>            :   // If you make changes to this method, please keep nsLeafBoxFrame::Reflow
<span class="lineNum">     644 </span>            :   // in sync, if the changes are applicable there.
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineCov">         32 :   DO_GLOBAL_REFLOW_COUNT(&quot;nsBoxFrame&quot;);</span>
<span class="lineNum">     647 </span><span class="lineCov">         64 :   DISPLAY_REFLOW(aPresContext, this, aReflowInput, aDesiredSize, aStatus);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span><span class="lineCov">         32 :   NS_ASSERTION(aReflowInput.ComputedWidth() &gt;=0 &amp;&amp;</span>
<span class="lineNum">     650 </span>            :                aReflowInput.ComputedHeight() &gt;= 0, &quot;Computed Size &lt; 0&quot;);
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : #ifdef DO_NOISY_REFLOW
<span class="lineNum">     653 </span>            :   printf(&quot;\n-------------Starting BoxFrame Reflow ----------------------------\n&quot;);
<span class="lineNum">     654 </span>            :   printf(&quot;%p ** nsBF::Reflow %d &quot;, this, myCounter++);
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   printSize(&quot;AW&quot;, aReflowInput.AvailableWidth());
<span class="lineNum">     657 </span>            :   printSize(&quot;AH&quot;, aReflowInput.AvailableHeight());
<span class="lineNum">     658 </span>            :   printSize(&quot;CW&quot;, aReflowInput.ComputedWidth());
<span class="lineNum">     659 </span>            :   printSize(&quot;CH&quot;, aReflowInput.ComputedHeight());
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :   printf(&quot; *\n&quot;);
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : #endif
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">         32 :   aStatus.Reset();</span>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :   // create the layout state
<span class="lineNum">     668 </span><span class="lineCov">         32 :   nsBoxLayoutState state(aPresContext, aReflowInput.mRenderingContext,</span>
<span class="lineNum">     669 </span><span class="lineCov">         96 :                          &amp;aReflowInput, aReflowInput.mReflowDepth);</span>
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span><span class="lineCov">         32 :   WritingMode wm = aReflowInput.GetWritingMode();</span>
<span class="lineNum">     672 </span>            :   LogicalSize computedSize(wm, aReflowInput.ComputedISize(),
<span class="lineNum">     673 </span><span class="lineCov">         32 :                            aReflowInput.ComputedBSize());</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineCov">         32 :   LogicalMargin m = aReflowInput.ComputedLogicalBorderPadding();</span>
<span class="lineNum">     676 </span>            :   // GetXULBorderAndPadding(m);
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">         32 :   LogicalSize prefSize(wm);</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :   // if we are told to layout intrinsic then get our preferred size.
<span class="lineNum">     681 </span><span class="lineCov">         32 :   NS_ASSERTION(computedSize.ISize(wm) != NS_INTRINSICSIZE,</span>
<span class="lineNum">     682 </span>            :                &quot;computed inline size should always be computed&quot;);
<span class="lineNum">     683 </span><span class="lineCov">         32 :   if (computedSize.BSize(wm) == NS_INTRINSICSIZE) {</span>
<span class="lineNum">     684 </span><span class="lineCov">          2 :     nsSize physicalPrefSize = GetXULPrefSize(state);</span>
<span class="lineNum">     685 </span><span class="lineCov">          2 :     nsSize minSize = GetXULMinSize(state);</span>
<span class="lineNum">     686 </span><span class="lineCov">          2 :     nsSize maxSize = GetXULMaxSize(state);</span>
<span class="lineNum">     687 </span>            :     // XXXbz isn't GetXULPrefSize supposed to bounds-check for us?
<span class="lineNum">     688 </span><span class="lineCov">          2 :     physicalPrefSize = BoundsCheck(minSize, physicalPrefSize, maxSize);</span>
<span class="lineNum">     689 </span><span class="lineCov">          2 :     prefSize = LogicalSize(wm, physicalPrefSize);</span>
<span class="lineNum">     690 </span>            :   }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :   // get our desiredSize
<span class="lineNum">     693 </span><span class="lineCov">         32 :   computedSize.ISize(wm) += m.IStart(wm) + m.IEnd(wm);</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineCov">         32 :   if (aReflowInput.ComputedBSize() == NS_INTRINSICSIZE) {</span>
<span class="lineNum">     696 </span><span class="lineCov">          2 :     computedSize.BSize(wm) = prefSize.BSize(wm);</span>
<span class="lineNum">     697 </span>            :     // prefSize is border-box but min/max constraints are content-box.
<span class="lineNum">     698 </span>            :     nscoord blockDirBorderPadding =
<span class="lineNum">     699 </span><span class="lineCov">          2 :       aReflowInput.ComputedLogicalBorderPadding().BStartEnd(wm);</span>
<span class="lineNum">     700 </span><span class="lineCov">          2 :     nscoord contentBSize = computedSize.BSize(wm) - blockDirBorderPadding;</span>
<span class="lineNum">     701 </span>            :     // Note: contentHeight might be negative, but that's OK because min-height
<span class="lineNum">     702 </span>            :     // is never negative.
<span class="lineNum">     703 </span><span class="lineCov">          2 :     computedSize.BSize(wm) = aReflowInput.ApplyMinMaxHeight(contentBSize) +</span>
<span class="lineNum">     704 </span>            :                              blockDirBorderPadding;
<span class="lineNum">     705 </span>            :   } else {
<span class="lineNum">     706 </span><span class="lineCov">         30 :     computedSize.BSize(wm) += m.BStart(wm) + m.BEnd(wm);</span>
<span class="lineNum">     707 </span>            :   }
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">         32 :   nsSize physicalSize = computedSize.GetPhysicalSize(wm);</span>
<span class="lineNum">     710 </span><span class="lineCov">         64 :   nsRect r(mRect.x, mRect.y, physicalSize.width, physicalSize.height);</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">         32 :   SetXULBounds(state, r);</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   // layout our children
<span class="lineNum">     715 </span><span class="lineCov">         32 :   XULLayout(state);</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :   // ok our child could have gotten bigger. So lets get its bounds
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   // get the ascent
<span class="lineNum">     720 </span><span class="lineCov">         32 :   LogicalSize boxSize = GetLogicalSize(wm);</span>
<span class="lineNum">     721 </span><span class="lineCov">         32 :   nscoord ascent = boxSize.BSize(wm);</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   // getting the ascent could be a lot of work. Don't get it if
<span class="lineNum">     724 </span>            :   // we are the root. The viewport doesn't care about it.
<span class="lineNum">     725 </span><span class="lineCov">         32 :   if (!(mState &amp; NS_STATE_IS_ROOT)) {</span>
<span class="lineNum">     726 </span><span class="lineCov">         10 :     ascent = GetXULBoxAscent(state);</span>
<span class="lineNum">     727 </span>            :   }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineCov">         32 :   aDesiredSize.SetSize(wm, boxSize);</span>
<span class="lineNum">     730 </span><span class="lineCov">         32 :   aDesiredSize.SetBlockStartAscent(ascent);</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">         32 :   aDesiredSize.mOverflowAreas = GetOverflowAreas();</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : #ifdef DO_NOISY_REFLOW
<span class="lineNum">     735 </span>            :   {
<span class="lineNum">     736 </span>            :     printf(&quot;%p ** nsBF(done) W:%d H:%d  &quot;, this, aDesiredSize.Width(), aDesiredSize.Height());
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     if (maxElementSize) {
<span class="lineNum">     739 </span>            :       printf(&quot;MW:%d\n&quot;, *maxElementWidth);
<span class="lineNum">     740 </span>            :     } else {
<span class="lineNum">     741 </span>            :       printf(&quot;MW:?\n&quot;);
<span class="lineNum">     742 </span>            :     }
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :   }
<span class="lineNum">     745 </span>            : #endif
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">         32 :   ReflowAbsoluteFrames(aPresContext, aDesiredSize, aReflowInput, aStatus);</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineCov">         32 :   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize);</span>
<span class="lineNum">     750 </span><span class="lineCov">         32 : }</span>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span>            : nsSize
<span class="lineNum">     753 </span><span class="lineCov">       1801 : nsBoxFrame::GetXULPrefSize(nsBoxLayoutState&amp; aBoxLayoutState)</span>
<span class="lineNum">     754 </span>            : {
<span class="lineNum">     755 </span><span class="lineCov">       1801 :   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),</span>
<span class="lineNum">     756 </span>            :                &quot;must have rendering context&quot;);
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">       1801 :   nsSize size(0,0);</span>
<span class="lineNum">     759 </span><span class="lineCov">       3602 :   DISPLAY_PREF_SIZE(this, size);</span>
<span class="lineNum">     760 </span><span class="lineCov">       1801 :   if (!DoesNeedRecalc(mPrefSize)) {</span>
<span class="lineNum">     761 </span><span class="lineCov">       1414 :      return mPrefSize;</span>
<span class="lineNum">     762 </span>            :   }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     765 </span>            :   PropagateDebug(aBoxLayoutState);
<span class="lineNum">     766 </span>            : #endif
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineCov">        387 :   if (IsXULCollapsed())</span>
<span class="lineNum">     769 </span><span class="lineCov">         17 :     return size;</span>
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :   // if the size was not completely redefined in CSS then ask our children
<span class="lineNum">     772 </span>            :   bool widthSet, heightSet;
<span class="lineNum">     773 </span><span class="lineCov">        370 :   if (!nsIFrame::AddXULPrefSize(this, size, widthSet, heightSet))</span>
<span class="lineNum">     774 </span>            :   {
<span class="lineNum">     775 </span><span class="lineCov">        367 :     if (mLayoutManager) {</span>
<span class="lineNum">     776 </span><span class="lineCov">        367 :       nsSize layoutSize = mLayoutManager-&gt;GetXULPrefSize(this, aBoxLayoutState);</span>
<span class="lineNum">     777 </span><span class="lineCov">        367 :       if (!widthSet)</span>
<span class="lineNum">     778 </span><span class="lineCov">        332 :         size.width = layoutSize.width;</span>
<span class="lineNum">     779 </span><span class="lineCov">        367 :       if (!heightSet)</span>
<span class="lineNum">     780 </span><span class="lineCov">        360 :         size.height = layoutSize.height;</span>
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span>            :     else {
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       size = nsBox::GetXULPrefSize(aBoxLayoutState);</span>
<span class="lineNum">     784 </span>            :     }
<span class="lineNum">     785 </span>            :   }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineCov">        370 :   nsSize minSize = GetXULMinSize(aBoxLayoutState);</span>
<span class="lineNum">     788 </span><span class="lineCov">        370 :   nsSize maxSize = GetXULMaxSize(aBoxLayoutState);</span>
<span class="lineNum">     789 </span><span class="lineCov">        370 :   mPrefSize = BoundsCheck(minSize, size, maxSize);</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineCov">        370 :   return mPrefSize;</span>
<span class="lineNum">     792 </span>            : }
<a name="793"><span class="lineNum">     793 </span>            : </a>
<span class="lineNum">     794 </span>            : nscoord
<span class="lineNum">     795 </span><span class="lineCov">       1837 : nsBoxFrame::GetXULBoxAscent(nsBoxLayoutState&amp; aBoxLayoutState)</span>
<span class="lineNum">     796 </span>            : {
<span class="lineNum">     797 </span><span class="lineCov">       1837 :   if (!DoesNeedRecalc(mAscent))</span>
<span class="lineNum">     798 </span><span class="lineCov">       1040 :      return mAscent;</span>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     801 </span>            :   PropagateDebug(aBoxLayoutState);
<span class="lineNum">     802 </span>            : #endif
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">        797 :   if (IsXULCollapsed())</span>
<span class="lineNum">     805 </span><span class="lineCov">        125 :     return 0;</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineCov">        672 :   if (mLayoutManager)</span>
<span class="lineNum">     808 </span><span class="lineCov">        672 :     mAscent = mLayoutManager-&gt;GetAscent(this, aBoxLayoutState);</span>
<span class="lineNum">     809 </span>            :   else
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     mAscent = nsBox::GetXULBoxAscent(aBoxLayoutState);</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineCov">        672 :   return mAscent;</span>
<span class="lineNum">     813 </span>            : }
<a name="814"><span class="lineNum">     814 </span>            : </a>
<span class="lineNum">     815 </span>            : nsSize
<span class="lineNum">     816 </span><span class="lineCov">       2495 : nsBoxFrame::GetXULMinSize(nsBoxLayoutState&amp; aBoxLayoutState)</span>
<span class="lineNum">     817 </span>            : {
<span class="lineNum">     818 </span><span class="lineCov">       2495 :   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),</span>
<span class="lineNum">     819 </span>            :                &quot;must have rendering context&quot;);
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineCov">       2495 :   nsSize size(0,0);</span>
<span class="lineNum">     822 </span><span class="lineCov">       4990 :   DISPLAY_MIN_SIZE(this, size);</span>
<span class="lineNum">     823 </span><span class="lineCov">       2495 :   if (!DoesNeedRecalc(mMinSize)) {</span>
<span class="lineNum">     824 </span><span class="lineCov">       2079 :     return mMinSize;</span>
<span class="lineNum">     825 </span>            :   }
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     828 </span>            :   PropagateDebug(aBoxLayoutState);
<span class="lineNum">     829 </span>            : #endif
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineCov">        416 :   if (IsXULCollapsed())</span>
<span class="lineNum">     832 </span><span class="lineCov">         33 :     return size;</span>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :   // if the size was not completely redefined in CSS then ask our children
<span class="lineNum">     835 </span>            :   bool widthSet, heightSet;
<span class="lineNum">     836 </span><span class="lineCov">        383 :   if (!nsIFrame::AddXULMinSize(aBoxLayoutState, this, size, widthSet, heightSet))</span>
<span class="lineNum">     837 </span>            :   {
<span class="lineNum">     838 </span><span class="lineCov">        343 :     if (mLayoutManager) {</span>
<span class="lineNum">     839 </span><span class="lineCov">        343 :       nsSize layoutSize = mLayoutManager-&gt;GetXULMinSize(this, aBoxLayoutState);</span>
<span class="lineNum">     840 </span><span class="lineCov">        343 :       if (!widthSet)</span>
<span class="lineNum">     841 </span><span class="lineCov">        262 :         size.width = layoutSize.width;</span>
<span class="lineNum">     842 </span><span class="lineCov">        343 :       if (!heightSet)</span>
<span class="lineNum">     843 </span><span class="lineCov">        320 :         size.height = layoutSize.height;</span>
<span class="lineNum">     844 </span>            :     }
<span class="lineNum">     845 </span>            :     else {
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :       size = nsBox::GetXULMinSize(aBoxLayoutState);</span>
<span class="lineNum">     847 </span>            :     }
<span class="lineNum">     848 </span>            :   }
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineCov">        383 :   mMinSize = size;</span>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineCov">        383 :   return size;</span>
<span class="lineNum">     853 </span>            : }
<a name="854"><span class="lineNum">     854 </span>            : </a>
<span class="lineNum">     855 </span>            : nsSize
<span class="lineNum">     856 </span><span class="lineCov">       1960 : nsBoxFrame::GetXULMaxSize(nsBoxLayoutState&amp; aBoxLayoutState)</span>
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineCov">       1960 :   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),</span>
<span class="lineNum">     859 </span>            :                &quot;must have rendering context&quot;);
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineCov">       1960 :   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);</span>
<span class="lineNum">     862 </span><span class="lineCov">       3920 :   DISPLAY_MAX_SIZE(this, size);</span>
<span class="lineNum">     863 </span><span class="lineCov">       1960 :   if (!DoesNeedRecalc(mMaxSize)) {</span>
<span class="lineNum">     864 </span><span class="lineCov">       1542 :     return mMaxSize;</span>
<span class="lineNum">     865 </span>            :   }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     868 </span>            :   PropagateDebug(aBoxLayoutState);
<span class="lineNum">     869 </span>            : #endif
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineCov">        418 :   if (IsXULCollapsed())</span>
<span class="lineNum">     872 </span><span class="lineCov">         29 :     return size;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   // if the size was not completely redefined in CSS then ask our children
<span class="lineNum">     875 </span>            :   bool widthSet, heightSet;
<span class="lineNum">     876 </span><span class="lineCov">        389 :   if (!nsIFrame::AddXULMaxSize(this, size, widthSet, heightSet))</span>
<span class="lineNum">     877 </span>            :   {
<span class="lineNum">     878 </span><span class="lineCov">        363 :     if (mLayoutManager) {</span>
<span class="lineNum">     879 </span><span class="lineCov">        363 :       nsSize layoutSize = mLayoutManager-&gt;GetXULMaxSize(this, aBoxLayoutState);</span>
<span class="lineNum">     880 </span><span class="lineCov">        363 :       if (!widthSet)</span>
<span class="lineNum">     881 </span><span class="lineCov">        363 :         size.width = layoutSize.width;</span>
<span class="lineNum">     882 </span><span class="lineCov">        363 :       if (!heightSet)</span>
<span class="lineNum">     883 </span><span class="lineCov">        363 :         size.height = layoutSize.height;</span>
<span class="lineNum">     884 </span>            :     }
<span class="lineNum">     885 </span>            :     else {
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       size = nsBox::GetXULMaxSize(aBoxLayoutState);</span>
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span>            :   }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">        389 :   mMaxSize = size;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineCov">        389 :   return size;</span>
<span class="lineNum">     893 </span>            : }
<a name="894"><span class="lineNum">     894 </span>            : </a>
<span class="lineNum">     895 </span>            : nscoord
<span class="lineNum">     896 </span><span class="lineCov">       1395 : nsBoxFrame::GetXULFlex()</span>
<span class="lineNum">     897 </span>            : {
<span class="lineNum">     898 </span><span class="lineCov">       1395 :   if (!DoesNeedRecalc(mFlex))</span>
<span class="lineNum">     899 </span><span class="lineCov">       1031 :      return mFlex;</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineCov">        364 :   mFlex = nsBox::GetXULFlex();</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineCov">        364 :   return mFlex;</span>
<span class="lineNum">     904 </span>            : }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : /**
<span class="lineNum">     907 </span>            :  * If subclassing please subclass this method not layout.
<span class="lineNum">     908 </span>            :  * layout will call this method.
<a name="909"><span class="lineNum">     909 </span>            :  */</a>
<span class="lineNum">     910 </span>            : NS_IMETHODIMP
<span class="lineNum">     911 </span><span class="lineCov">        594 : nsBoxFrame::DoXULLayout(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">     912 </span>            : {
<span class="lineNum">     913 </span><span class="lineCov">        594 :   uint32_t oldFlags = aState.LayoutFlags();</span>
<span class="lineNum">     914 </span><span class="lineCov">        594 :   aState.SetLayoutFlags(0);</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineCov">        594 :   nsresult rv = NS_OK;</span>
<span class="lineNum">     917 </span><span class="lineCov">        594 :   if (mLayoutManager) {</span>
<span class="lineNum">     918 </span><span class="lineCov">        594 :     CoordNeedsRecalc(mAscent);</span>
<span class="lineNum">     919 </span><span class="lineCov">        594 :     rv = mLayoutManager-&gt;XULLayout(this, aState);</span>
<span class="lineNum">     920 </span>            :   }
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineCov">        594 :   aState.SetLayoutFlags(oldFlags);</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineCov">        594 :   if (HasAbsolutelyPositionedChildren()) {</span>
<span class="lineNum">     925 </span>            :     // Set up a |reflowInput| to pass into ReflowAbsoluteFrames
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     WritingMode wm = GetWritingMode();</span>
<span class="lineNum">     927 </span>            :     ReflowInput reflowInput(aState.PresContext(), this,
<span class="lineNum">     928 </span>            :                                   aState.GetRenderingContext(),
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                                   LogicalSize(wm, GetLogicalSize().ISize(wm),</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                                               NS_UNCONSTRAINEDSIZE));</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            :     // Set up a |desiredSize| to pass into ReflowAbsoluteFrames
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     ReflowOutput desiredSize(reflowInput);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     desiredSize.Width() = mRect.width;</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     desiredSize.Height() = mRect.height;</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :     // get the ascent (cribbed from ::Reflow)
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     nscoord ascent = mRect.height;</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :     // getting the ascent could be a lot of work. Don't get it if
<span class="lineNum">     941 </span>            :     // we are the root. The viewport doesn't care about it.
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     if (!(mState &amp; NS_STATE_IS_ROOT)) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       ascent = GetXULBoxAscent(aState);</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     desiredSize.SetBlockStartAscent(ascent);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     desiredSize.mOverflowAreas = GetOverflowAreas();</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     AddStateBits(NS_FRAME_IN_REFLOW);</span>
<span class="lineNum">     949 </span>            :     // Set up a |reflowStatus| to pass into ReflowAbsoluteFrames
<span class="lineNum">     950 </span>            :     // (just a dummy value; hopefully that's OK)
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     nsReflowStatus reflowStatus;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     ReflowAbsoluteFrames(aState.PresContext(), desiredSize,</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :                          reflowInput, reflowStatus);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     RemoveStateBits(NS_FRAME_IN_REFLOW);</span>
<span class="lineNum">     955 </span>            :   }
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineCov">        594 :   return rv;</span>
<span class="lineNum">     958 </span>            : }
<a name="959"><span class="lineNum">     959 </span>            : </a>
<span class="lineNum">     960 </span>            : void
<span class="lineNum">     961 </span><span class="lineCov">         56 : nsBoxFrame::DestroyFrom(nsIFrame* aDestructRoot)</span>
<span class="lineNum">     962 </span>            : {
<span class="lineNum">     963 </span>            :   // unregister access key
<span class="lineNum">     964 </span><span class="lineCov">         56 :   RegUnregAccessKey(false);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :   // clean up the container box's layout manager and child boxes
<span class="lineNum">     967 </span><span class="lineCov">         56 :   SetXULLayoutManager(nullptr);</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span><span class="lineCov">         56 :   nsContainerFrame::DestroyFrom(aDestructRoot);</span>
<span class="lineNum">     970 </span><span class="lineCov">         56 : }</span>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">     973 </span>            : nsresult
<span class="lineNum">     974 </span>            : nsBoxFrame::SetXULDebug(nsBoxLayoutState&amp; aState, bool aDebug)
<span class="lineNum">     975 </span>            : {
<span class="lineNum">     976 </span>            :   // see if our state matches the given debug state
<span class="lineNum">     977 </span>            :   bool debugSet = mState &amp; NS_STATE_CURRENTLY_IN_DEBUG;
<span class="lineNum">     978 </span>            :   bool debugChanged = (!aDebug &amp;&amp; debugSet) || (aDebug &amp;&amp; !debugSet);
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :   // if it doesn't then tell each child below us the new debug state
<span class="lineNum">     981 </span>            :   if (debugChanged)
<span class="lineNum">     982 </span>            :   {
<span class="lineNum">     983 </span>            :      if (aDebug) {
<span class="lineNum">     984 </span>            :          mState |= NS_STATE_CURRENTLY_IN_DEBUG;
<span class="lineNum">     985 </span>            :      } else {
<span class="lineNum">     986 </span>            :          mState &amp;= ~NS_STATE_CURRENTLY_IN_DEBUG;
<span class="lineNum">     987 </span>            :      }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :      SetDebugOnChildList(aState, mFirstChild, aDebug);
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :     MarkIntrinsicISizesDirty();
<span class="lineNum">     992 </span>            :   }
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :   return NS_OK;
<span class="lineNum">     995 </span>            : }
<span class="lineNum">     996 </span>            : #endif
<a name="997"><span class="lineNum">     997 </span>            : </a>
<span class="lineNum">     998 </span>            : /* virtual */ void
<span class="lineNum">     999 </span><span class="lineCov">       1285 : nsBoxFrame::MarkIntrinsicISizesDirty()</span>
<span class="lineNum">    1000 </span>            : {
<span class="lineNum">    1001 </span><span class="lineCov">       1285 :   SizeNeedsRecalc(mPrefSize);</span>
<span class="lineNum">    1002 </span><span class="lineCov">       1285 :   SizeNeedsRecalc(mMinSize);</span>
<span class="lineNum">    1003 </span><span class="lineCov">       1285 :   SizeNeedsRecalc(mMaxSize);</span>
<span class="lineNum">    1004 </span><span class="lineCov">       1285 :   CoordNeedsRecalc(mFlex);</span>
<span class="lineNum">    1005 </span><span class="lineCov">       1285 :   CoordNeedsRecalc(mAscent);</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineCov">       1285 :   if (mLayoutManager) {</span>
<span class="lineNum">    1008 </span><span class="lineCov">       2444 :     nsBoxLayoutState state(PresContext());</span>
<span class="lineNum">    1009 </span><span class="lineCov">       1222 :     mLayoutManager-&gt;IntrinsicISizesDirty(this, state);</span>
<span class="lineNum">    1010 </span>            :   }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :   // Don't call base class method, since everything it does is within an
<span class="lineNum">    1013 </span>            :   // IsXULBoxWrapped check.
<span class="lineNum">    1014 </span><span class="lineCov">       1285 : }</span>
<a name="1015"><span class="lineNum">    1015 </span>            : </a>
<span class="lineNum">    1016 </span>            : void
<span class="lineNum">    1017 </span><span class="lineCov">         13 : nsBoxFrame::RemoveFrame(ChildListID     aListID,</span>
<span class="lineNum">    1018 </span>            :                         nsIFrame*       aOldFrame)
<span class="lineNum">    1019 </span>            : {
<span class="lineNum">    1020 </span><span class="lineCov">         13 :   NS_PRECONDITION(aListID == kPrincipalList, &quot;We don't support out-of-flow kids&quot;);</span>
<span class="lineNum">    1021 </span><span class="lineCov">         13 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    1022 </span><span class="lineCov">         26 :   nsBoxLayoutState state(presContext);</span>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :   // remove the child frame
<span class="lineNum">    1025 </span><span class="lineCov">         13 :   mFrames.RemoveFrame(aOldFrame);</span>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :   // notify the layout manager
<span class="lineNum">    1028 </span><span class="lineCov">         13 :   if (mLayoutManager)</span>
<span class="lineNum">    1029 </span><span class="lineCov">         13 :     mLayoutManager-&gt;ChildrenRemoved(this, state, aOldFrame);</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :   // destroy the child frame
<span class="lineNum">    1032 </span><span class="lineCov">         13 :   aOldFrame-&gt;Destroy();</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :   // mark us dirty and generate a reflow command
<span class="lineNum">    1035 </span><span class="lineCov">         13 :   PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1036 </span><span class="lineCov">         13 :     FrameNeedsReflow(this, nsIPresShell::eTreeChange,</span>
<span class="lineNum">    1037 </span><span class="lineCov">         26 :                      NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    1038 </span><span class="lineCov">         13 : }</span>
<a name="1039"><span class="lineNum">    1039 </span>            : </a>
<span class="lineNum">    1040 </span>            : void
<span class="lineNum">    1041 </span><span class="lineCov">         22 : nsBoxFrame::InsertFrames(ChildListID     aListID,</span>
<span class="lineNum">    1042 </span>            :                          nsIFrame*       aPrevFrame,
<span class="lineNum">    1043 </span>            :                          nsFrameList&amp;    aFrameList)
<span class="lineNum">    1044 </span>            : {
<span class="lineNum">    1045 </span><span class="lineCov">         22 :    NS_ASSERTION(!aPrevFrame || aPrevFrame-&gt;GetParent() == this,</span>
<span class="lineNum">    1046 </span>            :                 &quot;inserting after sibling frame with different parent&quot;);
<span class="lineNum">    1047 </span><span class="lineCov">         22 :    NS_ASSERTION(!aPrevFrame || mFrames.ContainsFrame(aPrevFrame),</span>
<span class="lineNum">    1048 </span>            :                 &quot;inserting after sibling frame not in our child list&quot;);
<span class="lineNum">    1049 </span><span class="lineCov">         22 :    NS_PRECONDITION(aListID == kPrincipalList, &quot;We don't support out-of-flow kids&quot;);</span>
<span class="lineNum">    1050 </span><span class="lineCov">         44 :    nsBoxLayoutState state(PresContext());</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :    // insert the child frames
<span class="lineNum">    1053 </span>            :    const nsFrameList::Slice&amp; newFrames =
<span class="lineNum">    1054 </span><span class="lineCov">         22 :      mFrames.InsertFrames(this, aPrevFrame, aFrameList);</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :    // notify the layout manager
<span class="lineNum">    1057 </span><span class="lineCov">         22 :    if (mLayoutManager)</span>
<span class="lineNum">    1058 </span><span class="lineCov">         22 :      mLayoutManager-&gt;ChildrenInserted(this, state, aPrevFrame, newFrames);</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :    // Make sure to check box order _after_ notifying the layout
<span class="lineNum">    1061 </span>            :    // manager; otherwise the slice we give the layout manager will
<span class="lineNum">    1062 </span>            :    // just be bogus.  If the layout manager cares about the order, we
<span class="lineNum">    1063 </span>            :    // just lose.
<span class="lineNum">    1064 </span><span class="lineCov">         22 :    CheckBoxOrder();</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1067 </span>            :    // if we are in debug make sure our children are in debug as well.
<span class="lineNum">    1068 </span>            :    if (mState &amp; NS_STATE_CURRENTLY_IN_DEBUG)
<span class="lineNum">    1069 </span>            :        SetDebugOnChildList(state, mFrames.FirstChild(), true);
<span class="lineNum">    1070 </span>            : #endif
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineCov">         22 :    PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1073 </span><span class="lineCov">         22 :      FrameNeedsReflow(this, nsIPresShell::eTreeChange,</span>
<span class="lineNum">    1074 </span><span class="lineCov">         44 :                       NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    1075 </span><span class="lineCov">         22 : }</span>
<span class="lineNum">    1076 </span>            : 
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<span class="lineNum">    1078 </span>            : void
<span class="lineNum">    1079 </span><span class="lineCov">          8 : nsBoxFrame::AppendFrames(ChildListID     aListID,</span>
<span class="lineNum">    1080 </span>            :                          nsFrameList&amp;    aFrameList)
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span><span class="lineCov">          8 :    NS_PRECONDITION(aListID == kPrincipalList, &quot;We don't support out-of-flow kids&quot;);</span>
<span class="lineNum">    1083 </span><span class="lineCov">         16 :    nsBoxLayoutState state(PresContext());</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :    // append the new frames
<span class="lineNum">    1086 </span><span class="lineCov">          8 :    const nsFrameList::Slice&amp; newFrames = mFrames.AppendFrames(this, aFrameList);</span>
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :    // notify the layout manager
<span class="lineNum">    1089 </span><span class="lineCov">          8 :    if (mLayoutManager)</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :      mLayoutManager-&gt;ChildrenAppended(this, state, newFrames);</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :    // Make sure to check box order _after_ notifying the layout
<span class="lineNum">    1093 </span>            :    // manager; otherwise the slice we give the layout manager will
<span class="lineNum">    1094 </span>            :    // just be bogus.  If the layout manager cares about the order, we
<span class="lineNum">    1095 </span>            :    // just lose.
<span class="lineNum">    1096 </span><span class="lineCov">          8 :    CheckBoxOrder();</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1099 </span>            :    // if we are in debug make sure our children are in debug as well.
<span class="lineNum">    1100 </span>            :    if (mState &amp; NS_STATE_CURRENTLY_IN_DEBUG)
<span class="lineNum">    1101 </span>            :        SetDebugOnChildList(state, mFrames.FirstChild(), true);
<span class="lineNum">    1102 </span>            : #endif
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :    // XXXbz why is this NS_FRAME_FIRST_REFLOW check here?
<span class="lineNum">    1105 </span><span class="lineCov">          8 :    if (!(GetStateBits() &amp; NS_FRAME_FIRST_REFLOW)) {</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :      PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :        FrameNeedsReflow(this, nsIPresShell::eTreeChange,</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                         NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    1109 </span>            :    }
<span class="lineNum">    1110 </span><span class="lineCov">          8 : }</span>
<a name="1111"><span class="lineNum">    1111 </span>            : </a>
<span class="lineNum">    1112 </span>            : /* virtual */ nsContainerFrame*
<span class="lineNum">    1113 </span><span class="lineCov">        688 : nsBoxFrame::GetContentInsertionFrame()</span>
<span class="lineNum">    1114 </span>            : {
<span class="lineNum">    1115 </span><span class="lineCov">        688 :   if (GetStateBits() &amp; NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK)</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     return PrincipalChildList().FirstChild()-&gt;GetContentInsertionFrame();</span>
<span class="lineNum">    1117 </span><span class="lineCov">        688 :   return nsContainerFrame::GetContentInsertionFrame();</span>
<span class="lineNum">    1118 </span>            : }
<a name="1119"><span class="lineNum">    1119 </span>            : </a>
<span class="lineNum">    1120 </span>            : nsresult
<span class="lineNum">    1121 </span><span class="lineCov">        114 : nsBoxFrame::AttributeChanged(int32_t aNameSpaceID,</span>
<span class="lineNum">    1122 </span>            :                              nsIAtom* aAttribute,
<span class="lineNum">    1123 </span>            :                              int32_t aModType)
<span class="lineNum">    1124 </span>            : {
<span class="lineNum">    1125 </span><span class="lineCov">        114 :   nsresult rv = nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute,</span>
<span class="lineNum">    1126 </span><span class="lineCov">        114 :                                                    aModType);</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :   // Ignore 'width', 'height', 'screenX', 'screenY' and 'sizemode' on a
<span class="lineNum">    1129 </span>            :   // &lt;window&gt;.
<span class="lineNum">    1130 </span><span class="lineCov">        228 :   if (mContent-&gt;IsAnyOfXULElements(nsGkAtoms::window,</span>
<span class="lineNum">    1131 </span>            :                                    nsGkAtoms::page,
<span class="lineNum">    1132 </span>            :                                    nsGkAtoms::dialog,
<span class="lineNum">    1133 </span><span class="lineCov">        119 :                                    nsGkAtoms::wizard) &amp;&amp;</span>
<span class="lineNum">    1134 </span><span class="lineCov">          5 :       (nsGkAtoms::width == aAttribute ||</span>
<span class="lineNum">    1135 </span><span class="lineCov">          3 :        nsGkAtoms::height == aAttribute ||</span>
<span class="lineNum">    1136 </span><span class="lineCov">          2 :        nsGkAtoms::screenX == aAttribute ||</span>
<span class="lineNum">    1137 </span><span class="lineCov">          2 :        nsGkAtoms::screenY == aAttribute ||</span>
<span class="lineNum">    1138 </span><span class="lineCov">          1 :        nsGkAtoms::sizemode == aAttribute)) {</span>
<span class="lineNum">    1139 </span><span class="lineCov">          2 :     return rv;</span>
<span class="lineNum">    1140 </span>            :   }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">        224 :   if (aAttribute == nsGkAtoms::width       ||</span>
<span class="lineNum">    1143 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::height      ||</span>
<span class="lineNum">    1144 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::align       ||</span>
<span class="lineNum">    1145 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::valign      ||</span>
<span class="lineNum">    1146 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::left        ||</span>
<span class="lineNum">    1147 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::top         ||</span>
<span class="lineNum">    1148 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::right        ||</span>
<span class="lineNum">    1149 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::bottom       ||</span>
<span class="lineNum">    1150 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::start        ||</span>
<span class="lineNum">    1151 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::end          ||</span>
<span class="lineNum">    1152 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::minwidth     ||</span>
<span class="lineNum">    1153 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::maxwidth     ||</span>
<span class="lineNum">    1154 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::minheight    ||</span>
<span class="lineNum">    1155 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::maxheight    ||</span>
<span class="lineNum">    1156 </span><span class="lineCov">        224 :       aAttribute == nsGkAtoms::flex         ||</span>
<span class="lineNum">    1157 </span><span class="lineCov">        223 :       aAttribute == nsGkAtoms::orient       ||</span>
<span class="lineNum">    1158 </span><span class="lineCov">        222 :       aAttribute == nsGkAtoms::pack         ||</span>
<span class="lineNum">    1159 </span><span class="lineCov">        222 :       aAttribute == nsGkAtoms::dir          ||</span>
<span class="lineNum">    1160 </span><span class="lineCov">        222 :       aAttribute == nsGkAtoms::mousethrough ||</span>
<span class="lineNum">    1161 </span><span class="lineCov">        111 :       aAttribute == nsGkAtoms::equalsize) {</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineCov">          2 :     if (aAttribute == nsGkAtoms::align  ||</span>
<span class="lineNum">    1164 </span><span class="lineCov">          2 :         aAttribute == nsGkAtoms::valign ||</span>
<span class="lineNum">    1165 </span><span class="lineCov">          1 :         aAttribute == nsGkAtoms::orient  ||</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         aAttribute == nsGkAtoms::pack    ||</span>
<span class="lineNum">    1167 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1168 </span>            :         aAttribute == nsGkAtoms::debug   ||
<span class="lineNum">    1169 </span>            : #endif
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         aAttribute == nsGkAtoms::dir) {</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">          1 :       mValign = nsBoxFrame::vAlign_Top;</span>
<span class="lineNum">    1173 </span><span class="lineCov">          1 :       mHalign = nsBoxFrame::hAlign_Left;</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineCov">          1 :       bool orient = true;</span>
<span class="lineNum">    1176 </span><span class="lineCov">          1 :       GetInitialOrientation(orient);</span>
<span class="lineNum">    1177 </span><span class="lineCov">          1 :       if (orient)</span>
<span class="lineNum">    1178 </span><span class="lineCov">          1 :         mState |= NS_STATE_IS_HORIZONTAL;</span>
<span class="lineNum">    1179 </span>            :       else
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         mState &amp;= ~NS_STATE_IS_HORIZONTAL;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineCov">          1 :       bool normal = true;</span>
<span class="lineNum">    1183 </span><span class="lineCov">          1 :       GetInitialDirection(normal);</span>
<span class="lineNum">    1184 </span><span class="lineCov">          1 :       if (normal)</span>
<span class="lineNum">    1185 </span><span class="lineCov">          1 :         mState |= NS_STATE_IS_DIRECTION_NORMAL;</span>
<span class="lineNum">    1186 </span>            :       else
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         mState &amp;= ~NS_STATE_IS_DIRECTION_NORMAL;</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineCov">          1 :       GetInitialVAlignment(mValign);</span>
<span class="lineNum">    1190 </span><span class="lineCov">          1 :       GetInitialHAlignment(mHalign);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">          1 :       bool equalSize = false;</span>
<span class="lineNum">    1193 </span><span class="lineCov">          1 :       GetInitialEqualSize(equalSize);</span>
<span class="lineNum">    1194 </span><span class="lineCov">          1 :       if (equalSize)</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         mState |= NS_STATE_EQUAL_SIZE;</span>
<span class="lineNum">    1196 </span>            :       else
<span class="lineNum">    1197 </span><span class="lineCov">          1 :         mState &amp;= ~NS_STATE_EQUAL_SIZE;</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1200 </span>            :       bool debug = mState &amp; NS_STATE_SET_TO_DEBUG;
<span class="lineNum">    1201 </span>            :       bool debugSet = GetInitialDebug(debug);
<span class="lineNum">    1202 </span>            :       if (debugSet) {
<span class="lineNum">    1203 </span>            :         mState |= NS_STATE_DEBUG_WAS_SET;
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :         if (debug)
<span class="lineNum">    1206 </span>            :           mState |= NS_STATE_SET_TO_DEBUG;
<span class="lineNum">    1207 </span>            :         else
<span class="lineNum">    1208 </span>            :           mState &amp;= ~NS_STATE_SET_TO_DEBUG;
<span class="lineNum">    1209 </span>            :       } else {
<span class="lineNum">    1210 </span>            :         mState &amp;= ~NS_STATE_DEBUG_WAS_SET;
<span class="lineNum">    1211 </span>            :       }
<span class="lineNum">    1212 </span>            : #endif
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span><span class="lineCov">          1 :       bool autostretch = !!(mState &amp; NS_STATE_AUTO_STRETCH);</span>
<span class="lineNum">    1215 </span><span class="lineCov">          1 :       GetInitialAutoStretch(autostretch);</span>
<span class="lineNum">    1216 </span><span class="lineCov">          1 :       if (autostretch)</span>
<span class="lineNum">    1217 </span><span class="lineCov">          1 :         mState |= NS_STATE_AUTO_STRETCH;</span>
<span class="lineNum">    1218 </span>            :       else
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :         mState &amp;= ~NS_STATE_AUTO_STRETCH;</span>
<span class="lineNum">    1220 </span>            :     }
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     else if (aAttribute == nsGkAtoms::left ||</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::top ||</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::right ||</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::bottom ||</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::start ||</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::end) {</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :       mState &amp;= ~NS_STATE_STACK_NOT_POSITIONED;</span>
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     else if (aAttribute == nsGkAtoms::mousethrough) {</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       UpdateMouseThrough();</span>
<span class="lineNum">    1231 </span>            :     }
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span><span class="lineCov">          1 :     PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1234 </span><span class="lineCov">          1 :       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    1235 </span>            :   }
<span class="lineNum">    1236 </span><span class="lineCov">        111 :   else if (aAttribute == nsGkAtoms::ordinal) {</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :     nsIFrame* parent = GetParentXULBox(this);</span>
<span class="lineNum">    1238 </span>            :     // If our parent is not a box, there's not much we can do... but in that
<span class="lineNum">    1239 </span>            :     // case our ordinal doesn't matter anyway, so that's ok.
<span class="lineNum">    1240 </span>            :     // Also don't bother with popup frames since they are kept on the
<span class="lineNum">    1241 </span>            :     // kPopupList and XULRelayoutChildAtOrdinal() only handles
<span class="lineNum">    1242 </span>            :     // principal children.
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     if (parent &amp;&amp; !(GetStateBits() &amp; NS_FRAME_OUT_OF_FLOW) &amp;&amp;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         StyleDisplay()-&gt;mDisplay != mozilla::StyleDisplay::MozPopup) {</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       parent-&gt;XULRelayoutChildAtOrdinal(this);</span>
<span class="lineNum">    1246 </span>            :       // XXXldb Should this instead be a tree change on the child or parent?
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :       PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1248 </span>            :         FrameNeedsReflow(parent, nsIPresShell::eStyleChange,
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                          NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    1250 </span>            :     }
<span class="lineNum">    1251 </span>            :   }
<span class="lineNum">    1252 </span>            :   // If the accesskey changed, register for the new value
<span class="lineNum">    1253 </span>            :   // The old value has been unregistered in nsXULElement::SetAttr
<span class="lineNum">    1254 </span><span class="lineCov">        111 :   else if (aAttribute == nsGkAtoms::accesskey) {</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :     RegUnregAccessKey(true);</span>
<span class="lineNum">    1256 </span>            :   }
<span class="lineNum">    1257 </span><span class="lineCov">        111 :   else if (aAttribute == nsGkAtoms::rows &amp;&amp;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :            mContent-&gt;IsXULElement(nsGkAtoms::tree)) {</span>
<span class="lineNum">    1259 </span>            :     // Reflow ourselves and all our children if &quot;rows&quot; changes, since
<span class="lineNum">    1260 </span>            :     // nsTreeBodyFrame's layout reads this from its parent (this frame).
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     PresContext()-&gt;PresShell()-&gt;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    1263 </span>            :   }
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineCov">        112 :   return rv;</span>
<span class="lineNum">    1266 </span>            : }
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1269 </span>            : void
<span class="lineNum">    1270 </span>            : nsBoxFrame::GetDebugPref()
<span class="lineNum">    1271 </span>            : {
<span class="lineNum">    1272 </span>            :   gDebug = Preferences::GetBool(&quot;xul.debug.box&quot;);
<span class="lineNum">    1273 </span>            : }
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            : class nsDisplayXULDebug : public nsDisplayItem {
<span class="lineNum">    1276 </span>            : public:
<span class="lineNum">    1277 </span>            :   nsDisplayXULDebug(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame) :
<span class="lineNum">    1278 </span>            :     nsDisplayItem(aBuilder, aFrame) {
<span class="lineNum">    1279 </span>            :     MOZ_COUNT_CTOR(nsDisplayXULDebug);
<span class="lineNum">    1280 </span>            :   }
<span class="lineNum">    1281 </span>            : #ifdef NS_BUILD_REFCNT_LOGGING
<span class="lineNum">    1282 </span>            :   virtual ~nsDisplayXULDebug() {
<span class="lineNum">    1283 </span>            :     MOZ_COUNT_DTOR(nsDisplayXULDebug);
<span class="lineNum">    1284 </span>            :   }
<span class="lineNum">    1285 </span>            : #endif
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :   virtual void HitTest(nsDisplayListBuilder* aBuilder, nsRect aRect,
<span class="lineNum">    1288 </span>            :                        HitTestState* aState, nsTArray&lt;nsIFrame*&gt; *aOutFrames) {
<span class="lineNum">    1289 </span>            :     nsPoint rectCenter(aRect.x + aRect.width / 2, aRect.y + aRect.height / 2);
<span class="lineNum">    1290 </span>            :     static_cast&lt;nsBoxFrame*&gt;(mFrame)-&gt;
<span class="lineNum">    1291 </span>            :       DisplayDebugInfoFor(this, rectCenter - ToReferenceFrame());
<span class="lineNum">    1292 </span>            :     aOutFrames-&gt;AppendElement(this);
<span class="lineNum">    1293 </span>            :   }
<span class="lineNum">    1294 </span>            :   virtual void Paint(nsDisplayListBuilder* aBuilder
<span class="lineNum">    1295 </span>            :                      gfxContext* aCtx);
<span class="lineNum">    1296 </span>            :   NS_DISPLAY_DECL_NAME(&quot;XULDebug&quot;, TYPE_XUL_DEBUG)
<span class="lineNum">    1297 </span>            : };
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : void
<span class="lineNum">    1300 </span>            : nsDisplayXULDebug::Paint(nsDisplayListBuilder* aBuilder,
<span class="lineNum">    1301 </span>            :                          gfxContext* aCtx)
<span class="lineNum">    1302 </span>            : {
<span class="lineNum">    1303 </span>            :   static_cast&lt;nsBoxFrame*&gt;(mFrame)-&gt;
<span class="lineNum">    1304 </span>            :     PaintXULDebugOverlay(*aCtx-&gt;GetDrawTarget(), ToReferenceFrame());
<span class="lineNum">    1305 </span>            : }
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            : static void
<span class="lineNum">    1308 </span>            : PaintXULDebugBackground(nsIFrame* aFrame, DrawTarget* aDrawTarget,
<span class="lineNum">    1309 </span>            :                         const nsRect&amp; aDirtyRect, nsPoint aPt)
<span class="lineNum">    1310 </span>            : {
<span class="lineNum">    1311 </span>            :   static_cast&lt;nsBoxFrame*&gt;(aFrame)-&gt;PaintXULDebugBackground(aDrawTarget, aPt);
<span class="lineNum">    1312 </span>            : }
<span class="lineNum">    1313 </span>            : #endif
<a name="1314"><span class="lineNum">    1314 </span>            : </a>
<span class="lineNum">    1315 </span>            : void
<span class="lineNum">    1316 </span><span class="lineCov">       1916 : nsBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    1317 </span>            :                              const nsRect&amp;           aDirtyRect,
<span class="lineNum">    1318 </span>            :                              const nsDisplayListSet&amp; aLists)
<span class="lineNum">    1319 </span>            : {
<span class="lineNum">    1320 </span><span class="lineCov">       1916 :   bool forceLayer = false;</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineCov">       1916 :   if (GetContent()-&gt;IsXULElement()) {</span>
<span class="lineNum">    1323 </span>            :     // forcelayer is only supported on XUL elements with box layout
<span class="lineNum">    1324 </span><span class="lineCov">       1796 :     if (GetContent()-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::layer)) {</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :       forceLayer = true;</span>
<span class="lineNum">    1326 </span>            :     }
<span class="lineNum">    1327 </span>            :     // Check for frames that are marked as a part of the region used
<span class="lineNum">    1328 </span>            :     // in calculating glass margins on Windows.
<span class="lineNum">    1329 </span><span class="lineCov">       1796 :     const nsStyleDisplay* styles = StyleDisplay();</span>
<span class="lineNum">    1330 </span><span class="lineCov">       1796 :     if (styles &amp;&amp; styles-&gt;mAppearance == NS_THEME_WIN_EXCLUDE_GLASS) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       aBuilder-&gt;AddWindowExcludeGlassRegion(</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :           nsRect(aBuilder-&gt;ToReferenceFrame(this), GetSize()));</span>
<span class="lineNum">    1333 </span>            :     }
<span class="lineNum">    1334 </span>            :   }
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineCov">       3832 :   nsDisplayListCollection tempLists;</span>
<span class="lineNum">    1337 </span><span class="lineCov">       1916 :   const nsDisplayListSet&amp; destination = forceLayer ? tempLists : aLists;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">       1916 :   DisplayBorderBackgroundOutline(aBuilder, destination);</span>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1342 </span>            :   if (mState &amp; NS_STATE_CURRENTLY_IN_DEBUG) {
<span class="lineNum">    1343 </span>            :     destination.BorderBackground()-&gt;AppendNewToTop(new (aBuilder)
<span class="lineNum">    1344 </span>            :       nsDisplayGeneric(aBuilder, this, PaintXULDebugBackground,
<span class="lineNum">    1345 </span>            :                        &quot;XULDebugBackground&quot;));
<span class="lineNum">    1346 </span>            :     destination.Outlines()-&gt;AppendNewToTop(new (aBuilder)
<span class="lineNum">    1347 </span>            :       nsDisplayXULDebug(aBuilder, this));
<span class="lineNum">    1348 </span>            :   }
<span class="lineNum">    1349 </span>            : #endif
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineCov">       3832 :   Maybe&lt;nsDisplayListBuilder::AutoContainerASRTracker&gt; contASRTracker;</span>
<span class="lineNum">    1352 </span><span class="lineCov">       1916 :   if (forceLayer) {</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     contASRTracker.emplace(aBuilder);</span>
<span class="lineNum">    1354 </span>            :   }
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span><span class="lineCov">       1916 :   BuildDisplayListForChildren(aBuilder, aDirtyRect, destination);</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :   // see if we have to draw a selection frame around this container
<span class="lineNum">    1359 </span><span class="lineCov">       1916 :   DisplaySelectionOverlay(aBuilder, destination.Content());</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineCov">       1916 :   if (forceLayer) {</span>
<span class="lineNum">    1362 </span>            :     // This is a bit of a hack. Collect up all descendant display items
<span class="lineNum">    1363 </span>            :     // and merge them into a single Content() list. This can cause us
<span class="lineNum">    1364 </span>            :     // to violate CSS stacking order, but forceLayer is a magic
<span class="lineNum">    1365 </span>            :     // XUL-only extension anyway.
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     nsDisplayList masterList;</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.BorderBackground());</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.BlockBorderBackgrounds());</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.Floats());</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.Content());</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.PositionedDescendants());</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     masterList.AppendToTop(tempLists.Outlines());</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     const ActiveScrolledRoot* ownLayerASR = contASRTracker-&gt;GetContainerASR();</span>
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :     DisplayListClipState::AutoSaveRestore ownLayerClipState(aBuilder);</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     ownLayerClipState.ClearUpToASR(ownLayerASR);</span>
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :     // Wrap the list to make it its own layer
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     aLists.Content()-&gt;AppendNewToTop(new (aBuilder)</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :       nsDisplayOwnLayer(aBuilder, this, &amp;masterList, ownLayerASR));</span>
<span class="lineNum">    1382 </span>            :   }
<span class="lineNum">    1383 </span><span class="lineCov">       1916 : }</span>
<a name="1384"><span class="lineNum">    1384 </span>            : </a>
<span class="lineNum">    1385 </span>            : void
<span class="lineNum">    1386 </span><span class="lineCov">       1745 : nsBoxFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    1387 </span>            :                                         const nsRect&amp;           aDirtyRect,
<span class="lineNum">    1388 </span>            :                                         const nsDisplayListSet&amp; aLists)
<span class="lineNum">    1389 </span>            : {
<span class="lineNum">    1390 </span><span class="lineCov">       1745 :   nsIFrame* kid = mFrames.FirstChild();</span>
<span class="lineNum">    1391 </span>            :   // Put each child's background onto the BlockBorderBackgrounds list
<span class="lineNum">    1392 </span>            :   // to emulate the existing two-layer XUL painting scheme.
<span class="lineNum">    1393 </span><span class="lineCov">       1745 :   nsDisplayListSet set(aLists, aLists.BlockBorderBackgrounds());</span>
<span class="lineNum">    1394 </span>            :   // The children should be in the right order
<span class="lineNum">    1395 </span><span class="lineCov">       9479 :   while (kid) {</span>
<span class="lineNum">    1396 </span><span class="lineCov">       3867 :     BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set);</span>
<span class="lineNum">    1397 </span><span class="lineCov">       3867 :     kid = kid-&gt;GetNextSibling();</span>
<span class="lineNum">    1398 </span>            :   }
<span class="lineNum">    1399 </span><span class="lineCov">       1745 : }</span>
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            : // REVIEW: PaintChildren did a few things none of which are a big deal
<span class="lineNum">    1402 </span>            : // anymore:
<span class="lineNum">    1403 </span>            : // * Paint some debugging rects for this frame.
<span class="lineNum">    1404 </span>            : // This is done by nsDisplayXULDebugBackground, which goes in the
<span class="lineNum">    1405 </span>            : // BorderBackground() layer so it isn't clipped by OVERFLOW_CLIP.
<span class="lineNum">    1406 </span>            : // * Apply OVERFLOW_CLIP to the children.
<span class="lineNum">    1407 </span>            : // This is now in nsFrame::BuildDisplayListForStackingContext/Child.
<span class="lineNum">    1408 </span>            : // * Actually paint the children.
<span class="lineNum">    1409 </span>            : // Moved to BuildDisplayList.
<span class="lineNum">    1410 </span>            : // * Paint per-kid debug information.
<span class="lineNum">    1411 </span>            : // This is done by nsDisplayXULDebug, which is in the Outlines()
<span class="lineNum">    1412 </span>            : // layer so it goes on top. This means it is not clipped by OVERFLOW_CLIP,
<span class="lineNum">    1413 </span>            : // whereas it did used to respect OVERFLOW_CLIP, but too bad.
<span class="lineNum">    1414 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1415 </span>            : void
<span class="lineNum">    1416 </span>            : nsBoxFrame::PaintXULDebugBackground(DrawTarget* aDrawTarget, nsPoint aPt)
<span class="lineNum">    1417 </span>            : {
<span class="lineNum">    1418 </span>            :   nsMargin border;
<span class="lineNum">    1419 </span>            :   GetXULBorder(border);
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span>            :   nsMargin debugBorder;
<span class="lineNum">    1422 </span>            :   nsMargin debugMargin;
<span class="lineNum">    1423 </span>            :   nsMargin debugPadding;
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            :   bool isHorizontal = IsXULHorizontal();
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            :   GetDebugBorder(debugBorder);
<span class="lineNum">    1428 </span>            :   PixelMarginToTwips(debugBorder);
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :   GetDebugMargin(debugMargin);
<span class="lineNum">    1431 </span>            :   PixelMarginToTwips(debugMargin);
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :   GetDebugPadding(debugPadding);
<span class="lineNum">    1434 </span>            :   PixelMarginToTwips(debugPadding);
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            :   nsRect inner(mRect);
<span class="lineNum">    1437 </span>            :   inner.MoveTo(aPt);
<span class="lineNum">    1438 </span>            :   inner.Deflate(debugMargin);
<span class="lineNum">    1439 </span>            :   inner.Deflate(border);
<span class="lineNum">    1440 </span>            :   //nsRect borderRect(inner);
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :   int32_t appUnitsPerDevPixel = PresContext()-&gt;AppUnitsPerDevPixel();
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span>            :   ColorPattern color(ToDeviceColor(isHorizontal ? Color(0.f, 0.f, 1.f, 1.f) :
<span class="lineNum">    1445 </span>            :                                                   Color(1.f, 0.f, 0.f, 1.f)));
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :   //left
<span class="lineNum">    1448 </span>            :   nsRect r(inner);
<span class="lineNum">    1449 </span>            :   r.width = debugBorder.left;
<span class="lineNum">    1450 </span>            :   aDrawTarget-&gt;FillRect(NSRectToRect(r, appUnitsPerDevPixel), color);
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :   // top
<span class="lineNum">    1453 </span>            :   r = inner;
<span class="lineNum">    1454 </span>            :   r.height = debugBorder.top;
<span class="lineNum">    1455 </span>            :   aDrawTarget-&gt;FillRect(NSRectToRect(r, appUnitsPerDevPixel), color);
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            :   //right
<span class="lineNum">    1458 </span>            :   r = inner;
<span class="lineNum">    1459 </span>            :   r.x = r.x + r.width - debugBorder.right;
<span class="lineNum">    1460 </span>            :   r.width = debugBorder.right;
<span class="lineNum">    1461 </span>            :   aDrawTarget-&gt;FillRect(NSRectToRect(r, appUnitsPerDevPixel), color);
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            :   //bottom
<span class="lineNum">    1464 </span>            :   r = inner;
<span class="lineNum">    1465 </span>            :   r.y = r.y + r.height - debugBorder.bottom;
<span class="lineNum">    1466 </span>            :   r.height = debugBorder.bottom;
<span class="lineNum">    1467 </span>            :   aDrawTarget-&gt;FillRect(NSRectToRect(r, appUnitsPerDevPixel), color);
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :   // If we have dirty children or we are dirty place a green border around us.
<span class="lineNum">    1470 </span>            :   if (NS_SUBTREE_DIRTY(this)) {
<span class="lineNum">    1471 </span>            :     nsRect dirty(inner);
<span class="lineNum">    1472 </span>            :     ColorPattern green(ToDeviceColor(Color(0.f, 1.f, 0.f, 1.f)));
<span class="lineNum">    1473 </span>            :     aDrawTarget-&gt;StrokeRect(NSRectToRect(dirty, appUnitsPerDevPixel), green);
<span class="lineNum">    1474 </span>            :   }
<span class="lineNum">    1475 </span>            : }
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            : void
<span class="lineNum">    1478 </span>            : nsBoxFrame::PaintXULDebugOverlay(DrawTarget&amp; aDrawTarget, nsPoint aPt)
<span class="lineNum">    1479 </span>            : {
<span class="lineNum">    1480 </span>            :   nsMargin border;
<span class="lineNum">    1481 </span>            :   GetXULBorder(border);
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :   nsMargin debugMargin;
<span class="lineNum">    1484 </span>            :   GetDebugMargin(debugMargin);
<span class="lineNum">    1485 </span>            :   PixelMarginToTwips(debugMargin);
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            :   nsRect inner(mRect);
<span class="lineNum">    1488 </span>            :   inner.MoveTo(aPt);
<span class="lineNum">    1489 </span>            :   inner.Deflate(debugMargin);
<span class="lineNum">    1490 </span>            :   inner.Deflate(border);
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            :   nscoord onePixel = GetPresContext()-&gt;IntScaledPixelsToTwips(1);
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :   kid = nsBox::GetChildXULBox(this);
<span class="lineNum">    1495 </span>            :   while (nullptr != kid) {
<span class="lineNum">    1496 </span>            :     bool isHorizontal = IsXULHorizontal();
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span>            :     nscoord x, y, borderSize, spacerSize;
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :     nsRect cr(kid-&gt;mRect);
<span class="lineNum">    1501 </span>            :     nsMargin margin;
<span class="lineNum">    1502 </span>            :     kid-&gt;GetXULMargin(margin);
<span class="lineNum">    1503 </span>            :     cr.Inflate(margin);
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :     if (isHorizontal)
<span class="lineNum">    1506 </span>            :     {
<span class="lineNum">    1507 </span>            :         cr.y = inner.y;
<span class="lineNum">    1508 </span>            :         x = cr.x;
<span class="lineNum">    1509 </span>            :         y = cr.y + onePixel;
<span class="lineNum">    1510 </span>            :         spacerSize = debugBorder.top - onePixel*4;
<span class="lineNum">    1511 </span>            :     } else {
<span class="lineNum">    1512 </span>            :         cr.x = inner.x;
<span class="lineNum">    1513 </span>            :         x = cr.y;
<span class="lineNum">    1514 </span>            :         y = cr.x + onePixel;
<span class="lineNum">    1515 </span>            :         spacerSize = debugBorder.left - onePixel*4;
<span class="lineNum">    1516 </span>            :     }
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span>            :     nscoord flex = kid-&gt;GetXULFlex();
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span>            :     if (!kid-&gt;IsXULCollapsed()) {
<span class="lineNum">    1521 </span>            :       if (isHorizontal)
<span class="lineNum">    1522 </span>            :           borderSize = cr.width;
<span class="lineNum">    1523 </span>            :       else
<span class="lineNum">    1524 </span>            :           borderSize = cr.height;
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :       DrawSpacer(GetPresContext(), aDrawTarget, isHorizontal, flex, x, y, borderSize, spacerSize);
<span class="lineNum">    1527 </span>            :     }
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span>            :     kid = GetNextXULBox(kid);
<span class="lineNum">    1530 </span>            :   }
<span class="lineNum">    1531 </span>            : }
<span class="lineNum">    1532 </span>            : #endif
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1535 </span>            : void
<span class="lineNum">    1536 </span>            : nsBoxFrame::GetBoxName(nsAutoString&amp; aName)
<span class="lineNum">    1537 </span>            : {
<span class="lineNum">    1538 </span>            :    GetFrameName(aName);
<span class="lineNum">    1539 </span>            : }
<span class="lineNum">    1540 </span>            : #endif
<span class="lineNum">    1541 </span>            : 
<a name="1542"><span class="lineNum">    1542 </span>            : #ifdef DEBUG_FRAME_DUMP</a>
<span class="lineNum">    1543 </span>            : nsresult
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 : nsBoxFrame::GetFrameName(nsAString&amp; aResult) const</span>
<span class="lineNum">    1545 </span>            : {
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   return MakeFrameName(NS_LITERAL_STRING(&quot;Box&quot;), aResult);</span>
<span class="lineNum">    1547 </span>            : }
<span class="lineNum">    1548 </span>            : #endif
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1551 </span>            : nsresult
<span class="lineNum">    1552 </span>            : nsBoxFrame::GetXULDebug(bool&amp; aDebug)
<span class="lineNum">    1553 </span>            : {
<span class="lineNum">    1554 </span>            :   aDebug = (mState &amp; NS_STATE_CURRENTLY_IN_DEBUG);
<span class="lineNum">    1555 </span>            :   return NS_OK;
<span class="lineNum">    1556 </span>            : }
<span class="lineNum">    1557 </span>            : #endif
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            : // REVIEW: nsBoxFrame::GetFrameForPoint is a problem because of 'mousethrough'
<span class="lineNum">    1560 </span>            : // attribute support. Here's how it works:
<span class="lineNum">    1561 </span>            : // * For each child frame F, we determine the target frame T(F) by recursively
<span class="lineNum">    1562 </span>            : // invoking GetFrameForPoint on the child
<span class="lineNum">    1563 </span>            : // * Let F' be the last child frame such that T(F') doesn't have mousethrough.
<span class="lineNum">    1564 </span>            : // If F' exists, return T(F')
<span class="lineNum">    1565 </span>            : // * Otherwise let F'' be the first child frame such that T(F'') is non-null.
<span class="lineNum">    1566 </span>            : // If F'' exists, return T(F'')
<span class="lineNum">    1567 </span>            : // * Otherwise return this frame, if this frame contains the point
<span class="lineNum">    1568 </span>            : // * Otherwise return null
<span class="lineNum">    1569 </span>            : // It's not clear how this should work for more complex z-ordering situations.
<span class="lineNum">    1570 </span>            : // The basic principle seems to be that if a frame F has a descendant
<span class="lineNum">    1571 </span>            : // 'mousethrough' frame that includes the target position, then F
<span class="lineNum">    1572 </span>            : // will not receive events (unless it overrides GetFrameForPoint).
<span class="lineNum">    1573 </span>            : // A 'mousethrough' frame will only receive an event if, after applying that rule,
<span class="lineNum">    1574 </span>            : // all eligible frames are 'mousethrough'; the bottom-most inner-most 'mousethrough'
<span class="lineNum">    1575 </span>            : // frame is then chosen (the first eligible frame reached in a
<span class="lineNum">    1576 </span>            : // traversal of the frame tree --- pre/post is irrelevant since ancestors
<span class="lineNum">    1577 </span>            : // of the mousethrough frames can't be eligible).
<span class="lineNum">    1578 </span>            : // IMHO this is very bogus and adds a great deal of complexity for something
<span class="lineNum">    1579 </span>            : // that is very rarely used. So I'm redefining 'mousethrough' to the following:
<span class="lineNum">    1580 </span>            : // a frame with mousethrough is transparent to mouse events. This is compatible
<span class="lineNum">    1581 </span>            : // with the way 'mousethrough' is used in Seamonkey's navigator.xul and
<span class="lineNum">    1582 </span>            : // Firefox's browser.xul. The only other place it's used is in the 'expander'
<span class="lineNum">    1583 </span>            : // XBL binding, which in our tree is only used by Thunderbird SMIME Advanced
<span class="lineNum">    1584 </span>            : // Preferences, and I can't figure out what that does, so I'll have to test it.
<span class="lineNum">    1585 </span>            : // If it's broken I'll probably just change the binding to use it more sensibly.
<span class="lineNum">    1586 </span>            : // This new behaviour is implemented in nsDisplayList::HitTest.
<span class="lineNum">    1587 </span>            : // REVIEW: This debug-box stuff is annoying. I'm just going to put debug boxes
<span class="lineNum">    1588 </span>            : // in the outline layer and avoid GetDebugBoxAt.
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            : // REVIEW: GetCursor had debug-only event dumping code. I have replaced it
<span class="lineNum">    1591 </span>            : // with instrumentation in nsDisplayXULDebug.
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            : #ifdef DEBUG_LAYOUT
<span class="lineNum">    1594 </span>            : void
<span class="lineNum">    1595 </span>            : nsBoxFrame::DrawLine(DrawTarget&amp; aDrawTarget, bool aHorizontal, nscoord x1, nscoord y1, nscoord x2, nscoord y2)
<span class="lineNum">    1596 </span>            : {
<span class="lineNum">    1597 </span>            :     nsPoint p1(x1, y1);
<span class="lineNum">    1598 </span>            :     nsPoint p2(x2, y2);
<span class="lineNum">    1599 </span>            :     if (!aHorizontal) {
<span class="lineNum">    1600 </span>            :       Swap(p1.x, p1.y);
<span class="lineNum">    1601 </span>            :       Swap(p2.x, p2.y);
<span class="lineNum">    1602 </span>            :     }
<span class="lineNum">    1603 </span>            :     ColorPattern white(ToDeviceColor(Color(1.f, 1.f, 1.f, 1.f)));
<span class="lineNum">    1604 </span>            :     StrokeLineWithSnapping(p1, p2, PresContext()-&gt;AppUnitsPerDevPixel(),
<span class="lineNum">    1605 </span>            :                            aDrawTarget, color);
<span class="lineNum">    1606 </span>            : }
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            : void
<span class="lineNum">    1609 </span>            : nsBoxFrame::FillRect(DrawTarget&amp; aDrawTarget, bool aHorizontal, nscoord x, nscoord y, nscoord width, nscoord height)
<span class="lineNum">    1610 </span>            : {
<span class="lineNum">    1611 </span>            :     Rect rect = NSRectToSnappedRect(aHorizontal ? nsRect(x, y, width, height) :
<span class="lineNum">    1612 </span>            :                                                   nsRect(y, x, height, width),
<span class="lineNum">    1613 </span>            :                                     PresContext()-&gt;AppUnitsPerDevPixel(),
<span class="lineNum">    1614 </span>            :                                     aDrawTarget);
<span class="lineNum">    1615 </span>            :     ColorPattern white(ToDeviceColor(Color(1.f, 1.f, 1.f, 1.f)));
<span class="lineNum">    1616 </span>            :     aDrawTarget.FillRect(rect, white);
<span class="lineNum">    1617 </span>            : }
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            : void
<span class="lineNum">    1620 </span>            : nsBoxFrame::DrawSpacer(nsPresContext* aPresContext, DrawTarget&amp; aDrawTarget,
<span class="lineNum">    1621 </span>            :                        bool aHorizontal, int32_t flex, nscoord x, nscoord y,
<span class="lineNum">    1622 </span>            :                        nscoord size, nscoord spacerSize)
<span class="lineNum">    1623 </span>            : {
<span class="lineNum">    1624 </span>            :          nscoord onePixel = aPresContext-&gt;IntScaledPixelsToTwips(1);
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :      // if we do draw the coils
<span class="lineNum">    1627 </span>            :         int distance = 0;
<span class="lineNum">    1628 </span>            :         int center = 0;
<span class="lineNum">    1629 </span>            :         int offset = 0;
<span class="lineNum">    1630 </span>            :         int coilSize = COIL_SIZE*onePixel;
<span class="lineNum">    1631 </span>            :         int halfSpacer = spacerSize/2;
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :         distance = size;
<span class="lineNum">    1634 </span>            :         center = y + halfSpacer;
<span class="lineNum">    1635 </span>            :         offset = x;
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span>            :         int coils = distance/coilSize;
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span>            :         int halfCoilSize = coilSize/2;
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span>            :         if (flex == 0) {
<span class="lineNum">    1642 </span>            :             DrawLine(aDrawTarget, aHorizontal, x,y + spacerSize/2, x + size, y + spacerSize/2);
<span class="lineNum">    1643 </span>            :         } else {
<span class="lineNum">    1644 </span>            :             for (int i=0; i &lt; coils; i++)
<span class="lineNum">    1645 </span>            :             {
<span class="lineNum">    1646 </span>            :                    DrawLine(aDrawTarget, aHorizontal, offset, center+halfSpacer, offset+halfCoilSize, center-halfSpacer);
<span class="lineNum">    1647 </span>            :                    DrawLine(aDrawTarget, aHorizontal, offset+halfCoilSize, center-halfSpacer, offset+coilSize, center+halfSpacer);
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            :                    offset += coilSize;
<span class="lineNum">    1650 </span>            :             }
<span class="lineNum">    1651 </span>            :         }
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :         FillRect(aDrawTarget, aHorizontal, x + size - spacerSize/2, y, spacerSize/2, spacerSize);
<span class="lineNum">    1654 </span>            :         FillRect(aDrawTarget, aHorizontal, x, y, spacerSize/2, spacerSize);
<span class="lineNum">    1655 </span>            : }
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            : void
<span class="lineNum">    1658 </span>            : nsBoxFrame::GetDebugBorder(nsMargin&amp; aInset)
<span class="lineNum">    1659 </span>            : {
<span class="lineNum">    1660 </span>            :     aInset.SizeTo(2,2,2,2);
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span>            :     if (IsXULHorizontal())
<span class="lineNum">    1663 </span>            :        aInset.top = 10;
<span class="lineNum">    1664 </span>            :     else
<span class="lineNum">    1665 </span>            :        aInset.left = 10;
<span class="lineNum">    1666 </span>            : }
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            : void
<span class="lineNum">    1669 </span>            : nsBoxFrame::GetDebugMargin(nsMargin&amp; aInset)
<span class="lineNum">    1670 </span>            : {
<span class="lineNum">    1671 </span>            :     aInset.SizeTo(2,2,2,2);
<span class="lineNum">    1672 </span>            : }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            : void
<span class="lineNum">    1675 </span>            : nsBoxFrame::GetDebugPadding(nsMargin&amp; aPadding)
<span class="lineNum">    1676 </span>            : {
<span class="lineNum">    1677 </span>            :     aPadding.SizeTo(2,2,2,2);
<span class="lineNum">    1678 </span>            : }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            : void
<span class="lineNum">    1681 </span>            : nsBoxFrame::PixelMarginToTwips(nsMargin&amp; aMarginPixels)
<span class="lineNum">    1682 </span>            : {
<span class="lineNum">    1683 </span>            :   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
<span class="lineNum">    1684 </span>            :   aMarginPixels.left   *= onePixel;
<span class="lineNum">    1685 </span>            :   aMarginPixels.right  *= onePixel;
<span class="lineNum">    1686 </span>            :   aMarginPixels.top    *= onePixel;
<span class="lineNum">    1687 </span>            :   aMarginPixels.bottom *= onePixel;
<span class="lineNum">    1688 </span>            : }
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : void
<span class="lineNum">    1691 </span>            : nsBoxFrame::GetValue(nsPresContext* aPresContext, const nsSize&amp; a, const nsSize&amp; b, char* ch)
<span class="lineNum">    1692 </span>            : {
<span class="lineNum">    1693 </span>            :     float p2t = aPresContext-&gt;ScaledPixelsToTwips();
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span>            :     char width[100];
<span class="lineNum">    1696 </span>            :     char height[100];
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span>            :     if (a.width == NS_INTRINSICSIZE)
<span class="lineNum">    1699 </span>            :         sprintf(width,&quot;%s&quot;,&quot;INF&quot;);
<span class="lineNum">    1700 </span>            :     else
<span class="lineNum">    1701 </span>            :         sprintf(width,&quot;%d&quot;, nscoord(a.width/*/p2t*/));
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            :     if (a.height == NS_INTRINSICSIZE)
<span class="lineNum">    1704 </span>            :         sprintf(height,&quot;%s&quot;,&quot;INF&quot;);
<span class="lineNum">    1705 </span>            :     else
<span class="lineNum">    1706 </span>            :         sprintf(height,&quot;%d&quot;, nscoord(a.height/*/p2t*/));
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span>            :     sprintf(ch, &quot;(%s%s, %s%s)&quot;, width, (b.width != NS_INTRINSICSIZE ? &quot;[SET]&quot; : &quot;&quot;),
<span class="lineNum">    1710 </span>            :                     height, (b.height != NS_INTRINSICSIZE ? &quot;[SET]&quot; : &quot;&quot;));
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            : }
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            : void
<span class="lineNum">    1715 </span>            : nsBoxFrame::GetValue(nsPresContext* aPresContext, int32_t a, int32_t b, char* ch)
<span class="lineNum">    1716 </span>            : {
<span class="lineNum">    1717 </span>            :     if (a == NS_INTRINSICSIZE)
<span class="lineNum">    1718 </span>            :       sprintf(ch, &quot;%d[SET]&quot;, b);
<span class="lineNum">    1719 </span>            :     else
<span class="lineNum">    1720 </span>            :       sprintf(ch, &quot;%d&quot;, a);
<span class="lineNum">    1721 </span>            : }
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            : nsresult
<span class="lineNum">    1724 </span>            : nsBoxFrame::DisplayDebugInfoFor(nsIFrame*  aBox,
<span class="lineNum">    1725 </span>            :                                 nsPoint&amp; aPoint)
<span class="lineNum">    1726 </span>            : {
<span class="lineNum">    1727 </span>            :     nsBoxLayoutState state(GetPresContext());
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :     nscoord x = aPoint.x;
<span class="lineNum">    1730 </span>            :     nscoord y = aPoint.y;
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :     // get the area inside our border but not our debug margins.
<span class="lineNum">    1733 </span>            :     nsRect insideBorder(aBox-&gt;mRect);
<span class="lineNum">    1734 </span>            :     insideBorder.MoveTo(0,0):
<span class="lineNum">    1735 </span>            :     nsMargin border(0,0,0,0);
<span class="lineNum">    1736 </span>            :     aBox-&gt;GetXULBorderAndPadding(border);
<span class="lineNum">    1737 </span>            :     insideBorder.Deflate(border);
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span>            :     bool isHorizontal = IsXULHorizontal();
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :     if (!insideBorder.Contains(nsPoint(x,y)))
<span class="lineNum">    1742 </span>            :         return NS_ERROR_FAILURE;
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span>            :     //printf(&quot;%%%%%% inside box %%%%%%%\n&quot;);
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :     int count = 0;
<span class="lineNum">    1747 </span>            :     nsIFrame* child = nsBox::GetChildXULBox(aBox);
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span>            :     nsMargin m;
<span class="lineNum">    1750 </span>            :     nsMargin m2;
<span class="lineNum">    1751 </span>            :     GetDebugBorder(m);
<span class="lineNum">    1752 </span>            :     PixelMarginToTwips(m);
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            :     GetDebugMargin(m2);
<span class="lineNum">    1755 </span>            :     PixelMarginToTwips(m2);
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :     m += m2;
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span>            :     if ((isHorizontal &amp;&amp; y &lt; insideBorder.y + m.top) ||
<span class="lineNum">    1760 </span>            :         (!isHorizontal &amp;&amp; x &lt; insideBorder.x + m.left)) {
<span class="lineNum">    1761 </span>            :         //printf(&quot;**** inside debug border *******\n&quot;);
<span class="lineNum">    1762 </span>            :         while (child)
<span class="lineNum">    1763 </span>            :         {
<span class="lineNum">    1764 </span>            :             const nsRect&amp; r = child-&gt;mRect;
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :             // if we are not in the child. But in the spacer above the child.
<span class="lineNum">    1767 </span>            :             if ((isHorizontal &amp;&amp; x &gt;= r.x &amp;&amp; x &lt; r.x + r.width) ||
<span class="lineNum">    1768 </span>            :                 (!isHorizontal &amp;&amp; y &gt;= r.y &amp;&amp; y &lt; r.y + r.height)) {
<span class="lineNum">    1769 </span>            :                 aCursor = NS_STYLE_CURSOR_POINTER;
<span class="lineNum">    1770 </span>            :                    // found it but we already showed it.
<span class="lineNum">    1771 </span>            :                     if (mDebugChild == child)
<span class="lineNum">    1772 </span>            :                         return NS_OK;
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :                     if (aBox-&gt;GetContent()) {
<span class="lineNum">    1775 </span>            :                       printf(&quot;---------------\n&quot;);
<span class="lineNum">    1776 </span>            :                       XULDumpBox(stdout);
<span class="lineNum">    1777 </span>            :                       printf(&quot;\n&quot;);
<span class="lineNum">    1778 </span>            :                     }
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            :                     if (child-&gt;GetContent()) {
<span class="lineNum">    1781 </span>            :                         printf(&quot;child #%d: &quot;, count);
<span class="lineNum">    1782 </span>            :                         child-&gt;XULDumpBox(stdout);
<span class="lineNum">    1783 </span>            :                         printf(&quot;\n&quot;);
<span class="lineNum">    1784 </span>            :                     }
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :                     mDebugChild = child;
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span>            :                     nsSize prefSizeCSS(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
<span class="lineNum">    1789 </span>            :                     nsSize minSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
<span class="lineNum">    1790 </span>            :                     nsSize maxSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
<span class="lineNum">    1791 </span>            :                     nscoord flexCSS = NS_INTRINSICSIZE;
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :                     bool widthSet, heightSet;
<span class="lineNum">    1794 </span>            :                     nsIFrame::AddXULPrefSize(child, prefSizeCSS, widthSet, heightSet);
<span class="lineNum">    1795 </span>            :                     nsIFrame::AddXULMinSize (state, child, minSizeCSS, widthSet, heightSet);
<span class="lineNum">    1796 </span>            :                     nsIFrame::AddXULMaxSize (child, maxSizeCSS, widthSet, heightSet);
<span class="lineNum">    1797 </span>            :                     nsIFrame::AddXULFlex    (child, flexCSS);
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span>            :                     nsSize prefSize = child-&gt;GetXULPrefSize(state);
<span class="lineNum">    1800 </span>            :                     nsSize minSize = child-&gt;GetXULMinSize(state);
<span class="lineNum">    1801 </span>            :                     nsSize maxSize = child-&gt;GetXULMaxSize(state);
<span class="lineNum">    1802 </span>            :                     nscoord flexSize = child-&gt;GetXULFlex();
<span class="lineNum">    1803 </span>            :                     nscoord ascentSize = child-&gt;GetXULBoxAscent(state);
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            :                     char min[100];
<span class="lineNum">    1806 </span>            :                     char pref[100];
<span class="lineNum">    1807 </span>            :                     char max[100];
<span class="lineNum">    1808 </span>            :                     char calc[100];
<span class="lineNum">    1809 </span>            :                     char flex[100];
<span class="lineNum">    1810 </span>            :                     char ascent[100];
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            :                     nsSize actualSize;
<span class="lineNum">    1813 </span>            :                     GetFrameSizeWithMargin(child, actualSize);
<span class="lineNum">    1814 </span>            :                     nsSize actualSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            :                     GetValue(aPresContext, minSize,  minSizeCSS, min);
<span class="lineNum">    1817 </span>            :                     GetValue(aPresContext, prefSize, prefSizeCSS, pref);
<span class="lineNum">    1818 </span>            :                     GetValue(aPresContext, maxSize,  maxSizeCSS, max);
<span class="lineNum">    1819 </span>            :                     GetValue(aPresContext, actualSize, actualSizeCSS, calc);
<span class="lineNum">    1820 </span>            :                     GetValue(aPresContext, flexSize,  flexCSS, flex);
<span class="lineNum">    1821 </span>            :                     GetValue(aPresContext, ascentSize,  NS_INTRINSICSIZE, ascent);
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :                     printf(&quot;min%s, pref%s, max%s, actual%s, flex=%s, ascent=%s\n\n&quot;,
<span class="lineNum">    1825 </span>            :                         min,
<span class="lineNum">    1826 </span>            :                         pref,
<span class="lineNum">    1827 </span>            :                         max,
<span class="lineNum">    1828 </span>            :                         calc,
<span class="lineNum">    1829 </span>            :                         flex,
<span class="lineNum">    1830 </span>            :                         ascent
<span class="lineNum">    1831 </span>            :                     );
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            :                     return NS_OK;
<span class="lineNum">    1834 </span>            :             }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :           child = GetNextXULBox(child);
<span class="lineNum">    1837 </span>            :           count++;
<span class="lineNum">    1838 </span>            :         }
<span class="lineNum">    1839 </span>            :     } else {
<span class="lineNum">    1840 </span>            :     }
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span>            :     mDebugChild = nullptr;
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            :     return NS_OK;
<span class="lineNum">    1845 </span>            : }
<span class="lineNum">    1846 </span>            : 
<span class="lineNum">    1847 </span>            : void
<span class="lineNum">    1848 </span>            : nsBoxFrame::SetDebugOnChildList(nsBoxLayoutState&amp; aState, nsIFrame* aChild, bool aDebug)
<span class="lineNum">    1849 </span>            : {
<span class="lineNum">    1850 </span>            :     nsIFrame* child = nsBox::GetChildXULBox(this);
<span class="lineNum">    1851 </span>            :      while (child)
<span class="lineNum">    1852 </span>            :      {
<span class="lineNum">    1853 </span>            :         child-&gt;SetXULDebug(aState, aDebug);
<span class="lineNum">    1854 </span>            :         child = GetNextXULBox(child);
<span class="lineNum">    1855 </span>            :      }
<span class="lineNum">    1856 </span>            : }
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span>            : nsresult
<span class="lineNum">    1859 </span>            : nsBoxFrame::GetFrameSizeWithMargin(nsIFrame* aBox, nsSize&amp; aSize)
<span class="lineNum">    1860 </span>            : {
<span class="lineNum">    1861 </span>            :   nsRect rect(aBox-&gt;GetRect());
<span class="lineNum">    1862 </span>            :   nsMargin margin(0,0,0,0);
<span class="lineNum">    1863 </span>            :   aBox-&gt;GetXULMargin(margin);
<span class="lineNum">    1864 </span>            :   rect.Inflate(margin);
<span class="lineNum">    1865 </span>            :   aSize.width = rect.width;
<span class="lineNum">    1866 </span>            :   aSize.height = rect.height;
<span class="lineNum">    1867 </span>            :   return NS_OK;
<span class="lineNum">    1868 </span>            : }
<span class="lineNum">    1869 </span>            : #endif
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            : // If you make changes to this function, check its counterparts
<a name="1872"><span class="lineNum">    1872 </span>            : // in nsTextBoxFrame and nsXULLabelFrame</a>
<span class="lineNum">    1873 </span>            : void
<span class="lineNum">    1874 </span><span class="lineCov">        288 : nsBoxFrame::RegUnregAccessKey(bool aDoReg)</span>
<span class="lineNum">    1875 </span>            : {
<span class="lineNum">    1876 </span><span class="lineCov">        288 :   MOZ_ASSERT(mContent);</span>
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span>            :   // only support accesskeys for the following elements
<span class="lineNum">    1879 </span><span class="lineCov">        288 :   if (!mContent-&gt;IsAnyOfXULElements(nsGkAtoms::button,</span>
<span class="lineNum">    1880 </span>            :                                     nsGkAtoms::toolbarbutton,
<span class="lineNum">    1881 </span>            :                                     nsGkAtoms::checkbox,
<span class="lineNum">    1882 </span>            :                                     nsGkAtoms::textbox,
<span class="lineNum">    1883 </span>            :                                     nsGkAtoms::tab,
<span class="lineNum">    1884 </span>            :                                     nsGkAtoms::radio)) {
<span class="lineNum">    1885 </span><span class="lineCov">        520 :     return;</span>
<span class="lineNum">    1886 </span>            :   }
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineCov">         56 :   nsAutoString accessKey;</span>
<span class="lineNum">    1889 </span><span class="lineCov">         56 :   mContent-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);</span>
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineCov">         56 :   if (accessKey.IsEmpty())</span>
<span class="lineNum">    1892 </span><span class="lineCov">         56 :     return;</span>
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :   // With a valid PresContext we can get the ESM
<span class="lineNum">    1895 </span>            :   // and register the access key
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :   EventStateManager* esm = PresContext()-&gt;EventStateManager();</span>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   uint32_t key = accessKey.First();</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   if (aDoReg)</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     esm-&gt;RegisterAccessKey(mContent, key);</span>
<span class="lineNum">    1901 </span>            :   else
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     esm-&gt;UnregisterAccessKey(mContent, key);</span>
<span class="lineNum">    1903 </span>            : }
<a name="1904"><span class="lineNum">    1904 </span>            : </a>
<span class="lineNum">    1905 </span>            : bool
<span class="lineNum">    1906 </span><span class="lineCov">        262 : nsBoxFrame::SupportsOrdinalsInChildren()</span>
<span class="lineNum">    1907 </span>            : {
<span class="lineNum">    1908 </span><span class="lineCov">        262 :   return true;</span>
<span class="lineNum">    1909 </span>            : }
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            : // Helper less-than-or-equal function, used in CheckBoxOrder() as a
<a name="1912"><span class="lineNum">    1912 </span>            : // template-parameter for the sorting functions.</a>
<span class="lineNum">    1913 </span>            : bool
<span class="lineNum">    1914 </span><span class="lineCov">        187 : IsBoxOrdinalLEQ(nsIFrame* aFrame1,</span>
<span class="lineNum">    1915 </span>            :                 nsIFrame* aFrame2)
<span class="lineNum">    1916 </span>            : {
<span class="lineNum">    1917 </span>            :   // If we've got a placeholder frame, use its out-of-flow frame's ordinal val.
<span class="lineNum">    1918 </span><span class="lineCov">        187 :   nsIFrame* aRealFrame1 = nsPlaceholderFrame::GetRealFrameFor(aFrame1);</span>
<span class="lineNum">    1919 </span><span class="lineCov">        187 :   nsIFrame* aRealFrame2 = nsPlaceholderFrame::GetRealFrameFor(aFrame2);</span>
<span class="lineNum">    1920 </span><span class="lineCov">        187 :   return aRealFrame1-&gt;GetXULOrdinal() &lt;= aRealFrame2-&gt;GetXULOrdinal();</span>
<span class="lineNum">    1921 </span>            : }
<a name="1922"><span class="lineNum">    1922 </span>            : </a>
<span class="lineNum">    1923 </span>            : void
<span class="lineNum">    1924 </span><span class="lineCov">        262 : nsBoxFrame::CheckBoxOrder()</span>
<span class="lineNum">    1925 </span>            : {
<span class="lineNum">    1926 </span><span class="lineCov">        524 :   if (SupportsOrdinalsInChildren() &amp;&amp;</span>
<span class="lineNum">    1927 </span><span class="lineCov">        262 :       !nsIFrame::IsFrameListSorted&lt;IsBoxOrdinalLEQ&gt;(mFrames)) {</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     nsIFrame::SortFrameList&lt;IsBoxOrdinalLEQ&gt;(mFrames);</span>
<span class="lineNum">    1929 </span>            :   }
<span class="lineNum">    1930 </span><span class="lineCov">        262 : }</span>
<a name="1931"><span class="lineNum">    1931 </span>            : </a>
<span class="lineNum">    1932 </span>            : nsresult
<span class="lineNum">    1933 </span><span class="lineCov">        141 : nsBoxFrame::LayoutChildAt(nsBoxLayoutState&amp; aState, nsIFrame* aBox, const nsRect&amp; aRect)</span>
<span class="lineNum">    1934 </span>            : {
<span class="lineNum">    1935 </span>            :   // get the current rect
<span class="lineNum">    1936 </span><span class="lineCov">        282 :   nsRect oldRect(aBox-&gt;GetRect());</span>
<span class="lineNum">    1937 </span><span class="lineCov">        141 :   aBox-&gt;SetXULBounds(aState, aRect);</span>
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span><span class="lineCov">        141 :   bool layout = NS_SUBTREE_DIRTY(aBox);</span>
<span class="lineNum">    1940 </span>            : 
<span class="lineNum">    1941 </span><span class="lineCov">        141 :   if (layout || (oldRect.width != aRect.width || oldRect.height != aRect.height))  {</span>
<span class="lineNum">    1942 </span><span class="lineCov">        110 :     return aBox-&gt;XULLayout(aState);</span>
<span class="lineNum">    1943 </span>            :   }
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span><span class="lineCov">         31 :   return NS_OK;</span>
<span class="lineNum">    1946 </span>            : }
<a name="1947"><span class="lineNum">    1947 </span>            : </a>
<span class="lineNum">    1948 </span>            : nsresult
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 : nsBoxFrame::XULRelayoutChildAtOrdinal(nsIFrame* aChild)</span>
<span class="lineNum">    1950 </span>            : {
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :   if (!SupportsOrdinalsInChildren())</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :   uint32_t ord = aChild-&gt;GetXULOrdinal();</span>
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :   nsIFrame* child = mFrames.FirstChild();</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :   nsIFrame* newPrevSib = nullptr;</span>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :   while (child) {</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :     if (ord &lt; child-&gt;GetXULOrdinal()) {</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1962 </span>            :     }
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     if (child != aChild) {</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :       newPrevSib = child;</span>
<span class="lineNum">    1966 </span>            :     }
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :     child = GetNextXULBox(child);</span>
<span class="lineNum">    1969 </span>            :   }
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :   if (aChild-&gt;GetPrevSibling() == newPrevSib) {</span>
<span class="lineNum">    1972 </span>            :     // This box is not moving.
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1974 </span>            :   }
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            :   // Take |aChild| out of its old position in the child list.
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :   mFrames.RemoveFrame(aChild);</span>
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            :   // Insert it after |newPrevSib| or at the start if it's null.
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :   mFrames.InsertFrame(nullptr, newPrevSib, aChild);</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1983 </span>            : }
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span>            : /**
<span class="lineNum">    1986 </span>            :  * This wrapper class lets us redirect mouse hits from descendant frames
<span class="lineNum">    1987 </span>            :  * of a menu to the menu itself, if they didn't specify 'allowevents'.
<span class="lineNum">    1988 </span>            :  *
<span class="lineNum">    1989 </span>            :  * The wrapper simply turns a hit on a descendant element
<span class="lineNum">    1990 </span>            :  * into a hit on the menu itself, unless there is an element between the target
<span class="lineNum">    1991 </span>            :  * and the menu with the &quot;allowevents&quot; attribute.
<span class="lineNum">    1992 </span>            :  *
<span class="lineNum">    1993 </span>            :  * This is used by nsMenuFrame and nsTreeColFrame.
<span class="lineNum">    1994 </span>            :  *
<span class="lineNum">    1995 </span>            :  * Note that turning a hit on a descendant element into nullptr, so events
<span class="lineNum">    1996 </span>            :  * could fall through to the menu background, might be an appealing simplification
<span class="lineNum">    1997 </span>            :  * but it would mean slightly strange behaviour in some cases, because grabber
<span class="lineNum">    1998 </span>            :  * wrappers can be created for many individual lists and items, so the exact
<span class="lineNum">    1999 </span>            :  * fallthrough behaviour would be complex. E.g. an element with &quot;allowevents&quot;
<span class="lineNum">    2000 </span>            :  * on top of the Content() list could receive the event even if it was covered
<span class="lineNum">    2001 </span>            :  * by a PositionedDescenants() element without &quot;allowevents&quot;. It is best to
<span class="lineNum">    2002 </span>            :  * never convert a non-null hit into null.
<span class="lineNum">    2003 </span>            :  */
<span class="lineNum">    2004 </span>            : // REVIEW: This is roughly of what nsMenuFrame::GetFrameForPoint used to do.
<a name="2005"><span class="lineNum">    2005 </span>            : // I've made 'allowevents' affect child elements because that seems the only</a>
<span class="lineNum">    2006 </span>            : // reasonable thing to do.
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 : class nsDisplayXULEventRedirector final : public nsDisplayWrapList</span>
<a name="2008"><span class="lineNum">    2008 </span>            : {</a>
<span class="lineNum">    2009 </span>            : public:
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :   nsDisplayXULEventRedirector(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    2011 </span>            :                               nsIFrame* aFrame, nsDisplayItem* aItem,
<a name="2012"><span class="lineNum">    2012 </span>            :                               nsIFrame* aTargetFrame)</a>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :     : nsDisplayWrapList(aBuilder, aFrame, aItem), mTargetFrame(aTargetFrame) {}</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :   nsDisplayXULEventRedirector(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    2015 </span>            :                               nsIFrame* aFrame, nsDisplayList* aList,
<span class="lineNum">    2016 </span>            :                               nsIFrame* aTargetFrame)
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     : nsDisplayWrapList(aBuilder, aFrame, aList), mTargetFrame(aTargetFrame) {}</span>
<span class="lineNum">    2018 </span>            :   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect&amp; aRect,
<a name="2019"><span class="lineNum">    2019 </span>            :                        HitTestState* aState,</a>
<span class="lineNum">    2020 </span>            :                        nsTArray&lt;nsIFrame*&gt; *aOutFrames) override;
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :   virtual bool ShouldFlattenAway(nsDisplayListBuilder* aBuilder) override {</span>
<a name="2022"><span class="lineNum">    2022 </span><span class="lineNoCov">          0 :     return false;</span></a>
<span class="lineNum">    2023 </span>            :   }
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :   NS_DISPLAY_DECL_NAME(&quot;XULEventRedirector&quot;, TYPE_XUL_EVENT_REDIRECTOR)</span>
<span class="lineNum">    2025 </span>            : private:
<span class="lineNum">    2026 </span>            :   nsIFrame* mTargetFrame;
<a name="2027"><span class="lineNum">    2027 </span>            : };</a>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 : void nsDisplayXULEventRedirector::HitTest(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    2030 </span>            :     const nsRect&amp; aRect, HitTestState* aState, nsTArray&lt;nsIFrame*&gt; *aOutFrames)
<span class="lineNum">    2031 </span>            : {
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :   nsTArray&lt;nsIFrame*&gt; outFrames;</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :   mList.HitTest(aBuilder, aRect, aState, &amp;outFrames);</span>
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :   bool topMostAdded = false;</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :   uint32_t localLength = outFrames.Length();</span>
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; localLength; i++) {</span>
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     for (nsIContent* content = outFrames.ElementAt(i)-&gt;GetContent();</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :          content &amp;&amp; content != mTargetFrame-&gt;GetContent();</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :          content = content-&gt;GetParent()) {</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :       if (content-&gt;AttrValueIs(kNameSpaceID_None, nsGkAtoms::allowevents,</span>
<span class="lineNum">    2044 </span>            :                                nsGkAtoms::_true, eCaseMatters)) {
<span class="lineNum">    2045 </span>            :         // Events are allowed on 'frame', so let it go.
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         aOutFrames-&gt;AppendElement(outFrames.ElementAt(i));</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         topMostAdded = true;</span>
<span class="lineNum">    2048 </span>            :       }
<span class="lineNum">    2049 </span>            :     }
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :     // If there was no hit on the topmost frame or its ancestors,
<span class="lineNum">    2052 </span>            :     // add the target frame itself as the first candidate (see bug 562554).
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :     if (!topMostAdded) {</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :       topMostAdded = true;</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :       aOutFrames-&gt;AppendElement(mTargetFrame);</span>
<span class="lineNum">    2056 </span>            :     }
<span class="lineNum">    2057 </span>            :   }
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : class nsXULEventRedirectorWrapper final : public nsDisplayWrapper
<a name="2061"><span class="lineNum">    2061 </span>            : {</a>
<span class="lineNum">    2062 </span>            : public:
<a name="2063"><span class="lineNum">    2063 </span><span class="lineNoCov">          0 :   explicit nsXULEventRedirectorWrapper(nsIFrame* aTargetFrame)</span></a>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :       : mTargetFrame(aTargetFrame) {}</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    2066 </span>            :                                   nsIFrame* aFrame,
<span class="lineNum">    2067 </span>            :                                   nsDisplayList* aList) override {
<span class="lineNum">    2068 </span>            :     return new (aBuilder)
<a name="2069"><span class="lineNum">    2069 </span><span class="lineNoCov">          0 :         nsDisplayXULEventRedirector(aBuilder, aFrame, aList, mTargetFrame);</span></a>
<span class="lineNum">    2070 </span>            :   }
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    2072 </span>            :                                   nsDisplayItem* aItem) override {
<span class="lineNum">    2073 </span>            :     return new (aBuilder)
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         nsDisplayXULEventRedirector(aBuilder, aItem-&gt;Frame(), aItem,</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :                                     mTargetFrame);</span>
<span class="lineNum">    2076 </span>            :   }
<span class="lineNum">    2077 </span>            : private:
<span class="lineNum">    2078 </span>            :   nsIFrame* mTargetFrame;
<span class="lineNum">    2079 </span>            : };
<a name="2080"><span class="lineNum">    2080 </span>            : </a>
<span class="lineNum">    2081 </span>            : void
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 : nsBoxFrame::WrapListsInRedirector(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    2083 </span>            :                                   const nsDisplayListSet&amp; aIn,
<span class="lineNum">    2084 </span>            :                                   const nsDisplayListSet&amp; aOut)
<span class="lineNum">    2085 </span>            : {
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :   nsXULEventRedirectorWrapper wrapper(this);</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :   wrapper.WrapLists(aBuilder, this, aIn, aOut);</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 : }</span>
<a name="2089"><span class="lineNum">    2089 </span>            : </a>
<span class="lineNum">    2090 </span>            : bool
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 : nsBoxFrame::GetEventPoint(WidgetGUIEvent* aEvent, nsPoint &amp;aPoint) {</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :   LayoutDeviceIntPoint refPoint;</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :   bool res = GetEventPoint(aEvent, refPoint);</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :   aPoint = nsLayoutUtils::GetEventCoordinatesRelativeTo(</span>
<span class="lineNum">    2095 </span>            :     aEvent, refPoint, this);
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :   return res;</span>
<span class="lineNum">    2097 </span>            : }
<a name="2098"><span class="lineNum">    2098 </span>            : </a>
<span class="lineNum">    2099 </span>            : bool
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 : nsBoxFrame::GetEventPoint(WidgetGUIEvent* aEvent, LayoutDeviceIntPoint&amp; aPoint) {</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(aEvent, false);</span>
<span class="lineNum">    2102 </span>            : 
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :   WidgetTouchEvent* touchEvent = aEvent-&gt;AsTouchEvent();</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :   if (touchEvent) {</span>
<span class="lineNum">    2105 </span>            :     // return false if there is more than one touch on the page, or if
<span class="lineNum">    2106 </span>            :     // we can't find a touch point
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :     if (touchEvent-&gt;mTouches.Length() != 1) {</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2109 </span>            :     }
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :     dom::Touch* touch = touchEvent-&gt;mTouches.SafeElementAt(0);</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     if (!touch) {</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2114 </span>            :     }
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :     aPoint = touch-&gt;mRefPoint;</span>
<span class="lineNum">    2116 </span>            :   } else {
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     aPoint = aEvent-&gt;mRefPoint;</span>
<span class="lineNum">    2118 </span>            :   }
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2120 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/painting/nsCSSRenderingGradients.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/painting</a> - nsCSSRenderingGradients.cpp<span style="font-size: 80%;"> (source / <a href="nsCSSRenderingGradients.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">260</td>
            <td class="headerCovTableEntry">513</td>
            <td class="headerCovTableEntryLo">50.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntryMed">75.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : // vim:cindent:ts=2:et:sw=2:
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* utility functions for drawing borders and backgrounds */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;nsCSSRenderingGradients.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;gfx2DGlue.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/ArrayUtils.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/gfx/Helpers.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;nsStyleConsts.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsPoint.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsRect.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsStyleContext.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsCSSColorUtils.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;gfxContext.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsStyleStructInlines.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsCSSProps.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;gfxGradientCache.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &quot;mozilla/layers/StackingContextHelper.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/layers/WebRenderLayerManager.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/webrender/WebRenderTypes.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/webrender/WebRenderAPI.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;Units.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : using namespace mozilla;
<span class="lineNum">      38 </span>            : using namespace mozilla::gfx;
<a name="39"><span class="lineNum">      39 </span>            : </a>
<span class="lineNum">      40 </span>            : static gfxFloat
<span class="lineNum">      41 </span><span class="lineNoCov">          0 : ConvertGradientValueToPixels(const nsStyleCoord&amp; aCoord,</span>
<span class="lineNum">      42 </span>            :                              gfxFloat aFillLength,
<span class="lineNum">      43 </span>            :                              int32_t aAppUnitsPerPixel)
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   switch (aCoord.GetUnit()) {</span>
<span class="lineNum">      46 </span>            :     case eStyleUnit_Percent:
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :       return aCoord.GetPercentValue() * aFillLength;</span>
<span class="lineNum">      48 </span>            :     case eStyleUnit_Coord:
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :       return NSAppUnitsToFloatPixels(aCoord.GetCoordValue(), aAppUnitsPerPixel);</span>
<span class="lineNum">      50 </span>            :     case eStyleUnit_Calc: {
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :       const nsStyleCoord::Calc *calc = aCoord.GetCalcValue();</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :       return calc-&gt;mPercent * aFillLength +</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :              NSAppUnitsToFloatPixels(calc-&gt;mLength, aAppUnitsPerPixel);</span>
<span class="lineNum">      54 </span>            :     }
<span class="lineNum">      55 </span>            :     default:
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :       NS_WARNING(&quot;Unexpected coord unit&quot;);</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">      58 </span>            :   }
<span class="lineNum">      59 </span>            : }
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : // Given a box with size aBoxSize and origin (0,0), and an angle aAngle,
<span class="lineNum">      62 </span>            : // and a starting point for the gradient line aStart, find the endpoint of
<span class="lineNum">      63 </span>            : // the gradient line --- the intersection of the gradient line with a line
<span class="lineNum">      64 </span>            : // perpendicular to aAngle that passes through the farthest corner in the
<a name="65"><span class="lineNum">      65 </span>            : // direction aAngle.</a>
<span class="lineNum">      66 </span>            : static gfxPoint
<span class="lineNum">      67 </span><span class="lineCov">         26 : ComputeGradientLineEndFromAngle(const gfxPoint&amp; aStart,</span>
<span class="lineNum">      68 </span>            :                                 double aAngle,
<span class="lineNum">      69 </span>            :                                 const gfxSize&amp; aBoxSize)
<span class="lineNum">      70 </span>            : {
<span class="lineNum">      71 </span><span class="lineCov">         26 :   double dx = cos(-aAngle);</span>
<span class="lineNum">      72 </span><span class="lineCov">         26 :   double dy = sin(-aAngle);</span>
<span class="lineNum">      73 </span>            :   gfxPoint farthestCorner(dx &gt; 0 ? aBoxSize.width : 0,
<span class="lineNum">      74 </span><span class="lineCov">         26 :                           dy &gt; 0 ? aBoxSize.height : 0);</span>
<span class="lineNum">      75 </span><span class="lineCov">         26 :   gfxPoint delta = farthestCorner - aStart;</span>
<span class="lineNum">      76 </span><span class="lineCov">         26 :   double u = delta.x*dy - delta.y*dx;</span>
<span class="lineNum">      77 </span><span class="lineCov">         26 :   return farthestCorner + gfxPoint(-u*dy, u*dx);</span>
<span class="lineNum">      78 </span>            : }
<span class="lineNum">      79 </span>            : 
<a name="80"><span class="lineNum">      80 </span>            : // Compute the start and end points of the gradient line for a linear gradient.</a>
<span class="lineNum">      81 </span>            : static void
<span class="lineNum">      82 </span><span class="lineCov">         26 : ComputeLinearGradientLine(nsPresContext* aPresContext,</span>
<span class="lineNum">      83 </span>            :                           nsStyleGradient* aGradient,
<span class="lineNum">      84 </span>            :                           const gfxSize&amp; aBoxSize,
<span class="lineNum">      85 </span>            :                           gfxPoint* aLineStart,
<span class="lineNum">      86 </span>            :                           gfxPoint* aLineEnd)
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span><span class="lineCov">         26 :   if (aGradient-&gt;mBgPosX.GetUnit() == eStyleUnit_None) {</span>
<span class="lineNum">      89 </span>            :     double angle;
<span class="lineNum">      90 </span><span class="lineCov">         23 :     if (aGradient-&gt;mAngle.IsAngleValue()) {</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :       angle = aGradient-&gt;mAngle.GetAngleValueInRadians();</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :       if (!aGradient-&gt;mLegacySyntax) {</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :         angle = M_PI_2 - angle;</span>
<span class="lineNum">      94 </span>            :       }
<span class="lineNum">      95 </span>            :     } else {
<span class="lineNum">      96 </span><span class="lineCov">         23 :       angle = -M_PI_2; // defaults to vertical gradient starting from top</span>
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span><span class="lineCov">         23 :     gfxPoint center(aBoxSize.width/2, aBoxSize.height/2);</span>
<span class="lineNum">      99 </span><span class="lineCov">         23 :     *aLineEnd = ComputeGradientLineEndFromAngle(center, angle, aBoxSize);</span>
<span class="lineNum">     100 </span><span class="lineCov">         23 :     *aLineStart = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineEnd;</span>
<span class="lineNum">     101 </span><span class="lineCov">          3 :   } else if (!aGradient-&gt;mLegacySyntax) {</span>
<span class="lineNum">     102 </span><span class="lineCov">          3 :     float xSign = aGradient-&gt;mBgPosX.GetPercentValue() * 2 - 1;</span>
<span class="lineNum">     103 </span><span class="lineCov">          3 :     float ySign = 1 - aGradient-&gt;mBgPosY.GetPercentValue() * 2;</span>
<span class="lineNum">     104 </span><span class="lineCov">          3 :     double angle = atan2(ySign * aBoxSize.width, xSign * aBoxSize.height);</span>
<span class="lineNum">     105 </span><span class="lineCov">          3 :     gfxPoint center(aBoxSize.width/2, aBoxSize.height/2);</span>
<span class="lineNum">     106 </span><span class="lineCov">          3 :     *aLineEnd = ComputeGradientLineEndFromAngle(center, angle, aBoxSize);</span>
<span class="lineNum">     107 </span><span class="lineCov">          3 :     *aLineStart = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineEnd;</span>
<span class="lineNum">     108 </span>            :   } else {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     int32_t appUnitsPerPixel = aPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     *aLineStart = gfxPoint(</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :       ConvertGradientValueToPixels(aGradient-&gt;mBgPosX, aBoxSize.width,</span>
<span class="lineNum">     112 </span>            :                                    appUnitsPerPixel),
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :       ConvertGradientValueToPixels(aGradient-&gt;mBgPosY, aBoxSize.height,</span>
<span class="lineNum">     114 </span>            :                                    appUnitsPerPixel));
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     if (aGradient-&gt;mAngle.IsAngleValue()) {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(aGradient-&gt;mLegacySyntax);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       double angle = aGradient-&gt;mAngle.GetAngleValueInRadians();</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       *aLineEnd = ComputeGradientLineEndFromAngle(*aLineStart, angle, aBoxSize);</span>
<span class="lineNum">     119 </span>            :     } else {
<span class="lineNum">     120 </span>            :       // No angle, the line end is just the reflection of the start point
<span class="lineNum">     121 </span>            :       // through the center of the box
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       *aLineEnd = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineStart;</span>
<span class="lineNum">     123 </span>            :     }
<span class="lineNum">     124 </span>            :   }
<span class="lineNum">     125 </span><span class="lineCov">         26 : }</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : // Compute the start and end points of the gradient line for a radial gradient.
<span class="lineNum">     128 </span>            : // Also returns the horizontal and vertical radii defining the circle or
<a name="129"><span class="lineNum">     129 </span>            : // ellipse to use.</a>
<span class="lineNum">     130 </span>            : static void
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : ComputeRadialGradientLine(nsPresContext* aPresContext,</span>
<span class="lineNum">     132 </span>            :                           nsStyleGradient* aGradient,
<span class="lineNum">     133 </span>            :                           const gfxSize&amp; aBoxSize,
<span class="lineNum">     134 </span>            :                           gfxPoint* aLineStart,
<span class="lineNum">     135 </span>            :                           gfxPoint* aLineEnd,
<span class="lineNum">     136 </span>            :                           double* aRadiusX,
<span class="lineNum">     137 </span>            :                           double* aRadiusY)
<span class="lineNum">     138 </span>            : {
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   if (aGradient-&gt;mBgPosX.GetUnit() == eStyleUnit_None) {</span>
<span class="lineNum">     140 </span>            :     // Default line start point is the center of the box
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     *aLineStart = gfxPoint(aBoxSize.width/2, aBoxSize.height/2);</span>
<span class="lineNum">     142 </span>            :   } else {
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     int32_t appUnitsPerPixel = aPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     *aLineStart = gfxPoint(</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       ConvertGradientValueToPixels(aGradient-&gt;mBgPosX, aBoxSize.width,</span>
<span class="lineNum">     146 </span>            :                                    appUnitsPerPixel),
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       ConvertGradientValueToPixels(aGradient-&gt;mBgPosY, aBoxSize.height,</span>
<span class="lineNum">     148 </span>            :                                    appUnitsPerPixel));
<span class="lineNum">     149 </span>            :   }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :   // Compute gradient shape: the x and y radii of an ellipse.
<span class="lineNum">     152 </span>            :   double radiusX, radiusY;
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   double leftDistance = Abs(aLineStart-&gt;x);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   double rightDistance = Abs(aBoxSize.width - aLineStart-&gt;x);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   double topDistance = Abs(aLineStart-&gt;y);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   double bottomDistance = Abs(aBoxSize.height - aLineStart-&gt;y);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   switch (aGradient-&gt;mSize) {</span>
<span class="lineNum">     158 </span>            :   case NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE:
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     radiusX = std::min(leftDistance, rightDistance);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     radiusY = std::min(topDistance, bottomDistance);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     if (aGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       radiusX = radiusY = std::min(radiusX, radiusY);</span>
<span class="lineNum">     163 </span>            :     }
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     165 </span>            :   case NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: {
<span class="lineNum">     166 </span>            :     // Compute x and y distances to nearest corner
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     double offsetX = std::min(leftDistance, rightDistance);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     double offsetY = std::min(topDistance, bottomDistance);</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     if (aGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       radiusX = radiusY = NS_hypot(offsetX, offsetY);</span>
<span class="lineNum">     171 </span>            :     } else {
<span class="lineNum">     172 </span>            :       // maintain aspect ratio
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       radiusX = offsetX*M_SQRT2;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       radiusY = offsetY*M_SQRT2;</span>
<span class="lineNum">     175 </span>            :     }
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     177 </span>            :   }
<span class="lineNum">     178 </span>            :   case NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE:
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     radiusX = std::max(leftDistance, rightDistance);</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     radiusY = std::max(topDistance, bottomDistance);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     if (aGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       radiusX = radiusY = std::max(radiusX, radiusY);</span>
<span class="lineNum">     183 </span>            :     }
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     185 </span>            :   case NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: {
<span class="lineNum">     186 </span>            :     // Compute x and y distances to nearest corner
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     double offsetX = std::max(leftDistance, rightDistance);</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     double offsetY = std::max(topDistance, bottomDistance);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     if (aGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       radiusX = radiusY = NS_hypot(offsetX, offsetY);</span>
<span class="lineNum">     191 </span>            :     } else {
<span class="lineNum">     192 </span>            :       // maintain aspect ratio
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :       radiusX = offsetX*M_SQRT2;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       radiusY = offsetY*M_SQRT2;</span>
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     197 </span>            :   }
<span class="lineNum">     198 </span>            :   case NS_STYLE_GRADIENT_SIZE_EXPLICIT_SIZE: {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     int32_t appUnitsPerPixel = aPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     radiusX = ConvertGradientValueToPixels(aGradient-&gt;mRadiusX,</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                                            aBoxSize.width, appUnitsPerPixel);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     radiusY = ConvertGradientValueToPixels(aGradient-&gt;mRadiusY,</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                                            aBoxSize.height, appUnitsPerPixel);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     205 </span>            :   }
<span class="lineNum">     206 </span>            :   default:
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     radiusX = radiusY = 0;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;unknown radial gradient sizing method&quot;);</span>
<span class="lineNum">     209 </span>            :   }
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   *aRadiusX = radiusX;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   *aRadiusY = radiusY;</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   double angle;
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   if (aGradient-&gt;mAngle.IsAngleValue()) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     angle = aGradient-&gt;mAngle.GetAngleValueInRadians();</span>
<span class="lineNum">     216 </span>            :   } else {
<span class="lineNum">     217 </span>            :     // Default angle is 0deg
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     angle = 0.0;</span>
<span class="lineNum">     219 </span>            :   }
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   // The gradient line end point is where the gradient line intersects
<span class="lineNum">     222 </span>            :   // the ellipse.
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   *aLineEnd = *aLineStart + gfxPoint(radiusX*cos(-angle), radiusY*sin(-angle));</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : }</span>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 : static float Interpolate(float aF1, float aF2, float aFrac)</span>
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   return aF1 + aFrac * (aF2 - aF1);</span>
<span class="lineNum">     230 </span>            : }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : // Returns aFrac*aC2 + (1 - aFrac)*C1. The interpolation is done
<span class="lineNum">     233 </span>            : // in unpremultiplied space, which is what SVG gradients and cairo
<a name="234"><span class="lineNum">     234 </span>            : // gradients expect.</a>
<span class="lineNum">     235 </span>            : static Color
<span class="lineNum">     236 </span><span class="lineCov">         28 : InterpolateColor(const Color&amp; aC1, const Color&amp; aC2, float aFrac)</span>
<span class="lineNum">     237 </span>            : {
<span class="lineNum">     238 </span><span class="lineCov">         28 :   double other = 1 - aFrac;</span>
<span class="lineNum">     239 </span><span class="lineCov">        112 :   return Color(aC2.r*aFrac + aC1.r*other,</span>
<span class="lineNum">     240 </span><span class="lineCov">         28 :                aC2.g*aFrac + aC1.g*other,</span>
<span class="lineNum">     241 </span><span class="lineCov">         28 :                aC2.b*aFrac + aC1.b*other,</span>
<span class="lineNum">     242 </span><span class="lineCov">         84 :                aC2.a*aFrac + aC1.a*other);</span>
<span class="lineNum">     243 </span>            : }
<a name="244"><span class="lineNum">     244 </span>            : </a>
<span class="lineNum">     245 </span>            : static nscoord
<span class="lineNum">     246 </span><span class="lineCov">         52 : FindTileStart(nscoord aDirtyCoord, nscoord aTilePos, nscoord aTileDim)</span>
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span><span class="lineCov">         52 :   NS_ASSERTION(aTileDim &gt; 0, &quot;Non-positive tile dimension&quot;);</span>
<span class="lineNum">     249 </span><span class="lineCov">         52 :   double multiples = floor(double(aDirtyCoord - aTilePos)/aTileDim);</span>
<span class="lineNum">     250 </span><span class="lineCov">         52 :   return NSToCoordRound(multiples*aTileDim + aTilePos);</span>
<span class="lineNum">     251 </span>            : }
<a name="252"><span class="lineNum">     252 </span>            : </a>
<span class="lineNum">     253 </span>            : static gfxFloat
<span class="lineNum">     254 </span><span class="lineCov">         32 : LinearGradientStopPositionForPoint(const gfxPoint&amp; aGradientStart,</span>
<span class="lineNum">     255 </span>            :                                    const gfxPoint&amp; aGradientEnd,
<span class="lineNum">     256 </span>            :                                    const gfxPoint&amp; aPoint)
<span class="lineNum">     257 </span>            : {
<span class="lineNum">     258 </span><span class="lineCov">         32 :   gfxPoint d = aGradientEnd - aGradientStart;</span>
<span class="lineNum">     259 </span><span class="lineCov">         32 :   gfxPoint p = aPoint - aGradientStart;</span>
<span class="lineNum">     260 </span>            :   /**
<span class="lineNum">     261 </span>            :    * Compute a parameter t such that a line perpendicular to the
<span class="lineNum">     262 </span>            :    * d vector, passing through aGradientStart + d*t, also
<span class="lineNum">     263 </span>            :    * passes through aPoint.
<span class="lineNum">     264 </span>            :    *
<span class="lineNum">     265 </span>            :    * t is given by
<span class="lineNum">     266 </span>            :    *   (p.x - d.x*t)*d.x + (p.y - d.y*t)*d.y = 0
<span class="lineNum">     267 </span>            :    *
<span class="lineNum">     268 </span>            :    * Solving for t we get
<span class="lineNum">     269 </span>            :    *   numerator = d.x*p.x + d.y*p.y
<span class="lineNum">     270 </span>            :    *   denominator = d.x^2 + d.y^2
<span class="lineNum">     271 </span>            :    *   t = numerator/denominator
<span class="lineNum">     272 </span>            :    *
<span class="lineNum">     273 </span>            :    * In nsCSSRendering::PaintGradient we know the length of d
<span class="lineNum">     274 </span>            :    * is not zero.
<span class="lineNum">     275 </span>            :    */
<span class="lineNum">     276 </span><span class="lineCov">         32 :   double numerator = d.x * p.x + d.y * p.y;</span>
<span class="lineNum">     277 </span><span class="lineCov">         32 :   double denominator = d.x * d.x + d.y * d.y;</span>
<span class="lineNum">     278 </span><span class="lineCov">         32 :   return numerator / denominator;</span>
<span class="lineNum">     279 </span>            : }
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : static bool
<span class="lineNum">     282 </span><span class="lineCov">          8 : RectIsBeyondLinearGradientEdge(const gfxRect&amp; aRect,</span>
<span class="lineNum">     283 </span>            :                                const gfxMatrix&amp; aPatternMatrix,
<span class="lineNum">     284 </span>            :                                const nsTArray&lt;ColorStop&gt;&amp; aStops,
<span class="lineNum">     285 </span>            :                                const gfxPoint&amp; aGradientStart,
<span class="lineNum">     286 </span>            :                                const gfxPoint&amp; aGradientEnd,
<span class="lineNum">     287 </span>            :                                Color* aOutEdgeColor)
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :   gfxFloat topLeft = LinearGradientStopPositionForPoint(
<span class="lineNum">     290 </span><span class="lineCov">          8 :     aGradientStart, aGradientEnd, aPatternMatrix.TransformPoint(aRect.TopLeft()));</span>
<span class="lineNum">     291 </span>            :   gfxFloat topRight = LinearGradientStopPositionForPoint(
<span class="lineNum">     292 </span><span class="lineCov">          8 :     aGradientStart, aGradientEnd, aPatternMatrix.TransformPoint(aRect.TopRight()));</span>
<span class="lineNum">     293 </span>            :   gfxFloat bottomLeft = LinearGradientStopPositionForPoint(
<span class="lineNum">     294 </span><span class="lineCov">          8 :     aGradientStart, aGradientEnd, aPatternMatrix.TransformPoint(aRect.BottomLeft()));</span>
<span class="lineNum">     295 </span>            :   gfxFloat bottomRight = LinearGradientStopPositionForPoint(
<span class="lineNum">     296 </span><span class="lineCov">          8 :     aGradientStart, aGradientEnd, aPatternMatrix.TransformPoint(aRect.BottomRight()));</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineCov">          8 :   const ColorStop&amp; firstStop = aStops[0];</span>
<span class="lineNum">     299 </span><span class="lineCov">         10 :   if (topLeft &lt; firstStop.mPosition &amp;&amp; topRight &lt; firstStop.mPosition &amp;&amp;</span>
<span class="lineNum">     300 </span><span class="lineCov">          2 :       bottomLeft &lt; firstStop.mPosition &amp;&amp; bottomRight &lt; firstStop.mPosition) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     *aOutEdgeColor = firstStop.mColor;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     303 </span>            :   }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineCov">          8 :   const ColorStop&amp; lastStop = aStops.LastElement();</span>
<span class="lineNum">     306 </span><span class="lineCov">          9 :   if (topLeft &gt;= lastStop.mPosition &amp;&amp; topRight &gt;= lastStop.mPosition &amp;&amp;</span>
<span class="lineNum">     307 </span><span class="lineCov">          2 :       bottomLeft &gt;= lastStop.mPosition &amp;&amp; bottomRight &gt;= lastStop.mPosition) {</span>
<span class="lineNum">     308 </span><span class="lineCov">          1 :     *aOutEdgeColor = lastStop.mColor;</span>
<span class="lineNum">     309 </span><span class="lineCov">          1 :     return true;</span>
<span class="lineNum">     310 </span>            :   }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineCov">          7 :   return false;</span>
<a name="313"><span class="lineNum">     313 </span>            : }</a>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">         26 : static void ResolveMidpoints(nsTArray&lt;ColorStop&gt;&amp; stops)</span>
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span><span class="lineCov">         42 :   for (size_t x = 1; x &lt; stops.Length() - 1;) {</span>
<span class="lineNum">     318 </span><span class="lineCov">         16 :     if (!stops[x].mIsMidpoint) {</span>
<span class="lineNum">     319 </span><span class="lineCov">         16 :       x++;</span>
<span class="lineNum">     320 </span><span class="lineCov">         32 :       continue;</span>
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     Color color1 = stops[x-1].mColor;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     Color color2 = stops[x+1].mColor;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     float offset1 = stops[x-1].mPosition;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     float offset2 = stops[x+1].mPosition;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     float offset = stops[x].mPosition;</span>
<span class="lineNum">     328 </span>            :     // check if everything coincides. If so, ignore the midpoint.
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     if (offset - offset1 == offset2 - offset) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :       stops.RemoveElementAt(x);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     332 </span>            :     }
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     // Check if we coincide with the left colorstop.
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     if (offset1 == offset) {</span>
<span class="lineNum">     336 </span>            :       // Morph the midpoint to a regular stop with the color of the next
<span class="lineNum">     337 </span>            :       // color stop.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       stops[x].mColor = color2;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       stops[x].mIsMidpoint = false;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :     // Check if we coincide with the right colorstop.
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     if (offset2 == offset) {</span>
<span class="lineNum">     345 </span>            :       // Morph the midpoint to a regular stop with the color of the previous
<span class="lineNum">     346 </span>            :       // color stop.
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :       stops[x].mColor = color1;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       stops[x].mIsMidpoint = false;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     float midpoint = (offset - offset1) / (offset2 - offset1);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     ColorStop newStops[9];</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     if (midpoint &gt; .5f) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :       for (size_t y = 0; y &lt; 7; y++) {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         newStops[y].mPosition = offset1 + (offset - offset1) * (7 + y) / 13;</span>
<span class="lineNum">     357 </span>            :       }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :       newStops[7].mPosition = offset + (offset2 - offset) / 3;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       newStops[8].mPosition = offset + (offset2 - offset) * 2 / 3;</span>
<span class="lineNum">     361 </span>            :     } else {
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       newStops[0].mPosition = offset1 + (offset - offset1) / 3;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :       newStops[1].mPosition = offset1 + (offset - offset1) * 2 / 3;</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       for (size_t y = 0; y &lt; 7; y++) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         newStops[y+2].mPosition = offset + (offset2 - offset) * y / 13;</span>
<span class="lineNum">     367 </span>            :       }
<span class="lineNum">     368 </span>            :     }
<span class="lineNum">     369 </span>            :     // calculate colors
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     for (size_t y = 0; y &lt; 9; y++) {</span>
<span class="lineNum">     372 </span>            :       // Calculate the intermediate color stops per the formula of the CSS images
<span class="lineNum">     373 </span>            :       // spec. http://dev.w3.org/csswg/css-images/#color-stop-syntax
<span class="lineNum">     374 </span>            :       // 9 points were chosen since it is the minimum number of stops that always
<span class="lineNum">     375 </span>            :       // give the smoothest appearace regardless of midpoint position and difference
<span class="lineNum">     376 </span>            :       // in luminance of the end points.
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       float relativeOffset = (newStops[y].mPosition - offset1) / (offset2 - offset1);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       float multiplier = powf(relativeOffset, logf(.5f) / logf(midpoint));</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       gfx::Float red = color1.r + multiplier * (color2.r - color1.r);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       gfx::Float green = color1.g + multiplier * (color2.g - color1.g);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :       gfx::Float blue = color1.b + multiplier * (color2.b - color1.b);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       gfx::Float alpha = color1.a + multiplier * (color2.a - color1.a);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       newStops[y].mColor = Color(red, green, blue, alpha);</span>
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     stops.ReplaceElementsAt(x, 1, newStops, 9);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     x += 9;</span>
<span class="lineNum">     390 </span>            :   }
<span class="lineNum">     391 </span><span class="lineCov">         26 : }</span>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<span class="lineNum">     393 </span>            : static Color
<span class="lineNum">     394 </span><span class="lineCov">         56 : Premultiply(const Color&amp; aColor)</span>
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span><span class="lineCov">         56 :   gfx::Float a = aColor.a;</span>
<span class="lineNum">     397 </span><span class="lineCov">         56 :   return Color(aColor.r * a, aColor.g * a, aColor.b * a, a);</span>
<span class="lineNum">     398 </span>            : }
<a name="399"><span class="lineNum">     399 </span>            : </a>
<span class="lineNum">     400 </span>            : static Color
<span class="lineNum">     401 </span><span class="lineCov">         28 : Unpremultiply(const Color&amp; aColor)</span>
<span class="lineNum">     402 </span>            : {
<span class="lineNum">     403 </span><span class="lineCov">         28 :   gfx::Float a = aColor.a;</span>
<span class="lineNum">     404 </span>            :   return (a &gt; 0.f)
<span class="lineNum">     405 </span><span class="lineCov">         84 :        ? Color(aColor.r / a, aColor.g / a, aColor.b / a, a)</span>
<span class="lineNum">     406 </span><span class="lineCov">        112 :        : aColor;</span>
<span class="lineNum">     407 </span>            : }
<a name="408"><span class="lineNum">     408 </span>            : </a>
<span class="lineNum">     409 </span>            : static Color
<span class="lineNum">     410 </span><span class="lineCov">         19 : TransparentColor(Color aColor) {</span>
<span class="lineNum">     411 </span><span class="lineCov">         19 :   aColor.a = 0;</span>
<span class="lineNum">     412 </span><span class="lineCov">         19 :   return aColor;</span>
<span class="lineNum">     413 </span>            : }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : // Adjusts and adds color stops in such a way that drawing the gradient with
<span class="lineNum">     416 </span>            : // unpremultiplied interpolation looks nearly the same as if it were drawn with
<span class="lineNum">     417 </span>            : // premultiplied interpolation.
<a name="418"><span class="lineNum">     418 </span>            : static const float kAlphaIncrementPerGradientStep = 0.1f;</a>
<span class="lineNum">     419 </span>            : static void
<span class="lineNum">     420 </span><span class="lineCov">         26 : ResolvePremultipliedAlpha(nsTArray&lt;ColorStop&gt;&amp; aStops)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span><span class="lineCov">         76 :   for (size_t x = 1; x &lt; aStops.Length(); x++) {</span>
<span class="lineNum">     423 </span><span class="lineCov">         50 :     const ColorStop leftStop = aStops[x - 1];</span>
<span class="lineNum">     424 </span><span class="lineCov">         50 :     const ColorStop rightStop = aStops[x];</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :     // if the left and right stop have the same alpha value, we don't need
<span class="lineNum">     427 </span>            :     // to do anything
<span class="lineNum">     428 </span><span class="lineCov">         50 :     if (leftStop.mColor.a == rightStop.mColor.a) {</span>
<span class="lineNum">     429 </span><span class="lineCov">         81 :       continue;</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :     // Is the stop on the left 100% transparent? If so, have it adopt the color
<span class="lineNum">     433 </span>            :     // of the right stop
<span class="lineNum">     434 </span><span class="lineCov">         19 :     if (leftStop.mColor.a == 0) {</span>
<span class="lineNum">     435 </span><span class="lineCov">         16 :       aStops[x - 1].mColor = TransparentColor(rightStop.mColor);</span>
<span class="lineNum">     436 </span><span class="lineCov">         16 :       continue;</span>
<span class="lineNum">     437 </span>            :     }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :     // Is the stop on the right completely transparent?
<span class="lineNum">     440 </span>            :     // If so, duplicate it and assign it the color on the left.
<span class="lineNum">     441 </span><span class="lineCov">          3 :     if (rightStop.mColor.a == 0) {</span>
<span class="lineNum">     442 </span><span class="lineCov">          3 :       ColorStop newStop = rightStop;</span>
<span class="lineNum">     443 </span><span class="lineCov">          3 :       newStop.mColor = TransparentColor(leftStop.mColor);</span>
<span class="lineNum">     444 </span><span class="lineCov">          3 :       aStops.InsertElementAt(x, newStop);</span>
<span class="lineNum">     445 </span><span class="lineCov">          3 :       x++;</span>
<span class="lineNum">     446 </span><span class="lineCov">          3 :       continue;</span>
<span class="lineNum">     447 </span>            :     }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :     // Now handle cases where one or both of the stops are partially transparent.
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     if (leftStop.mColor.a != 1.0f || rightStop.mColor.a != 1.0f) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       Color premulLeftColor = Premultiply(leftStop.mColor);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       Color premulRightColor = Premultiply(rightStop.mColor);</span>
<span class="lineNum">     453 </span>            :       // Calculate how many extra steps. We do a step per 10% transparency.
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :       size_t stepCount = NSToIntFloor(fabsf(leftStop.mColor.a - rightStop.mColor.a) / kAlphaIncrementPerGradientStep);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       for (size_t y = 1; y &lt; stepCount; y++) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         float frac = static_cast&lt;float&gt;(y) / stepCount;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         ColorStop newStop(Interpolate(leftStop.mPosition, rightStop.mPosition, frac), false,</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                           Unpremultiply(InterpolateColor(premulLeftColor, premulRightColor, frac)));</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         aStops.InsertElementAt(x, newStop);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         x++;</span>
<span class="lineNum">     461 </span>            :       }
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            :   }
<span class="lineNum">     464 </span><span class="lineCov">         26 : }</span>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<span class="lineNum">     466 </span>            : static ColorStop
<span class="lineNum">     467 </span><span class="lineCov">         28 : InterpolateColorStop(const ColorStop&amp; aFirst, const ColorStop&amp; aSecond,</span>
<span class="lineNum">     468 </span>            :                      double aPosition, const Color&amp; aDefault)
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span><span class="lineCov">         28 :   MOZ_ASSERT(aFirst.mPosition &lt;= aPosition);</span>
<span class="lineNum">     471 </span><span class="lineCov">         28 :   MOZ_ASSERT(aPosition &lt;= aSecond.mPosition);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">         28 :   double delta = aSecond.mPosition - aFirst.mPosition;</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">         28 :   if (delta &lt; 1e-6) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     return ColorStop(aPosition, false, aDefault);</span>
<span class="lineNum">     477 </span>            :   }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :   return ColorStop(aPosition, false,
<span class="lineNum">     480 </span><span class="lineCov">         56 :                    Unpremultiply(InterpolateColor(Premultiply(aFirst.mColor),</span>
<span class="lineNum">     481 </span><span class="lineCov">         56 :                                                   Premultiply(aSecond.mColor),</span>
<span class="lineNum">     482 </span><span class="lineCov">         56 :                                                   (aPosition - aFirst.mPosition) / delta)));</span>
<span class="lineNum">     483 </span>            : }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : // Clamp and extend the given ColorStop array in-place to fit exactly into the
<a name="486"><span class="lineNum">     486 </span>            : // range [0, 1].</a>
<span class="lineNum">     487 </span>            : static void
<span class="lineNum">     488 </span><span class="lineCov">         18 : ClampColorStops(nsTArray&lt;ColorStop&gt;&amp; aStops)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span><span class="lineCov">         18 :   MOZ_ASSERT(aStops.Length() &gt; 0);</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // If all stops are outside the range, then get rid of everything and replace
<span class="lineNum">     493 </span>            :   // with a single colour.
<span class="lineNum">     494 </span><span class="lineCov">         36 :   if (aStops.Length() &lt; 2 || aStops[0].mPosition &gt; 1 ||</span>
<span class="lineNum">     495 </span><span class="lineCov">         18 :       aStops.LastElement().mPosition &lt; 0) {</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     Color c = aStops[0].mPosition &gt; 1 ? aStops[0].mColor : aStops.LastElement().mColor;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     aStops.Clear();</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     aStops.AppendElement(ColorStop(0, false, c));</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :   // Create the 0 and 1 points if they fall in the range of |aStops|, and discard
<span class="lineNum">     503 </span>            :   // all stops outside the range [0, 1].
<span class="lineNum">     504 </span>            :   // XXX: If we have stops positioned at 0 or 1, we only keep the innermost of
<span class="lineNum">     505 </span>            :   // those stops. This should be fine for the current user(s) of this function.
<span class="lineNum">     506 </span><span class="lineCov">         34 :   for (size_t i = aStops.Length() - 1; i &gt; 0; i--) {</span>
<span class="lineNum">     507 </span><span class="lineCov">         26 :     if (aStops[i - 1].mPosition &lt; 1 &amp;&amp; aStops[i].mPosition &gt;= 1) {</span>
<span class="lineNum">     508 </span>            :       // Add a point to position 1.
<span class="lineNum">     509 </span><span class="lineCov">         54 :       aStops[i] = InterpolateColorStop(aStops[i - 1], aStops[i],</span>
<span class="lineNum">     510 </span>            :                                        /* aPosition = */ 1,
<span class="lineNum">     511 </span><span class="lineCov">         36 :                                        aStops[i - 1].mColor);</span>
<span class="lineNum">     512 </span>            :       // Remove all the elements whose position is greater than 1.
<span class="lineNum">     513 </span><span class="lineCov">         18 :       aStops.RemoveElementsAt(i + 1, aStops.Length() - (i + 1));</span>
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span><span class="lineCov">         26 :     if (aStops[i - 1].mPosition &lt;= 0 &amp;&amp; aStops[i].mPosition &gt; 0) {</span>
<span class="lineNum">     516 </span>            :       // Add a point to position 0.
<span class="lineNum">     517 </span><span class="lineCov">         30 :       aStops[i - 1] = InterpolateColorStop(aStops[i - 1], aStops[i],</span>
<span class="lineNum">     518 </span>            :                                            /* aPosition = */ 0,
<span class="lineNum">     519 </span><span class="lineCov">         20 :                                            aStops[i].mColor);</span>
<span class="lineNum">     520 </span>            :       // Remove all of the preceding stops -- they are all negative.
<span class="lineNum">     521 </span><span class="lineCov">         10 :       aStops.RemoveElementsAt(0, i - 1);</span>
<span class="lineNum">     522 </span><span class="lineCov">         10 :       break;</span>
<span class="lineNum">     523 </span>            :     }
<span class="lineNum">     524 </span>            :   }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">         18 :   MOZ_ASSERT(aStops[0].mPosition &gt;= -1e6);</span>
<span class="lineNum">     527 </span><span class="lineCov">         18 :   MOZ_ASSERT(aStops.LastElement().mPosition - 1 &lt;= 1e6);</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   // The end points won't exist yet if they don't fall in the original range of
<span class="lineNum">     530 </span>            :   // |aStops|. Create them if needed.
<span class="lineNum">     531 </span><span class="lineCov">         18 :   if (aStops[0].mPosition &gt; 0) {</span>
<span class="lineNum">     532 </span><span class="lineCov">          8 :     aStops.InsertElementAt(0, ColorStop(0, false, aStops[0].mColor));</span>
<span class="lineNum">     533 </span>            :   }
<span class="lineNum">     534 </span><span class="lineCov">         18 :   if (aStops.LastElement().mPosition &lt; 1) {</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     aStops.AppendElement(ColorStop(1, false, aStops.LastElement().mColor));</span>
<span class="lineNum">     536 </span>            :   }
<span class="lineNum">     537 </span>            : }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : namespace mozilla {
<a name="540"><span class="lineNum">     540 </span>            : </a>
<span class="lineNum">     541 </span>            : nsCSSGradientRenderer
<span class="lineNum">     542 </span><span class="lineCov">         26 : nsCSSGradientRenderer::Create(nsPresContext* aPresContext,</span>
<span class="lineNum">     543 </span>            :                              nsStyleGradient* aGradient,
<span class="lineNum">     544 </span>            :                              const nsSize&amp; aIntrinsicSize)
<span class="lineNum">     545 </span>            : {
<span class="lineNum">     546 </span><span class="lineCov">         26 :   nscoord appUnitsPerDevPixel = aPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">     547 </span><span class="lineCov">         26 :   gfxSize srcSize = gfxSize(gfxFloat(aIntrinsicSize.width)/appUnitsPerDevPixel,</span>
<span class="lineNum">     548 </span><span class="lineCov">         52 :                             gfxFloat(aIntrinsicSize.height)/appUnitsPerDevPixel);</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   // Compute &quot;gradient line&quot; start and end relative to the intrinsic size of
<span class="lineNum">     551 </span>            :   // the gradient.
<span class="lineNum">     552 </span><span class="lineCov">         26 :   gfxPoint lineStart, lineEnd;</span>
<span class="lineNum">     553 </span><span class="lineCov">         26 :   double radiusX = 0, radiusY = 0; // for radial gradients only</span>
<span class="lineNum">     554 </span><span class="lineCov">         26 :   if (aGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {</span>
<span class="lineNum">     555 </span>            :     ComputeLinearGradientLine(aPresContext, aGradient, srcSize,
<span class="lineNum">     556 </span><span class="lineCov">         26 :                               &amp;lineStart, &amp;lineEnd);</span>
<span class="lineNum">     557 </span>            :   } else {
<span class="lineNum">     558 </span>            :     ComputeRadialGradientLine(aPresContext, aGradient, srcSize,
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                               &amp;lineStart, &amp;lineEnd, &amp;radiusX, &amp;radiusY);</span>
<span class="lineNum">     560 </span>            :   }
<span class="lineNum">     561 </span>            :   // Avoid sending Infs or Nans to downwind draw targets.
<span class="lineNum">     562 </span><span class="lineCov">         26 :   if (!lineStart.IsFinite() || !lineEnd.IsFinite()) {</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     lineStart = lineEnd = gfxPoint(0, 0);</span>
<span class="lineNum">     564 </span>            :   }
<span class="lineNum">     565 </span><span class="lineCov">         26 :   gfxFloat lineLength = NS_hypot(lineEnd.x - lineStart.x,</span>
<span class="lineNum">     566 </span><span class="lineCov">         52 :                                   lineEnd.y - lineStart.y);</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineCov">         26 :   MOZ_ASSERT(aGradient-&gt;mStops.Length() &gt;= 2,</span>
<span class="lineNum">     569 </span>            :              &quot;The parser should reject gradients with less than two stops&quot;);
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :   // Build color stop array and compute stop positions
<span class="lineNum">     572 </span><span class="lineCov">         52 :   nsTArray&lt;ColorStop&gt; stops;</span>
<span class="lineNum">     573 </span>            :   // If there is a run of stops before stop i that did not have specified
<span class="lineNum">     574 </span>            :   // positions, then this is the index of the first stop in that run, otherwise
<span class="lineNum">     575 </span>            :   // it's -1.
<span class="lineNum">     576 </span><span class="lineCov">         26 :   int32_t firstUnsetPosition = -1;</span>
<span class="lineNum">     577 </span><span class="lineCov">         94 :   for (uint32_t i = 0; i &lt; aGradient-&gt;mStops.Length(); ++i) {</span>
<span class="lineNum">     578 </span><span class="lineCov">         68 :     const nsStyleGradientStop&amp; stop = aGradient-&gt;mStops[i];</span>
<span class="lineNum">     579 </span>            :     double position;
<span class="lineNum">     580 </span><span class="lineCov">         68 :     switch (stop.mLocation.GetUnit()) {</span>
<span class="lineNum">     581 </span>            :     case eStyleUnit_None:
<span class="lineNum">     582 </span><span class="lineCov">         39 :       if (i == 0) {</span>
<span class="lineNum">     583 </span>            :         // First stop defaults to position 0.0
<span class="lineNum">     584 </span><span class="lineCov">         16 :         position = 0.0;</span>
<span class="lineNum">     585 </span><span class="lineCov">         23 :       } else if (i == aGradient-&gt;mStops.Length() - 1) {</span>
<span class="lineNum">     586 </span>            :         // Last stop defaults to position 1.0
<span class="lineNum">     587 </span><span class="lineCov">         23 :         position = 1.0;</span>
<span class="lineNum">     588 </span>            :       } else {
<span class="lineNum">     589 </span>            :         // Other stops with no specified position get their position assigned
<span class="lineNum">     590 </span>            :         // later by interpolation, see below.
<span class="lineNum">     591 </span>            :         // Remeber where the run of stops with no specified position starts,
<span class="lineNum">     592 </span>            :         // if it starts here.
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :         if (firstUnsetPosition &lt; 0) {</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :           firstUnsetPosition = i;</span>
<span class="lineNum">     595 </span>            :         }
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         stops.AppendElement(ColorStop(0, stop.mIsInterpolationHint,</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                                       Color::FromABGR(stop.mColor)));</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     599 </span>            :       }
<span class="lineNum">     600 </span><span class="lineCov">         39 :       break;</span>
<span class="lineNum">     601 </span>            :     case eStyleUnit_Percent:
<span class="lineNum">     602 </span><span class="lineCov">          6 :       position = stop.mLocation.GetPercentValue();</span>
<span class="lineNum">     603 </span><span class="lineCov">          6 :       break;</span>
<span class="lineNum">     604 </span>            :     case eStyleUnit_Coord:
<span class="lineNum">     605 </span><span class="lineCov">         46 :       position = lineLength &lt; 1e-6 ? 0.0 :</span>
<span class="lineNum">     606 </span><span class="lineCov">         23 :           stop.mLocation.GetCoordValue() / appUnitsPerDevPixel / lineLength;</span>
<span class="lineNum">     607 </span><span class="lineCov">         23 :       break;</span>
<span class="lineNum">     608 </span>            :     case eStyleUnit_Calc:
<span class="lineNum">     609 </span>            :       nsStyleCoord::Calc *calc;
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       calc = stop.mLocation.GetCalcValue();</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :       position = calc-&gt;mPercent +</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :           ((lineLength &lt; 1e-6) ? 0.0 :</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           (NSAppUnitsToFloatPixels(calc-&gt;mLength, appUnitsPerDevPixel) / lineLength));</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     615 </span>            :     default:
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(false, &quot;Unknown stop position type&quot;);</span>
<span class="lineNum">     617 </span>            :     }
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">         68 :     if (i &gt; 0) {</span>
<span class="lineNum">     620 </span>            :       // Prevent decreasing stop positions by advancing this position
<span class="lineNum">     621 </span>            :       // to the previous stop position, if necessary
<span class="lineNum">     622 </span>            :       double previousPosition = firstUnsetPosition &gt; 0
<span class="lineNum">     623 </span><span class="lineCov">         84 :         ? stops[firstUnsetPosition - 1].mPosition</span>
<span class="lineNum">     624 </span><span class="lineCov">         84 :         : stops[i - 1].mPosition;</span>
<span class="lineNum">     625 </span><span class="lineCov">         42 :       position = std::max(position, previousPosition);</span>
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span><span class="lineCov">        136 :     stops.AppendElement(ColorStop(position, stop.mIsInterpolationHint,</span>
<span class="lineNum">     628 </span><span class="lineCov">        204 :                                   Color::FromABGR(stop.mColor)));</span>
<span class="lineNum">     629 </span><span class="lineCov">         68 :     if (firstUnsetPosition &gt; 0) {</span>
<span class="lineNum">     630 </span>            :       // Interpolate positions for all stops that didn't have a specified position
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       double p = stops[firstUnsetPosition - 1].mPosition;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       double d = (stops[i].mPosition - p)/(i - firstUnsetPosition + 1);</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :       for (uint32_t j = firstUnsetPosition; j &lt; i; ++j) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         p += d;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         stops[j].mPosition = p;</span>
<span class="lineNum">     636 </span>            :       }
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       firstUnsetPosition = -1;</span>
<span class="lineNum">     638 </span>            :     }
<span class="lineNum">     639 </span>            :   }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineCov">         26 :   ResolveMidpoints(stops);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">         26 :   nsCSSGradientRenderer renderer;</span>
<span class="lineNum">     644 </span><span class="lineCov">         26 :   renderer.mPresContext = aPresContext;</span>
<span class="lineNum">     645 </span><span class="lineCov">         26 :   renderer.mGradient = aGradient;</span>
<span class="lineNum">     646 </span><span class="lineCov">         26 :   renderer.mStops = std::move(stops);</span>
<span class="lineNum">     647 </span><span class="lineCov">         26 :   renderer.mLineStart = lineStart;</span>
<span class="lineNum">     648 </span><span class="lineCov">         26 :   renderer.mLineEnd = lineEnd;</span>
<span class="lineNum">     649 </span><span class="lineCov">         26 :   renderer.mRadiusX = radiusX;</span>
<span class="lineNum">     650 </span><span class="lineCov">         26 :   renderer.mRadiusY = radiusY;</span>
<span class="lineNum">     651 </span><span class="lineCov">         52 :   return renderer;</span>
<span class="lineNum">     652 </span>            : }
<a name="653"><span class="lineNum">     653 </span>            : </a>
<span class="lineNum">     654 </span>            : void
<span class="lineNum">     655 </span><span class="lineCov">         26 : nsCSSGradientRenderer::Paint(gfxContext&amp; aContext,</span>
<span class="lineNum">     656 </span>            :                              const nsRect&amp; aDest,
<span class="lineNum">     657 </span>            :                              const nsRect&amp; aFillArea,
<span class="lineNum">     658 </span>            :                              const nsSize&amp; aRepeatSize,
<span class="lineNum">     659 </span>            :                              const CSSIntRect&amp; aSrc,
<span class="lineNum">     660 </span>            :                              const nsRect&amp; aDirtyRect,
<span class="lineNum">     661 </span>            :                              float aOpacity)
<span class="lineNum">     662 </span>            : {
<span class="lineNum">     663 </span><span class="lineCov">         52 :   AUTO_PROFILER_LABEL(&quot;nsCSSGradientRenderer::Paint&quot;, GRAPHICS);</span>
<span class="lineNum">     664 </span><span class="lineCov">         52 :   Telemetry::AutoTimer&lt;Telemetry::GRADIENT_DURATION, Telemetry::Microsecond&gt; gradientTimer;</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineCov">         26 :   if (aDest.IsEmpty() || aFillArea.IsEmpty()) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     668 </span>            :   }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineCov">         26 :   nscoord appUnitsPerDevPixel = mPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineCov">         26 :   gfxFloat lineLength = NS_hypot(mLineEnd.x - mLineStart.x,</span>
<span class="lineNum">     673 </span><span class="lineCov">         52 :                                  mLineEnd.y - mLineStart.y);</span>
<span class="lineNum">     674 </span><span class="lineCov">         26 :   bool cellContainsFill = aDest.Contains(aFillArea);</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   // If a non-repeating linear gradient is axis-aligned and there are no gaps
<span class="lineNum">     677 </span>            :   // between tiles, we can optimise away most of the work by converting to a
<span class="lineNum">     678 </span>            :   // repeating linear gradient and filling the whole destination rect at once.
<span class="lineNum">     679 </span>            :   bool forceRepeatToCoverTiles =
<span class="lineNum">     680 </span><span class="lineCov">         52 :     mGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR &amp;&amp;</span>
<span class="lineNum">     681 </span><span class="lineCov">         47 :     (mLineStart.x == mLineEnd.x) != (mLineStart.y == mLineEnd.y) &amp;&amp;</span>
<span class="lineNum">     682 </span><span class="lineCov">         63 :     aRepeatSize.width == aDest.width &amp;&amp; aRepeatSize.height == aDest.height &amp;&amp;</span>
<span class="lineNum">     683 </span><span class="lineCov">         68 :     !mGradient-&gt;mRepeating &amp;&amp; !aSrc.IsEmpty() &amp;&amp; !cellContainsFill;</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">         26 :   gfxMatrix matrix;</span>
<span class="lineNum">     686 </span><span class="lineCov">         26 :   if (forceRepeatToCoverTiles) {</span>
<span class="lineNum">     687 </span>            :     // Length of the source rectangle along the gradient axis.
<span class="lineNum">     688 </span>            :     double rectLen;
<span class="lineNum">     689 </span>            :     // The position of the start of the rectangle along the gradient.
<span class="lineNum">     690 </span>            :     double offset;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     // The gradient line is &quot;backwards&quot;. Flip the line upside down to make
<span class="lineNum">     693 </span>            :     // things easier, and then rotate the matrix to turn everything back the
<span class="lineNum">     694 </span>            :     // right way up.
<span class="lineNum">     695 </span><span class="lineCov">         18 :     if (mLineStart.x &gt; mLineEnd.x || mLineStart.y &gt; mLineEnd.y) {</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       std::swap(mLineStart, mLineEnd);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       matrix.PreScale(-1, -1);</span>
<span class="lineNum">     698 </span>            :     }
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            :     // Fit the gradient line exactly into the source rect.
<span class="lineNum">     701 </span>            :     // aSrc is relative to aIntrinsincSize.
<span class="lineNum">     702 </span>            :     // srcRectDev will be relative to srcSize, so in the same coordinate space
<span class="lineNum">     703 </span>            :     // as lineStart / lineEnd.
<span class="lineNum">     704 </span>            :     gfxRect srcRectDev = nsLayoutUtils::RectToGfxRect(
<span class="lineNum">     705 </span><span class="lineCov">         18 :       CSSPixel::ToAppUnits(aSrc), appUnitsPerDevPixel);</span>
<span class="lineNum">     706 </span><span class="lineCov">         18 :     if (mLineStart.x != mLineEnd.x) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       rectLen = srcRectDev.width;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       offset = (srcRectDev.x - mLineStart.x) / lineLength;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       mLineStart.x = srcRectDev.x;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       mLineEnd.x = srcRectDev.XMost();</span>
<span class="lineNum">     711 </span>            :     } else {
<span class="lineNum">     712 </span><span class="lineCov">         18 :       rectLen = srcRectDev.height;</span>
<span class="lineNum">     713 </span><span class="lineCov">         18 :       offset = (srcRectDev.y - mLineStart.y) / lineLength;</span>
<span class="lineNum">     714 </span><span class="lineCov">         18 :       mLineStart.y = srcRectDev.y;</span>
<span class="lineNum">     715 </span><span class="lineCov">         18 :       mLineEnd.y = srcRectDev.YMost();</span>
<span class="lineNum">     716 </span>            :     }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :     // Adjust gradient stop positions for the new gradient line.
<span class="lineNum">     719 </span><span class="lineCov">         18 :     double scale = lineLength / rectLen;</span>
<span class="lineNum">     720 </span><span class="lineCov">         62 :     for (size_t i = 0; i &lt; mStops.Length(); i++) {</span>
<span class="lineNum">     721 </span><span class="lineCov">         44 :       mStops[i].mPosition = (mStops[i].mPosition - offset) * fabs(scale);</span>
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :     // Clamp or extrapolate gradient stops to exactly [0, 1].
<span class="lineNum">     725 </span><span class="lineCov">         18 :     ClampColorStops(mStops);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">         18 :     lineLength = rectLen;</span>
<span class="lineNum">     728 </span>            :   }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :   // Eliminate negative-position stops if the gradient is radial.
<span class="lineNum">     731 </span><span class="lineCov">         26 :   double firstStop = mStops[0].mPosition;</span>
<span class="lineNum">     732 </span><span class="lineCov">         26 :   if (mGradient-&gt;mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR &amp;&amp; firstStop &lt; 0.0) {</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     if (mGradient-&gt;mRepeating) {</span>
<span class="lineNum">     734 </span>            :       // Choose an instance of the repeated pattern that gives us all positive
<span class="lineNum">     735 </span>            :       // stop-offsets.
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       double lastStop = mStops[mStops.Length() - 1].mPosition;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       double stopDelta = lastStop - firstStop;</span>
<span class="lineNum">     738 </span>            :       // If all the stops are in approximately the same place then logic below
<span class="lineNum">     739 </span>            :       // will kick in that makes us draw just the last stop color, so don't
<span class="lineNum">     740 </span>            :       // try to do anything in that case. We certainly need to avoid
<span class="lineNum">     741 </span>            :       // dividing by zero.
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :       if (stopDelta &gt;= 1e-6) {</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         double instanceCount = ceil(-firstStop/stopDelta);</span>
<span class="lineNum">     744 </span>            :         // Advance stops by instanceCount multiples of the period of the
<span class="lineNum">     745 </span>            :         // repeating gradient.
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         double offset = instanceCount*stopDelta;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; i &lt; mStops.Length(); i++) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :           mStops[i].mPosition += offset;</span>
<span class="lineNum">     749 </span>            :         }
<span class="lineNum">     750 </span>            :       }
<span class="lineNum">     751 </span>            :     } else {
<span class="lineNum">     752 </span>            :       // Move negative-position stops to position 0.0. We may also need
<span class="lineNum">     753 </span>            :       // to set the color of the stop to the color the gradient should have
<span class="lineNum">     754 </span>            :       // at the center of the ellipse.
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; i &lt; mStops.Length(); i++) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         double pos = mStops[i].mPosition;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         if (pos &lt; 0.0) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :           mStops[i].mPosition = 0.0;</span>
<span class="lineNum">     759 </span>            :           // If this is the last stop, we don't need to adjust the color,
<span class="lineNum">     760 </span>            :           // it will fill the entire area.
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :           if (i &lt; mStops.Length() - 1) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :             double nextPos = mStops[i + 1].mPosition;</span>
<span class="lineNum">     763 </span>            :             // If nextPos is approximately equal to pos, then we don't
<span class="lineNum">     764 </span>            :             // need to adjust the color of this stop because it's
<span class="lineNum">     765 </span>            :             // not going to be displayed.
<span class="lineNum">     766 </span>            :             // If nextPos is negative, we don't need to adjust the color of
<span class="lineNum">     767 </span>            :             // this stop since it's not going to be displayed because
<span class="lineNum">     768 </span>            :             // nextPos will also be moved to 0.0.
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :             if (nextPos &gt;= 0.0 &amp;&amp; nextPos - pos &gt;= 1e-6) {</span>
<span class="lineNum">     770 </span>            :               // Compute how far the new position 0.0 is along the interval
<span class="lineNum">     771 </span>            :               // between pos and nextPos.
<span class="lineNum">     772 </span>            :               // XXX Color interpolation (in cairo, too) should use the
<span class="lineNum">     773 </span>            :               // CSS 'color-interpolation' property!
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :               float frac = float((0.0 - pos)/(nextPos - pos));</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :               mStops[i].mColor =</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :                 InterpolateColor(mStops[i].mColor, mStops[i + 1].mColor, frac);</span>
<span class="lineNum">     777 </span>            :             }
<span class="lineNum">     778 </span>            :           }
<span class="lineNum">     779 </span>            :         }
<span class="lineNum">     780 </span>            :       }
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     firstStop = mStops[0].mPosition;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(firstStop &gt;= 0.0, &quot;Failed to fix stop offsets&quot;);</span>
<span class="lineNum">     784 </span>            :   }
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineCov">         26 :   if (mGradient-&gt;mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR &amp;&amp; !mGradient-&gt;mRepeating) {</span>
<span class="lineNum">     787 </span>            :     // Direct2D can only handle a particular class of radial gradients because
<span class="lineNum">     788 </span>            :     // of the way the it specifies gradients. Setting firstStop to 0, when we
<span class="lineNum">     789 </span>            :     // can, will help us stay on the fast path. Currently we don't do this
<span class="lineNum">     790 </span>            :     // for repeating gradients but we could by adjusting the stop collection
<span class="lineNum">     791 </span>            :     // to start at 0
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     firstStop = 0;</span>
<span class="lineNum">     793 </span>            :   }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineCov">         26 :   double lastStop = mStops[mStops.Length() - 1].mPosition;</span>
<span class="lineNum">     796 </span>            :   // Cairo gradients must have stop positions in the range [0, 1]. So,
<span class="lineNum">     797 </span>            :   // stop positions will be normalized below by subtracting firstStop and then
<span class="lineNum">     798 </span>            :   // multiplying by stopScale.
<span class="lineNum">     799 </span>            :   double stopScale;
<span class="lineNum">     800 </span><span class="lineCov">         26 :   double stopOrigin = firstStop;</span>
<span class="lineNum">     801 </span><span class="lineCov">         26 :   double stopEnd = lastStop;</span>
<span class="lineNum">     802 </span><span class="lineCov">         26 :   double stopDelta = lastStop - firstStop;</span>
<span class="lineNum">     803 </span><span class="lineCov">         26 :   bool zeroRadius = mGradient-&gt;mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR &amp;&amp;</span>
<span class="lineNum">     804 </span><span class="lineCov">         26 :                       (mRadiusX &lt; 1e-6 || mRadiusY &lt; 1e-6);</span>
<span class="lineNum">     805 </span><span class="lineCov">         26 :   if (stopDelta &lt; 1e-6 || lineLength &lt; 1e-6 || zeroRadius) {</span>
<span class="lineNum">     806 </span>            :     // Stops are all at the same place. Map all stops to 0.0.
<span class="lineNum">     807 </span>            :     // For repeating radial gradients, or for any radial gradients with
<span class="lineNum">     808 </span>            :     // a zero radius, we need to fill with the last stop color, so just set
<span class="lineNum">     809 </span>            :     // both radii to 0.
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     if (mGradient-&gt;mRepeating || zeroRadius) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :       mRadiusX = mRadiusY = 0.0;</span>
<span class="lineNum">     812 </span>            :     }
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     stopDelta = 0.0;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     lastStop = firstStop;</span>
<span class="lineNum">     815 </span>            :   }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   // Don't normalize non-repeating or degenerate gradients below 0..1
<span class="lineNum">     818 </span>            :   // This keeps the gradient line as large as the box and doesn't
<span class="lineNum">     819 </span>            :   // lets us avoiding having to get padding correct for stops
<span class="lineNum">     820 </span>            :   // at 0 and 1
<span class="lineNum">     821 </span><span class="lineCov">         26 :   if (!mGradient-&gt;mRepeating || stopDelta == 0.0) {</span>
<span class="lineNum">     822 </span><span class="lineCov">         26 :     stopOrigin = std::min(stopOrigin, 0.0);</span>
<span class="lineNum">     823 </span><span class="lineCov">         26 :     stopEnd = std::max(stopEnd, 1.0);</span>
<span class="lineNum">     824 </span>            :   }
<span class="lineNum">     825 </span><span class="lineCov">         26 :   stopScale = 1.0/(stopEnd - stopOrigin);</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :   // Create the gradient pattern.
<span class="lineNum">     828 </span><span class="lineCov">         52 :   RefPtr&lt;gfxPattern&gt; gradientPattern;</span>
<span class="lineNum">     829 </span><span class="lineCov">         26 :   gfxPoint gradientStart;</span>
<span class="lineNum">     830 </span><span class="lineCov">         26 :   gfxPoint gradientEnd;</span>
<span class="lineNum">     831 </span><span class="lineCov">         26 :   if (mGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {</span>
<span class="lineNum">     832 </span>            :     // Compute the actual gradient line ends we need to pass to cairo after
<span class="lineNum">     833 </span>            :     // stops have been normalized.
<span class="lineNum">     834 </span><span class="lineCov">         26 :     gradientStart = mLineStart + (mLineEnd - mLineStart)*stopOrigin;</span>
<span class="lineNum">     835 </span><span class="lineCov">         26 :     gradientEnd = mLineStart + (mLineEnd - mLineStart)*stopEnd;</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span><span class="lineCov">         26 :     if (stopDelta == 0.0) {</span>
<span class="lineNum">     838 </span>            :       // Stops are all at the same place. For repeating gradients, this will
<span class="lineNum">     839 </span>            :       // just paint the last stop color. We don't need to do anything.
<span class="lineNum">     840 </span>            :       // For non-repeating gradients, this should render as two colors, one
<span class="lineNum">     841 </span>            :       // on each &quot;side&quot; of the gradient line segment, which is a point. All
<span class="lineNum">     842 </span>            :       // our stops will be at 0.0; we just need to set the direction vector
<span class="lineNum">     843 </span>            :       // correctly.
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :       gradientEnd = gradientStart + (mLineEnd - mLineStart);</span>
<span class="lineNum">     845 </span>            :     }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     gradientPattern = new gfxPattern(gradientStart.x, gradientStart.y,
<span class="lineNum">     848 </span><span class="lineCov">         26 :                                       gradientEnd.x, gradientEnd.y);</span>
<span class="lineNum">     849 </span>            :   } else {
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     NS_ASSERTION(firstStop &gt;= 0.0,</span>
<span class="lineNum">     851 </span>            :                   &quot;Negative stops not allowed for radial gradients&quot;);
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            :     // To form an ellipse, we'll stretch a circle vertically, if necessary.
<span class="lineNum">     854 </span>            :     // So our radii are based on radiusX.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     double innerRadius = mRadiusX*stopOrigin;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     double outerRadius = mRadiusX*stopEnd;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     if (stopDelta == 0.0) {</span>
<span class="lineNum">     858 </span>            :       // Stops are all at the same place.  See above (except we now have
<span class="lineNum">     859 </span>            :       // the inside vs. outside of an ellipse).
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       outerRadius = innerRadius + 1;</span>
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            :     gradientPattern = new gfxPattern(mLineStart.x, mLineStart.y, innerRadius,
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                                      mLineStart.x, mLineStart.y, outerRadius);</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     if (mRadiusX != mRadiusY) {</span>
<span class="lineNum">     865 </span>            :       // Stretch the circles into ellipses vertically by setting a transform
<span class="lineNum">     866 </span>            :       // in the pattern.
<span class="lineNum">     867 </span>            :       // Recall that this is the transform from user space to pattern space.
<span class="lineNum">     868 </span>            :       // So to stretch the ellipse by factor of P vertically, we scale
<span class="lineNum">     869 </span>            :       // user coordinates by 1/P.
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :       matrix.PreTranslate(mLineStart);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       matrix.PreScale(1.0, mRadiusX/mRadiusY);</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       matrix.PreTranslate(-mLineStart);</span>
<span class="lineNum">     873 </span>            :     }
<span class="lineNum">     874 </span>            :   }
<span class="lineNum">     875 </span>            :   // Use a pattern transform to take account of source and dest rects
<span class="lineNum">     876 </span><span class="lineCov">         52 :   matrix.PreTranslate(gfxPoint(mPresContext-&gt;CSSPixelsToDevPixels(aSrc.x),</span>
<span class="lineNum">     877 </span><span class="lineCov">         52 :                                mPresContext-&gt;CSSPixelsToDevPixels(aSrc.y)));</span>
<span class="lineNum">     878 </span><span class="lineCov">         26 :   matrix.PreScale(gfxFloat(mPresContext-&gt;CSSPixelsToAppUnits(aSrc.width))/aDest.width,</span>
<span class="lineNum">     879 </span><span class="lineCov">         52 :                   gfxFloat(mPresContext-&gt;CSSPixelsToAppUnits(aSrc.height))/aDest.height);</span>
<span class="lineNum">     880 </span><span class="lineCov">         26 :   gradientPattern-&gt;SetMatrix(matrix);</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineCov">         26 :   if (stopDelta == 0.0) {</span>
<span class="lineNum">     883 </span>            :     // Non-repeating gradient with all stops in same place -&gt; just add
<span class="lineNum">     884 </span>            :     // first stop and last stop, both at position 0.
<span class="lineNum">     885 </span>            :     // Repeating gradient with all stops in the same place, or radial
<span class="lineNum">     886 </span>            :     // gradient with radius of 0 -&gt; just paint the last stop color.
<span class="lineNum">     887 </span>            :     // We use firstStop offset to keep |stops| with same units (will later normalize to 0).
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     Color firstColor(mStops[0].mColor);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     Color lastColor(mStops.LastElement().mColor);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     mStops.Clear();</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     if (!mGradient-&gt;mRepeating &amp;&amp; !zeroRadius) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       mStops.AppendElement(ColorStop(firstStop, false, firstColor));</span>
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     mStops.AppendElement(ColorStop(firstStop, false, lastColor));</span>
<span class="lineNum">     896 </span>            :   }
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">         26 :   ResolvePremultipliedAlpha(mStops);</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineCov">         26 :   bool isRepeat = mGradient-&gt;mRepeating || forceRepeatToCoverTiles;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            :   // Now set normalized color stops in pattern.
<span class="lineNum">     903 </span>            :   // Offscreen gradient surface cache (not a tile):
<span class="lineNum">     904 </span>            :   // On some backends (e.g. D2D), the GradientStops object holds an offscreen surface
<span class="lineNum">     905 </span>            :   // which is a lookup table used to evaluate the gradient. This surface can use
<span class="lineNum">     906 </span>            :   // much memory (ram and/or GPU ram) and can be expensive to create. So we cache it.
<span class="lineNum">     907 </span>            :   // The cache key correlates 1:1 with the arguments for CreateGradientStops (also the implied backend type)
<span class="lineNum">     908 </span>            :   // Note that GradientStop is a simple struct with a stop value (while GradientStops has the surface).
<span class="lineNum">     909 </span><span class="lineCov">         52 :   nsTArray&lt;gfx::GradientStop&gt; rawStops(mStops.Length());</span>
<span class="lineNum">     910 </span><span class="lineCov">         26 :   rawStops.SetLength(mStops.Length());</span>
<span class="lineNum">     911 </span><span class="lineCov">        105 :   for(uint32_t i = 0; i &lt; mStops.Length(); i++) {</span>
<span class="lineNum">     912 </span><span class="lineCov">         79 :     rawStops[i].color = mStops[i].mColor;</span>
<span class="lineNum">     913 </span><span class="lineCov">         79 :     rawStops[i].color.a *= aOpacity;</span>
<span class="lineNum">     914 </span><span class="lineCov">         79 :     rawStops[i].offset = stopScale * (mStops[i].mPosition - stopOrigin);</span>
<span class="lineNum">     915 </span>            :   }
<span class="lineNum">     916 </span>            :   RefPtr&lt;mozilla::gfx::GradientStops&gt; gs =
<span class="lineNum">     917 </span><span class="lineCov">         52 :     gfxGradientCache::GetOrCreateGradientStops(aContext.GetDrawTarget(),</span>
<span class="lineNum">     918 </span>            :                                                rawStops,
<span class="lineNum">     919 </span><span class="lineCov">         52 :                                                isRepeat ? gfx::ExtendMode::REPEAT : gfx::ExtendMode::CLAMP);</span>
<span class="lineNum">     920 </span><span class="lineCov">         26 :   gradientPattern-&gt;SetColorStops(gs);</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :   // Paint gradient tiles. This isn't terribly efficient, but doing it this
<span class="lineNum">     923 </span>            :   // way is simple and sure to get pixel-snapping right. We could speed things
<span class="lineNum">     924 </span>            :   // up by drawing tiles into temporary surfaces and copying those to the
<span class="lineNum">     925 </span>            :   // destination, but after pixel-snapping tiles may not all be the same size.
<span class="lineNum">     926 </span><span class="lineCov">         52 :   nsRect dirty;</span>
<span class="lineNum">     927 </span><span class="lineCov">         26 :   if (!dirty.IntersectRect(aDirtyRect, aFillArea))</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :   gfxRect areaToFill =
<span class="lineNum">     931 </span><span class="lineCov">         26 :     nsLayoutUtils::RectToGfxRect(aFillArea, appUnitsPerDevPixel);</span>
<span class="lineNum">     932 </span><span class="lineCov">         26 :   gfxRect dirtyAreaToFill = nsLayoutUtils::RectToGfxRect(dirty, appUnitsPerDevPixel);</span>
<span class="lineNum">     933 </span><span class="lineCov">         26 :   dirtyAreaToFill.RoundOut();</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineCov">         26 :   gfxMatrix ctm = aContext.CurrentMatrix();</span>
<span class="lineNum">     936 </span><span class="lineCov">         26 :   bool isCTMPreservingAxisAlignedRectangles = ctm.PreservesAxisAlignedRectangles();</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            :   // xStart/yStart are the top-left corner of the top-left tile.
<span class="lineNum">     939 </span><span class="lineCov">         26 :   nscoord xStart = FindTileStart(dirty.x, aDest.x, aRepeatSize.width);</span>
<span class="lineNum">     940 </span><span class="lineCov">         26 :   nscoord yStart = FindTileStart(dirty.y, aDest.y, aRepeatSize.height);</span>
<span class="lineNum">     941 </span><span class="lineCov">         26 :   nscoord xEnd = forceRepeatToCoverTiles ? xStart + aDest.width : dirty.XMost();</span>
<span class="lineNum">     942 </span><span class="lineCov">         26 :   nscoord yEnd = forceRepeatToCoverTiles ? yStart + aDest.height : dirty.YMost();</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :   // x and y are the top-left corner of the tile to draw
<span class="lineNum">     945 </span><span class="lineCov">         52 :   for (nscoord y = yStart; y &lt; yEnd; y += aRepeatSize.height) {</span>
<span class="lineNum">     946 </span><span class="lineCov">         52 :     for (nscoord x = xStart; x &lt; xEnd; x += aRepeatSize.width) {</span>
<span class="lineNum">     947 </span>            :       // The coordinates of the tile
<span class="lineNum">     948 </span>            :       gfxRect tileRect = nsLayoutUtils::RectToGfxRect(
<span class="lineNum">     949 </span><span class="lineCov">         52 :                       nsRect(x, y, aDest.width, aDest.height),</span>
<span class="lineNum">     950 </span><span class="lineCov">         26 :                       appUnitsPerDevPixel);</span>
<span class="lineNum">     951 </span>            :       // The actual area to fill with this tile is the intersection of this
<span class="lineNum">     952 </span>            :       // tile with the overall area we're supposed to be filling
<span class="lineNum">     953 </span>            :       gfxRect fillRect =
<span class="lineNum">     954 </span><span class="lineCov">         26 :         forceRepeatToCoverTiles ? areaToFill : tileRect.Intersect(areaToFill);</span>
<span class="lineNum">     955 </span>            :       // Try snapping the fill rect. Snap its top-left and bottom-right
<span class="lineNum">     956 </span>            :       // independently to preserve the orientation.
<span class="lineNum">     957 </span><span class="lineCov">         26 :       gfxPoint snappedFillRectTopLeft = fillRect.TopLeft();</span>
<span class="lineNum">     958 </span><span class="lineCov">         26 :       gfxPoint snappedFillRectTopRight = fillRect.TopRight();</span>
<span class="lineNum">     959 </span><span class="lineCov">         26 :       gfxPoint snappedFillRectBottomRight = fillRect.BottomRight();</span>
<span class="lineNum">     960 </span>            :       // Snap three points instead of just two to ensure we choose the
<span class="lineNum">     961 </span>            :       // correct orientation if there's a reflection.
<span class="lineNum">     962 </span><span class="lineCov">         52 :       if (isCTMPreservingAxisAlignedRectangles &amp;&amp;</span>
<span class="lineNum">     963 </span><span class="lineCov">         52 :           aContext.UserToDevicePixelSnapped(snappedFillRectTopLeft, true) &amp;&amp;</span>
<span class="lineNum">     964 </span><span class="lineCov">         78 :           aContext.UserToDevicePixelSnapped(snappedFillRectBottomRight, true) &amp;&amp;</span>
<span class="lineNum">     965 </span><span class="lineCov">         26 :           aContext.UserToDevicePixelSnapped(snappedFillRectTopRight, true)) {</span>
<span class="lineNum">     966 </span><span class="lineCov">         52 :         if (snappedFillRectTopLeft.x == snappedFillRectBottomRight.x ||</span>
<span class="lineNum">     967 </span><span class="lineCov">         26 :             snappedFillRectTopLeft.y == snappedFillRectBottomRight.y) {</span>
<span class="lineNum">     968 </span>            :           // Nothing to draw; avoid scaling by zero and other weirdness that
<span class="lineNum">     969 </span>            :           // could put the context in an error state.
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     971 </span>            :         }
<span class="lineNum">     972 </span>            :         // Set the context's transform to the transform that maps fillRect to
<span class="lineNum">     973 </span>            :         // snappedFillRect. The part of the gradient that was going to
<span class="lineNum">     974 </span>            :         // exactly fill fillRect will fill snappedFillRect instead.
<span class="lineNum">     975 </span>            :         gfxMatrix transform = gfxUtils::TransformRectToRect(fillRect,
<span class="lineNum">     976 </span>            :             snappedFillRectTopLeft, snappedFillRectTopRight,
<span class="lineNum">     977 </span><span class="lineCov">         26 :             snappedFillRectBottomRight);</span>
<span class="lineNum">     978 </span><span class="lineCov">         26 :         aContext.SetMatrix(transform);</span>
<span class="lineNum">     979 </span>            :       }
<span class="lineNum">     980 </span><span class="lineCov">         26 :       aContext.NewPath();</span>
<span class="lineNum">     981 </span><span class="lineCov">         26 :       aContext.Rectangle(fillRect);</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineCov">         26 :       gfxRect dirtyFillRect = fillRect.Intersect(dirtyAreaToFill);</span>
<span class="lineNum">     984 </span><span class="lineCov">         26 :       gfxRect fillRectRelativeToTile = dirtyFillRect - tileRect.TopLeft();</span>
<span class="lineNum">     985 </span><span class="lineCov">         26 :       Color edgeColor;</span>
<span class="lineNum">     986 </span><span class="lineCov">         34 :       if (mGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR &amp;&amp; !isRepeat &amp;&amp;</span>
<span class="lineNum">     987 </span><span class="lineCov">          8 :           RectIsBeyondLinearGradientEdge(fillRectRelativeToTile, matrix, mStops,</span>
<span class="lineNum">     988 </span>            :                                          gradientStart, gradientEnd, &amp;edgeColor)) {
<span class="lineNum">     989 </span><span class="lineCov">          1 :         edgeColor.a *= aOpacity;</span>
<span class="lineNum">     990 </span><span class="lineCov">          1 :         aContext.SetColor(edgeColor);</span>
<span class="lineNum">     991 </span>            :       } else {
<span class="lineNum">     992 </span>            :         aContext.SetMatrix(
<span class="lineNum">     993 </span><span class="lineCov">         25 :           aContext.CurrentMatrix().Copy().PreTranslate(tileRect.TopLeft()));</span>
<span class="lineNum">     994 </span><span class="lineCov">         25 :         aContext.SetPattern(gradientPattern);</span>
<span class="lineNum">     995 </span>            :       }
<span class="lineNum">     996 </span><span class="lineCov">         26 :       aContext.Fill();</span>
<span class="lineNum">     997 </span><span class="lineCov">         26 :       aContext.SetMatrix(ctm);</span>
<span class="lineNum">     998 </span>            :     }
<span class="lineNum">     999 </span>            :   }
<span class="lineNum">    1000 </span>            : }
<a name="1001"><span class="lineNum">    1001 </span>            : </a>
<span class="lineNum">    1002 </span>            : void
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 : nsCSSGradientRenderer::BuildWebRenderParameters(float aOpacity,</span>
<span class="lineNum">    1004 </span>            :                                                 WrGradientExtendMode&amp; aMode,
<span class="lineNum">    1005 </span>            :                                                 nsTArray&lt;WrGradientStop&gt;&amp; aStops,
<span class="lineNum">    1006 </span>            :                                                 LayoutDevicePoint&amp; aLineStart,
<span class="lineNum">    1007 </span>            :                                                 LayoutDevicePoint&amp; aLineEnd,
<span class="lineNum">    1008 </span>            :                                                 LayoutDeviceSize&amp; aGradientRadius)
<span class="lineNum">    1009 </span>            : {
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   aMode = mGradient-&gt;mRepeating ? WrGradientExtendMode::Repeat : WrGradientExtendMode::Clamp;</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   aStops.SetLength(mStops.Length());</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   for(uint32_t i = 0; i &lt; mStops.Length(); i++) {</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     aStops[i].color.r = mStops[i].mColor.r;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     aStops[i].color.g = mStops[i].mColor.g;</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     aStops[i].color.b = mStops[i].mColor.b;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     aStops[i].color.a = mStops[i].mColor.a * aOpacity;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     aStops[i].offset = mStops[i].mPosition;</span>
<span class="lineNum">    1019 </span>            :   }
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   aLineStart = LayoutDevicePoint(mLineStart.x, mLineStart.y);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   aLineEnd = LayoutDevicePoint(mLineEnd.x, mLineEnd.y);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   aGradientRadius = LayoutDeviceSize(mRadiusX, mRadiusY);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 : }</span>
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<span class="lineNum">    1026 </span>            : void
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 : nsCSSGradientRenderer::BuildWebRenderDisplayItems(wr::DisplayListBuilder&amp; aBuilder,</span>
<span class="lineNum">    1028 </span>            :                                                   const layers::StackingContextHelper&amp; aSc,
<span class="lineNum">    1029 </span>            :                                                   layers::WebRenderDisplayItemLayer* aLayer,
<span class="lineNum">    1030 </span>            :                                                   const nsRect&amp; aDest,
<span class="lineNum">    1031 </span>            :                                                   const nsRect&amp; aFillArea,
<span class="lineNum">    1032 </span>            :                                                   const nsSize&amp; aRepeatSize,
<span class="lineNum">    1033 </span>            :                                                   const CSSIntRect&amp; aSrc,
<span class="lineNum">    1034 </span>            :                                                   float aOpacity)
<span class="lineNum">    1035 </span>            : {
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   if (aDest.IsEmpty() || aFillArea.IsEmpty()) {</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1038 </span>            :   }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   WrGradientExtendMode extendMode;
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   nsTArray&lt;WrGradientStop&gt; stops;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   LayoutDevicePoint lineStart;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   LayoutDevicePoint lineEnd;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   LayoutDeviceSize gradientRadius;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   BuildWebRenderParameters(aOpacity, extendMode, stops, lineStart, lineEnd, gradientRadius);</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   nscoord appUnitsPerDevPixel = mPresContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   nsPoint firstTile = nsPoint(FindTileStart(aFillArea.x, aDest.x, aRepeatSize.width),</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                               FindTileStart(aFillArea.y, aDest.y, aRepeatSize.height));</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :   // Translate the parameters into device coordinates
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   LayoutDeviceRect clipBounds = LayoutDevicePixel::FromAppUnits(aFillArea, appUnitsPerDevPixel);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   LayoutDeviceRect firstTileBounds = LayoutDevicePixel::FromAppUnits(nsRect(firstTile, aDest.Size()), appUnitsPerDevPixel);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   LayoutDeviceSize tileRepeat = LayoutDevicePixel::FromAppUnits(aRepeatSize, appUnitsPerDevPixel);</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            :   // Calculate the bounds of the gradient display item, which starts at the first
<span class="lineNum">    1058 </span>            :   // tile and extends to the end of clip bounds
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   LayoutDevicePoint tileToClip = clipBounds.BottomRight() - firstTileBounds.TopLeft();</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   LayoutDeviceRect gradientBounds = LayoutDeviceRect(firstTileBounds.TopLeft(),</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                                                      LayoutDeviceSize(tileToClip.x, tileToClip.y));</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :   // Calculate the tile spacing, which is the repeat size minus the tile size
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   LayoutDeviceSize tileSpacing = tileRepeat - firstTileBounds.Size();</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :   // Make the rects relative to the parent stacking context
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   WrRect wrClipBounds = aSc.ToRelativeWrRect(clipBounds);</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   LayerSize layerFirstTileSize = ViewAs&lt;LayerPixel&gt;(firstTileBounds.Size(),</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       PixelCastJustification::WebRenderHasUnitResolution);</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   WrRect wrGradientBounds = aSc.ToRelativeWrRect(gradientBounds);</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :   // srcTransform is used for scaling the gradient to match aSrc
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   LayoutDeviceRect srcTransform = LayoutDeviceRect(mPresContext-&gt;CSSPixelsToAppUnits(aSrc.x),</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                                                    mPresContext-&gt;CSSPixelsToAppUnits(aSrc.y),</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                                                    aDest.width / ((float)mPresContext-&gt;CSSPixelsToAppUnits(aSrc.width)),</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                                                    aDest.height / ((float)mPresContext-&gt;CSSPixelsToAppUnits(aSrc.height)));</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   lineStart.x = (lineStart.x - srcTransform.x) * srcTransform.width;</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   lineStart.y = (lineStart.y - srcTransform.y) * srcTransform.height;</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :   if (mGradient-&gt;mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     lineEnd.x = (lineEnd.x - srcTransform.x) * srcTransform.width;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     lineEnd.y = (lineEnd.y - srcTransform.y) * srcTransform.height;</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     aBuilder.PushLinearGradient(</span>
<span class="lineNum">    1086 </span>            :       wrGradientBounds,
<span class="lineNum">    1087 </span>            :       wrClipBounds,
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrPoint(lineStart),</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrPoint(lineEnd),</span>
<span class="lineNum">    1090 </span>            :       stops,
<span class="lineNum">    1091 </span>            :       extendMode,
<span class="lineNum">    1092 </span>            :       mozilla::wr::ToWrSize(layerFirstTileSize),
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrSize(tileSpacing));</span>
<span class="lineNum">    1094 </span>            :   } else {
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     gradientRadius.width *= srcTransform.width;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     gradientRadius.height *= srcTransform.height;</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     aBuilder.PushRadialGradient(</span>
<span class="lineNum">    1099 </span>            :       wrGradientBounds,
<span class="lineNum">    1100 </span>            :       wrClipBounds,
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrPoint(lineStart),</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrSize(gradientRadius),</span>
<span class="lineNum">    1103 </span>            :       stops,
<span class="lineNum">    1104 </span>            :       extendMode,
<span class="lineNum">    1105 </span>            :       mozilla::wr::ToWrSize(layerFirstTileSize),
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :       mozilla::wr::ToWrSize(tileSpacing));</span>
<span class="lineNum">    1107 </span>            :   }
<span class="lineNum">    1108 </span>            : }
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

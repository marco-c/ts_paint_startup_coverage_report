<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/generic/nsTextFrameUtils.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/generic</a> - nsTextFrameUtils.cpp<span style="font-size: 80%;"> (source / <a href="nsTextFrameUtils.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">82</td>
            <td class="headerCovTableEntry">180</td>
            <td class="headerCovTableEntryLo">45.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">46.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #include &quot;nsTextFrameUtils.h&quot;
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;nsBidiUtils.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;nsCharTraits.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsIContent.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsStyleStruct.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsTextFragment.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsUnicharUtils.h&quot;
<span class="lineNum">      14 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : using namespace mozilla;
<a name="17"><span class="lineNum">      17 </span>            : </a>
<span class="lineNum">      18 </span>            : static bool
<span class="lineNum">      19 </span><span class="lineNoCov">          0 : IsDiscardable(char16_t ch, nsTextFrameUtils::Flags* aFlags)</span>
<span class="lineNum">      20 </span>            : {
<span class="lineNum">      21 </span>            :   // Unlike IS_DISCARDABLE, we don't discard \r. \r will be ignored by gfxTextRun
<span class="lineNum">      22 </span>            :   // and discarding it would force us to copy text in many cases of preformatted
<span class="lineNum">      23 </span>            :   // text containing \r\n.
<span class="lineNum">      24 </span><span class="lineNoCov">          0 :   if (ch == CH_SHY) {</span>
<span class="lineNum">      25 </span><span class="lineNoCov">          0 :     *aFlags |= nsTextFrameUtils::Flags::TEXT_HAS_SHY;</span>
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">      27 </span>            :   }
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   return IsBidiControl(ch);</span>
<span class="lineNum">      29 </span>            : }
<a name="30"><span class="lineNum">      30 </span>            : </a>
<span class="lineNum">      31 </span>            : static bool
<span class="lineNum">      32 </span><span class="lineCov">        214 : IsDiscardable(uint8_t ch, nsTextFrameUtils::Flags* aFlags)</span>
<span class="lineNum">      33 </span>            : {
<span class="lineNum">      34 </span><span class="lineCov">        214 :   if (ch == CH_SHY) {</span>
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :     *aFlags |= nsTextFrameUtils::Flags::TEXT_HAS_SHY;</span>
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">      37 </span>            :   }
<span class="lineNum">      38 </span><span class="lineCov">        214 :   return false;</span>
<span class="lineNum">      39 </span>            : }
<a name="40"><span class="lineNum">      40 </span>            : </a>
<span class="lineNum">      41 </span>            : static bool
<span class="lineNum">      42 </span><span class="lineCov">        104 : IsSegmentBreak(char16_t aCh)</span>
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span><span class="lineCov">        104 :   return aCh == '\n' || aCh == '\r';</span>
<span class="lineNum">      45 </span>            : }
<a name="46"><span class="lineNum">      46 </span>            : </a>
<span class="lineNum">      47 </span>            : static bool
<span class="lineNum">      48 </span><span class="lineCov">        110 : IsSpaceOrTab(char16_t aCh)</span>
<span class="lineNum">      49 </span>            : {
<span class="lineNum">      50 </span><span class="lineCov">        110 :   return aCh == ' ' || aCh == '\t';</span>
<span class="lineNum">      51 </span>            : }
<a name="52"><span class="lineNum">      52 </span>            : </a>
<span class="lineNum">      53 </span>            : static bool
<span class="lineNum">      54 </span><span class="lineCov">        104 : IsSpaceOrTabOrSegmentBreak(char16_t aCh)</span>
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span><span class="lineCov">        104 :   return IsSpaceOrTab(aCh) || IsSegmentBreak(aCh);</span>
<span class="lineNum">      57 </span>            : }
<span class="lineNum">      58 </span>            : 
<a name="59"><span class="lineNum">      59 </span>            : template&lt;typename CharT&gt;</a>
<span class="lineNum">      60 </span>            : /* static */ bool
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : nsTextFrameUtils::IsSkippableCharacterForTransformText(CharT aChar)</span>
<span class="lineNum">      62 </span>            : {
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   return aChar == ' ' ||</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :          aChar == '\t' ||</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :          aChar == '\n' ||</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :          aChar == CH_SHY ||</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :          (aChar &gt; 0xFF &amp;&amp; IsBidiControl(aChar));</span>
<span class="lineNum">      68 </span>            : }
<span class="lineNum">      69 </span>            : 
<a name="70"><span class="lineNum">      70 </span>            : #ifdef DEBUG</a>
<span class="lineNum">      71 </span>            : template&lt;typename CharT&gt;
<span class="lineNum">      72 </span><span class="lineCov">         21 : static void AssertSkippedExpectedChars(const CharT* aText,</span>
<span class="lineNum">      73 </span>            :                                        const gfxSkipChars&amp; aSkipChars,
<span class="lineNum">      74 </span>            :                                        int32_t aSkipCharsOffset)
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span><span class="lineCov">         21 :   gfxSkipCharsIterator it(aSkipChars);</span>
<span class="lineNum">      77 </span><span class="lineCov">         21 :   it.AdvanceOriginal(aSkipCharsOffset);</span>
<span class="lineNum">      78 </span><span class="lineCov">        425 :   while (it.GetOriginalOffset() &lt; it.GetOriginalEnd()) {</span>
<span class="lineNum">      79 </span><span class="lineCov">        202 :     CharT ch = aText[it.GetOriginalOffset() - aSkipCharsOffset];</span>
<span class="lineNum">      80 </span><span class="lineCov">        202 :     MOZ_ASSERT(!it.IsOriginalCharSkipped() ||</span>
<span class="lineNum">      81 </span>            :                nsTextFrameUtils::IsSkippableCharacterForTransformText(ch),
<span class="lineNum">      82 </span>            :                &quot;skipped unexpected character; need to update &quot;
<span class="lineNum">      83 </span>            :                &quot;IsSkippableCharacterForTransformText?&quot;);
<span class="lineNum">      84 </span><span class="lineCov">        202 :     it.AdvanceOriginal(1);</span>
<span class="lineNum">      85 </span>            :   }
<span class="lineNum">      86 </span><span class="lineCov">         21 : }</span>
<span class="lineNum">      87 </span>            : #endif
<span class="lineNum">      88 </span>            : 
<a name="89"><span class="lineNum">      89 </span>            : template&lt;class CharT&gt;</a>
<span class="lineNum">      90 </span>            : static CharT*
<span class="lineNum">      91 </span><span class="lineCov">          6 : TransformWhiteSpaces(const CharT* aText, uint32_t aLength,</span>
<span class="lineNum">      92 </span>            :                      uint32_t aBegin, uint32_t aEnd,
<span class="lineNum">      93 </span>            :                      bool aHasSegmentBreak,
<span class="lineNum">      94 </span>            :                      bool&amp; aInWhitespace,
<span class="lineNum">      95 </span>            :                      CharT* aOutput,
<span class="lineNum">      96 </span>            :                      nsTextFrameUtils::Flags&amp; aFlags,
<span class="lineNum">      97 </span>            :                      nsTextFrameUtils::CompressionMode aCompression,
<span class="lineNum">      98 </span>            :                      gfxSkipChars* aSkipChars)
<span class="lineNum">      99 </span>            : {
<span class="lineNum">     100 </span><span class="lineCov">          6 :   MOZ_ASSERT(aCompression == nsTextFrameUtils::COMPRESS_WHITESPACE ||</span>
<span class="lineNum">     101 </span>            :              aCompression == nsTextFrameUtils::COMPRESS_WHITESPACE_NEWLINE,
<span class="lineNum">     102 </span>            :              &quot;whitespaces should be skippable!!&quot;);
<span class="lineNum">     103 </span>            :   // Get the context preceding/following this white space range.
<span class="lineNum">     104 </span>            :   // For 8-bit text (sizeof CharT == 1), the checks here should get optimized
<span class="lineNum">     105 </span>            :   // out, and isSegmentBreakSkippable should be initialized to be 'false'.
<span class="lineNum">     106 </span>            :   bool isSegmentBreakSkippable =
<span class="lineNum">     107 </span>            :     sizeof(CharT) &gt; 1 &amp;&amp;
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     ((aBegin &gt; 0 &amp;&amp; IS_ZERO_WIDTH_SPACE(aText[aBegin - 1])) ||</span>
<span class="lineNum">     109 </span><span class="lineCov">          6 :      (aEnd &lt; aLength &amp;&amp; IS_ZERO_WIDTH_SPACE(aText[aEnd])));</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   if (sizeof(CharT) &gt; 1 &amp;&amp; !isSegmentBreakSkippable &amp;&amp;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :       aBegin &gt; 0 &amp;&amp; aEnd &lt; aLength) {</span>
<span class="lineNum">     112 </span>            :     uint32_t ucs4before;
<span class="lineNum">     113 </span>            :     uint32_t ucs4after;
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     if (aBegin &gt; 1 &amp;&amp;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         NS_IS_LOW_SURROGATE(aText[aBegin - 1]) &amp;&amp;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         NS_IS_HIGH_SURROGATE(aText[aBegin - 2])) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       ucs4before = SURROGATE_TO_UCS4(aText[aBegin - 2], aText[aBegin - 1]);</span>
<span class="lineNum">     118 </span>            :     } else {
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       ucs4before = aText[aBegin - 1];</span>
<span class="lineNum">     120 </span>            :     }
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     if (aEnd + 1 &lt; aLength &amp;&amp;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :         NS_IS_HIGH_SURROGATE(aText[aEnd]) &amp;&amp;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :         NS_IS_LOW_SURROGATE(aText[aEnd + 1])) {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :       ucs4after = SURROGATE_TO_UCS4(aText[aEnd], aText[aEnd + 1]);</span>
<span class="lineNum">     125 </span>            :     } else {
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :       ucs4after = aText[aEnd];</span>
<span class="lineNum">     127 </span>            :     }
<span class="lineNum">     128 </span>            :     // Discard newlines between characters that have F, W, or H
<span class="lineNum">     129 </span>            :     // EastAsianWidth property and neither side is Hangul.
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     isSegmentBreakSkippable = IsSegmentBreakSkipChar(ucs4before) &amp;&amp;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :                               IsSegmentBreakSkipChar(ucs4after);</span>
<span class="lineNum">     132 </span>            :   }
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineCov">         12 :   for (uint32_t i = aBegin; i &lt; aEnd; ++i) {</span>
<span class="lineNum">     135 </span><span class="lineCov">          6 :     CharT ch = aText[i];</span>
<span class="lineNum">     136 </span><span class="lineCov">          6 :     bool keepChar = false;</span>
<span class="lineNum">     137 </span><span class="lineCov">          6 :     bool keepTransformedWhiteSpace = false;</span>
<span class="lineNum">     138 </span><span class="lineCov">          6 :     if (IsDiscardable(ch, &amp;aFlags)) {</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :       aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     141 </span>            :     }
<span class="lineNum">     142 </span><span class="lineCov">          6 :     if (IsSpaceOrTab(ch)) {</span>
<span class="lineNum">     143 </span><span class="lineCov">          6 :       if (aHasSegmentBreak) {</span>
<span class="lineNum">     144 </span>            :         // If white-space is set to normal, nowrap, or pre-line, white space
<span class="lineNum">     145 </span>            :         // characters are considered collapsible and all spaces and tabs
<span class="lineNum">     146 </span>            :         // immediately preceding or following a segment break are removed.
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :         aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     149 </span>            :       }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineCov">          6 :       if (aInWhitespace) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     154 </span>            :       } else {
<span class="lineNum">     155 </span><span class="lineCov">          6 :         keepTransformedWhiteSpace = true;</span>
<span class="lineNum">     156 </span>            :       }
<span class="lineNum">     157 </span>            :     } else {
<span class="lineNum">     158 </span>            :       // Apply Segment Break Transformation Rules (CSS Text 3 - 4.1.2) for
<span class="lineNum">     159 </span>            :       // segment break characters.
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       if (aCompression == nsTextFrameUtils::COMPRESS_WHITESPACE ||</span>
<span class="lineNum">     161 </span>            :           // XXX: According to CSS Text 3, a lone CR should not always be
<span class="lineNum">     162 </span>            :           //      kept, but still go through the Segment Break Transformation
<span class="lineNum">     163 </span>            :           //      Rules. However, this is what current modern browser engines
<span class="lineNum">     164 </span>            :           //      (webkit/blink/edge) do. So, once we can get some clarity
<span class="lineNum">     165 </span>            :           //      from the specification issue, we should either remove the
<span class="lineNum">     166 </span>            :           //      lone CR condition here, or leave it here with this comment
<span class="lineNum">     167 </span>            :           //      being rephrased.
<span class="lineNum">     168 </span>            :           //      Please see https://github.com/w3c/csswg-drafts/issues/855.
<span class="lineNum">     169 </span>            :           ch == '\r') {
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         keepChar = true;</span>
<span class="lineNum">     171 </span>            :       } else {
<span class="lineNum">     172 </span>            :         // aCompression == COMPRESS_WHITESPACE_NEWLINE
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :         // Any collapsible segment break immediately following another
<span class="lineNum">     175 </span>            :         // collapsible segment break is removed.  Then the remaining segment
<span class="lineNum">     176 </span>            :         // break is either transformed into a space (U+0020) or removed
<span class="lineNum">     177 </span>            :         // depending on the context before and after the break.
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         if (isSegmentBreakSkippable || aInWhitespace) {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :           aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     181 </span>            :         }
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         isSegmentBreakSkippable = true;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         keepTransformedWhiteSpace = true;</span>
<span class="lineNum">     184 </span>            :       }
<span class="lineNum">     185 </span>            :     }
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineCov">          6 :     if (keepChar) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :       *aOutput++ = ch;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       aSkipChars-&gt;KeepChar();</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       aInWhitespace = IsSpaceOrTab(ch);</span>
<span class="lineNum">     191 </span><span class="lineCov">          6 :     } else if (keepTransformedWhiteSpace) {</span>
<span class="lineNum">     192 </span><span class="lineCov">          6 :       *aOutput++ = ' ';</span>
<span class="lineNum">     193 </span><span class="lineCov">          6 :       aSkipChars-&gt;KeepChar();</span>
<span class="lineNum">     194 </span><span class="lineCov">          6 :       aInWhitespace = true;</span>
<span class="lineNum">     195 </span>            :     } else {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;Should've skipped the character!!&quot;);</span>
<span class="lineNum">     197 </span>            :     }
<span class="lineNum">     198 </span>            :   }
<span class="lineNum">     199 </span><span class="lineCov">          6 :   return aOutput;</span>
<span class="lineNum">     200 </span>            : }
<span class="lineNum">     201 </span>            : 
<a name="202"><span class="lineNum">     202 </span>            : template&lt;class CharT&gt;</a>
<span class="lineNum">     203 </span>            : CharT*
<span class="lineNum">     204 </span><span class="lineCov">         21 : nsTextFrameUtils::TransformText(const CharT* aText, uint32_t aLength,</span>
<span class="lineNum">     205 </span>            :                                 CharT* aOutput,
<span class="lineNum">     206 </span>            :                                 CompressionMode aCompression,
<span class="lineNum">     207 </span>            :                                 uint8_t* aIncomingFlags,
<span class="lineNum">     208 </span>            :                                 gfxSkipChars* aSkipChars,
<span class="lineNum">     209 </span>            :                                 Flags* aAnalysisFlags)
<span class="lineNum">     210 </span>            : {
<span class="lineNum">     211 </span><span class="lineCov">         21 :   Flags flags = Flags();</span>
<span class="lineNum">     212 </span>            : #ifdef DEBUG
<span class="lineNum">     213 </span><span class="lineCov">         21 :   int32_t skipCharsOffset = aSkipChars-&gt;GetOriginalCharCount();</span>
<span class="lineNum">     214 </span>            : #endif
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineCov">         21 :   bool lastCharArabic = false;</span>
<span class="lineNum">     217 </span><span class="lineCov">         21 :   if (aCompression == COMPRESS_NONE ||</span>
<span class="lineNum">     218 </span>            :       aCompression == COMPRESS_NONE_TRANSFORM_TO_SPACE) {
<span class="lineNum">     219 </span>            :     // Skip discardables.
<span class="lineNum">     220 </span>            :     uint32_t i;
<span class="lineNum">     221 </span><span class="lineCov">        111 :     for (i = 0; i &lt; aLength; ++i) {</span>
<span class="lineNum">     222 </span><span class="lineCov">        104 :       CharT ch = aText[i];</span>
<span class="lineNum">     223 </span><span class="lineCov">        104 :       if (IsDiscardable(ch, &amp;flags)) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     225 </span>            :       } else {
<span class="lineNum">     226 </span><span class="lineCov">        104 :         aSkipChars-&gt;KeepChar();</span>
<span class="lineNum">     227 </span><span class="lineCov">        104 :         if (ch &gt; ' ') {</span>
<span class="lineNum">     228 </span><span class="lineCov">         98 :           lastCharArabic = IS_ARABIC_CHAR(ch);</span>
<span class="lineNum">     229 </span><span class="lineCov">          6 :         } else if (aCompression == COMPRESS_NONE_TRANSFORM_TO_SPACE) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :           if (ch == '\t' || ch == '\n') {</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :             ch = ' ';</span>
<span class="lineNum">     232 </span>            :           }
<span class="lineNum">     233 </span>            :         } else {
<span class="lineNum">     234 </span>            :           // aCompression == COMPRESS_NONE
<span class="lineNum">     235 </span><span class="lineCov">          6 :           if (ch == '\t') {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :             flags |= Flags::TEXT_HAS_TAB;</span>
<span class="lineNum">     237 </span>            :           }
<span class="lineNum">     238 </span>            :         }
<span class="lineNum">     239 </span><span class="lineCov">        104 :         *aOutput++ = ch;</span>
<span class="lineNum">     240 </span>            :       }
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span><span class="lineCov">          7 :     if (lastCharArabic) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       *aIncomingFlags |= INCOMING_ARABICCHAR;</span>
<span class="lineNum">     244 </span>            :     } else {
<span class="lineNum">     245 </span><span class="lineCov">          7 :       *aIncomingFlags &amp;= ~INCOMING_ARABICCHAR;</span>
<span class="lineNum">     246 </span>            :     }
<span class="lineNum">     247 </span><span class="lineCov">          7 :     *aIncomingFlags &amp;= ~INCOMING_WHITESPACE;</span>
<span class="lineNum">     248 </span>            :   } else {
<span class="lineNum">     249 </span><span class="lineCov">         14 :     bool inWhitespace = (*aIncomingFlags &amp; INCOMING_WHITESPACE) != 0;</span>
<span class="lineNum">     250 </span>            :     uint32_t i;
<span class="lineNum">     251 </span><span class="lineCov">        112 :     for (i = 0; i &lt; aLength; ++i) {</span>
<span class="lineNum">     252 </span><span class="lineCov">         98 :       CharT ch = aText[i];</span>
<span class="lineNum">     253 </span>            :       // CSS Text 3 - 4.1. The White Space Processing Rules
<span class="lineNum">     254 </span>            :       // White space processing in CSS affects only the document white space
<span class="lineNum">     255 </span>            :       // characters: spaces (U+0020), tabs (U+0009), and segment breaks.
<span class="lineNum">     256 </span>            :       // Since we need the context of segment breaks and their surrounding
<span class="lineNum">     257 </span>            :       // white spaces to proceed the white space processing, a consecutive run
<span class="lineNum">     258 </span>            :       // of spaces/tabs/segment breaks is collected in a first pass loop, then
<span class="lineNum">     259 </span>            :       // we apply the collapsing and transformation rules to this run in a
<span class="lineNum">     260 </span>            :       // second pass loop.
<span class="lineNum">     261 </span><span class="lineCov">         98 :       if (IsSpaceOrTabOrSegmentBreak(ch)) {</span>
<span class="lineNum">     262 </span><span class="lineCov">          6 :         bool keepLastSpace = false;</span>
<span class="lineNum">     263 </span><span class="lineCov">          6 :         bool hasSegmentBreak = IsSegmentBreak(ch);</span>
<span class="lineNum">     264 </span><span class="lineCov">          6 :         uint32_t countTrailingDiscardables = 0;</span>
<span class="lineNum">     265 </span>            :         uint32_t j;
<span class="lineNum">     266 </span><span class="lineCov">         12 :         for (j = i + 1; j &lt; aLength &amp;&amp;</span>
<span class="lineNum">     267 </span><span class="lineCov">         12 :                         (IsSpaceOrTabOrSegmentBreak(aText[j]) ||</span>
<span class="lineNum">     268 </span><span class="lineCov">          6 :                          IsDiscardable(aText[j], &amp;flags));</span>
<span class="lineNum">     269 </span>            :              j++) {
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :           if (IsSegmentBreak(aText[j])) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :             hasSegmentBreak = true;</span>
<span class="lineNum">     272 </span>            :           }
<span class="lineNum">     273 </span>            :         }
<span class="lineNum">     274 </span>            :         // Exclude trailing discardables before checking space combining
<span class="lineNum">     275 </span>            :         // sequence tail.
<span class="lineNum">     276 </span><span class="lineCov">          6 :         for (; IsDiscardable(aText[j - 1], &amp;flags); j--) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :           countTrailingDiscardables++;</span>
<span class="lineNum">     278 </span>            :         }
<span class="lineNum">     279 </span>            :         // If the last white space is followed by a combining sequence tail,
<span class="lineNum">     280 </span>            :         // exclude it from the range of TransformWhiteSpaces.
<span class="lineNum">     281 </span><span class="lineCov">          6 :         if (sizeof(CharT) &gt; 1 &amp;&amp; aText[j - 1] == ' ' &amp;&amp; j &lt; aLength &amp;&amp;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             IsSpaceCombiningSequenceTail(&amp;aText[j], aLength - j)) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :           keepLastSpace = true;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :           j--;</span>
<span class="lineNum">     285 </span>            :         }
<span class="lineNum">     286 </span><span class="lineCov">          6 :         if (j &gt; i) {</span>
<span class="lineNum">     287 </span><span class="lineCov">          6 :           aOutput = TransformWhiteSpaces(aText, aLength, i, j, hasSegmentBreak,</span>
<span class="lineNum">     288 </span>            :                                          inWhitespace, aOutput, flags,
<span class="lineNum">     289 </span>            :                                          aCompression, aSkipChars);
<span class="lineNum">     290 </span>            :         }
<span class="lineNum">     291 </span>            :         // We need to keep KeepChar()/SkipChar() in order, so process the
<span class="lineNum">     292 </span>            :         // last white space first, then process the trailing discardables.
<span class="lineNum">     293 </span><span class="lineCov">          6 :         if (keepLastSpace) {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :           keepLastSpace = false;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :           *aOutput++ = ' ';</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :           aSkipChars-&gt;KeepChar();</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :           lastCharArabic = false;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :           j++;</span>
<span class="lineNum">     299 </span>            :         }
<span class="lineNum">     300 </span><span class="lineCov">          6 :         for (; countTrailingDiscardables &gt; 0; countTrailingDiscardables--) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :           aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :           j++;</span>
<span class="lineNum">     303 </span>            :         }
<span class="lineNum">     304 </span><span class="lineCov">          6 :         i = j - 1;</span>
<span class="lineNum">     305 </span><span class="lineCov">          6 :         continue;</span>
<span class="lineNum">     306 </span>            :       }
<span class="lineNum">     307 </span>            :       // Process characters other than the document white space characters.
<span class="lineNum">     308 </span><span class="lineCov">         92 :       if (IsDiscardable(ch, &amp;flags)) {</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         aSkipChars-&gt;SkipChar();</span>
<span class="lineNum">     310 </span>            :       } else {
<span class="lineNum">     311 </span><span class="lineCov">         92 :         *aOutput++ = ch;</span>
<span class="lineNum">     312 </span><span class="lineCov">         92 :         aSkipChars-&gt;KeepChar();</span>
<span class="lineNum">     313 </span>            :       }
<span class="lineNum">     314 </span><span class="lineCov">         92 :       lastCharArabic = IS_ARABIC_CHAR(ch);</span>
<span class="lineNum">     315 </span><span class="lineCov">         92 :       inWhitespace = false;</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">         14 :     if (lastCharArabic) {</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       *aIncomingFlags |= INCOMING_ARABICCHAR;</span>
<span class="lineNum">     320 </span>            :     } else {
<span class="lineNum">     321 </span><span class="lineCov">         14 :       *aIncomingFlags &amp;= ~INCOMING_ARABICCHAR;</span>
<span class="lineNum">     322 </span>            :     }
<span class="lineNum">     323 </span><span class="lineCov">         14 :     if (inWhitespace) {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :       *aIncomingFlags |= INCOMING_WHITESPACE;</span>
<span class="lineNum">     325 </span>            :     } else {
<span class="lineNum">     326 </span><span class="lineCov">         14 :       *aIncomingFlags &amp;= ~INCOMING_WHITESPACE;</span>
<span class="lineNum">     327 </span>            :     }
<span class="lineNum">     328 </span>            :   }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">         21 :   *aAnalysisFlags = flags;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : #ifdef DEBUG
<span class="lineNum">     333 </span><span class="lineCov">         21 :   AssertSkippedExpectedChars(aText, *aSkipChars, skipCharsOffset);</span>
<span class="lineNum">     334 </span>            : #endif
<span class="lineNum">     335 </span><span class="lineCov">         21 :   return aOutput;</span>
<span class="lineNum">     336 </span>            : }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : /*
<span class="lineNum">     339 </span>            :  * NOTE: The TransformText and IsSkippableCharacterForTransformText template
<span class="lineNum">     340 </span>            :  * functions are part of the public API of nsTextFrameUtils, while
<span class="lineNum">     341 </span>            :  * their function bodies are not available in the header. They may stop working
<span class="lineNum">     342 </span>            :  * (fail to resolve symbol in link time) once their callsites are moved to a
<span class="lineNum">     343 </span>            :  * different translation unit (e.g. a different unified source file).
<span class="lineNum">     344 </span>            :  * Explicit instantiating this function template with `uint8_t` and `char16_t`
<span class="lineNum">     345 </span>            :  * could prevent us from the potential risk.
<span class="lineNum">     346 </span>            :  */
<span class="lineNum">     347 </span>            : template uint8_t*
<span class="lineNum">     348 </span>            : nsTextFrameUtils::TransformText(const uint8_t* aText, uint32_t aLength,
<span class="lineNum">     349 </span>            :                                 uint8_t* aOutput,
<span class="lineNum">     350 </span>            :                                 CompressionMode aCompression,
<span class="lineNum">     351 </span>            :                                 uint8_t* aIncomingFlags,
<span class="lineNum">     352 </span>            :                                 gfxSkipChars* aSkipChars,
<span class="lineNum">     353 </span>            :                                 Flags* aAnalysisFlags);
<span class="lineNum">     354 </span>            : template char16_t*
<span class="lineNum">     355 </span>            : nsTextFrameUtils::TransformText(const char16_t* aText, uint32_t aLength,
<span class="lineNum">     356 </span>            :                                 char16_t* aOutput,
<span class="lineNum">     357 </span>            :                                 CompressionMode aCompression,
<span class="lineNum">     358 </span>            :                                 uint8_t* aIncomingFlags,
<span class="lineNum">     359 </span>            :                                 gfxSkipChars* aSkipChars,
<span class="lineNum">     360 </span>            :                                 Flags* aAnalysisFlags);
<span class="lineNum">     361 </span>            : template bool
<span class="lineNum">     362 </span>            : nsTextFrameUtils::IsSkippableCharacterForTransformText(uint8_t aChar);
<span class="lineNum">     363 </span>            : template bool
<span class="lineNum">     364 </span>            : nsTextFrameUtils::IsSkippableCharacterForTransformText(char16_t aChar);
<a name="365"><span class="lineNum">     365 </span>            : </a>
<span class="lineNum">     366 </span>            : uint32_t
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : nsTextFrameUtils::ComputeApproximateLengthWithWhitespaceCompression(</span>
<span class="lineNum">     368 </span>            :                     nsIContent *aContent, const nsStyleText *aStyleText)
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   const nsTextFragment *frag = aContent-&gt;GetText();</span>
<span class="lineNum">     371 </span>            :   // This is an approximation so we don't really need anything
<span class="lineNum">     372 </span>            :   // too fancy here.
<span class="lineNum">     373 </span>            :   uint32_t len;
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   if (aStyleText-&gt;WhiteSpaceIsSignificant()) {</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     len = frag-&gt;GetLength();</span>
<span class="lineNum">     376 </span>            :   } else {
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     bool is2b = frag-&gt;Is2b();</span>
<span class="lineNum">     378 </span>            :     union {
<span class="lineNum">     379 </span>            :       const char *s1b;
<span class="lineNum">     380 </span>            :       const char16_t *s2b;
<span class="lineNum">     381 </span>            :     } u;
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     if (is2b) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       u.s2b = frag-&gt;Get2b();</span>
<span class="lineNum">     384 </span>            :     } else {
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       u.s1b = frag-&gt;Get1b();</span>
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     bool prevWS = true; // more important to ignore blocks with</span>
<span class="lineNum">     388 </span>            :                         // only whitespace than get inline boundaries
<span class="lineNum">     389 </span>            :                         // exactly right
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     len = 0;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0, i_end = frag-&gt;GetLength(); i &lt; i_end; ++i) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :       char16_t c = is2b ? u.s2b[i] : u.s1b[i];</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       if (c == ' ' || c == '\n' || c == '\t' || c == '\r') {</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         if (!prevWS) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :           ++len;</span>
<span class="lineNum">     396 </span>            :         }
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         prevWS = true;</span>
<span class="lineNum">     398 </span>            :       } else {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         ++len;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         prevWS = false;</span>
<span class="lineNum">     401 </span>            :       }
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   return len;</span>
<a name="405"><span class="lineNum">     405 </span>            : }</a>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineNoCov">          0 : bool nsSkipCharsRunIterator::NextRun() {</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     if (mRunLength) {</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       mIterator.AdvanceOriginal(mRunLength);</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :       NS_ASSERTION(mRunLength &gt; 0, &quot;No characters in run (initial length too large?)&quot;);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       if (!mSkipped || mLengthIncludesSkipped) {</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         mRemainingLength -= mRunLength;</span>
<span class="lineNum">     414 </span>            :       }
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     if (!mRemainingLength)</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     418 </span>            :     int32_t length;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     mSkipped = mIterator.IsOriginalCharSkipped(&amp;length);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     mRunLength = std::min(length, mRemainingLength);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   } while (!mVisitSkipped &amp;&amp; mSkipped);</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     424 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

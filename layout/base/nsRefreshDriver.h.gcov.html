<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/base/nsRefreshDriver.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/base</a> - nsRefreshDriver.h<span style="font-size: 80%;"> (source / <a href="nsRefreshDriver.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntry">50</td>
            <td class="headerCovTableEntryMed">82.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /*
<span class="lineNum">       8 </span>            :  * Code to notify things that animate before a refresh, at an appropriate
<span class="lineNum">       9 </span>            :  * refresh rate.  (Perhaps temporary, until replaced by compositor.)
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef nsRefreshDriver_h_
<span class="lineNum">      13 </span>            : #define nsRefreshDriver_h_
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;mozilla/FlushType.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/TimeStamp.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/Vector.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/WeakPtr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsTObserverArray.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsTHashtable.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsTObserverArray.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsClassHashtable.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsHashKeys.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;mozilla/layers/TransactionIdAllocator.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : class nsPresContext;
<span class="lineNum">      31 </span>            : class nsIPresShell;
<span class="lineNum">      32 </span>            : class nsIDocument;
<span class="lineNum">      33 </span>            : class imgIRequest;
<span class="lineNum">      34 </span>            : class nsIDOMEvent;
<span class="lineNum">      35 </span>            : class nsINode;
<span class="lineNum">      36 </span>            : class nsIRunnable;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : namespace mozilla {
<span class="lineNum">      39 </span>            : class RefreshDriverTimer;
<span class="lineNum">      40 </span>            : namespace layout {
<span class="lineNum">      41 </span>            : class VsyncChild;
<span class="lineNum">      42 </span>            : } // namespace layout
<span class="lineNum">      43 </span>            : } // namespace mozilla
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /**
<span class="lineNum">      46 </span>            :  * An abstract base class to be implemented by callers wanting to be
<span class="lineNum">      47 </span>            :  * notified at refresh times.  When nothing needs to be painted, callers
<a name="48"><span class="lineNum">      48 </span>            :  * may not be notified.</a>
<span class="lineNum">      49 </span>            :  */
<span class="lineNum">      50 </span><span class="lineCov">         73 : class nsARefreshObserver {</span>
<span class="lineNum">      51 </span>            : public:
<span class="lineNum">      52 </span>            :   // AddRef and Release signatures that match nsISupports.  Implementors
<span class="lineNum">      53 </span>            :   // must implement reference counting, and those that do implement
<span class="lineNum">      54 </span>            :   // nsISupports will already have methods with the correct signature.
<span class="lineNum">      55 </span>            :   //
<span class="lineNum">      56 </span>            :   // The refresh driver does NOT hold references to refresh observers
<span class="lineNum">      57 </span>            :   // except while it is notifying them.
<span class="lineNum">      58 </span>            :   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   virtual void WillRefresh(mozilla::TimeStamp aTime) = 0;
<span class="lineNum">      61 </span>            : };
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : /**
<span class="lineNum">      64 </span>            :  * An abstract base class to be implemented by callers wanting to be notified
<span class="lineNum">      65 </span>            :  * that a refresh has occurred. Callers must ensure an observer is removed
<a name="66"><span class="lineNum">      66 </span>            :  * before it is destroyed.</a>
<span class="lineNum">      67 </span>            :  */
<span class="lineNum">      68 </span><span class="lineNoCov">          0 : class nsAPostRefreshObserver {</span>
<span class="lineNum">      69 </span>            : public:
<span class="lineNum">      70 </span>            :   virtual void DidRefresh() = 0;
<span class="lineNum">      71 </span>            : };
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : class nsRefreshDriver final : public mozilla::layers::TransactionIdAllocator,
<span class="lineNum">      74 </span>            :                               public nsARefreshObserver
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span>            : public:
<span class="lineNum">      77 </span>            :   explicit nsRefreshDriver(nsPresContext *aPresContext);
<span class="lineNum">      78 </span>            :   ~nsRefreshDriver();
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   /**
<span class="lineNum">      81 </span>            :    * Methods for testing, exposed via nsIDOMWindowUtils.  See
<span class="lineNum">      82 </span>            :    * nsIDOMWindowUtils.advanceTimeAndRefresh for description.
<span class="lineNum">      83 </span>            :    */
<span class="lineNum">      84 </span>            :   void AdvanceTimeAndRefresh(int64_t aMilliseconds);
<a name="85"><span class="lineNum">      85 </span>            :   void RestoreNormalRefresh();</a>
<span class="lineNum">      86 </span>            :   void DoTick();
<span class="lineNum">      87 </span><span class="lineCov">         75 :   bool IsTestControllingRefreshesEnabled() const</span>
<span class="lineNum">      88 </span>            :   {
<span class="lineNum">      89 </span><span class="lineCov">         75 :     return mTestControllingRefreshes;</span>
<span class="lineNum">      90 </span>            :   }
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :   /**
<span class="lineNum">      93 </span>            :    * Return the time of the most recent refresh.  This is intended to be
<span class="lineNum">      94 </span>            :    * used by callers who want to start an animation now and want to know
<span class="lineNum">      95 </span>            :    * what time to consider the start of the animation.  (This helps
<span class="lineNum">      96 </span>            :    * ensure that multiple animations started during the same event off
<span class="lineNum">      97 </span>            :    * the main event loop have the same start time.)
<span class="lineNum">      98 </span>            :    */
<span class="lineNum">      99 </span>            :   mozilla::TimeStamp MostRecentRefresh() const;
<span class="lineNum">     100 </span>            :   /**
<span class="lineNum">     101 </span>            :    * Same thing, but in microseconds since the epoch.
<span class="lineNum">     102 </span>            :    */
<span class="lineNum">     103 </span>            :   int64_t MostRecentRefreshEpochTime() const;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   /**
<span class="lineNum">     106 </span>            :    * Add / remove refresh observers.  Returns whether the operation
<span class="lineNum">     107 </span>            :    * succeeded.
<span class="lineNum">     108 </span>            :    *
<span class="lineNum">     109 </span>            :    * The flush type affects:
<span class="lineNum">     110 </span>            :    *   + the order in which the observers are notified (lowest flush
<span class="lineNum">     111 </span>            :    *     type to highest, in order registered)
<span class="lineNum">     112 </span>            :    *   + (in the future) which observers are suppressed when the display
<span class="lineNum">     113 </span>            :    *     doesn't require current position data or isn't currently
<span class="lineNum">     114 </span>            :    *     painting, and, correspondingly, which get notified when there
<span class="lineNum">     115 </span>            :    *     is a flush during such suppression
<span class="lineNum">     116 </span>            :    * and it must be FlushType::Style, FlushType::Layout, or FlushType::Display.
<span class="lineNum">     117 </span>            :    *
<span class="lineNum">     118 </span>            :    * The refresh driver does NOT own a reference to these observers;
<span class="lineNum">     119 </span>            :    * they must remove themselves before they are destroyed.
<span class="lineNum">     120 </span>            :    *
<span class="lineNum">     121 </span>            :    * The observer will be called even if there is no other activity.
<span class="lineNum">     122 </span>            :    */
<span class="lineNum">     123 </span>            :   bool AddRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     124 </span>            :                           mozilla::FlushType aFlushType);
<span class="lineNum">     125 </span>            :   bool RemoveRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     126 </span>            :                              mozilla::FlushType aFlushType);
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   /**
<span class="lineNum">     129 </span>            :    * Add an observer that will be called after each refresh. The caller
<span class="lineNum">     130 </span>            :    * must remove the observer before it is deleted. This does not trigger
<span class="lineNum">     131 </span>            :    * refresh driver ticks.
<span class="lineNum">     132 </span>            :    */
<span class="lineNum">     133 </span>            :   void AddPostRefreshObserver(nsAPostRefreshObserver *aObserver);
<span class="lineNum">     134 </span>            :   void RemovePostRefreshObserver(nsAPostRefreshObserver *aObserver);
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :   /**
<span class="lineNum">     137 </span>            :    * Add/Remove imgIRequest versions of observers.
<span class="lineNum">     138 </span>            :    *
<span class="lineNum">     139 </span>            :    * These are used for hooking into the refresh driver for
<span class="lineNum">     140 </span>            :    * controlling animated images.
<span class="lineNum">     141 </span>            :    *
<span class="lineNum">     142 </span>            :    * @note The refresh driver owns a reference to these listeners.
<span class="lineNum">     143 </span>            :    *
<span class="lineNum">     144 </span>            :    * @note Technically, imgIRequest objects are not nsARefreshObservers, but
<span class="lineNum">     145 </span>            :    * for controlling animated image repaint events, we subscribe the
<span class="lineNum">     146 </span>            :    * imgIRequests to the nsRefreshDriver for notification of paint events.
<span class="lineNum">     147 </span>            :    *
<span class="lineNum">     148 </span>            :    * @returns whether the operation succeeded, or void in the case of removal.
<span class="lineNum">     149 </span>            :    */
<span class="lineNum">     150 </span>            :   bool AddImageRequest(imgIRequest* aRequest);
<span class="lineNum">     151 </span>            :   void RemoveImageRequest(imgIRequest* aRequest);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :   /**
<a name="154"><span class="lineNum">     154 </span>            :    * Add / remove presshells that we should flush style and layout on</a>
<span class="lineNum">     155 </span>            :    */
<span class="lineNum">     156 </span><span class="lineCov">         38 :   bool AddStyleFlushObserver(nsIPresShell* aShell) {</span>
<span class="lineNum">     157 </span><span class="lineCov">         38 :     NS_ASSERTION(!mStyleFlushObservers.Contains(aShell),</span>
<span class="lineNum">     158 </span>            :                  &quot;Double-adding style flush observer&quot;);
<span class="lineNum">     159 </span>            :     // We only get the cause for the first observer each frame because capturing
<span class="lineNum">     160 </span>            :     // a stack is expensive. This is still useful if (1) you're trying to remove
<span class="lineNum">     161 </span>            :     // all flushes for a particial frame or (2) the costly flush is triggered
<span class="lineNum">     162 </span>            :     // near the call site where the first observer is triggered.
<span class="lineNum">     163 </span><span class="lineCov">         38 :     if (!mStyleCause) {</span>
<span class="lineNum">     164 </span><span class="lineCov">         38 :       mStyleCause = profiler_get_backtrace();</span>
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span><span class="lineCov">         38 :     bool appended = mStyleFlushObservers.AppendElement(aShell) != nullptr;</span>
<span class="lineNum">     167 </span><span class="lineCov">         38 :     EnsureTimerStarted();</span>
<span class="lineNum">     168 </span>            : 
<a name="169"><span class="lineNum">     169 </span><span class="lineCov">         38 :     return appended;</span></a>
<span class="lineNum">     170 </span>            :   }
<span class="lineNum">     171 </span><span class="lineCov">          4 :   void RemoveStyleFlushObserver(nsIPresShell* aShell) {</span>
<a name="172"><span class="lineNum">     172 </span><span class="lineCov">          4 :     mStyleFlushObservers.RemoveElement(aShell);</span></a>
<span class="lineNum">     173 </span><span class="lineCov">          4 :   }</span>
<span class="lineNum">     174 </span><span class="lineCov">         45 :   bool AddLayoutFlushObserver(nsIPresShell* aShell) {</span>
<span class="lineNum">     175 </span><span class="lineCov">         45 :     NS_ASSERTION(!IsLayoutFlushObserver(aShell),</span>
<span class="lineNum">     176 </span>            :                  &quot;Double-adding layout flush observer&quot;);
<span class="lineNum">     177 </span>            :     // We only get the cause for the first observer each frame because capturing
<span class="lineNum">     178 </span>            :     // a stack is expensive. This is still useful if (1) you're trying to remove
<span class="lineNum">     179 </span>            :     // all flushes for a particial frame or (2) the costly flush is triggered
<span class="lineNum">     180 </span>            :     // near the call site where the first observer is triggered.
<span class="lineNum">     181 </span><span class="lineCov">         45 :     if (!mReflowCause) {</span>
<span class="lineNum">     182 </span><span class="lineCov">         45 :       mReflowCause = profiler_get_backtrace();</span>
<span class="lineNum">     183 </span>            :     }
<span class="lineNum">     184 </span><span class="lineCov">         45 :     bool appended = mLayoutFlushObservers.AppendElement(aShell) != nullptr;</span>
<span class="lineNum">     185 </span><span class="lineCov">         45 :     EnsureTimerStarted();</span>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">         45 :     return appended;</span></a>
<span class="lineNum">     187 </span>            :   }
<span class="lineNum">     188 </span><span class="lineCov">          4 :   void RemoveLayoutFlushObserver(nsIPresShell* aShell) {</span>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">          4 :     mLayoutFlushObservers.RemoveElement(aShell);</span></a>
<span class="lineNum">     190 </span><span class="lineCov">          4 :   }</span>
<span class="lineNum">     191 </span><span class="lineCov">        342 :   bool IsLayoutFlushObserver(nsIPresShell* aShell) {</span>
<span class="lineNum">     192 </span><span class="lineCov">        342 :     return mLayoutFlushObservers.Contains(aShell);</span>
<span class="lineNum">     193 </span>            :   }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   /**
<span class="lineNum">     196 </span>            :    * &quot;Early Runner&quot; runnables will be called as the first step when refresh
<span class="lineNum">     197 </span>            :    * driver tick is triggered. Runners shouldn't keep other objects alive,
<a name="198"><span class="lineNum">     198 </span>            :    * since it isn't guaranteed they will ever get called.</a>
<span class="lineNum">     199 </span>            :    */
<span class="lineNum">     200 </span><span class="lineCov">          2 :   void AddEarlyRunner(nsIRunnable* aRunnable)</span>
<span class="lineNum">     201 </span>            :   {
<span class="lineNum">     202 </span><span class="lineCov">          2 :     mEarlyRunners.AppendElement(aRunnable);</span>
<span class="lineNum">     203 </span><span class="lineCov">          2 :     EnsureTimerStarted();</span>
<span class="lineNum">     204 </span><span class="lineCov">          2 :   }</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   /**
<span class="lineNum">     207 </span>            :    * Remember whether our presshell's view manager needs a flush
<a name="208"><span class="lineNum">     208 </span>            :    */</a>
<span class="lineNum">     209 </span>            :   void ScheduleViewManagerFlush();
<span class="lineNum">     210 </span><span class="lineCov">         39 :   void RevokeViewManagerFlush() {</span>
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">         39 :     mViewManagerFlushIsPending = false;</span></a>
<span class="lineNum">     212 </span><span class="lineCov">         39 :   }</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   bool ViewManagerFlushIsPending() {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     return mViewManagerFlushIsPending;</span>
<span class="lineNum">     215 </span>            :   }
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   /**
<span class="lineNum">     218 </span>            :    * Add a document for which we have FrameRequestCallbacks
<span class="lineNum">     219 </span>            :    */
<span class="lineNum">     220 </span>            :   void ScheduleFrameRequestCallbacks(nsIDocument* aDocument);
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   /**
<span class="lineNum">     223 </span>            :    * Remove a document for which we have FrameRequestCallbacks
<span class="lineNum">     224 </span>            :    */
<span class="lineNum">     225 </span>            :   void RevokeFrameRequestCallbacks(nsIDocument* aDocument);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   /**
<span class="lineNum">     228 </span>            :    * Queue a new event to dispatch in next tick before the style flush
<span class="lineNum">     229 </span>            :    */
<span class="lineNum">     230 </span>            :   void ScheduleEventDispatch(nsINode* aTarget, nsIDOMEvent* aEvent);
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /**
<span class="lineNum">     233 </span>            :    * Cancel all pending events scheduled by ScheduleEventDispatch which
<span class="lineNum">     234 </span>            :    * targets any node in aDocument.
<span class="lineNum">     235 </span>            :    */
<span class="lineNum">     236 </span>            :   void CancelPendingEvents(nsIDocument* aDocument);
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   /**
<span class="lineNum">     239 </span>            :    * Schedule a frame visibility update &quot;soon&quot;, subject to the heuristics and
<a name="240"><span class="lineNum">     240 </span>            :    * throttling we apply to visibility updates.</a>
<span class="lineNum">     241 </span>            :    */
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   void ScheduleFrameVisibilityUpdate() { mNeedToRecomputeVisibility = true; }</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   /**
<span class="lineNum">     245 </span>            :    * Tell the refresh driver that it is done driving refreshes and
<span class="lineNum">     246 </span>            :    * should stop its timer and forget about its pres context.  This may
<span class="lineNum">     247 </span>            :    * be called from within a refresh.
<span class="lineNum">     248 </span>            :    */
<a name="249"><span class="lineNum">     249 </span>            :   void Disconnect();</a>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">        171 :   bool IsFrozen() { return mFreezeCount &gt; 0; }</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :   /**
<span class="lineNum">     254 </span>            :    * Freeze the refresh driver.  It should stop delivering future
<span class="lineNum">     255 </span>            :    * refreshes until thawed. Note that the number of calls to Freeze() must
<span class="lineNum">     256 </span>            :    * match the number of calls to Thaw() in order for the refresh driver to
<span class="lineNum">     257 </span>            :    * be un-frozen.
<span class="lineNum">     258 </span>            :    */
<span class="lineNum">     259 </span>            :   void Freeze();
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   /**
<span class="lineNum">     262 </span>            :    * Thaw the refresh driver.  If the number of calls to Freeze() matches the
<span class="lineNum">     263 </span>            :    * number of calls to this function, the refresh driver should start
<span class="lineNum">     264 </span>            :    * delivering refreshes again.
<span class="lineNum">     265 </span>            :    */
<span class="lineNum">     266 </span>            :   void Thaw();
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :   /**
<span class="lineNum">     269 </span>            :    * Throttle or unthrottle the refresh driver.  This is done if the
<span class="lineNum">     270 </span>            :    * corresponding presshell is hidden or shown.
<span class="lineNum">     271 </span>            :    */
<span class="lineNum">     272 </span>            :   void SetThrottled(bool aThrottled);
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :   /**
<a name="275"><span class="lineNum">     275 </span>            :    * Return the prescontext we were initialized with</a>
<span class="lineNum">     276 </span>            :    */
<span class="lineNum">     277 </span><span class="lineCov">         81 :   nsPresContext* GetPresContext() const { return mPresContext; }</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :   /**
<span class="lineNum">     280 </span>            :    * PBackgroundChild actor is created asynchronously in content process.
<span class="lineNum">     281 </span>            :    * We can't create vsync-based timers during PBackground startup. This
<span class="lineNum">     282 </span>            :    * function will be called when PBackgroundChild actor is created. Then we can
<span class="lineNum">     283 </span>            :    * do the pending vsync-based timer creation.
<span class="lineNum">     284 </span>            :    */
<span class="lineNum">     285 </span>            :   static void PVsyncActorCreated(mozilla::layout::VsyncChild* aVsyncChild);
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : #ifdef DEBUG
<span class="lineNum">     288 </span>            :   /**
<span class="lineNum">     289 </span>            :    * Check whether the given observer is an observer for the given flush type
<span class="lineNum">     290 </span>            :    */
<span class="lineNum">     291 </span>            :   bool IsRefreshObserver(nsARefreshObserver *aObserver,
<span class="lineNum">     292 </span>            :                          mozilla::FlushType aFlushType);
<span class="lineNum">     293 </span>            : #endif
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :   /**
<span class="lineNum">     296 </span>            :    * Default interval the refresh driver uses, in ms.
<span class="lineNum">     297 </span>            :    */
<a name="298"><span class="lineNum">     298 </span>            :   static int32_t DefaultInterval();</a>
<span class="lineNum">     299 </span>            : 
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">         20 :   bool IsInRefresh() { return mInRefresh; }</span></a>
<a name="301"><span class="lineNum">     301 </span>            : </a>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   void SetIsResizeSuppressed() { mResizeSuppressed = true; }</span>
<span class="lineNum">     303 </span><span class="lineCov">         56 :   bool IsResizeSuppressed() const { return mResizeSuppressed; }</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   /**
<span class="lineNum">     306 </span>            :    * The latest value of process-wide jank levels.
<span class="lineNum">     307 </span>            :    *
<span class="lineNum">     308 </span>            :    * For each i, sJankLevels[i] counts the number of times delivery of
<span class="lineNum">     309 </span>            :    * vsync to the main thread has been delayed by at least 2^i
<span class="lineNum">     310 </span>            :    * ms. This data structure has been designed to make it easy to
<span class="lineNum">     311 </span>            :    * determine how much jank has taken place between two instants in
<span class="lineNum">     312 </span>            :    * time.
<span class="lineNum">     313 </span>            :    *
<span class="lineNum">     314 </span>            :    * Return `false` if `aJank` needs to be grown to accomodate the
<span class="lineNum">     315 </span>            :    * data but we didn't have enough memory.
<span class="lineNum">     316 </span>            :    */
<span class="lineNum">     317 </span>            :   static bool GetJankLevels(mozilla::Vector&lt;uint64_t&gt;&amp; aJank);
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :   // mozilla::layers::TransactionIdAllocator
<span class="lineNum">     320 </span>            :   uint64_t GetTransactionId(bool aThrottle) override;
<span class="lineNum">     321 </span>            :   uint64_t LastTransactionId() const override;
<span class="lineNum">     322 </span>            :   void NotifyTransactionCompleted(uint64_t aTransactionId) override;
<span class="lineNum">     323 </span>            :   void RevokeTransactionId(uint64_t aTransactionId) override;
<span class="lineNum">     324 </span>            :   void ClearPendingTransactions() override;
<span class="lineNum">     325 </span>            :   void ResetInitialTransactionId(uint64_t aTransactionId) override;
<span class="lineNum">     326 </span>            :   mozilla::TimeStamp GetTransactionStart() override;
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :   bool IsWaitingForPaint(mozilla::TimeStamp aTime);
<a name="329"><span class="lineNum">     329 </span>            : </a>
<a name="330"><span class="lineNum">     330 </span>            :   // nsARefreshObserver</a>
<span class="lineNum">     331 </span><span class="lineCov">        109 :   NS_IMETHOD_(MozExternalRefCountType) AddRef(void) override { return TransactionIdAllocator::AddRef(); }</span>
<span class="lineNum">     332 </span><span class="lineCov">         81 :   NS_IMETHOD_(MozExternalRefCountType) Release(void) override { return TransactionIdAllocator::Release(); }</span>
<span class="lineNum">     333 </span>            :   virtual void WillRefresh(mozilla::TimeStamp aTime) override;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :   /**
<span class="lineNum">     336 </span>            :    * Compute the time when the currently active refresh driver timer
<span class="lineNum">     337 </span>            :    * will start its next tick.
<span class="lineNum">     338 </span>            :    *
<span class="lineNum">     339 </span>            :    * Expects a non-null default value that is the upper bound of the
<span class="lineNum">     340 </span>            :    * expected deadline. If the next expected deadline is later than
<span class="lineNum">     341 </span>            :    * the default value, the default value is returned.
<span class="lineNum">     342 </span>            :    *
<span class="lineNum">     343 </span>            :    * If we're animating and we have skipped paints a time in the past
<span class="lineNum">     344 </span>            :    * is returned.
<span class="lineNum">     345 </span>            :    */
<span class="lineNum">     346 </span>            :   static mozilla::TimeStamp GetIdleDeadlineHint(mozilla::TimeStamp aDefault);
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   static void DispatchIdleRunnableAfterTick(nsIRunnable* aRunnable,
<span class="lineNum">     349 </span>            :                                             uint32_t aDelay);
<a name="350"><span class="lineNum">     350 </span>            :   static void CancelIdleRunnable(nsIRunnable* aRunnable);</a>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   bool SkippedPaints() const</span>
<span class="lineNum">     353 </span>            :   {
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     return mSkippedPaints;</span>
<span class="lineNum">     355 </span>            :   }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : private:
<a name="358"><span class="lineNum">     358 </span>            :   typedef nsTObserverArray&lt;nsARefreshObserver*&gt; ObserverArray;</a>
<a name="359"><span class="lineNum">     359 </span>            :   typedef nsTHashtable&lt;nsISupportsHashKey&gt; RequestTable;</a>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   struct ImageStartData {</span>
<span class="lineNum">     361 </span><span class="lineCov">          2 :     ImageStartData()</span>
<span class="lineNum">     362 </span><span class="lineCov">          2 :     {</span>
<span class="lineNum">     363 </span><span class="lineCov">          2 :     }</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :     mozilla::Maybe&lt;mozilla::TimeStamp&gt; mStartTime;
<span class="lineNum">     366 </span>            :     RequestTable mEntries;
<span class="lineNum">     367 </span>            :   };
<span class="lineNum">     368 </span>            :   typedef nsClassHashtable&lt;nsUint32HashKey, ImageStartData&gt; ImageStartTable;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   void DispatchPendingEvents();
<span class="lineNum">     371 </span>            :   void DispatchAnimationEvents();
<span class="lineNum">     372 </span>            :   void RunFrameRequestCallbacks(mozilla::TimeStamp aNowTime);
<span class="lineNum">     373 </span>            :   void Tick(int64_t aNowEpoch, mozilla::TimeStamp aNowTime);
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :   enum EnsureTimerStartedFlags {
<span class="lineNum">     376 </span>            :     eNone = 0,
<span class="lineNum">     377 </span>            :     eForceAdjustTimer = 1 &lt;&lt; 0,
<span class="lineNum">     378 </span>            :     eAllowTimeToGoBackwards = 1 &lt;&lt; 1,
<span class="lineNum">     379 </span>            :     eNeverAdjustTimer = 1 &lt;&lt; 2,
<span class="lineNum">     380 </span>            :   };
<span class="lineNum">     381 </span>            :   void EnsureTimerStarted(EnsureTimerStartedFlags aFlags = eNone);
<span class="lineNum">     382 </span>            :   void StopTimer();
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :   uint32_t ObserverCount() const;
<span class="lineNum">     385 </span>            :   uint32_t ImageRequestCount() const;
<span class="lineNum">     386 </span>            :   ObserverArray&amp; ArrayFor(mozilla::FlushType aFlushType);
<span class="lineNum">     387 </span>            :   // Trigger a refresh immediately, if haven't been disconnected or frozen.
<span class="lineNum">     388 </span>            :   void DoRefresh();
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   double GetRefreshTimerInterval() const;
<span class="lineNum">     391 </span>            :   double GetRegularTimerInterval(bool *outIsDefault = nullptr) const;
<span class="lineNum">     392 </span>            :   static double GetThrottledTimerInterval();
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   static mozilla::TimeDuration GetMinRecomputeVisibilityInterval();
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   bool HaveFrameRequestCallbacks() const {
<span class="lineNum">     397 </span>            :     return mFrameRequestCallbackDocs.Length() != 0;
<span class="lineNum">     398 </span>            :   }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :   void FinishedWaitingForTransaction();
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   mozilla::RefreshDriverTimer* ChooseTimer() const;
<span class="lineNum">     403 </span>            :   mozilla::RefreshDriverTimer* mActiveTimer;
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   UniqueProfilerBacktrace mReflowCause;
<span class="lineNum">     406 </span>            :   UniqueProfilerBacktrace mStyleCause;
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   // nsPresContext passed in constructor and unset in Disconnect.
<span class="lineNum">     409 </span>            :   mozilla::WeakPtr&lt;nsPresContext&gt; mPresContext;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   RefPtr&lt;nsRefreshDriver&gt; mRootRefresh;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   // The most recently allocated transaction id.
<span class="lineNum">     414 </span>            :   uint64_t mPendingTransaction;
<span class="lineNum">     415 </span>            :   // The most recently completed transaction id.
<span class="lineNum">     416 </span>            :   uint64_t mCompletedTransaction;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   uint32_t mFreezeCount;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   // How long we wait between ticks for throttled (which generally means
<span class="lineNum">     421 </span>            :   // non-visible) documents registered with a non-throttled refresh driver.
<span class="lineNum">     422 </span>            :   const mozilla::TimeDuration mThrottledFrameRequestInterval;
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   // How long we wait, at a minimum, before recomputing approximate frame
<span class="lineNum">     425 </span>            :   // visibility information. This is a minimum because, regardless of this
<span class="lineNum">     426 </span>            :   // interval, we only recompute visibility when we've seen a layout or style
<span class="lineNum">     427 </span>            :   // flush since the last time we did it.
<span class="lineNum">     428 </span>            :   const mozilla::TimeDuration mMinRecomputeVisibilityInterval;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   bool mThrottled;
<span class="lineNum">     431 </span>            :   bool mNeedToRecomputeVisibility;
<span class="lineNum">     432 </span>            :   bool mTestControllingRefreshes;
<span class="lineNum">     433 </span>            :   bool mViewManagerFlushIsPending;
<span class="lineNum">     434 </span>            :   bool mInRefresh;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   // True if the refresh driver is suspended waiting for transaction
<span class="lineNum">     437 </span>            :   // id's to be returned and shouldn't do any work during Tick().
<span class="lineNum">     438 </span>            :   bool mWaitingForTransaction;
<span class="lineNum">     439 </span>            :   // True if Tick() was skipped because of mWaitingForTransaction and
<span class="lineNum">     440 </span>            :   // we should schedule a new Tick immediately when resumed instead
<span class="lineNum">     441 </span>            :   // of waiting until the next interval.
<span class="lineNum">     442 </span>            :   bool mSkippedPaints;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   // True if view managers should delay any resize request until the
<span class="lineNum">     445 </span>            :   // next tick by the refresh driver. This flag will be reset at the
<span class="lineNum">     446 </span>            :   // start of every tick.
<span class="lineNum">     447 </span>            :   bool mResizeSuppressed;
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   int64_t mMostRecentRefreshEpochTime;
<span class="lineNum">     450 </span>            :   // Number of seconds that the refresh driver is blocked waiting for a compositor
<span class="lineNum">     451 </span>            :   // transaction to be completed before we append a note to the gfx critical log.
<span class="lineNum">     452 </span>            :   // The number is doubled every time the threshold is hit.
<span class="lineNum">     453 </span>            :   uint64_t mWarningThreshold;
<span class="lineNum">     454 </span>            :   mozilla::TimeStamp mMostRecentRefresh;
<span class="lineNum">     455 </span>            :   mozilla::TimeStamp mMostRecentTick;
<span class="lineNum">     456 </span>            :   mozilla::TimeStamp mTickStart;
<span class="lineNum">     457 </span>            :   mozilla::TimeStamp mNextThrottledFrameRequestTick;
<span class="lineNum">     458 </span>            :   mozilla::TimeStamp mNextRecomputeVisibilityTick;
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   // separate arrays for each flush type we support
<span class="lineNum">     461 </span>            :   ObserverArray mObservers[3];
<span class="lineNum">     462 </span>            :   RequestTable mRequests;
<span class="lineNum">     463 </span>            :   ImageStartTable mStartTable;
<a name="464"><span class="lineNum">     464 </span>            :   AutoTArray&lt;nsCOMPtr&lt;nsIRunnable&gt;, 16&gt; mEarlyRunners;</a>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   struct PendingEvent {</span>
<span class="lineNum">     467 </span>            :     nsCOMPtr&lt;nsINode&gt; mTarget;
<span class="lineNum">     468 </span>            :     nsCOMPtr&lt;nsIDOMEvent&gt; mEvent;
<span class="lineNum">     469 </span>            :   };
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   AutoTArray&lt;nsIPresShell*, 16&gt; mStyleFlushObservers;
<span class="lineNum">     472 </span>            :   AutoTArray&lt;nsIPresShell*, 16&gt; mLayoutFlushObservers;
<span class="lineNum">     473 </span>            :   // nsTArray on purpose, because we want to be able to swap.
<span class="lineNum">     474 </span>            :   nsTArray&lt;nsIDocument*&gt; mFrameRequestCallbackDocs;
<span class="lineNum">     475 </span>            :   nsTArray&lt;nsIDocument*&gt; mThrottledFrameRequestCallbackDocs;
<span class="lineNum">     476 </span>            :   nsTObserverArray&lt;nsAPostRefreshObserver*&gt; mPostRefreshObservers;
<span class="lineNum">     477 </span>            :   nsTArray&lt;PendingEvent&gt; mPendingEvents;
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :   void BeginRefreshingImages(RequestTable&amp; aEntries,
<span class="lineNum">     480 </span>            :                              mozilla::TimeStamp aDesired);
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :   friend class mozilla::RefreshDriverTimer;
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   static void Shutdown();
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   // `true` if we are currently in jank-critical mode.
<span class="lineNum">     487 </span>            :   //
<span class="lineNum">     488 </span>            :   // In jank-critical mode, any iteration of the event loop that takes
<span class="lineNum">     489 </span>            :   // more than 16ms to compute will cause an ongoing animation to miss
<span class="lineNum">     490 </span>            :   // frames.
<span class="lineNum">     491 </span>            :   //
<span class="lineNum">     492 </span>            :   // For simplicity, the current implementation assumes that we are
<span class="lineNum">     493 </span>            :   // in jank-critical mode if and only if the vsync driver has at least
<span class="lineNum">     494 </span>            :   // one observer.
<span class="lineNum">     495 </span>            :   static bool IsJankCritical();
<span class="lineNum">     496 </span>            : };
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : #endif /* !defined(nsRefreshDriver_h_) */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

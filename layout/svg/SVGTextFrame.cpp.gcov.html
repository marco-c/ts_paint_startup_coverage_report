<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - layout/svg/SVGTextFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">layout/svg</a> - SVGTextFrame.cpp<span style="font-size: 80%;"> (source / <a href="SVGTextFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2086</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">191</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // Main header first:
<span class="lineNum">       7 </span>            : #include &quot;SVGTextFrame.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : // Keep others in (case-insensitive) order:
<span class="lineNum">      10 </span>            : #include &quot;DOMSVGPoint.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;gfx2DGlue.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;gfxContext.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;gfxFont.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;gfxSkipChars.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;gfxTypes.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;LookAndFeel.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/gfx/2D.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mozilla/gfx/PatternHelpers.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsAlgorithm.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsBlockFrame.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsCaret.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsIDOMSVGLength.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsISelection.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsQuickSort.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsSVGEffects.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsSVGOuterSVGFrame.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsSVGPaintServerFrame.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/dom/SVGRect.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsSVGIntegrationUtils.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsSVGUtils.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsTextFrame.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsTextNode.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;SVGAnimatedNumberList.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;SVGContentUtils.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;SVGContextPaint.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;SVGLengthList.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;SVGNumberList.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;SVGPathElement.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;SVGTextPathElement.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;nsFrameSelection.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;nsStyleStructInlines.h&quot;
<span class="lineNum">      48 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      49 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      50 </span>            : #include &lt;limits&gt;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : using namespace mozilla;
<span class="lineNum">      53 </span>            : using namespace mozilla::dom;
<span class="lineNum">      54 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      55 </span>            : using namespace mozilla::image;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : // ============================================================================
<span class="lineNum">      58 </span>            : // Utility functions
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /**
<span class="lineNum">      61 </span>            :  * Using the specified gfxSkipCharsIterator, converts an offset and length
<span class="lineNum">      62 </span>            :  * in original char indexes to skipped char indexes.
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  * @param aIterator The gfxSkipCharsIterator to use for the conversion.
<span class="lineNum">      65 </span>            :  * @param aOriginalOffset The original offset.
<span class="lineNum">      66 </span>            :  * @param aOriginalLength The original length.
<a name="67"><span class="lineNum">      67 </span>            :  */</a>
<span class="lineNum">      68 </span>            : static gfxTextRun::Range
<span class="lineNum">      69 </span><span class="lineNoCov">          0 : ConvertOriginalToSkipped(gfxSkipCharsIterator&amp; aIterator,</span>
<span class="lineNum">      70 </span>            :                          uint32_t aOriginalOffset, uint32_t aOriginalLength)
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   uint32_t start = aIterator.ConvertOriginalToSkipped(aOriginalOffset);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   aIterator.AdvanceOriginal(aOriginalLength);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   return gfxTextRun::Range(start, aIterator.GetSkippedOffset());</span>
<span class="lineNum">      75 </span>            : }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /**
<span class="lineNum">      78 </span>            :  * Converts an nsPoint from app units to user space units using the specified
<span class="lineNum">      79 </span>            :  * nsPresContext and returns it as a gfxPoint.
<a name="80"><span class="lineNum">      80 </span>            :  */</a>
<span class="lineNum">      81 </span>            : static gfxPoint
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : AppUnitsToGfxUnits(const nsPoint&amp; aPoint, const nsPresContext* aContext)</span>
<span class="lineNum">      83 </span>            : {
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   return gfxPoint(aContext-&gt;AppUnitsToGfxUnits(aPoint.x),</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                   aContext-&gt;AppUnitsToGfxUnits(aPoint.y));</span>
<span class="lineNum">      86 </span>            : }
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /**
<span class="lineNum">      89 </span>            :  * Converts a gfxRect that is in app units to CSS pixels using the specified
<span class="lineNum">      90 </span>            :  * nsPresContext and returns it as a gfxRect.
<a name="91"><span class="lineNum">      91 </span>            :  */</a>
<span class="lineNum">      92 </span>            : static gfxRect
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : AppUnitsToFloatCSSPixels(const gfxRect&amp; aRect, const nsPresContext* aContext)</span>
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   return gfxRect(aContext-&gt;AppUnitsToFloatCSSPixels(aRect.x),</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :                  aContext-&gt;AppUnitsToFloatCSSPixels(aRect.y),</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                  aContext-&gt;AppUnitsToFloatCSSPixels(aRect.width),</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                  aContext-&gt;AppUnitsToFloatCSSPixels(aRect.height));</span>
<span class="lineNum">      99 </span>            : }
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /**
<span class="lineNum">     102 </span>            :  * Scales a gfxRect around a given point.
<span class="lineNum">     103 </span>            :  *
<span class="lineNum">     104 </span>            :  * @param aRect The rectangle to scale.
<span class="lineNum">     105 </span>            :  * @param aPoint The point around which to scale.
<span class="lineNum">     106 </span>            :  * @param aScale The scale amount.
<a name="107"><span class="lineNum">     107 </span>            :  */</a>
<span class="lineNum">     108 </span>            : static void
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : ScaleAround(gfxRect&amp; aRect, const gfxPoint&amp; aPoint, double aScale)</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   aRect.x = aPoint.x - aScale * (aPoint.x - aRect.x);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   aRect.y = aPoint.y - aScale * (aPoint.y - aRect.y);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   aRect.width *= aScale;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   aRect.height *= aScale;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : /**
<span class="lineNum">     118 </span>            :  * Returns whether a gfxPoint lies within a gfxRect.
<a name="119"><span class="lineNum">     119 </span>            :  */</a>
<span class="lineNum">     120 </span>            : static bool
<span class="lineNum">     121 </span><span class="lineNoCov">          0 : Inside(const gfxRect&amp; aRect, const gfxPoint&amp; aPoint)</span>
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   return aPoint.x &gt;= aRect.x &amp;&amp;</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :          aPoint.x &lt; aRect.XMost() &amp;&amp;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :          aPoint.y &gt;= aRect.y &amp;&amp;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :          aPoint.y &lt; aRect.YMost();</span>
<span class="lineNum">     127 </span>            : }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : /**
<span class="lineNum">     130 </span>            :  * Gets the measured ascent and descent of the text in the given nsTextFrame
<span class="lineNum">     131 </span>            :  * in app units.
<span class="lineNum">     132 </span>            :  *
<span class="lineNum">     133 </span>            :  * @param aFrame The text frame.
<span class="lineNum">     134 </span>            :  * @param aAscent The ascent in app units (output).
<span class="lineNum">     135 </span>            :  * @param aDescent The descent in app units (output).
<a name="136"><span class="lineNum">     136 </span>            :  */</a>
<span class="lineNum">     137 </span>            : static void
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : GetAscentAndDescentInAppUnits(nsTextFrame* aFrame,</span>
<span class="lineNum">     139 </span>            :                               gfxFloat&amp; aAscent, gfxFloat&amp; aDescent)
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = aFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   gfxTextRun* textRun = aFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :   gfxTextRun::Range range = ConvertOriginalToSkipped(
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     it, aFrame-&gt;GetContentOffset(), aFrame-&gt;GetContentLength());</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   gfxTextRun::Metrics metrics =
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     textRun-&gt;MeasureText(range, gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   aAscent = metrics.mAscent;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   aDescent = metrics.mDescent;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /**
<span class="lineNum">     155 </span>            :  * Updates an interval by intersecting it with another interval.
<span class="lineNum">     156 </span>            :  * The intervals are specified using a start index and a length.
<a name="157"><span class="lineNum">     157 </span>            :  */</a>
<span class="lineNum">     158 </span>            : static void
<span class="lineNum">     159 </span><span class="lineNoCov">          0 : IntersectInterval(uint32_t&amp; aStart, uint32_t&amp; aLength,</span>
<span class="lineNum">     160 </span>            :                   uint32_t aStartOther, uint32_t aLengthOther)
<span class="lineNum">     161 </span>            : {
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   uint32_t aEnd = aStart + aLength;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   uint32_t aEndOther = aStartOther + aLengthOther;</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   if (aStartOther &gt;= aEnd || aStart &gt;= aEndOther) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     aLength = 0;</span>
<span class="lineNum">     167 </span>            :   } else {
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     if (aStartOther &gt;= aStart)</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       aStart = aStartOther;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     aLength = std::min(aEnd, aEndOther) - aStart;</span>
<span class="lineNum">     171 </span>            :   }
<span class="lineNum">     172 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /**
<span class="lineNum">     175 </span>            :  * Intersects an interval as IntersectInterval does but by taking
<span class="lineNum">     176 </span>            :  * the offset and length of the other interval from a
<span class="lineNum">     177 </span>            :  * nsTextFrame::TrimmedOffsets object.
<a name="178"><span class="lineNum">     178 </span>            :  */</a>
<span class="lineNum">     179 </span>            : static void
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : TrimOffsets(uint32_t&amp; aStart, uint32_t&amp; aLength,</span>
<span class="lineNum">     181 </span>            :             const nsTextFrame::TrimmedOffsets&amp; aTrimmedOffsets)
<span class="lineNum">     182 </span>            : {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   IntersectInterval(aStart, aLength,</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :                     aTrimmedOffsets.mStart, aTrimmedOffsets.mLength);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : /**
<span class="lineNum">     188 </span>            :  * Returns the closest ancestor-or-self node that is not an SVG &lt;a&gt;
<span class="lineNum">     189 </span>            :  * element.
<a name="190"><span class="lineNum">     190 </span>            :  */</a>
<span class="lineNum">     191 </span>            : static nsIContent*
<span class="lineNum">     192 </span><span class="lineNoCov">          0 : GetFirstNonAAncestor(nsIContent* aContent)</span>
<span class="lineNum">     193 </span>            : {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   while (aContent &amp;&amp; aContent-&gt;IsSVGElement(nsGkAtoms::a)) {</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     aContent = aContent-&gt;GetParent();</span>
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   return aContent;</span>
<span class="lineNum">     198 </span>            : }
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /**
<span class="lineNum">     201 </span>            :  * Returns whether the given node is a text content element[1], taking into
<span class="lineNum">     202 </span>            :  * account whether it has a valid parent.
<span class="lineNum">     203 </span>            :  *
<span class="lineNum">     204 </span>            :  * For example, in:
<span class="lineNum">     205 </span>            :  *
<span class="lineNum">     206 </span>            :  *   &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
<span class="lineNum">     207 </span>            :  *     &lt;text&gt;&lt;a/&gt;&lt;text/&gt;&lt;/text&gt;
<span class="lineNum">     208 </span>            :  *     &lt;tspan/&gt;
<span class="lineNum">     209 </span>            :  *   &lt;/svg&gt;
<span class="lineNum">     210 </span>            :  *
<span class="lineNum">     211 </span>            :  * true would be returned for the outer &lt;text&gt; element and the &lt;a&gt; element,
<span class="lineNum">     212 </span>            :  * and false for the inner &lt;text&gt; element (since a &lt;text&gt; is not allowed
<span class="lineNum">     213 </span>            :  * to be a child of another &lt;text&gt;) and the &lt;tspan&gt; element (because it
<span class="lineNum">     214 </span>            :  * must be inside a &lt;text&gt; subtree).
<span class="lineNum">     215 </span>            :  *
<span class="lineNum">     216 </span>            :  * Note that we don't support the &lt;tref&gt; element yet and this function
<span class="lineNum">     217 </span>            :  * returns false for it.
<span class="lineNum">     218 </span>            :  *
<span class="lineNum">     219 </span>            :  * [1] https://svgwg.org/svg2-draft/intro.html#TermTextContentElement
<a name="220"><span class="lineNum">     220 </span>            :  */</a>
<span class="lineNum">     221 </span>            : static bool
<span class="lineNum">     222 </span><span class="lineNoCov">          0 : IsTextContentElement(nsIContent* aContent)</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsSVGElement(nsGkAtoms::text)) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     nsIContent* parent = GetFirstNonAAncestor(aContent-&gt;GetParent());</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     return !parent || !IsTextContentElement(parent);</span>
<span class="lineNum">     227 </span>            :   }
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     nsIContent* parent = GetFirstNonAAncestor(aContent-&gt;GetParent());</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     return parent &amp;&amp; parent-&gt;IsSVGElement(nsGkAtoms::text);</span>
<span class="lineNum">     232 </span>            :   }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsAnyOfSVGElements(nsGkAtoms::a,</span>
<span class="lineNum">     235 </span>            :                                    nsGkAtoms::tspan)) {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     240 </span>            : }
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : /**
<span class="lineNum">     243 </span>            :  * Returns whether the specified frame is an nsTextFrame that has some text
<span class="lineNum">     244 </span>            :  * content.
<a name="245"><span class="lineNum">     245 </span>            :  */</a>
<span class="lineNum">     246 </span>            : static bool
<span class="lineNum">     247 </span><span class="lineNoCov">          0 : IsNonEmptyTextFrame(nsIFrame* aFrame)</span>
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   nsTextFrame* textFrame = do_QueryFrame(aFrame);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   if (!textFrame) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   return textFrame-&gt;GetContentLength() != 0;</span>
<span class="lineNum">     255 </span>            : }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /**
<span class="lineNum">     258 </span>            :  * Takes an nsIFrame and if it is a text frame that has some text content,
<span class="lineNum">     259 </span>            :  * returns it as an nsTextFrame and its corresponding nsTextNode.
<span class="lineNum">     260 </span>            :  *
<span class="lineNum">     261 </span>            :  * @param aFrame The frame to look at.
<span class="lineNum">     262 </span>            :  * @param aTextFrame aFrame as an nsTextFrame (output).
<span class="lineNum">     263 </span>            :  * @param aTextNode The nsTextNode content of aFrame (output).
<span class="lineNum">     264 </span>            :  * @return true if aFrame is a non-empty text frame, false otherwise.
<a name="265"><span class="lineNum">     265 </span>            :  */</a>
<span class="lineNum">     266 </span>            : static bool
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : GetNonEmptyTextFrameAndNode(nsIFrame* aFrame,</span>
<span class="lineNum">     268 </span>            :                             nsTextFrame*&amp; aTextFrame,
<span class="lineNum">     269 </span>            :                             nsTextNode*&amp; aTextNode)
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   nsTextFrame* text = do_QueryFrame(aFrame);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   bool isNonEmptyTextFrame = text &amp;&amp; text-&gt;GetContentLength() != 0;</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   if (isNonEmptyTextFrame) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     nsIContent* content = text-&gt;GetContent();</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     NS_ASSERTION(content &amp;&amp; content-&gt;IsNodeOfType(nsINode::eTEXT),</span>
<span class="lineNum">     277 </span>            :                  &quot;unexpected content type for nsTextFrame&quot;);
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     nsTextNode* node = static_cast&lt;nsTextNode*&gt;(content);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(node-&gt;TextLength() != 0,</span>
<span class="lineNum">     281 </span>            :                &quot;frame's GetContentLength() should be 0 if the text node &quot;
<span class="lineNum">     282 </span>            :                &quot;has no content&quot;);
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     aTextFrame = text;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     aTextNode = node;</span>
<span class="lineNum">     286 </span>            :   }
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsNonEmptyTextFrame(aFrame) == isNonEmptyTextFrame,</span>
<span class="lineNum">     289 </span>            :              &quot;our logic should agree with IsNonEmptyTextFrame&quot;);
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   return isNonEmptyTextFrame;</span>
<span class="lineNum">     291 </span>            : }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : /**
<span class="lineNum">     294 </span>            :  * Returns whether the specified atom is for one of the five
<span class="lineNum">     295 </span>            :  * glyph positioning attributes that can appear on SVG text
<span class="lineNum">     296 </span>            :  * elements -- x, y, dx, dy or rotate.
<a name="297"><span class="lineNum">     297 </span>            :  */</a>
<span class="lineNum">     298 </span>            : static bool
<span class="lineNum">     299 </span><span class="lineNoCov">          0 : IsGlyphPositioningAttribute(nsIAtom* aAttribute)</span>
<span class="lineNum">     300 </span>            : {
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   return aAttribute == nsGkAtoms::x ||</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :          aAttribute == nsGkAtoms::y ||</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :          aAttribute == nsGkAtoms::dx ||</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :          aAttribute == nsGkAtoms::dy ||</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :          aAttribute == nsGkAtoms::rotate;</span>
<span class="lineNum">     306 </span>            : }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : /**
<span class="lineNum">     309 </span>            :  * Returns the position in app units of a given baseline (using an
<span class="lineNum">     310 </span>            :  * SVG dominant-baseline property value) for a given nsTextFrame.
<span class="lineNum">     311 </span>            :  *
<span class="lineNum">     312 </span>            :  * @param aFrame The text frame to inspect.
<span class="lineNum">     313 </span>            :  * @param aTextRun The text run of aFrame.
<span class="lineNum">     314 </span>            :  * @param aDominantBaseline The dominant-baseline value to use.
<a name="315"><span class="lineNum">     315 </span>            :  */</a>
<span class="lineNum">     316 </span>            : static nscoord
<span class="lineNum">     317 </span><span class="lineNoCov">          0 : GetBaselinePosition(nsTextFrame* aFrame,</span>
<span class="lineNum">     318 </span>            :                     gfxTextRun* aTextRun,
<span class="lineNum">     319 </span>            :                     uint8_t aDominantBaseline,
<span class="lineNum">     320 </span>            :                     float aFontSizeScaleFactor)
<span class="lineNum">     321 </span>            : {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   WritingMode writingMode = aFrame-&gt;GetWritingMode();</span>
<span class="lineNum">     323 </span>            :   gfxTextRun::Metrics metrics =
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     aTextRun-&gt;MeasureText(gfxFont::LOOSE_INK_EXTENTS, nullptr);</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   switch (aDominantBaseline) {</span>
<span class="lineNum">     327 </span>            :     case NS_STYLE_DOMINANT_BASELINE_HANGING:
<span class="lineNum">     328 </span>            :     case NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE:
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       return writingMode.IsVerticalRL()</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :              ? metrics.mAscent + metrics.mDescent : 0;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :     case NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT:
<span class="lineNum">     333 </span>            :     case NS_STYLE_DOMINANT_BASELINE_NO_CHANGE:
<span class="lineNum">     334 </span>            :     case NS_STYLE_DOMINANT_BASELINE_RESET_SIZE:
<span class="lineNum">     335 </span>            :       // These three should not simply map to 'baseline', but we don't
<span class="lineNum">     336 </span>            :       // support the complex baseline model that SVG 1.1 has and which
<span class="lineNum">     337 </span>            :       // css3-linebox now defines.
<span class="lineNum">     338 </span>            :       // (fall through)
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :     case NS_STYLE_DOMINANT_BASELINE_AUTO:
<span class="lineNum">     341 </span>            :     case NS_STYLE_DOMINANT_BASELINE_ALPHABETIC:
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :       return writingMode.IsVerticalRL()</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :              ? metrics.mAscent + metrics.mDescent -</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                aFrame-&gt;GetLogicalBaseline(writingMode)</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :              : aFrame-&gt;GetLogicalBaseline(writingMode);</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     case NS_STYLE_DOMINANT_BASELINE_MIDDLE:
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       return aFrame-&gt;GetLogicalBaseline(writingMode) -</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         SVGContentUtils::GetFontXHeight(aFrame) / 2.0 *</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         aFrame-&gt;PresContext()-&gt;AppUnitsPerCSSPixel() * aFontSizeScaleFactor;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :     case NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE:
<span class="lineNum">     353 </span>            :     case NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC:
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       return writingMode.IsVerticalLR()</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :              ? 0 : metrics.mAscent + metrics.mDescent;</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :     case NS_STYLE_DOMINANT_BASELINE_CENTRAL:
<span class="lineNum">     358 </span>            :     case NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL:
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :       return (metrics.mAscent + metrics.mDescent) / 2.0;</span>
<span class="lineNum">     360 </span>            :   }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   NS_NOTREACHED(&quot;unexpected dominant-baseline value&quot;);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   return aFrame-&gt;GetLogicalBaseline(writingMode);</span>
<span class="lineNum">     364 </span>            : }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : /**
<span class="lineNum">     367 </span>            :  * For a given text run, returns the range of skipped characters that comprise
<span class="lineNum">     368 </span>            :  * the ligature group and/or cluster that includes the character represented
<span class="lineNum">     369 </span>            :  * by the specified gfxSkipCharsIterator.
<span class="lineNum">     370 </span>            :  *
<span class="lineNum">     371 </span>            :  * @param aTextRun The text run to use for determining whether a given character
<span class="lineNum">     372 </span>            :  *   is part of a ligature or cluster.
<span class="lineNum">     373 </span>            :  * @param aIterator The gfxSkipCharsIterator to use for the current position
<span class="lineNum">     374 </span>            :  *   in the text run.
<a name="375"><span class="lineNum">     375 </span>            :  */</a>
<span class="lineNum">     376 </span>            : static gfxTextRun::Range
<span class="lineNum">     377 </span><span class="lineNoCov">          0 : ClusterRange(gfxTextRun* aTextRun, const gfxSkipCharsIterator&amp; aIterator)</span>
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   uint32_t start = aIterator.GetSkippedOffset();</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   uint32_t end = start + 1;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   while (end &lt; aTextRun-&gt;GetLength() &amp;&amp;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :          (!aTextRun-&gt;IsLigatureGroupStart(end) ||</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :           !aTextRun-&gt;IsClusterStart(end))) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     end++;</span>
<span class="lineNum">     385 </span>            :   }
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   return gfxTextRun::Range(start, end);</span>
<span class="lineNum">     387 </span>            : }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : /**
<span class="lineNum">     390 </span>            :  * Truncates an array to be at most the length of another array.
<span class="lineNum">     391 </span>            :  *
<span class="lineNum">     392 </span>            :  * @param aArrayToTruncate The array to truncate.
<span class="lineNum">     393 </span>            :  * @param aReferenceArray The array whose length will be used to truncate
<span class="lineNum">     394 </span>            :  *   aArrayToTruncate to.
<span class="lineNum">     395 </span>            :  */
<a name="396"><span class="lineNum">     396 </span>            : template&lt;typename T, typename U&gt;</a>
<span class="lineNum">     397 </span>            : static void
<span class="lineNum">     398 </span><span class="lineNoCov">          0 : TruncateTo(nsTArray&lt;T&gt;&amp; aArrayToTruncate, const nsTArray&lt;U&gt;&amp; aReferenceArray)</span>
<span class="lineNum">     399 </span>            : {
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   uint32_t length = aReferenceArray.Length();</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   if (aArrayToTruncate.Length() &gt; length) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     aArrayToTruncate.TruncateLength(length);</span>
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : /**
<span class="lineNum">     407 </span>            :  * Asserts that the anonymous block child of the SVGTextFrame has been
<span class="lineNum">     408 </span>            :  * reflowed (or does not exist).  Returns null if the child has not been
<span class="lineNum">     409 </span>            :  * reflowed, and the frame otherwise.
<span class="lineNum">     410 </span>            :  *
<span class="lineNum">     411 </span>            :  * We check whether the kid has been reflowed and not the frame itself
<span class="lineNum">     412 </span>            :  * since we sometimes need to call this function during reflow, after the
<span class="lineNum">     413 </span>            :  * kid has been reflowed but before we have cleared the dirty bits on the
<span class="lineNum">     414 </span>            :  * frame itself.
<a name="415"><span class="lineNum">     415 </span>            :  */</a>
<span class="lineNum">     416 </span>            : static SVGTextFrame*
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : FrameIfAnonymousChildReflowed(SVGTextFrame* aFrame)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   NS_PRECONDITION(aFrame, &quot;aFrame must not be null&quot;);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   nsIFrame* kid = aFrame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   if (NS_SUBTREE_DIRTY(kid)) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;should have already reflowed the anonymous block child&quot;);</span>
<span class="lineNum">     423 </span>            :     return nullptr;
<span class="lineNum">     424 </span>            :   }
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   return aFrame;</span>
<span class="lineNum">     426 </span>            : }
<a name="427"><span class="lineNum">     427 </span>            : </a>
<span class="lineNum">     428 </span>            : static double
<span class="lineNum">     429 </span><span class="lineNoCov">          0 : GetContextScale(const gfxMatrix&amp; aMatrix)</span>
<span class="lineNum">     430 </span>            : {
<span class="lineNum">     431 </span>            :   // The context scale is the ratio of the length of the transformed
<span class="lineNum">     432 </span>            :   // diagonal vector (1,1) to the length of the untransformed diagonal
<span class="lineNum">     433 </span>            :   // (which is sqrt(2)).
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   gfxPoint p = aMatrix.TransformPoint(gfxPoint(1, 1)) -</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                aMatrix.TransformPoint(gfxPoint(0, 0));</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   return SVGContentUtils::ComputeNormalizedHypotenuse(p.x, p.y);</span>
<span class="lineNum">     437 </span>            : }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : // ============================================================================
<span class="lineNum">     440 </span>            : // Utility classes
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : namespace mozilla {
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : // ----------------------------------------------------------------------------
<span class="lineNum">     445 </span>            : // TextRenderedRun
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            : /**
<span class="lineNum">     448 </span>            :  * A run of text within a single nsTextFrame whose glyphs can all be painted
<span class="lineNum">     449 </span>            :  * with a single call to nsTextFrame::PaintText.  A text rendered run can
<span class="lineNum">     450 </span>            :  * be created for a sequence of two or more consecutive glyphs as long as:
<span class="lineNum">     451 </span>            :  *
<span class="lineNum">     452 </span>            :  *   - Only the first glyph has (or none of the glyphs have) been positioned
<span class="lineNum">     453 </span>            :  *     with SVG text positioning attributes
<span class="lineNum">     454 </span>            :  *   - All of the glyphs have zero rotation
<span class="lineNum">     455 </span>            :  *   - The glyphs are not on a text path
<span class="lineNum">     456 </span>            :  *   - The glyphs correspond to content within the one nsTextFrame
<span class="lineNum">     457 </span>            :  *
<span class="lineNum">     458 </span>            :  * A TextRenderedRunIterator produces TextRenderedRuns required for painting a
<span class="lineNum">     459 </span>            :  * whole SVGTextFrame.
<span class="lineNum">     460 </span>            :  */
<span class="lineNum">     461 </span>            : struct TextRenderedRun
<span class="lineNum">     462 </span>            : {
<span class="lineNum">     463 </span>            :   typedef gfxTextRun::Range Range;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   /**
<span class="lineNum">     466 </span>            :    * Constructs a TextRenderedRun that is uninitialized except for mFrame
<a name="467"><span class="lineNum">     467 </span>            :    * being null.</a>
<span class="lineNum">     468 </span>            :    */
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   TextRenderedRun()</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     : mFrame(nullptr)</span>
<span class="lineNum">     471 </span>            :   {
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :   /**
<span class="lineNum">     475 </span>            :    * Constructs a TextRenderedRun with all of the information required to
<span class="lineNum">     476 </span>            :    * paint it.  See the comments documenting the member variables below
<a name="477"><span class="lineNum">     477 </span>            :    * for descriptions of the arguments.</a>
<span class="lineNum">     478 </span>            :    */
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   TextRenderedRun(nsTextFrame* aFrame, const gfxPoint&amp; aPosition,</span>
<span class="lineNum">     480 </span>            :                   float aLengthAdjustScaleFactor, double aRotate,
<span class="lineNum">     481 </span>            :                   float aFontSizeScaleFactor, nscoord aBaseline,
<span class="lineNum">     482 </span>            :                   uint32_t aTextFrameContentOffset,
<span class="lineNum">     483 </span>            :                   uint32_t aTextFrameContentLength,
<span class="lineNum">     484 </span>            :                   uint32_t aTextElementCharIndex)
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     : mFrame(aFrame),</span>
<span class="lineNum">     486 </span>            :       mPosition(aPosition),
<span class="lineNum">     487 </span>            :       mLengthAdjustScaleFactor(aLengthAdjustScaleFactor),
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       mRotate(static_cast&lt;float&gt;(aRotate)),</span>
<span class="lineNum">     489 </span>            :       mFontSizeScaleFactor(aFontSizeScaleFactor),
<span class="lineNum">     490 </span>            :       mBaseline(aBaseline),
<span class="lineNum">     491 </span>            :       mTextFrameContentOffset(aTextFrameContentOffset),
<span class="lineNum">     492 </span>            :       mTextFrameContentLength(aTextFrameContentLength),
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       mTextElementCharIndex(aTextElementCharIndex)</span>
<span class="lineNum">     494 </span>            :   {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   /**
<a name="498"><span class="lineNum">     498 </span>            :    * Returns the text run for the text frame that this rendered run is part of.</a>
<span class="lineNum">     499 </span>            :    */
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   gfxTextRun* GetTextRun() const</span>
<span class="lineNum">     501 </span>            :   {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     return mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     504 </span>            :   }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :   /**
<a name="507"><span class="lineNum">     507 </span>            :    * Returns whether this rendered run is RTL.</a>
<span class="lineNum">     508 </span>            :    */
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   bool IsRightToLeft() const</span>
<span class="lineNum">     510 </span>            :   {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     return GetTextRun()-&gt;IsRightToLeft();</span>
<span class="lineNum">     512 </span>            :   }
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :   /**
<a name="515"><span class="lineNum">     515 </span>            :    * Returns whether this rendered run is vertical.</a>
<span class="lineNum">     516 </span>            :    */
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   bool IsVertical() const</span>
<span class="lineNum">     518 </span>            :   {
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     return GetTextRun()-&gt;IsVertical();</span>
<span class="lineNum">     520 </span>            :   }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   /**
<span class="lineNum">     523 </span>            :    * Returns the transform that converts from a &lt;text&gt; element's user space into
<span class="lineNum">     524 </span>            :    * the coordinate space that rendered runs can be painted directly in.
<span class="lineNum">     525 </span>            :    *
<span class="lineNum">     526 </span>            :    * The difference between this method and GetTransformFromRunUserSpaceToUserSpace
<span class="lineNum">     527 </span>            :    * is that when calling in to nsTextFrame::PaintText, it will already take
<span class="lineNum">     528 </span>            :    * into account any left clip edge (that is, it doesn't just apply a visual
<span class="lineNum">     529 </span>            :    * clip to the rendered text, it shifts the glyphs over so that they are
<span class="lineNum">     530 </span>            :    * painted with their left edge at the x coordinate passed in to it).
<span class="lineNum">     531 </span>            :    * Thus we need to account for this in our transform.
<span class="lineNum">     532 </span>            :    *
<span class="lineNum">     533 </span>            :    *
<span class="lineNum">     534 </span>            :    * Assume that we have &lt;text x=&quot;100&quot; y=&quot;100&quot; rotate=&quot;0 0 1 0 0 1&quot;&gt;abcdef&lt;/text&gt;.
<span class="lineNum">     535 </span>            :    * This would result in four text rendered runs:
<span class="lineNum">     536 </span>            :    *
<span class="lineNum">     537 </span>            :    *   - one for &quot;ab&quot;
<span class="lineNum">     538 </span>            :    *   - one for &quot;c&quot;
<span class="lineNum">     539 </span>            :    *   - one for &quot;de&quot;
<span class="lineNum">     540 </span>            :    *   - one for &quot;f&quot;
<span class="lineNum">     541 </span>            :    *
<span class="lineNum">     542 </span>            :    * Assume now that we are painting the third TextRenderedRun.  It will have
<span class="lineNum">     543 </span>            :    * a left clip edge that is the sum of the advances of &quot;abc&quot;, and it will
<span class="lineNum">     544 </span>            :    * have a right clip edge that is the advance of &quot;f&quot;.  In
<span class="lineNum">     545 </span>            :    * SVGTextFrame::PaintSVG(), we pass in nsPoint() (i.e., the origin)
<span class="lineNum">     546 </span>            :    * as the point at which to paint the text frame, and we pass in the
<span class="lineNum">     547 </span>            :    * clip edge values.  The nsTextFrame will paint the substring of its
<span class="lineNum">     548 </span>            :    * text such that the top-left corner of the &quot;d&quot;'s glyph cell will be at
<span class="lineNum">     549 </span>            :    * (0, 0) in the current coordinate system.
<span class="lineNum">     550 </span>            :    *
<span class="lineNum">     551 </span>            :    * Thus, GetTransformFromUserSpaceForPainting must return a transform from
<span class="lineNum">     552 </span>            :    * whatever user space the &lt;text&gt; element is in to a coordinate space in
<span class="lineNum">     553 </span>            :    * device pixels (as that's what nsTextFrame works in) where the origin is at
<span class="lineNum">     554 </span>            :    * the same position as our user space mPositions[i].mPosition value for
<span class="lineNum">     555 </span>            :    * the &quot;d&quot; glyph, which will be (100 + userSpaceAdvance(&quot;abc&quot;), 100).
<span class="lineNum">     556 </span>            :    * The translation required to do this (ignoring the scale to get from
<span class="lineNum">     557 </span>            :    * user space to device pixels, and ignoring the
<span class="lineNum">     558 </span>            :    * (100 + userSpaceAdvance(&quot;abc&quot;), 100) translation) is:
<span class="lineNum">     559 </span>            :    *
<span class="lineNum">     560 </span>            :    *   (-leftEdge, -baseline)
<span class="lineNum">     561 </span>            :    *
<span class="lineNum">     562 </span>            :    * where baseline is the distance between the baseline of the text and the top
<span class="lineNum">     563 </span>            :    * edge of the nsTextFrame.  We translate by -leftEdge horizontally because
<span class="lineNum">     564 </span>            :    * the nsTextFrame will already shift the glyphs over by that amount and start
<span class="lineNum">     565 </span>            :    * painting glyphs at x = 0.  We translate by -baseline vertically so that
<span class="lineNum">     566 </span>            :    * painting the top edges of the glyphs at y = 0 will result in their
<span class="lineNum">     567 </span>            :    * baselines being at our desired y position.
<span class="lineNum">     568 </span>            :    *
<span class="lineNum">     569 </span>            :    *
<span class="lineNum">     570 </span>            :    * Now for an example with RTL text.  Assume our content is now
<span class="lineNum">     571 </span>            :    * &lt;text x=&quot;100&quot; y=&quot;100&quot; rotate=&quot;0 0 1 0 0 1&quot;&gt;WERBEH&lt;/text&gt;.  We'd have
<span class="lineNum">     572 </span>            :    * the following text rendered runs:
<span class="lineNum">     573 </span>            :    *
<span class="lineNum">     574 </span>            :    *   - one for &quot;EH&quot;
<span class="lineNum">     575 </span>            :    *   - one for &quot;B&quot;
<span class="lineNum">     576 </span>            :    *   - one for &quot;ER&quot;
<span class="lineNum">     577 </span>            :    *   - one for &quot;W&quot;
<span class="lineNum">     578 </span>            :    *
<span class="lineNum">     579 </span>            :    * Again, we are painting the third TextRenderedRun.  The left clip edge
<span class="lineNum">     580 </span>            :    * is the advance of the &quot;W&quot; and the right clip edge is the sum of the
<span class="lineNum">     581 </span>            :    * advances of &quot;BEH&quot;.  Our translation to get the rendered &quot;ER&quot; glyphs
<span class="lineNum">     582 </span>            :    * in the right place this time is:
<span class="lineNum">     583 </span>            :    *
<span class="lineNum">     584 </span>            :    *   (-frameWidth + rightEdge, -baseline)
<span class="lineNum">     585 </span>            :    *
<span class="lineNum">     586 </span>            :    * which is equivalent to:
<span class="lineNum">     587 </span>            :    *
<span class="lineNum">     588 </span>            :    *   (-(leftEdge + advance(&quot;ER&quot;)), -baseline)
<span class="lineNum">     589 </span>            :    *
<span class="lineNum">     590 </span>            :    * The reason we have to shift left additionally by the width of the run
<span class="lineNum">     591 </span>            :    * of glyphs we are painting is that although the nsTextFrame is RTL,
<span class="lineNum">     592 </span>            :    * we still supply the top-left corner to paint the frame at when calling
<span class="lineNum">     593 </span>            :    * nsTextFrame::PaintText, even though our user space positions for each
<span class="lineNum">     594 </span>            :    * glyph in mPositions specifies the origin of each glyph, which for RTL
<span class="lineNum">     595 </span>            :    * glyphs is at the right edge of the glyph cell.
<span class="lineNum">     596 </span>            :    *
<span class="lineNum">     597 </span>            :    *
<span class="lineNum">     598 </span>            :    * For any other use of an nsTextFrame in the context of a particular run
<span class="lineNum">     599 </span>            :    * (such as hit testing, or getting its rectangle),
<span class="lineNum">     600 </span>            :    * GetTransformFromRunUserSpaceToUserSpace should be used.
<span class="lineNum">     601 </span>            :    *
<span class="lineNum">     602 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     603 </span>            :    * @param aItem The nsCharClipDisplayItem that holds the amount of clipping
<span class="lineNum">     604 </span>            :    *   from the left and right edges of the text frame for this rendered run.
<span class="lineNum">     605 </span>            :    *   An appropriate nsCharClipDisplayItem can be obtained by constructing an
<span class="lineNum">     606 </span>            :    *   SVGCharClipDisplayItem for the TextRenderedRun.
<span class="lineNum">     607 </span>            :    */
<span class="lineNum">     608 </span>            :   gfxMatrix GetTransformFromUserSpaceForPainting(
<span class="lineNum">     609 </span>            :                                       nsPresContext* aContext,
<span class="lineNum">     610 </span>            :                                       const nsCharClipDisplayItem&amp; aItem) const;
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :   /**
<span class="lineNum">     613 </span>            :    * Returns the transform that converts from &quot;run user space&quot; to a &lt;text&gt;
<span class="lineNum">     614 </span>            :    * element's user space.  Run user space is a coordinate system that has the
<span class="lineNum">     615 </span>            :    * same size as the &lt;text&gt;'s user space but rotated and translated such that
<span class="lineNum">     616 </span>            :    * (0,0) is the top-left of the rectangle that bounds the text.
<span class="lineNum">     617 </span>            :    *
<span class="lineNum">     618 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     619 </span>            :    */
<span class="lineNum">     620 </span>            :   gfxMatrix GetTransformFromRunUserSpaceToUserSpace(nsPresContext* aContext) const;
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :   /**
<span class="lineNum">     623 </span>            :    * Returns the transform that converts from &quot;run user space&quot; to float pixels
<span class="lineNum">     624 </span>            :    * relative to the nsTextFrame that this rendered run is a part of.
<span class="lineNum">     625 </span>            :    *
<span class="lineNum">     626 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     627 </span>            :    */
<span class="lineNum">     628 </span>            :   gfxMatrix GetTransformFromRunUserSpaceToFrameUserSpace(nsPresContext* aContext) const;
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :   /**
<span class="lineNum">     631 </span>            :    * Flag values used for the aFlags arguments of GetRunUserSpaceRect,
<span class="lineNum">     632 </span>            :    * GetFrameUserSpaceRect and GetUserSpaceRect.
<span class="lineNum">     633 </span>            :    */
<span class="lineNum">     634 </span>            :   enum {
<span class="lineNum">     635 </span>            :     // Includes the fill geometry of the text in the returned rectangle.
<span class="lineNum">     636 </span>            :     eIncludeFill = 1,
<span class="lineNum">     637 </span>            :     // Includes the stroke geometry of the text in the returned rectangle.
<span class="lineNum">     638 </span>            :     eIncludeStroke = 2,
<span class="lineNum">     639 </span>            :     // Includes any text shadow in the returned rectangle.
<span class="lineNum">     640 </span>            :     eIncludeTextShadow = 4,
<span class="lineNum">     641 </span>            :     // Don't include any horizontal glyph overflow in the returned rectangle.
<span class="lineNum">     642 </span>            :     eNoHorizontalOverflow = 8
<span class="lineNum">     643 </span>            :   };
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   /**
<span class="lineNum">     646 </span>            :    * Returns a rectangle that bounds the fill and/or stroke of the rendered run
<span class="lineNum">     647 </span>            :    * in run user space.
<span class="lineNum">     648 </span>            :    *
<span class="lineNum">     649 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     650 </span>            :    * @param aFlags A combination of the flags above (eIncludeFill and
<span class="lineNum">     651 </span>            :    *   eIncludeStroke) indicating what parts of the text to include in
<span class="lineNum">     652 </span>            :    *   the rectangle.
<span class="lineNum">     653 </span>            :    */
<span class="lineNum">     654 </span>            :   SVGBBox GetRunUserSpaceRect(nsPresContext* aContext, uint32_t aFlags) const;
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   /**
<span class="lineNum">     657 </span>            :    * Returns a rectangle that covers the fill and/or stroke of the rendered run
<span class="lineNum">     658 </span>            :    * in &quot;frame user space&quot;.
<span class="lineNum">     659 </span>            :    *
<span class="lineNum">     660 </span>            :    * Frame user space is a coordinate space of the same scale as the &lt;text&gt;
<span class="lineNum">     661 </span>            :    * element's user space, but with its rotation set to the rotation of
<span class="lineNum">     662 </span>            :    * the glyphs within this rendered run and its origin set to the position
<span class="lineNum">     663 </span>            :    * such that placing the nsTextFrame there would result in the glyphs in
<span class="lineNum">     664 </span>            :    * this rendered run being at their correct positions.
<span class="lineNum">     665 </span>            :    *
<span class="lineNum">     666 </span>            :    * For example, say we have &lt;text x=&quot;100 150&quot; y=&quot;100&quot;&gt;ab&lt;/text&gt;.  Assume
<span class="lineNum">     667 </span>            :    * the advance of both the &quot;a&quot; and the &quot;b&quot; is 12 user units, and the
<span class="lineNum">     668 </span>            :    * ascent of the text is 8 user units and its descent is 6 user units,
<span class="lineNum">     669 </span>            :    * and that we are not measuing the stroke of the text, so that we stay
<span class="lineNum">     670 </span>            :    * entirely within the glyph cells.
<span class="lineNum">     671 </span>            :    *
<span class="lineNum">     672 </span>            :    * There will be two text rendered runs, one for &quot;a&quot; and one for &quot;b&quot;.
<span class="lineNum">     673 </span>            :    *
<span class="lineNum">     674 </span>            :    * The frame user space for the &quot;a&quot; run will have its origin at
<span class="lineNum">     675 </span>            :    * (100, 100 - 8) in the &lt;text&gt; element's user space and will have its
<span class="lineNum">     676 </span>            :    * axes aligned with the user space (since there is no rotate=&quot;&quot; or
<span class="lineNum">     677 </span>            :    * text path involve) and with its scale the same as the user space.
<span class="lineNum">     678 </span>            :    * The rect returned by this method will be (0, 0, 12, 14), since the &quot;a&quot;
<span class="lineNum">     679 </span>            :    * glyph is right at the left of the nsTextFrame.
<span class="lineNum">     680 </span>            :    *
<span class="lineNum">     681 </span>            :    * The frame user space for the &quot;b&quot; run will have its origin at
<span class="lineNum">     682 </span>            :    * (150 - 12, 100 - 8), and scale/rotation the same as above.  The rect
<span class="lineNum">     683 </span>            :    * returned by this method will be (12, 0, 12, 14), since we are
<span class="lineNum">     684 </span>            :    * advance(&quot;a&quot;) horizontally in to the text frame.
<span class="lineNum">     685 </span>            :    *
<span class="lineNum">     686 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     687 </span>            :    * @param aFlags A combination of the flags above (eIncludeFill and
<span class="lineNum">     688 </span>            :    *   eIncludeStroke) indicating what parts of the text to include in
<span class="lineNum">     689 </span>            :    *   the rectangle.
<span class="lineNum">     690 </span>            :    */
<span class="lineNum">     691 </span>            :   SVGBBox GetFrameUserSpaceRect(nsPresContext* aContext, uint32_t aFlags) const;
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :   /**
<span class="lineNum">     694 </span>            :    * Returns a rectangle that covers the fill and/or stroke of the rendered run
<span class="lineNum">     695 </span>            :    * in the &lt;text&gt; element's user space.
<span class="lineNum">     696 </span>            :    *
<span class="lineNum">     697 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     698 </span>            :    * @param aFlags A combination of the flags above indicating what parts of the
<span class="lineNum">     699 </span>            :    *   text to include in the rectangle.
<span class="lineNum">     700 </span>            :    * @param aAdditionalTransform An additional transform to apply to the
<span class="lineNum">     701 </span>            :    *   frame user space rectangle before its bounds are transformed into
<span class="lineNum">     702 </span>            :    *   user space.
<span class="lineNum">     703 </span>            :    */
<span class="lineNum">     704 </span>            :   SVGBBox GetUserSpaceRect(nsPresContext* aContext, uint32_t aFlags,
<span class="lineNum">     705 </span>            :                            const gfxMatrix* aAdditionalTransform = nullptr) const;
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   /**
<span class="lineNum">     708 </span>            :    * Gets the app unit amounts to clip from the left and right edges of
<span class="lineNum">     709 </span>            :    * the nsTextFrame in order to paint just this rendered run.
<span class="lineNum">     710 </span>            :    *
<span class="lineNum">     711 </span>            :    * Note that if clip edge amounts land in the middle of a glyph, the
<span class="lineNum">     712 </span>            :    * glyph won't be painted at all.  The clip edges are thus more of
<span class="lineNum">     713 </span>            :    * a selection mechanism for which glyphs will be painted, rather
<span class="lineNum">     714 </span>            :    * than a geometric clip.
<span class="lineNum">     715 </span>            :    */
<span class="lineNum">     716 </span>            :   void GetClipEdges(nscoord&amp; aVisIStartEdge, nscoord&amp; aVisIEndEdge) const;
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :   /**
<span class="lineNum">     719 </span>            :    * Returns the advance width of the whole rendered run.
<span class="lineNum">     720 </span>            :    */
<span class="lineNum">     721 </span>            :   nscoord GetAdvanceWidth() const;
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   /**
<span class="lineNum">     724 </span>            :    * Returns the index of the character into this rendered run whose
<span class="lineNum">     725 </span>            :    * glyph cell contains the given point, or -1 if there is no such
<span class="lineNum">     726 </span>            :    * character.  This does not hit test against any overflow.
<span class="lineNum">     727 </span>            :    *
<span class="lineNum">     728 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">     729 </span>            :    * @param aPoint The point in the user space of the &lt;text&gt; element.
<span class="lineNum">     730 </span>            :    */
<span class="lineNum">     731 </span>            :   int32_t GetCharNumAtPosition(nsPresContext* aContext,
<span class="lineNum">     732 </span>            :                                const gfxPoint&amp; aPoint) const;
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :   /**
<span class="lineNum">     735 </span>            :    * The text frame that this rendered run lies within.
<span class="lineNum">     736 </span>            :    */
<span class="lineNum">     737 </span>            :   nsTextFrame* mFrame;
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   /**
<span class="lineNum">     740 </span>            :    * The point in user space that the text is positioned at.
<span class="lineNum">     741 </span>            :    *
<span class="lineNum">     742 </span>            :    * For a horizontal run:
<span class="lineNum">     743 </span>            :    * The x coordinate is the left edge of a LTR run of text or the right edge of
<span class="lineNum">     744 </span>            :    * an RTL run.  The y coordinate is the baseline of the text.
<span class="lineNum">     745 </span>            :    * For a vertical run:
<span class="lineNum">     746 </span>            :    * The x coordinate is the baseline of the text.
<span class="lineNum">     747 </span>            :    * The y coordinate is the top edge of a LTR run, or bottom of RTL.
<span class="lineNum">     748 </span>            :    */
<span class="lineNum">     749 </span>            :   gfxPoint mPosition;
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :   /**
<span class="lineNum">     752 </span>            :    * The horizontal scale factor to apply when painting glyphs to take
<span class="lineNum">     753 </span>            :    * into account textLength=&quot;&quot;.
<span class="lineNum">     754 </span>            :    */
<span class="lineNum">     755 </span>            :   float mLengthAdjustScaleFactor;
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            :   /**
<span class="lineNum">     758 </span>            :    * The rotation in radians in the user coordinate system that the text has.
<span class="lineNum">     759 </span>            :    */
<span class="lineNum">     760 </span>            :   float mRotate;
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :   /**
<span class="lineNum">     763 </span>            :    * The scale factor that was used to transform the text run's original font
<span class="lineNum">     764 </span>            :    * size into a sane range for painting and measurement.
<span class="lineNum">     765 </span>            :    */
<span class="lineNum">     766 </span>            :   double mFontSizeScaleFactor;
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :   /**
<span class="lineNum">     769 </span>            :    * The baseline in app units of this text run.  The measurement is from the
<span class="lineNum">     770 </span>            :    * top of the text frame. (From the left edge if vertical.)
<span class="lineNum">     771 </span>            :    */
<span class="lineNum">     772 </span>            :   nscoord mBaseline;
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :   /**
<span class="lineNum">     775 </span>            :    * The offset and length in mFrame's content nsTextNode that corresponds to
<span class="lineNum">     776 </span>            :    * this text rendered run.  These are original char indexes.
<span class="lineNum">     777 </span>            :    */
<span class="lineNum">     778 </span>            :   uint32_t mTextFrameContentOffset;
<span class="lineNum">     779 </span>            :   uint32_t mTextFrameContentLength;
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :   /**
<span class="lineNum">     782 </span>            :    * The character index in the whole SVG &lt;text&gt; element that this text rendered
<span class="lineNum">     783 </span>            :    * run begins at.
<span class="lineNum">     784 </span>            :    */
<span class="lineNum">     785 </span>            :   uint32_t mTextElementCharIndex;
<span class="lineNum">     786 </span>            : };
<a name="787"><span class="lineNum">     787 </span>            : </a>
<span class="lineNum">     788 </span>            : gfxMatrix
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : TextRenderedRun::GetTransformFromUserSpaceForPainting(</span>
<span class="lineNum">     790 </span>            :                                        nsPresContext* aContext,
<span class="lineNum">     791 </span>            :                                        const nsCharClipDisplayItem&amp; aItem) const
<span class="lineNum">     792 </span>            : {
<span class="lineNum">     793 </span>            :   // We transform to device pixels positioned such that painting the text frame
<span class="lineNum">     794 </span>            :   // at (0,0) with aItem will result in the text being in the right place.
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   gfxMatrix m;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   if (!mFrame) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     return m;</span>
<span class="lineNum">     799 </span>            :   }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :   // Glyph position in user space.
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   m.PreTranslate(mPosition / cssPxPerDevPx);</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :   // Take into account any font size scaling and scaling due to textLength=&quot;&quot;.
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   m.PreScale(1.0 / mFontSizeScaleFactor, 1.0 / mFontSizeScaleFactor);</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   // Rotation due to rotate=&quot;&quot; or a &lt;textPath&gt;.
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   m.PreRotate(mRotate);</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   m.PreScale(mLengthAdjustScaleFactor, 1.0);</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :   // Translation to get the text frame in the right place.
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   nsPoint t;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   if (IsVertical()) {</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     t = nsPoint(-mBaseline,</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                 IsRightToLeft()</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                   ? -mFrame-&gt;GetRect().height + aItem.mVisIEndEdge</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :                   : -aItem.mVisIStartEdge);</span>
<span class="lineNum">     822 </span>            :   } else {
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     t = nsPoint(IsRightToLeft()</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                   ? -mFrame-&gt;GetRect().width + aItem.mVisIEndEdge</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                   : -aItem.mVisIStartEdge,</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 -mBaseline);</span>
<span class="lineNum">     827 </span>            :   }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   m.PreTranslate(AppUnitsToGfxUnits(t, aContext));</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   return m;</span>
<span class="lineNum">     831 </span>            : }
<a name="832"><span class="lineNum">     832 </span>            : </a>
<span class="lineNum">     833 </span>            : gfxMatrix
<span class="lineNum">     834 </span><span class="lineNoCov">          0 : TextRenderedRun::GetTransformFromRunUserSpaceToUserSpace(</span>
<span class="lineNum">     835 </span>            :                                                   nsPresContext* aContext) const
<span class="lineNum">     836 </span>            : {
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   gfxMatrix m;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   if (!mFrame) {</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     return m;</span>
<span class="lineNum">     840 </span>            :   }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :   nscoord start, end;
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :   GetClipEdges(start, end);</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :   // Glyph position in user space.
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   m.PreTranslate(mPosition);</span>
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   // Rotation due to rotate=&quot;&quot; or a &lt;textPath&gt;.
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :   m.PreRotate(mRotate);</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :   // Scale due to textLength=&quot;&quot;.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   m.PreScale(mLengthAdjustScaleFactor, 1.0);</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   // Translation to get the text frame in the right place.
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   nsPoint t;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   if (IsVertical()) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     t = nsPoint(-mBaseline,</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                 IsRightToLeft()</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                   ? -mFrame-&gt;GetRect().height + start + end</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                   : 0);</span>
<span class="lineNum">     864 </span>            :   } else {
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     t = nsPoint(IsRightToLeft()</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                   ? -mFrame-&gt;GetRect().width + start + end</span>
<span class="lineNum">     867 </span>            :                   : 0,
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :                 -mBaseline);</span>
<span class="lineNum">     869 </span>            :   }
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   m.PreTranslate(AppUnitsToGfxUnits(t, aContext) *</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                    cssPxPerDevPx / mFontSizeScaleFactor);</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :   return m;</span>
<span class="lineNum">     874 </span>            : }
<a name="875"><span class="lineNum">     875 </span>            : </a>
<span class="lineNum">     876 </span>            : gfxMatrix
<span class="lineNum">     877 </span><span class="lineNoCov">          0 : TextRenderedRun::GetTransformFromRunUserSpaceToFrameUserSpace(</span>
<span class="lineNum">     878 </span>            :                                                   nsPresContext* aContext) const
<span class="lineNum">     879 </span>            : {
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :   gfxMatrix m;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   if (!mFrame) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     return m;</span>
<span class="lineNum">     883 </span>            :   }
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   nscoord start, end;
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   GetClipEdges(start, end);</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :   // Translate by the horizontal distance into the text frame this
<span class="lineNum">     889 </span>            :   // rendered run is.
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   gfxFloat appPerCssPx = aContext-&gt;AppUnitsPerCSSPixel();</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   gfxPoint t = IsVertical() ? gfxPoint(0, start / appPerCssPx)</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                             : gfxPoint(start / appPerCssPx, 0);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   return m.PreTranslate(t);</span>
<span class="lineNum">     894 </span>            : }
<a name="895"><span class="lineNum">     895 </span>            : </a>
<span class="lineNum">     896 </span>            : SVGBBox
<span class="lineNum">     897 </span><span class="lineNoCov">          0 : TextRenderedRun::GetRunUserSpaceRect(nsPresContext* aContext,</span>
<span class="lineNum">     898 </span>            :                                      uint32_t aFlags) const
<span class="lineNum">     899 </span>            : {
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   SVGBBox r;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   if (!mFrame) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">     903 </span>            :   }
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :   // Determine the amount of overflow above and below the frame's mRect.
<span class="lineNum">     906 </span>            :   //
<span class="lineNum">     907 </span>            :   // We need to call GetVisualOverflowRectRelativeToSelf because this includes
<span class="lineNum">     908 </span>            :   // overflowing decorations, which the MeasureText call below does not.  We
<span class="lineNum">     909 </span>            :   // assume here the decorations only overflow above and below the frame, never
<span class="lineNum">     910 </span>            :   // horizontally.
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   nsRect self = mFrame-&gt;GetVisualOverflowRectRelativeToSelf();</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   nsRect rect = mFrame-&gt;GetRect();</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   bool vertical = IsVertical();</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   nscoord above = vertical ? -self.x : -self.y;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   nscoord below = vertical ? self.XMost() - rect.width</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                            : self.YMost() - rect.height;</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   gfxTextRun* textRun = mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :   // Get the content range for this rendered run.
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   Range range = ConvertOriginalToSkipped(it, mTextFrameContentOffset,</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                                          mTextFrameContentLength);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   if (range.Length() == 0) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">     926 </span>            :   }
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :   // Measure that range.
<span class="lineNum">     929 </span>            :   gfxTextRun::Metrics metrics =
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     textRun-&gt;MeasureText(range, gfxFont::LOOSE_INK_EXTENTS, nullptr, nullptr);</span>
<span class="lineNum">     931 </span>            :   // Make sure it includes the font-box.
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   gfxRect fontBox(0, -metrics.mAscent,</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       metrics.mAdvanceWidth, metrics.mAscent + metrics.mDescent);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   metrics.mBoundingBox.UnionRect(metrics.mBoundingBox, fontBox);</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :   // Determine the rectangle that covers the rendered run's fill,
<span class="lineNum">     937 </span>            :   // taking into account the measured vertical overflow due to
<span class="lineNum">     938 </span>            :   // decorations.
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   nscoord baseline = metrics.mBoundingBox.y + metrics.mAscent;</span>
<span class="lineNum">     940 </span>            :   gfxFloat x, width;
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   if (aFlags &amp; eNoHorizontalOverflow) {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     x = 0.0;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     width = textRun-&gt;GetAdvanceWidth(range, nullptr);</span>
<span class="lineNum">     944 </span>            :   } else {
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     x = metrics.mBoundingBox.x;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     width = metrics.mBoundingBox.width;</span>
<span class="lineNum">     947 </span>            :   }
<span class="lineNum">     948 </span>            :   nsRect fillInAppUnits(x, baseline - above,
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :                         width, metrics.mBoundingBox.height + above + below);</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   if (textRun-&gt;IsVertical()) {</span>
<span class="lineNum">     951 </span>            :     // Swap line-relative textMetrics dimensions to physical coordinates.
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     Swap(fillInAppUnits.x, fillInAppUnits.y);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     Swap(fillInAppUnits.width, fillInAppUnits.height);</span>
<span class="lineNum">     954 </span>            :   }
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :   // Account for text-shadow.
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   if (aFlags &amp; eIncludeTextShadow) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     fillInAppUnits =</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       nsLayoutUtils::GetTextShadowRectsUnion(fillInAppUnits, mFrame);</span>
<span class="lineNum">     960 </span>            :   }
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   // Convert the app units rectangle to user units.
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   gfxRect fill = AppUnitsToFloatCSSPixels(gfxRect(fillInAppUnits.x,</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                                                   fillInAppUnits.y,</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                                                   fillInAppUnits.width,</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                                                   fillInAppUnits.height),</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                                           aContext);</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   // Scale the rectangle up due to any mFontSizeScaleFactor.  We scale
<span class="lineNum">     970 </span>            :   // it around the text's origin.
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   ScaleAround(fill,</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :               textRun-&gt;IsVertical()</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :                 ? gfxPoint(aContext-&gt;AppUnitsToFloatCSSPixels(baseline), 0.0)</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :                 : gfxPoint(0.0, aContext-&gt;AppUnitsToFloatCSSPixels(baseline)),</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :               1.0 / mFontSizeScaleFactor);</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   // Include the fill if requested.
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   if (aFlags &amp; eIncludeFill) {</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     r = fill;</span>
<span class="lineNum">     980 </span>            :   }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :   // Include the stroke if requested.
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   if ((aFlags &amp; eIncludeStroke) &amp;&amp;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       !fill.IsEmpty() &amp;&amp;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       nsSVGUtils::GetStrokeWidth(mFrame) &gt; 0) {</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     r.UnionEdges(nsSVGUtils::PathExtentsToMaxStrokeExtents(fill, mFrame,</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :                                                            gfxMatrix()));</span>
<span class="lineNum">     988 </span>            :   }
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   return r;</span>
<span class="lineNum">     991 </span>            : }
<a name="992"><span class="lineNum">     992 </span>            : </a>
<span class="lineNum">     993 </span>            : SVGBBox
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : TextRenderedRun::GetFrameUserSpaceRect(nsPresContext* aContext,</span>
<span class="lineNum">     995 </span>            :                                        uint32_t aFlags) const
<span class="lineNum">     996 </span>            : {
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   SVGBBox r = GetRunUserSpaceRect(aContext, aFlags);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   if (r.IsEmpty()) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">    1000 </span>            :   }
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   gfxMatrix m = GetTransformFromRunUserSpaceToFrameUserSpace(aContext);</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   return m.TransformBounds(r.ToThebesRect());</span>
<span class="lineNum">    1003 </span>            : }
<a name="1004"><span class="lineNum">    1004 </span>            : </a>
<span class="lineNum">    1005 </span>            : SVGBBox
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 : TextRenderedRun::GetUserSpaceRect(nsPresContext* aContext,</span>
<span class="lineNum">    1007 </span>            :                                   uint32_t aFlags,
<span class="lineNum">    1008 </span>            :                                   const gfxMatrix* aAdditionalTransform) const
<span class="lineNum">    1009 </span>            : {
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   SVGBBox r = GetRunUserSpaceRect(aContext, aFlags);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   if (r.IsEmpty()) {</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">    1013 </span>            :   }
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   gfxMatrix m = GetTransformFromRunUserSpaceToUserSpace(aContext);</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   if (aAdditionalTransform) {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     m *= *aAdditionalTransform;</span>
<span class="lineNum">    1017 </span>            :   }
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   return m.TransformBounds(r.ToThebesRect());</span>
<span class="lineNum">    1019 </span>            : }
<a name="1020"><span class="lineNum">    1020 </span>            : </a>
<span class="lineNum">    1021 </span>            : void
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 : TextRenderedRun::GetClipEdges(nscoord&amp; aVisIStartEdge,</span>
<span class="lineNum">    1023 </span>            :                               nscoord&amp; aVisIEndEdge) const
<span class="lineNum">    1024 </span>            : {
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :   uint32_t contentLength = mFrame-&gt;GetContentLength();</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   if (mTextFrameContentOffset == 0 &amp;&amp;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       mTextFrameContentLength == contentLength) {</span>
<span class="lineNum">    1028 </span>            :     // If the rendered run covers the entire content, we know we don't need
<span class="lineNum">    1029 </span>            :     // to clip without having to measure anything.
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     aVisIStartEdge = 0;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     aVisIEndEdge = 0;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1033 </span>            :   }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   gfxTextRun* textRun = mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :   // Get the covered content offset/length for this rendered run in skipped
<span class="lineNum">    1039 </span>            :   // characters, since that is what GetAdvanceWidth expects.
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   Range runRange = ConvertOriginalToSkipped(it, mTextFrameContentOffset,</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :                                             mTextFrameContentLength);</span>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :   // Get the offset/length of the whole nsTextFrame.
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   uint32_t frameOffset = mFrame-&gt;GetContentOffset();</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   uint32_t frameLength = mFrame-&gt;GetContentLength();</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            :   // Trim the whole-nsTextFrame offset/length to remove any leading/trailing
<span class="lineNum">    1048 </span>            :   // white space, as the nsTextFrame when painting does not include them when
<span class="lineNum">    1049 </span>            :   // interpreting clip edges.
<span class="lineNum">    1050 </span>            :   nsTextFrame::TrimmedOffsets trimmedOffsets =
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     mFrame-&gt;GetTrimmedOffsets(mFrame-&gt;GetContent()-&gt;GetText(), true);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   TrimOffsets(frameOffset, frameLength, trimmedOffsets);</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            :   // Convert the trimmed whole-nsTextFrame offset/length into skipped
<span class="lineNum">    1055 </span>            :   // characters.
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   Range frameRange = ConvertOriginalToSkipped(it, frameOffset, frameLength);</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :   // Measure the advance width in the text run between the start of
<span class="lineNum">    1059 </span>            :   // frame's content and the start of the rendered run's content,
<span class="lineNum">    1060 </span>            :   nscoord startEdge = textRun-&gt;
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     GetAdvanceWidth(Range(frameRange.start, runRange.start), nullptr);</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :   // and between the end of the rendered run's content and the end
<span class="lineNum">    1064 </span>            :   // of the frame's content.
<span class="lineNum">    1065 </span>            :   nscoord endEdge = textRun-&gt;
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     GetAdvanceWidth(Range(runRange.end, frameRange.end), nullptr);</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   if (textRun-&gt;IsRightToLeft()) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     aVisIStartEdge = endEdge;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     aVisIEndEdge = startEdge;</span>
<span class="lineNum">    1071 </span>            :   } else {
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     aVisIStartEdge = startEdge;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     aVisIEndEdge = endEdge;</span>
<span class="lineNum">    1074 </span>            :   }
<span class="lineNum">    1075 </span>            : }
<a name="1076"><span class="lineNum">    1076 </span>            : </a>
<span class="lineNum">    1077 </span>            : nscoord
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 : TextRenderedRun::GetAdvanceWidth() const</span>
<span class="lineNum">    1079 </span>            : {
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :   gfxTextRun* textRun = mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :   Range range = ConvertOriginalToSkipped(it, mTextFrameContentOffset,</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                                          mTextFrameContentLength);</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   return textRun-&gt;GetAdvanceWidth(range, nullptr);</span>
<span class="lineNum">    1087 </span>            : }
<a name="1088"><span class="lineNum">    1088 </span>            : </a>
<span class="lineNum">    1089 </span>            : int32_t
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 : TextRenderedRun::GetCharNumAtPosition(nsPresContext* aContext,</span>
<span class="lineNum">    1091 </span>            :                                       const gfxPoint&amp; aPoint) const
<span class="lineNum">    1092 </span>            : {
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   if (mTextFrameContentLength == 0) {</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1095 </span>            :   }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :   // Convert the point from user space into run user space, and take
<span class="lineNum">    1101 </span>            :   // into account any mFontSizeScaleFactor.
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   gfxMatrix m = GetTransformFromRunUserSpaceToUserSpace(aContext);</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (!m.Invert()) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1105 </span>            :   }
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   gfxPoint p = m.TransformPoint(aPoint) / cssPxPerDevPx * mFontSizeScaleFactor;</span>
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :   // First check that the point lies vertically between the top and bottom
<span class="lineNum">    1109 </span>            :   // edges of the text.
<span class="lineNum">    1110 </span>            :   gfxFloat ascent, descent;
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   GetAscentAndDescentInAppUnits(mFrame, ascent, descent);</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :   WritingMode writingMode = mFrame-&gt;GetWritingMode();</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :   if (writingMode.IsVertical()) {</span>
<span class="lineNum">    1115 </span>            :     gfxFloat leftEdge =
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       mFrame-&gt;GetLogicalBaseline(writingMode) -</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         (writingMode.IsVerticalRL() ? ascent : descent);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     gfxFloat rightEdge = leftEdge + ascent + descent;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     if (p.x &lt; aContext-&gt;AppUnitsToGfxUnits(leftEdge) ||</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         p.x &gt; aContext-&gt;AppUnitsToGfxUnits(rightEdge)) {</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    1122 </span>            :     }
<span class="lineNum">    1123 </span>            :   } else {
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     gfxFloat topEdge = mFrame-&gt;GetLogicalBaseline(writingMode) - ascent;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     gfxFloat bottomEdge = topEdge + ascent + descent;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     if (p.y &lt; aContext-&gt;AppUnitsToGfxUnits(topEdge) ||</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :         p.y &gt; aContext-&gt;AppUnitsToGfxUnits(bottomEdge)) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    1129 </span>            :     }
<span class="lineNum">    1130 </span>            :   }
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   gfxTextRun* textRun = mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :   // Next check that the point lies horizontally within the left and right
<span class="lineNum">    1136 </span>            :   // edges of the text.
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :   Range range = ConvertOriginalToSkipped(it, mTextFrameContentOffset,</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                                          mTextFrameContentLength);</span>
<span class="lineNum">    1139 </span>            :   gfxFloat runAdvance =
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     aContext-&gt;AppUnitsToGfxUnits(textRun-&gt;GetAdvanceWidth(range, nullptr));</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   gfxFloat pos = writingMode.IsVertical() ? p.y : p.x;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   if (pos &lt; 0 || pos &gt;= runAdvance) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1145 </span>            :   }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :   // Finally, measure progressively smaller portions of the rendered run to
<span class="lineNum">    1148 </span>            :   // find which glyph it lies within.  This will need to change once we
<span class="lineNum">    1149 </span>            :   // support letter-spacing and word-spacing.
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   bool rtl = textRun-&gt;IsRightToLeft();</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :   for (int32_t i = mTextFrameContentLength - 1; i &gt;= 0; i--) {</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     range = ConvertOriginalToSkipped(it, mTextFrameContentOffset, i);</span>
<span class="lineNum">    1153 </span>            :     gfxFloat advance =
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       aContext-&gt;AppUnitsToGfxUnits(textRun-&gt;GetAdvanceWidth(range, nullptr));</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     if ((rtl &amp;&amp; pos &lt; runAdvance - advance) ||</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         (!rtl &amp;&amp; pos &gt;= advance)) {</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       return i;</span>
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            :   }
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">    1161 </span>            : }
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : // ----------------------------------------------------------------------------
<span class="lineNum">    1164 </span>            : // TextNodeIterator
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : enum SubtreePosition
<span class="lineNum">    1167 </span>            : {
<span class="lineNum">    1168 </span>            :   eBeforeSubtree,
<span class="lineNum">    1169 </span>            :   eWithinSubtree,
<span class="lineNum">    1170 </span>            :   eAfterSubtree
<span class="lineNum">    1171 </span>            : };
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            : /**
<span class="lineNum">    1174 </span>            :  * An iterator class for nsTextNodes that are descendants of a given node, the
<span class="lineNum">    1175 </span>            :  * root.  Nodes are iterated in document order.  An optional subtree can be
<span class="lineNum">    1176 </span>            :  * specified, in which case the iterator will track whether the current state of
<span class="lineNum">    1177 </span>            :  * the traversal over the tree is within that subtree or is past that subtree.
<span class="lineNum">    1178 </span>            :  */
<span class="lineNum">    1179 </span>            : class TextNodeIterator
<span class="lineNum">    1180 </span>            : {
<span class="lineNum">    1181 </span>            : public:
<span class="lineNum">    1182 </span>            :   /**
<span class="lineNum">    1183 </span>            :    * Constructs a TextNodeIterator with the specified root node and optional
<a name="1184"><span class="lineNum">    1184 </span>            :    * subtree.</a>
<span class="lineNum">    1185 </span>            :    */
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   explicit TextNodeIterator(nsIContent* aRoot, nsIContent* aSubtree = nullptr)</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     : mRoot(aRoot),</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       mSubtree(aSubtree == aRoot ? nullptr : aSubtree),</span>
<span class="lineNum">    1189 </span>            :       mCurrent(aRoot),
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :       mSubtreePosition(mSubtree ? eBeforeSubtree : eWithinSubtree)</span>
<span class="lineNum">    1191 </span>            :   {
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     NS_ASSERTION(aRoot, &quot;expected non-null root&quot;);</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     if (!aRoot-&gt;IsNodeOfType(nsINode::eTEXT)) {</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :       Next();</span>
<span class="lineNum">    1195 </span>            :     }
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :   /**
<a name="1199"><span class="lineNum">    1199 </span>            :    * Returns the current nsTextNode, or null if the iterator has finished.</a>
<span class="lineNum">    1200 </span>            :    */
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   nsTextNode* Current() const</span>
<span class="lineNum">    1202 </span>            :   {
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     return static_cast&lt;nsTextNode*&gt;(mCurrent);</span>
<span class="lineNum">    1204 </span>            :   }
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   /**
<span class="lineNum">    1207 </span>            :    * Advances to the next nsTextNode and returns it, or null if the end of
<span class="lineNum">    1208 </span>            :    * iteration has been reached.
<span class="lineNum">    1209 </span>            :    */
<span class="lineNum">    1210 </span>            :   nsTextNode* Next();
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :   /**
<span class="lineNum">    1213 </span>            :    * Returns whether the iterator is currently within the subtree rooted
<span class="lineNum">    1214 </span>            :    * at mSubtree.  Returns true if we are not tracking a subtree (we consider
<span class="lineNum">    1215 </span>            :    * that we're always within the subtree).
<span class="lineNum">    1216 </span>            :    */
<span class="lineNum">    1217 </span>            :   bool IsWithinSubtree() const
<span class="lineNum">    1218 </span>            :   {
<span class="lineNum">    1219 </span>            :     return mSubtreePosition == eWithinSubtree;
<span class="lineNum">    1220 </span>            :   }
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :   /**
<span class="lineNum">    1223 </span>            :    * Returns whether the iterator is past the subtree rooted at mSubtree.
<span class="lineNum">    1224 </span>            :    * Returns false if we are not tracking a subtree.
<span class="lineNum">    1225 </span>            :    */
<span class="lineNum">    1226 </span>            :   bool IsAfterSubtree() const
<span class="lineNum">    1227 </span>            :   {
<span class="lineNum">    1228 </span>            :     return mSubtreePosition == eAfterSubtree;
<span class="lineNum">    1229 </span>            :   }
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            : private:
<span class="lineNum">    1232 </span>            :   /**
<span class="lineNum">    1233 </span>            :    * The root under which all nsTextNodes will be iterated over.
<span class="lineNum">    1234 </span>            :    */
<span class="lineNum">    1235 </span>            :   nsIContent* mRoot;
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            :   /**
<span class="lineNum">    1238 </span>            :    * The node rooting the subtree to track.
<span class="lineNum">    1239 </span>            :    */
<span class="lineNum">    1240 </span>            :   nsIContent* mSubtree;
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            :   /**
<span class="lineNum">    1243 </span>            :    * The current node during iteration.
<span class="lineNum">    1244 </span>            :    */
<span class="lineNum">    1245 </span>            :   nsIContent* mCurrent;
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            :   /**
<span class="lineNum">    1248 </span>            :    * The current iterator position relative to mSubtree.
<span class="lineNum">    1249 </span>            :    */
<span class="lineNum">    1250 </span>            :   SubtreePosition mSubtreePosition;
<span class="lineNum">    1251 </span>            : };
<a name="1252"><span class="lineNum">    1252 </span>            : </a>
<span class="lineNum">    1253 </span>            : nsTextNode*
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 : TextNodeIterator::Next()</span>
<span class="lineNum">    1255 </span>            : {
<span class="lineNum">    1256 </span>            :   // Starting from mCurrent, we do a non-recursive traversal to the next
<span class="lineNum">    1257 </span>            :   // nsTextNode beneath mRoot, updating mSubtreePosition appropriately if we
<span class="lineNum">    1258 </span>            :   // encounter mSubtree.
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   if (mCurrent) {</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :       nsIContent* next = IsTextContentElement(mCurrent) ?</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :                            mCurrent-&gt;GetFirstChild() :</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                            nullptr;</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :       if (next) {</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :         mCurrent = next;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :         if (mCurrent == mSubtree) {</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :           mSubtreePosition = eWithinSubtree;</span>
<span class="lineNum">    1268 </span>            :         }
<span class="lineNum">    1269 </span>            :       } else {
<span class="lineNum">    1270 </span>            :         for (;;) {
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :           if (mCurrent == mRoot) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             mCurrent = nullptr;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1274 </span>            :           }
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :           if (mCurrent == mSubtree) {</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :             mSubtreePosition = eAfterSubtree;</span>
<span class="lineNum">    1277 </span>            :           }
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :           next = mCurrent-&gt;GetNextSibling();</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :           if (next) {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :             mCurrent = next;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :             if (mCurrent == mSubtree) {</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :               mSubtreePosition = eWithinSubtree;</span>
<span class="lineNum">    1283 </span>            :             }
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1285 </span>            :           }
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :           if (mCurrent == mSubtree) {</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :             mSubtreePosition = eAfterSubtree;</span>
<span class="lineNum">    1288 </span>            :           }
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :           mCurrent = mCurrent-&gt;GetParent();</span>
<span class="lineNum">    1290 </span>            :         }
<span class="lineNum">    1291 </span>            :       }
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     } while (mCurrent &amp;&amp; !mCurrent-&gt;IsNodeOfType(nsINode::eTEXT));</span>
<span class="lineNum">    1293 </span>            :   }
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   return static_cast&lt;nsTextNode*&gt;(mCurrent);</span>
<span class="lineNum">    1296 </span>            : }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : // ----------------------------------------------------------------------------
<span class="lineNum">    1299 </span>            : // TextNodeCorrespondenceRecorder
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : /**
<span class="lineNum">    1302 </span>            :  * TextNodeCorrespondence is used as the value of a frame property that
<span class="lineNum">    1303 </span>            :  * is stored on all its descendant nsTextFrames.  It stores the number of DOM
<span class="lineNum">    1304 </span>            :  * characters between it and the previous nsTextFrame that did not have an
<span class="lineNum">    1305 </span>            :  * nsTextFrame created for them, due to either not being in a correctly
<span class="lineNum">    1306 </span>            :  * parented text content element, or because they were display:none.
<span class="lineNum">    1307 </span>            :  * These are called &quot;undisplayed characters&quot;.
<span class="lineNum">    1308 </span>            :  *
<span class="lineNum">    1309 </span>            :  * See also TextNodeCorrespondenceRecorder below, which is what sets the
<span class="lineNum">    1310 </span>            :  * frame property.
<span class="lineNum">    1311 </span>            :  */
<a name="1312"><span class="lineNum">    1312 </span>            : struct TextNodeCorrespondence</a>
<span class="lineNum">    1313 </span>            : {
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :   explicit TextNodeCorrespondence(uint32_t aUndisplayedCharacters)</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     : mUndisplayedCharacters(aUndisplayedCharacters)</span>
<span class="lineNum">    1316 </span>            :   {
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :   uint32_t mUndisplayedCharacters;
<a name="1320"><span class="lineNum">    1320 </span>            : };</a>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 : NS_DECLARE_FRAME_PROPERTY_DELETABLE(TextNodeCorrespondenceProperty,</span>
<span class="lineNum">    1323 </span>            :                                     TextNodeCorrespondence)
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : /**
<span class="lineNum">    1326 </span>            :  * Returns the number of undisplayed characters before the specified
<span class="lineNum">    1327 </span>            :  * nsTextFrame.
<a name="1328"><span class="lineNum">    1328 </span>            :  */</a>
<span class="lineNum">    1329 </span>            : static uint32_t
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 : GetUndisplayedCharactersBeforeFrame(nsTextFrame* aFrame)</span>
<span class="lineNum">    1331 </span>            : {
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   void* value = aFrame-&gt;GetProperty(TextNodeCorrespondenceProperty());</span>
<span class="lineNum">    1333 </span>            :   TextNodeCorrespondence* correspondence =
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     static_cast&lt;TextNodeCorrespondence*&gt;(value);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   if (!correspondence) {</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     NS_NOTREACHED(&quot;expected a TextNodeCorrespondenceProperty on nsTextFrame &quot;</span>
<span class="lineNum">    1337 </span>            :                   &quot;used for SVG text&quot;);
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1339 </span>            :   }
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :   return correspondence-&gt;mUndisplayedCharacters;</span>
<span class="lineNum">    1341 </span>            : }
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            : /**
<span class="lineNum">    1344 </span>            :  * Traverses the nsTextFrames for an SVGTextFrame and records a
<span class="lineNum">    1345 </span>            :  * TextNodeCorrespondenceProperty on each for the number of undisplayed DOM
<span class="lineNum">    1346 </span>            :  * characters between each frame.  This is done by iterating simultaneously
<span class="lineNum">    1347 </span>            :  * over the nsTextNodes and nsTextFrames and noting when nsTextNodes (or
<span class="lineNum">    1348 </span>            :  * parts of them) are skipped when finding the next nsTextFrame.
<span class="lineNum">    1349 </span>            :  */
<span class="lineNum">    1350 </span>            : class TextNodeCorrespondenceRecorder
<span class="lineNum">    1351 </span>            : {
<span class="lineNum">    1352 </span>            : public:
<span class="lineNum">    1353 </span>            :   /**
<span class="lineNum">    1354 </span>            :    * Entry point for the TextNodeCorrespondenceProperty recording.
<span class="lineNum">    1355 </span>            :    */
<span class="lineNum">    1356 </span>            :   static void RecordCorrespondence(SVGTextFrame* aRoot);
<a name="1357"><span class="lineNum">    1357 </span>            : </a>
<span class="lineNum">    1358 </span>            : private:
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :   explicit TextNodeCorrespondenceRecorder(SVGTextFrame* aRoot)</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :     : mNodeIterator(aRoot-&gt;GetContent()),</span>
<span class="lineNum">    1361 </span>            :       mPreviousNode(nullptr),
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       mNodeCharIndex(0)</span>
<span class="lineNum">    1363 </span>            :   {
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :   void Record(SVGTextFrame* aRoot);
<span class="lineNum">    1367 </span>            :   void TraverseAndRecord(nsIFrame* aFrame);
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            :   /**
<span class="lineNum">    1370 </span>            :    * Returns the next non-empty nsTextNode.
<span class="lineNum">    1371 </span>            :    */
<span class="lineNum">    1372 </span>            :   nsTextNode* NextNode();
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   /**
<span class="lineNum">    1375 </span>            :    * The iterator over the nsTextNodes that we use as we simultaneously
<span class="lineNum">    1376 </span>            :    * iterate over the nsTextFrames.
<span class="lineNum">    1377 </span>            :    */
<span class="lineNum">    1378 </span>            :   TextNodeIterator mNodeIterator;
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            :   /**
<span class="lineNum">    1381 </span>            :    * The previous nsTextNode we iterated over.
<span class="lineNum">    1382 </span>            :    */
<span class="lineNum">    1383 </span>            :   nsTextNode* mPreviousNode;
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :   /**
<span class="lineNum">    1386 </span>            :    * The index into the current nsTextNode's character content.
<span class="lineNum">    1387 </span>            :    */
<span class="lineNum">    1388 </span>            :   uint32_t mNodeCharIndex;
<span class="lineNum">    1389 </span>            : };
<a name="1390"><span class="lineNum">    1390 </span>            : </a>
<span class="lineNum">    1391 </span>            : /* static */ void
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 : TextNodeCorrespondenceRecorder::RecordCorrespondence(SVGTextFrame* aRoot)</span>
<span class="lineNum">    1393 </span>            : {
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   TextNodeCorrespondenceRecorder recorder(aRoot);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   recorder.Record(aRoot);</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 : }</span>
<a name="1397"><span class="lineNum">    1397 </span>            : </a>
<span class="lineNum">    1398 </span>            : void
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 : TextNodeCorrespondenceRecorder::Record(SVGTextFrame* aRoot)</span>
<span class="lineNum">    1400 </span>            : {
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   if (!mNodeIterator.Current()) {</span>
<span class="lineNum">    1402 </span>            :     // If there are no nsTextNodes then there is nothing to do.
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1404 </span>            :   }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :   // Traverse over all the nsTextFrames and record the number of undisplayed
<span class="lineNum">    1407 </span>            :   // characters.
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   TraverseAndRecord(aRoot);</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :   // Find how many undisplayed characters there are after the final nsTextFrame.
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   uint32_t undisplayed = 0;</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :   if (mNodeIterator.Current()) {</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     if (mPreviousNode &amp;&amp; mPreviousNode-&gt;TextLength() != mNodeCharIndex) {</span>
<span class="lineNum">    1414 </span>            :       // The last nsTextFrame ended part way through an nsTextNode.  The
<span class="lineNum">    1415 </span>            :       // remaining characters count as undisplayed.
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :       NS_ASSERTION(mNodeCharIndex &lt; mPreviousNode-&gt;TextLength(),</span>
<span class="lineNum">    1417 </span>            :                    &quot;incorrect tracking of undisplayed characters in &quot;
<span class="lineNum">    1418 </span>            :                    &quot;text nodes&quot;);
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       undisplayed += mPreviousNode-&gt;TextLength() - mNodeCharIndex;</span>
<span class="lineNum">    1420 </span>            :     }
<span class="lineNum">    1421 </span>            :     // All the remaining nsTextNodes that we iterate must also be undisplayed.
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     for (nsTextNode* textNode = mNodeIterator.Current();</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :          textNode;</span>
<span class="lineNum">    1424 </span>            :          textNode = NextNode()) {
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :       undisplayed += textNode-&gt;TextLength();</span>
<span class="lineNum">    1426 </span>            :     }
<span class="lineNum">    1427 </span>            :   }
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span>            :   // Record the trailing number of undisplayed characters on the
<span class="lineNum">    1430 </span>            :   // SVGTextFrame.
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   aRoot-&gt;mTrailingUndisplayedCharacters = undisplayed;</span>
<span class="lineNum">    1432 </span>            : }
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<span class="lineNum">    1434 </span>            : nsTextNode*
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 : TextNodeCorrespondenceRecorder::NextNode()</span>
<span class="lineNum">    1436 </span>            : {
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   mPreviousNode = mNodeIterator.Current();</span>
<span class="lineNum">    1438 </span>            :   nsTextNode* next;
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :     next = mNodeIterator.Next();</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   } while (next &amp;&amp; next-&gt;TextLength() == 0);</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   return next;</span>
<span class="lineNum">    1443 </span>            : }
<a name="1444"><span class="lineNum">    1444 </span>            : </a>
<span class="lineNum">    1445 </span>            : void
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 : TextNodeCorrespondenceRecorder::TraverseAndRecord(nsIFrame* aFrame)</span>
<span class="lineNum">    1447 </span>            : {
<span class="lineNum">    1448 </span>            :   // Recursively iterate over the frame tree, for frames that correspond
<span class="lineNum">    1449 </span>            :   // to text content elements.
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :   if (IsTextContentElement(aFrame-&gt;GetContent())) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     for (nsIFrame* f : aFrame-&gt;PrincipalChildList()) {</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :       TraverseAndRecord(f);</span>
<span class="lineNum">    1453 </span>            :     }
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1455 </span>            :   }
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            :   nsTextFrame* frame;  // The current text frame.
<span class="lineNum">    1458 </span>            :   nsTextNode* node;    // The text node for the current text frame.
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   if (!GetNonEmptyTextFrameAndNode(aFrame, frame, node)) {</span>
<span class="lineNum">    1460 </span>            :     // If this isn't an nsTextFrame, or is empty, nothing to do.
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1462 </span>            :   }
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   NS_ASSERTION(frame-&gt;GetContentOffset() &gt;= 0,</span>
<span class="lineNum">    1465 </span>            :                &quot;don't know how to handle negative content indexes&quot;);
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   uint32_t undisplayed = 0;</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :   if (!mPreviousNode) {</span>
<span class="lineNum">    1469 </span>            :     // Must be the very first text frame.
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     NS_ASSERTION(mNodeCharIndex == 0, &quot;incorrect tracking of undisplayed &quot;</span>
<span class="lineNum">    1471 </span>            :                                       &quot;characters in text nodes&quot;);
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     if (!mNodeIterator.Current()) {</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :       NS_NOTREACHED(&quot;incorrect tracking of correspondence between text frames &quot;</span>
<span class="lineNum">    1474 </span>            :                     &quot;and text nodes&quot;);
<span class="lineNum">    1475 </span>            :     } else {
<span class="lineNum">    1476 </span>            :       // Each whole nsTextNode we find before we get to the text node for the
<span class="lineNum">    1477 </span>            :       // first text frame must be undisplayed.
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :       while (mNodeIterator.Current() != node) {</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :         undisplayed += mNodeIterator.Current()-&gt;TextLength();</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         NextNode();</span>
<span class="lineNum">    1481 </span>            :       }
<span class="lineNum">    1482 </span>            :       // If the first text frame starts at a non-zero content offset, then those
<span class="lineNum">    1483 </span>            :       // earlier characters are also undisplayed.
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :       undisplayed += frame-&gt;GetContentOffset();</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       NextNode();</span>
<span class="lineNum">    1486 </span>            :     }
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :   } else if (mPreviousNode == node) {</span>
<span class="lineNum">    1488 </span>            :     // Same text node as last time.
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     if (static_cast&lt;uint32_t&gt;(frame-&gt;GetContentOffset()) != mNodeCharIndex) {</span>
<span class="lineNum">    1490 </span>            :       // We have some characters in the middle of the text node
<span class="lineNum">    1491 </span>            :       // that are undisplayed.
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :       NS_ASSERTION(mNodeCharIndex &lt;</span>
<span class="lineNum">    1493 </span>            :                      static_cast&lt;uint32_t&gt;(frame-&gt;GetContentOffset()),
<span class="lineNum">    1494 </span>            :                    &quot;incorrect tracking of undisplayed characters in &quot;
<span class="lineNum">    1495 </span>            :                    &quot;text nodes&quot;);
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :       undisplayed = frame-&gt;GetContentOffset() - mNodeCharIndex;</span>
<span class="lineNum">    1497 </span>            :     }
<span class="lineNum">    1498 </span>            :   } else {
<span class="lineNum">    1499 </span>            :     // Different text node from last time.
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :     if (mPreviousNode-&gt;TextLength() != mNodeCharIndex) {</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :       NS_ASSERTION(mNodeCharIndex &lt; mPreviousNode-&gt;TextLength(),</span>
<span class="lineNum">    1502 </span>            :                    &quot;incorrect tracking of undisplayed characters in &quot;
<span class="lineNum">    1503 </span>            :                    &quot;text nodes&quot;);
<span class="lineNum">    1504 </span>            :       // Any trailing characters at the end of the previous nsTextNode are
<span class="lineNum">    1505 </span>            :       // undisplayed.
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :       undisplayed = mPreviousNode-&gt;TextLength() - mNodeCharIndex;</span>
<span class="lineNum">    1507 </span>            :     }
<span class="lineNum">    1508 </span>            :     // Each whole nsTextNode we find before we get to the text node for
<span class="lineNum">    1509 </span>            :     // the current text frame must be undisplayed.
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     while (mNodeIterator.Current() != node) {</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :       undisplayed += mNodeIterator.Current()-&gt;TextLength();</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :       NextNode();</span>
<span class="lineNum">    1513 </span>            :     }
<span class="lineNum">    1514 </span>            :     // If the current text frame starts at a non-zero content offset, then those
<span class="lineNum">    1515 </span>            :     // earlier characters are also undisplayed.
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     undisplayed += frame-&gt;GetContentOffset();</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     NextNode();</span>
<span class="lineNum">    1518 </span>            :   }
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span>            :   // Set the frame property.
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :   frame-&gt;SetProperty(TextNodeCorrespondenceProperty(),</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :                      new TextNodeCorrespondence(undisplayed));</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            :   // Remember how far into the current nsTextNode we are.
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   mNodeCharIndex = frame-&gt;GetContentEnd();</span>
<span class="lineNum">    1526 </span>            : }
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            : // ----------------------------------------------------------------------------
<span class="lineNum">    1529 </span>            : // TextFrameIterator
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            : /**
<span class="lineNum">    1532 </span>            :  * An iterator class for nsTextFrames that are descendants of an
<span class="lineNum">    1533 </span>            :  * SVGTextFrame.  The iterator can optionally track whether the
<span class="lineNum">    1534 </span>            :  * current nsTextFrame is for a descendant of, or past, a given subtree
<span class="lineNum">    1535 </span>            :  * content node or frame.  (This functionality is used for example by the SVG
<span class="lineNum">    1536 </span>            :  * DOM text methods to get only the nsTextFrames for a particular &lt;tspan&gt;.)
<span class="lineNum">    1537 </span>            :  *
<span class="lineNum">    1538 </span>            :  * TextFrameIterator also tracks and exposes other information about the
<span class="lineNum">    1539 </span>            :  * current nsTextFrame:
<span class="lineNum">    1540 </span>            :  *
<span class="lineNum">    1541 </span>            :  *   * how many undisplayed characters came just before it
<span class="lineNum">    1542 </span>            :  *   * its position (in app units) relative to the SVGTextFrame's anonymous
<span class="lineNum">    1543 </span>            :  *     block frame
<span class="lineNum">    1544 </span>            :  *   * what nsInlineFrame corresponding to a &lt;textPath&gt; element it is a
<span class="lineNum">    1545 </span>            :  *     descendant of
<span class="lineNum">    1546 </span>            :  *   * what computed dominant-baseline value applies to it
<span class="lineNum">    1547 </span>            :  *
<span class="lineNum">    1548 </span>            :  * Note that any text frames that are empty -- whose ContentLength() is 0 --
<a name="1549"><span class="lineNum">    1549 </span>            :  * will be skipped over.</a>
<span class="lineNum">    1550 </span>            :  */
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 : class TextFrameIterator</span>
<span class="lineNum">    1552 </span>            : {
<span class="lineNum">    1553 </span>            : public:
<span class="lineNum">    1554 </span>            :   /**
<span class="lineNum">    1555 </span>            :    * Constructs a TextFrameIterator for the specified SVGTextFrame
<a name="1556"><span class="lineNum">    1556 </span>            :    * with an optional frame subtree to restrict iterated text frames to.</a>
<span class="lineNum">    1557 </span>            :    */
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   explicit TextFrameIterator(SVGTextFrame* aRoot, nsIFrame* aSubtree = nullptr)</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     : mRootFrame(aRoot),</span>
<span class="lineNum">    1560 </span>            :       mSubtree(aSubtree),
<span class="lineNum">    1561 </span>            :       mCurrentFrame(aRoot),
<span class="lineNum">    1562 </span>            :       mCurrentPosition(),
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :       mSubtreePosition(mSubtree ? eBeforeSubtree : eWithinSubtree)</span>
<span class="lineNum">    1564 </span>            :   {
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            :   /**
<span class="lineNum">    1569 </span>            :    * Constructs a TextFrameIterator for the specified SVGTextFrame
<a name="1570"><span class="lineNum">    1570 </span>            :    * with an optional frame content subtree to restrict iterated text frames to.</a>
<span class="lineNum">    1571 </span>            :    */
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   TextFrameIterator(SVGTextFrame* aRoot, nsIContent* aSubtree)</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     : mRootFrame(aRoot),</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :       mSubtree(aRoot &amp;&amp; aSubtree &amp;&amp; aSubtree != aRoot-&gt;GetContent() ?</span>
<span class="lineNum">    1575 </span>            :                  aSubtree-&gt;GetPrimaryFrame() :
<span class="lineNum">    1576 </span>            :                  nullptr),
<span class="lineNum">    1577 </span>            :       mCurrentFrame(aRoot),
<span class="lineNum">    1578 </span>            :       mCurrentPosition(),
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :       mSubtreePosition(mSubtree ? eBeforeSubtree : eWithinSubtree)</span>
<span class="lineNum">    1580 </span>            :   {
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            :   /**
<a name="1585"><span class="lineNum">    1585 </span>            :    * Returns the root SVGTextFrame this TextFrameIterator is iterating over.</a>
<span class="lineNum">    1586 </span>            :    */
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   SVGTextFrame* Root() const</span>
<span class="lineNum">    1588 </span>            :   {
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :     return mRootFrame;</span>
<span class="lineNum">    1590 </span>            :   }
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            :   /**
<a name="1593"><span class="lineNum">    1593 </span>            :    * Returns the current nsTextFrame.</a>
<span class="lineNum">    1594 </span>            :    */
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :   nsTextFrame* Current() const</span>
<span class="lineNum">    1596 </span>            :   {
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     return do_QueryFrame(mCurrentFrame);</span>
<span class="lineNum">    1598 </span>            :   }
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :   /**
<span class="lineNum">    1601 </span>            :    * Returns the number of undisplayed characters in the DOM just before the
<span class="lineNum">    1602 </span>            :    * current frame.
<span class="lineNum">    1603 </span>            :    */
<span class="lineNum">    1604 </span>            :   uint32_t UndisplayedCharacters() const;
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :   /**
<span class="lineNum">    1607 </span>            :    * Returns the current frame's position, in app units, relative to the
<a name="1608"><span class="lineNum">    1608 </span>            :    * root SVGTextFrame's anonymous block frame.</a>
<span class="lineNum">    1609 </span>            :    */
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   nsPoint Position() const</span>
<span class="lineNum">    1611 </span>            :   {
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     return mCurrentPosition;</span>
<span class="lineNum">    1613 </span>            :   }
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            :   /**
<span class="lineNum">    1616 </span>            :    * Advances to the next nsTextFrame and returns it.
<span class="lineNum">    1617 </span>            :    */
<span class="lineNum">    1618 </span>            :   nsTextFrame* Next();
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            :   /**
<a name="1621"><span class="lineNum">    1621 </span>            :    * Returns whether the iterator is within the subtree.</a>
<span class="lineNum">    1622 </span>            :    */
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :   bool IsWithinSubtree() const</span>
<span class="lineNum">    1624 </span>            :   {
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     return mSubtreePosition == eWithinSubtree;</span>
<span class="lineNum">    1626 </span>            :   }
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            :   /**
<a name="1629"><span class="lineNum">    1629 </span>            :    * Returns whether the iterator is past the subtree.</a>
<span class="lineNum">    1630 </span>            :    */
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :   bool IsAfterSubtree() const</span>
<span class="lineNum">    1632 </span>            :   {
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :     return mSubtreePosition == eAfterSubtree;</span>
<span class="lineNum">    1634 </span>            :   }
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            :   /**
<span class="lineNum">    1637 </span>            :    * Returns the frame corresponding to the &lt;textPath&gt; element, if we
<a name="1638"><span class="lineNum">    1638 </span>            :    * are inside one.</a>
<span class="lineNum">    1639 </span>            :    */
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   nsIFrame* TextPathFrame() const</span>
<span class="lineNum">    1641 </span>            :   {
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     return mTextPathFrames.IsEmpty() ?</span>
<span class="lineNum">    1643 </span>            :              nullptr :
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :              mTextPathFrames.ElementAt(mTextPathFrames.Length() - 1);</span>
<span class="lineNum">    1645 </span>            :   }
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            :   /**
<a name="1648"><span class="lineNum">    1648 </span>            :    * Returns the current frame's computed dominant-baseline value.</a>
<span class="lineNum">    1649 </span>            :    */
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   uint8_t DominantBaseline() const</span>
<span class="lineNum">    1651 </span>            :   {
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :     return mBaselines.ElementAt(mBaselines.Length() - 1);</span>
<span class="lineNum">    1653 </span>            :   }
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            :   /**
<a name="1656"><span class="lineNum">    1656 </span>            :    * Finishes the iterator.</a>
<span class="lineNum">    1657 </span>            :    */
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   void Close()</span>
<span class="lineNum">    1659 </span>            :   {
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :     mCurrentFrame = nullptr;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span>            : private:
<span class="lineNum">    1664 </span>            :   /**
<a name="1665"><span class="lineNum">    1665 </span>            :    * Initializes the iterator and advances to the first item.</a>
<span class="lineNum">    1666 </span>            :    */
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :   void Init()</span>
<span class="lineNum">    1668 </span>            :   {
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     if (!mRootFrame) {</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :     mBaselines.AppendElement(mRootFrame-&gt;StyleSVGReset()-&gt;mDominantBaseline);</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :     Next();</span>
<span class="lineNum">    1675 </span>            :   }
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            :   /**
<span class="lineNum">    1678 </span>            :    * Pushes the specified frame's computed dominant-baseline value.
<span class="lineNum">    1679 </span>            :    * If the value of the property is &quot;auto&quot;, then the parent frame's
<span class="lineNum">    1680 </span>            :    * computed value is used.
<span class="lineNum">    1681 </span>            :    */
<span class="lineNum">    1682 </span>            :   void PushBaseline(nsIFrame* aNextFrame);
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :   /**
<span class="lineNum">    1685 </span>            :    * Pops the current dominant-baseline off the stack.
<span class="lineNum">    1686 </span>            :    */
<span class="lineNum">    1687 </span>            :   void PopBaseline();
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            :   /**
<span class="lineNum">    1690 </span>            :    * The root frame we are iterating through.
<span class="lineNum">    1691 </span>            :    */
<span class="lineNum">    1692 </span>            :   SVGTextFrame* mRootFrame;
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span>            :   /**
<span class="lineNum">    1695 </span>            :    * The frame for the subtree we are also interested in tracking.
<span class="lineNum">    1696 </span>            :    */
<span class="lineNum">    1697 </span>            :   nsIFrame* mSubtree;
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            :   /**
<span class="lineNum">    1700 </span>            :    * The current value of the iterator.
<span class="lineNum">    1701 </span>            :    */
<span class="lineNum">    1702 </span>            :   nsIFrame* mCurrentFrame;
<span class="lineNum">    1703 </span>            : 
<span class="lineNum">    1704 </span>            :   /**
<span class="lineNum">    1705 </span>            :    * The position, in app units, of the current frame relative to mRootFrame.
<span class="lineNum">    1706 </span>            :    */
<span class="lineNum">    1707 </span>            :   nsPoint mCurrentPosition;
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span>            :   /**
<span class="lineNum">    1710 </span>            :    * Stack of frames corresponding to &lt;textPath&gt; elements that are in scope
<span class="lineNum">    1711 </span>            :    * for the current frame.
<span class="lineNum">    1712 </span>            :    */
<span class="lineNum">    1713 </span>            :   AutoTArray&lt;nsIFrame*, 1&gt; mTextPathFrames;
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :   /**
<span class="lineNum">    1716 </span>            :    * Stack of dominant-baseline values to record as we traverse through the
<span class="lineNum">    1717 </span>            :    * frame tree.
<span class="lineNum">    1718 </span>            :    */
<span class="lineNum">    1719 </span>            :   AutoTArray&lt;uint8_t, 8&gt; mBaselines;
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :   /**
<span class="lineNum">    1722 </span>            :    * The iterator's current position relative to mSubtree.
<span class="lineNum">    1723 </span>            :    */
<span class="lineNum">    1724 </span>            :   SubtreePosition mSubtreePosition;
<span class="lineNum">    1725 </span>            : };
<a name="1726"><span class="lineNum">    1726 </span>            : </a>
<span class="lineNum">    1727 </span>            : uint32_t
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 : TextFrameIterator::UndisplayedCharacters() const</span>
<span class="lineNum">    1729 </span>            : {
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!(mRootFrame-&gt;PrincipalChildList().FirstChild() &amp;&amp;</span>
<span class="lineNum">    1731 </span>            :                NS_SUBTREE_DIRTY(mRootFrame-&gt;PrincipalChildList().FirstChild())),
<span class="lineNum">    1732 </span>            :              &quot;should have already reflowed the anonymous block child&quot;);
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :   if (!mCurrentFrame) {</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     return mRootFrame-&gt;mTrailingUndisplayedCharacters;</span>
<span class="lineNum">    1736 </span>            :   }
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   nsTextFrame* frame = do_QueryFrame(mCurrentFrame);</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :   return GetUndisplayedCharactersBeforeFrame(frame);</span>
<span class="lineNum">    1740 </span>            : }
<a name="1741"><span class="lineNum">    1741 </span>            : </a>
<span class="lineNum">    1742 </span>            : nsTextFrame*
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 : TextFrameIterator::Next()</span>
<span class="lineNum">    1744 </span>            : {
<span class="lineNum">    1745 </span>            :   // Starting from mCurrentFrame, we do a non-recursive traversal to the next
<span class="lineNum">    1746 </span>            :   // nsTextFrame beneath mRoot, updating mSubtreePosition appropriately if we
<span class="lineNum">    1747 </span>            :   // encounter mSubtree.
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :   if (mCurrentFrame) {</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :       nsIFrame* next = IsTextContentElement(mCurrentFrame-&gt;GetContent()) ?</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                          mCurrentFrame-&gt;PrincipalChildList().FirstChild() :</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                          nullptr;</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :       if (next) {</span>
<span class="lineNum">    1754 </span>            :         // Descend into this frame, and accumulate its position.
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :         mCurrentPosition += next-&gt;GetPosition();</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :         if (next-&gt;GetContent()-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    1757 </span>            :           // Record this &lt;textPath&gt; frame.
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :           mTextPathFrames.AppendElement(next);</span>
<span class="lineNum">    1759 </span>            :         }
<span class="lineNum">    1760 </span>            :         // Record the frame's baseline.
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :         PushBaseline(next);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :         mCurrentFrame = next;</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         if (mCurrentFrame == mSubtree) {</span>
<span class="lineNum">    1764 </span>            :           // If the current frame is mSubtree, we have now moved into it.
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :           mSubtreePosition = eWithinSubtree;</span>
<span class="lineNum">    1766 </span>            :         }
<span class="lineNum">    1767 </span>            :       } else {
<span class="lineNum">    1768 </span>            :         for (;;) {
<span class="lineNum">    1769 </span>            :           // We want to move past the current frame.
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :           if (mCurrentFrame == mRootFrame) {</span>
<span class="lineNum">    1771 </span>            :             // If we've reached the root frame, we're finished.
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :             mCurrentFrame = nullptr;</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1774 </span>            :           }
<span class="lineNum">    1775 </span>            :           // Remove the current frame's position.
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :           mCurrentPosition -= mCurrentFrame-&gt;GetPosition();</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :           if (mCurrentFrame-&gt;GetContent()-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    1778 </span>            :             // Pop off the &lt;textPath&gt; frame if this is a &lt;textPath&gt;.
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :             mTextPathFrames.TruncateLength(mTextPathFrames.Length() - 1);</span>
<span class="lineNum">    1780 </span>            :           }
<span class="lineNum">    1781 </span>            :           // Pop off the current baseline.
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :           PopBaseline();</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :           if (mCurrentFrame == mSubtree) {</span>
<span class="lineNum">    1784 </span>            :             // If this was mSubtree, we have now moved past it.
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :             mSubtreePosition = eAfterSubtree;</span>
<span class="lineNum">    1786 </span>            :           }
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :           next = mCurrentFrame-&gt;GetNextSibling();</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :           if (next) {</span>
<span class="lineNum">    1789 </span>            :             // Moving to the next sibling.
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :             mCurrentPosition += next-&gt;GetPosition();</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :             if (next-&gt;GetContent()-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    1792 </span>            :               // Record this &lt;textPath&gt; frame.
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :               mTextPathFrames.AppendElement(next);</span>
<span class="lineNum">    1794 </span>            :             }
<span class="lineNum">    1795 </span>            :             // Record the frame's baseline.
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :             PushBaseline(next);</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :             mCurrentFrame = next;</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :             if (mCurrentFrame == mSubtree) {</span>
<span class="lineNum">    1799 </span>            :               // If the current frame is mSubtree, we have now moved into it.
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :               mSubtreePosition = eWithinSubtree;</span>
<span class="lineNum">    1801 </span>            :             }
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1803 </span>            :           }
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :           if (mCurrentFrame == mSubtree) {</span>
<span class="lineNum">    1805 </span>            :             // If there is no next sibling frame, and the current frame is
<span class="lineNum">    1806 </span>            :             // mSubtree, we have now moved past it.
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :             mSubtreePosition = eAfterSubtree;</span>
<span class="lineNum">    1808 </span>            :           }
<span class="lineNum">    1809 </span>            :           // Ascend out of this frame.
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :           mCurrentFrame = mCurrentFrame-&gt;GetParent();</span>
<span class="lineNum">    1811 </span>            :         }
<span class="lineNum">    1812 </span>            :       }
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :     } while (mCurrentFrame &amp;&amp;</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :              !IsNonEmptyTextFrame(mCurrentFrame));</span>
<span class="lineNum">    1815 </span>            :   }
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :   return Current();</span>
<span class="lineNum">    1818 </span>            : }
<a name="1819"><span class="lineNum">    1819 </span>            : </a>
<span class="lineNum">    1820 </span>            : void
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 : TextFrameIterator::PushBaseline(nsIFrame* aNextFrame)</span>
<span class="lineNum">    1822 </span>            : {
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :   uint8_t baseline = aNextFrame-&gt;StyleSVGReset()-&gt;mDominantBaseline;</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :   if (baseline == NS_STYLE_DOMINANT_BASELINE_AUTO) {</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :     baseline = mBaselines.LastElement();</span>
<span class="lineNum">    1826 </span>            :   }
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   mBaselines.AppendElement(baseline);</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 : }</span>
<a name="1829"><span class="lineNum">    1829 </span>            : </a>
<span class="lineNum">    1830 </span>            : void
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 : TextFrameIterator::PopBaseline()</span>
<span class="lineNum">    1832 </span>            : {
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!mBaselines.IsEmpty(), &quot;popped too many baselines&quot;);</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :   mBaselines.TruncateLength(mBaselines.Length() - 1);</span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">    1838 </span>            : // TextRenderedRunIterator
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            : /**
<a name="1841"><span class="lineNum">    1841 </span>            :  * Iterator for TextRenderedRun objects for the SVGTextFrame.</a>
<span class="lineNum">    1842 </span>            :  */
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 : class TextRenderedRunIterator</span>
<span class="lineNum">    1844 </span>            : {
<span class="lineNum">    1845 </span>            : public:
<span class="lineNum">    1846 </span>            :   /**
<span class="lineNum">    1847 </span>            :    * Values for the aFilter argument of the constructor, to indicate which frames
<span class="lineNum">    1848 </span>            :    * we should be limited to iterating TextRenderedRun objects for.
<span class="lineNum">    1849 </span>            :    */
<span class="lineNum">    1850 </span>            :   enum RenderedRunFilter {
<span class="lineNum">    1851 </span>            :     // Iterate TextRenderedRuns for all nsTextFrames.
<span class="lineNum">    1852 </span>            :     eAllFrames,
<span class="lineNum">    1853 </span>            :     // Iterate only TextRenderedRuns for nsTextFrames that are
<span class="lineNum">    1854 </span>            :     // visibility:visible.
<span class="lineNum">    1855 </span>            :     eVisibleFrames
<span class="lineNum">    1856 </span>            :   };
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span>            :   /**
<span class="lineNum">    1859 </span>            :    * Constructs a TextRenderedRunIterator with an optional frame subtree to
<span class="lineNum">    1860 </span>            :    * restrict iterated rendered runs to.
<span class="lineNum">    1861 </span>            :    *
<span class="lineNum">    1862 </span>            :    * @param aSVGTextFrame The SVGTextFrame whose rendered runs to iterate
<span class="lineNum">    1863 </span>            :    *   through.
<span class="lineNum">    1864 </span>            :    * @param aFilter Indicates whether to iterate rendered runs for non-visible
<span class="lineNum">    1865 </span>            :    *   nsTextFrames.
<span class="lineNum">    1866 </span>            :    * @param aSubtree An optional frame subtree to restrict iterated rendered
<a name="1867"><span class="lineNum">    1867 </span>            :    *   runs to.</a>
<span class="lineNum">    1868 </span>            :    */
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :   explicit TextRenderedRunIterator(SVGTextFrame* aSVGTextFrame,</span>
<span class="lineNum">    1870 </span>            :                                    RenderedRunFilter aFilter = eAllFrames,
<span class="lineNum">    1871 </span>            :                                    nsIFrame* aSubtree = nullptr)
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     : mFrameIterator(FrameIfAnonymousChildReflowed(aSVGTextFrame), aSubtree),</span>
<span class="lineNum">    1873 </span>            :       mFilter(aFilter),
<span class="lineNum">    1874 </span>            :       mTextElementCharIndex(0),
<span class="lineNum">    1875 </span>            :       mFrameStartTextElementCharIndex(0),
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :       mFontSizeScaleFactor(aSVGTextFrame-&gt;mFontSizeScaleFactor),</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :       mCurrent(First())</span>
<span class="lineNum">    1878 </span>            :   {
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            :   /**
<span class="lineNum">    1882 </span>            :    * Constructs a TextRenderedRunIterator with a content subtree to restrict
<span class="lineNum">    1883 </span>            :    * iterated rendered runs to.
<span class="lineNum">    1884 </span>            :    *
<span class="lineNum">    1885 </span>            :    * @param aSVGTextFrame The SVGTextFrame whose rendered runs to iterate
<span class="lineNum">    1886 </span>            :    *   through.
<span class="lineNum">    1887 </span>            :    * @param aFilter Indicates whether to iterate rendered runs for non-visible
<span class="lineNum">    1888 </span>            :    *   nsTextFrames.
<a name="1889"><span class="lineNum">    1889 </span>            :    * @param aSubtree A content subtree to restrict iterated rendered runs to.</a>
<span class="lineNum">    1890 </span>            :    */
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator(SVGTextFrame* aSVGTextFrame,</span>
<span class="lineNum">    1892 </span>            :                           RenderedRunFilter aFilter,
<span class="lineNum">    1893 </span>            :                           nsIContent* aSubtree)
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     : mFrameIterator(FrameIfAnonymousChildReflowed(aSVGTextFrame), aSubtree),</span>
<span class="lineNum">    1895 </span>            :       mFilter(aFilter),
<span class="lineNum">    1896 </span>            :       mTextElementCharIndex(0),
<span class="lineNum">    1897 </span>            :       mFrameStartTextElementCharIndex(0),
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :       mFontSizeScaleFactor(aSVGTextFrame-&gt;mFontSizeScaleFactor),</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :       mCurrent(First())</span>
<span class="lineNum">    1900 </span>            :   {
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span>            :   /**
<a name="1904"><span class="lineNum">    1904 </span>            :    * Returns the current TextRenderedRun.</a>
<span class="lineNum">    1905 </span>            :    */
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :   TextRenderedRun Current() const</span>
<span class="lineNum">    1907 </span>            :   {
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :     return mCurrent;</span>
<span class="lineNum">    1909 </span>            :   }
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            :   /**
<span class="lineNum">    1912 </span>            :    * Advances to the next TextRenderedRun and returns it.
<span class="lineNum">    1913 </span>            :    */
<span class="lineNum">    1914 </span>            :   TextRenderedRun Next();
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            : private:
<span class="lineNum">    1917 </span>            :   /**
<a name="1918"><span class="lineNum">    1918 </span>            :    * Returns the root SVGTextFrame this iterator is for.</a>
<span class="lineNum">    1919 </span>            :    */
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :   SVGTextFrame* Root() const</span>
<span class="lineNum">    1921 </span>            :   {
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     return mFrameIterator.Root();</span>
<span class="lineNum">    1923 </span>            :   }
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span>            :   /**
<span class="lineNum">    1926 </span>            :    * Advances to the first TextRenderedRun and returns it.
<span class="lineNum">    1927 </span>            :    */
<span class="lineNum">    1928 </span>            :   TextRenderedRun First();
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            :   /**
<span class="lineNum">    1931 </span>            :    * The frame iterator to use.
<span class="lineNum">    1932 </span>            :    */
<span class="lineNum">    1933 </span>            :   TextFrameIterator mFrameIterator;
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            :   /**
<span class="lineNum">    1936 </span>            :    * The filter indicating which TextRenderedRuns to return.
<span class="lineNum">    1937 </span>            :    */
<span class="lineNum">    1938 </span>            :   RenderedRunFilter mFilter;
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :   /**
<span class="lineNum">    1941 </span>            :    * The character index across the entire &lt;text&gt; element we are currently
<span class="lineNum">    1942 </span>            :    * up to.
<span class="lineNum">    1943 </span>            :    */
<span class="lineNum">    1944 </span>            :   uint32_t mTextElementCharIndex;
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span>            :   /**
<span class="lineNum">    1947 </span>            :    * The character index across the entire &lt;text&gt; for the start of the current
<span class="lineNum">    1948 </span>            :    * frame.
<span class="lineNum">    1949 </span>            :    */
<span class="lineNum">    1950 </span>            :   uint32_t mFrameStartTextElementCharIndex;
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            :   /**
<span class="lineNum">    1953 </span>            :    * The font-size scale factor we used when constructing the nsTextFrames.
<span class="lineNum">    1954 </span>            :    */
<span class="lineNum">    1955 </span>            :   double mFontSizeScaleFactor;
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            :   /**
<span class="lineNum">    1958 </span>            :    * The current TextRenderedRun.
<span class="lineNum">    1959 </span>            :    */
<span class="lineNum">    1960 </span>            :   TextRenderedRun mCurrent;
<span class="lineNum">    1961 </span>            : };
<a name="1962"><span class="lineNum">    1962 </span>            : </a>
<span class="lineNum">    1963 </span>            : TextRenderedRun
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 : TextRenderedRunIterator::Next()</span>
<span class="lineNum">    1965 </span>            : {
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :   if (!mFrameIterator.Current()) {</span>
<span class="lineNum">    1967 </span>            :     // If there are no more frames, then there are no more rendered runs to
<span class="lineNum">    1968 </span>            :     // return.
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     mCurrent = TextRenderedRun();</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :     return mCurrent;</span>
<span class="lineNum">    1971 </span>            :   }
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            :   // The values we will use to initialize the TextRenderedRun with.
<span class="lineNum">    1974 </span>            :   nsTextFrame* frame;
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :   gfxPoint pt;</span>
<span class="lineNum">    1976 </span>            :   double rotate;
<span class="lineNum">    1977 </span>            :   nscoord baseline;
<span class="lineNum">    1978 </span>            :   uint32_t offset, length;
<span class="lineNum">    1979 </span>            :   uint32_t charIndex;
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span>            :   // We loop, because we want to skip over rendered runs that either aren't
<span class="lineNum">    1982 </span>            :   // within our subtree of interest, because they don't match the filter,
<span class="lineNum">    1983 </span>            :   // or because they are hidden due to having fallen off the end of a
<span class="lineNum">    1984 </span>            :   // &lt;textPath&gt;.
<span class="lineNum">    1985 </span>            :   for (;;) {
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :     if (mFrameIterator.IsAfterSubtree()) {</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :       mCurrent = TextRenderedRun();</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :       return mCurrent;</span>
<span class="lineNum">    1989 </span>            :     }
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :     frame = mFrameIterator.Current();</span>
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     charIndex = mTextElementCharIndex;</span>
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span>            :     // Find the end of the rendered run, by looking through the
<span class="lineNum">    1996 </span>            :     // SVGTextFrame's positions array until we find one that is recorded
<span class="lineNum">    1997 </span>            :     // as a run boundary.
<span class="lineNum">    1998 </span>            :     uint32_t runStart, runEnd;  // XXX Replace runStart with mTextElementCharIndex.
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :     runStart = mTextElementCharIndex;</span>
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :     runEnd = runStart + 1;</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :     while (runEnd &lt; Root()-&gt;mPositions.Length() &amp;&amp;</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :            !Root()-&gt;mPositions[runEnd].mRunBoundary) {</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :       runEnd++;</span>
<span class="lineNum">    2004 </span>            :     }
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span>            :     // Convert the global run start/end indexes into an offset/length into the
<span class="lineNum">    2007 </span>            :     // current frame's nsTextNode.
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     offset = frame-&gt;GetContentOffset() + runStart -</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :              mFrameStartTextElementCharIndex;</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :     length = runEnd - runStart;</span>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            :     // If the end of the frame's content comes before the run boundary we found
<span class="lineNum">    2013 </span>            :     // in SVGTextFrame's position array, we need to shorten the rendered run.
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :     uint32_t contentEnd = frame-&gt;GetContentEnd();</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :     if (offset + length &gt; contentEnd) {</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :       length = contentEnd - offset;</span>
<span class="lineNum">    2017 </span>            :     }
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :     NS_ASSERTION(offset &gt;= uint32_t(frame-&gt;GetContentOffset()), &quot;invalid offset&quot;);</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :     NS_ASSERTION(offset + length &lt;= contentEnd, &quot;invalid offset or length&quot;);</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     // Get the frame's baseline position.
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :     frame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :     baseline = GetBaselinePosition(frame,</span>
<span class="lineNum">    2025 </span>            :                                    frame-&gt;GetTextRun(nsTextFrame::eInflated),
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :                                    mFrameIterator.DominantBaseline(),</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :                                    mFontSizeScaleFactor);</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            :     // Trim the offset/length to remove any leading/trailing white space.
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :     uint32_t untrimmedOffset = offset;</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :     uint32_t untrimmedLength = length;</span>
<span class="lineNum">    2032 </span>            :     nsTextFrame::TrimmedOffsets trimmedOffsets =
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       frame-&gt;GetTrimmedOffsets(frame-&gt;GetContent()-&gt;GetText(), true);</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :     TrimOffsets(offset, length, trimmedOffsets);</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :     charIndex += offset - untrimmedOffset;</span>
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            :     // Get the position and rotation of the character that begins this
<span class="lineNum">    2038 </span>            :     // rendered run.
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     pt = Root()-&gt;mPositions[charIndex].mPosition;</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     rotate = Root()-&gt;mPositions[charIndex].mAngle;</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span>            :     // Determine if we should skip this rendered run.
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :     bool skip = !mFrameIterator.IsWithinSubtree() ||</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :                 Root()-&gt;mPositions[mTextElementCharIndex].mHidden;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :     if (mFilter == eVisibleFrames) {</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :       skip = skip || !frame-&gt;StyleVisibility()-&gt;IsVisible();</span>
<span class="lineNum">    2047 </span>            :     }
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span>            :     // Update our global character index to move past the characters
<span class="lineNum">    2050 </span>            :     // corresponding to this rendered run.
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :     mTextElementCharIndex += untrimmedLength;</span>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :     // If we have moved past the end of the current frame's content, we need to
<span class="lineNum">    2054 </span>            :     // advance to the next frame.
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     if (offset + untrimmedLength &gt;= contentEnd) {</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :       mFrameIterator.Next();</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :       mTextElementCharIndex += mFrameIterator.UndisplayedCharacters();</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :       mFrameStartTextElementCharIndex = mTextElementCharIndex;</span>
<span class="lineNum">    2059 </span>            :     }
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :     if (!mFrameIterator.Current()) {</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :       if (skip) {</span>
<span class="lineNum">    2063 </span>            :         // That was the last frame, and we skipped this rendered run.  So we
<span class="lineNum">    2064 </span>            :         // have no rendered run to return.
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :         mCurrent = TextRenderedRun();</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         return mCurrent;</span>
<span class="lineNum">    2067 </span>            :       }
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2069 </span>            :     }
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :     if (length &amp;&amp; !skip) {</span>
<span class="lineNum">    2072 </span>            :       // Only return a rendered run if it didn't get collapsed away entirely
<span class="lineNum">    2073 </span>            :       // (due to it being all white space) and if we don't want to skip it.
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2075 </span>            :     }
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :   mCurrent = TextRenderedRun(frame, pt, Root()-&gt;mLengthAdjustScaleFactor,</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :                              rotate, mFontSizeScaleFactor, baseline,</span>
<span class="lineNum">    2080 </span>            :                              offset, length, charIndex);
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :   return mCurrent;</span>
<span class="lineNum">    2082 </span>            : }
<a name="2083"><span class="lineNum">    2083 </span>            : </a>
<span class="lineNum">    2084 </span>            : TextRenderedRun
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 : TextRenderedRunIterator::First()</span>
<span class="lineNum">    2086 </span>            : {
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :   if (!mFrameIterator.Current()) {</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :     return TextRenderedRun();</span>
<span class="lineNum">    2089 </span>            :   }
<span class="lineNum">    2090 </span>            : 
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :   if (Root()-&gt;mPositions.IsEmpty()) {</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :     mFrameIterator.Close();</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :     return TextRenderedRun();</span>
<span class="lineNum">    2094 </span>            :   }
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span>            :   // Get the character index for the start of this rendered run, by skipping
<span class="lineNum">    2097 </span>            :   // any undisplayed characters.
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :   mTextElementCharIndex = mFrameIterator.UndisplayedCharacters();</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :   mFrameStartTextElementCharIndex = mTextElementCharIndex;</span>
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :   return Next();</span>
<span class="lineNum">    2102 </span>            : }
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">    2105 </span>            : // CharIterator
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span>            : /**
<a name="2108"><span class="lineNum">    2108 </span>            :  * Iterator for characters within an SVGTextFrame.</a>
<span class="lineNum">    2109 </span>            :  */
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 : class CharIterator</span>
<span class="lineNum">    2111 </span>            : {
<span class="lineNum">    2112 </span>            :   typedef gfxTextRun::Range Range;
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            : public:
<span class="lineNum">    2115 </span>            :   /**
<span class="lineNum">    2116 </span>            :    * Values for the aFilter argument of the constructor, to indicate which
<span class="lineNum">    2117 </span>            :    * characters we should be iterating over.
<span class="lineNum">    2118 </span>            :    */
<span class="lineNum">    2119 </span>            :   enum CharacterFilter {
<span class="lineNum">    2120 </span>            :     // Iterate over all original characters from the DOM that are within valid
<span class="lineNum">    2121 </span>            :     // text content elements.
<span class="lineNum">    2122 </span>            :     eOriginal,
<span class="lineNum">    2123 </span>            :     // Iterate only over characters that are addressable by the positioning
<span class="lineNum">    2124 </span>            :     // attributes x=&quot;&quot;, y=&quot;&quot;, etc.  This includes all characters after
<span class="lineNum">    2125 </span>            :     // collapsing white space as required by the value of 'white-space'.
<span class="lineNum">    2126 </span>            :     eAddressable,
<span class="lineNum">    2127 </span>            :     // Iterate only over characters that are the first of clusters or ligature
<span class="lineNum">    2128 </span>            :     // groups.
<span class="lineNum">    2129 </span>            :     eClusterAndLigatureGroupStart,
<span class="lineNum">    2130 </span>            :     // Iterate only over characters that are part of a cluster or ligature
<span class="lineNum">    2131 </span>            :     // group but not the first character.
<span class="lineNum">    2132 </span>            :     eClusterOrLigatureGroupMiddle
<span class="lineNum">    2133 </span>            :   };
<span class="lineNum">    2134 </span>            : 
<span class="lineNum">    2135 </span>            :   /**
<span class="lineNum">    2136 </span>            :    * Constructs a CharIterator.
<span class="lineNum">    2137 </span>            :    *
<span class="lineNum">    2138 </span>            :    * @param aSVGTextFrame The SVGTextFrame whose characters to iterate
<span class="lineNum">    2139 </span>            :    *   through.
<span class="lineNum">    2140 </span>            :    * @param aFilter Indicates which characters to iterate over.
<span class="lineNum">    2141 </span>            :    * @param aSubtree A content subtree to track whether the current character
<span class="lineNum">    2142 </span>            :    *   is within.
<span class="lineNum">    2143 </span>            :    */
<span class="lineNum">    2144 </span>            :   CharIterator(SVGTextFrame* aSVGTextFrame,
<span class="lineNum">    2145 </span>            :                CharacterFilter aFilter,
<span class="lineNum">    2146 </span>            :                nsIContent* aSubtree = nullptr);
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span>            :   /**
<a name="2149"><span class="lineNum">    2149 </span>            :    * Returns whether the iterator is finished.</a>
<span class="lineNum">    2150 </span>            :    */
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :   bool AtEnd() const</span>
<span class="lineNum">    2152 </span>            :   {
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :     return !mFrameIterator.Current();</span>
<span class="lineNum">    2154 </span>            :   }
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span>            :   /**
<span class="lineNum">    2157 </span>            :    * Advances to the next matching character.  Returns true if there was a
<span class="lineNum">    2158 </span>            :    * character to advance to, and false otherwise.
<span class="lineNum">    2159 </span>            :    */
<span class="lineNum">    2160 </span>            :   bool Next();
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            :   /**
<span class="lineNum">    2163 </span>            :    * Advances ahead aCount matching characters.  Returns true if there were
<span class="lineNum">    2164 </span>            :    * enough characters to advance past, and false otherwise.
<span class="lineNum">    2165 </span>            :    */
<span class="lineNum">    2166 </span>            :   bool Next(uint32_t aCount);
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span>            :   /**
<span class="lineNum">    2169 </span>            :    * Advances ahead up to aCount matching characters.
<span class="lineNum">    2170 </span>            :    */
<span class="lineNum">    2171 </span>            :   void NextWithinSubtree(uint32_t aCount);
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span>            :   /**
<span class="lineNum">    2174 </span>            :    * Advances to the character with the specified index.  The index is in the
<span class="lineNum">    2175 </span>            :    * space of original characters (i.e., all DOM characters under the &lt;text&gt;
<span class="lineNum">    2176 </span>            :    * that are within valid text content elements).
<span class="lineNum">    2177 </span>            :    */
<span class="lineNum">    2178 </span>            :   bool AdvanceToCharacter(uint32_t aTextElementCharIndex);
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span>            :   /**
<span class="lineNum">    2181 </span>            :    * Advances to the first matching character after the current nsTextFrame.
<span class="lineNum">    2182 </span>            :    */
<span class="lineNum">    2183 </span>            :   bool AdvancePastCurrentFrame();
<span class="lineNum">    2184 </span>            : 
<span class="lineNum">    2185 </span>            :   /**
<span class="lineNum">    2186 </span>            :    * Advances to the first matching character after the frames within
<span class="lineNum">    2187 </span>            :    * the current &lt;textPath&gt;.
<span class="lineNum">    2188 </span>            :    */
<span class="lineNum">    2189 </span>            :   bool AdvancePastCurrentTextPathFrame();
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span>            :   /**
<span class="lineNum">    2192 </span>            :    * Advances to the first matching character of the subtree.  Returns true
<span class="lineNum">    2193 </span>            :    * if we successfully advance to the subtree, or if we are already within
<span class="lineNum">    2194 </span>            :    * the subtree.  Returns false if we are past the subtree.
<span class="lineNum">    2195 </span>            :    */
<span class="lineNum">    2196 </span>            :   bool AdvanceToSubtree();
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span>            :   /**
<a name="2199"><span class="lineNum">    2199 </span>            :    * Returns the nsTextFrame for the current character.</a>
<span class="lineNum">    2200 </span>            :    */
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :   nsTextFrame* TextFrame() const</span>
<span class="lineNum">    2202 </span>            :   {
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     return mFrameIterator.Current();</span>
<span class="lineNum">    2204 </span>            :   }
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            :   /**
<a name="2207"><span class="lineNum">    2207 </span>            :    * Returns whether the iterator is within the subtree.</a>
<span class="lineNum">    2208 </span>            :    */
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :   bool IsWithinSubtree() const</span>
<span class="lineNum">    2210 </span>            :   {
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     return mFrameIterator.IsWithinSubtree();</span>
<span class="lineNum">    2212 </span>            :   }
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :   /**
<a name="2215"><span class="lineNum">    2215 </span>            :    * Returns whether the iterator is past the subtree.</a>
<span class="lineNum">    2216 </span>            :    */
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :   bool IsAfterSubtree() const</span>
<span class="lineNum">    2218 </span>            :   {
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :     return mFrameIterator.IsAfterSubtree();</span>
<span class="lineNum">    2220 </span>            :   }
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            :   /**
<a name="2223"><span class="lineNum">    2223 </span>            :    * Returns whether the current character is a skipped character.</a>
<span class="lineNum">    2224 </span>            :    */
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :   bool IsOriginalCharSkipped() const</span>
<span class="lineNum">    2226 </span>            :   {
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :     return mSkipCharsIterator.IsOriginalCharSkipped();</span>
<span class="lineNum">    2228 </span>            :   }
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span>            :   /**
<span class="lineNum">    2231 </span>            :    * Returns whether the current character is the start of a cluster and
<span class="lineNum">    2232 </span>            :    * ligature group.
<span class="lineNum">    2233 </span>            :    */
<span class="lineNum">    2234 </span>            :   bool IsClusterAndLigatureGroupStart() const;
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span>            :   /**
<span class="lineNum">    2237 </span>            :    * Returns whether the current character is trimmed away when painting,
<span class="lineNum">    2238 </span>            :    * due to it being leading/trailing white space.
<span class="lineNum">    2239 </span>            :    */
<span class="lineNum">    2240 </span>            :   bool IsOriginalCharTrimmed() const;
<span class="lineNum">    2241 </span>            : 
<span class="lineNum">    2242 </span>            :   /**
<span class="lineNum">    2243 </span>            :    * Returns whether the current character is unaddressable from the SVG glyph
<a name="2244"><span class="lineNum">    2244 </span>            :    * positioning attributes.</a>
<span class="lineNum">    2245 </span>            :    */
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :   bool IsOriginalCharUnaddressable() const</span>
<span class="lineNum">    2247 </span>            :   {
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :     return IsOriginalCharSkipped() || IsOriginalCharTrimmed();</span>
<span class="lineNum">    2249 </span>            :   }
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :   /**
<a name="2252"><span class="lineNum">    2252 </span>            :    * Returns the text run for the current character.</a>
<span class="lineNum">    2253 </span>            :    */
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :   gfxTextRun* TextRun() const</span>
<span class="lineNum">    2255 </span>            :   {
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :     return mTextRun;</span>
<span class="lineNum">    2257 </span>            :   }
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span>            :   /**
<a name="2260"><span class="lineNum">    2260 </span>            :    * Returns the current character index.</a>
<span class="lineNum">    2261 </span>            :    */
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :   uint32_t TextElementCharIndex() const</span>
<span class="lineNum">    2263 </span>            :   {
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :     return mTextElementCharIndex;</span>
<span class="lineNum">    2265 </span>            :   }
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            :   /**
<span class="lineNum">    2268 </span>            :    * Returns the character index for the start of the cluster/ligature group it
<a name="2269"><span class="lineNum">    2269 </span>            :    * is part of.</a>
<span class="lineNum">    2270 </span>            :    */
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :   uint32_t GlyphStartTextElementCharIndex() const</span>
<span class="lineNum">    2272 </span>            :   {
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :     return mGlyphStartTextElementCharIndex;</span>
<span class="lineNum">    2274 </span>            :   }
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span>            :   /**
<span class="lineNum">    2277 </span>            :    * Returns the number of undisplayed characters between the beginning of
<a name="2278"><span class="lineNum">    2278 </span>            :    * the glyph and the current character.</a>
<span class="lineNum">    2279 </span>            :    */
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :   uint32_t GlyphUndisplayedCharacters() const</span>
<span class="lineNum">    2281 </span>            :   {
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :     return mGlyphUndisplayedCharacters;</span>
<span class="lineNum">    2283 </span>            :   }
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span>            :   /**
<span class="lineNum">    2286 </span>            :    * Gets the original character offsets within the nsTextNode for the
<span class="lineNum">    2287 </span>            :    * cluster/ligature group the current character is a part of.
<span class="lineNum">    2288 </span>            :    *
<span class="lineNum">    2289 </span>            :    * @param aOriginalOffset The offset of the start of the cluster/ligature
<span class="lineNum">    2290 </span>            :    *   group (output).
<span class="lineNum">    2291 </span>            :    * @param aOriginalLength The length of cluster/ligature group (output).
<span class="lineNum">    2292 </span>            :    */
<span class="lineNum">    2293 </span>            :   void GetOriginalGlyphOffsets(uint32_t&amp; aOriginalOffset,
<span class="lineNum">    2294 </span>            :                                uint32_t&amp; aOriginalLength) const;
<span class="lineNum">    2295 </span>            : 
<span class="lineNum">    2296 </span>            :   /**
<span class="lineNum">    2297 </span>            :    * Gets the advance, in user units, of the glyph the current character is
<span class="lineNum">    2298 </span>            :    * part of.
<span class="lineNum">    2299 </span>            :    *
<span class="lineNum">    2300 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">    2301 </span>            :    */
<span class="lineNum">    2302 </span>            :   gfxFloat GetGlyphAdvance(nsPresContext* aContext) const;
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span>            :   /**
<span class="lineNum">    2305 </span>            :    * Gets the advance, in user units, of the current character.  If the
<span class="lineNum">    2306 </span>            :    * character is a part of ligature, then the advance returned will be
<span class="lineNum">    2307 </span>            :    * a fraction of the ligature glyph's advance.
<span class="lineNum">    2308 </span>            :    *
<span class="lineNum">    2309 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">    2310 </span>            :    */
<span class="lineNum">    2311 </span>            :   gfxFloat GetAdvance(nsPresContext* aContext) const;
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :   /**
<span class="lineNum">    2314 </span>            :    * Gets the specified partial advance of the glyph the current character is
<span class="lineNum">    2315 </span>            :    * part of.  The partial advance is measured from the first character
<span class="lineNum">    2316 </span>            :    * corresponding to the glyph until the specified part length.
<span class="lineNum">    2317 </span>            :    *
<span class="lineNum">    2318 </span>            :    * The part length value does not include any undisplayed characters in the
<span class="lineNum">    2319 </span>            :    * middle of the cluster/ligature group.  For example, if you have:
<span class="lineNum">    2320 </span>            :    *
<span class="lineNum">    2321 </span>            :    *   &lt;text&gt;f&lt;tspan display=&quot;none&quot;&gt;x&lt;/tspan&gt;i&lt;/text&gt;
<span class="lineNum">    2322 </span>            :    *
<span class="lineNum">    2323 </span>            :    * and the &quot;f&quot; and &quot;i&quot; are ligaturized, then calling GetGlyphPartialAdvance
<span class="lineNum">    2324 </span>            :    * with aPartLength values will have the following results:
<span class="lineNum">    2325 </span>            :    *
<span class="lineNum">    2326 </span>            :    *   0 =&gt; 0
<span class="lineNum">    2327 </span>            :    *   1 =&gt; adv(&quot;fi&quot;) / 2
<span class="lineNum">    2328 </span>            :    *   2 =&gt; adv(&quot;fi&quot;)
<span class="lineNum">    2329 </span>            :    *
<span class="lineNum">    2330 </span>            :    * @param aPartLength The number of characters in the cluster/ligature group
<span class="lineNum">    2331 </span>            :    *   to measure.
<span class="lineNum">    2332 </span>            :    * @param aContext The context to use for unit conversions.
<span class="lineNum">    2333 </span>            :    */
<span class="lineNum">    2334 </span>            :   gfxFloat GetGlyphPartialAdvance(uint32_t aPartLength,
<span class="lineNum">    2335 </span>            :                                   nsPresContext* aContext) const;
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            :   /**
<span class="lineNum">    2338 </span>            :    * Returns the frame corresponding to the &lt;textPath&gt; that the current
<a name="2339"><span class="lineNum">    2339 </span>            :    * character is within.</a>
<span class="lineNum">    2340 </span>            :    */
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :   nsIFrame* TextPathFrame() const</span>
<span class="lineNum">    2342 </span>            :   {
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     return mFrameIterator.TextPathFrame();</span>
<span class="lineNum">    2344 </span>            :   }
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span>            : private:
<span class="lineNum">    2347 </span>            :   /**
<span class="lineNum">    2348 </span>            :    * Advances to the next character without checking it against the filter.
<span class="lineNum">    2349 </span>            :    * Returns true if there was a next character to advance to, or false
<span class="lineNum">    2350 </span>            :    * otherwise.
<span class="lineNum">    2351 </span>            :    */
<span class="lineNum">    2352 </span>            :   bool NextCharacter();
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :   /**
<span class="lineNum">    2355 </span>            :    * Returns whether the current character matches the filter.
<span class="lineNum">    2356 </span>            :    */
<span class="lineNum">    2357 </span>            :   bool MatchesFilter() const;
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            :   /**
<a name="2360"><span class="lineNum">    2360 </span>            :    * If this is the start of a glyph, record it.</a>
<span class="lineNum">    2361 </span>            :    */
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :   void UpdateGlyphStartTextElementCharIndex() {</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     if (!IsOriginalCharSkipped() &amp;&amp; IsClusterAndLigatureGroupStart()) {</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :       mGlyphStartTextElementCharIndex = mTextElementCharIndex;</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :       mGlyphUndisplayedCharacters = 0;</span>
<span class="lineNum">    2366 </span>            :     }
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span>            :   /**
<span class="lineNum">    2370 </span>            :    * The filter to use.
<span class="lineNum">    2371 </span>            :    */
<span class="lineNum">    2372 </span>            :   CharacterFilter mFilter;
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span>            :   /**
<span class="lineNum">    2375 </span>            :    * The iterator for text frames.
<span class="lineNum">    2376 </span>            :    */
<span class="lineNum">    2377 </span>            :   TextFrameIterator mFrameIterator;
<span class="lineNum">    2378 </span>            : 
<span class="lineNum">    2379 </span>            :   /**
<span class="lineNum">    2380 </span>            :    * A gfxSkipCharsIterator for the text frame the current character is
<span class="lineNum">    2381 </span>            :    * a part of.
<span class="lineNum">    2382 </span>            :    */
<span class="lineNum">    2383 </span>            :   gfxSkipCharsIterator mSkipCharsIterator;
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :   // Cache for information computed by IsOriginalCharTrimmed.
<span class="lineNum">    2386 </span>            :   mutable nsTextFrame* mFrameForTrimCheck;
<span class="lineNum">    2387 </span>            :   mutable uint32_t mTrimmedOffset;
<span class="lineNum">    2388 </span>            :   mutable uint32_t mTrimmedLength;
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            :   /**
<span class="lineNum">    2391 </span>            :    * The text run the current character is a part of.
<span class="lineNum">    2392 </span>            :    */
<span class="lineNum">    2393 </span>            :   gfxTextRun* mTextRun;
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span>            :   /**
<span class="lineNum">    2396 </span>            :    * The current character's index.
<span class="lineNum">    2397 </span>            :    */
<span class="lineNum">    2398 </span>            :   uint32_t mTextElementCharIndex;
<span class="lineNum">    2399 </span>            : 
<span class="lineNum">    2400 </span>            :   /**
<span class="lineNum">    2401 </span>            :    * The index of the character that starts the cluster/ligature group the
<span class="lineNum">    2402 </span>            :    * current character is a part of.
<span class="lineNum">    2403 </span>            :    */
<span class="lineNum">    2404 </span>            :   uint32_t mGlyphStartTextElementCharIndex;
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            :   /**
<span class="lineNum">    2407 </span>            :    * If we are iterating in mode eClusterOrLigatureGroupMiddle, then
<span class="lineNum">    2408 </span>            :    * this tracks how many undisplayed characters were encountered
<span class="lineNum">    2409 </span>            :    * between the start of this glyph (at mGlyphStartTextElementCharIndex)
<span class="lineNum">    2410 </span>            :    * and the current character (at mTextElementCharIndex).
<span class="lineNum">    2411 </span>            :    */
<span class="lineNum">    2412 </span>            :   uint32_t mGlyphUndisplayedCharacters;
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            :   /**
<span class="lineNum">    2415 </span>            :    * The scale factor to apply to glyph advances returned by
<span class="lineNum">    2416 </span>            :    * GetGlyphAdvance etc. to take into account textLength=&quot;&quot;.
<span class="lineNum">    2417 </span>            :    */
<span class="lineNum">    2418 </span>            :   float mLengthAdjustScaleFactor;
<a name="2419"><span class="lineNum">    2419 </span>            : };</a>
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 : CharIterator::CharIterator(SVGTextFrame* aSVGTextFrame,</span>
<span class="lineNum">    2422 </span>            :                            CharIterator::CharacterFilter aFilter,
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :                            nsIContent* aSubtree)</span>
<span class="lineNum">    2424 </span>            :   : mFilter(aFilter),
<span class="lineNum">    2425 </span>            :     mFrameIterator(FrameIfAnonymousChildReflowed(aSVGTextFrame), aSubtree),
<span class="lineNum">    2426 </span>            :     mFrameForTrimCheck(nullptr),
<span class="lineNum">    2427 </span>            :     mTrimmedOffset(0),
<span class="lineNum">    2428 </span>            :     mTrimmedLength(0),
<span class="lineNum">    2429 </span>            :     mTextElementCharIndex(0),
<span class="lineNum">    2430 </span>            :     mGlyphStartTextElementCharIndex(0),
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :     mLengthAdjustScaleFactor(aSVGTextFrame-&gt;mLengthAdjustScaleFactor)</span>
<span class="lineNum">    2432 </span>            : {
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :   if (!AtEnd()) {</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     mSkipCharsIterator = TextFrame()-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :     mTextRun = TextFrame()-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :     mTextElementCharIndex = mFrameIterator.UndisplayedCharacters();</span>
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :     UpdateGlyphStartTextElementCharIndex();</span>
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :     if (!MatchesFilter()) {</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :       Next();</span>
<span class="lineNum">    2440 </span>            :     }
<span class="lineNum">    2441 </span>            :   }
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 : }</span>
<a name="2443"><span class="lineNum">    2443 </span>            : </a>
<span class="lineNum">    2444 </span>            : bool
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 : CharIterator::Next()</span>
<span class="lineNum">    2446 </span>            : {
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :   while (NextCharacter()) {</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :     if (MatchesFilter()) {</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    2450 </span>            :     }
<span class="lineNum">    2451 </span>            :   }
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2453 </span>            : }
<a name="2454"><span class="lineNum">    2454 </span>            : </a>
<span class="lineNum">    2455 </span>            : bool
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 : CharIterator::Next(uint32_t aCount)</span>
<span class="lineNum">    2457 </span>            : {
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :   if (aCount == 0 &amp;&amp; AtEnd()) {</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2460 </span>            :   }
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :   while (aCount) {</span>
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :     if (!Next()) {</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2464 </span>            :     }
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :     aCount--;</span>
<span class="lineNum">    2466 </span>            :   }
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2468 </span>            : }
<a name="2469"><span class="lineNum">    2469 </span>            : </a>
<span class="lineNum">    2470 </span>            : void
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 : CharIterator::NextWithinSubtree(uint32_t aCount)</span>
<span class="lineNum">    2472 </span>            : {
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :   while (IsWithinSubtree() &amp;&amp; aCount) {</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     --aCount;</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :     if (!Next()) {</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    2477 </span>            :     }
<span class="lineNum">    2478 </span>            :   }
<span class="lineNum">    2479 </span>            : }
<a name="2480"><span class="lineNum">    2480 </span>            : </a>
<span class="lineNum">    2481 </span>            : bool
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 : CharIterator::AdvanceToCharacter(uint32_t aTextElementCharIndex)</span>
<span class="lineNum">    2483 </span>            : {
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :   while (mTextElementCharIndex &lt; aTextElementCharIndex) {</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :     if (!Next()) {</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2487 </span>            :     }
<span class="lineNum">    2488 </span>            :   }
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2490 </span>            : }
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<span class="lineNum">    2492 </span>            : bool
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 : CharIterator::AdvancePastCurrentFrame()</span>
<span class="lineNum">    2494 </span>            : {
<span class="lineNum">    2495 </span>            :   // XXX Can do this better than one character at a time if it matters.
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :   nsTextFrame* currentFrame = TextFrame();</span>
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :     if (!Next()) {</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2500 </span>            :     }
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :   } while (TextFrame() == currentFrame);</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2503 </span>            : }
<a name="2504"><span class="lineNum">    2504 </span>            : </a>
<span class="lineNum">    2505 </span>            : bool
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 : CharIterator::AdvancePastCurrentTextPathFrame()</span>
<span class="lineNum">    2507 </span>            : {
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :   nsIFrame* currentTextPathFrame = TextPathFrame();</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :   NS_ASSERTION(currentTextPathFrame,</span>
<span class="lineNum">    2510 </span>            :                &quot;expected AdvancePastCurrentTextPathFrame to be called only &quot;
<span class="lineNum">    2511 </span>            :                &quot;within a text path frame&quot;);
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :     if (!AdvancePastCurrentFrame()) {</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2515 </span>            :     }
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :   } while (TextPathFrame() == currentTextPathFrame);</span>
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2518 </span>            : }
<a name="2519"><span class="lineNum">    2519 </span>            : </a>
<span class="lineNum">    2520 </span>            : bool
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 : CharIterator::AdvanceToSubtree()</span>
<span class="lineNum">    2522 </span>            : {
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :   while (!IsWithinSubtree()) {</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :     if (IsAfterSubtree()) {</span>
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2526 </span>            :     }
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :     if (!AdvancePastCurrentFrame()) {</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2529 </span>            :     }
<span class="lineNum">    2530 </span>            :   }
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2532 </span>            : }
<a name="2533"><span class="lineNum">    2533 </span>            : </a>
<span class="lineNum">    2534 </span>            : bool
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 : CharIterator::IsClusterAndLigatureGroupStart() const</span>
<span class="lineNum">    2536 </span>            : {
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :   return mTextRun-&gt;IsLigatureGroupStart(mSkipCharsIterator.GetSkippedOffset()) &amp;&amp;</span>
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :          mTextRun-&gt;IsClusterStart(mSkipCharsIterator.GetSkippedOffset());</span>
<span class="lineNum">    2539 </span>            : }
<a name="2540"><span class="lineNum">    2540 </span>            : </a>
<span class="lineNum">    2541 </span>            : bool
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 : CharIterator::IsOriginalCharTrimmed() const</span>
<span class="lineNum">    2543 </span>            : {
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :   if (mFrameForTrimCheck != TextFrame()) {</span>
<span class="lineNum">    2545 </span>            :     // Since we do a lot of trim checking, we cache the trimmed offsets and
<span class="lineNum">    2546 </span>            :     // lengths while we are in the same frame.
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :     mFrameForTrimCheck = TextFrame();</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :     uint32_t offset = mFrameForTrimCheck-&gt;GetContentOffset();</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :     uint32_t length = mFrameForTrimCheck-&gt;GetContentLength();</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :     nsIContent* content = mFrameForTrimCheck-&gt;GetContent();</span>
<span class="lineNum">    2551 </span>            :     nsTextFrame::TrimmedOffsets trim =
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :       mFrameForTrimCheck-&gt;GetTrimmedOffsets(content-&gt;GetText(), true);</span>
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :     TrimOffsets(offset, length, trim);</span>
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :     mTrimmedOffset = offset;</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :     mTrimmedLength = length;</span>
<span class="lineNum">    2556 </span>            :   }
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span>            :   // A character is trimmed if it is outside the mTrimmedOffset/mTrimmedLength
<span class="lineNum">    2559 </span>            :   // range and it is not a significant newline character.
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :   uint32_t index = mSkipCharsIterator.GetOriginalOffset();</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :   return !((index &gt;= mTrimmedOffset &amp;&amp;</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :             index &lt; mTrimmedOffset + mTrimmedLength) ||</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :            (index &gt;= mTrimmedOffset + mTrimmedLength &amp;&amp;</span>
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :             mFrameForTrimCheck-&gt;StyleText()-&gt;</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :               NewlineIsSignificant(mFrameForTrimCheck) &amp;&amp;</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :             mFrameForTrimCheck-&gt;GetContent()-&gt;GetText()-&gt;CharAt(index) == '\n'));</span>
<span class="lineNum">    2567 </span>            : }
<a name="2568"><span class="lineNum">    2568 </span>            : </a>
<span class="lineNum">    2569 </span>            : void
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 : CharIterator::GetOriginalGlyphOffsets(uint32_t&amp; aOriginalOffset,</span>
<span class="lineNum">    2571 </span>            :                                       uint32_t&amp; aOriginalLength) const
<span class="lineNum">    2572 </span>            : {
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = TextFrame()-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :   it.SetOriginalOffset(mSkipCharsIterator.GetOriginalOffset() -</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :                          (mTextElementCharIndex -</span>
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :                           mGlyphStartTextElementCharIndex -</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :                           mGlyphUndisplayedCharacters));</span>
<span class="lineNum">    2578 </span>            : 
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :   while (it.GetSkippedOffset() &gt; 0 &amp;&amp;</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :          (!mTextRun-&gt;IsClusterStart(it.GetSkippedOffset()) ||</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :           !mTextRun-&gt;IsLigatureGroupStart(it.GetSkippedOffset()))) {</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :     it.AdvanceSkipped(-1);</span>
<span class="lineNum">    2583 </span>            :   }
<span class="lineNum">    2584 </span>            : 
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :   aOriginalOffset = it.GetOriginalOffset();</span>
<span class="lineNum">    2586 </span>            : 
<span class="lineNum">    2587 </span>            :   // Find the end of the cluster/ligature group.
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :   it.SetOriginalOffset(mSkipCharsIterator.GetOriginalOffset());</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :     it.AdvanceSkipped(1);</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :   } while (it.GetSkippedOffset() &lt; mTextRun-&gt;GetLength() &amp;&amp;</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :            (!mTextRun-&gt;IsClusterStart(it.GetSkippedOffset()) ||</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :             !mTextRun-&gt;IsLigatureGroupStart(it.GetSkippedOffset())));</span>
<span class="lineNum">    2594 </span>            : 
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :   aOriginalLength = it.GetOriginalOffset() - aOriginalOffset;</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 : }</span>
<a name="2597"><span class="lineNum">    2597 </span>            : </a>
<span class="lineNum">    2598 </span>            : gfxFloat
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 : CharIterator::GetGlyphAdvance(nsPresContext* aContext) const</span>
<span class="lineNum">    2600 </span>            : {
<span class="lineNum">    2601 </span>            :   uint32_t offset, length;
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :   GetOriginalGlyphOffsets(offset, length);</span>
<span class="lineNum">    2603 </span>            : 
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = TextFrame()-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :   Range range = ConvertOriginalToSkipped(it, offset, length);</span>
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :   gfxFloat advance = mTextRun-&gt;GetAdvanceWidth(range, nullptr);</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :   return aContext-&gt;AppUnitsToGfxUnits(advance) *</span>
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :          mLengthAdjustScaleFactor * cssPxPerDevPx;</span>
<span class="lineNum">    2613 </span>            : }
<a name="2614"><span class="lineNum">    2614 </span>            : </a>
<span class="lineNum">    2615 </span>            : gfxFloat
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 : CharIterator::GetAdvance(nsPresContext* aContext) const</span>
<span class="lineNum">    2617 </span>            : {
<span class="lineNum">    2618 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineNoCov">          0 :   uint32_t offset = mSkipCharsIterator.GetSkippedOffset();</span>
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :   gfxFloat advance = mTextRun-&gt;</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :     GetAdvanceWidth(Range(offset, offset + 1), nullptr);</span>
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :   return aContext-&gt;AppUnitsToGfxUnits(advance) *</span>
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :          mLengthAdjustScaleFactor * cssPxPerDevPx;</span>
<span class="lineNum">    2626 </span>            : }
<a name="2627"><span class="lineNum">    2627 </span>            : </a>
<span class="lineNum">    2628 </span>            : gfxFloat
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 : CharIterator::GetGlyphPartialAdvance(uint32_t aPartLength,</span>
<span class="lineNum">    2630 </span>            :                                      nsPresContext* aContext) const
<span class="lineNum">    2631 </span>            : {
<span class="lineNum">    2632 </span>            :   uint32_t offset, length;
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :   GetOriginalGlyphOffsets(offset, length);</span>
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aPartLength &lt;= length, &quot;invalid aPartLength value&quot;);</span>
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :   length = aPartLength;</span>
<span class="lineNum">    2637 </span>            : 
<span class="lineNum">    2638 </span><span class="lineNoCov">          0 :   gfxSkipCharsIterator it = TextFrame()-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :   Range range = ConvertOriginalToSkipped(it, offset, length);</span>
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span>            :   float cssPxPerDevPx = aContext-&gt;
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(aContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :   gfxFloat advance = mTextRun-&gt;GetAdvanceWidth(range, nullptr);</span>
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :   return aContext-&gt;AppUnitsToGfxUnits(advance) *</span>
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :          mLengthAdjustScaleFactor * cssPxPerDevPx;</span>
<span class="lineNum">    2647 </span>            : }
<a name="2648"><span class="lineNum">    2648 </span>            : </a>
<span class="lineNum">    2649 </span>            : bool
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 : CharIterator::NextCharacter()</span>
<span class="lineNum">    2651 </span>            : {
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :   if (AtEnd()) {</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2654 </span>            :   }
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :   mTextElementCharIndex++;</span>
<span class="lineNum">    2657 </span>            : 
<span class="lineNum">    2658 </span>            :   // Advance within the current text run.
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :   mSkipCharsIterator.AdvanceOriginal(1);</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :   if (mSkipCharsIterator.GetOriginalOffset() &lt; TextFrame()-&gt;GetContentEnd()) {</span>
<span class="lineNum">    2661 </span>            :     // We're still within the part of the text run for the current text frame.
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :     UpdateGlyphStartTextElementCharIndex();</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2664 </span>            :   }
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span>            :   // Advance to the next frame.
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :   mFrameIterator.Next();</span>
<span class="lineNum">    2668 </span>            : 
<span class="lineNum">    2669 </span>            :   // Skip any undisplayed characters.
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :   uint32_t undisplayed = mFrameIterator.UndisplayedCharacters();</span>
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :   mGlyphUndisplayedCharacters += undisplayed;</span>
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :   mTextElementCharIndex += undisplayed;</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :   if (!TextFrame()) {</span>
<span class="lineNum">    2674 </span>            :     // We're at the end.
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :     mSkipCharsIterator = gfxSkipCharsIterator();</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2677 </span>            :   }
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :   mSkipCharsIterator = TextFrame()-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2680 </span><span class="lineNoCov">          0 :   mTextRun = TextFrame()-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :   UpdateGlyphStartTextElementCharIndex();</span>
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2683 </span>            : }
<a name="2684"><span class="lineNum">    2684 </span>            : </a>
<span class="lineNum">    2685 </span>            : bool
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 : CharIterator::MatchesFilter() const</span>
<span class="lineNum">    2687 </span>            : {
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :   if (mFilter == eOriginal) {</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2690 </span>            :   }
<span class="lineNum">    2691 </span>            : 
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :   if (IsOriginalCharSkipped()) {</span>
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2694 </span>            :   }
<span class="lineNum">    2695 </span>            : 
<span class="lineNum">    2696 </span><span class="lineNoCov">          0 :   if (mFilter == eAddressable) {</span>
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :     return !IsOriginalCharUnaddressable();</span>
<span class="lineNum">    2698 </span>            :   }
<span class="lineNum">    2699 </span>            : 
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :   return (mFilter == eClusterAndLigatureGroupStart) ==</span>
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :          IsClusterAndLigatureGroupStart();</span>
<span class="lineNum">    2702 </span>            : }
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">    2705 </span>            : // nsCharClipDisplayItem
<span class="lineNum">    2706 </span>            : 
<span class="lineNum">    2707 </span>            : /**
<span class="lineNum">    2708 </span>            :  * An nsCharClipDisplayItem that obtains its left and right clip edges from a
<a name="2709"><span class="lineNum">    2709 </span>            :  * TextRenderedRun object.</a>
<span class="lineNum">    2710 </span>            :  */
<a name="2711"><span class="lineNum">    2711 </span><span class="lineNoCov">          0 : class SVGCharClipDisplayItem : public nsCharClipDisplayItem {</span></a>
<span class="lineNum">    2712 </span>            : public:
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :   explicit SVGCharClipDisplayItem(const TextRenderedRun&amp; aRun)</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :     : nsCharClipDisplayItem(aRun.mFrame)</span>
<span class="lineNum">    2715 </span>            :   {
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :     aRun.GetClipEdges(mVisIStartEdge, mVisIEndEdge);</span>
<a name="2717"><span class="lineNum">    2717 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :   NS_DISPLAY_DECL_NAME(&quot;SVGText&quot;, TYPE_TEXT)</span>
<span class="lineNum">    2720 </span>            : };
<span class="lineNum">    2721 </span>            : 
<span class="lineNum">    2722 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">    2723 </span>            : // SVGTextDrawPathCallbacks
<span class="lineNum">    2724 </span>            : 
<span class="lineNum">    2725 </span>            : /**
<span class="lineNum">    2726 </span>            :  * Text frame draw callback class that paints the text and text decoration parts
<span class="lineNum">    2727 </span>            :  * of an nsTextFrame using SVG painting properties, and selection backgrounds
<span class="lineNum">    2728 </span>            :  * and decorations as they would normally.
<span class="lineNum">    2729 </span>            :  *
<span class="lineNum">    2730 </span>            :  * An instance of this class is passed to nsTextFrame::PaintText if painting
<span class="lineNum">    2731 </span>            :  * cannot be done directly (e.g. if we are using an SVG pattern fill, stroking
<span class="lineNum">    2732 </span>            :  * the text, etc.).
<span class="lineNum">    2733 </span>            :  */
<span class="lineNum">    2734 </span>            : class SVGTextDrawPathCallbacks : public nsTextFrame::DrawPathCallbacks
<span class="lineNum">    2735 </span>            : {
<span class="lineNum">    2736 </span>            :   typedef mozilla::image::imgDrawingParams imgDrawingParams;
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span>            : public:
<span class="lineNum">    2739 </span>            :   /**
<span class="lineNum">    2740 </span>            :    * Constructs an SVGTextDrawPathCallbacks.
<span class="lineNum">    2741 </span>            :    *
<span class="lineNum">    2742 </span>            :    * @param aSVGTextFrame The ancestor text frame.
<span class="lineNum">    2743 </span>            :    * @param aContext The context to use for painting.
<span class="lineNum">    2744 </span>            :    * @param aFrame The nsTextFrame to paint.
<span class="lineNum">    2745 </span>            :    * @param aCanvasTM The transformation matrix to set when painting; this
<span class="lineNum">    2746 </span>            :    *   should be the FOR_OUTERSVG_TM canvas TM of the text, so that
<span class="lineNum">    2747 </span>            :    *   paint servers are painted correctly.
<a name="2748"><span class="lineNum">    2748 </span>            :    * @param aShouldPaintSVGGlyphs Whether SVG glyphs should be painted.</a>
<span class="lineNum">    2749 </span>            :    */
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :   SVGTextDrawPathCallbacks(SVGTextFrame* aSVGTextFrame,</span>
<span class="lineNum">    2751 </span>            :                            gfxContext&amp; aContext,
<span class="lineNum">    2752 </span>            :                            nsTextFrame* aFrame,
<span class="lineNum">    2753 </span>            :                            const gfxMatrix&amp; aCanvasTM,
<span class="lineNum">    2754 </span>            :                            bool aShouldPaintSVGGlyphs)
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :     : DrawPathCallbacks(aShouldPaintSVGGlyphs),</span>
<span class="lineNum">    2756 </span>            :       mSVGTextFrame(aSVGTextFrame),
<span class="lineNum">    2757 </span>            :       mContext(aContext),
<span class="lineNum">    2758 </span>            :       mFrame(aFrame),
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :       mCanvasTM(aCanvasTM)</span>
<span class="lineNum">    2760 </span>            :   {
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span>            :   void NotifySelectionBackgroundNeedsFill(const Rect&amp; aBackgroundRect,
<span class="lineNum">    2764 </span>            :                                           nscolor aColor,
<span class="lineNum">    2765 </span>            :                                           DrawTarget&amp; aDrawTarget) override;
<span class="lineNum">    2766 </span>            :   void PaintDecorationLine(Rect aPath, nscolor aColor) override;
<span class="lineNum">    2767 </span>            :   void PaintSelectionDecorationLine(Rect aPath, nscolor aColor) override;
<span class="lineNum">    2768 </span>            :   void NotifyBeforeText(nscolor aColor) override;
<span class="lineNum">    2769 </span>            :   void NotifyGlyphPathEmitted() override;
<span class="lineNum">    2770 </span>            :   void NotifyAfterText() override;
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span>            : private:
<a name="2773"><span class="lineNum">    2773 </span>            :   void SetupContext();</a>
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :   bool IsClipPathChild() const {</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     return mSVGTextFrame-&gt;HasAnyStateBits(NS_STATE_SVG_CLIPPATH_CHILD);</span>
<span class="lineNum">    2777 </span>            :   }
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            :   /**
<span class="lineNum">    2780 </span>            :    * Paints a piece of text geometry.  This is called when glyphs
<span class="lineNum">    2781 </span>            :    * or text decorations have been emitted to the gfxContext.
<span class="lineNum">    2782 </span>            :    */
<span class="lineNum">    2783 </span>            :   void HandleTextGeometry();
<span class="lineNum">    2784 </span>            : 
<span class="lineNum">    2785 </span>            :   /**
<span class="lineNum">    2786 </span>            :    * Sets the gfxContext paint to the appropriate color or pattern
<span class="lineNum">    2787 </span>            :    * for filling text geometry.
<span class="lineNum">    2788 </span>            :    */
<span class="lineNum">    2789 </span>            :   void MakeFillPattern(GeneralPattern* aOutPattern,
<span class="lineNum">    2790 </span>            :                        imgDrawingParams&amp; aImgParams);
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span>            :   /**
<span class="lineNum">    2793 </span>            :    * Fills and strokes a piece of text geometry, using group opacity
<span class="lineNum">    2794 </span>            :    * if the selection style requires it.
<span class="lineNum">    2795 </span>            :    */
<span class="lineNum">    2796 </span>            :   void FillAndStrokeGeometry();
<span class="lineNum">    2797 </span>            : 
<span class="lineNum">    2798 </span>            :   /**
<span class="lineNum">    2799 </span>            :    * Fills a piece of text geometry.
<span class="lineNum">    2800 </span>            :    */
<span class="lineNum">    2801 </span>            :   void FillGeometry();
<span class="lineNum">    2802 </span>            : 
<span class="lineNum">    2803 </span>            :   /**
<span class="lineNum">    2804 </span>            :    * Strokes a piece of text geometry.
<span class="lineNum">    2805 </span>            :    */
<span class="lineNum">    2806 </span>            :   void StrokeGeometry();
<span class="lineNum">    2807 </span>            : 
<span class="lineNum">    2808 </span>            :   SVGTextFrame* mSVGTextFrame;
<span class="lineNum">    2809 </span>            :   gfxContext&amp; mContext;
<span class="lineNum">    2810 </span>            :   nsTextFrame* mFrame;
<span class="lineNum">    2811 </span>            :   const gfxMatrix&amp; mCanvasTM;
<span class="lineNum">    2812 </span>            : 
<span class="lineNum">    2813 </span>            :   /**
<span class="lineNum">    2814 </span>            :    * The color that we were last told from one of the path callback functions.
<span class="lineNum">    2815 </span>            :    * This color can be the special NS_SAME_AS_FOREGROUND_COLOR,
<span class="lineNum">    2816 </span>            :    * NS_40PERCENT_FOREGROUND_COLOR and NS_TRANSPARENT colors when we are
<span class="lineNum">    2817 </span>            :    * painting selections or IME decorations.
<span class="lineNum">    2818 </span>            :    */
<span class="lineNum">    2819 </span>            :   nscolor mColor;
<span class="lineNum">    2820 </span>            : };
<a name="2821"><span class="lineNum">    2821 </span>            : </a>
<span class="lineNum">    2822 </span>            : void
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::NotifySelectionBackgroundNeedsFill(</span>
<span class="lineNum">    2824 </span>            :                                                       const Rect&amp; aBackgroundRect,
<span class="lineNum">    2825 </span>            :                                                       nscolor aColor,
<span class="lineNum">    2826 </span>            :                                                       DrawTarget&amp; aDrawTarget)
<span class="lineNum">    2827 </span>            : {
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :   if (IsClipPathChild()) {</span>
<span class="lineNum">    2829 </span>            :     // Don't paint selection backgrounds when in a clip path.
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2831 </span>            :   }
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :   mColor = aColor; // currently needed by MakeFillPattern</span>
<span class="lineNum">    2834 </span>            : 
<span class="lineNum">    2835 </span><span class="lineNoCov">          0 :   GeneralPattern fillPattern;</span>
<span class="lineNum">    2836 </span>            :   // XXX cku Bug 1362417 we should pass imgDrawingParams from nsTextFrame.
<span class="lineNum">    2837 </span><span class="lineNoCov">          0 :   imgDrawingParams imgParams;</span>
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :   MakeFillPattern(&amp;fillPattern, imgParams);</span>
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :   if (fillPattern.GetPattern()) {</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :     DrawOptions drawOptions(aColor == NS_40PERCENT_FOREGROUND_COLOR ? 0.4 : 1.0);</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :     aDrawTarget.FillRect(aBackgroundRect, fillPattern, drawOptions);</span>
<span class="lineNum">    2842 </span>            :   }
<span class="lineNum">    2843 </span>            : }
<a name="2844"><span class="lineNum">    2844 </span>            : </a>
<span class="lineNum">    2845 </span>            : void
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::NotifyBeforeText(nscolor aColor)</span>
<span class="lineNum">    2847 </span>            : {
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :   mColor = aColor;</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :   SetupContext();</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :   mContext.NewPath();</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 : }</span>
<a name="2852"><span class="lineNum">    2852 </span>            : </a>
<span class="lineNum">    2853 </span>            : void
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::NotifyGlyphPathEmitted()</span>
<span class="lineNum">    2855 </span>            : {
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :   HandleTextGeometry();</span>
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 :   mContext.NewPath();</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 : }</span>
<a name="2859"><span class="lineNum">    2859 </span>            : </a>
<span class="lineNum">    2860 </span>            : void
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::NotifyAfterText()</span>
<span class="lineNum">    2862 </span>            : {
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   mContext.Restore();</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 : }</span>
<a name="2865"><span class="lineNum">    2865 </span>            : </a>
<span class="lineNum">    2866 </span>            : void
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::PaintDecorationLine(Rect aPath, nscolor aColor)</span>
<span class="lineNum">    2868 </span>            : {
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :   mColor = aColor;</span>
<span class="lineNum">    2870 </span>            :   AntialiasMode aaMode =
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :     nsSVGUtils::ToAntialiasMode(mFrame-&gt;StyleText()-&gt;mTextRendering);</span>
<span class="lineNum">    2872 </span>            : 
<span class="lineNum">    2873 </span><span class="lineNoCov">          0 :   mContext.Save();</span>
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :   mContext.NewPath();</span>
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :   mContext.SetAntialiasMode(aaMode);</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :   mContext.Rectangle(ThebesRect(aPath));</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :   HandleTextGeometry();</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :   mContext.NewPath();</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :   mContext.Restore();</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 : }</span>
<a name="2881"><span class="lineNum">    2881 </span>            : </a>
<span class="lineNum">    2882 </span>            : void
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::PaintSelectionDecorationLine(Rect aPath,</span>
<span class="lineNum">    2884 </span>            :                                                        nscolor aColor)
<span class="lineNum">    2885 </span>            : {
<span class="lineNum">    2886 </span><span class="lineNoCov">          0 :   if (IsClipPathChild()) {</span>
<span class="lineNum">    2887 </span>            :     // Don't paint selection decorations when in a clip path.
<span class="lineNum">    2888 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2889 </span>            :   }
<span class="lineNum">    2890 </span>            : 
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :   mColor = aColor;</span>
<span class="lineNum">    2892 </span>            : 
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :   mContext.Save();</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :   mContext.NewPath();</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :   mContext.Rectangle(ThebesRect(aPath));</span>
<span class="lineNum">    2896 </span><span class="lineNoCov">          0 :   FillAndStrokeGeometry();</span>
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :   mContext.Restore();</span>
<span class="lineNum">    2898 </span>            : }
<a name="2899"><span class="lineNum">    2899 </span>            : </a>
<span class="lineNum">    2900 </span>            : void
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::SetupContext()</span>
<span class="lineNum">    2902 </span>            : {
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :   mContext.Save();</span>
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span>            :   // XXX This is copied from nsSVGGlyphFrame::Render, but cairo doesn't actually
<span class="lineNum">    2906 </span>            :   // seem to do anything with the antialias mode.  So we can perhaps remove it,
<span class="lineNum">    2907 </span>            :   // or make SetAntialiasMode set cairo text antialiasing too.
<span class="lineNum">    2908 </span><span class="lineNoCov">          0 :   switch (mFrame-&gt;StyleText()-&gt;mTextRendering) {</span>
<span class="lineNum">    2909 </span>            :   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :     mContext.SetAntialiasMode(AntialiasMode::NONE);</span>
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    2912 </span>            :   default:
<span class="lineNum">    2913 </span><span class="lineNoCov">          0 :     mContext.SetAntialiasMode(AntialiasMode::SUBPIXEL);</span>
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    2915 </span>            :   }
<span class="lineNum">    2916 </span><span class="lineNoCov">          0 : }</span>
<a name="2917"><span class="lineNum">    2917 </span>            : </a>
<span class="lineNum">    2918 </span>            : void
<span class="lineNum">    2919 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::HandleTextGeometry()</span>
<span class="lineNum">    2920 </span>            : {
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :   if (IsClipPathChild()) {</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :     RefPtr&lt;Path&gt; path = mContext.GetPath();</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :     ColorPattern white(Color(1.f, 1.f, 1.f, 1.f)); // for masking, so no ToDeviceColor</span>
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :     mContext.GetDrawTarget()-&gt;Fill(path, white);</span>
<span class="lineNum">    2925 </span>            :   } else {
<span class="lineNum">    2926 </span>            :     // Normal painting.
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :     gfxContextMatrixAutoSaveRestore saveMatrix(&amp;mContext);</span>
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :     mContext.SetMatrix(mCanvasTM);</span>
<span class="lineNum">    2929 </span>            : 
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :     FillAndStrokeGeometry();</span>
<span class="lineNum">    2931 </span>            :   }
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 : }</span>
<a name="2933"><span class="lineNum">    2933 </span>            : </a>
<span class="lineNum">    2934 </span>            : void
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::MakeFillPattern(GeneralPattern* aOutPattern,</span>
<span class="lineNum">    2936 </span>            :                                           imgDrawingParams&amp; aImgParams)
<span class="lineNum">    2937 </span>            : {
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :   if (mColor == NS_SAME_AS_FOREGROUND_COLOR ||</span>
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :       mColor == NS_40PERCENT_FOREGROUND_COLOR) {</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :     nsSVGUtils::MakeFillPatternFor(mFrame, &amp;mContext, aOutPattern, aImgParams);</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2942 </span>            :   }
<span class="lineNum">    2943 </span>            : 
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :   if (mColor == NS_TRANSPARENT) {</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2946 </span>            :   }
<span class="lineNum">    2947 </span>            : 
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :   aOutPattern-&gt;InitColorPattern(ToDeviceColor(mColor));</span>
<span class="lineNum">    2949 </span>            : }
<a name="2950"><span class="lineNum">    2950 </span>            : </a>
<span class="lineNum">    2951 </span>            : void
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::FillAndStrokeGeometry()</span>
<span class="lineNum">    2953 </span>            : {
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :   bool pushedGroup = false;</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :   if (mColor == NS_40PERCENT_FOREGROUND_COLOR) {</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :     pushedGroup = true;</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :     mContext.PushGroupForBlendBack(gfxContentType::COLOR_ALPHA, 0.4f);</span>
<span class="lineNum">    2958 </span>            :   }
<span class="lineNum">    2959 </span>            : 
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :   uint32_t paintOrder = mFrame-&gt;StyleSVG()-&gt;mPaintOrder;</span>
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :   if (paintOrder == NS_STYLE_PAINT_ORDER_NORMAL) {</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :     FillGeometry();</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :     StrokeGeometry();</span>
<span class="lineNum">    2964 </span>            :   } else {
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :     while (paintOrder) {</span>
<span class="lineNum">    2966 </span>            :       uint32_t component =
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :         paintOrder &amp; ((1 &lt;&lt; NS_STYLE_PAINT_ORDER_BITWIDTH) - 1);</span>
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :       switch (component) {</span>
<span class="lineNum">    2969 </span>            :         case NS_STYLE_PAINT_ORDER_FILL:
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :           FillGeometry();</span>
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2972 </span>            :         case NS_STYLE_PAINT_ORDER_STROKE:
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :           StrokeGeometry();</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2975 </span>            :       }
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :       paintOrder &gt;&gt;= NS_STYLE_PAINT_ORDER_BITWIDTH;</span>
<span class="lineNum">    2977 </span>            :     }
<span class="lineNum">    2978 </span>            :   }
<span class="lineNum">    2979 </span>            : 
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :   if (pushedGroup) {</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :     mContext.PopGroupAndBlend();</span>
<span class="lineNum">    2982 </span>            :   }
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 : }</span>
<a name="2984"><span class="lineNum">    2984 </span>            : </a>
<span class="lineNum">    2985 </span>            : void
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::FillGeometry()</span>
<span class="lineNum">    2987 </span>            : {
<span class="lineNum">    2988 </span><span class="lineNoCov">          0 :   GeneralPattern fillPattern;</span>
<span class="lineNum">    2989 </span>            :   // XXX cku Bug 1362417 we should pass imgDrawingParams from nsTextFrame.
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :   imgDrawingParams imgParams;</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :   MakeFillPattern(&amp;fillPattern, imgParams);</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :   if (fillPattern.GetPattern()) {</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :     RefPtr&lt;Path&gt; path = mContext.GetPath();</span>
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :     FillRule fillRule = nsSVGUtils::ToFillRule(IsClipPathChild() ?</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :                           mFrame-&gt;StyleSVG()-&gt;mClipRule :</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :                           mFrame-&gt;StyleSVG()-&gt;mFillRule);</span>
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :     if (fillRule != path-&gt;GetFillRule()) {</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :       RefPtr&lt;PathBuilder&gt; builder = path-&gt;CopyToBuilder(fillRule);</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :       path = builder-&gt;Finish();</span>
<span class="lineNum">    3000 </span>            :     }
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :     mContext.GetDrawTarget()-&gt;Fill(path, fillPattern);</span>
<span class="lineNum">    3002 </span>            :   }
<span class="lineNum">    3003 </span><span class="lineNoCov">          0 : }</span>
<a name="3004"><span class="lineNum">    3004 </span>            : </a>
<span class="lineNum">    3005 </span>            : void
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 : SVGTextDrawPathCallbacks::StrokeGeometry()</span>
<span class="lineNum">    3007 </span>            : {
<span class="lineNum">    3008 </span>            :   // We don't paint the stroke when we are filling with a selection color.
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :   if (mColor == NS_SAME_AS_FOREGROUND_COLOR ||</span>
<span class="lineNum">    3010 </span><span class="lineNoCov">          0 :       mColor == NS_40PERCENT_FOREGROUND_COLOR) {</span>
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :     if (nsSVGUtils::HasStroke(mFrame, /*aContextPaint*/ nullptr)) {</span>
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :       GeneralPattern strokePattern;</span>
<span class="lineNum">    3013 </span>            :       // XXX cku Bug 1362417 we should pass imgDrawingParams from nsTextFrame.
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :       imgDrawingParams imgParams;</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :       nsSVGUtils::MakeStrokePatternFor(mFrame, &amp;mContext, &amp;strokePattern,</span>
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :                                        imgParams, /*aContextPaint*/ nullptr);</span>
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :       if (strokePattern.GetPattern()) {</span>
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :         if (!mFrame-&gt;GetParent()-&gt;GetContent()-&gt;IsSVGElement()) {</span>
<span class="lineNum">    3019 </span>            :           // The cast that follows would be unsafe
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(false, &quot;Our nsTextFrame's parent's content should be SVG&quot;);</span>
<span class="lineNum">    3021 </span>            :           return;
<span class="lineNum">    3022 </span>            :         }
<span class="lineNum">    3023 </span>            :         nsSVGElement* svgOwner =
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :           static_cast&lt;nsSVGElement*&gt;(mFrame-&gt;GetParent()-&gt;GetContent());</span>
<span class="lineNum">    3025 </span>            : 
<span class="lineNum">    3026 </span>            :         // Apply any stroke-specific transform
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :         gfxMatrix outerSVGToUser;</span>
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 :         if (nsSVGUtils::GetNonScalingStrokeTransform(mFrame, &amp;outerSVGToUser) &amp;&amp;</span>
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :             outerSVGToUser.Invert()) {</span>
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :           mContext.Multiply(outerSVGToUser);</span>
<span class="lineNum">    3031 </span>            :         }
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineNoCov">          0 :         RefPtr&lt;Path&gt; path = mContext.GetPath();</span>
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :         SVGContentUtils::AutoStrokeOptions strokeOptions;</span>
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 :         SVGContentUtils::GetStrokeOptions(&amp;strokeOptions, svgOwner,</span>
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :                                           mFrame-&gt;StyleContext(),</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :                                           /*aContextPaint*/ nullptr);</span>
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :         DrawOptions drawOptions;</span>
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :         drawOptions.mAntialiasMode =</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :           nsSVGUtils::ToAntialiasMode(mFrame-&gt;StyleText()-&gt;mTextRendering);</span>
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :         mContext.GetDrawTarget()-&gt;Stroke(path, strokePattern, strokeOptions);</span>
<span class="lineNum">    3042 </span>            :       }
<span class="lineNum">    3043 </span>            :     }
<span class="lineNum">    3044 </span>            :   }
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3046 </span>            : 
<span class="lineNum">    3047 </span>            : } // namespace mozilla
<span class="lineNum">    3048 </span>            : 
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span>            : // ============================================================================
<span class="lineNum">    3051 </span>            : // SVGTextFrame
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span>            : // ----------------------------------------------------------------------------
<span class="lineNum">    3054 </span>            : // Display list item
<span class="lineNum">    3055 </span>            : 
<a name="3056"><span class="lineNum">    3056 </span>            : class nsDisplaySVGText : public nsDisplayItem {</a>
<span class="lineNum">    3057 </span>            : public:
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :   nsDisplaySVGText(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    3059 </span>            :                    SVGTextFrame* aFrame)
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :     : nsDisplayItem(aBuilder, aFrame),</span>
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :       mDisableSubpixelAA(false)</span>
<span class="lineNum">    3062 </span>            :   {
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :     MOZ_COUNT_CTOR(nsDisplaySVGText);</span>
<span class="lineNum">    3064 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aFrame, &quot;Must have a frame!&quot;);</span>
<a name="3065"><span class="lineNum">    3065 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    3066 </span>            : #ifdef NS_BUILD_REFCNT_LOGGING
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :   virtual ~nsDisplaySVGText() {</span>
<span class="lineNum">    3068 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR(nsDisplaySVGText);</span>
<span class="lineNum">    3069 </span><span class="lineNoCov">          0 :   }</span>
<a name="3070"><span class="lineNum">    3070 </span>            : #endif</a>
<span class="lineNum">    3071 </span>            : 
<a name="3072"><span class="lineNum">    3072 </span><span class="lineNoCov">          0 :   NS_DISPLAY_DECL_NAME(&quot;nsDisplaySVGText&quot;, TYPE_SVG_TEXT)</span></a>
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :   virtual void DisableComponentAlpha() override {</span>
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :     mDisableSubpixelAA = true;</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    3077 </span>            :   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect&amp; aRect,
<span class="lineNum">    3078 </span>            :                        HitTestState* aState,
<span class="lineNum">    3079 </span>            :                        nsTArray&lt;nsIFrame*&gt; *aOutFrames) override;
<a name="3080"><span class="lineNum">    3080 </span>            :   virtual void Paint(nsDisplayListBuilder* aBuilder,</a>
<span class="lineNum">    3081 </span>            :                      gfxContext* aCtx) override;
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :   nsDisplayItemGeometry* AllocateGeometry(nsDisplayListBuilder* aBuilder) override</span>
<span class="lineNum">    3083 </span>            :   {
<a name="3084"><span class="lineNum">    3084 </span><span class="lineNoCov">          0 :     return new nsDisplayItemGenericImageGeometry(this, aBuilder);</span></a>
<span class="lineNum">    3085 </span>            :   }
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder) override {</span>
<span class="lineNum">    3087 </span>            :     bool snap;
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :     return GetBounds(aBuilder, &amp;snap);</span>
<span class="lineNum">    3089 </span>            :   }
<span class="lineNum">    3090 </span>            : private:
<span class="lineNum">    3091 </span>            :   bool mDisableSubpixelAA;
<span class="lineNum">    3092 </span>            : };
<a name="3093"><span class="lineNum">    3093 </span>            : </a>
<span class="lineNum">    3094 </span>            : void
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 : nsDisplaySVGText::HitTest(nsDisplayListBuilder* aBuilder, const nsRect&amp; aRect,</span>
<span class="lineNum">    3096 </span>            :                           HitTestState* aState, nsTArray&lt;nsIFrame*&gt; *aOutFrames)
<span class="lineNum">    3097 </span>            : {
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :   SVGTextFrame *frame = static_cast&lt;SVGTextFrame*&gt;(mFrame);</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :   nsPoint pointRelativeToReferenceFrame = aRect.Center();</span>
<span class="lineNum">    3100 </span>            :   // ToReferenceFrame() includes frame-&gt;GetPosition(), our user space position.
<span class="lineNum">    3101 </span>            :   nsPoint userSpacePtInAppUnits = pointRelativeToReferenceFrame -
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :                                     (ToReferenceFrame() - frame-&gt;GetPosition());</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            :   gfxPoint userSpacePt =
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 :     gfxPoint(userSpacePtInAppUnits.x, userSpacePtInAppUnits.y) /</span>
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :       frame-&gt;PresContext()-&gt;AppUnitsPerCSSPixel();</span>
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :   nsIFrame* target = frame-&gt;GetFrameForPoint(userSpacePt);</span>
<span class="lineNum">    3109 </span><span class="lineNoCov">          0 :   if (target) {</span>
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 :     aOutFrames-&gt;AppendElement(target);</span>
<span class="lineNum">    3111 </span>            :   }
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 : }</span>
<a name="3113"><span class="lineNum">    3113 </span>            : </a>
<span class="lineNum">    3114 </span>            : void
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 : nsDisplaySVGText::Paint(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    3116 </span>            :                         gfxContext* aCtx)
<span class="lineNum">    3117 </span>            : {
<span class="lineNum">    3118 </span>            :   DrawTargetAutoDisableSubpixelAntialiasing
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :     disable(aCtx-&gt;GetDrawTarget(), mDisableSubpixelAA);</span>
<span class="lineNum">    3120 </span>            : 
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :   uint32_t appUnitsPerDevPixel = mFrame-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    3122 </span>            : 
<span class="lineNum">    3123 </span>            :   // ToReferenceFrame includes our mRect offset, but painting takes
<span class="lineNum">    3124 </span>            :   // account of that too. To avoid double counting, we subtract that
<span class="lineNum">    3125 </span>            :   // here.
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :   nsPoint offset = ToReferenceFrame() - mFrame-&gt;GetPosition();</span>
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            :   gfxPoint devPixelOffset =
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :     nsLayoutUtils::PointToGfxPoint(offset, appUnitsPerDevPixel);</span>
<span class="lineNum">    3130 </span>            : 
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :   gfxMatrix tm = nsSVGUtils::GetCSSPxToDevPxMatrix(mFrame) *</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :                    gfxMatrix::Translation(devPixelOffset);</span>
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :   gfxContext* ctx = aCtx;</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :   ctx-&gt;Save();</span>
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :   imgDrawingParams imgParams(aBuilder-&gt;ShouldSyncDecodeImages()</span>
<span class="lineNum">    3137 </span>            :                              ? imgIContainer::FLAG_SYNC_DECODE
<span class="lineNum">    3138 </span><span class="lineNoCov">          0 :                              : imgIContainer::FLAG_SYNC_DECODE_IF_FAST);</span>
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :   static_cast&lt;SVGTextFrame*&gt;(mFrame)-&gt;PaintSVG(*ctx, tm, imgParams);</span>
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :   nsDisplayItemGenericImageGeometry::UpdateDrawResult(this, imgParams.result);</span>
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :   ctx-&gt;Restore();</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3143 </span>            : 
<span class="lineNum">    3144 </span>            : // ---------------------------------------------------------------------
<a name="3145"><span class="lineNum">    3145 </span>            : // nsQueryFrame methods</a>
<span class="lineNum">    3146 </span>            : 
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 : NS_QUERYFRAME_HEAD(SVGTextFrame)</span>
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(SVGTextFrame)</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 : NS_QUERYFRAME_TAIL_INHERITING(nsSVGDisplayContainerFrame)</span>
<span class="lineNum">    3150 </span>            : 
<span class="lineNum">    3151 </span>            : // ---------------------------------------------------------------------
<span class="lineNum">    3152 </span>            : // Implementation
<a name="3153"><span class="lineNum">    3153 </span>            : </a>
<span class="lineNum">    3154 </span>            : nsIFrame*
<span class="lineNum">    3155 </span><span class="lineNoCov">          0 : NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)</span>
<span class="lineNum">    3156 </span>            : {
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :   return new (aPresShell) SVGTextFrame(aContext);</span>
<a name="3158"><span class="lineNum">    3158 </span>            : }</a>
<span class="lineNum">    3159 </span>            : 
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 : NS_IMPL_FRAMEARENA_HELPERS(SVGTextFrame)</span>
<span class="lineNum">    3161 </span>            : 
<span class="lineNum">    3162 </span>            : // ---------------------------------------------------------------------
<span class="lineNum">    3163 </span>            : // nsIFrame methods
<a name="3164"><span class="lineNum">    3164 </span>            : </a>
<span class="lineNum">    3165 </span>            : void
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 : SVGTextFrame::Init(nsIContent*       aContent,</span>
<span class="lineNum">    3167 </span>            :                    nsContainerFrame* aParent,
<span class="lineNum">    3168 </span>            :                    nsIFrame*         aPrevInFlow)
<span class="lineNum">    3169 </span>            : {
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aContent-&gt;IsSVGElement(nsGkAtoms::text), &quot;Content is not an SVG text&quot;);</span>
<span class="lineNum">    3171 </span>            : 
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :   nsSVGDisplayContainerFrame::Init(aContent, aParent, aPrevInFlow);</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :   AddStateBits((aParent-&gt;GetStateBits() &amp; NS_STATE_SVG_CLIPPATH_CHILD) |</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :                NS_FRAME_SVG_LAYOUT | NS_FRAME_IS_SVG_TEXT);</span>
<span class="lineNum">    3175 </span>            : 
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :   mMutationObserver = new MutationObserver(this);</span>
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 : }</span>
<a name="3178"><span class="lineNum">    3178 </span>            : </a>
<span class="lineNum">    3179 </span>            : void
<span class="lineNum">    3180 </span><span class="lineNoCov">          0 : SVGTextFrame::BuildDisplayList(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    3181 </span>            :                                const nsRect&amp; aDirtyRect,
<span class="lineNum">    3182 </span>            :                                const nsDisplayListSet&amp; aLists)
<span class="lineNum">    3183 </span>            : {
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :   if (NS_SUBTREE_DIRTY(this)) {</span>
<span class="lineNum">    3185 </span>            :     // We can sometimes be asked to paint before reflow happens and we
<span class="lineNum">    3186 </span>            :     // have updated mPositions, etc.  In this case, we just avoid
<span class="lineNum">    3187 </span>            :     // painting.
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3189 </span>            :   }
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :   if (!IsVisibleForPainting(aBuilder) &amp;&amp;</span>
<span class="lineNum">    3191 </span><span class="lineNoCov">          0 :       aBuilder-&gt;IsForPainting()) {</span>
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3193 </span>            :   }
<span class="lineNum">    3194 </span><span class="lineNoCov">          0 :   DisplayOutline(aBuilder, aLists);</span>
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :   aLists.Content()-&gt;AppendNewToTop(</span>
<span class="lineNum">    3196 </span><span class="lineNoCov">          0 :     new (aBuilder) nsDisplaySVGText(aBuilder, this));</span>
<span class="lineNum">    3197 </span>            : }
<a name="3198"><span class="lineNum">    3198 </span>            : </a>
<span class="lineNum">    3199 </span>            : nsresult
<span class="lineNum">    3200 </span><span class="lineNoCov">          0 : SVGTextFrame::AttributeChanged(int32_t aNameSpaceID,</span>
<span class="lineNum">    3201 </span>            :                                nsIAtom* aAttribute,
<span class="lineNum">    3202 </span>            :                                int32_t aModType)
<span class="lineNum">    3203 </span>            : {
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :   if (aNameSpaceID != kNameSpaceID_None)</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span><span class="lineNoCov">          0 :   if (aAttribute == nsGkAtoms::transform) {</span>
<span class="lineNum">    3208 </span>            :     // We don't invalidate for transform changes (the layers code does that).
<span class="lineNum">    3209 </span>            :     // Also note that SVGTransformableElement::GetAttributeChangeHint will
<span class="lineNum">    3210 </span>            :     // return nsChangeHint_UpdateOverflow for &quot;transform&quot; attribute changes
<span class="lineNum">    3211 </span>            :     // and cause DoApplyRenderingChangeToTree to make the SchedulePaint call.
<span class="lineNum">    3212 </span>            : 
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :     if (!(mState &amp; NS_FRAME_FIRST_REFLOW) &amp;&amp;</span>
<span class="lineNum">    3214 </span><span class="lineNoCov">          0 :         mCanvasTM &amp;&amp; mCanvasTM-&gt;IsSingular()) {</span>
<span class="lineNum">    3215 </span>            :       // We won't have calculated the glyph positions correctly.
<span class="lineNum">    3216 </span><span class="lineNoCov">          0 :       NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3217 </span>            :     }
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :     mCanvasTM = nullptr;</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :   } else if (IsGlyphPositioningAttribute(aAttribute) ||</span>
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::textLength ||</span>
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :              aAttribute == nsGkAtoms::lengthAdjust) {</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :     NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3223 </span>            :   }
<span class="lineNum">    3224 </span>            : 
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    3226 </span>            : }
<a name="3227"><span class="lineNum">    3227 </span>            : </a>
<span class="lineNum">    3228 </span>            : void
<span class="lineNum">    3229 </span><span class="lineNoCov">          0 : SVGTextFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)</span>
<span class="lineNum">    3230 </span>            : {
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    3232 </span>            :     // We need this DidSetStyleContext override to handle cases like this:
<span class="lineNum">    3233 </span>            :     //
<span class="lineNum">    3234 </span>            :     //   &lt;defs&gt;
<span class="lineNum">    3235 </span>            :     //     &lt;g&gt;
<span class="lineNum">    3236 </span>            :     //       &lt;mask&gt;
<span class="lineNum">    3237 </span>            :     //         &lt;text&gt;...&lt;/text&gt;
<span class="lineNum">    3238 </span>            :     //       &lt;/mask&gt;
<span class="lineNum">    3239 </span>            :     //     &lt;/g&gt;
<span class="lineNum">    3240 </span>            :     //   &lt;/defs&gt;
<span class="lineNum">    3241 </span>            :     //
<span class="lineNum">    3242 </span>            :     // where the &lt;text&gt; is non-display, and a style change occurs on the &lt;defs&gt;,
<span class="lineNum">    3243 </span>            :     // the &lt;g&gt;, the &lt;mask&gt;, or the &lt;text&gt; itself.  If the style change happened
<span class="lineNum">    3244 </span>            :     // on the parent of the &lt;defs&gt;, then in
<span class="lineNum">    3245 </span>            :     // nsSVGDisplayContainerFrame::ReflowSVG, we would find the non-display
<span class="lineNum">    3246 </span>            :     // &lt;defs&gt; container and then call ReflowSVGNonDisplayText on it.  If we do
<span class="lineNum">    3247 </span>            :     // not actually reflow the parent of the &lt;defs&gt;, then without this
<span class="lineNum">    3248 </span>            :     // DidSetStyleContext we would (a) not cause the &lt;text&gt;'s anonymous block
<span class="lineNum">    3249 </span>            :     // child to be reflowed when it is next painted, and (b) not cause the
<span class="lineNum">    3250 </span>            :     // &lt;text&gt; to be repainted anyway since the user of the &lt;mask&gt; would not
<span class="lineNum">    3251 </span>            :     // know it needs to be repainted.
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :     ScheduleReflowSVGNonDisplayText(nsIPresShell::eStyleChange);</span>
<span class="lineNum">    3253 </span>            :   }
<span class="lineNum">    3254 </span><span class="lineNoCov">          0 : }</span>
<a name="3255"><span class="lineNum">    3255 </span>            : </a>
<span class="lineNum">    3256 </span>            : void
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 : SVGTextFrame::ReflowSVGNonDisplayText()</span>
<span class="lineNum">    3258 </span>            : {
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(nsSVGUtils::AnyOuterSVGIsCallingReflowSVG(this),</span>
<span class="lineNum">    3260 </span>            :              &quot;only call ReflowSVGNonDisplayText when an outer SVG frame is &quot;
<span class="lineNum">    3261 </span>            :              &quot;under ReflowSVG&quot;);
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mState &amp; NS_FRAME_IS_NONDISPLAY,</span>
<span class="lineNum">    3263 </span>            :              &quot;only call ReflowSVGNonDisplayText if the frame is &quot;
<span class="lineNum">    3264 </span>            :              &quot;NS_FRAME_IS_NONDISPLAY&quot;);
<span class="lineNum">    3265 </span>            : 
<span class="lineNum">    3266 </span>            :   // We had a style change, so we mark this frame as dirty so that the next
<span class="lineNum">    3267 </span>            :   // time it is painted, we reflow the anonymous block frame.
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :   AddStateBits(NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span>            :   // We also need to call InvalidateRenderingObservers, so that if the &lt;text&gt;
<span class="lineNum">    3271 </span>            :   // element is within a &lt;mask&gt;, say, the element referencing the &lt;mask&gt; will
<span class="lineNum">    3272 </span>            :   // be updated, which will then cause this SVGTextFrame to be painted and
<span class="lineNum">    3273 </span>            :   // in doing so cause the anonymous block frame to be reflowed.
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :   nsLayoutUtils::PostRestyleEvent(</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :     mContent-&gt;AsElement(), nsRestyleHint(0),</span>
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :     nsChangeHint_InvalidateRenderingObservers);</span>
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span>            :   // Finally, we need to actually reflow the anonymous block frame and update
<span class="lineNum">    3279 </span>            :   // mPositions, in case we are being reflowed immediately after a DOM
<span class="lineNum">    3280 </span>            :   // mutation that needs frame reconstruction.
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 :   MaybeReflowAnonymousBlockChild();</span>
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 : }</span>
<a name="3284"><span class="lineNum">    3284 </span>            : </a>
<span class="lineNum">    3285 </span>            : void
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 : SVGTextFrame::ScheduleReflowSVGNonDisplayText(nsIPresShell::IntrinsicDirty aReason)</span>
<span class="lineNum">    3287 </span>            : {
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!nsSVGUtils::OuterSVGIsCallingReflowSVG(this),</span>
<span class="lineNum">    3289 </span>            :              &quot;do not call ScheduleReflowSVGNonDisplayText when the outer SVG &quot;
<span class="lineNum">    3290 </span>            :              &quot;frame is under ReflowSVG&quot;);
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!(mState &amp; NS_STATE_SVG_TEXT_IN_REFLOW),</span>
<span class="lineNum">    3292 </span>            :              &quot;do not call ScheduleReflowSVGNonDisplayText while reflowing the &quot;
<span class="lineNum">    3293 </span>            :              &quot;anonymous block child&quot;);
<span class="lineNum">    3294 </span>            : 
<span class="lineNum">    3295 </span>            :   // We need to find an ancestor frame that we can call FrameNeedsReflow
<span class="lineNum">    3296 </span>            :   // on that will cause the document to be marked as needing relayout,
<span class="lineNum">    3297 </span>            :   // and for that ancestor (or some further ancestor) to be marked as
<span class="lineNum">    3298 </span>            :   // a root to reflow.  We choose the closest ancestor frame that is not
<span class="lineNum">    3299 </span>            :   // NS_FRAME_IS_NONDISPLAY and which is either an outer SVG frame or a
<span class="lineNum">    3300 </span>            :   // non-SVG frame.  (We don't consider displayed SVG frame ancestors toerh
<span class="lineNum">    3301 </span>            :   // than nsSVGOuterSVGFrame, since calling FrameNeedsReflow on those other
<span class="lineNum">    3302 </span>            :   // SVG frames would do a bunch of unnecessary work on the SVG frames up to
<span class="lineNum">    3303 </span>            :   // the nsSVGOuterSVGFrame.)
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span><span class="lineNoCov">          0 :   nsIFrame* f = this;</span>
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :   while (f) {</span>
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :     if (!(f-&gt;GetStateBits() &amp; NS_FRAME_IS_NONDISPLAY)) {</span>
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :       if (NS_SUBTREE_DIRTY(f)) {</span>
<span class="lineNum">    3309 </span>            :         // This is a displayed frame, so if it is already dirty, we will be reflowed
<span class="lineNum">    3310 </span>            :         // soon anyway.  No need to call FrameNeedsReflow again, then.
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3312 </span>            :       }
<span class="lineNum">    3313 </span><span class="lineNoCov">          0 :       if (!f-&gt;IsFrameOfType(eSVG) ||</span>
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :           (f-&gt;GetStateBits() &amp; NS_STATE_IS_OUTER_SVG)) {</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3316 </span>            :       }
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :       f-&gt;AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    3318 </span>            :     }
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :     f = f-&gt;GetParent();</span>
<span class="lineNum">    3320 </span>            :   }
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(f, &quot;should have found an ancestor frame to reflow&quot;);</span>
<span class="lineNum">    3323 </span>            : 
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :   PresContext()-&gt;PresShell()-&gt;FrameNeedsReflow(f, aReason, NS_FRAME_IS_DIRTY);</span>
<a name="3325"><span class="lineNum">    3325 </span>            : }</a>
<span class="lineNum">    3326 </span>            : 
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 : NS_IMPL_ISUPPORTS(SVGTextFrame::MutationObserver, nsIMutationObserver)</span>
<a name="3328"><span class="lineNum">    3328 </span>            : </a>
<span class="lineNum">    3329 </span>            : void
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 : SVGTextFrame::MutationObserver::ContentAppended(nsIDocument* aDocument,</span>
<span class="lineNum">    3331 </span>            :                                                 nsIContent* aContainer,
<span class="lineNum">    3332 </span>            :                                                 nsIContent* aFirstNewContent,
<span class="lineNum">    3333 </span>            :                                                 int32_t aNewIndexInContainer)
<span class="lineNum">    3334 </span>            : {
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :   mFrame-&gt;NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 : }</span>
<a name="3337"><span class="lineNum">    3337 </span>            : </a>
<span class="lineNum">    3338 </span>            : void
<span class="lineNum">    3339 </span><span class="lineNoCov">          0 : SVGTextFrame::MutationObserver::ContentInserted(</span>
<span class="lineNum">    3340 </span>            :                                         nsIDocument* aDocument,
<span class="lineNum">    3341 </span>            :                                         nsIContent* aContainer,
<span class="lineNum">    3342 </span>            :                                         nsIContent* aChild,
<span class="lineNum">    3343 </span>            :                                         int32_t aIndexInContainer)
<span class="lineNum">    3344 </span>            : {
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :   mFrame-&gt;NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3346 </span><span class="lineNoCov">          0 : }</span>
<a name="3347"><span class="lineNum">    3347 </span>            : </a>
<span class="lineNum">    3348 </span>            : void
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 : SVGTextFrame::MutationObserver::ContentRemoved(</span>
<span class="lineNum">    3350 </span>            :                                        nsIDocument *aDocument,
<span class="lineNum">    3351 </span>            :                                        nsIContent* aContainer,
<span class="lineNum">    3352 </span>            :                                        nsIContent* aChild,
<span class="lineNum">    3353 </span>            :                                        int32_t aIndexInContainer,
<span class="lineNum">    3354 </span>            :                                        nsIContent* aPreviousSibling)
<span class="lineNum">    3355 </span>            : {
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :   mFrame-&gt;NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3357 </span><span class="lineNoCov">          0 : }</span>
<a name="3358"><span class="lineNum">    3358 </span>            : </a>
<span class="lineNum">    3359 </span>            : void
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 : SVGTextFrame::MutationObserver::CharacterDataChanged(</span>
<span class="lineNum">    3361 </span>            :                                                  nsIDocument* aDocument,
<span class="lineNum">    3362 </span>            :                                                  nsIContent* aContent,
<span class="lineNum">    3363 </span>            :                                                  CharacterDataChangeInfo* aInfo)
<span class="lineNum">    3364 </span>            : {
<span class="lineNum">    3365 </span><span class="lineNoCov">          0 :   mFrame-&gt;NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 : }</span>
<a name="3367"><span class="lineNum">    3367 </span>            : </a>
<span class="lineNum">    3368 </span>            : void
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 : SVGTextFrame::MutationObserver::AttributeChanged(</span>
<span class="lineNum">    3370 </span>            :                                                 nsIDocument* aDocument,
<span class="lineNum">    3371 </span>            :                                                 mozilla::dom::Element* aElement,
<span class="lineNum">    3372 </span>            :                                                 int32_t aNameSpaceID,
<span class="lineNum">    3373 </span>            :                                                 nsIAtom* aAttribute,
<span class="lineNum">    3374 </span>            :                                                 int32_t aModType,
<span class="lineNum">    3375 </span>            :                                                 const nsAttrValue* aOldValue)
<span class="lineNum">    3376 </span>            : {
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 :   if (!aElement-&gt;IsSVGElement()) {</span>
<span class="lineNum">    3378 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3379 </span>            :   }
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span>            :   // Attribute changes on this element will be handled by
<span class="lineNum">    3382 </span>            :   // SVGTextFrame::AttributeChanged.
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :   if (aElement == mFrame-&gt;GetContent()) {</span>
<span class="lineNum">    3384 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3385 </span>            :   }
<span class="lineNum">    3386 </span>            : 
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :   mFrame-&gt;HandleAttributeChangeInDescendant(aElement, aNameSpaceID, aAttribute);</span>
<span class="lineNum">    3388 </span>            : }
<a name="3389"><span class="lineNum">    3389 </span>            : </a>
<span class="lineNum">    3390 </span>            : void
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 : SVGTextFrame::HandleAttributeChangeInDescendant(Element* aElement,</span>
<span class="lineNum">    3392 </span>            :                                                 int32_t aNameSpaceID,
<span class="lineNum">    3393 </span>            :                                                 nsIAtom* aAttribute)
<span class="lineNum">    3394 </span>            : {
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :   if (aElement-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :     if (aNameSpaceID == kNameSpaceID_None &amp;&amp;</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :         aAttribute == nsGkAtoms::startOffset) {</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :       NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :     } else if ((aNameSpaceID == kNameSpaceID_XLink ||</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :                 aNameSpaceID == kNameSpaceID_None) &amp;&amp;</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :                aAttribute == nsGkAtoms::href) {</span>
<span class="lineNum">    3402 </span>            :       // Blow away our reference, if any
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :       nsIFrame* childElementFrame = aElement-&gt;GetPrimaryFrame();</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :       if (childElementFrame) {</span>
<span class="lineNum">    3405 </span><span class="lineNoCov">          0 :         childElementFrame-&gt;DeleteProperty(</span>
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :           nsSVGEffects::HrefAsTextPathProperty());</span>
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :         NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3408 </span>            :       }
<span class="lineNum">    3409 </span>            :     }
<span class="lineNum">    3410 </span>            :   } else {
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :     if (aNameSpaceID == kNameSpaceID_None &amp;&amp;</span>
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :         IsGlyphPositioningAttribute(aAttribute)) {</span>
<span class="lineNum">    3413 </span><span class="lineNoCov">          0 :       NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3414 </span>            :     }
<span class="lineNum">    3415 </span>            :   }
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 : }</span>
<a name="3417"><span class="lineNum">    3417 </span>            : </a>
<span class="lineNum">    3418 </span>            : void
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 : SVGTextFrame::FindCloserFrameForSelection(</span>
<span class="lineNum">    3420 </span>            :                                  nsPoint aPoint,
<span class="lineNum">    3421 </span>            :                                  nsIFrame::FrameWithDistance* aCurrentBestFrame)
<span class="lineNum">    3422 </span>            : {
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :   if (GetStateBits() &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    3424 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3425 </span>            :   }
<span class="lineNum">    3426 </span>            : 
<span class="lineNum">    3427 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    3428 </span>            : 
<span class="lineNum">    3429 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    3430 </span>            : 
<span class="lineNum">    3431 </span>            :   // Find the frame that has the closest rendered run rect to aPoint.
<span class="lineNum">    3432 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this);</span>
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    3434 </span>            :     uint32_t flags = TextRenderedRun::eIncludeFill |
<span class="lineNum">    3435 </span>            :                      TextRenderedRun::eIncludeStroke |
<span class="lineNum">    3436 </span><span class="lineNoCov">          0 :                      TextRenderedRun::eNoHorizontalOverflow;</span>
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :     SVGBBox userRect = run.GetUserSpaceRect(presContext, flags);</span>
<span class="lineNum">    3438 </span><span class="lineNoCov">          0 :     float devPxPerCSSPx = presContext-&gt;CSSPixelsToDevPixels(1.f);</span>
<span class="lineNum">    3439 </span><span class="lineNoCov">          0 :     userRect.Scale(devPxPerCSSPx);</span>
<span class="lineNum">    3440 </span>            : 
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :     if (!userRect.IsEmpty()) {</span>
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :       gfxMatrix m;</span>
<span class="lineNum">    3443 </span><span class="lineNoCov">          0 :       if (!NS_SVGDisplayListHitTestingEnabled()) {</span>
<span class="lineNum">    3444 </span><span class="lineNoCov">          0 :         m = GetCanvasTM();</span>
<span class="lineNum">    3445 </span>            :       }
<span class="lineNum">    3446 </span><span class="lineNoCov">          0 :       nsRect rect = nsSVGUtils::ToCanvasBounds(userRect.ToThebesRect(), m,</span>
<span class="lineNum">    3447 </span><span class="lineNoCov">          0 :                                                presContext);</span>
<span class="lineNum">    3448 </span>            : 
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :       if (nsLayoutUtils::PointIsCloserToRect(aPoint, rect,</span>
<span class="lineNum">    3450 </span>            :                                              aCurrentBestFrame-&gt;mXDistance,
<span class="lineNum">    3451 </span>            :                                              aCurrentBestFrame-&gt;mYDistance)) {
<span class="lineNum">    3452 </span><span class="lineNoCov">          0 :         aCurrentBestFrame-&gt;mFrame = run.mFrame;</span>
<span class="lineNum">    3453 </span>            :       }
<span class="lineNum">    3454 </span>            :     }
<span class="lineNum">    3455 </span>            :   }
<span class="lineNum">    3456 </span>            : }
<span class="lineNum">    3457 </span>            : 
<span class="lineNum">    3458 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    3459 </span>            : // nsSVGDisplayableFrame methods
<a name="3460"><span class="lineNum">    3460 </span>            : </a>
<span class="lineNum">    3461 </span>            : void
<span class="lineNum">    3462 </span><span class="lineNoCov">          0 : SVGTextFrame::NotifySVGChanged(uint32_t aFlags)</span>
<span class="lineNum">    3463 </span>            : {
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aFlags &amp; (TRANSFORM_CHANGED | COORD_CONTEXT_CHANGED),</span>
<span class="lineNum">    3465 </span>            :              &quot;Invalidation logic may need adjusting&quot;);
<span class="lineNum">    3466 </span>            : 
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 :   bool needNewBounds = false;</span>
<span class="lineNum">    3468 </span><span class="lineNoCov">          0 :   bool needGlyphMetricsUpdate = false;</span>
<span class="lineNum">    3469 </span><span class="lineNoCov">          0 :   bool needNewCanvasTM = false;</span>
<span class="lineNum">    3470 </span>            : 
<span class="lineNum">    3471 </span><span class="lineNoCov">          0 :   if ((aFlags &amp; COORD_CONTEXT_CHANGED) &amp;&amp;</span>
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :       (mState &amp; NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES)) {</span>
<span class="lineNum">    3473 </span><span class="lineNoCov">          0 :     needGlyphMetricsUpdate = true;</span>
<span class="lineNum">    3474 </span>            :   }
<span class="lineNum">    3475 </span>            : 
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :   if (aFlags &amp; TRANSFORM_CHANGED) {</span>
<span class="lineNum">    3477 </span><span class="lineNoCov">          0 :     needNewCanvasTM = true;</span>
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :     if (mCanvasTM &amp;&amp; mCanvasTM-&gt;IsSingular()) {</span>
<span class="lineNum">    3479 </span>            :       // We won't have calculated the glyph positions correctly.
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :       needNewBounds = true;</span>
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :       needGlyphMetricsUpdate = true;</span>
<span class="lineNum">    3482 </span>            :     }
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 :     if (StyleSVGReset()-&gt;HasNonScalingStroke()) {</span>
<span class="lineNum">    3484 </span>            :       // Stroke currently contributes to our mRect, and our stroke depends on
<span class="lineNum">    3485 </span>            :       // the transform to our outer-&lt;svg&gt; if |vector-effect:non-scaling-stroke|.
<span class="lineNum">    3486 </span><span class="lineNoCov">          0 :       needNewBounds = true;</span>
<span class="lineNum">    3487 </span>            :     }
<span class="lineNum">    3488 </span>            :   }
<span class="lineNum">    3489 </span>            : 
<span class="lineNum">    3490 </span>            :   // If the scale at which we computed our mFontSizeScaleFactor has changed by
<span class="lineNum">    3491 </span>            :   // at least a factor of two, reflow the text.  This avoids reflowing text
<span class="lineNum">    3492 </span>            :   // at every tick of a transform animation, but ensures our glyph metrics
<span class="lineNum">    3493 </span>            :   // do not get too far out of sync with the final font size on the screen.
<span class="lineNum">    3494 </span><span class="lineNoCov">          0 :   if (needNewCanvasTM &amp;&amp; mLastContextScale != 0.0f) {</span>
<span class="lineNum">    3495 </span><span class="lineNoCov">          0 :     mCanvasTM = nullptr;</span>
<span class="lineNum">    3496 </span>            :     // If we are a non-display frame, then we don't want to call
<span class="lineNum">    3497 </span>            :     // GetCanvasTM(), since the context scale does not use it.
<span class="lineNum">    3498 </span>            :     gfxMatrix newTM =
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :       (mState &amp; NS_FRAME_IS_NONDISPLAY) ? gfxMatrix() :</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :                                           GetCanvasTM();</span>
<span class="lineNum">    3501 </span>            :     // Compare the old and new context scales.
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :     float scale = GetContextScale(newTM);</span>
<span class="lineNum">    3503 </span><span class="lineNoCov">          0 :     float change = scale / mLastContextScale;</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :     if (change &gt;= 2.0f || change &lt;= 0.5f) {</span>
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :       needNewBounds = true;</span>
<span class="lineNum">    3506 </span><span class="lineNoCov">          0 :       needGlyphMetricsUpdate = true;</span>
<span class="lineNum">    3507 </span>            :     }
<span class="lineNum">    3508 </span>            :   }
<span class="lineNum">    3509 </span>            : 
<span class="lineNum">    3510 </span><span class="lineNoCov">          0 :   if (needNewBounds) {</span>
<span class="lineNum">    3511 </span>            :     // Ancestor changes can't affect how we render from the perspective of
<span class="lineNum">    3512 </span>            :     // any rendering observers that we may have, so we don't need to
<span class="lineNum">    3513 </span>            :     // invalidate them. We also don't need to invalidate ourself, since our
<span class="lineNum">    3514 </span>            :     // changed ancestor will have invalidated its entire area, which includes
<span class="lineNum">    3515 </span>            :     // our area.
<span class="lineNum">    3516 </span><span class="lineNoCov">          0 :     ScheduleReflowSVG();</span>
<span class="lineNum">    3517 </span>            :   }
<span class="lineNum">    3518 </span>            : 
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :   if (needGlyphMetricsUpdate) {</span>
<span class="lineNum">    3520 </span>            :     // If we are positioned using percentage values we need to update our
<span class="lineNum">    3521 </span>            :     // position whenever our viewport's dimensions change.  But only do this if
<span class="lineNum">    3522 </span>            :     // we have been reflowed once, otherwise the glyph positioning will be
<span class="lineNum">    3523 </span>            :     // wrong.  (We need to wait until bidi reordering has been done.)
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :     if (!(mState &amp; NS_FRAME_FIRST_REFLOW)) {</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :       NotifyGlyphMetricsChange();</span>
<span class="lineNum">    3526 </span>            :     }
<span class="lineNum">    3527 </span>            :   }
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3529 </span>            : 
<span class="lineNum">    3530 </span>            : /**
<span class="lineNum">    3531 </span>            :  * Gets the offset into a DOM node that the specified caret is positioned at.
<a name="3532"><span class="lineNum">    3532 </span>            :  */</a>
<span class="lineNum">    3533 </span>            : static int32_t
<span class="lineNum">    3534 </span><span class="lineNoCov">          0 : GetCaretOffset(nsCaret* aCaret)</span>
<span class="lineNum">    3535 </span>            : {
<span class="lineNum">    3536 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsISelection&gt; selection = aCaret-&gt;GetSelection();</span>
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 :   if (!selection) {</span>
<span class="lineNum">    3538 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3539 </span>            :   }
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span><span class="lineNoCov">          0 :   int32_t offset = -1;</span>
<span class="lineNum">    3542 </span><span class="lineNoCov">          0 :   selection-&gt;GetAnchorOffset(&amp;offset);</span>
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 :   return offset;</span>
<span class="lineNum">    3544 </span>            : }
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span>            : /**
<span class="lineNum">    3547 </span>            :  * Returns whether the caret should be painted for a given TextRenderedRun
<span class="lineNum">    3548 </span>            :  * by checking whether the caret is in the range covered by the rendered run.
<span class="lineNum">    3549 </span>            :  *
<span class="lineNum">    3550 </span>            :  * @param aThisRun The TextRenderedRun to be painted.
<span class="lineNum">    3551 </span>            :  * @param aCaret The caret.
<a name="3552"><span class="lineNum">    3552 </span>            :  */</a>
<span class="lineNum">    3553 </span>            : static bool
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 : ShouldPaintCaret(const TextRenderedRun&amp; aThisRun, nsCaret* aCaret)</span>
<span class="lineNum">    3555 </span>            : {
<span class="lineNum">    3556 </span><span class="lineNoCov">          0 :   int32_t caretOffset = GetCaretOffset(aCaret);</span>
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :   if (caretOffset &lt; 0) {</span>
<span class="lineNum">    3559 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3560 </span>            :   }
<span class="lineNum">    3561 </span>            : 
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :   if (uint32_t(caretOffset) &gt;= aThisRun.mTextFrameContentOffset &amp;&amp;</span>
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 :       uint32_t(caretOffset) &lt; aThisRun.mTextFrameContentOffset +</span>
<span class="lineNum">    3564 </span><span class="lineNoCov">          0 :                                 aThisRun.mTextFrameContentLength) {</span>
<span class="lineNum">    3565 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    3566 </span>            :   }
<span class="lineNum">    3567 </span>            : 
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    3569 </span>            : }
<a name="3570"><span class="lineNum">    3570 </span>            : </a>
<span class="lineNum">    3571 </span>            : void
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 : SVGTextFrame::PaintSVG(gfxContext&amp; aContext,</span>
<span class="lineNum">    3573 </span>            :                        const gfxMatrix&amp; aTransform,
<span class="lineNum">    3574 </span>            :                        imgDrawingParams&amp; aImgParams,
<span class="lineNum">    3575 </span>            :                        const nsIntRect *aDirtyRect)
<span class="lineNum">    3576 </span>            : {
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :   DrawTarget&amp; aDrawTarget = *aContext.GetDrawTarget();</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :   if (!kid) {</span>
<span class="lineNum">    3580 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3581 </span>            :   }
<span class="lineNum">    3582 </span>            : 
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    3584 </span>            : 
<span class="lineNum">    3585 </span><span class="lineNoCov">          0 :   gfxMatrix initialMatrix = aContext.CurrentMatrix();</span>
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    3588 </span>            :     // If we are in a canvas DrawWindow call that used the
<span class="lineNum">    3589 </span>            :     // DRAWWINDOW_DO_NOT_FLUSH flag, then we may still have out
<span class="lineNum">    3590 </span>            :     // of date frames.  Just don't paint anything if they are
<span class="lineNum">    3591 </span>            :     // dirty.
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 :     if (presContext-&gt;PresShell()-&gt;InDrawWindowNotFlushing() &amp;&amp;</span>
<span class="lineNum">    3593 </span><span class="lineNoCov">          0 :         NS_SUBTREE_DIRTY(this)) {</span>
<span class="lineNum">    3594 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3595 </span>            :     }
<span class="lineNum">    3596 </span>            :     // Text frames inside &lt;clipPath&gt;, &lt;mask&gt;, etc. will never have had
<span class="lineNum">    3597 </span>            :     // ReflowSVG called on them, so call UpdateGlyphPositioning to do this now.
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :     UpdateGlyphPositioning();</span>
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :   } else if (NS_SUBTREE_DIRTY(this)) {</span>
<span class="lineNum">    3600 </span>            :     // If we are asked to paint before reflow has recomputed mPositions etc.
<span class="lineNum">    3601 </span>            :     // directly via PaintSVG, rather than via a display list, then we need
<span class="lineNum">    3602 </span>            :     // to bail out here too.
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3604 </span>            :   }
<span class="lineNum">    3605 </span>            : 
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :   if (aTransform.IsSingular()) {</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Can't render text element!&quot;);</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3609 </span>            :   }
<span class="lineNum">    3610 </span>            : 
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :   gfxMatrix matrixForPaintServers = aTransform * initialMatrix;</span>
<span class="lineNum">    3612 </span>            : 
<span class="lineNum">    3613 </span>            :   // Check if we need to draw anything.
<span class="lineNum">    3614 </span><span class="lineNoCov">          0 :   if (aDirtyRect) {</span>
<span class="lineNum">    3615 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||</span>
<span class="lineNum">    3616 </span>            :                  (mState &amp; NS_FRAME_IS_NONDISPLAY),
<span class="lineNum">    3617 </span>            :                  &quot;Display lists handle dirty rect intersection test&quot;);
<span class="lineNum">    3618 </span><span class="lineNoCov">          0 :     nsRect dirtyRect(aDirtyRect-&gt;x, aDirtyRect-&gt;y,</span>
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :                      aDirtyRect-&gt;width, aDirtyRect-&gt;height);</span>
<span class="lineNum">    3620 </span>            : 
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 :     gfxFloat appUnitsPerDevPixel = presContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :     gfxRect frameRect(mRect.x / appUnitsPerDevPixel,</span>
<span class="lineNum">    3623 </span><span class="lineNoCov">          0 :                       mRect.y / appUnitsPerDevPixel,</span>
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :                       mRect.width / appUnitsPerDevPixel,</span>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :                       mRect.height / appUnitsPerDevPixel);</span>
<span class="lineNum">    3626 </span>            : 
<span class="lineNum">    3627 </span>            :     nsRect canvasRect = nsLayoutUtils::RoundGfxRectToAppRect(
<span class="lineNum">    3628 </span><span class="lineNoCov">          0 :         GetCanvasTM().TransformBounds(frameRect), 1);</span>
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 :     if (!canvasRect.Intersects(dirtyRect)) {</span>
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3631 </span>            :     }
<span class="lineNum">    3632 </span>            :   }
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span>            :   // SVG frames' PaintSVG methods paint in CSS px, but normally frames paint in
<span class="lineNum">    3635 </span>            :   // dev pixels. Here we multiply a CSS-px-to-dev-pixel factor onto aTransform
<span class="lineNum">    3636 </span>            :   // so our non-SVG nsTextFrame children paint correctly.
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 :   auto auPerDevPx = presContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    3638 </span><span class="lineNoCov">          0 :   float cssPxPerDevPx = presContext-&gt;AppUnitsToFloatCSSPixels(auPerDevPx);</span>
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :   gfxMatrix canvasTMForChildren = aTransform;</span>
<span class="lineNum">    3640 </span><span class="lineNoCov">          0 :   canvasTMForChildren.PreScale(cssPxPerDevPx, cssPxPerDevPx);</span>
<span class="lineNum">    3641 </span><span class="lineNoCov">          0 :   initialMatrix.PreScale(1 / cssPxPerDevPx, 1 / cssPxPerDevPx);</span>
<span class="lineNum">    3642 </span>            : 
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :   gfxContextAutoSaveRestore save(&amp;aContext);</span>
<span class="lineNum">    3644 </span><span class="lineNoCov">          0 :   aContext.NewPath();</span>
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :   aContext.Multiply(canvasTMForChildren);</span>
<span class="lineNum">    3646 </span><span class="lineNoCov">          0 :   gfxMatrix currentMatrix = aContext.CurrentMatrix();</span>
<span class="lineNum">    3647 </span>            : 
<span class="lineNum">    3648 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsCaret&gt; caret = presContext-&gt;PresShell()-&gt;GetCaret();</span>
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :   nsRect caretRect;</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :   nsIFrame* caretFrame = caret-&gt;GetPaintGeometry(&amp;caretRect);</span>
<span class="lineNum">    3651 </span>            : 
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eVisibleFrames);</span>
<span class="lineNum">    3653 </span><span class="lineNoCov">          0 :   TextRenderedRun run = it.Current();</span>
<span class="lineNum">    3654 </span>            : 
<span class="lineNum">    3655 </span>            :   SVGContextPaint* outerContextPaint =
<span class="lineNum">    3656 </span><span class="lineNoCov">          0 :     SVGContextPaint::GetContextPaint(mContent);</span>
<span class="lineNum">    3657 </span>            : 
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :   while (run.mFrame) {</span>
<span class="lineNum">    3659 </span><span class="lineNoCov">          0 :     nsTextFrame* frame = run.mFrame;</span>
<span class="lineNum">    3660 </span>            : 
<span class="lineNum">    3661 </span>            :     // Determine how much of the left and right edges of the text frame we
<span class="lineNum">    3662 </span>            :     // need to ignore.
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :     SVGCharClipDisplayItem item(run);</span>
<span class="lineNum">    3664 </span>            : 
<span class="lineNum">    3665 </span>            :     // Set up the fill and stroke so that SVG glyphs can get painted correctly
<span class="lineNum">    3666 </span>            :     // when they use context-fill etc.
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :     aContext.SetMatrix(initialMatrix);</span>
<span class="lineNum">    3668 </span>            : 
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :     RefPtr&lt;SVGContextPaintImpl&gt; contextPaint = new SVGContextPaintImpl();</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :     DrawMode drawMode = contextPaint-&gt;Init(&amp;aDrawTarget,</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :                                            aContext.CurrentMatrix(),</span>
<span class="lineNum">    3672 </span>            :                                            frame, outerContextPaint,
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 :                                            aImgParams);</span>
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :     if (drawMode &amp; DrawMode::GLYPH_STROKE) {</span>
<span class="lineNum">    3675 </span>            :       // This may change the gfxContext's transform (for non-scaling stroke),
<span class="lineNum">    3676 </span>            :       // in which case this needs to happen before we call SetMatrix() below.
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :       nsSVGUtils::SetupCairoStrokeGeometry(frame, &amp;aContext, outerContextPaint);</span>
<span class="lineNum">    3678 </span>            :     }
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span>            :     // Set up the transform for painting the text frame for the substring
<span class="lineNum">    3681 </span>            :     // indicated by the run.
<span class="lineNum">    3682 </span>            :     gfxMatrix runTransform =
<span class="lineNum">    3683 </span><span class="lineNoCov">          0 :       run.GetTransformFromUserSpaceForPainting(presContext, item) *</span>
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 :       currentMatrix;</span>
<span class="lineNum">    3685 </span><span class="lineNoCov">          0 :     aContext.SetMatrix(runTransform);</span>
<span class="lineNum">    3686 </span>            : 
<span class="lineNum">    3687 </span><span class="lineNoCov">          0 :     if (drawMode != DrawMode(0)) {</span>
<span class="lineNum">    3688 </span>            :       bool paintSVGGlyphs;
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :       nsTextFrame::PaintTextParams params(&amp;aContext);</span>
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 :       params.framePt = gfxPoint();</span>
<span class="lineNum">    3691 </span>            :       params.dirtyRect = LayoutDevicePixel::
<span class="lineNum">    3692 </span><span class="lineNoCov">          0 :         FromAppUnits(frame-&gt;GetVisualOverflowRect(), auPerDevPx);</span>
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :       params.contextPaint = contextPaint;</span>
<span class="lineNum">    3694 </span><span class="lineNoCov">          0 :       if (ShouldRenderAsPath(frame, paintSVGGlyphs)) {</span>
<span class="lineNum">    3695 </span>            :         SVGTextDrawPathCallbacks callbacks(this, aContext, frame,
<span class="lineNum">    3696 </span>            :                                            matrixForPaintServers,
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :                                            paintSVGGlyphs);</span>
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :         params.callbacks = &amp;callbacks;</span>
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 :         frame-&gt;PaintText(params, item);</span>
<span class="lineNum">    3700 </span>            :       } else {
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :         frame-&gt;PaintText(params, item);</span>
<span class="lineNum">    3702 </span>            :       }
<span class="lineNum">    3703 </span>            :     }
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :     if (frame == caretFrame &amp;&amp; ShouldPaintCaret(run, caret)) {</span>
<span class="lineNum">    3706 </span>            :       // XXX Should we be looking at the fill/stroke colours to paint the
<span class="lineNum">    3707 </span>            :       // caret with, rather than using the color property?
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :       caret-&gt;PaintCaret(aDrawTarget, frame, nsPoint());</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :       aContext.NewPath();</span>
<span class="lineNum">    3710 </span>            :     }
<span class="lineNum">    3711 </span>            : 
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :     run = it.Next();</span>
<span class="lineNum">    3713 </span>            :   }
<span class="lineNum">    3714 </span>            : }
<a name="3715"><span class="lineNum">    3715 </span>            : </a>
<span class="lineNum">    3716 </span>            : nsIFrame*
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 : SVGTextFrame::GetFrameForPoint(const gfxPoint&amp; aPoint)</span>
<span class="lineNum">    3718 </span>            : {
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 :   NS_ASSERTION(PrincipalChildList().FirstChild(), &quot;must have a child frame&quot;);</span>
<span class="lineNum">    3720 </span>            : 
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    3722 </span>            :     // Text frames inside &lt;clipPath&gt; will never have had ReflowSVG called on
<span class="lineNum">    3723 </span>            :     // them, so call UpdateGlyphPositioning to do this now.  (Text frames
<span class="lineNum">    3724 </span>            :     // inside &lt;mask&gt; and other non-display containers will never need to
<span class="lineNum">    3725 </span>            :     // be hit tested.)
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :     UpdateGlyphPositioning();</span>
<span class="lineNum">    3727 </span>            :   } else {
<span class="lineNum">    3728 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!NS_SUBTREE_DIRTY(this), &quot;reflow should have happened&quot;);</span>
<span class="lineNum">    3729 </span>            :   }
<span class="lineNum">    3730 </span>            : 
<span class="lineNum">    3731 </span>            :   // Hit-testing any clip-path will typically be a lot quicker than the
<span class="lineNum">    3732 </span>            :   // hit-testing of our text frames in the loop below, so we do the former up
<span class="lineNum">    3733 </span>            :   // front to avoid unnecessarily wasting cycles on the latter.
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :   if (!nsSVGUtils::HitTestClip(this, aPoint)) {</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    3736 </span>            :   }
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    3739 </span>            : 
<span class="lineNum">    3740 </span>            :   // Ideally we'd iterate backwards so that we can just return the first frame
<span class="lineNum">    3741 </span>            :   // that is under aPoint.  In practice this will rarely matter though since it
<span class="lineNum">    3742 </span>            :   // is rare for text in/under an SVG &lt;text&gt; element to overlap (i.e. the first
<span class="lineNum">    3743 </span>            :   // text frame that is hit will likely be the only text frame that is hit).
<span class="lineNum">    3744 </span>            : 
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this);</span>
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :   nsIFrame* hit = nullptr;</span>
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :     uint16_t hitTestFlags = nsSVGUtils::GetGeometryHitTestFlags(run.mFrame);</span>
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :     if (!(hitTestFlags &amp; (SVG_HIT_TEST_FILL | SVG_HIT_TEST_STROKE))) {</span>
<span class="lineNum">    3750 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3751 </span>            :     }
<span class="lineNum">    3752 </span>            : 
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :     gfxMatrix m = run.GetTransformFromRunUserSpaceToUserSpace(presContext);</span>
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :     if (!m.Invert()) {</span>
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    3756 </span>            :     }
<span class="lineNum">    3757 </span>            : 
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :     gfxPoint pointInRunUserSpace = m.TransformPoint(aPoint);</span>
<span class="lineNum">    3759 </span>            :     gfxRect frameRect =
<span class="lineNum">    3760 </span><span class="lineNoCov">          0 :       run.GetRunUserSpaceRect(presContext, TextRenderedRun::eIncludeFill |</span>
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :                                            TextRenderedRun::eIncludeStroke).ToThebesRect();</span>
<span class="lineNum">    3762 </span>            : 
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :     if (Inside(frameRect, pointInRunUserSpace)) {</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :       hit = run.mFrame;</span>
<span class="lineNum">    3765 </span>            :     }
<span class="lineNum">    3766 </span>            :   }
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :   return hit;</span>
<span class="lineNum">    3768 </span>            : }
<a name="3769"><span class="lineNum">    3769 </span>            : </a>
<span class="lineNum">    3770 </span>            : void
<span class="lineNum">    3771 </span><span class="lineNoCov">          0 : SVGTextFrame::ReflowSVG()</span>
<span class="lineNum">    3772 </span>            : {
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :   NS_ASSERTION(nsSVGUtils::OuterSVGIsCallingReflowSVG(this),</span>
<span class="lineNum">    3774 </span>            :                &quot;This call is probaby a wasteful mistake&quot;);
<span class="lineNum">    3775 </span>            : 
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!(GetStateBits() &amp; NS_FRAME_IS_NONDISPLAY),</span>
<span class="lineNum">    3777 </span>            :              &quot;ReflowSVG mechanism not designed for this&quot;);
<span class="lineNum">    3778 </span>            : 
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :   if (!nsSVGUtils::NeedsReflowSVG(this)) {</span>
<span class="lineNum">    3780 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!(mState &amp; NS_STATE_SVG_POSITIONING_DIRTY), &quot;How did this happen?&quot;);</span>
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3782 </span>            :   }
<span class="lineNum">    3783 </span>            : 
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :   MaybeReflowAnonymousBlockChild();</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    3786 </span>            : 
<span class="lineNum">    3787 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    3788 </span>            : 
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :   SVGBBox r;</span>
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames);</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :     uint32_t runFlags = 0;</span>
<span class="lineNum">    3793 </span><span class="lineNoCov">          0 :     if (run.mFrame-&gt;StyleSVG()-&gt;mFill.Type() != eStyleSVGPaintType_None) {</span>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :       runFlags |= TextRenderedRun::eIncludeFill |</span>
<span class="lineNum">    3795 </span>            :                   TextRenderedRun::eIncludeTextShadow;
<span class="lineNum">    3796 </span>            :     }
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :     if (nsSVGUtils::HasStroke(run.mFrame)) {</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :       runFlags |= TextRenderedRun::eIncludeFill |</span>
<span class="lineNum">    3799 </span>            :                   TextRenderedRun::eIncludeTextShadow;
<span class="lineNum">    3800 </span>            :     }
<span class="lineNum">    3801 </span>            :     // Our &quot;visual&quot; overflow rect needs to be valid for building display lists
<span class="lineNum">    3802 </span>            :     // for hit testing, which means that for certain values of 'pointer-events'
<span class="lineNum">    3803 </span>            :     // it needs to include the geometry of the fill or stroke even when the fill/
<span class="lineNum">    3804 </span>            :     // stroke don't actually render (e.g. when stroke=&quot;none&quot; or
<span class="lineNum">    3805 </span>            :     // stroke-opacity=&quot;0&quot;). GetGeometryHitTestFlags accounts for 'pointer-events'.
<span class="lineNum">    3806 </span>            :     // The text-shadow is not part of the hit-test area.
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :     uint16_t hitTestFlags = nsSVGUtils::GetGeometryHitTestFlags(run.mFrame);</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :     if (hitTestFlags &amp; SVG_HIT_TEST_FILL) {</span>
<span class="lineNum">    3809 </span><span class="lineNoCov">          0 :       runFlags |= TextRenderedRun::eIncludeFill;</span>
<span class="lineNum">    3810 </span>            :     }
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :     if (hitTestFlags &amp; SVG_HIT_TEST_STROKE) {</span>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :       runFlags |= TextRenderedRun::eIncludeStroke;</span>
<span class="lineNum">    3813 </span>            :     }
<span class="lineNum">    3814 </span>            : 
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :     if (runFlags) {</span>
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 :       r.UnionEdges(run.GetUserSpaceRect(presContext, runFlags));</span>
<span class="lineNum">    3817 </span>            :     }
<span class="lineNum">    3818 </span>            :   }
<span class="lineNum">    3819 </span>            : 
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :   if (r.IsEmpty()) {</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :     mRect.SetEmpty();</span>
<span class="lineNum">    3822 </span>            :   } else {
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :     mRect =</span>
<span class="lineNum">    3824 </span><span class="lineNoCov">          0 :       nsLayoutUtils::RoundGfxRectToAppRect(r.ToThebesRect(), presContext-&gt;AppUnitsPerCSSPixel());</span>
<span class="lineNum">    3825 </span>            : 
<span class="lineNum">    3826 </span>            :     // Due to rounding issues when we have a transform applied, we sometimes
<span class="lineNum">    3827 </span>            :     // don't include an additional row of pixels.  For now, just inflate our
<span class="lineNum">    3828 </span>            :     // covered region.
<span class="lineNum">    3829 </span><span class="lineNoCov">          0 :     mRect.Inflate(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    3830 </span>            :   }
<span class="lineNum">    3831 </span>            : 
<span class="lineNum">    3832 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_FIRST_REFLOW) {</span>
<span class="lineNum">    3833 </span>            :     // Make sure we have our filter property (if any) before calling
<span class="lineNum">    3834 </span>            :     // FinishAndStoreOverflow (subsequent filter changes are handled off
<span class="lineNum">    3835 </span>            :     // nsChangeHint_UpdateEffects):
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :     nsSVGEffects::UpdateEffects(this);</span>
<span class="lineNum">    3837 </span>            :   }
<span class="lineNum">    3838 </span>            : 
<span class="lineNum">    3839 </span>            :   // Now unset the various reflow bits. Do this before calling
<span class="lineNum">    3840 </span>            :   // FinishAndStoreOverflow since FinishAndStoreOverflow can require glyph
<span class="lineNum">    3841 </span>            :   // positions (to resolve transform-origin).
<span class="lineNum">    3842 </span>            :   mState &amp;= ~(NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :               NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    3844 </span>            : 
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 :   nsRect overflow = nsRect(nsPoint(0,0), mRect.Size());</span>
<span class="lineNum">    3846 </span><span class="lineNoCov">          0 :   nsOverflowAreas overflowAreas(overflow, overflow);</span>
<span class="lineNum">    3847 </span><span class="lineNoCov">          0 :   FinishAndStoreOverflow(overflowAreas, mRect.Size());</span>
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span>            :   // XXX nsSVGContainerFrame::ReflowSVG only looks at its nsSVGDisplayableFrame
<span class="lineNum">    3850 </span>            :   // children, and calls ConsiderChildOverflow on them.  Does it matter
<span class="lineNum">    3851 </span>            :   // that ConsiderChildOverflow won't be called on our children?
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 :   nsSVGDisplayContainerFrame::ReflowSVG();</span>
<span class="lineNum">    3853 </span>            : }
<span class="lineNum">    3854 </span>            : 
<span class="lineNum">    3855 </span>            : /**
<span class="lineNum">    3856 </span>            :  * Converts nsSVGUtils::eBBox* flags into TextRenderedRun flags appropriate
<span class="lineNum">    3857 </span>            :  * for the specified rendered run.
<a name="3858"><span class="lineNum">    3858 </span>            :  */</a>
<span class="lineNum">    3859 </span>            : static uint32_t
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 : TextRenderedRunFlagsForBBoxContribution(const TextRenderedRun&amp; aRun,</span>
<span class="lineNum">    3861 </span>            :                                         uint32_t aBBoxFlags)
<span class="lineNum">    3862 </span>            : {
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :   uint32_t flags = 0;</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :   if ((aBBoxFlags &amp; nsSVGUtils::eBBoxIncludeFillGeometry) ||</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :       ((aBBoxFlags &amp; nsSVGUtils::eBBoxIncludeFill) &amp;&amp;</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :        aRun.mFrame-&gt;StyleSVG()-&gt;mFill.Type() != eStyleSVGPaintType_None)) {</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :     flags |= TextRenderedRun::eIncludeFill;</span>
<span class="lineNum">    3868 </span>            :   }
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :   if ((aBBoxFlags &amp; nsSVGUtils::eBBoxIncludeStrokeGeometry) ||</span>
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :       ((aBBoxFlags &amp; nsSVGUtils::eBBoxIncludeStroke) &amp;&amp;</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :        nsSVGUtils::HasStroke(aRun.mFrame))) {</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :     flags |= TextRenderedRun::eIncludeStroke;</span>
<span class="lineNum">    3873 </span>            :   }
<span class="lineNum">    3874 </span><span class="lineNoCov">          0 :   return flags;</span>
<span class="lineNum">    3875 </span>            : }
<a name="3876"><span class="lineNum">    3876 </span>            : </a>
<span class="lineNum">    3877 </span>            : SVGBBox
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 : SVGTextFrame::GetBBoxContribution(const gfx::Matrix &amp;aToBBoxUserspace,</span>
<span class="lineNum">    3879 </span>            :                                   uint32_t aFlags)
<span class="lineNum">    3880 </span>            : {
<span class="lineNum">    3881 </span><span class="lineNoCov">          0 :   NS_ASSERTION(PrincipalChildList().FirstChild(), &quot;must have a child frame&quot;);</span>
<span class="lineNum">    3882 </span><span class="lineNoCov">          0 :   SVGBBox bbox;</span>
<span class="lineNum">    3883 </span>            : 
<span class="lineNum">    3884 </span><span class="lineNoCov">          0 :   if (aFlags &amp; nsSVGUtils::eForGetClientRects) {</span>
<span class="lineNum">    3885 </span><span class="lineNoCov">          0 :     Rect rect = NSRectToRect(mRect, PresContext()-&gt;AppUnitsPerCSSPixel());</span>
<span class="lineNum">    3886 </span><span class="lineNoCov">          0 :     if (!rect.IsEmpty()) {</span>
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :       bbox = aToBBoxUserspace.TransformBounds(rect);</span>
<span class="lineNum">    3888 </span>            :     }
<span class="lineNum">    3889 </span><span class="lineNoCov">          0 :     return bbox;</span>
<span class="lineNum">    3890 </span>            :   }
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    3893 </span><span class="lineNoCov">          0 :   if (kid &amp;&amp; NS_SUBTREE_DIRTY(kid)) {</span>
<span class="lineNum">    3894 </span>            :     // Return an empty bbox if our kid's subtree is dirty. This may be called
<span class="lineNum">    3895 </span>            :     // in that situation, e.g. when we're building a display list after an
<span class="lineNum">    3896 </span>            :     // interrupted reflow. This can also be called during reflow before we've
<span class="lineNum">    3897 </span>            :     // been reflowed, e.g. if an earlier sibling is calling FinishAndStoreOverflow and
<span class="lineNum">    3898 </span>            :     // needs our parent's perspective matrix, which depends on the SVG bbox
<span class="lineNum">    3899 </span>            :     // contribution of this frame. In the latter situation, when all siblings have
<span class="lineNum">    3900 </span>            :     // been reflowed, the parent will compute its perspective and rerun
<span class="lineNum">    3901 </span>            :     // FinishAndStoreOverflow for all its children.
<span class="lineNum">    3902 </span><span class="lineNoCov">          0 :     return bbox;</span>
<span class="lineNum">    3903 </span>            :   }
<span class="lineNum">    3904 </span>            : 
<span class="lineNum">    3905 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    3906 </span>            : 
<span class="lineNum">    3907 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    3908 </span>            : 
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this);</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :     uint32_t flags = TextRenderedRunFlagsForBBoxContribution(run, aFlags);</span>
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :     gfxMatrix m = ThebesMatrix(aToBBoxUserspace);</span>
<span class="lineNum">    3913 </span>            :     SVGBBox bboxForRun =
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :       run.GetUserSpaceRect(presContext, flags, &amp;m);</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :     bbox.UnionEdges(bboxForRun);</span>
<span class="lineNum">    3916 </span>            :   }
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :   return bbox;</span>
<span class="lineNum">    3919 </span>            : }
<span class="lineNum">    3920 </span>            : 
<span class="lineNum">    3921 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    3922 </span>            : // nsSVGContainerFrame methods
<a name="3923"><span class="lineNum">    3923 </span>            : </a>
<span class="lineNum">    3924 </span>            : gfxMatrix
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 : SVGTextFrame::GetCanvasTM()</span>
<span class="lineNum">    3926 </span>            : {
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :   if (!mCanvasTM) {</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :     NS_ASSERTION(GetParent(), &quot;null parent&quot;);</span>
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!(GetStateBits() &amp; NS_FRAME_IS_NONDISPLAY),</span>
<span class="lineNum">    3930 </span>            :                  &quot;should not call GetCanvasTM() when we are non-display&quot;);
<span class="lineNum">    3931 </span>            : 
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :     nsSVGContainerFrame *parent = static_cast&lt;nsSVGContainerFrame*&gt;(GetParent());</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :     dom::SVGTextContentElement *content = static_cast&lt;dom::SVGTextContentElement*&gt;(mContent);</span>
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :     gfxMatrix tm = content-&gt;PrependLocalTransformsTo(parent-&gt;GetCanvasTM());</span>
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span><span class="lineNoCov">          0 :     mCanvasTM = new gfxMatrix(tm);</span>
<span class="lineNum">    3938 </span>            :   }
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :   return *mCanvasTM;</span>
<span class="lineNum">    3940 </span>            : }
<span class="lineNum">    3941 </span>            : 
<span class="lineNum">    3942 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    3943 </span>            : // SVGTextFrame SVG DOM methods
<span class="lineNum">    3944 </span>            : 
<span class="lineNum">    3945 </span>            : /**
<span class="lineNum">    3946 </span>            :  * Returns whether the specified node has any non-empty nsTextNodes
<span class="lineNum">    3947 </span>            :  * beneath it.
<a name="3948"><span class="lineNum">    3948 </span>            :  */</a>
<span class="lineNum">    3949 </span>            : static bool
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 : HasTextContent(nsIContent* aContent)</span>
<span class="lineNum">    3951 </span>            : {
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aContent, &quot;expected non-null aContent&quot;);</span>
<span class="lineNum">    3953 </span>            : 
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :   TextNodeIterator it(aContent);</span>
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :   for (nsTextNode* text = it.Current(); text; text = it.Next()) {</span>
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :     if (text-&gt;TextLength() != 0) {</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    3958 </span>            :     }
<span class="lineNum">    3959 </span>            :   }
<span class="lineNum">    3960 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    3961 </span>            : }
<span class="lineNum">    3962 </span>            : 
<span class="lineNum">    3963 </span>            : /**
<span class="lineNum">    3964 </span>            :  * Returns the number of DOM characters beneath the specified node.
<a name="3965"><span class="lineNum">    3965 </span>            :  */</a>
<span class="lineNum">    3966 </span>            : static uint32_t
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 : GetTextContentLength(nsIContent* aContent)</span>
<span class="lineNum">    3968 </span>            : {
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aContent, &quot;expected non-null aContent&quot;);</span>
<span class="lineNum">    3970 </span>            : 
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :   uint32_t length = 0;</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :   TextNodeIterator it(aContent);</span>
<span class="lineNum">    3973 </span><span class="lineNoCov">          0 :   for (nsTextNode* text = it.Current(); text; text = it.Next()) {</span>
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :     length += text-&gt;TextLength();</span>
<span class="lineNum">    3975 </span>            :   }
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :   return length;</span>
<span class="lineNum">    3977 </span>            : }
<a name="3978"><span class="lineNum">    3978 </span>            : </a>
<span class="lineNum">    3979 </span>            : int32_t
<span class="lineNum">    3980 </span><span class="lineNoCov">          0 : SVGTextFrame::ConvertTextElementCharIndexToAddressableIndex(</span>
<span class="lineNum">    3981 </span>            :                                                            int32_t aIndex,
<span class="lineNum">    3982 </span>            :                                                            nsIContent* aContent)
<span class="lineNum">    3983 </span>            : {
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eOriginal, aContent);</span>
<span class="lineNum">    3985 </span><span class="lineNoCov">          0 :   if (!it.AdvanceToSubtree()) {</span>
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3987 </span>            :   }
<span class="lineNum">    3988 </span><span class="lineNoCov">          0 :   int32_t result = 0;</span>
<span class="lineNum">    3989 </span>            :   int32_t textElementCharIndex;
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :   while (!it.AtEnd() &amp;&amp;</span>
<span class="lineNum">    3991 </span><span class="lineNoCov">          0 :          it.IsWithinSubtree()) {</span>
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :     bool addressable = !it.IsOriginalCharUnaddressable();</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :     textElementCharIndex = it.TextElementCharIndex();</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :     it.Next();</span>
<span class="lineNum">    3995 </span><span class="lineNoCov">          0 :     uint32_t delta = it.TextElementCharIndex() - textElementCharIndex;</span>
<span class="lineNum">    3996 </span><span class="lineNoCov">          0 :     aIndex -= delta;</span>
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :     if (addressable) {</span>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 :       if (aIndex &lt; 0) {</span>
<span class="lineNum">    3999 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">    4000 </span>            :       }
<span class="lineNum">    4001 </span><span class="lineNoCov">          0 :       result += delta;</span>
<span class="lineNum">    4002 </span>            :     }
<span class="lineNum">    4003 </span>            :   }
<span class="lineNum">    4004 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">    4005 </span>            : }
<span class="lineNum">    4006 </span>            : 
<span class="lineNum">    4007 </span>            : /**
<span class="lineNum">    4008 </span>            :  * Implements the SVG DOM GetNumberOfChars method for the specified
<span class="lineNum">    4009 </span>            :  * text content element.
<a name="4010"><span class="lineNum">    4010 </span>            :  */</a>
<span class="lineNum">    4011 </span>            : uint32_t
<span class="lineNum">    4012 </span><span class="lineNoCov">          0 : SVGTextFrame::GetNumberOfChars(nsIContent* aContent)</span>
<span class="lineNum">    4013 </span>            : {
<span class="lineNum">    4014 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4015 </span>            : 
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 :   uint32_t n = 0;</span>
<span class="lineNum">    4017 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4018 </span><span class="lineNoCov">          0 :   if (it.AdvanceToSubtree()) {</span>
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :     while (!it.AtEnd() &amp;&amp; it.IsWithinSubtree()) {</span>
<span class="lineNum">    4020 </span><span class="lineNoCov">          0 :       n++;</span>
<span class="lineNum">    4021 </span><span class="lineNoCov">          0 :       it.Next();</span>
<span class="lineNum">    4022 </span>            :     }
<span class="lineNum">    4023 </span>            :   }
<span class="lineNum">    4024 </span><span class="lineNoCov">          0 :   return n;</span>
<span class="lineNum">    4025 </span>            : }
<span class="lineNum">    4026 </span>            : 
<span class="lineNum">    4027 </span>            : /**
<span class="lineNum">    4028 </span>            :  * Implements the SVG DOM GetComputedTextLength method for the specified
<span class="lineNum">    4029 </span>            :  * text child element.
<a name="4030"><span class="lineNum">    4030 </span>            :  */</a>
<span class="lineNum">    4031 </span>            : float
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 : SVGTextFrame::GetComputedTextLength(nsIContent* aContent)</span>
<span class="lineNum">    4033 </span>            : {
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :   float cssPxPerDevPx = PresContext()-&gt;</span>
<span class="lineNum">    4037 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(PresContext()-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    4038 </span>            : 
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :   nscoord length = 0;</span>
<span class="lineNum">    4040 </span>            :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames,
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :                              aContent);</span>
<span class="lineNum">    4042 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :     length += run.GetAdvanceWidth();</span>
<span class="lineNum">    4044 </span>            :   }
<span class="lineNum">    4045 </span>            : 
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :   return PresContext()-&gt;AppUnitsToGfxUnits(length) *</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :            cssPxPerDevPx * mLengthAdjustScaleFactor / mFontSizeScaleFactor;</span>
<span class="lineNum">    4048 </span>            : }
<span class="lineNum">    4049 </span>            : 
<span class="lineNum">    4050 </span>            : /**
<span class="lineNum">    4051 </span>            :  * Implements the SVG DOM SelectSubString method for the specified
<span class="lineNum">    4052 </span>            :  * text content element.
<a name="4053"><span class="lineNum">    4053 </span>            :  */</a>
<span class="lineNum">    4054 </span>            : nsresult
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 : SVGTextFrame::SelectSubString(nsIContent* aContent,</span>
<span class="lineNum">    4056 </span>            :                               uint32_t charnum, uint32_t nchars)
<span class="lineNum">    4057 </span>            : {
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span>            :   // Convert charnum/nchars from addressable characters relative to
<span class="lineNum">    4061 </span>            :   // aContent to global character indices.
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :   CharIterator chit(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :   if (!chit.AdvanceToSubtree() ||</span>
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :       !chit.Next(charnum) ||</span>
<span class="lineNum">    4065 </span><span class="lineNoCov">          0 :       chit.IsAfterSubtree()) {</span>
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4067 </span>            :   }
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :   charnum = chit.TextElementCharIndex();</span>
<span class="lineNum">    4069 </span><span class="lineNoCov">          0 :   nsIContent* content = chit.TextFrame()-&gt;GetContent();</span>
<span class="lineNum">    4070 </span><span class="lineNoCov">          0 :   chit.NextWithinSubtree(nchars);</span>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :   nchars = chit.TextElementCharIndex() - charnum;</span>
<span class="lineNum">    4072 </span>            : 
<span class="lineNum">    4073 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsFrameSelection&gt; frameSelection = GetFrameSelection();</span>
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :   frameSelection-&gt;HandleClick(content, charnum, charnum + nchars,</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :                               false, false, CARET_ASSOCIATE_BEFORE);</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4078 </span>            : }
<span class="lineNum">    4079 </span>            : 
<span class="lineNum">    4080 </span>            : /**
<span class="lineNum">    4081 </span>            :  * Implements the SVG DOM GetSubStringLength method for the specified
<span class="lineNum">    4082 </span>            :  * text content element.
<a name="4083"><span class="lineNum">    4083 </span>            :  */</a>
<span class="lineNum">    4084 </span>            : nsresult
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 : SVGTextFrame::GetSubStringLength(nsIContent* aContent,</span>
<span class="lineNum">    4086 </span>            :                                  uint32_t charnum, uint32_t nchars,
<span class="lineNum">    4087 </span>            :                                  float* aResult)
<span class="lineNum">    4088 </span>            : {
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4090 </span>            : 
<span class="lineNum">    4091 </span>            :   // Convert charnum/nchars from addressable characters relative to
<span class="lineNum">    4092 </span>            :   // aContent to global character indices.
<span class="lineNum">    4093 </span><span class="lineNoCov">          0 :   CharIterator chit(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :   if (!chit.AdvanceToSubtree() ||</span>
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :       !chit.Next(charnum) ||</span>
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 :       chit.IsAfterSubtree()) {</span>
<span class="lineNum">    4097 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4098 </span>            :   }
<span class="lineNum">    4099 </span>            : 
<span class="lineNum">    4100 </span><span class="lineNoCov">          0 :   if (nchars == 0) {</span>
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :     *aResult = 0.0f;</span>
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    4103 </span>            :   }
<span class="lineNum">    4104 </span>            : 
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :   charnum = chit.TextElementCharIndex();</span>
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :   chit.NextWithinSubtree(nchars);</span>
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :   nchars = chit.TextElementCharIndex() - charnum;</span>
<span class="lineNum">    4108 </span>            : 
<span class="lineNum">    4109 </span>            :   // Find each rendered run that intersects with the range defined
<span class="lineNum">    4110 </span>            :   // by charnum/nchars.
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :   nscoord textLength = 0;</span>
<span class="lineNum">    4112 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator runIter(this, TextRenderedRunIterator::eAllFrames);</span>
<span class="lineNum">    4113 </span><span class="lineNoCov">          0 :   TextRenderedRun run = runIter.Current();</span>
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :   while (run.mFrame) {</span>
<span class="lineNum">    4115 </span>            :     // If this rendered run is past the substring we are interested in, we
<span class="lineNum">    4116 </span>            :     // are done.
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 :     uint32_t offset = run.mTextElementCharIndex;</span>
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :     if (offset &gt;= charnum + nchars) {</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4120 </span>            :     }
<span class="lineNum">    4121 </span>            : 
<span class="lineNum">    4122 </span>            :     // Intersect the substring we are interested in with the range covered by
<span class="lineNum">    4123 </span>            :     // the rendered run.
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :     uint32_t length = run.mTextFrameContentLength;</span>
<span class="lineNum">    4125 </span><span class="lineNoCov">          0 :     IntersectInterval(offset, length, charnum, nchars);</span>
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :     if (length != 0) {</span>
<span class="lineNum">    4128 </span>            :       // Convert offset into an index into the frame.
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 :       offset += run.mTextFrameContentOffset - run.mTextElementCharIndex;</span>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span>            :       gfxSkipCharsIterator skipCharsIter =
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 :         run.mFrame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 :       gfxTextRun* textRun = run.mFrame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :       Range range = ConvertOriginalToSkipped(skipCharsIter, offset, length);</span>
<span class="lineNum">    4135 </span>            : 
<span class="lineNum">    4136 </span>            :       // Accumulate the advance.
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :       textLength += textRun-&gt;GetAdvanceWidth(range, nullptr);</span>
<span class="lineNum">    4138 </span>            :     }
<span class="lineNum">    4139 </span>            : 
<span class="lineNum">    4140 </span><span class="lineNoCov">          0 :     run = runIter.Next();</span>
<span class="lineNum">    4141 </span>            :   }
<span class="lineNum">    4142 </span>            : 
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    4144 </span>            :   float cssPxPerDevPx = presContext-&gt;
<span class="lineNum">    4145 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span><span class="lineNoCov">          0 :   *aResult = presContext-&gt;AppUnitsToGfxUnits(textLength) *</span>
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 :                cssPxPerDevPx / mFontSizeScaleFactor;</span>
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4150 </span>            : }
<span class="lineNum">    4151 </span>            : 
<span class="lineNum">    4152 </span>            : /**
<span class="lineNum">    4153 </span>            :  * Implements the SVG DOM GetCharNumAtPosition method for the specified
<span class="lineNum">    4154 </span>            :  * text content element.
<a name="4155"><span class="lineNum">    4155 </span>            :  */</a>
<span class="lineNum">    4156 </span>            : int32_t
<span class="lineNum">    4157 </span><span class="lineNoCov">          0 : SVGTextFrame::GetCharNumAtPosition(nsIContent* aContent,</span>
<span class="lineNum">    4158 </span>            :                                    mozilla::nsISVGPoint* aPoint)
<span class="lineNum">    4159 </span>            : {
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4161 </span>            : 
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :   nsPresContext* context = PresContext();</span>
<span class="lineNum">    4163 </span>            : 
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :   gfxPoint p(aPoint-&gt;X(), aPoint-&gt;Y());</span>
<span class="lineNum">    4165 </span>            : 
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 :   int32_t result = -1;</span>
<span class="lineNum">    4167 </span>            : 
<span class="lineNum">    4168 </span><span class="lineNoCov">          0 :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames, aContent);</span>
<span class="lineNum">    4169 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    4170 </span>            :     // Hit test this rendered run.  Later runs will override earlier ones.
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :     int32_t index = run.GetCharNumAtPosition(context, p);</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :     if (index != -1) {</span>
<span class="lineNum">    4173 </span><span class="lineNoCov">          0 :       result = index + run.mTextElementCharIndex;</span>
<span class="lineNum">    4174 </span>            :     }
<span class="lineNum">    4175 </span>            :   }
<span class="lineNum">    4176 </span>            : 
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :   if (result == -1) {</span>
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    4179 </span>            :   }
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :   return ConvertTextElementCharIndexToAddressableIndex(result, aContent);</span>
<span class="lineNum">    4182 </span>            : }
<span class="lineNum">    4183 </span>            : 
<span class="lineNum">    4184 </span>            : /**
<span class="lineNum">    4185 </span>            :  * Implements the SVG DOM GetStartPositionOfChar method for the specified
<span class="lineNum">    4186 </span>            :  * text content element.
<a name="4187"><span class="lineNum">    4187 </span>            :  */</a>
<span class="lineNum">    4188 </span>            : nsresult
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 : SVGTextFrame::GetStartPositionOfChar(nsIContent* aContent,</span>
<span class="lineNum">    4190 </span>            :                                      uint32_t aCharNum,
<span class="lineNum">    4191 </span>            :                                      mozilla::nsISVGPoint** aResult)
<span class="lineNum">    4192 </span>            : {
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4194 </span>            : 
<span class="lineNum">    4195 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :   if (!it.AdvanceToSubtree() ||</span>
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :       !it.Next(aCharNum)) {</span>
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4199 </span>            :   }
<span class="lineNum">    4200 </span>            : 
<span class="lineNum">    4201 </span>            :   // We need to return the start position of the whole glyph.
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :   uint32_t startIndex = it.GlyphStartTextElementCharIndex();</span>
<span class="lineNum">    4203 </span>            : 
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :   NS_ADDREF(*aResult =</span>
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :     new DOMSVGPoint(ToPoint(mPositions[startIndex].mPosition)));</span>
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4207 </span>            : }
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            : /**
<span class="lineNum">    4210 </span>            :  * Implements the SVG DOM GetEndPositionOfChar method for the specified
<span class="lineNum">    4211 </span>            :  * text content element.
<a name="4212"><span class="lineNum">    4212 </span>            :  */</a>
<span class="lineNum">    4213 </span>            : nsresult
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 : SVGTextFrame::GetEndPositionOfChar(nsIContent* aContent,</span>
<span class="lineNum">    4215 </span>            :                                    uint32_t aCharNum,
<span class="lineNum">    4216 </span>            :                                    mozilla::nsISVGPoint** aResult)
<span class="lineNum">    4217 </span>            : {
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4219 </span>            : 
<span class="lineNum">    4220 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :   if (!it.AdvanceToSubtree() ||</span>
<span class="lineNum">    4222 </span><span class="lineNoCov">          0 :       !it.Next(aCharNum)) {</span>
<span class="lineNum">    4223 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4224 </span>            :   }
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span>            :   // We need to return the end position of the whole glyph.
<span class="lineNum">    4227 </span><span class="lineNoCov">          0 :   uint32_t startIndex = it.GlyphStartTextElementCharIndex();</span>
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span>            :   // Get the advance of the glyph.
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :   gfxFloat advance = it.GetGlyphAdvance(PresContext());</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 :   if (it.TextRun()-&gt;IsRightToLeft()) {</span>
<span class="lineNum">    4232 </span><span class="lineNoCov">          0 :     advance = -advance;</span>
<span class="lineNum">    4233 </span>            :   }
<span class="lineNum">    4234 </span>            : 
<span class="lineNum">    4235 </span>            :   // The end position is the start position plus the advance in the direction
<span class="lineNum">    4236 </span>            :   // of the glyph's rotation.
<span class="lineNum">    4237 </span>            :   Matrix m =
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :     Matrix::Rotation(mPositions[startIndex].mAngle) *</span>
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :     Matrix::Translation(ToPoint(mPositions[startIndex].mPosition));</span>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :   Point p = m.TransformPoint(Point(advance / mFontSizeScaleFactor, 0));</span>
<span class="lineNum">    4241 </span>            : 
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :   NS_ADDREF(*aResult = new DOMSVGPoint(p));</span>
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4244 </span>            : }
<span class="lineNum">    4245 </span>            : 
<span class="lineNum">    4246 </span>            : /**
<span class="lineNum">    4247 </span>            :  * Implements the SVG DOM GetExtentOfChar method for the specified
<span class="lineNum">    4248 </span>            :  * text content element.
<a name="4249"><span class="lineNum">    4249 </span>            :  */</a>
<span class="lineNum">    4250 </span>            : nsresult
<span class="lineNum">    4251 </span><span class="lineNoCov">          0 : SVGTextFrame::GetExtentOfChar(nsIContent* aContent,</span>
<span class="lineNum">    4252 </span>            :                               uint32_t aCharNum,
<span class="lineNum">    4253 </span>            :                               dom::SVGIRect** aResult)
<span class="lineNum">    4254 </span>            : {
<span class="lineNum">    4255 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4256 </span>            : 
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4258 </span><span class="lineNoCov">          0 :   if (!it.AdvanceToSubtree() ||</span>
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :       !it.Next(aCharNum)) {</span>
<span class="lineNum">    4260 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4261 </span>            :   }
<span class="lineNum">    4262 </span>            : 
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    4264 </span>            : 
<span class="lineNum">    4265 </span>            :   float cssPxPerDevPx = presContext-&gt;
<span class="lineNum">    4266 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    4267 </span>            : 
<span class="lineNum">    4268 </span>            :   // We need to return the extent of the whole glyph.
<span class="lineNum">    4269 </span><span class="lineNoCov">          0 :   uint32_t startIndex = it.GlyphStartTextElementCharIndex();</span>
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :   // The ascent and descent gives the height of the glyph.
<span class="lineNum">    4272 </span>            :   gfxFloat ascent, descent;
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :   GetAscentAndDescentInAppUnits(it.TextFrame(), ascent, descent);</span>
<span class="lineNum">    4274 </span>            : 
<span class="lineNum">    4275 </span>            :   // Get the advance of the glyph.
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :   gfxFloat advance = it.GetGlyphAdvance(presContext);</span>
<span class="lineNum">    4277 </span><span class="lineNoCov">          0 :   gfxFloat x = it.TextRun()-&gt;IsRightToLeft() ? -advance : 0.0;</span>
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span>            :   // The horizontal extent is the origin of the glyph plus the advance
<span class="lineNum">    4280 </span>            :   // in the direction of the glyph's rotation.
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :   gfxMatrix m;</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :   m.PreTranslate(mPositions[startIndex].mPosition);</span>
<span class="lineNum">    4283 </span><span class="lineNoCov">          0 :   m.PreRotate(mPositions[startIndex].mAngle);</span>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :   m.PreScale(1 / mFontSizeScaleFactor, 1 / mFontSizeScaleFactor);</span>
<span class="lineNum">    4285 </span>            : 
<span class="lineNum">    4286 </span><span class="lineNoCov">          0 :   gfxRect glyphRect;</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :   if (it.TextRun()-&gt;IsVertical()) {</span>
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :     glyphRect =</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :       gfxRect(-presContext-&gt;AppUnitsToGfxUnits(descent) * cssPxPerDevPx, x,</span>
<span class="lineNum">    4290 </span><span class="lineNoCov">          0 :               presContext-&gt;AppUnitsToGfxUnits(ascent + descent) * cssPxPerDevPx,</span>
<span class="lineNum">    4291 </span>            :               advance);
<span class="lineNum">    4292 </span>            :   } else {
<span class="lineNum">    4293 </span><span class="lineNoCov">          0 :     glyphRect =</span>
<span class="lineNum">    4294 </span><span class="lineNoCov">          0 :       gfxRect(x, -presContext-&gt;AppUnitsToGfxUnits(ascent) * cssPxPerDevPx,</span>
<span class="lineNum">    4295 </span>            :               advance,
<span class="lineNum">    4296 </span><span class="lineNoCov">          0 :               presContext-&gt;AppUnitsToGfxUnits(ascent + descent) * cssPxPerDevPx);</span>
<span class="lineNum">    4297 </span>            :   }
<span class="lineNum">    4298 </span>            : 
<span class="lineNum">    4299 </span>            :   // Transform the glyph's rect into user space.
<span class="lineNum">    4300 </span><span class="lineNoCov">          0 :   gfxRect r = m.TransformBounds(glyphRect);</span>
<span class="lineNum">    4301 </span>            : 
<span class="lineNum">    4302 </span><span class="lineNoCov">          0 :   NS_ADDREF(*aResult = new dom::SVGRect(aContent, r.x, r.y, r.width, r.height));</span>
<span class="lineNum">    4303 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4304 </span>            : }
<span class="lineNum">    4305 </span>            : 
<span class="lineNum">    4306 </span>            : /**
<span class="lineNum">    4307 </span>            :  * Implements the SVG DOM GetRotationOfChar method for the specified
<span class="lineNum">    4308 </span>            :  * text content element.
<a name="4309"><span class="lineNum">    4309 </span>            :  */</a>
<span class="lineNum">    4310 </span>            : nsresult
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 : SVGTextFrame::GetRotationOfChar(nsIContent* aContent,</span>
<span class="lineNum">    4312 </span>            :                                 uint32_t aCharNum,
<span class="lineNum">    4313 </span>            :                                 float* aResult)
<span class="lineNum">    4314 </span>            : {
<span class="lineNum">    4315 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    4316 </span>            : 
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eAddressable, aContent);</span>
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :   if (!it.AdvanceToSubtree() ||</span>
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :       !it.Next(aCharNum)) {</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :     return NS_ERROR_DOM_INDEX_SIZE_ERR;</span>
<span class="lineNum">    4321 </span>            :   }
<span class="lineNum">    4322 </span>            : 
<span class="lineNum">    4323 </span><span class="lineNoCov">          0 :   *aResult = mPositions[it.TextElementCharIndex()].mAngle * 180.0 / M_PI;</span>
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4325 </span>            : }
<span class="lineNum">    4326 </span>            : 
<span class="lineNum">    4327 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    4328 </span>            : // SVGTextFrame text layout methods
<span class="lineNum">    4329 </span>            : 
<span class="lineNum">    4330 </span>            : /**
<span class="lineNum">    4331 </span>            :  * Given the character position array before values have been filled in
<span class="lineNum">    4332 </span>            :  * to any unspecified positions, and an array of dx/dy values, returns whether
<span class="lineNum">    4333 </span>            :  * a character at a given index should start a new rendered run.
<span class="lineNum">    4334 </span>            :  *
<span class="lineNum">    4335 </span>            :  * @param aPositions The array of character positions before unspecified
<span class="lineNum">    4336 </span>            :  *   positions have been filled in and dx/dy values have been added to them.
<span class="lineNum">    4337 </span>            :  * @param aDeltas The array of dx/dy values.
<span class="lineNum">    4338 </span>            :  * @param aIndex The character index in question.
<a name="4339"><span class="lineNum">    4339 </span>            :  */</a>
<span class="lineNum">    4340 </span>            : static bool
<span class="lineNum">    4341 </span><span class="lineNoCov">          0 : ShouldStartRunAtIndex(const nsTArray&lt;CharPosition&gt;&amp; aPositions,</span>
<span class="lineNum">    4342 </span>            :                       const nsTArray&lt;gfxPoint&gt;&amp; aDeltas,
<span class="lineNum">    4343 </span>            :                       uint32_t aIndex)
<span class="lineNum">    4344 </span>            : {
<span class="lineNum">    4345 </span><span class="lineNoCov">          0 :   if (aIndex == 0) {</span>
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4347 </span>            :   }
<span class="lineNum">    4348 </span>            : 
<span class="lineNum">    4349 </span><span class="lineNoCov">          0 :   if (aIndex &lt; aPositions.Length()) {</span>
<span class="lineNum">    4350 </span>            :     // If an explicit x or y value was given, start a new run.
<span class="lineNum">    4351 </span><span class="lineNoCov">          0 :     if (aPositions[aIndex].IsXSpecified() ||</span>
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :         aPositions[aIndex].IsYSpecified()) {</span>
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4354 </span>            :     }
<span class="lineNum">    4355 </span>            : 
<span class="lineNum">    4356 </span>            :     // If a non-zero rotation was given, or the previous character had a non-
<span class="lineNum">    4357 </span>            :     // zero rotation, start a new run.
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :     if ((aPositions[aIndex].IsAngleSpecified() &amp;&amp;</span>
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :          aPositions[aIndex].mAngle != 0.0f) ||</span>
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :         (aPositions[aIndex - 1].IsAngleSpecified() &amp;&amp;</span>
<span class="lineNum">    4361 </span><span class="lineNoCov">          0 :          (aPositions[aIndex - 1].mAngle != 0.0f))) {</span>
<span class="lineNum">    4362 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4363 </span>            :     }
<span class="lineNum">    4364 </span>            :   }
<span class="lineNum">    4365 </span>            : 
<span class="lineNum">    4366 </span><span class="lineNoCov">          0 :   if (aIndex &lt; aDeltas.Length()) {</span>
<span class="lineNum">    4367 </span>            :     // If a non-zero dx or dy value was given, start a new run.
<span class="lineNum">    4368 </span><span class="lineNoCov">          0 :     if (aDeltas[aIndex].x != 0.0 ||</span>
<span class="lineNum">    4369 </span><span class="lineNoCov">          0 :         aDeltas[aIndex].y != 0.0) {</span>
<span class="lineNum">    4370 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    4371 </span>            :     }
<span class="lineNum">    4372 </span>            :   }
<span class="lineNum">    4373 </span>            : 
<span class="lineNum">    4374 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    4375 </span>            : }
<a name="4376"><span class="lineNum">    4376 </span>            : </a>
<span class="lineNum">    4377 </span>            : bool
<span class="lineNum">    4378 </span><span class="lineNoCov">          0 : SVGTextFrame::ResolvePositionsForNode(nsIContent* aContent,</span>
<span class="lineNum">    4379 </span>            :                                       uint32_t&amp; aIndex,
<span class="lineNum">    4380 </span>            :                                       bool aInTextPath,
<span class="lineNum">    4381 </span>            :                                       bool&amp; aForceStartOfChunk,
<span class="lineNum">    4382 </span>            :                                       nsTArray&lt;gfxPoint&gt;&amp; aDeltas)
<span class="lineNum">    4383 </span>            : {
<span class="lineNum">    4384 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsNodeOfType(nsINode::eTEXT)) {</span>
<span class="lineNum">    4385 </span>            :     // We found a text node.
<span class="lineNum">    4386 </span><span class="lineNoCov">          0 :     uint32_t length = static_cast&lt;nsTextNode*&gt;(aContent)-&gt;TextLength();</span>
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 :     if (length) {</span>
<span class="lineNum">    4388 </span><span class="lineNoCov">          0 :       uint32_t end = aIndex + length;</span>
<span class="lineNum">    4389 </span><span class="lineNoCov">          0 :       if (MOZ_UNLIKELY(end &gt; mPositions.Length())) {</span>
<span class="lineNum">    4390 </span><span class="lineNoCov">          0 :         MOZ_ASSERT_UNREACHABLE(&quot;length of mPositions does not match characters &quot;</span>
<span class="lineNum">    4391 </span>            :                                &quot;found by iterating content&quot;);
<span class="lineNum">    4392 </span>            :         return false;
<span class="lineNum">    4393 </span>            :       }
<span class="lineNum">    4394 </span><span class="lineNoCov">          0 :       if (aForceStartOfChunk) {</span>
<span class="lineNum">    4395 </span>            :         // Note this character as starting a new anchored chunk.
<span class="lineNum">    4396 </span><span class="lineNoCov">          0 :         mPositions[aIndex].mStartOfChunk = true;</span>
<span class="lineNum">    4397 </span><span class="lineNoCov">          0 :         aForceStartOfChunk = false;</span>
<span class="lineNum">    4398 </span>            :       }
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :       while (aIndex &lt; end) {</span>
<span class="lineNum">    4400 </span>            :         // Record whether each of these characters should start a new rendered
<span class="lineNum">    4401 </span>            :         // run.  That is always the case for characters on a text path.
<span class="lineNum">    4402 </span>            :         //
<span class="lineNum">    4403 </span>            :         // Run boundaries due to rotate=&quot;&quot; values are handled in
<span class="lineNum">    4404 </span>            :         // DoGlyphPositioning.
<span class="lineNum">    4405 </span><span class="lineNoCov">          0 :         if (aInTextPath || ShouldStartRunAtIndex(mPositions, aDeltas, aIndex)) {</span>
<span class="lineNum">    4406 </span><span class="lineNoCov">          0 :           mPositions[aIndex].mRunBoundary = true;</span>
<span class="lineNum">    4407 </span>            :         }
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 :         aIndex++;</span>
<span class="lineNum">    4409 </span>            :       }
<span class="lineNum">    4410 </span>            :     }
<span class="lineNum">    4411 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4412 </span>            :   }
<span class="lineNum">    4413 </span>            : 
<span class="lineNum">    4414 </span>            :   // Skip past elements that aren't text content elements.
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 :   if (!IsTextContentElement(aContent)) {</span>
<span class="lineNum">    4416 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    4417 </span>            :   }
<span class="lineNum">    4418 </span>            : 
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    4420 </span>            :     // &lt;textPath&gt; elements are as if they are specified with x=&quot;0&quot; y=&quot;0&quot;, but
<span class="lineNum">    4421 </span>            :     // only if they actually have some text content.
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :     if (HasTextContent(aContent)) {</span>
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 :       if (MOZ_UNLIKELY(aIndex &gt;= mPositions.Length())) {</span>
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :         MOZ_ASSERT_UNREACHABLE(&quot;length of mPositions does not match characters &quot;</span>
<span class="lineNum">    4425 </span>            :                                &quot;found by iterating content&quot;);
<span class="lineNum">    4426 </span>            :         return false;
<span class="lineNum">    4427 </span>            :       }
<span class="lineNum">    4428 </span><span class="lineNoCov">          0 :       mPositions[aIndex].mPosition = gfxPoint();</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :       mPositions[aIndex].mStartOfChunk = true;</span>
<span class="lineNum">    4430 </span>            :     }
<span class="lineNum">    4431 </span><span class="lineNoCov">          0 :   } else if (!aContent-&gt;IsSVGElement(nsGkAtoms::a)) {</span>
<span class="lineNum">    4432 </span>            :     // We have a text content element that can have x/y/dx/dy/rotate attributes.
<span class="lineNum">    4433 </span><span class="lineNoCov">          0 :     nsSVGElement* element = static_cast&lt;nsSVGElement*&gt;(aContent);</span>
<span class="lineNum">    4434 </span>            : 
<span class="lineNum">    4435 </span>            :     // Get x, y, dx, dy.
<span class="lineNum">    4436 </span><span class="lineNoCov">          0 :     SVGUserUnitList x, y, dx, dy;</span>
<span class="lineNum">    4437 </span><span class="lineNoCov">          0 :     element-&gt;GetAnimatedLengthListValues(&amp;x, &amp;y, &amp;dx, &amp;dy, nullptr);</span>
<span class="lineNum">    4438 </span>            : 
<span class="lineNum">    4439 </span>            :     // Get rotate.
<span class="lineNum">    4440 </span><span class="lineNoCov">          0 :     const SVGNumberList* rotate = nullptr;</span>
<span class="lineNum">    4441 </span>            :     SVGAnimatedNumberList* animatedRotate =
<span class="lineNum">    4442 </span><span class="lineNoCov">          0 :       element-&gt;GetAnimatedNumberList(nsGkAtoms::rotate);</span>
<span class="lineNum">    4443 </span><span class="lineNoCov">          0 :     if (animatedRotate) {</span>
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :       rotate = &amp;animatedRotate-&gt;GetAnimValue();</span>
<span class="lineNum">    4445 </span>            :     }
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span><span class="lineNoCov">          0 :     bool percentages = false;</span>
<span class="lineNum">    4448 </span><span class="lineNoCov">          0 :     uint32_t count = GetTextContentLength(aContent);</span>
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span><span class="lineNoCov">          0 :     if (MOZ_UNLIKELY(aIndex + count &gt; mPositions.Length())) {</span>
<span class="lineNum">    4451 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;length of mPositions does not match characters &quot;</span>
<span class="lineNum">    4452 </span>            :                              &quot;found by iterating content&quot;);
<span class="lineNum">    4453 </span>            :       return false;
<span class="lineNum">    4454 </span>            :     }
<span class="lineNum">    4455 </span>            : 
<span class="lineNum">    4456 </span>            :     // New text anchoring chunks start at each character assigned a position
<span class="lineNum">    4457 </span>            :     // with x=&quot;&quot; or y=&quot;&quot;, or if we forced one with aForceStartOfChunk due to
<span class="lineNum">    4458 </span>            :     // being just after a &lt;textPath&gt;.
<span class="lineNum">    4459 </span><span class="lineNoCov">          0 :     uint32_t newChunkCount = std::max(x.Length(), y.Length());</span>
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :     if (!newChunkCount &amp;&amp; aForceStartOfChunk) {</span>
<span class="lineNum">    4461 </span><span class="lineNoCov">          0 :       newChunkCount = 1;</span>
<span class="lineNum">    4462 </span>            :     }
<span class="lineNum">    4463 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0, j = 0; i &lt; newChunkCount &amp;&amp; j &lt; count; j++) {</span>
<span class="lineNum">    4464 </span><span class="lineNoCov">          0 :       if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4465 </span><span class="lineNoCov">          0 :         mPositions[aIndex + j].mStartOfChunk = true;</span>
<span class="lineNum">    4466 </span><span class="lineNoCov">          0 :         i++;</span>
<span class="lineNum">    4467 </span>            :       }
<span class="lineNum">    4468 </span>            :     }
<span class="lineNum">    4469 </span>            : 
<span class="lineNum">    4470 </span>            :     // Copy dx=&quot;&quot; and dy=&quot;&quot; values into aDeltas.
<span class="lineNum">    4471 </span><span class="lineNoCov">          0 :     if (!dx.IsEmpty() || !dy.IsEmpty()) {</span>
<span class="lineNum">    4472 </span>            :       // Any unspecified deltas when we grow the array just get left as 0s.
<span class="lineNum">    4473 </span><span class="lineNoCov">          0 :       aDeltas.EnsureLengthAtLeast(aIndex + count);</span>
<span class="lineNum">    4474 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0, j = 0; i &lt; dx.Length() &amp;&amp; j &lt; count; j++) {</span>
<span class="lineNum">    4475 </span><span class="lineNoCov">          0 :         if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4476 </span><span class="lineNoCov">          0 :           aDeltas[aIndex + j].x = dx[i];</span>
<span class="lineNum">    4477 </span><span class="lineNoCov">          0 :           percentages = percentages || dx.HasPercentageValueAt(i);</span>
<span class="lineNum">    4478 </span><span class="lineNoCov">          0 :           i++;</span>
<span class="lineNum">    4479 </span>            :         }
<span class="lineNum">    4480 </span>            :       }
<span class="lineNum">    4481 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0, j = 0; i &lt; dy.Length() &amp;&amp; j &lt; count; j++) {</span>
<span class="lineNum">    4482 </span><span class="lineNoCov">          0 :         if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4483 </span><span class="lineNoCov">          0 :           aDeltas[aIndex + j].y = dy[i];</span>
<span class="lineNum">    4484 </span><span class="lineNoCov">          0 :           percentages = percentages || dy.HasPercentageValueAt(i);</span>
<span class="lineNum">    4485 </span><span class="lineNoCov">          0 :           i++;</span>
<span class="lineNum">    4486 </span>            :         }
<span class="lineNum">    4487 </span>            :       }
<span class="lineNum">    4488 </span>            :     }
<span class="lineNum">    4489 </span>            : 
<span class="lineNum">    4490 </span>            :     // Copy x=&quot;&quot; and y=&quot;&quot; values.
<span class="lineNum">    4491 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0, j = 0; i &lt; x.Length() &amp;&amp; j &lt; count; j++) {</span>
<span class="lineNum">    4492 </span><span class="lineNoCov">          0 :       if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4493 </span><span class="lineNoCov">          0 :         mPositions[aIndex + j].mPosition.x = x[i];</span>
<span class="lineNum">    4494 </span><span class="lineNoCov">          0 :         percentages = percentages || x.HasPercentageValueAt(i);</span>
<span class="lineNum">    4495 </span><span class="lineNoCov">          0 :         i++;</span>
<span class="lineNum">    4496 </span>            :       }
<span class="lineNum">    4497 </span>            :     }
<span class="lineNum">    4498 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0, j = 0; i &lt; y.Length() &amp;&amp; j &lt; count; j++) {</span>
<span class="lineNum">    4499 </span><span class="lineNoCov">          0 :       if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4500 </span><span class="lineNoCov">          0 :         mPositions[aIndex + j].mPosition.y = y[i];</span>
<span class="lineNum">    4501 </span><span class="lineNoCov">          0 :         percentages = percentages || y.HasPercentageValueAt(i);</span>
<span class="lineNum">    4502 </span><span class="lineNoCov">          0 :         i++;</span>
<span class="lineNum">    4503 </span>            :       }
<span class="lineNum">    4504 </span>            :     }
<span class="lineNum">    4505 </span>            : 
<span class="lineNum">    4506 </span>            :     // Copy rotate=&quot;&quot; values.
<span class="lineNum">    4507 </span><span class="lineNoCov">          0 :     if (rotate &amp;&amp; !rotate-&gt;IsEmpty()) {</span>
<span class="lineNum">    4508 </span><span class="lineNoCov">          0 :       uint32_t i = 0, j = 0;</span>
<span class="lineNum">    4509 </span><span class="lineNoCov">          0 :       while (i &lt; rotate-&gt;Length() &amp;&amp; j &lt; count) {</span>
<span class="lineNum">    4510 </span><span class="lineNoCov">          0 :         if (!mPositions[aIndex + j].mUnaddressable) {</span>
<span class="lineNum">    4511 </span><span class="lineNoCov">          0 :           mPositions[aIndex + j].mAngle = M_PI * (*rotate)[i] / 180.0;</span>
<span class="lineNum">    4512 </span><span class="lineNoCov">          0 :           i++;</span>
<span class="lineNum">    4513 </span>            :         }
<span class="lineNum">    4514 </span><span class="lineNoCov">          0 :         j++;</span>
<span class="lineNum">    4515 </span>            :       }
<span class="lineNum">    4516 </span>            :       // Propagate final rotate=&quot;&quot; value to the end of this element.
<span class="lineNum">    4517 </span><span class="lineNoCov">          0 :       while (j &lt; count) {</span>
<span class="lineNum">    4518 </span><span class="lineNoCov">          0 :         mPositions[aIndex + j].mAngle = mPositions[aIndex + j - 1].mAngle;</span>
<span class="lineNum">    4519 </span><span class="lineNoCov">          0 :         j++;</span>
<span class="lineNum">    4520 </span>            :       }
<span class="lineNum">    4521 </span>            :     }
<span class="lineNum">    4522 </span>            : 
<span class="lineNum">    4523 </span><span class="lineNoCov">          0 :     if (percentages) {</span>
<span class="lineNum">    4524 </span><span class="lineNoCov">          0 :       AddStateBits(NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES);</span>
<span class="lineNum">    4525 </span>            :     }
<span class="lineNum">    4526 </span>            :   }
<span class="lineNum">    4527 </span>            : 
<span class="lineNum">    4528 </span>            :   // Recurse to children.
<span class="lineNum">    4529 </span><span class="lineNoCov">          0 :   bool inTextPath = aInTextPath || aContent-&gt;IsSVGElement(nsGkAtoms::textPath);</span>
<span class="lineNum">    4530 </span><span class="lineNoCov">          0 :   for (nsIContent* child = aContent-&gt;GetFirstChild();</span>
<span class="lineNum">    4531 </span><span class="lineNoCov">          0 :        child;</span>
<span class="lineNum">    4532 </span><span class="lineNoCov">          0 :        child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">    4533 </span><span class="lineNoCov">          0 :     bool ok = ResolvePositionsForNode(child, aIndex, inTextPath,</span>
<span class="lineNum">    4534 </span><span class="lineNoCov">          0 :                                       aForceStartOfChunk, aDeltas);</span>
<span class="lineNum">    4535 </span><span class="lineNoCov">          0 :     if (!ok) {</span>
<span class="lineNum">    4536 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    4537 </span>            :     }
<span class="lineNum">    4538 </span>            :   }
<span class="lineNum">    4539 </span>            : 
<span class="lineNum">    4540 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsSVGElement(nsGkAtoms::textPath)) {</span>
<span class="lineNum">    4541 </span>            :     // Force a new anchored chunk just after a &lt;textPath&gt;.
<span class="lineNum">    4542 </span><span class="lineNoCov">          0 :     aForceStartOfChunk = true;</span>
<span class="lineNum">    4543 </span>            :   }
<span class="lineNum">    4544 </span>            : 
<span class="lineNum">    4545 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    4546 </span>            : }
<a name="4547"><span class="lineNum">    4547 </span>            : </a>
<span class="lineNum">    4548 </span>            : bool
<span class="lineNum">    4549 </span><span class="lineNoCov">          0 : SVGTextFrame::ResolvePositions(nsTArray&lt;gfxPoint&gt;&amp; aDeltas,</span>
<span class="lineNum">    4550 </span>            :                                bool aRunPerGlyph)
<span class="lineNum">    4551 </span>            : {
<span class="lineNum">    4552 </span><span class="lineNoCov">          0 :   NS_ASSERTION(mPositions.IsEmpty(), &quot;expected mPositions to be empty&quot;);</span>
<span class="lineNum">    4553 </span><span class="lineNoCov">          0 :   RemoveStateBits(NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES);</span>
<span class="lineNum">    4554 </span>            : 
<span class="lineNum">    4555 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eOriginal);</span>
<span class="lineNum">    4556 </span><span class="lineNoCov">          0 :   if (it.AtEnd()) {</span>
<span class="lineNum">    4557 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    4558 </span>            :   }
<span class="lineNum">    4559 </span>            : 
<span class="lineNum">    4560 </span>            :   // We assume the first character position is (0,0) unless we later see
<span class="lineNum">    4561 </span>            :   // otherwise, and note it as unaddressable if it is.
<span class="lineNum">    4562 </span><span class="lineNoCov">          0 :   bool firstCharUnaddressable = it.IsOriginalCharUnaddressable();</span>
<span class="lineNum">    4563 </span><span class="lineNoCov">          0 :   mPositions.AppendElement(CharPosition::Unspecified(firstCharUnaddressable));</span>
<span class="lineNum">    4564 </span>            : 
<span class="lineNum">    4565 </span>            :   // Fill in unspecified positions for all remaining characters, noting
<span class="lineNum">    4566 </span>            :   // them as unaddressable if they are.
<span class="lineNum">    4567 </span><span class="lineNoCov">          0 :   uint32_t index = 0;</span>
<span class="lineNum">    4568 </span><span class="lineNoCov">          0 :   while (it.Next()) {</span>
<span class="lineNum">    4569 </span><span class="lineNoCov">          0 :     while (++index &lt; it.TextElementCharIndex()) {</span>
<span class="lineNum">    4570 </span><span class="lineNoCov">          0 :       mPositions.AppendElement(CharPosition::Unspecified(false));</span>
<span class="lineNum">    4571 </span>            :     }
<span class="lineNum">    4572 </span><span class="lineNoCov">          0 :     mPositions.AppendElement(CharPosition::Unspecified(</span>
<span class="lineNum">    4573 </span><span class="lineNoCov">          0 :                                              it.IsOriginalCharUnaddressable()));</span>
<span class="lineNum">    4574 </span>            :   }
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 :   while (++index &lt; it.TextElementCharIndex()) {</span>
<span class="lineNum">    4576 </span><span class="lineNoCov">          0 :     mPositions.AppendElement(CharPosition::Unspecified(false));</span>
<span class="lineNum">    4577 </span>            :   }
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span>            :   // Recurse over the content and fill in character positions as we go.
<span class="lineNum">    4580 </span><span class="lineNoCov">          0 :   bool forceStartOfChunk = false;</span>
<span class="lineNum">    4581 </span><span class="lineNoCov">          0 :   index = 0;</span>
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :   bool ok = ResolvePositionsForNode(mContent, index, aRunPerGlyph,</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :                                     forceStartOfChunk, aDeltas);</span>
<span class="lineNum">    4584 </span><span class="lineNoCov">          0 :   return ok &amp;&amp; index &gt; 0;</span>
<span class="lineNum">    4585 </span>            : }
<a name="4586"><span class="lineNum">    4586 </span>            : </a>
<span class="lineNum">    4587 </span>            : void
<span class="lineNum">    4588 </span><span class="lineNoCov">          0 : SVGTextFrame::DetermineCharPositions(nsTArray&lt;nsPoint&gt;&amp; aPositions)</span>
<span class="lineNum">    4589 </span>            : {
<span class="lineNum">    4590 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aPositions.IsEmpty(), &quot;expected aPositions to be empty&quot;);</span>
<span class="lineNum">    4591 </span>            : 
<span class="lineNum">    4592 </span><span class="lineNoCov">          0 :   nsPoint position, lastPosition;</span>
<span class="lineNum">    4593 </span>            : 
<span class="lineNum">    4594 </span><span class="lineNoCov">          0 :   TextFrameIterator frit(this);</span>
<span class="lineNum">    4595 </span><span class="lineNoCov">          0 :   for (nsTextFrame* frame = frit.Current(); frame; frame = frit.Next()) {</span>
<span class="lineNum">    4596 </span><span class="lineNoCov">          0 :     gfxSkipCharsIterator it = frame-&gt;EnsureTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    4597 </span><span class="lineNoCov">          0 :     gfxTextRun* textRun = frame-&gt;GetTextRun(nsTextFrame::eInflated);</span>
<span class="lineNum">    4598 </span>            : 
<span class="lineNum">    4599 </span>            :     // Reset the position to the new frame's position.
<span class="lineNum">    4600 </span><span class="lineNoCov">          0 :     position = frit.Position();</span>
<span class="lineNum">    4601 </span><span class="lineNoCov">          0 :     if (textRun-&gt;IsVertical()) {</span>
<span class="lineNum">    4602 </span><span class="lineNoCov">          0 :       if (textRun-&gt;IsRightToLeft()) {</span>
<span class="lineNum">    4603 </span><span class="lineNoCov">          0 :         position.y += frame-&gt;GetRect().height;</span>
<span class="lineNum">    4604 </span>            :       }
<span class="lineNum">    4605 </span><span class="lineNoCov">          0 :       position.x += GetBaselinePosition(frame, textRun,</span>
<span class="lineNum">    4606 </span><span class="lineNoCov">          0 :                                         frit.DominantBaseline(),</span>
<span class="lineNum">    4607 </span><span class="lineNoCov">          0 :                                         mFontSizeScaleFactor);</span>
<span class="lineNum">    4608 </span>            :     } else {
<span class="lineNum">    4609 </span><span class="lineNoCov">          0 :       if (textRun-&gt;IsRightToLeft()) {</span>
<span class="lineNum">    4610 </span><span class="lineNoCov">          0 :         position.x += frame-&gt;GetRect().width;</span>
<span class="lineNum">    4611 </span>            :       }
<span class="lineNum">    4612 </span><span class="lineNoCov">          0 :       position.y += GetBaselinePosition(frame, textRun,</span>
<span class="lineNum">    4613 </span><span class="lineNoCov">          0 :                                         frit.DominantBaseline(),</span>
<span class="lineNum">    4614 </span><span class="lineNoCov">          0 :                                         mFontSizeScaleFactor);</span>
<span class="lineNum">    4615 </span>            :     }
<span class="lineNum">    4616 </span>            : 
<span class="lineNum">    4617 </span>            :     // Any characters not in a frame, e.g. when display:none.
<span class="lineNum">    4618 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; frit.UndisplayedCharacters(); i++) {</span>
<span class="lineNum">    4619 </span><span class="lineNoCov">          0 :       aPositions.AppendElement(position);</span>
<span class="lineNum">    4620 </span>            :     }
<span class="lineNum">    4621 </span>            : 
<span class="lineNum">    4622 </span>            :     // Any white space characters trimmed at the start of the line of text.
<span class="lineNum">    4623 </span>            :     nsTextFrame::TrimmedOffsets trimmedOffsets =
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :       frame-&gt;GetTrimmedOffsets(frame-&gt;GetContent()-&gt;GetText(), true);</span>
<span class="lineNum">    4625 </span><span class="lineNoCov">          0 :     while (it.GetOriginalOffset() &lt; trimmedOffsets.mStart) {</span>
<span class="lineNum">    4626 </span><span class="lineNoCov">          0 :       aPositions.AppendElement(position);</span>
<span class="lineNum">    4627 </span><span class="lineNoCov">          0 :       it.AdvanceOriginal(1);</span>
<span class="lineNum">    4628 </span>            :     }
<span class="lineNum">    4629 </span>            : 
<span class="lineNum">    4630 </span>            :     // If a ligature was started in the previous frame, we should record
<span class="lineNum">    4631 </span>            :     // the ligature's start position, not any partial position.
<span class="lineNum">    4632 </span><span class="lineNoCov">          0 :     while (it.GetOriginalOffset() &lt; frame-&gt;GetContentEnd() &amp;&amp;</span>
<span class="lineNum">    4633 </span><span class="lineNoCov">          0 :            !it.IsOriginalCharSkipped() &amp;&amp;</span>
<span class="lineNum">    4634 </span><span class="lineNoCov">          0 :            (!textRun-&gt;IsLigatureGroupStart(it.GetSkippedOffset()) ||</span>
<span class="lineNum">    4635 </span><span class="lineNoCov">          0 :             !textRun-&gt;IsClusterStart(it.GetSkippedOffset()))) {</span>
<span class="lineNum">    4636 </span><span class="lineNoCov">          0 :       uint32_t offset = it.GetSkippedOffset();</span>
<span class="lineNum">    4637 </span>            :       nscoord advance = textRun-&gt;
<span class="lineNum">    4638 </span><span class="lineNoCov">          0 :         GetAdvanceWidth(Range(offset, offset + 1), nullptr);</span>
<span class="lineNum">    4639 </span><span class="lineNoCov">          0 :       (textRun-&gt;IsVertical() ? position.y : position.x) +=</span>
<span class="lineNum">    4640 </span><span class="lineNoCov">          0 :         textRun-&gt;IsRightToLeft() ? -advance : advance;</span>
<span class="lineNum">    4641 </span><span class="lineNoCov">          0 :       aPositions.AppendElement(lastPosition);</span>
<span class="lineNum">    4642 </span><span class="lineNoCov">          0 :       it.AdvanceOriginal(1);</span>
<span class="lineNum">    4643 </span>            :     }
<span class="lineNum">    4644 </span>            : 
<span class="lineNum">    4645 </span>            :     // The meat of the text frame.
<span class="lineNum">    4646 </span><span class="lineNoCov">          0 :     while (it.GetOriginalOffset() &lt; frame-&gt;GetContentEnd()) {</span>
<span class="lineNum">    4647 </span><span class="lineNoCov">          0 :       aPositions.AppendElement(position);</span>
<span class="lineNum">    4648 </span><span class="lineNoCov">          0 :       if (!it.IsOriginalCharSkipped() &amp;&amp;</span>
<span class="lineNum">    4649 </span><span class="lineNoCov">          0 :           textRun-&gt;IsLigatureGroupStart(it.GetSkippedOffset()) &amp;&amp;</span>
<span class="lineNum">    4650 </span><span class="lineNoCov">          0 :           textRun-&gt;IsClusterStart(it.GetSkippedOffset())) {</span>
<span class="lineNum">    4651 </span>            :         // A real visible character.
<span class="lineNum">    4652 </span>            :         nscoord advance = textRun-&gt;
<span class="lineNum">    4653 </span><span class="lineNoCov">          0 :           GetAdvanceWidth(ClusterRange(textRun, it), nullptr);</span>
<span class="lineNum">    4654 </span><span class="lineNoCov">          0 :         (textRun-&gt;IsVertical() ? position.y : position.x) +=</span>
<span class="lineNum">    4655 </span><span class="lineNoCov">          0 :           textRun-&gt;IsRightToLeft() ? -advance : advance;</span>
<span class="lineNum">    4656 </span><span class="lineNoCov">          0 :         lastPosition = position;</span>
<span class="lineNum">    4657 </span>            :       }
<span class="lineNum">    4658 </span><span class="lineNoCov">          0 :       it.AdvanceOriginal(1);</span>
<span class="lineNum">    4659 </span>            :     }
<span class="lineNum">    4660 </span>            :   }
<span class="lineNum">    4661 </span>            : 
<span class="lineNum">    4662 </span>            :   // Finally any characters at the end that are not in a frame.
<span class="lineNum">    4663 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; frit.UndisplayedCharacters(); i++) {</span>
<span class="lineNum">    4664 </span><span class="lineNoCov">          0 :     aPositions.AppendElement(position);</span>
<span class="lineNum">    4665 </span>            :   }
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4667 </span>            : 
<span class="lineNum">    4668 </span>            : /**
<span class="lineNum">    4669 </span>            :  * Physical text-anchor values.
<span class="lineNum">    4670 </span>            :  */
<span class="lineNum">    4671 </span>            : enum TextAnchorSide {
<span class="lineNum">    4672 </span>            :   eAnchorLeft,
<span class="lineNum">    4673 </span>            :   eAnchorMiddle,
<span class="lineNum">    4674 </span>            :   eAnchorRight
<span class="lineNum">    4675 </span>            : };
<span class="lineNum">    4676 </span>            : 
<span class="lineNum">    4677 </span>            : /**
<span class="lineNum">    4678 </span>            :  * Converts a logical text-anchor value to its physical value, based on whether
<span class="lineNum">    4679 </span>            :  * it is for an RTL frame.
<a name="4680"><span class="lineNum">    4680 </span>            :  */</a>
<span class="lineNum">    4681 </span>            : static TextAnchorSide
<span class="lineNum">    4682 </span><span class="lineNoCov">          0 : ConvertLogicalTextAnchorToPhysical(uint8_t aTextAnchor, bool aIsRightToLeft)</span>
<span class="lineNum">    4683 </span>            : {
<span class="lineNum">    4684 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aTextAnchor &lt;= 3, &quot;unexpected value for aTextAnchor&quot;);</span>
<span class="lineNum">    4685 </span><span class="lineNoCov">          0 :   if (!aIsRightToLeft)</span>
<span class="lineNum">    4686 </span><span class="lineNoCov">          0 :     return TextAnchorSide(aTextAnchor);</span>
<span class="lineNum">    4687 </span><span class="lineNoCov">          0 :   return TextAnchorSide(2 - aTextAnchor);</span>
<span class="lineNum">    4688 </span>            : }
<span class="lineNum">    4689 </span>            : 
<span class="lineNum">    4690 </span>            : /**
<span class="lineNum">    4691 </span>            :  * Shifts the recorded character positions for an anchored chunk.
<span class="lineNum">    4692 </span>            :  *
<span class="lineNum">    4693 </span>            :  * @param aCharPositions The recorded character positions.
<span class="lineNum">    4694 </span>            :  * @param aChunkStart The character index the starts the anchored chunk.  This
<span class="lineNum">    4695 </span>            :  *   character's initial position is the anchor point.
<span class="lineNum">    4696 </span>            :  * @param aChunkEnd The character index just after the end of the anchored
<span class="lineNum">    4697 </span>            :  *   chunk.
<span class="lineNum">    4698 </span>            :  * @param aVisIStartEdge The left/top-most edge of any of the glyphs within the
<span class="lineNum">    4699 </span>            :  *   anchored chunk.
<span class="lineNum">    4700 </span>            :  * @param aVisIEndEdge The right/bottom-most edge of any of the glyphs within
<span class="lineNum">    4701 </span>            :  *   the anchored chunk.
<span class="lineNum">    4702 </span>            :  * @param aAnchorSide The direction to anchor.
<a name="4703"><span class="lineNum">    4703 </span>            :  */</a>
<span class="lineNum">    4704 </span>            : static void
<span class="lineNum">    4705 </span><span class="lineNoCov">          0 : ShiftAnchoredChunk(nsTArray&lt;mozilla::CharPosition&gt;&amp; aCharPositions,</span>
<span class="lineNum">    4706 </span>            :                    uint32_t aChunkStart,
<span class="lineNum">    4707 </span>            :                    uint32_t aChunkEnd,
<span class="lineNum">    4708 </span>            :                    gfxFloat aVisIStartEdge,
<span class="lineNum">    4709 </span>            :                    gfxFloat aVisIEndEdge,
<span class="lineNum">    4710 </span>            :                    TextAnchorSide aAnchorSide,
<span class="lineNum">    4711 </span>            :                    bool aVertical)
<span class="lineNum">    4712 </span>            : {
<span class="lineNum">    4713 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aVisIStartEdge &lt;= aVisIEndEdge,</span>
<span class="lineNum">    4714 </span>            :                &quot;unexpected anchored chunk edges&quot;);
<span class="lineNum">    4715 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aChunkStart &lt; aChunkEnd,</span>
<span class="lineNum">    4716 </span>            :                &quot;unexpected values for aChunkStart and aChunkEnd&quot;);
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span><span class="lineNoCov">          0 :   gfxFloat shift = aVertical ? aCharPositions[aChunkStart].mPosition.y</span>
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 :                              : aCharPositions[aChunkStart].mPosition.x;</span>
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :   switch (aAnchorSide) {</span>
<span class="lineNum">    4721 </span>            :     case eAnchorLeft:
<span class="lineNum">    4722 </span><span class="lineNoCov">          0 :       shift -= aVisIStartEdge;</span>
<span class="lineNum">    4723 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4724 </span>            :     case eAnchorMiddle:
<span class="lineNum">    4725 </span><span class="lineNoCov">          0 :       shift -= (aVisIStartEdge + aVisIEndEdge) / 2;</span>
<span class="lineNum">    4726 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4727 </span>            :     case eAnchorRight:
<span class="lineNum">    4728 </span><span class="lineNoCov">          0 :       shift -= aVisIEndEdge;</span>
<span class="lineNum">    4729 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4730 </span>            :     default:
<span class="lineNum">    4731 </span><span class="lineNoCov">          0 :       NS_NOTREACHED(&quot;unexpected value for aAnchorSide&quot;);</span>
<span class="lineNum">    4732 </span>            :   }
<span class="lineNum">    4733 </span>            : 
<span class="lineNum">    4734 </span><span class="lineNoCov">          0 :   if (shift != 0.0) {</span>
<span class="lineNum">    4735 </span><span class="lineNoCov">          0 :     if (aVertical) {</span>
<span class="lineNum">    4736 </span><span class="lineNoCov">          0 :       for (uint32_t i = aChunkStart; i &lt; aChunkEnd; i++) {</span>
<span class="lineNum">    4737 </span><span class="lineNoCov">          0 :         aCharPositions[i].mPosition.y += shift;</span>
<span class="lineNum">    4738 </span>            :       }
<span class="lineNum">    4739 </span>            :     } else {
<span class="lineNum">    4740 </span><span class="lineNoCov">          0 :       for (uint32_t i = aChunkStart; i &lt; aChunkEnd; i++) {</span>
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 :         aCharPositions[i].mPosition.x += shift;</span>
<span class="lineNum">    4742 </span>            :       }
<span class="lineNum">    4743 </span>            :     }
<span class="lineNum">    4744 </span>            :   }
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 : }</span>
<a name="4746"><span class="lineNum">    4746 </span>            : </a>
<span class="lineNum">    4747 </span>            : void
<span class="lineNum">    4748 </span><span class="lineNoCov">          0 : SVGTextFrame::AdjustChunksForLineBreaks()</span>
<span class="lineNum">    4749 </span>            : {
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(PrincipalChildList().FirstChild());</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :   NS_ASSERTION(block, &quot;expected block frame&quot;);</span>
<span class="lineNum">    4752 </span>            : 
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :   nsBlockFrame::LineIterator line = block-&gt;LinesBegin();</span>
<span class="lineNum">    4754 </span>            : 
<span class="lineNum">    4755 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eOriginal);</span>
<span class="lineNum">    4756 </span><span class="lineNoCov">          0 :   while (!it.AtEnd() &amp;&amp; line != block-&gt;LinesEnd()) {</span>
<span class="lineNum">    4757 </span><span class="lineNoCov">          0 :     if (it.TextFrame() == line-&gt;mFirstChild) {</span>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 :       mPositions[it.TextElementCharIndex()].mStartOfChunk = true;</span>
<span class="lineNum">    4759 </span><span class="lineNoCov">          0 :       line++;</span>
<span class="lineNum">    4760 </span>            :     }
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :     it.AdvancePastCurrentFrame();</span>
<span class="lineNum">    4762 </span>            :   }
<span class="lineNum">    4763 </span><span class="lineNoCov">          0 : }</span>
<a name="4764"><span class="lineNum">    4764 </span>            : </a>
<span class="lineNum">    4765 </span>            : void
<span class="lineNum">    4766 </span><span class="lineNoCov">          0 : SVGTextFrame::AdjustPositionsForClusters()</span>
<span class="lineNum">    4767 </span>            : {
<span class="lineNum">    4768 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    4769 </span>            : 
<span class="lineNum">    4770 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eClusterOrLigatureGroupMiddle);</span>
<span class="lineNum">    4771 </span><span class="lineNoCov">          0 :   while (!it.AtEnd()) {</span>
<span class="lineNum">    4772 </span>            :     // Find the start of the cluster/ligature group.
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :     uint32_t charIndex = it.TextElementCharIndex();</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :     uint32_t startIndex = it.GlyphStartTextElementCharIndex();</span>
<span class="lineNum">    4775 </span>            : 
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :     mPositions[charIndex].mClusterOrLigatureGroupMiddle = true;</span>
<span class="lineNum">    4777 </span>            : 
<span class="lineNum">    4778 </span>            :     // Don't allow different rotations on ligature parts.
<span class="lineNum">    4779 </span><span class="lineNoCov">          0 :     bool rotationAdjusted = false;</span>
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :     double angle = mPositions[startIndex].mAngle;</span>
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 :     if (mPositions[charIndex].mAngle != angle) {</span>
<span class="lineNum">    4782 </span><span class="lineNoCov">          0 :       mPositions[charIndex].mAngle = angle;</span>
<span class="lineNum">    4783 </span><span class="lineNoCov">          0 :       rotationAdjusted = true;</span>
<span class="lineNum">    4784 </span>            :     }
<span class="lineNum">    4785 </span>            : 
<span class="lineNum">    4786 </span>            :     // Find out the partial glyph advance for this character and update
<span class="lineNum">    4787 </span>            :     // the character position.
<span class="lineNum">    4788 </span>            :     uint32_t partLength =
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :       charIndex - startIndex - it.GlyphUndisplayedCharacters();</span>
<span class="lineNum">    4790 </span>            :     gfxFloat advance =
<span class="lineNum">    4791 </span><span class="lineNoCov">          0 :       it.GetGlyphPartialAdvance(partLength, presContext) / mFontSizeScaleFactor;</span>
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :     gfxPoint direction = gfxPoint(cos(angle), sin(angle)) *</span>
<span class="lineNum">    4793 </span><span class="lineNoCov">          0 :                          (it.TextRun()-&gt;IsRightToLeft() ? -1.0 : 1.0);</span>
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :     if (it.TextRun()-&gt;IsVertical()) {</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :       Swap(direction.x, direction.y);</span>
<span class="lineNum">    4796 </span>            :     }
<span class="lineNum">    4797 </span><span class="lineNoCov">          0 :     mPositions[charIndex].mPosition = mPositions[startIndex].mPosition +</span>
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 :                                       direction * advance;</span>
<span class="lineNum">    4799 </span>            : 
<span class="lineNum">    4800 </span>            :     // Ensure any runs that would end in the middle of a ligature now end just
<span class="lineNum">    4801 </span>            :     // after the ligature.
<span class="lineNum">    4802 </span><span class="lineNoCov">          0 :     if (mPositions[charIndex].mRunBoundary) {</span>
<span class="lineNum">    4803 </span><span class="lineNoCov">          0 :       mPositions[charIndex].mRunBoundary = false;</span>
<span class="lineNum">    4804 </span><span class="lineNoCov">          0 :       if (charIndex + 1 &lt; mPositions.Length()) {</span>
<span class="lineNum">    4805 </span><span class="lineNoCov">          0 :         mPositions[charIndex + 1].mRunBoundary = true;</span>
<span class="lineNum">    4806 </span>            :       }
<span class="lineNum">    4807 </span><span class="lineNoCov">          0 :     } else if (rotationAdjusted) {</span>
<span class="lineNum">    4808 </span><span class="lineNoCov">          0 :       if (charIndex + 1 &lt; mPositions.Length()) {</span>
<span class="lineNum">    4809 </span><span class="lineNoCov">          0 :         mPositions[charIndex + 1].mRunBoundary = true;</span>
<span class="lineNum">    4810 </span>            :       }
<span class="lineNum">    4811 </span>            :     }
<span class="lineNum">    4812 </span>            : 
<span class="lineNum">    4813 </span>            :     // Ensure any anchored chunks that would begin in the middle of a ligature
<span class="lineNum">    4814 </span>            :     // now begin just after the ligature.
<span class="lineNum">    4815 </span><span class="lineNoCov">          0 :     if (mPositions[charIndex].mStartOfChunk) {</span>
<span class="lineNum">    4816 </span><span class="lineNoCov">          0 :       mPositions[charIndex].mStartOfChunk = false;</span>
<span class="lineNum">    4817 </span><span class="lineNoCov">          0 :       if (charIndex + 1 &lt; mPositions.Length()) {</span>
<span class="lineNum">    4818 </span><span class="lineNoCov">          0 :         mPositions[charIndex + 1].mStartOfChunk = true;</span>
<span class="lineNum">    4819 </span>            :       }
<span class="lineNum">    4820 </span>            :     }
<span class="lineNum">    4821 </span>            : 
<span class="lineNum">    4822 </span><span class="lineNoCov">          0 :     it.Next();</span>
<span class="lineNum">    4823 </span>            :   }
<span class="lineNum">    4824 </span><span class="lineNoCov">          0 : }</span>
<a name="4825"><span class="lineNum">    4825 </span>            : </a>
<span class="lineNum">    4826 </span>            : SVGPathElement*
<span class="lineNum">    4827 </span><span class="lineNoCov">          0 : SVGTextFrame::GetTextPathPathElement(nsIFrame* aTextPathFrame)</span>
<span class="lineNum">    4828 </span>            : {
<span class="lineNum">    4829 </span>            :   nsSVGTextPathProperty *property =
<span class="lineNum">    4830 </span><span class="lineNoCov">          0 :     aTextPathFrame-&gt;GetProperty(nsSVGEffects::HrefAsTextPathProperty());</span>
<span class="lineNum">    4831 </span>            : 
<span class="lineNum">    4832 </span><span class="lineNoCov">          0 :   if (!property) {</span>
<span class="lineNum">    4833 </span><span class="lineNoCov">          0 :     nsIContent* content = aTextPathFrame-&gt;GetContent();</span>
<span class="lineNum">    4834 </span><span class="lineNoCov">          0 :     dom::SVGTextPathElement* tp = static_cast&lt;dom::SVGTextPathElement*&gt;(content);</span>
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :     nsAutoString href;</span>
<span class="lineNum">    4836 </span><span class="lineNoCov">          0 :     if (tp-&gt;mStringAttributes[dom::SVGTextPathElement::HREF].IsExplicitlySet()) {</span>
<span class="lineNum">    4837 </span>            :       tp-&gt;mStringAttributes[dom::SVGTextPathElement::HREF]
<span class="lineNum">    4838 </span><span class="lineNoCov">          0 :         .GetAnimValue(href, tp);</span>
<span class="lineNum">    4839 </span>            :     } else {
<span class="lineNum">    4840 </span>            :       tp-&gt;mStringAttributes[dom::SVGTextPathElement::XLINK_HREF]
<span class="lineNum">    4841 </span><span class="lineNoCov">          0 :         .GetAnimValue(href, tp);</span>
<span class="lineNum">    4842 </span>            :     }
<span class="lineNum">    4843 </span>            : 
<span class="lineNum">    4844 </span><span class="lineNoCov">          0 :     if (href.IsEmpty()) {</span>
<span class="lineNum">    4845 </span><span class="lineNoCov">          0 :       return nullptr; // no URL</span>
<span class="lineNum">    4846 </span>            :     }
<span class="lineNum">    4847 </span>            : 
<span class="lineNum">    4848 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIURI&gt; targetURI;</span>
<span class="lineNum">    4849 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIURI&gt; base = content-&gt;GetBaseURI();</span>
<span class="lineNum">    4850 </span><span class="lineNoCov">          0 :     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), href,</span>
<span class="lineNum">    4851 </span><span class="lineNoCov">          0 :                                               content-&gt;GetUncomposedDoc(), base);</span>
<span class="lineNum">    4852 </span>            : 
<span class="lineNum">    4853 </span><span class="lineNoCov">          0 :     property = nsSVGEffects::GetTextPathProperty(</span>
<span class="lineNum">    4854 </span>            :       targetURI,
<span class="lineNum">    4855 </span>            :       aTextPathFrame,
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :       nsSVGEffects::HrefAsTextPathProperty());</span>
<span class="lineNum">    4857 </span><span class="lineNoCov">          0 :     if (!property)</span>
<span class="lineNum">    4858 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    4859 </span>            :   }
<span class="lineNum">    4860 </span>            : 
<span class="lineNum">    4861 </span><span class="lineNoCov">          0 :   Element* element = property-&gt;GetReferencedElement();</span>
<span class="lineNum">    4862 </span><span class="lineNoCov">          0 :   return (element &amp;&amp; element-&gt;IsSVGElement(nsGkAtoms::path)) ?</span>
<span class="lineNum">    4863 </span><span class="lineNoCov">          0 :     static_cast&lt;SVGPathElement*&gt;(element) : nullptr;</span>
<span class="lineNum">    4864 </span>            : }
<a name="4865"><span class="lineNum">    4865 </span>            : </a>
<span class="lineNum">    4866 </span>            : already_AddRefed&lt;Path&gt;
<span class="lineNum">    4867 </span><span class="lineNoCov">          0 : SVGTextFrame::GetTextPath(nsIFrame* aTextPathFrame)</span>
<span class="lineNum">    4868 </span>            : {
<span class="lineNum">    4869 </span><span class="lineNoCov">          0 :   SVGPathElement* element = GetTextPathPathElement(aTextPathFrame);</span>
<span class="lineNum">    4870 </span><span class="lineNoCov">          0 :   if (!element) {</span>
<span class="lineNum">    4871 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4872 </span>            :   }
<span class="lineNum">    4873 </span>            : 
<span class="lineNum">    4874 </span><span class="lineNoCov">          0 :   RefPtr&lt;Path&gt; path = element-&gt;GetOrBuildPathForMeasuring();</span>
<span class="lineNum">    4875 </span><span class="lineNoCov">          0 :   if (!path) {</span>
<span class="lineNum">    4876 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    4877 </span>            :   }
<span class="lineNum">    4878 </span>            : 
<span class="lineNum">    4879 </span><span class="lineNoCov">          0 :   gfxMatrix matrix = element-&gt;PrependLocalTransformsTo(gfxMatrix());</span>
<span class="lineNum">    4880 </span><span class="lineNoCov">          0 :   if (!matrix.IsIdentity()) {</span>
<span class="lineNum">    4881 </span>            :     RefPtr&lt;PathBuilder&gt; builder =
<span class="lineNum">    4882 </span><span class="lineNoCov">          0 :       path-&gt;TransformedCopyToBuilder(ToMatrix(matrix));</span>
<span class="lineNum">    4883 </span><span class="lineNoCov">          0 :     path = builder-&gt;Finish();</span>
<span class="lineNum">    4884 </span>            :   }
<span class="lineNum">    4885 </span>            : 
<span class="lineNum">    4886 </span><span class="lineNoCov">          0 :   return path.forget();</span>
<span class="lineNum">    4887 </span>            : }
<a name="4888"><span class="lineNum">    4888 </span>            : </a>
<span class="lineNum">    4889 </span>            : gfxFloat
<span class="lineNum">    4890 </span><span class="lineNoCov">          0 : SVGTextFrame::GetOffsetScale(nsIFrame* aTextPathFrame)</span>
<span class="lineNum">    4891 </span>            : {
<span class="lineNum">    4892 </span><span class="lineNoCov">          0 :   SVGPathElement* pathElement = GetTextPathPathElement(aTextPathFrame);</span>
<span class="lineNum">    4893 </span><span class="lineNoCov">          0 :   if (!pathElement)</span>
<span class="lineNum">    4894 </span><span class="lineNoCov">          0 :     return 1.0;</span>
<span class="lineNum">    4895 </span>            : 
<span class="lineNum">    4896 </span><span class="lineNoCov">          0 :   return pathElement-&gt;GetPathLengthScale(dom::SVGPathElement::eForTextPath);</span>
<span class="lineNum">    4897 </span>            : }
<a name="4898"><span class="lineNum">    4898 </span>            : </a>
<span class="lineNum">    4899 </span>            : gfxFloat
<span class="lineNum">    4900 </span><span class="lineNoCov">          0 : SVGTextFrame::GetStartOffset(nsIFrame* aTextPathFrame)</span>
<span class="lineNum">    4901 </span>            : {
<span class="lineNum">    4902 </span>            :   dom::SVGTextPathElement *tp =
<span class="lineNum">    4903 </span><span class="lineNoCov">          0 :     static_cast&lt;dom::SVGTextPathElement*&gt;(aTextPathFrame-&gt;GetContent());</span>
<span class="lineNum">    4904 </span>            :   nsSVGLength2 *length =
<span class="lineNum">    4905 </span><span class="lineNoCov">          0 :     &amp;tp-&gt;mLengthAttributes[dom::SVGTextPathElement::STARTOFFSET];</span>
<span class="lineNum">    4906 </span>            : 
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :   if (length-&gt;IsPercentage()) {</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :     RefPtr&lt;Path&gt; data = GetTextPath(aTextPathFrame);</span>
<span class="lineNum">    4909 </span><span class="lineNoCov">          0 :     return data ?</span>
<span class="lineNum">    4910 </span><span class="lineNoCov">          0 :       length-&gt;GetAnimValInSpecifiedUnits() * data-&gt;ComputeLength() / 100.0 :</span>
<span class="lineNum">    4911 </span><span class="lineNoCov">          0 :       0.0;</span>
<span class="lineNum">    4912 </span>            :   }
<span class="lineNum">    4913 </span><span class="lineNoCov">          0 :   return length-&gt;GetAnimValue(tp) * GetOffsetScale(aTextPathFrame);</span>
<span class="lineNum">    4914 </span>            : }
<a name="4915"><span class="lineNum">    4915 </span>            : </a>
<span class="lineNum">    4916 </span>            : void
<span class="lineNum">    4917 </span><span class="lineNoCov">          0 : SVGTextFrame::DoTextPathLayout()</span>
<span class="lineNum">    4918 </span>            : {
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :   nsPresContext* context = PresContext();</span>
<span class="lineNum">    4920 </span>            : 
<span class="lineNum">    4921 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eClusterAndLigatureGroupStart);</span>
<span class="lineNum">    4922 </span><span class="lineNoCov">          0 :   while (!it.AtEnd()) {</span>
<span class="lineNum">    4923 </span><span class="lineNoCov">          0 :     nsIFrame* textPathFrame = it.TextPathFrame();</span>
<span class="lineNum">    4924 </span><span class="lineNoCov">          0 :     if (!textPathFrame) {</span>
<span class="lineNum">    4925 </span>            :       // Skip past this frame if we're not in a text path.
<span class="lineNum">    4926 </span><span class="lineNoCov">          0 :       it.AdvancePastCurrentFrame();</span>
<span class="lineNum">    4927 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    4928 </span>            :     }
<span class="lineNum">    4929 </span>            : 
<span class="lineNum">    4930 </span>            :     // Get the path itself.
<span class="lineNum">    4931 </span><span class="lineNoCov">          0 :     RefPtr&lt;Path&gt; path = GetTextPath(textPathFrame);</span>
<span class="lineNum">    4932 </span><span class="lineNoCov">          0 :     if (!path) {</span>
<span class="lineNum">    4933 </span><span class="lineNoCov">          0 :       it.AdvancePastCurrentTextPathFrame();</span>
<span class="lineNum">    4934 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    4935 </span>            :     }
<span class="lineNum">    4936 </span>            : 
<span class="lineNum">    4937 </span><span class="lineNoCov">          0 :     nsIContent* textPath = textPathFrame-&gt;GetContent();</span>
<span class="lineNum">    4938 </span>            : 
<span class="lineNum">    4939 </span><span class="lineNoCov">          0 :     gfxFloat offset = GetStartOffset(textPathFrame);</span>
<span class="lineNum">    4940 </span><span class="lineNoCov">          0 :     Float pathLength = path-&gt;ComputeLength();</span>
<span class="lineNum">    4941 </span>            : 
<span class="lineNum">    4942 </span>            :     // Loop for each text frame in the text path.
<span class="lineNum">    4943 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    4944 </span><span class="lineNoCov">          0 :       uint32_t i = it.TextElementCharIndex();</span>
<span class="lineNum">    4945 </span>            :       gfxFloat halfAdvance =
<span class="lineNum">    4946 </span><span class="lineNoCov">          0 :         it.GetGlyphAdvance(context) / mFontSizeScaleFactor / 2.0;</span>
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :       gfxFloat sign = it.TextRun()-&gt;IsRightToLeft() ? -1.0 : 1.0;</span>
<span class="lineNum">    4948 </span><span class="lineNoCov">          0 :       bool vertical = it.TextRun()-&gt;IsVertical();</span>
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :       gfxFloat midx = (vertical ? mPositions[i].mPosition.y</span>
<span class="lineNum">    4950 </span><span class="lineNoCov">          0 :                                 : mPositions[i].mPosition.x) +</span>
<span class="lineNum">    4951 </span><span class="lineNoCov">          0 :                       sign * halfAdvance + offset;</span>
<span class="lineNum">    4952 </span>            : 
<span class="lineNum">    4953 </span>            :       // Hide the character if it falls off the end of the path.
<span class="lineNum">    4954 </span><span class="lineNoCov">          0 :       mPositions[i].mHidden = midx &lt; 0 || midx &gt; pathLength;</span>
<span class="lineNum">    4955 </span>            : 
<span class="lineNum">    4956 </span>            :       // Position the character on the path at the right angle.
<span class="lineNum">    4957 </span><span class="lineNoCov">          0 :       Point tangent; // Unit vector tangent to the point we find.</span>
<span class="lineNum">    4958 </span><span class="lineNoCov">          0 :       Point pt = path-&gt;ComputePointAtLength(Float(midx), &amp;tangent);</span>
<span class="lineNum">    4959 </span><span class="lineNoCov">          0 :       Float rotation = vertical ? atan2f(-tangent.x, tangent.y)</span>
<span class="lineNum">    4960 </span><span class="lineNoCov">          0 :                                 : atan2f(tangent.y, tangent.x);</span>
<span class="lineNum">    4961 </span><span class="lineNoCov">          0 :       Point normal(-tangent.y, tangent.x); // Unit vector normal to the point.</span>
<span class="lineNum">    4962 </span><span class="lineNoCov">          0 :       Point offsetFromPath = normal * (vertical ? -mPositions[i].mPosition.x</span>
<span class="lineNum">    4963 </span><span class="lineNoCov">          0 :                                                 : mPositions[i].mPosition.y);</span>
<span class="lineNum">    4964 </span><span class="lineNoCov">          0 :       pt += offsetFromPath;</span>
<span class="lineNum">    4965 </span><span class="lineNoCov">          0 :       Point direction = tangent * sign;</span>
<span class="lineNum">    4966 </span><span class="lineNoCov">          0 :       mPositions[i].mPosition = ThebesPoint(pt) - ThebesPoint(direction) * halfAdvance;</span>
<span class="lineNum">    4967 </span><span class="lineNoCov">          0 :       mPositions[i].mAngle += rotation;</span>
<span class="lineNum">    4968 </span>            : 
<span class="lineNum">    4969 </span>            :       // Position any characters for a partial ligature.
<span class="lineNum">    4970 </span><span class="lineNoCov">          0 :       for (uint32_t j = i + 1;</span>
<span class="lineNum">    4971 </span><span class="lineNoCov">          0 :            j &lt; mPositions.Length() &amp;&amp; mPositions[j].mClusterOrLigatureGroupMiddle;</span>
<span class="lineNum">    4972 </span>            :            j++) {
<span class="lineNum">    4973 </span>            :         gfxPoint partialAdvance =
<span class="lineNum">    4974 </span><span class="lineNoCov">          0 :           ThebesPoint(direction) * it.GetGlyphPartialAdvance(j - i, context) /</span>
<span class="lineNum">    4975 </span><span class="lineNoCov">          0 :                                                          mFontSizeScaleFactor;</span>
<span class="lineNum">    4976 </span><span class="lineNoCov">          0 :         mPositions[j].mPosition = mPositions[i].mPosition + partialAdvance;</span>
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :         mPositions[j].mAngle = mPositions[i].mAngle;</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :         mPositions[j].mHidden = mPositions[i].mHidden;</span>
<span class="lineNum">    4979 </span>            :       }
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 :       it.Next();</span>
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :     } while (it.TextPathFrame() &amp;&amp;</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 :              it.TextPathFrame()-&gt;GetContent() == textPath);</span>
<span class="lineNum">    4983 </span>            :   }
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 : }</span>
<a name="4985"><span class="lineNum">    4985 </span>            : </a>
<span class="lineNum">    4986 </span>            : void
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 : SVGTextFrame::DoAnchoring()</span>
<span class="lineNum">    4988 </span>            : {
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    4990 </span>            : 
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :   CharIterator it(this, CharIterator::eOriginal);</span>
<span class="lineNum">    4992 </span>            : 
<span class="lineNum">    4993 </span>            :   // Don't need to worry about skipped or trimmed characters.
<span class="lineNum">    4994 </span><span class="lineNoCov">          0 :   while (!it.AtEnd() &amp;&amp;</span>
<span class="lineNum">    4995 </span><span class="lineNoCov">          0 :          (it.IsOriginalCharSkipped() || it.IsOriginalCharTrimmed())) {</span>
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :     it.Next();</span>
<span class="lineNum">    4997 </span>            :   }
<span class="lineNum">    4998 </span>            : 
<span class="lineNum">    4999 </span><span class="lineNoCov">          0 :   bool vertical = GetWritingMode().IsVertical();</span>
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 :   uint32_t start = it.TextElementCharIndex();</span>
<span class="lineNum">    5001 </span><span class="lineNoCov">          0 :   while (start &lt; mPositions.Length()) {</span>
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :     it.AdvanceToCharacter(start);</span>
<span class="lineNum">    5003 </span><span class="lineNoCov">          0 :     nsTextFrame* chunkFrame = it.TextFrame();</span>
<span class="lineNum">    5004 </span>            : 
<span class="lineNum">    5005 </span>            :     // Measure characters in this chunk to find the left-most and right-most
<span class="lineNum">    5006 </span>            :     // edges of all glyphs within the chunk.
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :     uint32_t index = it.TextElementCharIndex();</span>
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :     uint32_t end = start;</span>
<span class="lineNum">    5009 </span><span class="lineNoCov">          0 :     gfxFloat left = std::numeric_limits&lt;gfxFloat&gt;::infinity();</span>
<span class="lineNum">    5010 </span><span class="lineNoCov">          0 :     gfxFloat right = -std::numeric_limits&lt;gfxFloat&gt;::infinity();</span>
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :       if (!it.IsOriginalCharSkipped() &amp;&amp; !it.IsOriginalCharTrimmed()) {</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :         gfxFloat advance = it.GetAdvance(presContext) / mFontSizeScaleFactor;</span>
<span class="lineNum">    5014 </span>            :         gfxFloat pos =
<span class="lineNum">    5015 </span><span class="lineNoCov">          0 :           it.TextRun()-&gt;IsVertical() ? mPositions[index].mPosition.y</span>
<span class="lineNum">    5016 </span><span class="lineNoCov">          0 :                                      : mPositions[index].mPosition.x;</span>
<span class="lineNum">    5017 </span><span class="lineNoCov">          0 :         if (it.TextRun()-&gt;IsRightToLeft()) {</span>
<span class="lineNum">    5018 </span><span class="lineNoCov">          0 :           left  = std::min(left,  pos - advance);</span>
<span class="lineNum">    5019 </span><span class="lineNoCov">          0 :           right = std::max(right, pos);</span>
<span class="lineNum">    5020 </span>            :         } else {
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :           left  = std::min(left,  pos);</span>
<span class="lineNum">    5022 </span><span class="lineNoCov">          0 :           right = std::max(right, pos + advance);</span>
<span class="lineNum">    5023 </span>            :         }
<span class="lineNum">    5024 </span>            :       }
<span class="lineNum">    5025 </span><span class="lineNoCov">          0 :       it.Next();</span>
<span class="lineNum">    5026 </span><span class="lineNoCov">          0 :       index = end = it.TextElementCharIndex();</span>
<span class="lineNum">    5027 </span><span class="lineNoCov">          0 :     } while (!it.AtEnd() &amp;&amp; !mPositions[end].mStartOfChunk);</span>
<span class="lineNum">    5028 </span>            : 
<span class="lineNum">    5029 </span><span class="lineNoCov">          0 :     if (left != std::numeric_limits&lt;gfxFloat&gt;::infinity()) {</span>
<span class="lineNum">    5030 </span>            :       bool isRTL =
<span class="lineNum">    5031 </span><span class="lineNoCov">          0 :         chunkFrame-&gt;StyleVisibility()-&gt;mDirection == NS_STYLE_DIRECTION_RTL;</span>
<span class="lineNum">    5032 </span>            :       TextAnchorSide anchor =
<span class="lineNum">    5033 </span><span class="lineNoCov">          0 :         ConvertLogicalTextAnchorToPhysical(chunkFrame-&gt;StyleSVG()-&gt;mTextAnchor,</span>
<span class="lineNum">    5034 </span><span class="lineNoCov">          0 :                                            isRTL);</span>
<span class="lineNum">    5035 </span>            : 
<span class="lineNum">    5036 </span><span class="lineNoCov">          0 :       ShiftAnchoredChunk(mPositions, start, end, left, right, anchor,</span>
<span class="lineNum">    5037 </span><span class="lineNoCov">          0 :                          vertical);</span>
<span class="lineNum">    5038 </span>            :     }
<span class="lineNum">    5039 </span>            : 
<span class="lineNum">    5040 </span><span class="lineNoCov">          0 :     start = it.TextElementCharIndex();</span>
<span class="lineNum">    5041 </span>            :   }
<span class="lineNum">    5042 </span><span class="lineNoCov">          0 : }</span>
<a name="5043"><span class="lineNum">    5043 </span>            : </a>
<span class="lineNum">    5044 </span>            : void
<span class="lineNum">    5045 </span><span class="lineNoCov">          0 : SVGTextFrame::DoGlyphPositioning()</span>
<span class="lineNum">    5046 </span>            : {
<span class="lineNum">    5047 </span><span class="lineNoCov">          0 :   mPositions.Clear();</span>
<span class="lineNum">    5048 </span><span class="lineNoCov">          0 :   RemoveStateBits(NS_STATE_SVG_POSITIONING_DIRTY);</span>
<span class="lineNum">    5049 </span>            : 
<span class="lineNum">    5050 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    5051 </span><span class="lineNoCov">          0 :   if (kid &amp;&amp; NS_SUBTREE_DIRTY(kid)) {</span>
<span class="lineNum">    5052 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;should have already reflowed the kid&quot;);</span>
<span class="lineNum">    5053 </span>            :     return;
<span class="lineNum">    5054 </span>            :   }
<span class="lineNum">    5055 </span>            : 
<span class="lineNum">    5056 </span>            :   // Determine the positions of each character in app units.
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 :   nsTArray&lt;nsPoint&gt; charPositions;</span>
<span class="lineNum">    5058 </span><span class="lineNoCov">          0 :   DetermineCharPositions(charPositions);</span>
<span class="lineNum">    5059 </span>            : 
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :   if (charPositions.IsEmpty()) {</span>
<span class="lineNum">    5061 </span>            :     // No characters, so nothing to do.
<span class="lineNum">    5062 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5063 </span>            :   }
<span class="lineNum">    5064 </span>            : 
<span class="lineNum">    5065 </span>            :   // If the textLength=&quot;&quot; attribute was specified, then we need ResolvePositions
<span class="lineNum">    5066 </span>            :   // to record that a new run starts with each glyph.
<span class="lineNum">    5067 </span><span class="lineNoCov">          0 :   SVGTextContentElement* element = static_cast&lt;SVGTextContentElement*&gt;(mContent);</span>
<span class="lineNum">    5068 </span>            :   nsSVGLength2* textLengthAttr =
<span class="lineNum">    5069 </span><span class="lineNoCov">          0 :     element-&gt;GetAnimatedLength(nsGkAtoms::textLength);</span>
<span class="lineNum">    5070 </span><span class="lineNoCov">          0 :   bool adjustingTextLength = textLengthAttr-&gt;IsExplicitlySet();</span>
<span class="lineNum">    5071 </span><span class="lineNoCov">          0 :   float expectedTextLength = textLengthAttr-&gt;GetAnimValue(element);</span>
<span class="lineNum">    5072 </span>            : 
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 :   if (adjustingTextLength &amp;&amp; expectedTextLength &lt; 0.0f) {</span>
<span class="lineNum">    5074 </span>            :     // If textLength=&quot;&quot; is less than zero, ignore it.
<span class="lineNum">    5075 </span><span class="lineNoCov">          0 :     adjustingTextLength = false;</span>
<span class="lineNum">    5076 </span>            :   }
<span class="lineNum">    5077 </span>            : 
<span class="lineNum">    5078 </span>            :   // Get the x, y, dx, dy, rotate values for the subtree.
<span class="lineNum">    5079 </span><span class="lineNoCov">          0 :   nsTArray&lt;gfxPoint&gt; deltas;</span>
<span class="lineNum">    5080 </span><span class="lineNoCov">          0 :   if (!ResolvePositions(deltas, adjustingTextLength)) {</span>
<span class="lineNum">    5081 </span>            :     // If ResolvePositions returned false, it means either there were some
<span class="lineNum">    5082 </span>            :     // characters in the DOM but none of them are displayed, or there was
<span class="lineNum">    5083 </span>            :     // an error in processing mPositions.  Clear out mPositions so that we don't
<span class="lineNum">    5084 </span>            :     // attempt to do any painting later.
<span class="lineNum">    5085 </span><span class="lineNoCov">          0 :     mPositions.Clear();</span>
<span class="lineNum">    5086 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5087 </span>            :   }
<span class="lineNum">    5088 </span>            : 
<span class="lineNum">    5089 </span>            :   // XXX We might be able to do less work when there is at most a single
<span class="lineNum">    5090 </span>            :   // x/y/dx/dy position.
<span class="lineNum">    5091 </span>            : 
<span class="lineNum">    5092 </span>            :   // Truncate the positioning arrays to the actual number of characters present.
<span class="lineNum">    5093 </span><span class="lineNoCov">          0 :   TruncateTo(deltas, charPositions);</span>
<span class="lineNum">    5094 </span><span class="lineNoCov">          0 :   TruncateTo(mPositions, charPositions);</span>
<span class="lineNum">    5095 </span>            : 
<span class="lineNum">    5096 </span>            :   // Fill in an unspecified character position at index 0.
<span class="lineNum">    5097 </span><span class="lineNoCov">          0 :   if (!mPositions[0].IsXSpecified()) {</span>
<span class="lineNum">    5098 </span><span class="lineNoCov">          0 :     mPositions[0].mPosition.x = 0.0;</span>
<span class="lineNum">    5099 </span>            :   }
<span class="lineNum">    5100 </span><span class="lineNoCov">          0 :   if (!mPositions[0].IsYSpecified()) {</span>
<span class="lineNum">    5101 </span><span class="lineNoCov">          0 :     mPositions[0].mPosition.y = 0.0;</span>
<span class="lineNum">    5102 </span>            :   }
<span class="lineNum">    5103 </span><span class="lineNoCov">          0 :   if (!mPositions[0].IsAngleSpecified()) {</span>
<span class="lineNum">    5104 </span><span class="lineNoCov">          0 :     mPositions[0].mAngle = 0.0;</span>
<span class="lineNum">    5105 </span>            :   }
<span class="lineNum">    5106 </span>            : 
<span class="lineNum">    5107 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    5108 </span><span class="lineNoCov">          0 :   bool vertical = GetWritingMode().IsVertical();</span>
<span class="lineNum">    5109 </span>            : 
<span class="lineNum">    5110 </span>            :   float cssPxPerDevPx = presContext-&gt;
<span class="lineNum">    5111 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    5112 </span><span class="lineNoCov">          0 :   double factor = cssPxPerDevPx / mFontSizeScaleFactor;</span>
<span class="lineNum">    5113 </span>            : 
<span class="lineNum">    5114 </span>            :   // Determine how much to compress or expand glyph positions due to
<span class="lineNum">    5115 </span>            :   // textLength=&quot;&quot; and lengthAdjust=&quot;&quot;.
<span class="lineNum">    5116 </span><span class="lineNoCov">          0 :   double adjustment = 0.0;</span>
<span class="lineNum">    5117 </span><span class="lineNoCov">          0 :   mLengthAdjustScaleFactor = 1.0f;</span>
<span class="lineNum">    5118 </span><span class="lineNoCov">          0 :   if (adjustingTextLength) {</span>
<span class="lineNum">    5119 </span><span class="lineNoCov">          0 :     nscoord frameLength = vertical ? PrincipalChildList().FirstChild()-&gt;GetRect().height</span>
<span class="lineNum">    5120 </span><span class="lineNoCov">          0 :                                    : PrincipalChildList().FirstChild()-&gt;GetRect().width;</span>
<span class="lineNum">    5121 </span>            :     float actualTextLength =
<span class="lineNum">    5122 </span><span class="lineNoCov">          0 :       static_cast&lt;float&gt;(presContext-&gt;AppUnitsToGfxUnits(frameLength) * factor);</span>
<span class="lineNum">    5123 </span>            : 
<span class="lineNum">    5124 </span><span class="lineNoCov">          0 :     RefPtr&lt;SVGAnimatedEnumeration&gt; lengthAdjustEnum = element-&gt;LengthAdjust();</span>
<span class="lineNum">    5125 </span><span class="lineNoCov">          0 :     uint16_t lengthAdjust = lengthAdjustEnum-&gt;AnimVal();</span>
<span class="lineNum">    5126 </span><span class="lineNoCov">          0 :     switch (lengthAdjust) {</span>
<span class="lineNum">    5127 </span>            :       case SVG_LENGTHADJUST_SPACINGANDGLYPHS:
<span class="lineNum">    5128 </span>            :         // Scale the glyphs and their positions.
<span class="lineNum">    5129 </span><span class="lineNoCov">          0 :         if (actualTextLength &gt; 0) {</span>
<span class="lineNum">    5130 </span><span class="lineNoCov">          0 :           mLengthAdjustScaleFactor = expectedTextLength / actualTextLength;</span>
<span class="lineNum">    5131 </span>            :         }
<span class="lineNum">    5132 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5133 </span>            : 
<span class="lineNum">    5134 </span>            :       default:
<span class="lineNum">    5135 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(lengthAdjust == SVG_LENGTHADJUST_SPACING);</span>
<span class="lineNum">    5136 </span>            :         // Just add space between each glyph.
<span class="lineNum">    5137 </span><span class="lineNoCov">          0 :         int32_t adjustableSpaces = 0;</span>
<span class="lineNum">    5138 </span><span class="lineNoCov">          0 :         for (uint32_t i = 1; i &lt; mPositions.Length(); i++) {</span>
<span class="lineNum">    5139 </span><span class="lineNoCov">          0 :           if (!mPositions[i].mUnaddressable) {</span>
<span class="lineNum">    5140 </span><span class="lineNoCov">          0 :             adjustableSpaces++;</span>
<span class="lineNum">    5141 </span>            :           }
<span class="lineNum">    5142 </span>            :         }
<span class="lineNum">    5143 </span><span class="lineNoCov">          0 :         if (adjustableSpaces) {</span>
<span class="lineNum">    5144 </span><span class="lineNoCov">          0 :           adjustment = (expectedTextLength - actualTextLength) / adjustableSpaces;</span>
<span class="lineNum">    5145 </span>            :         }
<span class="lineNum">    5146 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5147 </span>            :     }
<span class="lineNum">    5148 </span>            :   }
<span class="lineNum">    5149 </span>            : 
<span class="lineNum">    5150 </span>            :   // Fill in any unspecified character positions based on the positions recorded
<span class="lineNum">    5151 </span>            :   // in charPositions, and also add in the dx/dy values.
<span class="lineNum">    5152 </span><span class="lineNoCov">          0 :   if (!deltas.IsEmpty()) {</span>
<span class="lineNum">    5153 </span><span class="lineNoCov">          0 :     mPositions[0].mPosition += deltas[0];</span>
<span class="lineNum">    5154 </span>            :   }
<span class="lineNum">    5155 </span>            : 
<span class="lineNum">    5156 </span><span class="lineNoCov">          0 :   gfxFloat xLengthAdjustFactor = vertical ? 1.0 : mLengthAdjustScaleFactor;</span>
<span class="lineNum">    5157 </span><span class="lineNoCov">          0 :   gfxFloat yLengthAdjustFactor = vertical ? mLengthAdjustScaleFactor : 1.0;</span>
<span class="lineNum">    5158 </span><span class="lineNoCov">          0 :   for (uint32_t i = 1; i &lt; mPositions.Length(); i++) {</span>
<span class="lineNum">    5159 </span>            :     // Fill in unspecified x position.
<span class="lineNum">    5160 </span><span class="lineNoCov">          0 :     if (!mPositions[i].IsXSpecified()) {</span>
<span class="lineNum">    5161 </span><span class="lineNoCov">          0 :       nscoord d = charPositions[i].x - charPositions[i - 1].x;</span>
<span class="lineNum">    5162 </span><span class="lineNoCov">          0 :       mPositions[i].mPosition.x =</span>
<span class="lineNum">    5163 </span><span class="lineNoCov">          0 :         mPositions[i - 1].mPosition.x +</span>
<span class="lineNum">    5164 </span><span class="lineNoCov">          0 :         presContext-&gt;AppUnitsToGfxUnits(d) * factor * xLengthAdjustFactor;</span>
<span class="lineNum">    5165 </span><span class="lineNoCov">          0 :       if (!vertical &amp;&amp; !mPositions[i].mUnaddressable) {</span>
<span class="lineNum">    5166 </span><span class="lineNoCov">          0 :         mPositions[i].mPosition.x += adjustment;</span>
<span class="lineNum">    5167 </span>            :       }
<span class="lineNum">    5168 </span>            :     }
<span class="lineNum">    5169 </span>            :     // Fill in unspecified y position.
<span class="lineNum">    5170 </span><span class="lineNoCov">          0 :     if (!mPositions[i].IsYSpecified()) {</span>
<span class="lineNum">    5171 </span><span class="lineNoCov">          0 :       nscoord d = charPositions[i].y - charPositions[i - 1].y;</span>
<span class="lineNum">    5172 </span><span class="lineNoCov">          0 :       mPositions[i].mPosition.y =</span>
<span class="lineNum">    5173 </span><span class="lineNoCov">          0 :         mPositions[i - 1].mPosition.y +</span>
<span class="lineNum">    5174 </span><span class="lineNoCov">          0 :         presContext-&gt;AppUnitsToGfxUnits(d) * factor * yLengthAdjustFactor;</span>
<span class="lineNum">    5175 </span><span class="lineNoCov">          0 :       if (vertical &amp;&amp; !mPositions[i].mUnaddressable) {</span>
<span class="lineNum">    5176 </span><span class="lineNoCov">          0 :         mPositions[i].mPosition.y += adjustment;</span>
<span class="lineNum">    5177 </span>            :       }
<span class="lineNum">    5178 </span>            :     }
<span class="lineNum">    5179 </span>            :     // Add in dx/dy.
<span class="lineNum">    5180 </span><span class="lineNoCov">          0 :     if (i &lt; deltas.Length()) {</span>
<span class="lineNum">    5181 </span><span class="lineNoCov">          0 :       mPositions[i].mPosition += deltas[i];</span>
<span class="lineNum">    5182 </span>            :     }
<span class="lineNum">    5183 </span>            :     // Fill in unspecified rotation values.
<span class="lineNum">    5184 </span><span class="lineNoCov">          0 :     if (!mPositions[i].IsAngleSpecified()) {</span>
<span class="lineNum">    5185 </span><span class="lineNoCov">          0 :       mPositions[i].mAngle = 0.0f;</span>
<span class="lineNum">    5186 </span>            :     }
<span class="lineNum">    5187 </span>            :   }
<span class="lineNum">    5188 </span>            : 
<span class="lineNum">    5189 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mPositions.Length() == charPositions.Length());</span>
<span class="lineNum">    5190 </span>            : 
<span class="lineNum">    5191 </span><span class="lineNoCov">          0 :   AdjustChunksForLineBreaks();</span>
<span class="lineNum">    5192 </span><span class="lineNoCov">          0 :   AdjustPositionsForClusters();</span>
<span class="lineNum">    5193 </span><span class="lineNoCov">          0 :   DoAnchoring();</span>
<span class="lineNum">    5194 </span><span class="lineNoCov">          0 :   DoTextPathLayout();</span>
<span class="lineNum">    5195 </span>            : }
<a name="5196"><span class="lineNum">    5196 </span>            : </a>
<span class="lineNum">    5197 </span>            : bool
<span class="lineNum">    5198 </span><span class="lineNoCov">          0 : SVGTextFrame::ShouldRenderAsPath(nsTextFrame* aFrame,</span>
<span class="lineNum">    5199 </span>            :                                  bool&amp; aShouldPaintSVGGlyphs)
<span class="lineNum">    5200 </span>            : {
<span class="lineNum">    5201 </span>            :   // Rendering to a clip path.
<span class="lineNum">    5202 </span><span class="lineNoCov">          0 :   if (HasAnyStateBits(NS_STATE_SVG_CLIPPATH_CHILD)) {</span>
<span class="lineNum">    5203 </span><span class="lineNoCov">          0 :     aShouldPaintSVGGlyphs = false;</span>
<span class="lineNum">    5204 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5205 </span>            :   }
<span class="lineNum">    5206 </span>            : 
<span class="lineNum">    5207 </span><span class="lineNoCov">          0 :   aShouldPaintSVGGlyphs = true;</span>
<span class="lineNum">    5208 </span>            : 
<span class="lineNum">    5209 </span><span class="lineNoCov">          0 :   const nsStyleSVG* style = aFrame-&gt;StyleSVG();</span>
<span class="lineNum">    5210 </span>            : 
<span class="lineNum">    5211 </span>            :   // Fill is a non-solid paint, has a non-default fill-rule or has
<span class="lineNum">    5212 </span>            :   // non-1 opacity.
<span class="lineNum">    5213 </span><span class="lineNoCov">          0 :   if (!(style-&gt;mFill.Type() == eStyleSVGPaintType_None ||</span>
<span class="lineNum">    5214 </span><span class="lineNoCov">          0 :         (style-&gt;mFill.Type() == eStyleSVGPaintType_Color &amp;&amp;</span>
<span class="lineNum">    5215 </span><span class="lineNoCov">          0 :          style-&gt;mFillOpacity == 1))) {</span>
<span class="lineNum">    5216 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5217 </span>            :   }
<span class="lineNum">    5218 </span>            : 
<span class="lineNum">    5219 </span>            :   // Text has a stroke.
<span class="lineNum">    5220 </span><span class="lineNoCov">          0 :   if (style-&gt;HasStroke() &amp;&amp;</span>
<span class="lineNum">    5221 </span><span class="lineNoCov">          0 :       SVGContentUtils::CoordToFloat(static_cast&lt;nsSVGElement*&gt;(mContent),</span>
<span class="lineNum">    5222 </span>            :                                     style-&gt;mStrokeWidth) &gt; 0) {
<span class="lineNum">    5223 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    5224 </span>            :   }
<span class="lineNum">    5225 </span>            : 
<span class="lineNum">    5226 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    5227 </span>            : }
<a name="5228"><span class="lineNum">    5228 </span>            : </a>
<span class="lineNum">    5229 </span>            : void
<span class="lineNum">    5230 </span><span class="lineNoCov">          0 : SVGTextFrame::ScheduleReflowSVG()</span>
<span class="lineNum">    5231 </span>            : {
<span class="lineNum">    5232 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    5233 </span><span class="lineNoCov">          0 :     ScheduleReflowSVGNonDisplayText(nsIPresShell::eStyleChange);</span>
<span class="lineNum">    5234 </span>            :   } else {
<span class="lineNum">    5235 </span><span class="lineNoCov">          0 :     nsSVGUtils::ScheduleReflowSVG(this);</span>
<span class="lineNum">    5236 </span>            :   }
<span class="lineNum">    5237 </span><span class="lineNoCov">          0 : }</span>
<a name="5238"><span class="lineNum">    5238 </span>            : </a>
<span class="lineNum">    5239 </span>            : void
<span class="lineNum">    5240 </span><span class="lineNoCov">          0 : SVGTextFrame::NotifyGlyphMetricsChange()</span>
<span class="lineNum">    5241 </span>            : {
<span class="lineNum">    5242 </span><span class="lineNoCov">          0 :   AddStateBits(NS_STATE_SVG_POSITIONING_DIRTY);</span>
<span class="lineNum">    5243 </span><span class="lineNoCov">          0 :   nsLayoutUtils::PostRestyleEvent(</span>
<span class="lineNum">    5244 </span><span class="lineNoCov">          0 :     mContent-&gt;AsElement(), nsRestyleHint(0),</span>
<span class="lineNum">    5245 </span><span class="lineNoCov">          0 :     nsChangeHint_InvalidateRenderingObservers);</span>
<span class="lineNum">    5246 </span><span class="lineNoCov">          0 :   ScheduleReflowSVG();</span>
<span class="lineNum">    5247 </span><span class="lineNoCov">          0 : }</span>
<a name="5248"><span class="lineNum">    5248 </span>            : </a>
<span class="lineNum">    5249 </span>            : void
<span class="lineNum">    5250 </span><span class="lineNoCov">          0 : SVGTextFrame::UpdateGlyphPositioning()</span>
<span class="lineNum">    5251 </span>            : {
<span class="lineNum">    5252 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    5253 </span><span class="lineNoCov">          0 :   if (!kid) {</span>
<span class="lineNum">    5254 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5255 </span>            :   }
<span class="lineNum">    5256 </span>            : 
<span class="lineNum">    5257 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_STATE_SVG_POSITIONING_DIRTY) {</span>
<span class="lineNum">    5258 </span><span class="lineNoCov">          0 :     DoGlyphPositioning();</span>
<span class="lineNum">    5259 </span>            :   }
<span class="lineNum">    5260 </span>            : }
<a name="5261"><span class="lineNum">    5261 </span>            : </a>
<span class="lineNum">    5262 </span>            : void
<span class="lineNum">    5263 </span><span class="lineNoCov">          0 : SVGTextFrame::MaybeReflowAnonymousBlockChild()</span>
<span class="lineNum">    5264 </span>            : {
<span class="lineNum">    5265 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    5266 </span><span class="lineNoCov">          0 :   if (!kid)</span>
<span class="lineNum">    5267 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5268 </span>            : 
<span class="lineNum">    5269 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!(kid-&gt;GetStateBits() &amp; NS_FRAME_IN_REFLOW),</span>
<span class="lineNum">    5270 </span>            :                &quot;should not be in reflow when about to reflow again&quot;);
<span class="lineNum">    5271 </span>            : 
<span class="lineNum">    5272 </span><span class="lineNoCov">          0 :   if (NS_SUBTREE_DIRTY(this)) {</span>
<span class="lineNum">    5273 </span><span class="lineNoCov">          0 :     if (mState &amp; NS_FRAME_IS_DIRTY) {</span>
<span class="lineNum">    5274 </span>            :       // If we require a full reflow, ensure our kid is marked fully dirty.
<span class="lineNum">    5275 </span>            :       // (Note that our anonymous nsBlockFrame is not an nsSVGDisplayableFrame, so
<span class="lineNum">    5276 </span>            :       // even when we are called via our ReflowSVG this will not be done for us
<span class="lineNum">    5277 </span>            :       // by nsSVGDisplayContainerFrame::ReflowSVG.)
<span class="lineNum">    5278 </span><span class="lineNoCov">          0 :       kid-&gt;AddStateBits(NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    5279 </span>            :     }
<span class="lineNum">    5280 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(nsSVGUtils::AnyOuterSVGIsCallingReflowSVG(this),</span>
<span class="lineNum">    5281 </span>            :                &quot;should be under ReflowSVG&quot;);
<span class="lineNum">    5282 </span><span class="lineNoCov">          0 :     nsPresContext::InterruptPreventer noInterrupts(PresContext());</span>
<span class="lineNum">    5283 </span><span class="lineNoCov">          0 :     DoReflow();</span>
<span class="lineNum">    5284 </span>            :   }
<span class="lineNum">    5285 </span>            : }
<a name="5286"><span class="lineNum">    5286 </span>            : </a>
<span class="lineNum">    5287 </span>            : void
<span class="lineNum">    5288 </span><span class="lineNoCov">          0 : SVGTextFrame::DoReflow()</span>
<span class="lineNum">    5289 </span>            : {
<span class="lineNum">    5290 </span>            :   // Since we are going to reflow the anonymous block frame, we will
<span class="lineNum">    5291 </span>            :   // need to update mPositions.
<span class="lineNum">    5292 </span><span class="lineNoCov">          0 :   AddStateBits(NS_STATE_SVG_POSITIONING_DIRTY);</span>
<span class="lineNum">    5293 </span>            : 
<span class="lineNum">    5294 </span><span class="lineNoCov">          0 :   if (mState &amp; NS_FRAME_IS_NONDISPLAY) {</span>
<span class="lineNum">    5295 </span>            :     // Normally, these dirty flags would be cleared in ReflowSVG(), but that
<span class="lineNum">    5296 </span>            :     // doesn't get called for non-display frames. We don't want to reflow our
<span class="lineNum">    5297 </span>            :     // descendants every time SVGTextFrame::PaintSVG makes sure that we have
<span class="lineNum">    5298 </span>            :     // valid positions by calling UpdateGlyphPositioning(), so we need to clear
<span class="lineNum">    5299 </span>            :     // these dirty bits. Note that this also breaks an invalidation loop where
<span class="lineNum">    5300 </span>            :     // our descendants invalidate as they reflow, which invalidates rendering
<span class="lineNum">    5301 </span>            :     // observers, which reschedules the frame that is currently painting by
<span class="lineNum">    5302 </span>            :     // referencing us to paint again. See bug 839958 comment 7. Hopefully we
<span class="lineNum">    5303 </span>            :     // will break that loop more convincingly at some point.
<span class="lineNum">    5304 </span><span class="lineNoCov">          0 :     mState &amp;= ~(NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    5305 </span>            :   }
<span class="lineNum">    5306 </span>            : 
<span class="lineNum">    5307 </span><span class="lineNoCov">          0 :   nsPresContext *presContext = PresContext();</span>
<span class="lineNum">    5308 </span><span class="lineNoCov">          0 :   nsIFrame* kid = PrincipalChildList().FirstChild();</span>
<span class="lineNum">    5309 </span><span class="lineNoCov">          0 :   if (!kid)</span>
<span class="lineNum">    5310 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5311 </span>            : 
<span class="lineNum">    5312 </span>            :   RefPtr&lt;gfxContext&gt; renderingContext =
<span class="lineNum">    5313 </span><span class="lineNoCov">          0 :     presContext-&gt;PresShell()-&gt;CreateReferenceRenderingContext();</span>
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span><span class="lineNoCov">          0 :   if (UpdateFontSizeScaleFactor()) {</span>
<span class="lineNum">    5316 </span>            :     // If the font size scale factor changed, we need the block to report
<span class="lineNum">    5317 </span>            :     // an updated preferred width.
<span class="lineNum">    5318 </span><span class="lineNoCov">          0 :     kid-&gt;MarkIntrinsicISizesDirty();</span>
<span class="lineNum">    5319 </span>            :   }
<span class="lineNum">    5320 </span>            : 
<span class="lineNum">    5321 </span><span class="lineNoCov">          0 :   mState |= NS_STATE_SVG_TEXT_IN_REFLOW;</span>
<span class="lineNum">    5322 </span>            : 
<span class="lineNum">    5323 </span><span class="lineNoCov">          0 :   nscoord inlineSize = kid-&gt;GetPrefISize(renderingContext);</span>
<span class="lineNum">    5324 </span><span class="lineNoCov">          0 :   WritingMode wm = kid-&gt;GetWritingMode();</span>
<span class="lineNum">    5325 </span>            :   ReflowInput reflowInput(presContext, kid,
<span class="lineNum">    5326 </span>            :                                 renderingContext,
<span class="lineNum">    5327 </span><span class="lineNoCov">          0 :                                 LogicalSize(wm, inlineSize,</span>
<span class="lineNum">    5328 </span><span class="lineNoCov">          0 :                                             NS_UNCONSTRAINEDSIZE));</span>
<span class="lineNum">    5329 </span><span class="lineNoCov">          0 :   ReflowOutput desiredSize(reflowInput);</span>
<span class="lineNum">    5330 </span><span class="lineNoCov">          0 :   nsReflowStatus status;</span>
<span class="lineNum">    5331 </span>            : 
<span class="lineNum">    5332 </span><span class="lineNoCov">          0 :   NS_ASSERTION(reflowInput.ComputedPhysicalBorderPadding() == nsMargin(0, 0, 0, 0) &amp;&amp;</span>
<span class="lineNum">    5333 </span>            :                reflowInput.ComputedPhysicalMargin() == nsMargin(0, 0, 0, 0),
<span class="lineNum">    5334 </span>            :                &quot;style system should ensure that :-moz-svg-text &quot;
<span class="lineNum">    5335 </span>            :                &quot;does not get styled&quot;);
<span class="lineNum">    5336 </span>            : 
<span class="lineNum">    5337 </span><span class="lineNoCov">          0 :   kid-&gt;Reflow(presContext, desiredSize, reflowInput, status);</span>
<span class="lineNum">    5338 </span><span class="lineNoCov">          0 :   kid-&gt;DidReflow(presContext, &amp;reflowInput, nsDidReflowStatus::FINISHED);</span>
<span class="lineNum">    5339 </span><span class="lineNoCov">          0 :   kid-&gt;SetSize(wm, desiredSize.Size(wm));</span>
<span class="lineNum">    5340 </span>            : 
<span class="lineNum">    5341 </span><span class="lineNoCov">          0 :   mState &amp;= ~NS_STATE_SVG_TEXT_IN_REFLOW;</span>
<span class="lineNum">    5342 </span>            : 
<span class="lineNum">    5343 </span><span class="lineNoCov">          0 :   TextNodeCorrespondenceRecorder::RecordCorrespondence(this);</span>
<span class="lineNum">    5344 </span>            : }
<span class="lineNum">    5345 </span>            : 
<span class="lineNum">    5346 </span>            : // Usable font size range in devpixels / user-units
<span class="lineNum">    5347 </span>            : #define CLAMP_MIN_SIZE 8.0
<span class="lineNum">    5348 </span>            : #define CLAMP_MAX_SIZE 200.0
<span class="lineNum">    5349 </span>            : #define PRECISE_SIZE   200.0
<a name="5350"><span class="lineNum">    5350 </span>            : </a>
<span class="lineNum">    5351 </span>            : bool
<span class="lineNum">    5352 </span><span class="lineNoCov">          0 : SVGTextFrame::UpdateFontSizeScaleFactor()</span>
<span class="lineNum">    5353 </span>            : {
<span class="lineNum">    5354 </span><span class="lineNoCov">          0 :   double oldFontSizeScaleFactor = mFontSizeScaleFactor;</span>
<span class="lineNum">    5355 </span>            : 
<span class="lineNum">    5356 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span><span class="lineNoCov">          0 :   bool geometricPrecision = false;</span>
<span class="lineNum">    5359 </span><span class="lineNoCov">          0 :   nscoord min = nscoord_MAX,</span>
<span class="lineNum">    5360 </span><span class="lineNoCov">          0 :           max = nscoord_MIN;</span>
<span class="lineNum">    5361 </span>            : 
<span class="lineNum">    5362 </span>            :   // Find the minimum and maximum font sizes used over all the
<span class="lineNum">    5363 </span>            :   // nsTextFrames.
<span class="lineNum">    5364 </span><span class="lineNoCov">          0 :   TextFrameIterator it(this);</span>
<span class="lineNum">    5365 </span><span class="lineNoCov">          0 :   nsTextFrame* f = it.Current();</span>
<span class="lineNum">    5366 </span><span class="lineNoCov">          0 :   while (f) {</span>
<span class="lineNum">    5367 </span><span class="lineNoCov">          0 :     if (!geometricPrecision) {</span>
<span class="lineNum">    5368 </span>            :       // Unfortunately we can't treat text-rendering:geometricPrecision
<span class="lineNum">    5369 </span>            :       // separately for each text frame.
<span class="lineNum">    5370 </span><span class="lineNoCov">          0 :       geometricPrecision = f-&gt;StyleText()-&gt;mTextRendering ==</span>
<span class="lineNum">    5371 </span>            :                              NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION;
<span class="lineNum">    5372 </span>            :     }
<span class="lineNum">    5373 </span><span class="lineNoCov">          0 :     nscoord size = f-&gt;StyleFont()-&gt;mFont.size;</span>
<span class="lineNum">    5374 </span><span class="lineNoCov">          0 :     if (size) {</span>
<span class="lineNum">    5375 </span><span class="lineNoCov">          0 :       min = std::min(min, size);</span>
<span class="lineNum">    5376 </span><span class="lineNoCov">          0 :       max = std::max(max, size);</span>
<span class="lineNum">    5377 </span>            :     }
<span class="lineNum">    5378 </span><span class="lineNoCov">          0 :     f = it.Next();</span>
<span class="lineNum">    5379 </span>            :   }
<span class="lineNum">    5380 </span>            : 
<span class="lineNum">    5381 </span><span class="lineNoCov">          0 :   if (min == nscoord_MAX) {</span>
<span class="lineNum">    5382 </span>            :     // No text, so no need for scaling.
<span class="lineNum">    5383 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = 1.0;</span>
<span class="lineNum">    5384 </span><span class="lineNoCov">          0 :     return mFontSizeScaleFactor != oldFontSizeScaleFactor;</span>
<span class="lineNum">    5385 </span>            :   }
<span class="lineNum">    5386 </span>            : 
<span class="lineNum">    5387 </span><span class="lineNoCov">          0 :   double minSize = presContext-&gt;AppUnitsToFloatCSSPixels(min);</span>
<span class="lineNum">    5388 </span>            : 
<span class="lineNum">    5389 </span><span class="lineNoCov">          0 :   if (geometricPrecision) {</span>
<span class="lineNum">    5390 </span>            :     // We want to ensure minSize is scaled to PRECISE_SIZE.
<span class="lineNum">    5391 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = PRECISE_SIZE / minSize;</span>
<span class="lineNum">    5392 </span><span class="lineNoCov">          0 :     return mFontSizeScaleFactor != oldFontSizeScaleFactor;</span>
<span class="lineNum">    5393 </span>            :   }
<span class="lineNum">    5394 </span>            : 
<span class="lineNum">    5395 </span>            :   // When we are non-display, we could be painted in different coordinate
<span class="lineNum">    5396 </span>            :   // spaces, and we don't want to have to reflow for each of these.  We
<span class="lineNum">    5397 </span>            :   // just assume that the context scale is 1.0 for them all, so we don't
<span class="lineNum">    5398 </span>            :   // get stuck with a font size scale factor based on whichever referencing
<span class="lineNum">    5399 </span>            :   // frame happens to reflow first.
<span class="lineNum">    5400 </span><span class="lineNoCov">          0 :   double contextScale = 1.0;</span>
<span class="lineNum">    5401 </span><span class="lineNoCov">          0 :   if (!(mState &amp; NS_FRAME_IS_NONDISPLAY)) {</span>
<span class="lineNum">    5402 </span><span class="lineNoCov">          0 :     gfxMatrix m(GetCanvasTM());</span>
<span class="lineNum">    5403 </span><span class="lineNoCov">          0 :     if (!m.IsSingular()) {</span>
<span class="lineNum">    5404 </span><span class="lineNoCov">          0 :       contextScale = GetContextScale(m);</span>
<span class="lineNum">    5405 </span>            :     }
<span class="lineNum">    5406 </span>            :   }
<span class="lineNum">    5407 </span><span class="lineNoCov">          0 :   mLastContextScale = contextScale;</span>
<span class="lineNum">    5408 </span>            : 
<span class="lineNum">    5409 </span><span class="lineNoCov">          0 :   double maxSize = presContext-&gt;AppUnitsToFloatCSSPixels(max);</span>
<span class="lineNum">    5410 </span>            : 
<span class="lineNum">    5411 </span>            :   // But we want to ignore any scaling required due to HiDPI displays, since
<span class="lineNum">    5412 </span>            :   // regular CSS text frames will still create text runs using the font size
<span class="lineNum">    5413 </span>            :   // in CSS pixels, and we want SVG text to have the same rendering as HTML
<span class="lineNum">    5414 </span>            :   // text for regular font sizes.
<span class="lineNum">    5415 </span>            :   float cssPxPerDevPx =
<span class="lineNum">    5416 </span><span class="lineNoCov">          0 :     presContext-&gt;AppUnitsToFloatCSSPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    5417 </span><span class="lineNoCov">          0 :   contextScale *= cssPxPerDevPx;</span>
<span class="lineNum">    5418 </span>            : 
<span class="lineNum">    5419 </span><span class="lineNoCov">          0 :   double minTextRunSize = minSize * contextScale;</span>
<span class="lineNum">    5420 </span><span class="lineNoCov">          0 :   double maxTextRunSize = maxSize * contextScale;</span>
<span class="lineNum">    5421 </span>            : 
<span class="lineNum">    5422 </span><span class="lineNoCov">          0 :   if (minTextRunSize &gt;= CLAMP_MIN_SIZE &amp;&amp;</span>
<span class="lineNum">    5423 </span>            :       maxTextRunSize &lt;= CLAMP_MAX_SIZE) {
<span class="lineNum">    5424 </span>            :     // We are already in the ideal font size range for all text frames,
<span class="lineNum">    5425 </span>            :     // so we only have to take into account the contextScale.
<span class="lineNum">    5426 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = contextScale;</span>
<span class="lineNum">    5427 </span><span class="lineNoCov">          0 :   } else if (maxSize / minSize &gt; CLAMP_MAX_SIZE / CLAMP_MIN_SIZE) {</span>
<span class="lineNum">    5428 </span>            :     // We can't scale the font sizes so that all of the text frames lie
<span class="lineNum">    5429 </span>            :     // within our ideal font size range, so we treat the minimum as more
<span class="lineNum">    5430 </span>            :     // important and just scale so that minSize = CLAMP_MIN_SIZE.
<span class="lineNum">    5431 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = CLAMP_MIN_SIZE / minTextRunSize;</span>
<span class="lineNum">    5432 </span><span class="lineNoCov">          0 :   } else if (minTextRunSize &lt; CLAMP_MIN_SIZE) {</span>
<span class="lineNum">    5433 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = CLAMP_MIN_SIZE / minTextRunSize;</span>
<span class="lineNum">    5434 </span>            :   } else {
<span class="lineNum">    5435 </span><span class="lineNoCov">          0 :     mFontSizeScaleFactor = CLAMP_MAX_SIZE / maxTextRunSize;</span>
<span class="lineNum">    5436 </span>            :   }
<span class="lineNum">    5437 </span>            : 
<span class="lineNum">    5438 </span><span class="lineNoCov">          0 :   return mFontSizeScaleFactor != oldFontSizeScaleFactor;</span>
<span class="lineNum">    5439 </span>            : }
<a name="5440"><span class="lineNum">    5440 </span>            : </a>
<span class="lineNum">    5441 </span>            : double
<span class="lineNum">    5442 </span><span class="lineNoCov">          0 : SVGTextFrame::GetFontSizeScaleFactor() const</span>
<span class="lineNum">    5443 </span>            : {
<span class="lineNum">    5444 </span><span class="lineNoCov">          0 :   return mFontSizeScaleFactor;</span>
<span class="lineNum">    5445 </span>            : }
<span class="lineNum">    5446 </span>            : 
<span class="lineNum">    5447 </span>            : /**
<span class="lineNum">    5448 </span>            :  * Take aPoint, which is in the &lt;text&gt; element's user space, and convert
<span class="lineNum">    5449 </span>            :  * it to the appropriate frame user space of aChildFrame according to
<span class="lineNum">    5450 </span>            :  * which rendered run the point hits.
<a name="5451"><span class="lineNum">    5451 </span>            :  */</a>
<span class="lineNum">    5452 </span>            : Point
<span class="lineNum">    5453 </span><span class="lineNoCov">          0 : SVGTextFrame::TransformFramePointToTextChild(const Point&amp; aPoint,</span>
<span class="lineNum">    5454 </span>            :                                              nsIFrame* aChildFrame)
<span class="lineNum">    5455 </span>            : {
<span class="lineNum">    5456 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aChildFrame &amp;&amp;</span>
<span class="lineNum">    5457 </span>            :                nsLayoutUtils::GetClosestFrameOfType
<span class="lineNum">    5458 </span>            :                  (aChildFrame-&gt;GetParent(), LayoutFrameType::SVGText) == this,
<span class="lineNum">    5459 </span>            :                &quot;aChildFrame must be a descendant of this frame&quot;);
<span class="lineNum">    5460 </span>            : 
<span class="lineNum">    5461 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    5462 </span>            : 
<span class="lineNum">    5463 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    5464 </span>            : 
<span class="lineNum">    5465 </span>            :   // Add in the mRect offset to aPoint, as that will have been taken into
<span class="lineNum">    5466 </span>            :   // account when transforming the point from the ancestor frame down
<span class="lineNum">    5467 </span>            :   // to this one.
<span class="lineNum">    5468 </span>            :   float cssPxPerDevPx = presContext-&gt;
<span class="lineNum">    5469 </span><span class="lineNoCov">          0 :     AppUnitsToFloatCSSPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    5470 </span><span class="lineNoCov">          0 :   float factor = presContext-&gt;AppUnitsPerCSSPixel();</span>
<span class="lineNum">    5471 </span>            :   Point framePosition(NSAppUnitsToFloatPixels(mRect.x, factor),
<span class="lineNum">    5472 </span><span class="lineNoCov">          0 :                       NSAppUnitsToFloatPixels(mRect.y, factor));</span>
<span class="lineNum">    5473 </span><span class="lineNoCov">          0 :   Point pointInUserSpace = aPoint * cssPxPerDevPx + framePosition;</span>
<span class="lineNum">    5474 </span>            : 
<span class="lineNum">    5475 </span>            :   // Find the closest rendered run for the text frames beneath aChildFrame.
<span class="lineNum">    5476 </span>            :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames,
<span class="lineNum">    5477 </span><span class="lineNoCov">          0 :                              aChildFrame);</span>
<span class="lineNum">    5478 </span><span class="lineNoCov">          0 :   TextRenderedRun hit;</span>
<span class="lineNum">    5479 </span><span class="lineNoCov">          0 :   gfxPoint pointInRun;</span>
<span class="lineNum">    5480 </span><span class="lineNoCov">          0 :   nscoord dx = nscoord_MAX;</span>
<span class="lineNum">    5481 </span><span class="lineNoCov">          0 :   nscoord dy = nscoord_MAX;</span>
<span class="lineNum">    5482 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    5483 </span>            :     uint32_t flags = TextRenderedRun::eIncludeFill |
<span class="lineNum">    5484 </span>            :                      TextRenderedRun::eIncludeStroke |
<span class="lineNum">    5485 </span><span class="lineNoCov">          0 :                      TextRenderedRun::eNoHorizontalOverflow;</span>
<span class="lineNum">    5486 </span><span class="lineNoCov">          0 :     gfxRect runRect = run.GetRunUserSpaceRect(presContext, flags).ToThebesRect();</span>
<span class="lineNum">    5487 </span>            : 
<span class="lineNum">    5488 </span><span class="lineNoCov">          0 :     gfxMatrix m = run.GetTransformFromRunUserSpaceToUserSpace(presContext);</span>
<span class="lineNum">    5489 </span><span class="lineNoCov">          0 :     if (!m.Invert()) {</span>
<span class="lineNum">    5490 </span><span class="lineNoCov">          0 :       return aPoint;</span>
<span class="lineNum">    5491 </span>            :     }
<span class="lineNum">    5492 </span><span class="lineNoCov">          0 :     gfxPoint pointInRunUserSpace = m.TransformPoint(ThebesPoint(pointInUserSpace));</span>
<span class="lineNum">    5493 </span>            : 
<span class="lineNum">    5494 </span><span class="lineNoCov">          0 :     if (Inside(runRect, pointInRunUserSpace)) {</span>
<span class="lineNum">    5495 </span>            :       // The point was inside the rendered run's rect, so we choose it.
<span class="lineNum">    5496 </span><span class="lineNoCov">          0 :       dx = 0;</span>
<span class="lineNum">    5497 </span><span class="lineNoCov">          0 :       dy = 0;</span>
<span class="lineNum">    5498 </span><span class="lineNoCov">          0 :       pointInRun = pointInRunUserSpace;</span>
<span class="lineNum">    5499 </span><span class="lineNoCov">          0 :       hit = run;</span>
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :     } else if (nsLayoutUtils::PointIsCloserToRect(pointInRunUserSpace,</span>
<span class="lineNum">    5501 </span>            :                                                   runRect, dx, dy)) {
<span class="lineNum">    5502 </span>            :       // The point was closer to this rendered run's rect than any others
<span class="lineNum">    5503 </span>            :       // we've seen so far.
<span class="lineNum">    5504 </span><span class="lineNoCov">          0 :       pointInRun.x = clamped(pointInRunUserSpace.x,</span>
<span class="lineNum">    5505 </span><span class="lineNoCov">          0 :                              runRect.X(), runRect.XMost());</span>
<span class="lineNum">    5506 </span><span class="lineNoCov">          0 :       pointInRun.y = clamped(pointInRunUserSpace.y,</span>
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :                              runRect.Y(), runRect.YMost());</span>
<span class="lineNum">    5508 </span><span class="lineNoCov">          0 :       hit = run;</span>
<span class="lineNum">    5509 </span>            :     }
<span class="lineNum">    5510 </span>            :   }
<span class="lineNum">    5511 </span>            : 
<span class="lineNum">    5512 </span><span class="lineNoCov">          0 :   if (!hit.mFrame) {</span>
<span class="lineNum">    5513 </span>            :     // We didn't find any rendered runs for the frame.
<span class="lineNum">    5514 </span><span class="lineNoCov">          0 :     return aPoint;</span>
<span class="lineNum">    5515 </span>            :   }
<span class="lineNum">    5516 </span>            : 
<span class="lineNum">    5517 </span>            :   // Return the point in user units relative to the nsTextFrame,
<span class="lineNum">    5518 </span>            :   // but taking into account mFontSizeScaleFactor.
<span class="lineNum">    5519 </span><span class="lineNoCov">          0 :   gfxMatrix m = hit.GetTransformFromRunUserSpaceToFrameUserSpace(presContext);</span>
<span class="lineNum">    5520 </span><span class="lineNoCov">          0 :   m.PreScale(mFontSizeScaleFactor, mFontSizeScaleFactor);</span>
<span class="lineNum">    5521 </span><span class="lineNoCov">          0 :   return ToPoint(m.TransformPoint(pointInRun) / cssPxPerDevPx);</span>
<span class="lineNum">    5522 </span>            : }
<span class="lineNum">    5523 </span>            : 
<span class="lineNum">    5524 </span>            : /**
<span class="lineNum">    5525 </span>            :  * For each rendered run beneath aChildFrame, translate aRect from
<span class="lineNum">    5526 </span>            :  * aChildFrame to the run's text frame, transform it then into
<span class="lineNum">    5527 </span>            :  * the run's frame user space, intersect it with the run's
<span class="lineNum">    5528 </span>            :  * frame user space rect, then transform it up to user space.
<span class="lineNum">    5529 </span>            :  * The result is the union of all of these.
<a name="5530"><span class="lineNum">    5530 </span>            :  */</a>
<span class="lineNum">    5531 </span>            : gfxRect
<span class="lineNum">    5532 </span><span class="lineNoCov">          0 : SVGTextFrame::TransformFrameRectFromTextChild(const nsRect&amp; aRect,</span>
<span class="lineNum">    5533 </span>            :                                               nsIFrame* aChildFrame)
<span class="lineNum">    5534 </span>            : {
<span class="lineNum">    5535 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aChildFrame &amp;&amp;</span>
<span class="lineNum">    5536 </span>            :                nsLayoutUtils::GetClosestFrameOfType
<span class="lineNum">    5537 </span>            :                  (aChildFrame-&gt;GetParent(), LayoutFrameType::SVGText) == this,
<span class="lineNum">    5538 </span>            :                &quot;aChildFrame must be a descendant of this frame&quot;);
<span class="lineNum">    5539 </span>            : 
<span class="lineNum">    5540 </span><span class="lineNoCov">          0 :   UpdateGlyphPositioning();</span>
<span class="lineNum">    5541 </span>            : 
<span class="lineNum">    5542 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">    5543 </span>            : 
<span class="lineNum">    5544 </span><span class="lineNoCov">          0 :   gfxRect result;</span>
<span class="lineNum">    5545 </span>            :   TextRenderedRunIterator it(this, TextRenderedRunIterator::eAllFrames,
<span class="lineNum">    5546 </span><span class="lineNoCov">          0 :                              aChildFrame);</span>
<span class="lineNum">    5547 </span><span class="lineNoCov">          0 :   for (TextRenderedRun run = it.Current(); run.mFrame; run = it.Next()) {</span>
<span class="lineNum">    5548 </span>            :     // First, translate aRect from aChildFrame to this run's frame.
<span class="lineNum">    5549 </span><span class="lineNoCov">          0 :     nsRect rectInTextFrame = aRect + aChildFrame-&gt;GetOffsetTo(run.mFrame);</span>
<span class="lineNum">    5550 </span>            : 
<span class="lineNum">    5551 </span>            :     // Scale it into frame user space.
<span class="lineNum">    5552 </span>            :     gfxRect rectInFrameUserSpace =
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :       AppUnitsToFloatCSSPixels(gfxRect(rectInTextFrame.x,</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 :                                        rectInTextFrame.y,</span>
<span class="lineNum">    5555 </span><span class="lineNoCov">          0 :                                        rectInTextFrame.width,</span>
<span class="lineNum">    5556 </span><span class="lineNoCov">          0 :                                        rectInTextFrame.height), presContext);</span>
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span>            :     // Intersect it with the run.
<span class="lineNum">    5559 </span>            :     uint32_t flags = TextRenderedRun::eIncludeFill |
<span class="lineNum">    5560 </span><span class="lineNoCov">          0 :                      TextRenderedRun::eIncludeStroke;</span>
<span class="lineNum">    5561 </span>            : 
<span class="lineNum">    5562 </span><span class="lineNoCov">          0 :     if (rectInFrameUserSpace.IntersectRect(rectInFrameUserSpace,</span>
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :         run.GetFrameUserSpaceRect(presContext, flags).ToThebesRect())) {</span>
<span class="lineNum">    5564 </span>            :       // Transform it up to user space of the &lt;text&gt;, also taking into
<span class="lineNum">    5565 </span>            :       // account the font size scale.
<span class="lineNum">    5566 </span><span class="lineNoCov">          0 :       gfxMatrix m = run.GetTransformFromRunUserSpaceToUserSpace(presContext);</span>
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 :       m.PreScale(mFontSizeScaleFactor, mFontSizeScaleFactor);</span>
<span class="lineNum">    5568 </span><span class="lineNoCov">          0 :       gfxRect rectInUserSpace = m.TransformRect(rectInFrameUserSpace);</span>
<span class="lineNum">    5569 </span>            : 
<span class="lineNum">    5570 </span>            :       // Union it into the result.
<span class="lineNum">    5571 </span><span class="lineNoCov">          0 :       result.UnionRect(result, rectInUserSpace);</span>
<span class="lineNum">    5572 </span>            :     }
<span class="lineNum">    5573 </span>            :   }
<span class="lineNum">    5574 </span>            : 
<span class="lineNum">    5575 </span>            :   // Subtract the mRect offset from the result, as our user space for
<span class="lineNum">    5576 </span>            :   // this frame is relative to the top-left of mRect.
<span class="lineNum">    5577 </span><span class="lineNoCov">          0 :   float factor = presContext-&gt;AppUnitsPerCSSPixel();</span>
<span class="lineNum">    5578 </span><span class="lineNoCov">          0 :   gfxPoint framePosition(NSAppUnitsToFloatPixels(mRect.x, factor),</span>
<span class="lineNum">    5579 </span><span class="lineNoCov">          0 :                          NSAppUnitsToFloatPixels(mRect.y, factor));</span>
<span class="lineNum">    5580 </span>            : 
<span class="lineNum">    5581 </span><span class="lineNoCov">          0 :   return result - framePosition;</span>
<span class="lineNum">    5582 </span>            : }
<a name="5583"><span class="lineNum">    5583 </span>            : </a>
<span class="lineNum">    5584 </span>            : void
<span class="lineNum">    5585 </span><span class="lineNoCov">          0 : SVGTextFrame::AppendDirectlyOwnedAnonBoxes(nsTArray&lt;OwnedAnonBox&gt;&amp; aResult)</span>
<span class="lineNum">    5586 </span>            : {
<span class="lineNum">    5587 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(PrincipalChildList().FirstChild(), &quot;Must have our anon box&quot;);</span>
<span class="lineNum">    5588 </span><span class="lineNoCov">          0 :   aResult.AppendElement(OwnedAnonBox(PrincipalChildList().FirstChild()));</span>
<span class="lineNum">    5589 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

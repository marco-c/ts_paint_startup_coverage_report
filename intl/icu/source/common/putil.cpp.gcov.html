<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/putil.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - putil.cpp<span style="font-size: 80%;"> (source / <a href="putil.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">50</td>
            <td class="headerCovTableEntry">418</td>
            <td class="headerCovTableEntryLo">12.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntryLo">11.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : ******************************************************************************
<span class="lineNum">       5 </span>            : *
<span class="lineNum">       6 </span>            : *   Copyright (C) 1997-2016, International Business Machines
<span class="lineNum">       7 </span>            : *   Corporation and others.  All Rights Reserved.
<span class="lineNum">       8 </span>            : *
<span class="lineNum">       9 </span>            : ******************************************************************************
<span class="lineNum">      10 </span>            : *
<span class="lineNum">      11 </span>            : *  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)
<span class="lineNum">      12 </span>            : *
<span class="lineNum">      13 </span>            : *   Date        Name        Description
<span class="lineNum">      14 </span>            : *   04/14/97    aliu        Creation.
<span class="lineNum">      15 </span>            : *   04/24/97    aliu        Added getDefaultDataDirectory() and
<span class="lineNum">      16 </span>            : *                            getDefaultLocaleID().
<span class="lineNum">      17 </span>            : *   04/28/97    aliu        Rewritten to assume Unix and apply general methods
<span class="lineNum">      18 </span>            : *                            for assumed case.  Non-UNIX platforms must be
<span class="lineNum">      19 </span>            : *                            special-cased.  Rewrote numeric methods dealing
<span class="lineNum">      20 </span>            : *                            with NaN and Infinity to be platform independent
<span class="lineNum">      21 </span>            : *                             over all IEEE 754 platforms.
<span class="lineNum">      22 </span>            : *   05/13/97    aliu        Restored sign of timezone
<span class="lineNum">      23 </span>            : *                            (semantics are hours West of GMT)
<span class="lineNum">      24 </span>            : *   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,
<span class="lineNum">      25 </span>            : *                             nextDouble..
<span class="lineNum">      26 </span>            : *   07/22/98    stephen     Added remainder, max, min, trunc
<span class="lineNum">      27 </span>            : *   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity
<span class="lineNum">      28 </span>            : *   08/24/98    stephen     Added longBitsFromDouble
<span class="lineNum">      29 </span>            : *   09/08/98    stephen     Minor changes for Mac Port
<span class="lineNum">      30 </span>            : *   03/02/99    stephen     Removed openFile().  Added AS400 support.
<span class="lineNum">      31 </span>            : *                            Fixed EBCDIC tables
<span class="lineNum">      32 </span>            : *   04/15/99    stephen     Converted to C.
<span class="lineNum">      33 </span>            : *   06/28/99    stephen     Removed mutex locking in u_isBigEndian().
<span class="lineNum">      34 </span>            : *   08/04/99    jeffrey R.  Added OS/2 changes
<span class="lineNum">      35 </span>            : *   11/15/99    helena      Integrated S/390 IEEE support.
<span class="lineNum">      36 </span>            : *   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID
<span class="lineNum">      37 </span>            : *   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage
<span class="lineNum">      38 </span>            : *   01/03/08    Steven L.   Fake Time Support
<span class="lineNum">      39 </span>            : ******************************************************************************
<span class="lineNum">      40 </span>            : */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // Defines _XOPEN_SOURCE for access to POSIX functions.
<span class="lineNum">      43 </span>            : // Must be before any other #includes.
<span class="lineNum">      44 </span>            : #include &quot;uposixdefs.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : // First, the platform type. Need this for U_PLATFORM.
<span class="lineNum">      47 </span>            : #include &quot;unicode/platform.h&quot;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #if U_PLATFORM == U_PF_MINGW &amp;&amp; defined __STRICT_ANSI__
<span class="lineNum">      50 </span>            : /* tzset isn't defined in strict ANSI on MinGW. */
<span class="lineNum">      51 </span>            : #undef __STRICT_ANSI__
<span class="lineNum">      52 </span>            : #endif
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /*
<span class="lineNum">      55 </span>            :  * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.
<span class="lineNum">      56 </span>            :  */
<span class="lineNum">      57 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : #if !U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">      60 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      61 </span>            : #endif
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : /* include the rest of the ICU headers */
<span class="lineNum">      64 </span>            : #include &quot;unicode/putil.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;unicode/ustring.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;putilimp.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;umutex.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;cstring.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;locmap.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;ucln_cmn.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;charstr.h&quot;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /* Include standard headers. */
<span class="lineNum">      76 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      77 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      78 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      79 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      80 </span>            : #include &lt;locale.h&gt;
<span class="lineNum">      81 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : #ifndef U_COMMON_IMPLEMENTATION
<span class="lineNum">      84 </span>            : #error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu
<span class="lineNum">      85 </span>            : #endif
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /* include system headers */
<span class="lineNum">      89 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">      90 </span>            :     /*
<span class="lineNum">      91 </span>            :      * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.
<span class="lineNum">      92 </span>            :      * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)
<span class="lineNum">      93 </span>            :      * to use native APIs as much as possible?
<span class="lineNum">      94 </span>            :      */
<span class="lineNum">      95 </span>            : #ifndef WIN32_LEAN_AND_MEAN
<span class="lineNum">      96 </span>            : #   define WIN32_LEAN_AND_MEAN
<span class="lineNum">      97 </span>            : #endif
<span class="lineNum">      98 </span>            : #   define VC_EXTRALEAN
<span class="lineNum">      99 </span>            : #   define NOUSER
<span class="lineNum">     100 </span>            : #   define NOSERVICE
<span class="lineNum">     101 </span>            : #   define NOIME
<span class="lineNum">     102 </span>            : #   define NOMCX
<span class="lineNum">     103 </span>            : #   include &lt;windows.h&gt;
<span class="lineNum">     104 </span>            : #   include &quot;unicode/uloc.h&quot;
<span class="lineNum">     105 </span>            : #if U_PLATFORM_HAS_WINUWP_API == 0
<span class="lineNum">     106 </span>            : #   include &quot;wintz.h&quot;
<span class="lineNum">     107 </span>            : #else // U_PLATFORM_HAS_WINUWP_API
<span class="lineNum">     108 </span>            : typedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef
<span class="lineNum">     109 </span>            : #include &lt;Windows.Globalization.h&gt;
<span class="lineNum">     110 </span>            : #include &lt;windows.system.userprofile.h&gt;
<span class="lineNum">     111 </span>            : #include &lt;wrl/wrappers/corewrappers.h&gt;
<span class="lineNum">     112 </span>            : #include &lt;wrl/client.h&gt;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : using namespace ABI::Windows::Foundation;
<span class="lineNum">     115 </span>            : using namespace Microsoft::WRL;
<span class="lineNum">     116 </span>            : using namespace Microsoft::WRL::Wrappers;
<span class="lineNum">     117 </span>            : #endif
<span class="lineNum">     118 </span>            : #elif U_PLATFORM == U_PF_OS400
<span class="lineNum">     119 </span>            : #   include &lt;float.h&gt;
<span class="lineNum">     120 </span>            : #   include &lt;qusec.h&gt;       /* error code structure */
<span class="lineNum">     121 </span>            : #   include &lt;qusrjobi.h&gt;
<span class="lineNum">     122 </span>            : #   include &lt;qliept.h&gt;      /* EPT_CALL macro  - this include must be after all other &quot;QSYSINCs&quot; */
<span class="lineNum">     123 </span>            : #   include &lt;mih/testptr.h&gt; /* For uprv_maximumPtr */
<span class="lineNum">     124 </span>            : #elif U_PLATFORM == U_PF_OS390
<span class="lineNum">     125 </span>            : #   include &quot;unicode/ucnv.h&quot;   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */
<span class="lineNum">     126 </span>            : #elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">     127 </span>            : #   include &lt;limits.h&gt;
<span class="lineNum">     128 </span>            : #   include &lt;unistd.h&gt;
<span class="lineNum">     129 </span>            : #   if U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">     130 </span>            : #       ifndef _XPG4_2
<span class="lineNum">     131 </span>            : #           define _XPG4_2
<span class="lineNum">     132 </span>            : #       endif
<span class="lineNum">     133 </span>            : #   endif
<span class="lineNum">     134 </span>            : #elif U_PLATFORM == U_PF_QNX
<span class="lineNum">     135 </span>            : #   include &lt;sys/neutrino.h&gt;
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /*
<span class="lineNum">     139 </span>            :  * Only include langinfo.h if we have a way to get the codeset. If we later
<span class="lineNum">     140 </span>            :  * depend on more feature, we can test on U_HAVE_NL_LANGINFO.
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  */
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : #if U_HAVE_NL_LANGINFO_CODESET
<span class="lineNum">     145 </span>            : #include &lt;langinfo.h&gt;
<span class="lineNum">     146 </span>            : #endif
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /**
<span class="lineNum">     149 </span>            :  * Simple things (presence of functions, etc) should just go in configure.in and be added to
<span class="lineNum">     150 </span>            :  * icucfg.h via autoheader.
<span class="lineNum">     151 </span>            :  */
<span class="lineNum">     152 </span>            : #if U_PLATFORM_IMPLEMENTS_POSIX
<span class="lineNum">     153 </span>            : #   if U_PLATFORM == U_PF_OS400
<span class="lineNum">     154 </span>            : #    define HAVE_DLFCN_H 0
<span class="lineNum">     155 </span>            : #    define HAVE_DLOPEN 0
<span class="lineNum">     156 </span>            : #   else
<span class="lineNum">     157 </span>            : #   ifndef HAVE_DLFCN_H
<span class="lineNum">     158 </span>            : #    define HAVE_DLFCN_H 1
<span class="lineNum">     159 </span>            : #   endif
<span class="lineNum">     160 </span>            : #   ifndef HAVE_DLOPEN
<span class="lineNum">     161 </span>            : #    define HAVE_DLOPEN 1
<span class="lineNum">     162 </span>            : #   endif
<span class="lineNum">     163 </span>            : #   endif
<span class="lineNum">     164 </span>            : #   ifndef HAVE_GETTIMEOFDAY
<span class="lineNum">     165 </span>            : #    define HAVE_GETTIMEOFDAY 1
<span class="lineNum">     166 </span>            : #   endif
<span class="lineNum">     167 </span>            : #else
<span class="lineNum">     168 </span>            : #   define HAVE_DLFCN_H 0
<span class="lineNum">     169 </span>            : #   define HAVE_DLOPEN 0
<span class="lineNum">     170 </span>            : #   define HAVE_GETTIMEOFDAY 0
<span class="lineNum">     171 </span>            : #endif
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : U_NAMESPACE_USE
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : /* Define the extension for data files, again... */
<span class="lineNum">     176 </span>            : #define DATA_TYPE &quot;dat&quot;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /* Leave this copyright notice here! */
<span class="lineNum">     179 </span>            : static const char copyright[] = U_COPYRIGHT_STRING;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /* floating point implementations ------------------------------------------- */
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : /* We return QNAN rather than SNAN*/
<span class="lineNum">     184 </span>            : #define SIGN 0x80000000U
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Make it easy to define certain types of constants */
<span class="lineNum">     187 </span>            : typedef union {
<span class="lineNum">     188 </span>            :     int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */
<span class="lineNum">     189 </span>            :     double d64;
<span class="lineNum">     190 </span>            : } BitPatternConversion;
<span class="lineNum">     191 </span>            : static const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };
<span class="lineNum">     192 </span>            : static const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : /*---------------------------------------------------------------------------
<span class="lineNum">     195 </span>            :   Platform utilities
<span class="lineNum">     196 </span>            :   Our general strategy is to assume we're on a POSIX platform.  Platforms which
<span class="lineNum">     197 </span>            :   are non-POSIX must declare themselves so.  The default POSIX implementation
<span class="lineNum">     198 </span>            :   will sometimes work for non-POSIX platforms as well (e.g., the NaN-related
<span class="lineNum">     199 </span>            :   functions).
<span class="lineNum">     200 </span>            :   ---------------------------------------------------------------------------*/
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400
<span class="lineNum">     203 </span>            : #   undef U_POSIX_LOCALE
<span class="lineNum">     204 </span>            : #else
<span class="lineNum">     205 </span>            : #   define U_POSIX_LOCALE    1
<span class="lineNum">     206 </span>            : #endif
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /*
<span class="lineNum">     209 </span>            :     WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble
<span class="lineNum">     210 </span>            :     can't be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).
<span class="lineNum">     211 </span>            : */
<span class="lineNum">     212 </span>            : #if !IEEE_754
<span class="lineNum">     213 </span>            : static char*
<span class="lineNum">     214 </span>            : u_topNBytesOfDouble(double* d, int n)
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span>            : #if U_IS_BIG_ENDIAN
<span class="lineNum">     217 </span>            :     return (char*)d;
<span class="lineNum">     218 </span>            : #else
<span class="lineNum">     219 </span>            :     return (char*)(d + 1) - n;
<span class="lineNum">     220 </span>            : #endif
<span class="lineNum">     221 </span>            : }
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : static char*
<span class="lineNum">     224 </span>            : u_bottomNBytesOfDouble(double* d, int n)
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            : #if U_IS_BIG_ENDIAN
<span class="lineNum">     227 </span>            :     return (char*)(d + 1) - n;
<span class="lineNum">     228 </span>            : #else
<span class="lineNum">     229 </span>            :     return (char*)d;
<span class="lineNum">     230 </span>            : #endif
<span class="lineNum">     231 </span>            : }
<span class="lineNum">     232 </span>            : #endif   /* !IEEE_754 */
<span class="lineNum">     233 </span>            : 
<a name="234"><span class="lineNum">     234 </span>            : #if IEEE_754</a>
<span class="lineNum">     235 </span>            : static UBool
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : u_signBit(double d) {</span>
<span class="lineNum">     237 </span>            :     uint8_t hiByte;
<span class="lineNum">     238 </span>            : #if U_IS_BIG_ENDIAN
<span class="lineNum">     239 </span>            :     hiByte = *(uint8_t *)&amp;d;
<span class="lineNum">     240 </span>            : #else
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     hiByte = *(((uint8_t *)&amp;d) + sizeof(double) - 1);</span>
<span class="lineNum">     242 </span>            : #endif
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     return (hiByte &amp; 0x80) != 0;</span>
<span class="lineNum">     244 </span>            : }
<span class="lineNum">     245 </span>            : #endif
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : #if defined (U_DEBUG_FAKETIME)
<span class="lineNum">     250 </span>            : /* Override the clock to test things without having to move the system clock.
<span class="lineNum">     251 </span>            :  * Assumes POSIX gettimeofday() will function
<span class="lineNum">     252 </span>            :  */
<span class="lineNum">     253 </span>            : UDate fakeClock_t0 = 0; /** Time to start the clock from **/
<span class="lineNum">     254 </span>            : UDate fakeClock_dt = 0; /** Offset (fake time - real time) **/
<span class="lineNum">     255 </span>            : UBool fakeClock_set = FALSE; /** True if fake clock has spun up **/
<span class="lineNum">     256 </span>            : static UMutex fakeClockMutex = U_MUTEX_INTIALIZER;
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : static UDate getUTCtime_real() {
<span class="lineNum">     259 </span>            :     struct timeval posixTime;
<span class="lineNum">     260 </span>            :     gettimeofday(&amp;posixTime, NULL);
<span class="lineNum">     261 </span>            :     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));
<span class="lineNum">     262 </span>            : }
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : static UDate getUTCtime_fake() {
<span class="lineNum">     265 </span>            :     umtx_lock(&amp;fakeClockMutex);
<span class="lineNum">     266 </span>            :     if(!fakeClock_set) {
<span class="lineNum">     267 </span>            :         UDate real = getUTCtime_real();
<span class="lineNum">     268 </span>            :         const char *fake_start = getenv(&quot;U_FAKETIME_START&quot;);
<span class="lineNum">     269 </span>            :         if((fake_start!=NULL) &amp;&amp; (fake_start[0]!=0)) {
<span class="lineNum">     270 </span>            :             sscanf(fake_start,&quot;%lf&quot;,&amp;fakeClock_t0);
<span class="lineNum">     271 </span>            :             fakeClock_dt = fakeClock_t0 - real;
<span class="lineNum">     272 </span>            :             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\n&quot;
<span class="lineNum">     273 </span>            :                     &quot;env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\n&quot;,
<span class="lineNum">     274 </span>            :                     fakeClock_t0, fake_start, fakeClock_dt, real);
<span class="lineNum">     275 </span>            :         } else {
<span class="lineNum">     276 </span>            :           fakeClock_dt = 0;
<span class="lineNum">     277 </span>            :             fprintf(stderr,&quot;U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\n&quot;
<span class="lineNum">     278 </span>            :                     &quot;Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\n&quot;);
<span class="lineNum">     279 </span>            :         }
<span class="lineNum">     280 </span>            :         fakeClock_set = TRUE;
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span>            :     umtx_unlock(&amp;fakeClockMutex);
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :     return getUTCtime_real() + fakeClock_dt;
<span class="lineNum">     285 </span>            : }
<span class="lineNum">     286 </span>            : #endif
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">     289 </span>            : typedef union {
<span class="lineNum">     290 </span>            :     int64_t int64;
<span class="lineNum">     291 </span>            :     FILETIME fileTime;
<span class="lineNum">     292 </span>            : } FileTimeConversion;   /* This is like a ULARGE_INTEGER */
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : /* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */
<span class="lineNum">     295 </span>            : #define EPOCH_BIAS  INT64_C(116444736000000000)
<span class="lineNum">     296 </span>            : #define HECTONANOSECOND_PER_MILLISECOND   10000
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : #endif
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /*---------------------------------------------------------------------------
<span class="lineNum">     301 </span>            :   Universal Implementations
<span class="lineNum">     302 </span>            :   These are designed to work on all platforms.  Try these, and if they
<span class="lineNum">     303 </span>            :   don't work on your platform, then special case your platform with new
<span class="lineNum">     304 </span>            :   implementations.
<span class="lineNum">     305 </span>            : ---------------------------------------------------------------------------*/
<a name="306"><span class="lineNum">     306 </span>            : </a>
<span class="lineNum">     307 </span>            : U_CAPI UDate U_EXPORT2
<span class="lineNum">     308 </span><span class="lineNoCov">          0 : uprv_getUTCtime()</span>
<span class="lineNum">     309 </span>            : {
<span class="lineNum">     310 </span>            : #if defined(U_DEBUG_FAKETIME)
<span class="lineNum">     311 </span>            :     return getUTCtime_fake(); /* Hook for overriding the clock */
<span class="lineNum">     312 </span>            : #else
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     return uprv_getRawUTCtime();</span>
<span class="lineNum">     314 </span>            : #endif
<span class="lineNum">     315 </span>            : }
<span class="lineNum">     316 </span>            : 
<a name="317"><span class="lineNum">     317 </span>            : /* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/</a>
<span class="lineNum">     318 </span>            : U_CAPI UDate U_EXPORT2
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : uprv_getRawUTCtime()</span>
<span class="lineNum">     320 </span>            : {
<span class="lineNum">     321 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     FileTimeConversion winTime;
<span class="lineNum">     324 </span>            :     GetSystemTimeAsFileTime(&amp;winTime.fileTime);
<span class="lineNum">     325 </span>            :     return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);
<span class="lineNum">     326 </span>            : #else
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : #if HAVE_GETTIMEOFDAY
<span class="lineNum">     329 </span>            :     struct timeval posixTime;
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     gettimeofday(&amp;posixTime, NULL);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));</span>
<span class="lineNum">     332 </span>            : #else
<span class="lineNum">     333 </span>            :     time_t epochtime;
<span class="lineNum">     334 </span>            :     time(&amp;epochtime);
<span class="lineNum">     335 </span>            :     return (UDate)epochtime * U_MILLIS_PER_SECOND;
<span class="lineNum">     336 </span>            : #endif
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : #endif
<span class="lineNum">     339 </span>            : }
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : /*-----------------------------------------------------------------------------
<span class="lineNum">     342 </span>            :   IEEE 754
<span class="lineNum">     343 </span>            :   These methods detect and return NaN and infinity values for doubles
<span class="lineNum">     344 </span>            :   conforming to IEEE 754.  Platforms which support this standard include X86,
<span class="lineNum">     345 </span>            :   Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.
<span class="lineNum">     346 </span>            :   If this doesn't work on your platform, you have non-IEEE floating-point, and
<span class="lineNum">     347 </span>            :   will need to code your own versions.  A naive implementation is to return 0.0
<span class="lineNum">     348 </span>            :   for getNaN and getInfinity, and false for isNaN and isInfinite.
<span class="lineNum">     349 </span>            :   ---------------------------------------------------------------------------*/
<a name="350"><span class="lineNum">     350 </span>            : </a>
<span class="lineNum">     351 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : uprv_isNaN(double number)</span>
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span>            : #if IEEE_754
<span class="lineNum">     355 </span>            :     BitPatternConversion convertedNumber;
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     convertedNumber.d64 = number;</span>
<span class="lineNum">     357 </span>            :     /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     return (UBool)((convertedNumber.i64 &amp; U_INT64_MAX) &gt; gInf.i64);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : #elif U_PLATFORM == U_PF_OS390
<span class="lineNum">     361 </span>            :     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
<span class="lineNum">     362 </span>            :                         sizeof(uint32_t));
<span class="lineNum">     363 </span>            :     uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&amp;number,
<span class="lineNum">     364 </span>            :                         sizeof(uint32_t));
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     return ((highBits &amp; 0x7F080000L) == 0x7F080000L) &amp;&amp;
<span class="lineNum">     367 </span>            :       (lowBits == 0x00000000L);
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : #else
<span class="lineNum">     370 </span>            :     /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/
<span class="lineNum">     371 </span>            :     /* you'll need to replace this default implementation with what's correct*/
<span class="lineNum">     372 </span>            :     /* for your platform.*/
<span class="lineNum">     373 </span>            :     return number != number;
<span class="lineNum">     374 </span>            : #endif
<span class="lineNum">     375 </span>            : }
<a name="376"><span class="lineNum">     376 </span>            : </a>
<span class="lineNum">     377 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     378 </span><span class="lineNoCov">          0 : uprv_isInfinite(double number)</span>
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span>            : #if IEEE_754
<span class="lineNum">     381 </span>            :     BitPatternConversion convertedNumber;
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     convertedNumber.d64 = number;</span>
<span class="lineNum">     383 </span>            :     /* Infinity is exactly 0x7FF0000000000000U. */
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     return (UBool)((convertedNumber.i64 &amp; U_INT64_MAX) == gInf.i64);</span>
<span class="lineNum">     385 </span>            : #elif U_PLATFORM == U_PF_OS390
<span class="lineNum">     386 </span>            :     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
<span class="lineNum">     387 </span>            :                         sizeof(uint32_t));
<span class="lineNum">     388 </span>            :     uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&amp;number,
<span class="lineNum">     389 </span>            :                         sizeof(uint32_t));
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :     return ((highBits  &amp; ~SIGN) == 0x70FF0000L) &amp;&amp; (lowBits == 0x00000000L);
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : #else
<span class="lineNum">     394 </span>            :     /* If your platform doesn't support IEEE 754 but *does* have an infinity*/
<span class="lineNum">     395 </span>            :     /* value, you'll need to replace this default implementation with what's*/
<span class="lineNum">     396 </span>            :     /* correct for your platform.*/
<span class="lineNum">     397 </span>            :     return number == (2.0 * number);
<span class="lineNum">     398 </span>            : #endif
<span class="lineNum">     399 </span>            : }
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     402 </span><span class="lineNoCov">          0 : uprv_isPositiveInfinity(double number)</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span>            : #if IEEE_754 || U_PLATFORM == U_PF_OS390
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     return (UBool)(number &gt; 0 &amp;&amp; uprv_isInfinite(number));</span>
<span class="lineNum">     406 </span>            : #else
<span class="lineNum">     407 </span>            :     return uprv_isInfinite(number);
<span class="lineNum">     408 </span>            : #endif
<span class="lineNum">     409 </span>            : }
<a name="410"><span class="lineNum">     410 </span>            : </a>
<span class="lineNum">     411 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     412 </span><span class="lineNoCov">          0 : uprv_isNegativeInfinity(double number)</span>
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span>            : #if IEEE_754 || U_PLATFORM == U_PF_OS390
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     return (UBool)(number &lt; 0 &amp;&amp; uprv_isInfinite(number));</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : #else
<span class="lineNum">     418 </span>            :     uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&amp;number,
<span class="lineNum">     419 </span>            :                         sizeof(uint32_t));
<span class="lineNum">     420 </span>            :     return((highBits &amp; SIGN) &amp;&amp; uprv_isInfinite(number));
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : #endif
<span class="lineNum">     423 </span>            : }
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : uprv_getNaN()</span>
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span>            : #if IEEE_754 || U_PLATFORM == U_PF_OS390
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     return gNan.d64;</span>
<span class="lineNum">     430 </span>            : #else
<span class="lineNum">     431 </span>            :     /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/
<span class="lineNum">     432 </span>            :     /* you'll need to replace this default implementation with what's correct*/
<span class="lineNum">     433 </span>            :     /* for your platform.*/
<span class="lineNum">     434 </span>            :     return 0.0;
<span class="lineNum">     435 </span>            : #endif
<span class="lineNum">     436 </span>            : }
<a name="437"><span class="lineNum">     437 </span>            : </a>
<span class="lineNum">     438 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : uprv_getInfinity()</span>
<span class="lineNum">     440 </span>            : {
<span class="lineNum">     441 </span>            : #if IEEE_754 || U_PLATFORM == U_PF_OS390
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     return gInf.d64;</span>
<span class="lineNum">     443 </span>            : #else
<span class="lineNum">     444 </span>            :     /* If your platform doesn't support IEEE 754 but *does* have an infinity*/
<span class="lineNum">     445 </span>            :     /* value, you'll need to replace this default implementation with what's*/
<span class="lineNum">     446 </span>            :     /* correct for your platform.*/
<span class="lineNum">     447 </span>            :     return 0.0;
<span class="lineNum">     448 </span>            : #endif
<span class="lineNum">     449 </span>            : }
<a name="450"><span class="lineNum">     450 </span>            : </a>
<span class="lineNum">     451 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : uprv_floor(double x)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     return floor(x);</span>
<span class="lineNum">     455 </span>            : }
<a name="456"><span class="lineNum">     456 </span>            : </a>
<span class="lineNum">     457 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     458 </span><span class="lineNoCov">          0 : uprv_ceil(double x)</span>
<span class="lineNum">     459 </span>            : {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     return ceil(x);</span>
<span class="lineNum">     461 </span>            : }
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     464 </span><span class="lineNoCov">          0 : uprv_round(double x)</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     return uprv_floor(x + 0.5);</span>
<span class="lineNum">     467 </span>            : }
<a name="468"><span class="lineNum">     468 </span>            : </a>
<span class="lineNum">     469 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     470 </span><span class="lineNoCov">          0 : uprv_fabs(double x)</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     return fabs(x);</span>
<span class="lineNum">     473 </span>            : }
<a name="474"><span class="lineNum">     474 </span>            : </a>
<span class="lineNum">     475 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     476 </span><span class="lineNoCov">          0 : uprv_modf(double x, double* y)</span>
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     return modf(x, y);</span>
<span class="lineNum">     479 </span>            : }
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     482 </span><span class="lineNoCov">          0 : uprv_fmod(double x, double y)</span>
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     return fmod(x, y);</span>
<span class="lineNum">     485 </span>            : }
<a name="486"><span class="lineNum">     486 </span>            : </a>
<span class="lineNum">     487 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     488 </span><span class="lineNoCov">          0 : uprv_pow(double x, double y)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span>            :     /* This is declared as &quot;double pow(double x, double y)&quot; */
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     return pow(x, y);</span>
<span class="lineNum">     492 </span>            : }
<a name="493"><span class="lineNum">     493 </span>            : </a>
<span class="lineNum">     494 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     495 </span><span class="lineNoCov">          0 : uprv_pow10(int32_t x)</span>
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     return pow(10.0, (double)x);</span>
<span class="lineNum">     498 </span>            : }
<a name="499"><span class="lineNum">     499 </span>            : </a>
<span class="lineNum">     500 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     501 </span><span class="lineNoCov">          0 : uprv_fmax(double x, double y)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span>            : #if IEEE_754
<span class="lineNum">     504 </span>            :     /* first handle NaN*/
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     if(uprv_isNaN(x) || uprv_isNaN(y))</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :         return uprv_getNaN();</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :     /* check for -0 and 0*/
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     if(x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; u_signBit(x))</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         return y;</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : #endif
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :     /* this should work for all flt point w/o NaN and Inf special cases */
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     return (x &gt; y ? x : y);</span>
<span class="lineNum">     516 </span>            : }
<a name="517"><span class="lineNum">     517 </span>            : </a>
<span class="lineNum">     518 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     519 </span><span class="lineNoCov">          0 : uprv_fmin(double x, double y)</span>
<span class="lineNum">     520 </span>            : {
<span class="lineNum">     521 </span>            : #if IEEE_754
<span class="lineNum">     522 </span>            :     /* first handle NaN*/
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     if(uprv_isNaN(x) || uprv_isNaN(y))</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         return uprv_getNaN();</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :     /* check for -0 and 0*/
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     if(x == 0.0 &amp;&amp; y == 0.0 &amp;&amp; u_signBit(y))</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         return y;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : #endif
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :     /* this should work for all flt point w/o NaN and Inf special cases */
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     return (x &gt; y ? y : x);</span>
<span class="lineNum">     534 </span>            : }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : /**
<span class="lineNum">     537 </span>            :  * Truncates the given double.
<span class="lineNum">     538 </span>            :  * trunc(3.3) = 3.0, trunc (-3.3) = -3.0
<span class="lineNum">     539 </span>            :  * This is different than calling floor() or ceil():
<span class="lineNum">     540 </span>            :  * floor(3.3) = 3, floor(-3.3) = -4
<span class="lineNum">     541 </span>            :  * ceil(3.3) = 4, ceil(-3.3) = -3
<a name="542"><span class="lineNum">     542 </span>            :  */</a>
<span class="lineNum">     543 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     544 </span><span class="lineNoCov">          0 : uprv_trunc(double d)</span>
<span class="lineNum">     545 </span>            : {
<span class="lineNum">     546 </span>            : #if IEEE_754
<span class="lineNum">     547 </span>            :     /* handle error cases*/
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     if(uprv_isNaN(d))</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         return uprv_getNaN();</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     if(uprv_isInfinite(d))</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         return uprv_getInfinity();</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     if(u_signBit(d))    /* Signbit() picks up -0.0;  d&lt;0 does not. */</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         return ceil(d);</span>
<span class="lineNum">     555 </span>            :     else
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         return floor(d);</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            : #else
<span class="lineNum">     559 </span>            :     return d &gt;= 0 ? floor(d) : ceil(d);
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : #endif
<span class="lineNum">     562 </span>            : }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : /**
<span class="lineNum">     565 </span>            :  * Return the largest positive number that can be represented by an integer
<span class="lineNum">     566 </span>            :  * type of arbitrary bit length.
<a name="567"><span class="lineNum">     567 </span>            :  */</a>
<span class="lineNum">     568 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     569 </span><span class="lineNoCov">          0 : uprv_maxMantissa(void)</span>
<span class="lineNum">     570 </span>            : {
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;</span>
<span class="lineNum">     572 </span>            : }
<a name="573"><span class="lineNum">     573 </span>            : </a>
<span class="lineNum">     574 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">     575 </span><span class="lineNoCov">          0 : uprv_log(double d)</span>
<span class="lineNum">     576 </span>            : {
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     return log(d);</span>
<span class="lineNum">     578 </span>            : }
<a name="579"><span class="lineNum">     579 </span>            : </a>
<span class="lineNum">     580 </span>            : U_CAPI void * U_EXPORT2
<span class="lineNum">     581 </span><span class="lineNoCov">          0 : uprv_maximumPtr(void * base)</span>
<span class="lineNum">     582 </span>            : {
<span class="lineNum">     583 </span>            : #if U_PLATFORM == U_PF_OS400
<span class="lineNum">     584 </span>            :     /*
<span class="lineNum">     585 </span>            :      * With the provided function we should never be out of range of a given segment
<span class="lineNum">     586 </span>            :      * (a traditional/typical segment that is).  Our segments have 5 bytes for the
<span class="lineNum">     587 </span>            :      * id and 3 bytes for the offset.  The key is that the casting takes care of
<span class="lineNum">     588 </span>            :      * only retrieving the offset portion minus x1000.  Hence, the smallest offset
<span class="lineNum">     589 </span>            :      * seen in a program is x001000 and when casted to an int would be 0.
<span class="lineNum">     590 </span>            :      * That's why we can only add 0xffefff.  Otherwise, we would exceed the segment.
<span class="lineNum">     591 </span>            :      *
<span class="lineNum">     592 </span>            :      * Currently, 16MB is the current addressing limitation on i5/OS if the activation is
<span class="lineNum">     593 </span>            :      * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).
<span class="lineNum">     594 </span>            :      * This function determines the activation based on the pointer that is passed in and
<span class="lineNum">     595 </span>            :      * calculates the appropriate maximum available size for
<span class="lineNum">     596 </span>            :      * each pointer type (TERASPACE and non-TERASPACE)
<span class="lineNum">     597 </span>            :      *
<span class="lineNum">     598 </span>            :      * Unlike other operating systems, the pointer model isn't determined at
<span class="lineNum">     599 </span>            :      * compile time on i5/OS.
<span class="lineNum">     600 </span>            :      */
<span class="lineNum">     601 </span>            :     if ((base != NULL) &amp;&amp; (_TESTPTR(base, _C_TERASPACE_CHECK))) {
<span class="lineNum">     602 </span>            :         /* if it is a TERASPACE pointer the max is 2GB - 4k */
<span class="lineNum">     603 </span>            :         return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span>            :     /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */
<span class="lineNum">     606 </span>            :     return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : #else
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     return U_MAX_PTR(base);</span>
<span class="lineNum">     610 </span>            : #endif
<span class="lineNum">     611 </span>            : }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : /*---------------------------------------------------------------------------
<span class="lineNum">     614 </span>            :   Platform-specific Implementations
<span class="lineNum">     615 </span>            :   Try these, and if they don't work on your platform, then special case your
<span class="lineNum">     616 </span>            :   platform with new implementations.
<span class="lineNum">     617 </span>            :   ---------------------------------------------------------------------------*/
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : /* Generic time zone layer -------------------------------------------------- */
<span class="lineNum">     620 </span>            : 
<a name="621"><span class="lineNum">     621 </span>            : /* Time zone utilities */</a>
<span class="lineNum">     622 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     623 </span><span class="lineNoCov">          0 : uprv_tzset()</span>
<span class="lineNum">     624 </span>            : {
<span class="lineNum">     625 </span>            : #if defined(U_TZSET)
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     U_TZSET();</span>
<span class="lineNum">     627 </span>            : #else
<span class="lineNum">     628 </span>            :     /* no initialization*/
<span class="lineNum">     629 </span>            : #endif
<span class="lineNum">     630 </span><span class="lineNoCov">          0 : }</span>
<a name="631"><span class="lineNum">     631 </span>            : </a>
<span class="lineNum">     632 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     633 </span><span class="lineNoCov">          0 : uprv_timezone()</span>
<span class="lineNum">     634 </span>            : {
<span class="lineNum">     635 </span>            : #ifdef U_TIMEZONE
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     return U_TIMEZONE;</span>
<span class="lineNum">     637 </span>            : #else
<span class="lineNum">     638 </span>            :     time_t t, t1, t2;
<span class="lineNum">     639 </span>            :     struct tm tmrec;
<span class="lineNum">     640 </span>            :     int32_t tdiff = 0;
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :     time(&amp;t);
<span class="lineNum">     643 </span>            :     uprv_memcpy( &amp;tmrec, localtime(&amp;t), sizeof(tmrec) );
<span class="lineNum">     644 </span>            : #if U_PLATFORM != U_PF_IPHONE
<span class="lineNum">     645 </span>            :     UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/
<span class="lineNum">     646 </span>            : #endif
<span class="lineNum">     647 </span>            :     t1 = mktime(&amp;tmrec);                 /* local time in seconds*/
<span class="lineNum">     648 </span>            :     uprv_memcpy( &amp;tmrec, gmtime(&amp;t), sizeof(tmrec) );
<span class="lineNum">     649 </span>            :     t2 = mktime(&amp;tmrec);                 /* GMT (or UTC) in seconds*/
<span class="lineNum">     650 </span>            :     tdiff = t2 - t1;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : #if U_PLATFORM != U_PF_IPHONE
<span class="lineNum">     653 </span>            :     /* imitate NT behaviour, which returns same timezone offset to GMT for
<span class="lineNum">     654 </span>            :        winter and summer.
<span class="lineNum">     655 </span>            :        This does not work on all platforms. For instance, on glibc on Linux
<span class="lineNum">     656 </span>            :        and on Mac OS 10.5, tdiff calculated above remains the same
<span class="lineNum">     657 </span>            :        regardless of whether DST is in effect or not. iOS is another
<span class="lineNum">     658 </span>            :        platform where this does not work. Linux + glibc and Mac OS 10.5
<span class="lineNum">     659 </span>            :        have U_TIMEZONE defined so that this code is not reached.
<span class="lineNum">     660 </span>            :     */
<span class="lineNum">     661 </span>            :     if (dst_checked)
<span class="lineNum">     662 </span>            :         tdiff += 3600;
<span class="lineNum">     663 </span>            : #endif
<span class="lineNum">     664 </span>            :     return tdiff;
<span class="lineNum">     665 </span>            : #endif
<span class="lineNum">     666 </span>            : }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : /* Note that U_TZNAME does *not* have to be tzname, but if it is,
<span class="lineNum">     669 </span>            :    some platforms need to have it declared here. */
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : #if defined(U_TZNAME) &amp;&amp; (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED)
<span class="lineNum">     672 </span>            : /* RS6000 and others reject char **tzname.  */
<span class="lineNum">     673 </span>            : extern U_IMPORT char *U_TZNAME[];
<span class="lineNum">     674 </span>            : #endif
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : #if !UCONFIG_NO_FILE_IO &amp;&amp; ((U_PLATFORM_IS_DARWIN_BASED &amp;&amp; (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)
<span class="lineNum">     677 </span>            : /* These platforms are likely to use Olson timezone IDs. */
<span class="lineNum">     678 </span>            : #define CHECK_LOCALTIME_LINK 1
<span class="lineNum">     679 </span>            : #if U_PLATFORM_IS_DARWIN_BASED
<span class="lineNum">     680 </span>            : #include &lt;tzfile.h&gt;
<span class="lineNum">     681 </span>            : #define TZZONEINFO      (TZDIR &quot;/&quot;)
<span class="lineNum">     682 </span>            : #elif U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">     683 </span>            : #define TZDEFAULT       &quot;/etc/localtime&quot;
<span class="lineNum">     684 </span>            : #define TZZONEINFO      &quot;/usr/share/lib/zoneinfo/&quot;
<span class="lineNum">     685 </span>            : #define TZZONEINFO2     &quot;../usr/share/lib/zoneinfo/&quot;
<span class="lineNum">     686 </span>            : #define TZ_ENV_CHECK    &quot;localtime&quot;
<span class="lineNum">     687 </span>            : #else
<span class="lineNum">     688 </span>            : #define TZDEFAULT       &quot;/etc/localtime&quot;
<span class="lineNum">     689 </span>            : #define TZZONEINFO      &quot;/usr/share/zoneinfo/&quot;
<span class="lineNum">     690 </span>            : #endif
<span class="lineNum">     691 </span>            : #if U_HAVE_DIRENT_H
<span class="lineNum">     692 </span>            : #define TZFILE_SKIP     &quot;posixrules&quot; /* tz file to skip when searching. */
<span class="lineNum">     693 </span>            : /* Some Linux distributions have 'localtime' in /usr/share/zoneinfo
<span class="lineNum">     694 </span>            :    symlinked to /etc/localtime, which makes searchForTZFile return
<span class="lineNum">     695 </span>            :    'localtime' when it's the first match. */
<span class="lineNum">     696 </span>            : #define TZFILE_SKIP2    &quot;localtime&quot;
<span class="lineNum">     697 </span>            : #define SEARCH_TZFILE
<span class="lineNum">     698 </span>            : #include &lt;dirent.h&gt;  /* Needed to search through system timezone files */
<span class="lineNum">     699 </span>            : #endif
<span class="lineNum">     700 </span>            : static char gTimeZoneBuffer[PATH_MAX];
<span class="lineNum">     701 </span>            : static char *gTimeZoneBufferPtr = NULL;
<span class="lineNum">     702 </span>            : #endif
<span class="lineNum">     703 </span>            : 
<a name="704"><span class="lineNum">     704 </span>            : #if !U_PLATFORM_USES_ONLY_WIN32_API</a>
<span class="lineNum">     705 </span>            : #define isNonDigit(ch) (ch &lt; '0' || '9' &lt; ch)
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : static UBool isValidOlsonID(const char *id) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     int32_t idx = 0;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :     /* Determine if this is something like Iceland (Olson ID)
<span class="lineNum">     710 </span>            :     or AST4ADT (non-Olson ID) */
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     while (id[idx] &amp;&amp; isNonDigit(id[idx]) &amp;&amp; id[idx] != ',') {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         idx++;</span>
<span class="lineNum">     713 </span>            :     }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     /* If we went through the whole string, then it might be okay.
<span class="lineNum">     716 </span>            :     The timezone is sometimes set to &quot;CST-7CDT&quot;, &quot;CST6CDT5,J129,J131/19:30&quot;,
<span class="lineNum">     717 </span>            :     &quot;GRNLNDST3GRNLNDDT&quot; or similar, so we cannot use it.
<span class="lineNum">     718 </span>            :     The rest of the time it could be an Olson ID. George */
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     return (UBool)(id[idx] == 0</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :         || uprv_strcmp(id, &quot;PST8PDT&quot;) == 0</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         || uprv_strcmp(id, &quot;MST7MDT&quot;) == 0</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         || uprv_strcmp(id, &quot;CST6CDT&quot;) == 0</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :         || uprv_strcmp(id, &quot;EST5EDT&quot;) == 0);</span>
<span class="lineNum">     724 </span>            : }
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : /* On some Unix-like OS, 'posix' subdirectory in
<span class="lineNum">     727 </span>            :    /usr/share/zoneinfo replicates the top-level contents. 'right'
<span class="lineNum">     728 </span>            :    subdirectory has the same set of files, but individual files
<span class="lineNum">     729 </span>            :    are different from those in the top-level directory or 'posix'
<span class="lineNum">     730 </span>            :    because 'right' has files for TAI (Int'l Atomic Time) while 'posix'
<span class="lineNum">     731 </span>            :    has files for UTC.
<span class="lineNum">     732 </span>            :    When the first match for /etc/localtime is in either of them
<span class="lineNum">     733 </span>            :    (usually in posix because 'right' has different file contents),
<span class="lineNum">     734 </span>            :    or TZ environment variable points to one of them, createTimeZone
<span class="lineNum">     735 </span>            :    fails because, say, 'posix/America/New_York' is not an Olson
<a name="736"><span class="lineNum">     736 </span>            :    timezone id ('America/New_York' is). So, we have to skip</a>
<span class="lineNum">     737 </span>            :    'posix/' and 'right/' at the beginning. */
<span class="lineNum">     738 </span><span class="lineNoCov">          0 : static void skipZoneIDPrefix(const char** id) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     if (uprv_strncmp(*id, &quot;posix/&quot;, 6) == 0</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         || uprv_strncmp(*id, &quot;right/&quot;, 6) == 0)</span>
<span class="lineNum">     741 </span>            :     {
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         *id += 6;</span>
<span class="lineNum">     743 </span>            :     }
<span class="lineNum">     744 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     745 </span>            : #endif
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : #if defined(U_TZNAME) &amp;&amp; !U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            : #define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)
<span class="lineNum">     750 </span>            : typedef struct OffsetZoneMapping {
<span class="lineNum">     751 </span>            :     int32_t offsetSeconds;
<span class="lineNum">     752 </span>            :     int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/
<span class="lineNum">     753 </span>            :     const char *stdID;
<span class="lineNum">     754 </span>            :     const char *dstID;
<span class="lineNum">     755 </span>            :     const char *olsonID;
<span class="lineNum">     756 </span>            : } OffsetZoneMapping;
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : enum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : /*
<span class="lineNum">     761 </span>            : This list tries to disambiguate a set of abbreviated timezone IDs and offsets
<span class="lineNum">     762 </span>            : and maps it to an Olson ID.
<span class="lineNum">     763 </span>            : Before adding anything to this list, take a look at
<span class="lineNum">     764 </span>            : icu/source/tools/tzcode/tz.alias
<span class="lineNum">     765 </span>            : Sometimes no daylight savings (0) is important to define due to aliases.
<span class="lineNum">     766 </span>            : This list can be tested with icu/source/test/compat/tzone.pl
<span class="lineNum">     767 </span>            : More values could be added to daylightType to increase precision.
<span class="lineNum">     768 </span>            : */
<span class="lineNum">     769 </span>            : static const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {
<span class="lineNum">     770 </span>            :     {-45900, 2, &quot;CHAST&quot;, &quot;CHADT&quot;, &quot;Pacific/Chatham&quot;},
<span class="lineNum">     771 </span>            :     {-43200, 1, &quot;PETT&quot;, &quot;PETST&quot;, &quot;Asia/Kamchatka&quot;},
<span class="lineNum">     772 </span>            :     {-43200, 2, &quot;NZST&quot;, &quot;NZDT&quot;, &quot;Pacific/Auckland&quot;},
<span class="lineNum">     773 </span>            :     {-43200, 1, &quot;ANAT&quot;, &quot;ANAST&quot;, &quot;Asia/Anadyr&quot;},
<span class="lineNum">     774 </span>            :     {-39600, 1, &quot;MAGT&quot;, &quot;MAGST&quot;, &quot;Asia/Magadan&quot;},
<span class="lineNum">     775 </span>            :     {-37800, 2, &quot;LHST&quot;, &quot;LHST&quot;, &quot;Australia/Lord_Howe&quot;},
<span class="lineNum">     776 </span>            :     {-36000, 2, &quot;EST&quot;, &quot;EST&quot;, &quot;Australia/Sydney&quot;},
<span class="lineNum">     777 </span>            :     {-36000, 1, &quot;SAKT&quot;, &quot;SAKST&quot;, &quot;Asia/Sakhalin&quot;},
<span class="lineNum">     778 </span>            :     {-36000, 1, &quot;VLAT&quot;, &quot;VLAST&quot;, &quot;Asia/Vladivostok&quot;},
<span class="lineNum">     779 </span>            :     {-34200, 2, &quot;CST&quot;, &quot;CST&quot;, &quot;Australia/South&quot;},
<span class="lineNum">     780 </span>            :     {-32400, 1, &quot;YAKT&quot;, &quot;YAKST&quot;, &quot;Asia/Yakutsk&quot;},
<span class="lineNum">     781 </span>            :     {-32400, 1, &quot;CHOT&quot;, &quot;CHOST&quot;, &quot;Asia/Choibalsan&quot;},
<span class="lineNum">     782 </span>            :     {-31500, 2, &quot;CWST&quot;, &quot;CWST&quot;, &quot;Australia/Eucla&quot;},
<span class="lineNum">     783 </span>            :     {-28800, 1, &quot;IRKT&quot;, &quot;IRKST&quot;, &quot;Asia/Irkutsk&quot;},
<span class="lineNum">     784 </span>            :     {-28800, 1, &quot;ULAT&quot;, &quot;ULAST&quot;, &quot;Asia/Ulaanbaatar&quot;},
<span class="lineNum">     785 </span>            :     {-28800, 2, &quot;WST&quot;, &quot;WST&quot;, &quot;Australia/West&quot;},
<span class="lineNum">     786 </span>            :     {-25200, 1, &quot;HOVT&quot;, &quot;HOVST&quot;, &quot;Asia/Hovd&quot;},
<span class="lineNum">     787 </span>            :     {-25200, 1, &quot;KRAT&quot;, &quot;KRAST&quot;, &quot;Asia/Krasnoyarsk&quot;},
<span class="lineNum">     788 </span>            :     {-21600, 1, &quot;NOVT&quot;, &quot;NOVST&quot;, &quot;Asia/Novosibirsk&quot;},
<span class="lineNum">     789 </span>            :     {-21600, 1, &quot;OMST&quot;, &quot;OMSST&quot;, &quot;Asia/Omsk&quot;},
<span class="lineNum">     790 </span>            :     {-18000, 1, &quot;YEKT&quot;, &quot;YEKST&quot;, &quot;Asia/Yekaterinburg&quot;},
<span class="lineNum">     791 </span>            :     {-14400, 1, &quot;SAMT&quot;, &quot;SAMST&quot;, &quot;Europe/Samara&quot;},
<span class="lineNum">     792 </span>            :     {-14400, 1, &quot;AMT&quot;, &quot;AMST&quot;, &quot;Asia/Yerevan&quot;},
<span class="lineNum">     793 </span>            :     {-14400, 1, &quot;AZT&quot;, &quot;AZST&quot;, &quot;Asia/Baku&quot;},
<span class="lineNum">     794 </span>            :     {-10800, 1, &quot;AST&quot;, &quot;ADT&quot;, &quot;Asia/Baghdad&quot;},
<span class="lineNum">     795 </span>            :     {-10800, 1, &quot;MSK&quot;, &quot;MSD&quot;, &quot;Europe/Moscow&quot;},
<span class="lineNum">     796 </span>            :     {-10800, 1, &quot;VOLT&quot;, &quot;VOLST&quot;, &quot;Europe/Volgograd&quot;},
<span class="lineNum">     797 </span>            :     {-7200, 0, &quot;EET&quot;, &quot;CEST&quot;, &quot;Africa/Tripoli&quot;},
<span class="lineNum">     798 </span>            :     {-7200, 1, &quot;EET&quot;, &quot;EEST&quot;, &quot;Europe/Athens&quot;}, /* Conflicts with Africa/Cairo */
<span class="lineNum">     799 </span>            :     {-7200, 1, &quot;IST&quot;, &quot;IDT&quot;, &quot;Asia/Jerusalem&quot;},
<span class="lineNum">     800 </span>            :     {-3600, 0, &quot;CET&quot;, &quot;WEST&quot;, &quot;Africa/Algiers&quot;},
<span class="lineNum">     801 </span>            :     {-3600, 2, &quot;WAT&quot;, &quot;WAST&quot;, &quot;Africa/Windhoek&quot;},
<span class="lineNum">     802 </span>            :     {0, 1, &quot;GMT&quot;, &quot;IST&quot;, &quot;Europe/Dublin&quot;},
<span class="lineNum">     803 </span>            :     {0, 1, &quot;GMT&quot;, &quot;BST&quot;, &quot;Europe/London&quot;},
<span class="lineNum">     804 </span>            :     {0, 0, &quot;WET&quot;, &quot;WEST&quot;, &quot;Africa/Casablanca&quot;},
<span class="lineNum">     805 </span>            :     {0, 0, &quot;WET&quot;, &quot;WET&quot;, &quot;Africa/El_Aaiun&quot;},
<span class="lineNum">     806 </span>            :     {3600, 1, &quot;AZOT&quot;, &quot;AZOST&quot;, &quot;Atlantic/Azores&quot;},
<span class="lineNum">     807 </span>            :     {3600, 1, &quot;EGT&quot;, &quot;EGST&quot;, &quot;America/Scoresbysund&quot;},
<span class="lineNum">     808 </span>            :     {10800, 1, &quot;PMST&quot;, &quot;PMDT&quot;, &quot;America/Miquelon&quot;},
<span class="lineNum">     809 </span>            :     {10800, 2, &quot;UYT&quot;, &quot;UYST&quot;, &quot;America/Montevideo&quot;},
<span class="lineNum">     810 </span>            :     {10800, 1, &quot;WGT&quot;, &quot;WGST&quot;, &quot;America/Godthab&quot;},
<span class="lineNum">     811 </span>            :     {10800, 2, &quot;BRT&quot;, &quot;BRST&quot;, &quot;Brazil/East&quot;},
<span class="lineNum">     812 </span>            :     {12600, 1, &quot;NST&quot;, &quot;NDT&quot;, &quot;America/St_Johns&quot;},
<span class="lineNum">     813 </span>            :     {14400, 1, &quot;AST&quot;, &quot;ADT&quot;, &quot;Canada/Atlantic&quot;},
<span class="lineNum">     814 </span>            :     {14400, 2, &quot;AMT&quot;, &quot;AMST&quot;, &quot;America/Cuiaba&quot;},
<span class="lineNum">     815 </span>            :     {14400, 2, &quot;CLT&quot;, &quot;CLST&quot;, &quot;Chile/Continental&quot;},
<span class="lineNum">     816 </span>            :     {14400, 2, &quot;FKT&quot;, &quot;FKST&quot;, &quot;Atlantic/Stanley&quot;},
<span class="lineNum">     817 </span>            :     {14400, 2, &quot;PYT&quot;, &quot;PYST&quot;, &quot;America/Asuncion&quot;},
<span class="lineNum">     818 </span>            :     {18000, 1, &quot;CST&quot;, &quot;CDT&quot;, &quot;America/Havana&quot;},
<span class="lineNum">     819 </span>            :     {18000, 1, &quot;EST&quot;, &quot;EDT&quot;, &quot;US/Eastern&quot;}, /* Conflicts with America/Grand_Turk */
<span class="lineNum">     820 </span>            :     {21600, 2, &quot;EAST&quot;, &quot;EASST&quot;, &quot;Chile/EasterIsland&quot;},
<span class="lineNum">     821 </span>            :     {21600, 0, &quot;CST&quot;, &quot;MDT&quot;, &quot;Canada/Saskatchewan&quot;},
<span class="lineNum">     822 </span>            :     {21600, 0, &quot;CST&quot;, &quot;CDT&quot;, &quot;America/Guatemala&quot;},
<span class="lineNum">     823 </span>            :     {21600, 1, &quot;CST&quot;, &quot;CDT&quot;, &quot;US/Central&quot;}, /* Conflicts with Mexico/General */
<span class="lineNum">     824 </span>            :     {25200, 1, &quot;MST&quot;, &quot;MDT&quot;, &quot;US/Mountain&quot;}, /* Conflicts with Mexico/BajaSur */
<span class="lineNum">     825 </span>            :     {28800, 0, &quot;PST&quot;, &quot;PST&quot;, &quot;Pacific/Pitcairn&quot;},
<span class="lineNum">     826 </span>            :     {28800, 1, &quot;PST&quot;, &quot;PDT&quot;, &quot;US/Pacific&quot;}, /* Conflicts with Mexico/BajaNorte */
<span class="lineNum">     827 </span>            :     {32400, 1, &quot;AKST&quot;, &quot;AKDT&quot;, &quot;US/Alaska&quot;},
<span class="lineNum">     828 </span>            :     {36000, 1, &quot;HAST&quot;, &quot;HADT&quot;, &quot;US/Aleutian&quot;}
<span class="lineNum">     829 </span>            : };
<span class="lineNum">     830 </span>            : 
<a name="831"><span class="lineNum">     831 </span>            : /*#define DEBUG_TZNAME*/</a>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 : static const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)</span>
<span class="lineNum">     834 </span>            : {
<span class="lineNum">     835 </span>            :     int32_t idx;
<span class="lineNum">     836 </span>            : #ifdef DEBUG_TZNAME
<span class="lineNum">     837 </span>            :     fprintf(stderr, &quot;TZ=%s std=%s dst=%s daylight=%d offset=%d\n&quot;, getenv(&quot;TZ&quot;), stdID, dstID, daylightType, offset);
<span class="lineNum">     838 </span>            : #endif
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     for (idx = 0; idx &lt; UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)</span>
<span class="lineNum">     840 </span>            :     {
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :             &amp;&amp; daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :             &amp;&amp; strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :             &amp;&amp; strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)</span>
<span class="lineNum">     845 </span>            :         {
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :             return OFFSET_ZONE_MAPPINGS[idx].olsonID;</span>
<span class="lineNum">     847 </span>            :         }
<span class="lineNum">     848 </span>            :     }
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     850 </span>            : }
<span class="lineNum">     851 </span>            : #endif
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : #ifdef SEARCH_TZFILE
<span class="lineNum">     854 </span>            : #define MAX_READ_SIZE 512
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : typedef struct DefaultTZInfo {
<span class="lineNum">     857 </span>            :     char* defaultTZBuffer;
<span class="lineNum">     858 </span>            :     int64_t defaultTZFileSize;
<span class="lineNum">     859 </span>            :     FILE* defaultTZFilePtr;
<span class="lineNum">     860 </span>            :     UBool defaultTZstatus;
<span class="lineNum">     861 </span>            :     int32_t defaultTZPosition;
<span class="lineNum">     862 </span>            : } DefaultTZInfo;
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /*
<span class="lineNum">     865 </span>            :  * This method compares the two files given to see if they are a match.
<a name="866"><span class="lineNum">     866 </span>            :  * It is currently use to compare two TZ files.</a>
<span class="lineNum">     867 </span>            :  */
<span class="lineNum">     868 </span><span class="lineNoCov">          0 : static UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {</span>
<span class="lineNum">     869 </span>            :     FILE* file; 
<span class="lineNum">     870 </span>            :     int64_t sizeFile;
<span class="lineNum">     871 </span>            :     int64_t sizeFileLeft;
<span class="lineNum">     872 </span>            :     int32_t sizeFileRead;
<span class="lineNum">     873 </span>            :     int32_t sizeFileToRead;
<span class="lineNum">     874 </span>            :     char bufferFile[MAX_READ_SIZE];
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     UBool result = TRUE;</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     if (tzInfo-&gt;defaultTZFilePtr == NULL) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         tzInfo-&gt;defaultTZFilePtr = fopen(defaultTZFileName, &quot;r&quot;);</span>
<span class="lineNum">     879 </span>            :     }
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :     file = fopen(TZFileName, &quot;r&quot;);</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     tzInfo-&gt;defaultTZPosition = 0; /* reset position to begin search */</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     if (file != NULL &amp;&amp; tzInfo-&gt;defaultTZFilePtr != NULL) {</span>
<span class="lineNum">     885 </span>            :         /* First check that the file size are equal. */
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         if (tzInfo-&gt;defaultTZFileSize == 0) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :             fseek(tzInfo-&gt;defaultTZFilePtr, 0, SEEK_END);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :             tzInfo-&gt;defaultTZFileSize = ftell(tzInfo-&gt;defaultTZFilePtr);</span>
<span class="lineNum">     889 </span>            :         }
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         fseek(file, 0, SEEK_END);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         sizeFile = ftell(file);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         sizeFileLeft = sizeFile;</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         if (sizeFile != tzInfo-&gt;defaultTZFileSize) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :             result = FALSE;</span>
<span class="lineNum">     896 </span>            :         } else {
<span class="lineNum">     897 </span>            :             /* Store the data from the files in seperate buffers and
<span class="lineNum">     898 </span>            :              * compare each byte to determine equality.
<span class="lineNum">     899 </span>            :              */
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :             if (tzInfo-&gt;defaultTZBuffer == NULL) {</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :                 rewind(tzInfo-&gt;defaultTZFilePtr);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo-&gt;defaultTZFileSize);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 sizeFileRead = fread(tzInfo-&gt;defaultTZBuffer, 1, tzInfo-&gt;defaultTZFileSize, tzInfo-&gt;defaultTZFilePtr);</span>
<span class="lineNum">     904 </span>            :             }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :             rewind(file);</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :             while(sizeFileLeft &gt; 0) {</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 uprv_memset(bufferFile, 0, MAX_READ_SIZE);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :                 sizeFileToRead = sizeFileLeft &lt; MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                 sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 if (memcmp(tzInfo-&gt;defaultTZBuffer + tzInfo-&gt;defaultTZPosition, bufferFile, sizeFileRead) != 0) {</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                     result = FALSE;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     914 </span>            :                 }
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                 sizeFileLeft -= sizeFileRead;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZPosition += sizeFileRead;</span>
<span class="lineNum">     917 </span>            :             }
<span class="lineNum">     918 </span>            :         }
<span class="lineNum">     919 </span>            :     } else {
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         result = FALSE;</span>
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     if (file != NULL) {</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         fclose(file);</span>
<span class="lineNum">     925 </span>            :     }
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     928 </span>            : }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            : /* dirent also lists two entries: &quot;.&quot; and &quot;..&quot; that we can safely ignore. */
<span class="lineNum">     932 </span>            : #define SKIP1 &quot;.&quot;
<span class="lineNum">     933 </span>            : #define SKIP2 &quot;..&quot;
<span class="lineNum">     934 </span>            : static UBool U_CALLCONV putil_cleanup(void);
<span class="lineNum">     935 </span>            : static CharString *gSearchTZFileResult = NULL;
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            : /*
<span class="lineNum">     938 </span>            :  * This method recursively traverses the directory given for a matching TZ file and returns the first match.
<a name="939"><span class="lineNum">     939 </span>            :  * This function is not thread safe - it uses a global, gSearchTZFileResult, to hold its results.</a>
<span class="lineNum">     940 </span>            :  */
<span class="lineNum">     941 </span><span class="lineNoCov">          0 : static char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     DIR* dirp = opendir(path);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     DIR* subDirp = NULL;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     struct dirent* dirEntry = NULL;</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     char* result = NULL;</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     if (dirp == NULL) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     949 </span>            :     }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     if (gSearchTZFileResult == NULL) {</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         gSearchTZFileResult = new CharString;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         if (gSearchTZFileResult == NULL) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     955 </span>            :         }
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);</span>
<span class="lineNum">     957 </span>            :     }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :     /* Save the current path */
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     CharString curpath(path, -1, status);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     964 </span>            :     }
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :     /* Check each entry in the directory. */
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     while((dirEntry = readdir(dirp)) != NULL) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         const char* dirName = dirEntry-&gt;d_name;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         if (uprv_strcmp(dirName, SKIP1) != 0 &amp;&amp; uprv_strcmp(dirName, SKIP2) != 0) {</span>
<span class="lineNum">     970 </span>            :             /* Create a newpath with the new entry to test each entry in the directory. */
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :             CharString newpath(curpath, status);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :             newpath.append(dirName, -1, status);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             if (U_FAILURE(status)) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     975 </span>            :             }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :             if ((subDirp = opendir(newpath.data())) != NULL) {</span>
<span class="lineNum">     978 </span>            :                 /* If this new path is a directory, make a recursive call with the newpath. */
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :                 closedir(subDirp);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :                 newpath.append('/', status);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :                 if (U_FAILURE(status)) {</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :                     return NULL;</span>
<span class="lineNum">     983 </span>            :                 }
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 result = searchForTZFile(newpath.data(), tzInfo);</span>
<span class="lineNum">     985 </span>            :                 /*
<span class="lineNum">     986 </span>            :                  Have to get out here. Otherwise, we'd keep looking
<span class="lineNum">     987 </span>            :                  and return the first match in the top-level directory
<span class="lineNum">     988 </span>            :                  if there's a match in the top-level. If not, this function
<span class="lineNum">     989 </span>            :                  would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().
<span class="lineNum">     990 </span>            :                  It worked without this in most cases because we have a fallback of calling
<span class="lineNum">     991 </span>            :                  localtime_r to figure out the default timezone.
<span class="lineNum">     992 </span>            :                 */
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :                 if (result != NULL)</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :             } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 &amp;&amp; uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :                 if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :                     int32_t amountToSkip = sizeof(TZZONEINFO) - 1;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                     if (amountToSkip &gt; newpath.length()) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :                         amountToSkip = newpath.length();</span>
<span class="lineNum">    1000 </span>            :                     }
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                     const char* zoneid = newpath.data() + amountToSkip;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :                     skipZoneIDPrefix(&amp;zoneid);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :                     gSearchTZFileResult-&gt;clear();</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                     gSearchTZFileResult-&gt;append(zoneid, -1, status);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                     if (U_FAILURE(status)) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    1007 </span>            :                     }
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                     result = gSearchTZFileResult-&gt;data();</span>
<span class="lineNum">    1009 </span>            :                     /* Get out after the first one found. */
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1011 </span>            :                 }
<span class="lineNum">    1012 </span>            :             }
<span class="lineNum">    1013 </span>            :         }
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     closedir(dirp);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1017 </span>            : }
<span class="lineNum">    1018 </span>            : #endif
<a name="1019"><span class="lineNum">    1019 </span>            : </a>
<span class="lineNum">    1020 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 : uprv_tzname_clear_cache()</span>
<span class="lineNum">    1022 </span>            : {
<span class="lineNum">    1023 </span>            : #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     gTimeZoneBufferPtr = NULL;</span>
<span class="lineNum">    1025 </span>            : #endif
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : // With the Universal Windows Platform we can just ask Windows for the name
<span class="lineNum">    1029 </span>            : #if U_PLATFORM_HAS_WINUWP_API
<span class="lineNum">    1030 </span>            : U_CAPI const char* U_EXPORT2
<span class="lineNum">    1031 </span>            : uprv_getWindowsTimeZone()
<span class="lineNum">    1032 </span>            : {
<span class="lineNum">    1033 </span>            :     // Get default Windows timezone.   
<span class="lineNum">    1034 </span>            :     ComPtr&lt;IInspectable&gt; calendar;
<span class="lineNum">    1035 </span>            :     HRESULT hr = RoActivateInstance(
<span class="lineNum">    1036 </span>            :         HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),
<span class="lineNum">    1037 </span>            :         &amp;calendar);
<span class="lineNum">    1038 </span>            :     if (SUCCEEDED(hr))
<span class="lineNum">    1039 </span>            :     {
<span class="lineNum">    1040 </span>            :         ComPtr&lt;ABI::Windows::Globalization::ITimeZoneOnCalendar&gt; timezone;
<span class="lineNum">    1041 </span>            :         hr = calendar.As(&amp;timezone);
<span class="lineNum">    1042 </span>            :         if (SUCCEEDED(hr))
<span class="lineNum">    1043 </span>            :         {
<span class="lineNum">    1044 </span>            :             HString timezoneString;
<span class="lineNum">    1045 </span>            :             hr = timezone-&gt;GetTimeZone(timezoneString.GetAddressOf());
<span class="lineNum">    1046 </span>            :             if (SUCCEEDED(hr))
<span class="lineNum">    1047 </span>            :             {
<span class="lineNum">    1048 </span>            :                 int32_t length = wcslen(timezoneString.GetRawBuffer(NULL));
<span class="lineNum">    1049 </span>            :                 char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));
<span class="lineNum">    1050 </span>            :                 if (asciiId != nullptr)
<span class="lineNum">    1051 </span>            :                 {
<span class="lineNum">    1052 </span>            :                     u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);
<span class="lineNum">    1053 </span>            :                     return asciiId;
<span class="lineNum">    1054 </span>            :                 }
<span class="lineNum">    1055 </span>            :             }
<span class="lineNum">    1056 </span>            :         }
<span class="lineNum">    1057 </span>            :     }
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :     // Failed
<span class="lineNum">    1060 </span>            :     return nullptr;
<span class="lineNum">    1061 </span>            : }
<span class="lineNum">    1062 </span>            : #endif
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<span class="lineNum">    1064 </span>            : U_CAPI const char* U_EXPORT2
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 : uprv_tzname(int n)</span>
<span class="lineNum">    1066 </span>            : {
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     const char *tzid = NULL;</span>
<span class="lineNum">    1068 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1069 </span>            : #if U_PLATFORM_HAS_WINUWP_API &gt; 0
<span class="lineNum">    1070 </span>            :     tzid = uprv_getWindowsTimeZone();
<span class="lineNum">    1071 </span>            : #else
<span class="lineNum">    1072 </span>            :     tzid = uprv_detectWindowsTimeZone();
<span class="lineNum">    1073 </span>            : #endif
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :     if (tzid != NULL) {
<span class="lineNum">    1076 </span>            :         return tzid;
<span class="lineNum">    1077 </span>            :     }
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : #ifndef U_TZNAME
<span class="lineNum">    1080 </span>            :     // The return value is free'd in timezone.cpp on Windows because
<span class="lineNum">    1081 </span>            :     // the other code path returns a pointer to a heap location.
<span class="lineNum">    1082 </span>            :     // If we don't have a name already, then tzname wouldn't be any
<span class="lineNum">    1083 </span>            :     // better, so just fall back.
<span class="lineNum">    1084 </span>            :     return uprv_strdup(&quot;Etc/UTC&quot;);
<span class="lineNum">    1085 </span>            : #endif // !U_TZNAME
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            : #else
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : /*#if U_PLATFORM_IS_DARWIN_BASED
<span class="lineNum">    1090 </span>            :     int ret;
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :     tzid = getenv(&quot;TZFILE&quot;);
<span class="lineNum">    1093 </span>            :     if (tzid != NULL) {
<span class="lineNum">    1094 </span>            :         return tzid;
<span class="lineNum">    1095 </span>            :     }
<span class="lineNum">    1096 </span>            : #endif*/
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : /* This code can be temporarily disabled to test tzname resolution later on. */
<span class="lineNum">    1099 </span>            : #ifndef DEBUG_TZNAME
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     tzid = getenv(&quot;TZ&quot;);</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     if (tzid != NULL &amp;&amp; isValidOlsonID(tzid)</span>
<span class="lineNum">    1102 </span>            : #if U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">    1103 </span>            :     /* When TZ equals localtime on Solaris, check the /etc/localtime file. */
<span class="lineNum">    1104 </span>            :         &amp;&amp; uprv_strcmp(tzid, TZ_ENV_CHECK) != 0
<span class="lineNum">    1105 </span>            : #endif
<span class="lineNum">    1106 </span>            :     ) {
<span class="lineNum">    1107 </span>            :         /* The colon forces tzset() to treat the remainder as zoneinfo path */ 
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         if (tzid[0] == ':') { </span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :             tzid++; </span>
<span class="lineNum">    1110 </span>            :         } 
<span class="lineNum">    1111 </span>            :         /* This might be a good Olson ID. */
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :         skipZoneIDPrefix(&amp;tzid);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         return tzid;</span>
<span class="lineNum">    1114 </span>            :     }
<span class="lineNum">    1115 </span>            :     /* else U_TZNAME will give a better result. */
<span class="lineNum">    1116 </span>            : #endif
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            : #if defined(CHECK_LOCALTIME_LINK) &amp;&amp; !defined(DEBUG_SKIP_LOCALTIME_LINK)
<span class="lineNum">    1119 </span>            :     /* Caller must handle threading issues */
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     if (gTimeZoneBufferPtr == NULL) {</span>
<span class="lineNum">    1121 </span>            :         /*
<span class="lineNum">    1122 </span>            :         This is a trick to look at the name of the link to get the Olson ID
<span class="lineNum">    1123 </span>            :         because the tzfile contents is underspecified.
<span class="lineNum">    1124 </span>            :         This isn't guaranteed to work because it may not be a symlink.
<span class="lineNum">    1125 </span>            :         */
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer)-1);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :         if (0 &lt; ret) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :             int32_t tzZoneInfoLen = uprv_strlen(TZZONEINFO);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :             gTimeZoneBuffer[ret] = 0;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO, tzZoneInfoLen) == 0</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                 &amp;&amp; isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))</span>
<span class="lineNum">    1132 </span>            :             {
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :                 return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);</span>
<span class="lineNum">    1134 </span>            :             }
<span class="lineNum">    1135 </span>            : #if U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">    1136 </span>            :             else
<span class="lineNum">    1137 </span>            :             {
<span class="lineNum">    1138 </span>            :                 tzZoneInfoLen = uprv_strlen(TZZONEINFO2);
<span class="lineNum">    1139 </span>            :                 if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO2, tzZoneInfoLen) == 0
<span class="lineNum">    1140 </span>            :                                 &amp;&amp; isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))
<span class="lineNum">    1141 </span>            :                 {
<span class="lineNum">    1142 </span>            :                     return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);
<span class="lineNum">    1143 </span>            :                 }
<span class="lineNum">    1144 </span>            :             }
<span class="lineNum">    1145 </span>            : #endif
<span class="lineNum">    1146 </span>            :         } else {
<span class="lineNum">    1147 </span>            : #if defined(SEARCH_TZFILE)
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :             DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :             if (tzInfo != NULL) {</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZBuffer = NULL;</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZFileSize = 0;</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZFilePtr = NULL;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZstatus = FALSE;</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                 tzInfo-&gt;defaultTZPosition = 0;</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                 gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            :                 /* Free previously allocated memory */
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                 if (tzInfo-&gt;defaultTZBuffer != NULL) {</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :                     uprv_free(tzInfo-&gt;defaultTZBuffer);</span>
<span class="lineNum">    1161 </span>            :                 }
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                 if (tzInfo-&gt;defaultTZFilePtr != NULL) {</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     fclose(tzInfo-&gt;defaultTZFilePtr);</span>
<span class="lineNum">    1164 </span>            :                 }
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                 uprv_free(tzInfo);</span>
<span class="lineNum">    1166 </span>            :             }
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :             if (gTimeZoneBufferPtr != NULL &amp;&amp; isValidOlsonID(gTimeZoneBufferPtr)) {</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :                 return gTimeZoneBufferPtr;</span>
<span class="lineNum">    1170 </span>            :             }
<span class="lineNum">    1171 </span>            : #endif
<span class="lineNum">    1172 </span>            :         }
<span class="lineNum">    1173 </span>            :     }
<span class="lineNum">    1174 </span>            :     else {
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         return gTimeZoneBufferPtr;</span>
<span class="lineNum">    1176 </span>            :     }
<span class="lineNum">    1177 </span>            : #endif
<span class="lineNum">    1178 </span>            : #endif
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            : #ifdef U_TZNAME
<span class="lineNum">    1181 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1182 </span>            :     /* The return value is free'd in timezone.cpp on Windows because
<span class="lineNum">    1183 </span>            :      * the other code path returns a pointer to a heap location. */
<span class="lineNum">    1184 </span>            :     return uprv_strdup(U_TZNAME[n]);
<span class="lineNum">    1185 </span>            : #else
<span class="lineNum">    1186 </span>            :     /*
<span class="lineNum">    1187 </span>            :     U_TZNAME is usually a non-unique abbreviation, which isn't normally usable.
<span class="lineNum">    1188 </span>            :     So we remap the abbreviation to an olson ID.
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            :     Since Windows exposes a little more timezone information,
<span class="lineNum">    1191 </span>            :     we normally don't use this code on Windows because
<span class="lineNum">    1192 </span>            :     uprv_detectWindowsTimeZone should have already given the correct answer.
<span class="lineNum">    1193 </span>            :     */
<span class="lineNum">    1194 </span>            :     {
<span class="lineNum">    1195 </span>            :         struct tm juneSol, decemberSol;
<span class="lineNum">    1196 </span>            :         int daylightType;
<span class="lineNum">    1197 </span>            :         static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/
<span class="lineNum">    1198 </span>            :         static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :         /* This probing will tell us when daylight savings occurs.  */
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :         localtime_r(&amp;juneSolstice, &amp;juneSol);</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         localtime_r(&amp;decemberSolstice, &amp;decemberSol);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         if(decemberSol.tm_isdst &gt; 0) {</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :           daylightType = U_DAYLIGHT_DECEMBER;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :         } else if(juneSol.tm_isdst &gt; 0) {</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :           daylightType = U_DAYLIGHT_JUNE;</span>
<span class="lineNum">    1207 </span>            :         } else {
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :           daylightType = U_DAYLIGHT_NONE;</span>
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :         if (tzid != NULL) {</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :             return tzid;</span>
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     return U_TZNAME[n];</span>
<span class="lineNum">    1216 </span>            : #endif
<span class="lineNum">    1217 </span>            : #else
<span class="lineNum">    1218 </span>            :     return &quot;&quot;;
<span class="lineNum">    1219 </span>            : #endif
<span class="lineNum">    1220 </span>            : }
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : /* Get and set the ICU data directory --------------------------------------- */
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : static icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;
<span class="lineNum">    1225 </span>            : static char *gDataDirectory = NULL;
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            : UInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;
<span class="lineNum">    1228 </span>            : static CharString *gTimeZoneFilesDirectory = NULL;
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            : #if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1231 </span>            :  static char *gCorrectedPOSIXLocale = NULL; /* Sometimes heap allocated */
<span class="lineNum">    1232 </span>            :  static bool gCorrectedPOSIXLocaleHeapAllocated = false;
<a name="1233"><span class="lineNum">    1233 </span>            : #endif</a>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 : static UBool U_CALLCONV putil_cleanup(void)</span>
<span class="lineNum">    1236 </span>            : {
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :     if (gDataDirectory &amp;&amp; *gDataDirectory) {</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :         uprv_free(gDataDirectory);</span>
<span class="lineNum">    1239 </span>            :     }
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     gDataDirectory = NULL;</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     gDataDirInitOnce.reset();</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     delete gTimeZoneFilesDirectory;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     gTimeZoneFilesDirectory = NULL;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     gTimeZoneFilesInitOnce.reset();</span>
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            : #ifdef SEARCH_TZFILE
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :     delete gSearchTZFileResult;</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     gSearchTZFileResult = NULL;</span>
<span class="lineNum">    1250 </span>            : #endif
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            : #if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     if (gCorrectedPOSIXLocale &amp;&amp; gCorrectedPOSIXLocaleHeapAllocated) {</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         uprv_free(gCorrectedPOSIXLocale);</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         gCorrectedPOSIXLocale = NULL;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         gCorrectedPOSIXLocaleHeapAllocated = false;</span>
<span class="lineNum">    1257 </span>            :     }
<span class="lineNum">    1258 </span>            : #endif
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1260 </span>            : }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            : /*
<span class="lineNum">    1263 </span>            :  * Set the data directory.
<span class="lineNum">    1264 </span>            :  *    Make a copy of the passed string, and set the global data dir to point to it.
<a name="1265"><span class="lineNum">    1265 </span>            :  */</a>
<span class="lineNum">    1266 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1267 </span><span class="lineCov">          3 : u_setDataDirectory(const char *directory) {</span>
<span class="lineNum">    1268 </span>            :     char *newDataDir;
<span class="lineNum">    1269 </span>            :     int32_t length;
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span><span class="lineCov">          3 :     if(directory==NULL || *directory==0) {</span>
<span class="lineNum">    1272 </span>            :         /* A small optimization to prevent the malloc and copy when the
<span class="lineNum">    1273 </span>            :         shared library is used, and this is a way to make sure that NULL
<span class="lineNum">    1274 </span>            :         is never returned.
<span class="lineNum">    1275 </span>            :         */
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         newDataDir = (char *)&quot;&quot;;</span>
<span class="lineNum">    1277 </span>            :     }
<span class="lineNum">    1278 </span>            :     else {
<span class="lineNum">    1279 </span><span class="lineCov">          3 :         length=(int32_t)uprv_strlen(directory);</span>
<span class="lineNum">    1280 </span><span class="lineCov">          3 :         newDataDir = (char *)uprv_malloc(length + 2);</span>
<span class="lineNum">    1281 </span>            :         /* Exit out if newDataDir could not be created. */
<span class="lineNum">    1282 </span><span class="lineCov">          3 :         if (newDataDir == NULL) {</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1284 </span>            :         }
<span class="lineNum">    1285 </span><span class="lineCov">          3 :         uprv_strcpy(newDataDir, directory);</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            : #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
<span class="lineNum">    1288 </span>            :         {
<span class="lineNum">    1289 </span>            :             char *p;
<span class="lineNum">    1290 </span>            :             while(p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) {
<span class="lineNum">    1291 </span>            :                 *p = U_FILE_SEP_CHAR;
<span class="lineNum">    1292 </span>            :             }
<span class="lineNum">    1293 </span>            :         }
<span class="lineNum">    1294 </span>            : #endif
<span class="lineNum">    1295 </span>            :     }
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span><span class="lineCov">          3 :     if (gDataDirectory &amp;&amp; *gDataDirectory) {</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :         uprv_free(gDataDirectory);</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span><span class="lineCov">          3 :     gDataDirectory = newDataDir;</span>
<span class="lineNum">    1301 </span><span class="lineCov">          3 :     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);</span>
<span class="lineNum">    1302 </span>            : }
<a name="1303"><span class="lineNum">    1303 </span>            : </a>
<span class="lineNum">    1304 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 : uprv_pathIsAbsolute(const char *path)</span>
<span class="lineNum">    1306 </span>            : {
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   if(!path || !*path) {</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1309 </span>            :   }
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :   if(*path == U_FILE_SEP_CHAR) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1313 </span>            :   }
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            : #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
<span class="lineNum">    1316 </span>            :   if(*path == U_FILE_ALT_SEP_CHAR) {
<span class="lineNum">    1317 </span>            :     return TRUE;
<span class="lineNum">    1318 </span>            :   }
<span class="lineNum">    1319 </span>            : #endif
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : #if U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1322 </span>            :   if( (((path[0] &gt;= 'A') &amp;&amp; (path[0] &lt;= 'Z')) ||
<span class="lineNum">    1323 </span>            :        ((path[0] &gt;= 'a') &amp;&amp; (path[0] &lt;= 'z'))) &amp;&amp;
<span class="lineNum">    1324 </span>            :       path[1] == ':' ) {
<span class="lineNum">    1325 </span>            :     return TRUE;
<span class="lineNum">    1326 </span>            :   }
<span class="lineNum">    1327 </span>            : #endif
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   return FALSE;</span>
<span class="lineNum">    1330 </span>            : }
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : /* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR
<span class="lineNum">    1333 </span>            :    until some client wrapper makefiles are updated */
<span class="lineNum">    1334 </span>            : #if U_PLATFORM_IS_DARWIN_BASED &amp;&amp; TARGET_IPHONE_SIMULATOR
<span class="lineNum">    1335 </span>            : # if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
<span class="lineNum">    1336 </span>            : #  define ICU_DATA_DIR_PREFIX_ENV_VAR &quot;IPHONE_SIMULATOR_ROOT&quot;
<span class="lineNum">    1337 </span>            : # endif
<a name="1338"><span class="lineNum">    1338 </span>            : #endif</a>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">          3 : static void U_CALLCONV dataDirectoryInitFn() {</span>
<span class="lineNum">    1341 </span>            :     /* If we already have the directory, then return immediately. Will happen if user called
<span class="lineNum">    1342 </span>            :      * u_setDataDirectory().
<span class="lineNum">    1343 </span>            :      */
<span class="lineNum">    1344 </span><span class="lineCov">          3 :     if (gDataDirectory) {</span>
<span class="lineNum">    1345 </span><span class="lineCov">          3 :         return;</span>
<span class="lineNum">    1346 </span>            :     }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     const char *path = NULL;</span>
<span class="lineNum">    1349 </span>            : #if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
<span class="lineNum">    1350 </span>            :     char datadir_path_buffer[PATH_MAX];
<span class="lineNum">    1351 </span>            : #endif
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :     /*
<span class="lineNum">    1354 </span>            :     When ICU_NO_USER_DATA_OVERRIDE is defined, users aren't allowed to
<span class="lineNum">    1355 </span>            :     override ICU's data with the ICU_DATA environment variable. This prevents
<span class="lineNum">    1356 </span>            :     problems where multiple custom copies of ICU's specific version of data
<span class="lineNum">    1357 </span>            :     are installed on a system. Either the application must define the data
<span class="lineNum">    1358 </span>            :     directory with u_setDataDirectory, define ICU_DATA_DIR when compiling
<span class="lineNum">    1359 </span>            :     ICU, set the data with udata_setCommonData or trust that all of the
<span class="lineNum">    1360 </span>            :     required data is contained in ICU's data library that contains
<span class="lineNum">    1361 </span>            :     the entry point defined by U_ICUDATA_ENTRY_POINT.
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :     There may also be some platforms where environment variables
<span class="lineNum">    1364 </span>            :     are not allowed.
<span class="lineNum">    1365 </span>            :     */
<span class="lineNum">    1366 </span>            : #   if !defined(ICU_NO_USER_DATA_OVERRIDE) &amp;&amp; !UCONFIG_NO_FILE_IO
<span class="lineNum">    1367 </span>            :     /* First try to get the environment variable */
<span class="lineNum">    1368 </span>            : #       if U_PLATFORM_HAS_WINUWP_API == 0  // Windows UWP does not support getenv
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         path=getenv(&quot;ICU_DATA&quot;);</span>
<span class="lineNum">    1370 </span>            : #       endif
<span class="lineNum">    1371 </span>            : #   endif
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :     /* ICU_DATA_DIR may be set as a compile option.
<span class="lineNum">    1374 </span>            :      * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time
<span class="lineNum">    1375 </span>            :      * and is used only when data is built in archive mode eliminating the need
<span class="lineNum">    1376 </span>            :      * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation
<span class="lineNum">    1377 </span>            :      * directory of the data dat file. Users should use ICU_DATA_DIR if they want to
<span class="lineNum">    1378 </span>            :      * set their own path.
<span class="lineNum">    1379 </span>            :      */
<span class="lineNum">    1380 </span>            : #if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)
<span class="lineNum">    1381 </span>            :     if(path==NULL || *path==0) {
<span class="lineNum">    1382 </span>            : # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
<span class="lineNum">    1383 </span>            :         const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);
<span class="lineNum">    1384 </span>            : # endif
<span class="lineNum">    1385 </span>            : # ifdef ICU_DATA_DIR
<span class="lineNum">    1386 </span>            :         path=ICU_DATA_DIR;
<span class="lineNum">    1387 </span>            : # else
<span class="lineNum">    1388 </span>            :         path=U_ICU_DATA_DEFAULT_DIR;
<span class="lineNum">    1389 </span>            : # endif
<span class="lineNum">    1390 </span>            : # if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)
<span class="lineNum">    1391 </span>            :         if (prefix != NULL) {
<span class="lineNum">    1392 </span>            :             snprintf(datadir_path_buffer, PATH_MAX, &quot;%s%s&quot;, prefix, path);
<span class="lineNum">    1393 </span>            :             path=datadir_path_buffer;
<span class="lineNum">    1394 </span>            :         }
<span class="lineNum">    1395 </span>            : # endif
<span class="lineNum">    1396 </span>            :     }
<span class="lineNum">    1397 </span>            : #endif
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            : #if defined(ICU_DATA_DIR_WINDOWS) &amp;&amp; U_PLATFORM_HAS_WINUWP_API != 0
<span class="lineNum">    1400 </span>            :     // Use data from the %windir%\globalization\icu directory
<span class="lineNum">    1401 </span>            :     // This is only available if ICU is built as a system component
<span class="lineNum">    1402 </span>            :     char datadir_path_buffer[MAX_PATH];
<span class="lineNum">    1403 </span>            :     UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));
<span class="lineNum">    1404 </span>            :     if (length &gt; 0 &amp;&amp; length &lt; (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))
<span class="lineNum">    1405 </span>            :     {
<span class="lineNum">    1406 </span>            :         if (datadir_path_buffer[length - 1] != '\\')
<span class="lineNum">    1407 </span>            :         {
<span class="lineNum">    1408 </span>            :             datadir_path_buffer[length++] = '\\';
<span class="lineNum">    1409 </span>            :             datadir_path_buffer[length] = '\0';
<span class="lineNum">    1410 </span>            :         }
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            :         if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) &lt; UPRV_LENGTHOF(datadir_path_buffer))
<span class="lineNum">    1413 </span>            :         {
<span class="lineNum">    1414 </span>            :             uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);
<span class="lineNum">    1415 </span>            :             path = datadir_path_buffer;
<span class="lineNum">    1416 </span>            :         }
<span class="lineNum">    1417 </span>            :     }
<span class="lineNum">    1418 </span>            : #endif
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     if(path==NULL) {</span>
<span class="lineNum">    1421 </span>            :         /* It looks really bad, set it to something. */
<span class="lineNum">    1422 </span>            : #if U_PLATFORM_HAS_WIN32_API
<span class="lineNum">    1423 </span>            :         // Windows UWP will require icudtl.dat file in same directory as icuuc.dll
<span class="lineNum">    1424 </span>            :         path = &quot;.\\&quot;;
<span class="lineNum">    1425 </span>            : #else
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :         path = &quot;&quot;;</span>
<span class="lineNum">    1427 </span>            : #endif
<span class="lineNum">    1428 </span>            :     }
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     u_setDataDirectory(path);</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1432 </span>            : }
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<span class="lineNum">    1434 </span>            : U_CAPI const char * U_EXPORT2
<span class="lineNum">    1435 </span><span class="lineCov">         10 : u_getDataDirectory(void) {</span>
<span class="lineNum">    1436 </span><span class="lineCov">         10 :     umtx_initOnce(gDataDirInitOnce, &amp;dataDirectoryInitFn);</span>
<span class="lineNum">    1437 </span><span class="lineCov">         10 :     return gDataDirectory;</span>
<a name="1438"><span class="lineNum">    1438 </span>            : }</a>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 : static void setTimeZoneFilesDir(const char *path, UErrorCode &amp;status) {</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1443 </span>            :     }
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     gTimeZoneFilesDirectory-&gt;clear();</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     gTimeZoneFilesDirectory-&gt;append(path, status);</span>
<span class="lineNum">    1446 </span>            : #if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)
<span class="lineNum">    1447 </span>            :     char *p = gTimeZoneFilesDirectory-&gt;data();
<span class="lineNum">    1448 </span>            :     while (p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) {
<span class="lineNum">    1449 </span>            :         *p = U_FILE_SEP_CHAR;
<span class="lineNum">    1450 </span>            :     }
<span class="lineNum">    1451 </span>            : #endif
<span class="lineNum">    1452 </span>            : }
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            : #define TO_STRING(x) TO_STRING_2(x) 
<a name="1455"><span class="lineNum">    1455 </span>            : #define TO_STRING_2(x) #x</a>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 : static void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &amp;status) {</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :     U_ASSERT(gTimeZoneFilesDirectory == NULL);</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     gTimeZoneFilesDirectory = new CharString();</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     if (gTimeZoneFilesDirectory == NULL) {</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1464 </span>            :     }
<span class="lineNum">    1465 </span>            : #if U_PLATFORM_HAS_WINUWP_API == 0
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     const char *dir = getenv(&quot;ICU_TIMEZONE_FILES_DIR&quot;);</span>
<span class="lineNum">    1467 </span>            : #else
<span class="lineNum">    1468 </span>            :     // TODO: UWP does not support alternate timezone data directories at this time
<span class="lineNum">    1469 </span>            :     const char *dir = &quot;&quot;;
<span class="lineNum">    1470 </span>            : #endif // U_PLATFORM_HAS_WINUWP_API
<span class="lineNum">    1471 </span>            : #if defined(U_TIMEZONE_FILES_DIR)
<span class="lineNum">    1472 </span>            :     if (dir == NULL) {
<span class="lineNum">    1473 </span>            :         dir = TO_STRING(U_TIMEZONE_FILES_DIR);
<span class="lineNum">    1474 </span>            :     }
<span class="lineNum">    1475 </span>            : #endif
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     if (dir == NULL) {</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         dir = &quot;&quot;;</span>
<span class="lineNum">    1478 </span>            :     }
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     setTimeZoneFilesDir(dir, status);</span>
<span class="lineNum">    1480 </span>            : }
<span class="lineNum">    1481 </span>            : 
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<span class="lineNum">    1483 </span>            : U_CAPI const char * U_EXPORT2
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 : u_getTimeZoneFilesDirectory(UErrorCode *status) {</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     return U_SUCCESS(*status) ? gTimeZoneFilesDirectory-&gt;data() : &quot;&quot;;</span>
<span class="lineNum">    1487 </span>            : }
<a name="1488"><span class="lineNum">    1488 </span>            : </a>
<span class="lineNum">    1489 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 : u_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :     umtx_initOnce(gTimeZoneFilesInitOnce, &amp;TimeZoneDataDirInitFn, *status);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     setTimeZoneFilesDir(path, *status);</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :     // Note: this function does some extra churn, first setting based on the
<span class="lineNum">    1495 </span>            :     //       environment, then immediately replacing with the value passed in.
<span class="lineNum">    1496 </span>            :     //       The logic is simpler that way, and performance shouldn't be an issue.
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            : #if U_POSIX_LOCALE
<span class="lineNum">    1501 </span>            : /* A helper function used by uprv_getPOSIXIDForDefaultLocale and
<span class="lineNum">    1502 </span>            :  * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for
<a name="1503"><span class="lineNum">    1503 </span>            :  * LC_CTYPE and LC_MESSAGES. It doesn't support other locale categories.</a>
<span class="lineNum">    1504 </span>            :  */
<span class="lineNum">    1505 </span><span class="lineCov">          2 : static const char *uprv_getPOSIXIDForCategory(int category)</span>
<span class="lineNum">    1506 </span>            : {
<span class="lineNum">    1507 </span><span class="lineCov">          2 :     const char* posixID = NULL;</span>
<span class="lineNum">    1508 </span><span class="lineCov">          2 :     if (category == LC_MESSAGES || category == LC_CTYPE) {</span>
<span class="lineNum">    1509 </span>            :         /*
<span class="lineNum">    1510 </span>            :         * On Solaris two different calls to setlocale can result in
<span class="lineNum">    1511 </span>            :         * different values. Only get this value once.
<span class="lineNum">    1512 </span>            :         *
<span class="lineNum">    1513 </span>            :         * We must check this first because an application can set this.
<span class="lineNum">    1514 </span>            :         *
<span class="lineNum">    1515 </span>            :         * LC_ALL can't be used because it's platform dependent. The LANG
<span class="lineNum">    1516 </span>            :         * environment variable seems to affect LC_CTYPE variable by default.
<span class="lineNum">    1517 </span>            :         * Here is what setlocale(LC_ALL, NULL) can return.
<span class="lineNum">    1518 </span>            :         * HPUX can return 'C C C C C C C'
<span class="lineNum">    1519 </span>            :         * Solaris can return /en_US/C/C/C/C/C on the second try.
<span class="lineNum">    1520 </span>            :         * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...
<span class="lineNum">    1521 </span>            :         *
<span class="lineNum">    1522 </span>            :         * The default codepage detection also needs to use LC_CTYPE.
<span class="lineNum">    1523 </span>            :         *
<span class="lineNum">    1524 </span>            :         * Do not call setlocale(LC_*, &quot;&quot;)! Using an empty string instead
<span class="lineNum">    1525 </span>            :         * of NULL, will modify the libc behavior.
<span class="lineNum">    1526 </span>            :         */
<span class="lineNum">    1527 </span><span class="lineCov">          2 :         posixID = setlocale(category, NULL);</span>
<span class="lineNum">    1528 </span><span class="lineCov">          2 :         if ((posixID == 0)</span>
<span class="lineNum">    1529 </span><span class="lineCov">          2 :             || (uprv_strcmp(&quot;C&quot;, posixID) == 0)</span>
<span class="lineNum">    1530 </span><span class="lineCov">          2 :             || (uprv_strcmp(&quot;POSIX&quot;, posixID) == 0))</span>
<span class="lineNum">    1531 </span>            :         {
<span class="lineNum">    1532 </span>            :             /* Maybe we got some garbage.  Try something more reasonable */
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :             posixID = getenv(&quot;LC_ALL&quot;);</span>
<span class="lineNum">    1534 </span>            :             /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008 
<span class="lineNum">    1535 </span>            :              * This is needed to properly handle empty env. variables
<span class="lineNum">    1536 </span>            :              */
<span class="lineNum">    1537 </span>            : #if U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">    1538 </span>            :             if ((posixID == 0) || (posixID[0] == '\0')) {
<span class="lineNum">    1539 </span>            :                 posixID = getenv(category == LC_MESSAGES ? &quot;LC_MESSAGES&quot; : &quot;LC_CTYPE&quot;);
<span class="lineNum">    1540 </span>            :                 if ((posixID == 0) || (posixID[0] == '\0')) {
<span class="lineNum">    1541 </span>            : #else
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :             if (posixID == 0) {</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                 posixID = getenv(category == LC_MESSAGES ? &quot;LC_MESSAGES&quot; : &quot;LC_CTYPE&quot;);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :                 if (posixID == 0) {</span>
<span class="lineNum">    1545 </span>            : #endif                    
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :                     posixID = getenv(&quot;LANG&quot;);</span>
<span class="lineNum">    1547 </span>            :                 }
<span class="lineNum">    1548 </span>            :             }
<span class="lineNum">    1549 </span>            :         }
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span><span class="lineCov">          2 :     if ((posixID==0)</span>
<span class="lineNum">    1552 </span><span class="lineCov">          2 :         || (uprv_strcmp(&quot;C&quot;, posixID) == 0)</span>
<span class="lineNum">    1553 </span><span class="lineCov">          2 :         || (uprv_strcmp(&quot;POSIX&quot;, posixID) == 0))</span>
<span class="lineNum">    1554 </span>            :     {
<span class="lineNum">    1555 </span>            :         /* Nothing worked.  Give it a nice POSIX default value. */
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         posixID = &quot;en_US_POSIX&quot;;</span>
<span class="lineNum">    1557 </span>            :     }
<span class="lineNum">    1558 </span><span class="lineCov">          2 :     return posixID;</span>
<span class="lineNum">    1559 </span>            : }
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : /* Return just the POSIX id for the default locale, whatever happens to be in
<a name="1562"><span class="lineNum">    1562 </span>            :  * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.</a>
<span class="lineNum">    1563 </span>            :  */
<span class="lineNum">    1564 </span><span class="lineCov">          2 : static const char *uprv_getPOSIXIDForDefaultLocale(void)</span>
<span class="lineNum">    1565 </span>            : {
<span class="lineNum">    1566 </span>            :     static const char* posixID = NULL;
<span class="lineNum">    1567 </span><span class="lineCov">          2 :     if (posixID == 0) {</span>
<span class="lineNum">    1568 </span><span class="lineCov">          2 :         posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);</span>
<span class="lineNum">    1569 </span>            :     }
<span class="lineNum">    1570 </span><span class="lineCov">          2 :     return posixID;</span>
<span class="lineNum">    1571 </span>            : }
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span>            : #if !U_CHARSET_IS_UTF8
<span class="lineNum">    1574 </span>            : /* Return just the POSIX id for the default codepage, whatever happens to be in
<span class="lineNum">    1575 </span>            :  * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.
<span class="lineNum">    1576 </span>            :  */
<span class="lineNum">    1577 </span>            : static const char *uprv_getPOSIXIDForDefaultCodepage(void)
<span class="lineNum">    1578 </span>            : {
<span class="lineNum">    1579 </span>            :     static const char* posixID = NULL;
<span class="lineNum">    1580 </span>            :     if (posixID == 0) {
<span class="lineNum">    1581 </span>            :         posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);
<span class="lineNum">    1582 </span>            :     }
<span class="lineNum">    1583 </span>            :     return posixID;
<span class="lineNum">    1584 </span>            : }
<span class="lineNum">    1585 </span>            : #endif
<span class="lineNum">    1586 </span>            : #endif
<span class="lineNum">    1587 </span>            : 
<a name="1588"><span class="lineNum">    1588 </span>            : /* NOTE: The caller should handle thread safety */</a>
<span class="lineNum">    1589 </span>            : U_CAPI const char* U_EXPORT2
<span class="lineNum">    1590 </span><span class="lineCov">          2 : uprv_getDefaultLocaleID()</span>
<span class="lineNum">    1591 </span>            : {
<span class="lineNum">    1592 </span>            : #if U_POSIX_LOCALE
<span class="lineNum">    1593 </span>            : /*
<span class="lineNum">    1594 </span>            :   Note that:  (a '!' means the ID is improper somehow)
<span class="lineNum">    1595 </span>            :      LC_ALL  ----&gt;     default_loc          codepage
<span class="lineNum">    1596 </span>            : --------------------------------------------------------
<span class="lineNum">    1597 </span>            :      ab.CD             ab                   CD
<span class="lineNum">    1598 </span>            :      ab@CD             ab__CD               -
<span class="lineNum">    1599 </span>            :      ab@CD.EF          ab__CD               EF
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :      ab_CD.EF@GH       ab_CD_GH             EF
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            : Some 'improper' ways to do the same as above:
<span class="lineNum">    1604 </span>            :   !  ab_CD@GH.EF       ab_CD_GH             EF
<span class="lineNum">    1605 </span>            :   !  ab_CD.EF@GH.IJ    ab_CD_GH             EF
<span class="lineNum">    1606 </span>            :   !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            :      _CD@GH            _CD_GH               -
<span class="lineNum">    1609 </span>            :      _CD.EF@GH         _CD_GH               EF
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : The variant cannot have dots in it.
<span class="lineNum">    1612 </span>            : The 'rightmost' variant (@xxx) wins.
<span class="lineNum">    1613 </span>            : The leftmost codepage (.xxx) wins.
<span class="lineNum">    1614 </span>            : */
<span class="lineNum">    1615 </span><span class="lineCov">          2 :     char *correctedPOSIXLocale = 0;</span>
<span class="lineNum">    1616 </span><span class="lineCov">          2 :     const char* posixID = uprv_getPOSIXIDForDefaultLocale();</span>
<span class="lineNum">    1617 </span>            :     const char *p;
<span class="lineNum">    1618 </span>            :     const char *q;
<span class="lineNum">    1619 </span>            :     int32_t len;
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :     /* Format: (no spaces)
<span class="lineNum">    1622 </span>            :     ll [ _CC ] [ . MM ] [ @ VV]
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :       l = lang, C = ctry, M = charmap, V = variant
<span class="lineNum">    1625 </span>            :     */
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span><span class="lineCov">          2 :     if (gCorrectedPOSIXLocale != NULL) {</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :         return gCorrectedPOSIXLocale;</span>
<span class="lineNum">    1629 </span>            :     }
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineCov">          2 :     if ((p = uprv_strchr(posixID, '.')) != NULL) {</span>
<span class="lineNum">    1632 </span>            :         /* assume new locale can't be larger than old one? */
<span class="lineNum">    1633 </span><span class="lineCov">          2 :         correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="lineNum">    1634 </span>            :         /* Exit on memory allocation error. */
<span class="lineNum">    1635 </span><span class="lineCov">          2 :         if (correctedPOSIXLocale == NULL) {</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1637 </span>            :         }
<span class="lineNum">    1638 </span><span class="lineCov">          2 :         uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="lineNum">    1639 </span><span class="lineCov">          2 :         correctedPOSIXLocale[p-posixID] = 0;</span>
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span>            :         /* do not copy after the @ */
<span class="lineNum">    1642 </span><span class="lineCov">          2 :         if ((p = uprv_strchr(correctedPOSIXLocale, '@')) != NULL) {</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :             correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;</span>
<span class="lineNum">    1644 </span>            :         }
<span class="lineNum">    1645 </span>            :     }
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            :     /* Note that we scan the *uncorrected* ID. */
<span class="lineNum">    1648 </span><span class="lineCov">          2 :     if ((p = uprv_strrchr(posixID, '@')) != NULL) {</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         if (correctedPOSIXLocale == NULL) {</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :             correctedPOSIXLocale = static_cast&lt;char *&gt;(uprv_malloc(uprv_strlen(posixID)+1));</span>
<span class="lineNum">    1651 </span>            :             /* Exit on memory allocation error. */
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :             if (correctedPOSIXLocale == NULL) {</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1654 </span>            :             }
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :             uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :             correctedPOSIXLocale[p-posixID] = 0;</span>
<span class="lineNum">    1657 </span>            :         }
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :         p++;</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            :         /* Take care of any special cases here.. */
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :         if (!uprv_strcmp(p, &quot;nynorsk&quot;)) {</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :             p = &quot;NY&quot;;</span>
<span class="lineNum">    1663 </span>            :             /* Don't worry about no__NY. In practice, it won't appear. */
<span class="lineNum">    1664 </span>            :         }
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :         if (uprv_strchr(correctedPOSIXLocale,'_') == NULL) {</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :             uprv_strcat(correctedPOSIXLocale, &quot;__&quot;); /* aa@b -&gt; aa__b */</span>
<span class="lineNum">    1668 </span>            :         }
<span class="lineNum">    1669 </span>            :         else {
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :             uprv_strcat(correctedPOSIXLocale, &quot;_&quot;); /* aa_CC@b -&gt; aa_CC_b */</span>
<span class="lineNum">    1671 </span>            :         }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :         if ((q = uprv_strchr(p, '.')) != NULL) {</span>
<span class="lineNum">    1674 </span>            :             /* How big will the resulting string be? */
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :             len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :             uprv_strncat(correctedPOSIXLocale, p, q-p);</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :             correctedPOSIXLocale[len] = 0;</span>
<span class="lineNum">    1678 </span>            :         }
<span class="lineNum">    1679 </span>            :         else {
<span class="lineNum">    1680 </span>            :             /* Anything following the @ sign */
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :             uprv_strcat(correctedPOSIXLocale, p);</span>
<span class="lineNum">    1682 </span>            :         }
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :         /* Should there be a map from 'no@nynorsk' -&gt; no_NO_NY here?
<span class="lineNum">    1685 </span>            :          * How about 'russian' -&gt; 'ru'?
<span class="lineNum">    1686 </span>            :          * Many of the other locales using ISO codes will be handled by the
<span class="lineNum">    1687 </span>            :          * canonicalization functions in uloc_getDefault.
<span class="lineNum">    1688 </span>            :          */
<span class="lineNum">    1689 </span>            :     }
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            :     /* Was a correction made? */
<span class="lineNum">    1692 </span><span class="lineCov">          2 :     if (correctedPOSIXLocale != NULL) {</span>
<span class="lineNum">    1693 </span><span class="lineCov">          2 :         posixID = correctedPOSIXLocale;</span>
<span class="lineNum">    1694 </span>            :     }
<span class="lineNum">    1695 </span>            :     else {
<span class="lineNum">    1696 </span>            :         /* copy it, just in case the original pointer goes away.  See j2395 */
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :         correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);</span>
<span class="lineNum">    1698 </span>            :         /* Exit on memory allocation error. */
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :         if (correctedPOSIXLocale == NULL) {</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">    1701 </span>            :         }
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :         posixID = uprv_strcpy(correctedPOSIXLocale, posixID);</span>
<span class="lineNum">    1703 </span>            :     }
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineCov">          2 :     if (gCorrectedPOSIXLocale == NULL) {</span>
<span class="lineNum">    1706 </span><span class="lineCov">          2 :         gCorrectedPOSIXLocale = correctedPOSIXLocale;</span>
<span class="lineNum">    1707 </span><span class="lineCov">          2 :         gCorrectedPOSIXLocaleHeapAllocated = true;</span>
<span class="lineNum">    1708 </span><span class="lineCov">          2 :         ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);</span>
<span class="lineNum">    1709 </span><span class="lineCov">          2 :         correctedPOSIXLocale = NULL;</span>
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span><span class="lineCov">          2 :     if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :         uprv_free(correctedPOSIXLocale);</span>
<span class="lineNum">    1714 </span>            :     }
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineCov">          2 :     return posixID;</span>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            : #elif U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    1719 </span>            : #define POSIX_LOCALE_CAPACITY 64
<span class="lineNum">    1720 </span>            :     UErrorCode status = U_ZERO_ERROR;
<span class="lineNum">    1721 </span>            :     char *correctedPOSIXLocale = 0;
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            :     // If we have already figured this out just use the cached value
<span class="lineNum">    1724 </span>            :     if (gCorrectedPOSIXLocale != NULL) {
<span class="lineNum">    1725 </span>            :         return gCorrectedPOSIXLocale;
<span class="lineNum">    1726 </span>            :     }
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span>            :     // No cached value, need to determine the current value
<span class="lineNum">    1729 </span>            :     static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];
<span class="lineNum">    1730 </span>            : #if U_PLATFORM_HAS_WINUWP_API == 0 
<span class="lineNum">    1731 </span>            :     // If not a Universal Windows App, we'll need user default language.
<span class="lineNum">    1732 </span>            :     // Vista and above should use Locale Names instead of LCIDs
<span class="lineNum">    1733 </span>            :     int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));
<span class="lineNum">    1734 </span>            : #else
<span class="lineNum">    1735 </span>            :     // In a UWP app, we want the top language that the application and user agreed upon
<span class="lineNum">    1736 </span>            :     ComPtr&lt;ABI::Windows::Foundation::Collections::IVectorView&lt;HSTRING&gt;&gt; languageList;
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            :     ComPtr&lt;ABI::Windows::Globalization::IApplicationLanguagesStatics&gt; applicationLanguagesStatics;
<span class="lineNum">    1739 </span>            :     HRESULT hr = GetActivationFactory(
<span class="lineNum">    1740 </span>            :         HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),
<span class="lineNum">    1741 </span>            :         &amp;applicationLanguagesStatics);
<span class="lineNum">    1742 </span>            :     if (SUCCEEDED(hr))
<span class="lineNum">    1743 </span>            :     {
<span class="lineNum">    1744 </span>            :         hr = applicationLanguagesStatics-&gt;get_Languages(&amp;languageList);
<span class="lineNum">    1745 </span>            :     }
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :     if (FAILED(hr))
<span class="lineNum">    1748 </span>            :     {
<span class="lineNum">    1749 </span>            :         // If there is no application context, then use the top language from the user language profile
<span class="lineNum">    1750 </span>            :         ComPtr&lt;ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics&gt; globalizationPreferencesStatics;
<span class="lineNum">    1751 </span>            :         hr = GetActivationFactory(
<span class="lineNum">    1752 </span>            :             HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),
<span class="lineNum">    1753 </span>            :             &amp;globalizationPreferencesStatics);
<span class="lineNum">    1754 </span>            :         if (SUCCEEDED(hr))
<span class="lineNum">    1755 </span>            :         {
<span class="lineNum">    1756 </span>            :             hr = globalizationPreferencesStatics-&gt;get_Languages(&amp;languageList);
<span class="lineNum">    1757 </span>            :         }
<span class="lineNum">    1758 </span>            :     }
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            :     // We have a list of languages, ICU knows one, so use the top one for our locale
<span class="lineNum">    1761 </span>            :     HString topLanguage;
<span class="lineNum">    1762 </span>            :     if (SUCCEEDED(hr))
<span class="lineNum">    1763 </span>            :     {
<span class="lineNum">    1764 </span>            :         hr = languageList-&gt;GetAt(0, topLanguage.GetAddressOf());
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :     if (FAILED(hr))
<span class="lineNum">    1768 </span>            :     {
<span class="lineNum">    1769 </span>            :         // Unexpected, use en-US by default
<span class="lineNum">    1770 </span>            :         if (gCorrectedPOSIXLocale == NULL) {
<span class="lineNum">    1771 </span>            :             gCorrectedPOSIXLocale = &quot;en_US&quot;;
<span class="lineNum">    1772 </span>            :         }
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            :         return gCorrectedPOSIXLocale;
<span class="lineNum">    1775 </span>            :     }
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span>            :     // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.
<span class="lineNum">    1778 </span>            :     int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));
<span class="lineNum">    1779 </span>            : #endif
<span class="lineNum">    1780 </span>            :     // Now we should have a Windows locale name that needs converted to the POSIX style,
<span class="lineNum">    1781 </span>            :     if (length &gt; 0)
<span class="lineNum">    1782 </span>            :     {
<span class="lineNum">    1783 </span>            :         // First we need to go from UTF-16 to char (and also convert from _ to - while we're at it.)
<span class="lineNum">    1784 </span>            :         char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :         int32_t i;
<span class="lineNum">    1787 </span>            :         for (i = 0; i &lt; UPRV_LENGTHOF(modifiedWindowsLocale); i++)
<span class="lineNum">    1788 </span>            :         {
<span class="lineNum">    1789 </span>            :             if (windowsLocale[i] == '_')
<span class="lineNum">    1790 </span>            :             {
<span class="lineNum">    1791 </span>            :                 modifiedWindowsLocale[i] = '-';
<span class="lineNum">    1792 </span>            :             }
<span class="lineNum">    1793 </span>            :             else
<span class="lineNum">    1794 </span>            :             {
<span class="lineNum">    1795 </span>            :                 modifiedWindowsLocale[i] = static_cast&lt;char&gt;(windowsLocale[i]);
<span class="lineNum">    1796 </span>            :             }
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            :             if (modifiedWindowsLocale[i] == '\0')
<span class="lineNum">    1799 </span>            :             {
<span class="lineNum">    1800 </span>            :                 break;
<span class="lineNum">    1801 </span>            :             }
<span class="lineNum">    1802 </span>            :         }
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :         if (i &gt;= UPRV_LENGTHOF(modifiedWindowsLocale))
<span class="lineNum">    1805 </span>            :         {
<span class="lineNum">    1806 </span>            :             // Ran out of room, can't really happen, maybe we'll be lucky about a matching
<span class="lineNum">    1807 </span>            :             // locale when tags are dropped
<span class="lineNum">    1808 </span>            :             modifiedWindowsLocale[UPRV_LENGTHOF(modifiedWindowsLocale) - 1] = '\0';
<span class="lineNum">    1809 </span>            :         }
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            :         // Now normalize the resulting name
<span class="lineNum">    1812 </span>            :         if (correctedPOSIXLocale)
<span class="lineNum">    1813 </span>            :         {
<span class="lineNum">    1814 </span>            :             int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &amp;status);
<span class="lineNum">    1815 </span>            :             if (U_SUCCESS(status))
<span class="lineNum">    1816 </span>            :             {
<span class="lineNum">    1817 </span>            :                 *(correctedPOSIXLocale + posixLen) = 0;
<span class="lineNum">    1818 </span>            :                 gCorrectedPOSIXLocale = correctedPOSIXLocale;
<span class="lineNum">    1819 </span>            :                 gCorrectedPOSIXLocaleHeapAllocated = true;
<span class="lineNum">    1820 </span>            :                 ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);
<span class="lineNum">    1821 </span>            :             }
<span class="lineNum">    1822 </span>            :             else
<span class="lineNum">    1823 </span>            :             {
<span class="lineNum">    1824 </span>            :                 uprv_free(correctedPOSIXLocale);
<span class="lineNum">    1825 </span>            :             }
<span class="lineNum">    1826 </span>            :         }
<span class="lineNum">    1827 </span>            :     }
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span>            :     // If unable to find a locale we can agree upon, use en-US by default
<span class="lineNum">    1830 </span>            :     if (gCorrectedPOSIXLocale == NULL) {
<span class="lineNum">    1831 </span>            :         gCorrectedPOSIXLocale = &quot;en_US&quot;;
<span class="lineNum">    1832 </span>            :     }
<span class="lineNum">    1833 </span>            :     return gCorrectedPOSIXLocale;
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            : #elif U_PLATFORM == U_PF_OS400
<span class="lineNum">    1836 </span>            :     /* locales are process scoped and are by definition thread safe */
<span class="lineNum">    1837 </span>            :     static char correctedLocale[64];
<span class="lineNum">    1838 </span>            :     const  char *localeID = getenv(&quot;LC_ALL&quot;);
<span class="lineNum">    1839 </span>            :            char *p;
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :     if (localeID == NULL)
<span class="lineNum">    1842 </span>            :         localeID = getenv(&quot;LANG&quot;);
<span class="lineNum">    1843 </span>            :     if (localeID == NULL)
<span class="lineNum">    1844 </span>            :         localeID = setlocale(LC_ALL, NULL);
<span class="lineNum">    1845 </span>            :     /* Make sure we have something... */
<span class="lineNum">    1846 </span>            :     if (localeID == NULL)
<span class="lineNum">    1847 </span>            :         return &quot;en_US_POSIX&quot;;
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            :     /* Extract the locale name from the path. */
<span class="lineNum">    1850 </span>            :     if((p = uprv_strrchr(localeID, '/')) != NULL)
<span class="lineNum">    1851 </span>            :     {
<span class="lineNum">    1852 </span>            :         /* Increment p to start of locale name. */
<span class="lineNum">    1853 </span>            :         p++;
<span class="lineNum">    1854 </span>            :         localeID = p;
<span class="lineNum">    1855 </span>            :     }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            :     /* Copy to work location. */
<span class="lineNum">    1858 </span>            :     uprv_strcpy(correctedLocale, localeID);
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span>            :     /* Strip off the '.locale' extension. */
<span class="lineNum">    1861 </span>            :     if((p = uprv_strchr(correctedLocale, '.')) != NULL) {
<span class="lineNum">    1862 </span>            :         *p = 0;
<span class="lineNum">    1863 </span>            :     }
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            :     /* Upper case the locale name. */
<span class="lineNum">    1866 </span>            :     T_CString_toUpperCase(correctedLocale);
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span>            :     /* See if we are using the POSIX locale.  Any of the
<span class="lineNum">    1869 </span>            :     * following are equivalent and use the same QLGPGCMA
<span class="lineNum">    1870 </span>            :     * (POSIX) locale.
<span class="lineNum">    1871 </span>            :     * QLGPGCMA2 means UCS2
<span class="lineNum">    1872 </span>            :     * QLGPGCMA_4 means UTF-32
<span class="lineNum">    1873 </span>            :     * QLGPGCMA_8 means UTF-8
<span class="lineNum">    1874 </span>            :     */
<span class="lineNum">    1875 </span>            :     if ((uprv_strcmp(&quot;C&quot;, correctedLocale) == 0) ||
<span class="lineNum">    1876 </span>            :         (uprv_strcmp(&quot;POSIX&quot;, correctedLocale) == 0) ||
<span class="lineNum">    1877 </span>            :         (uprv_strncmp(&quot;QLGPGCMA&quot;, correctedLocale, 8) == 0))
<span class="lineNum">    1878 </span>            :     {
<span class="lineNum">    1879 </span>            :         uprv_strcpy(correctedLocale, &quot;en_US_POSIX&quot;);
<span class="lineNum">    1880 </span>            :     }
<span class="lineNum">    1881 </span>            :     else
<span class="lineNum">    1882 </span>            :     {
<span class="lineNum">    1883 </span>            :         int16_t LocaleLen;
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span>            :         /* Lower case the lang portion. */
<span class="lineNum">    1886 </span>            :         for(p = correctedLocale; *p != 0 &amp;&amp; *p != '_'; p++)
<span class="lineNum">    1887 </span>            :         {
<span class="lineNum">    1888 </span>            :             *p = uprv_tolower(*p);
<span class="lineNum">    1889 </span>            :         }
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span>            :         /* Adjust for Euro.  After '_E' add 'URO'. */
<span class="lineNum">    1892 </span>            :         LocaleLen = uprv_strlen(correctedLocale);
<span class="lineNum">    1893 </span>            :         if (correctedLocale[LocaleLen - 2] == '_' &amp;&amp;
<span class="lineNum">    1894 </span>            :             correctedLocale[LocaleLen - 1] == 'E')
<span class="lineNum">    1895 </span>            :         {
<span class="lineNum">    1896 </span>            :             uprv_strcat(correctedLocale, &quot;URO&quot;);
<span class="lineNum">    1897 </span>            :         }
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            :         /* If using Lotus-based locale then convert to
<span class="lineNum">    1900 </span>            :          * equivalent non Lotus.
<span class="lineNum">    1901 </span>            :          */
<span class="lineNum">    1902 </span>            :         else if (correctedLocale[LocaleLen - 2] == '_' &amp;&amp;
<span class="lineNum">    1903 </span>            :             correctedLocale[LocaleLen - 1] == 'L')
<span class="lineNum">    1904 </span>            :         {
<span class="lineNum">    1905 </span>            :             correctedLocale[LocaleLen - 2] = 0;
<span class="lineNum">    1906 </span>            :         }
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :         /* There are separate simplified and traditional
<span class="lineNum">    1909 </span>            :          * locales called zh_HK_S and zh_HK_T.
<span class="lineNum">    1910 </span>            :          */
<span class="lineNum">    1911 </span>            :         else if (uprv_strncmp(correctedLocale, &quot;zh_HK&quot;, 5) == 0)
<span class="lineNum">    1912 </span>            :         {
<span class="lineNum">    1913 </span>            :             uprv_strcpy(correctedLocale, &quot;zh_HK&quot;);
<span class="lineNum">    1914 </span>            :         }
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            :         /* A special zh_CN_GBK locale...
<span class="lineNum">    1917 </span>            :         */
<span class="lineNum">    1918 </span>            :         else if (uprv_strcmp(correctedLocale, &quot;zh_CN_GBK&quot;) == 0)
<span class="lineNum">    1919 </span>            :         {
<span class="lineNum">    1920 </span>            :             uprv_strcpy(correctedLocale, &quot;zh_CN&quot;);
<span class="lineNum">    1921 </span>            :         }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            :     }
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span>            :     return correctedLocale;
<span class="lineNum">    1926 </span>            : #endif
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            : }
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            : #if !U_CHARSET_IS_UTF8
<span class="lineNum">    1931 </span>            : #if U_POSIX_LOCALE
<span class="lineNum">    1932 </span>            : /*
<span class="lineNum">    1933 </span>            : Due to various platform differences, one platform may specify a charset,
<span class="lineNum">    1934 </span>            : when they really mean a different charset. Remap the names so that they are
<span class="lineNum">    1935 </span>            : compatible with ICU. Only conflicting/ambiguous aliases should be resolved
<span class="lineNum">    1936 </span>            : here. Before adding anything to this function, please consider adding unique
<span class="lineNum">    1937 </span>            : names to the ICU alias table in the data directory.
<span class="lineNum">    1938 </span>            : */
<span class="lineNum">    1939 </span>            : static const char*
<span class="lineNum">    1940 </span>            : remapPlatformDependentCodepage(const char *locale, const char *name) {
<span class="lineNum">    1941 </span>            :     if (locale != NULL &amp;&amp; *locale == 0) {
<span class="lineNum">    1942 </span>            :         /* Make sure that an empty locale is handled the same way. */
<span class="lineNum">    1943 </span>            :         locale = NULL;
<span class="lineNum">    1944 </span>            :     }
<span class="lineNum">    1945 </span>            :     if (name == NULL) {
<span class="lineNum">    1946 </span>            :         return NULL;
<span class="lineNum">    1947 </span>            :     }
<span class="lineNum">    1948 </span>            : #if U_PLATFORM == U_PF_AIX
<span class="lineNum">    1949 </span>            :     if (uprv_strcmp(name, &quot;IBM-943&quot;) == 0) {
<span class="lineNum">    1950 </span>            :         /* Use the ASCII compatible ibm-943 */
<span class="lineNum">    1951 </span>            :         name = &quot;Shift-JIS&quot;;
<span class="lineNum">    1952 </span>            :     }
<span class="lineNum">    1953 </span>            :     else if (uprv_strcmp(name, &quot;IBM-1252&quot;) == 0) {
<span class="lineNum">    1954 </span>            :         /* Use the windows-1252 that contains the Euro */
<span class="lineNum">    1955 </span>            :         name = &quot;IBM-5348&quot;;
<span class="lineNum">    1956 </span>            :     }
<span class="lineNum">    1957 </span>            : #elif U_PLATFORM == U_PF_SOLARIS
<span class="lineNum">    1958 </span>            :     if (locale != NULL &amp;&amp; uprv_strcmp(name, &quot;EUC&quot;) == 0) {
<span class="lineNum">    1959 </span>            :         /* Solaris underspecifies the &quot;EUC&quot; name. */
<span class="lineNum">    1960 </span>            :         if (uprv_strcmp(locale, &quot;zh_CN&quot;) == 0) {
<span class="lineNum">    1961 </span>            :             name = &quot;EUC-CN&quot;;
<span class="lineNum">    1962 </span>            :         }
<span class="lineNum">    1963 </span>            :         else if (uprv_strcmp(locale, &quot;zh_TW&quot;) == 0) {
<span class="lineNum">    1964 </span>            :             name = &quot;EUC-TW&quot;;
<span class="lineNum">    1965 </span>            :         }
<span class="lineNum">    1966 </span>            :         else if (uprv_strcmp(locale, &quot;ko_KR&quot;) == 0) {
<span class="lineNum">    1967 </span>            :             name = &quot;EUC-KR&quot;;
<span class="lineNum">    1968 </span>            :         }
<span class="lineNum">    1969 </span>            :     }
<span class="lineNum">    1970 </span>            :     else if (uprv_strcmp(name, &quot;eucJP&quot;) == 0) {
<span class="lineNum">    1971 </span>            :         /*
<span class="lineNum">    1972 </span>            :         ibm-954 is the best match.
<span class="lineNum">    1973 </span>            :         ibm-33722 is the default for eucJP (similar to Windows).
<span class="lineNum">    1974 </span>            :         */
<span class="lineNum">    1975 </span>            :         name = &quot;eucjis&quot;;
<span class="lineNum">    1976 </span>            :     }
<span class="lineNum">    1977 </span>            :     else if (uprv_strcmp(name, &quot;646&quot;) == 0) {
<span class="lineNum">    1978 </span>            :         /*
<span class="lineNum">    1979 </span>            :          * The default codepage given by Solaris is 646 but the C library routines treat it as if it was
<span class="lineNum">    1980 </span>            :          * ISO-8859-1 instead of US-ASCII(646).
<span class="lineNum">    1981 </span>            :          */
<span class="lineNum">    1982 </span>            :         name = &quot;ISO-8859-1&quot;;
<span class="lineNum">    1983 </span>            :     }
<span class="lineNum">    1984 </span>            : #elif U_PLATFORM_IS_DARWIN_BASED
<span class="lineNum">    1985 </span>            :     if (locale == NULL &amp;&amp; *name == 0) {
<span class="lineNum">    1986 </span>            :         /*
<span class="lineNum">    1987 </span>            :         No locale was specified, and an empty name was passed in.
<span class="lineNum">    1988 </span>            :         This usually indicates that nl_langinfo didn't return valid information.
<span class="lineNum">    1989 </span>            :         Mac OS X uses UTF-8 by default (especially the locale data and console).
<span class="lineNum">    1990 </span>            :         */
<span class="lineNum">    1991 </span>            :         name = &quot;UTF-8&quot;;
<span class="lineNum">    1992 </span>            :     }
<span class="lineNum">    1993 </span>            :     else if (uprv_strcmp(name, &quot;CP949&quot;) == 0) {
<span class="lineNum">    1994 </span>            :         /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */
<span class="lineNum">    1995 </span>            :         name = &quot;EUC-KR&quot;;
<span class="lineNum">    1996 </span>            :     }
<span class="lineNum">    1997 </span>            :     else if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;en_US_POSIX&quot;) != 0 &amp;&amp; uprv_strcmp(name, &quot;US-ASCII&quot;) == 0) {
<span class="lineNum">    1998 </span>            :         /*
<span class="lineNum">    1999 </span>            :          * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.
<span class="lineNum">    2000 </span>            :          */
<span class="lineNum">    2001 </span>            :         name = &quot;UTF-8&quot;;
<span class="lineNum">    2002 </span>            :     }
<span class="lineNum">    2003 </span>            : #elif U_PLATFORM == U_PF_BSD
<span class="lineNum">    2004 </span>            :     if (uprv_strcmp(name, &quot;CP949&quot;) == 0) {
<span class="lineNum">    2005 </span>            :         /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */
<span class="lineNum">    2006 </span>            :         name = &quot;EUC-KR&quot;;
<span class="lineNum">    2007 </span>            :     }
<span class="lineNum">    2008 </span>            : #elif U_PLATFORM == U_PF_HPUX
<span class="lineNum">    2009 </span>            :     if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;zh_HK&quot;) == 0 &amp;&amp; uprv_strcmp(name, &quot;big5&quot;) == 0) {
<span class="lineNum">    2010 </span>            :         /* HP decided to extend big5 as hkbig5 even though it's not compatible :-( */
<span class="lineNum">    2011 </span>            :         /* zh_TW.big5 is not the same charset as zh_HK.big5! */
<span class="lineNum">    2012 </span>            :         name = &quot;hkbig5&quot;;
<span class="lineNum">    2013 </span>            :     }
<span class="lineNum">    2014 </span>            :     else if (uprv_strcmp(name, &quot;eucJP&quot;) == 0) {
<span class="lineNum">    2015 </span>            :         /*
<span class="lineNum">    2016 </span>            :         ibm-1350 is the best match, but unavailable.
<span class="lineNum">    2017 </span>            :         ibm-954 is mostly a superset of ibm-1350.
<span class="lineNum">    2018 </span>            :         ibm-33722 is the default for eucJP (similar to Windows).
<span class="lineNum">    2019 </span>            :         */
<span class="lineNum">    2020 </span>            :         name = &quot;eucjis&quot;;
<span class="lineNum">    2021 </span>            :     }
<span class="lineNum">    2022 </span>            : #elif U_PLATFORM == U_PF_LINUX
<span class="lineNum">    2023 </span>            :     if (locale != NULL &amp;&amp; uprv_strcmp(name, &quot;euc&quot;) == 0) {
<span class="lineNum">    2024 </span>            :         /* Linux underspecifies the &quot;EUC&quot; name. */
<span class="lineNum">    2025 </span>            :         if (uprv_strcmp(locale, &quot;korean&quot;) == 0) {
<span class="lineNum">    2026 </span>            :             name = &quot;EUC-KR&quot;;
<span class="lineNum">    2027 </span>            :         }
<span class="lineNum">    2028 </span>            :         else if (uprv_strcmp(locale, &quot;japanese&quot;) == 0) {
<span class="lineNum">    2029 </span>            :             /* See comment below about eucJP */
<span class="lineNum">    2030 </span>            :             name = &quot;eucjis&quot;;
<span class="lineNum">    2031 </span>            :         }
<span class="lineNum">    2032 </span>            :     }
<span class="lineNum">    2033 </span>            :     else if (uprv_strcmp(name, &quot;eucjp&quot;) == 0) {
<span class="lineNum">    2034 </span>            :         /*
<span class="lineNum">    2035 </span>            :         ibm-1350 is the best match, but unavailable.
<span class="lineNum">    2036 </span>            :         ibm-954 is mostly a superset of ibm-1350.
<span class="lineNum">    2037 </span>            :         ibm-33722 is the default for eucJP (similar to Windows).
<span class="lineNum">    2038 </span>            :         */
<span class="lineNum">    2039 </span>            :         name = &quot;eucjis&quot;;
<span class="lineNum">    2040 </span>            :     }
<span class="lineNum">    2041 </span>            :     else if (locale != NULL &amp;&amp; uprv_strcmp(locale, &quot;en_US_POSIX&quot;) != 0 &amp;&amp;
<span class="lineNum">    2042 </span>            :             (uprv_strcmp(name, &quot;ANSI_X3.4-1968&quot;) == 0 || uprv_strcmp(name, &quot;US-ASCII&quot;) == 0)) {
<span class="lineNum">    2043 </span>            :         /*
<span class="lineNum">    2044 </span>            :          * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.
<span class="lineNum">    2045 </span>            :          */
<span class="lineNum">    2046 </span>            :         name = &quot;UTF-8&quot;;
<span class="lineNum">    2047 </span>            :     }
<span class="lineNum">    2048 </span>            :     /*
<span class="lineNum">    2049 </span>            :      * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of
<span class="lineNum">    2050 </span>            :      * it by falling back to 'US-ASCII' when NULL is returned from this
<span class="lineNum">    2051 </span>            :      * function. So, we don't have to worry about it here.
<span class="lineNum">    2052 </span>            :      */
<span class="lineNum">    2053 </span>            : #endif
<span class="lineNum">    2054 </span>            :     /* return NULL when &quot;&quot; is passed in */
<span class="lineNum">    2055 </span>            :     if (*name == 0) {
<span class="lineNum">    2056 </span>            :         name = NULL;
<span class="lineNum">    2057 </span>            :     }
<span class="lineNum">    2058 </span>            :     return name;
<span class="lineNum">    2059 </span>            : }
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            : static const char*
<span class="lineNum">    2062 </span>            : getCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)
<span class="lineNum">    2063 </span>            : {
<span class="lineNum">    2064 </span>            :     char localeBuf[100];
<span class="lineNum">    2065 </span>            :     const char *name = NULL;
<span class="lineNum">    2066 </span>            :     char *variant = NULL;
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            :     if (localeName != NULL &amp;&amp; (name = (uprv_strchr(localeName, '.'))) != NULL) {
<span class="lineNum">    2069 </span>            :         size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);
<span class="lineNum">    2070 </span>            :         uprv_strncpy(localeBuf, localeName, localeCapacity);
<span class="lineNum">    2071 </span>            :         localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */
<span class="lineNum">    2072 </span>            :         name = uprv_strncpy(buffer, name+1, buffCapacity);
<span class="lineNum">    2073 </span>            :         buffer[buffCapacity-1] = 0; /* ensure NULL termination */
<span class="lineNum">    2074 </span>            :         if ((variant = const_cast&lt;char *&gt;(uprv_strchr(name, '@'))) != NULL) {
<span class="lineNum">    2075 </span>            :             *variant = 0;
<span class="lineNum">    2076 </span>            :         }
<span class="lineNum">    2077 </span>            :         name = remapPlatformDependentCodepage(localeBuf, name);
<span class="lineNum">    2078 </span>            :     }
<span class="lineNum">    2079 </span>            :     return name;
<span class="lineNum">    2080 </span>            : }
<span class="lineNum">    2081 </span>            : #endif
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span>            : static const char*
<span class="lineNum">    2084 </span>            : int_getDefaultCodepage()
<span class="lineNum">    2085 </span>            : {
<span class="lineNum">    2086 </span>            : #if U_PLATFORM == U_PF_OS400
<span class="lineNum">    2087 </span>            :     uint32_t ccsid = 37; /* Default to ibm-37 */
<span class="lineNum">    2088 </span>            :     static char codepage[64];
<span class="lineNum">    2089 </span>            :     Qwc_JOBI0400_t jobinfo;
<span class="lineNum">    2090 </span>            :     Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :     EPT_CALL(QUSRJOBI)(&amp;jobinfo, sizeof(jobinfo), &quot;JOBI0400&quot;,
<span class="lineNum">    2093 </span>            :         &quot;*                         &quot;, &quot;                &quot;, &amp;error);
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span>            :     if (error.Bytes_Available == 0) {
<span class="lineNum">    2096 </span>            :         if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {
<span class="lineNum">    2097 </span>            :             ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;
<span class="lineNum">    2098 </span>            :         }
<span class="lineNum">    2099 </span>            :         else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {
<span class="lineNum">    2100 </span>            :             ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;
<span class="lineNum">    2101 </span>            :         }
<span class="lineNum">    2102 </span>            :         /* else use the default */
<span class="lineNum">    2103 </span>            :     }
<span class="lineNum">    2104 </span>            :     sprintf(codepage,&quot;ibm-%d&quot;, ccsid);
<span class="lineNum">    2105 </span>            :     return codepage;
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span>            : #elif U_PLATFORM == U_PF_OS390
<span class="lineNum">    2108 </span>            :     static char codepage[64];
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span>            :     strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));
<span class="lineNum">    2111 </span>            :     strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);
<span class="lineNum">    2112 </span>            :     codepage[63] = 0; /* NULL terminate */
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            :     return codepage;
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            : #elif U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    2117 </span>            :     static char codepage[64];
<span class="lineNum">    2118 </span>            :     DWORD codepageNumber = 0;
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span>            : #if U_PLATFORM_HAS_WINUWP_API &gt; 0
<span class="lineNum">    2121 </span>            :     // UWP doesn't have a direct API to get the default ACP as Microsoft would rather
<span class="lineNum">    2122 </span>            :     // have folks use Unicode than a &quot;system&quot; code page, however this is the same
<span class="lineNum">    2123 </span>            :     // codepage as the system default locale codepage.  (FWIW, the system locale is
<span class="lineNum">    2124 </span>            :     // ONLY used for codepage, it should never be used for anything else)
<span class="lineNum">    2125 </span>            :     GetLocaleInfoEx(LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
<span class="lineNum">    2126 </span>            :         (LPWSTR)&amp;codepageNumber, sizeof(codepageNumber) / sizeof(WCHAR));
<span class="lineNum">    2127 </span>            : #else
<span class="lineNum">    2128 </span>            :     // Win32 apps can call GetACP
<span class="lineNum">    2129 </span>            :     codepageNumber = GetACP();
<span class="lineNum">    2130 </span>            : #endif
<span class="lineNum">    2131 </span>            :     // Special case for UTF-8
<span class="lineNum">    2132 </span>            :     if (codepageNumber == 65001)
<span class="lineNum">    2133 </span>            :     { 
<span class="lineNum">    2134 </span>            :         return &quot;UTF-8&quot;;
<span class="lineNum">    2135 </span>            :     }
<span class="lineNum">    2136 </span>            :     // Windows codepages can look like windows-1252, so format the found number
<span class="lineNum">    2137 </span>            :     // the numbers are eclectic, however all valid system code pages, besides UTF-8
<span class="lineNum">    2138 </span>            :     // are between 3 and 19999
<span class="lineNum">    2139 </span>            :     if (codepageNumber &gt; 0 &amp;&amp; codepageNumber &lt; 20000)
<span class="lineNum">    2140 </span>            :     {
<span class="lineNum">    2141 </span>            :         sprintf(codepage, &quot;windows-%ld&quot;, codepageNumber);
<span class="lineNum">    2142 </span>            :         return codepage;
<span class="lineNum">    2143 </span>            :     }
<span class="lineNum">    2144 </span>            :     // If the codepage number call failed then return UTF-8
<span class="lineNum">    2145 </span>            :     return &quot;UTF-8&quot;;
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span>            : #elif U_POSIX_LOCALE
<span class="lineNum">    2148 </span>            :     static char codesetName[100];
<span class="lineNum">    2149 </span>            :     const char *localeName = NULL;
<span class="lineNum">    2150 </span>            :     const char *name = NULL;
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            :     localeName = uprv_getPOSIXIDForDefaultCodepage();
<span class="lineNum">    2153 </span>            :     uprv_memset(codesetName, 0, sizeof(codesetName));
<span class="lineNum">    2154 </span>            :     /* On Solaris nl_langinfo returns C locale values unless setlocale
<span class="lineNum">    2155 </span>            :      * was called earlier.
<span class="lineNum">    2156 </span>            :      */
<span class="lineNum">    2157 </span>            : #if (U_HAVE_NL_LANGINFO_CODESET &amp;&amp; U_PLATFORM != U_PF_SOLARIS)
<span class="lineNum">    2158 </span>            :     /* When available, check nl_langinfo first because it usually gives more
<span class="lineNum">    2159 </span>            :        useful names. It depends on LC_CTYPE.
<span class="lineNum">    2160 </span>            :        nl_langinfo may use the same buffer as setlocale. */
<span class="lineNum">    2161 </span>            :     {
<span class="lineNum">    2162 </span>            :         const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);
<span class="lineNum">    2163 </span>            : #if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED
<span class="lineNum">    2164 </span>            :         /*
<span class="lineNum">    2165 </span>            :          * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8
<span class="lineNum">    2166 </span>            :          * instead of ASCII.
<span class="lineNum">    2167 </span>            :          */
<span class="lineNum">    2168 </span>            :         if (uprv_strcmp(localeName, &quot;en_US_POSIX&quot;) != 0) {
<span class="lineNum">    2169 </span>            :             codeset = remapPlatformDependentCodepage(localeName, codeset);
<span class="lineNum">    2170 </span>            :         } else
<span class="lineNum">    2171 </span>            : #endif
<span class="lineNum">    2172 </span>            :         {
<span class="lineNum">    2173 </span>            :             codeset = remapPlatformDependentCodepage(NULL, codeset);
<span class="lineNum">    2174 </span>            :         }
<span class="lineNum">    2175 </span>            : 
<span class="lineNum">    2176 </span>            :         if (codeset != NULL) {
<span class="lineNum">    2177 </span>            :             uprv_strncpy(codesetName, codeset, sizeof(codesetName));
<span class="lineNum">    2178 </span>            :             codesetName[sizeof(codesetName)-1] = 0;
<span class="lineNum">    2179 </span>            :             return codesetName;
<span class="lineNum">    2180 </span>            :         }
<span class="lineNum">    2181 </span>            :     }
<span class="lineNum">    2182 </span>            : #endif
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span>            :     /* Use setlocale in a nice way, and then check some environment variables.
<span class="lineNum">    2185 </span>            :        Maybe the application used setlocale already.
<span class="lineNum">    2186 </span>            :     */
<span class="lineNum">    2187 </span>            :     uprv_memset(codesetName, 0, sizeof(codesetName));
<span class="lineNum">    2188 </span>            :     name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));
<span class="lineNum">    2189 </span>            :     if (name) {
<span class="lineNum">    2190 </span>            :         /* if we can find the codeset name from setlocale, return that. */
<span class="lineNum">    2191 </span>            :         return name;
<span class="lineNum">    2192 </span>            :     }
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            :     if (*codesetName == 0)
<span class="lineNum">    2195 </span>            :     {
<span class="lineNum">    2196 </span>            :         /* Everything failed. Return US ASCII (ISO 646). */
<span class="lineNum">    2197 </span>            :         (void)uprv_strcpy(codesetName, &quot;US-ASCII&quot;);
<span class="lineNum">    2198 </span>            :     }
<span class="lineNum">    2199 </span>            :     return codesetName;
<span class="lineNum">    2200 </span>            : #else
<span class="lineNum">    2201 </span>            :     return &quot;US-ASCII&quot;;
<span class="lineNum">    2202 </span>            : #endif
<span class="lineNum">    2203 </span>            : }
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            : U_CAPI const char*  U_EXPORT2
<span class="lineNum">    2207 </span>            : uprv_getDefaultCodepage()
<span class="lineNum">    2208 </span>            : {
<span class="lineNum">    2209 </span>            :     static char const  *name = NULL;
<span class="lineNum">    2210 </span>            :     umtx_lock(NULL);
<span class="lineNum">    2211 </span>            :     if (name == NULL) {
<span class="lineNum">    2212 </span>            :         name = int_getDefaultCodepage();
<span class="lineNum">    2213 </span>            :     }
<span class="lineNum">    2214 </span>            :     umtx_unlock(NULL);
<span class="lineNum">    2215 </span>            :     return name;
<span class="lineNum">    2216 </span>            : }
<span class="lineNum">    2217 </span>            : #endif  /* !U_CHARSET_IS_UTF8 */
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span>            : /* end of platform-specific implementation -------------- */
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            : /* version handling --------------------------------------------------------- */
<a name="2223"><span class="lineNum">    2223 </span>            : </a>
<span class="lineNum">    2224 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 : u_versionFromString(UVersionInfo versionArray, const char *versionString) {</span>
<span class="lineNum">    2226 </span>            :     char *end;
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :     uint16_t part=0;</span>
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :     if(versionArray==NULL) {</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2231 </span>            :     }
<span class="lineNum">    2232 </span>            : 
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :     if(versionString!=NULL) {</span>
<span class="lineNum">    2234 </span>            :         for(;;) {
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :             versionArray[part]=(uint8_t)uprv_strtoul(versionString, &amp;end, 10);</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :             if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2238 </span>            :             }
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :             versionString=end+1;</span>
<span class="lineNum">    2240 </span>            :         }
<span class="lineNum">    2241 </span>            :     }
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :     while(part&lt;U_MAX_VERSION_LENGTH) {</span>
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         versionArray[part++]=0;</span>
<span class="lineNum">    2245 </span>            :     }
<span class="lineNum">    2246 </span>            : }
<a name="2247"><span class="lineNum">    2247 </span>            : </a>
<span class="lineNum">    2248 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 : u_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :     if(versionArray!=NULL &amp;&amp; versionString!=NULL) {</span>
<span class="lineNum">    2251 </span>            :         char versionChars[U_MAX_VERSION_STRING_LENGTH+1];
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :         int32_t len = u_strlen(versionString);</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :         if(len&gt;U_MAX_VERSION_STRING_LENGTH) {</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :             len = U_MAX_VERSION_STRING_LENGTH;</span>
<span class="lineNum">    2255 </span>            :         }
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :         u_UCharsToChars(versionString, versionChars, len);</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :         versionChars[len]=0;</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :         u_versionFromString(versionArray, versionChars);</span>
<span class="lineNum">    2259 </span>            :     }
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 : }</span>
<a name="2261"><span class="lineNum">    2261 </span>            : </a>
<span class="lineNum">    2262 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 : u_versionToString(const UVersionInfo versionArray, char *versionString) {</span>
<span class="lineNum">    2264 </span>            :     uint16_t count, part;
<span class="lineNum">    2265 </span>            :     uint8_t field;
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :     if(versionString==NULL) {</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2269 </span>            :     }
<span class="lineNum">    2270 </span>            : 
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :     if(versionArray==NULL) {</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         versionString[0]=0;</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2274 </span>            :     }
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span>            :     /* count how many fields need to be written */
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :     for(count=4; count&gt;0 &amp;&amp; versionArray[count-1]==0; --count) {</span>
<span class="lineNum">    2278 </span>            :     }
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :     if(count &lt;= 1) {</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :         count = 2;</span>
<span class="lineNum">    2282 </span>            :     }
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            :     /* write the first part */
<span class="lineNum">    2285 </span>            :     /* write the decimal field value */
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :     field=versionArray[0];</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :     if(field&gt;=100) {</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :         *versionString++=(char)('0'+field/100);</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :         field%=100;</span>
<span class="lineNum">    2290 </span>            :     }
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :     if(field&gt;=10) {</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :         *versionString++=(char)('0'+field/10);</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         field%=10;</span>
<span class="lineNum">    2294 </span>            :     }
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :     *versionString++=(char)('0'+field);</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span>            :     /* write the following parts */
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :     for(part=1; part&lt;count; ++part) {</span>
<span class="lineNum">    2299 </span>            :         /* write a dot first */
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :         *versionString++=U_VERSION_DELIMITER;</span>
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span>            :         /* write the decimal field value */
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :         field=versionArray[part];</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :         if(field&gt;=100) {</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :             *versionString++=(char)('0'+field/100);</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :             field%=100;</span>
<span class="lineNum">    2307 </span>            :         }
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :         if(field&gt;=10) {</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :             *versionString++=(char)('0'+field/10);</span>
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :             field%=10;</span>
<span class="lineNum">    2311 </span>            :         }
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :         *versionString++=(char)('0'+field);</span>
<span class="lineNum">    2313 </span>            :     }
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :     /* NUL-terminate */
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :     *versionString=0;</span>
<span class="lineNum">    2317 </span>            : }
<a name="2318"><span class="lineNum">    2318 </span>            : </a>
<span class="lineNum">    2319 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 : u_getVersion(UVersionInfo versionArray) {</span>
<span class="lineNum">    2321 </span>            :     (void)copyright;   // Suppress unused variable warning from clang.
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     u_versionFromString(versionArray, U_ICU_VERSION);</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span>            : /**
<span class="lineNum">    2326 </span>            :  * icucfg.h dependent code 
<span class="lineNum">    2327 </span>            :  */
<span class="lineNum">    2328 </span>            : 
<span class="lineNum">    2329 </span>            : #if U_ENABLE_DYLOAD
<span class="lineNum">    2330 </span>            :  
<span class="lineNum">    2331 </span>            : #if HAVE_DLOPEN &amp;&amp; !U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            : #if HAVE_DLFCN_H
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span>            : #ifdef __MVS__
<span class="lineNum">    2336 </span>            : #ifndef __SUSV3
<span class="lineNum">    2337 </span>            : #define __SUSV3 1
<span class="lineNum">    2338 </span>            : #endif
<span class="lineNum">    2339 </span>            : #endif
<span class="lineNum">    2340 </span>            : #include &lt;dlfcn.h&gt;
<span class="lineNum">    2341 </span>            : #endif
<a name="2342"><span class="lineNum">    2342 </span>            : </a>
<span class="lineNum">    2343 </span>            : U_INTERNAL void * U_EXPORT2
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 : uprv_dl_open(const char *libName, UErrorCode *status) {</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   void *ret = NULL;</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :   if(U_FAILURE(*status)) return ret;</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :   if(ret==NULL) {</span>
<span class="lineNum">    2349 </span>            : #ifdef U_TRACE_DYLOAD
<span class="lineNum">    2350 </span>            :     printf(&quot;dlerror on dlopen(%s): %s\n&quot;, libName, dlerror());
<span class="lineNum">    2351 </span>            : #endif
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :     *status = U_MISSING_RESOURCE_ERROR;</span>
<span class="lineNum">    2353 </span>            :   }
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">    2355 </span>            : }
<a name="2356"><span class="lineNum">    2356 </span>            : </a>
<span class="lineNum">    2357 </span>            : U_INTERNAL void U_EXPORT2
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 : uprv_dl_close(void *lib, UErrorCode *status) {</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :   if(U_FAILURE(*status)) return;</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :   dlclose(lib);</span>
<span class="lineNum">    2361 </span>            : }
<a name="2362"><span class="lineNum">    2362 </span>            : </a>
<span class="lineNum">    2363 </span>            : U_INTERNAL UVoidFunction* U_EXPORT2
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 : uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {</span>
<span class="lineNum">    2365 </span>            :   union {
<span class="lineNum">    2366 </span>            :       UVoidFunction *fp;
<span class="lineNum">    2367 </span>            :       void *vp;
<span class="lineNum">    2368 </span>            :   } uret;
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :   uret.fp = NULL;</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   if(U_FAILURE(*status)) return uret.fp;</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :   uret.vp = dlsym(lib, sym);</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :   if(uret.vp == NULL) {</span>
<span class="lineNum">    2373 </span>            : #ifdef U_TRACE_DYLOAD
<span class="lineNum">    2374 </span>            :     printf(&quot;dlerror on dlsym(%p,%s): %s\n&quot;, lib,sym, dlerror());
<span class="lineNum">    2375 </span>            : #endif
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :     *status = U_MISSING_RESOURCE_ERROR;</span>
<span class="lineNum">    2377 </span>            :   }
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :   return uret.fp;</span>
<span class="lineNum">    2379 </span>            : }
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            : #else
<span class="lineNum">    2382 </span>            : 
<span class="lineNum">    2383 </span>            : /* null (nonexistent) implementation. */
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            : U_INTERNAL void * U_EXPORT2
<span class="lineNum">    2386 </span>            : uprv_dl_open(const char *libName, UErrorCode *status) {
<span class="lineNum">    2387 </span>            :   if(U_FAILURE(*status)) return NULL;
<span class="lineNum">    2388 </span>            :   *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2389 </span>            :   return NULL;
<span class="lineNum">    2390 </span>            : }
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span>            : U_INTERNAL void U_EXPORT2
<span class="lineNum">    2393 </span>            : uprv_dl_close(void *lib, UErrorCode *status) {
<span class="lineNum">    2394 </span>            :   if(U_FAILURE(*status)) return;
<span class="lineNum">    2395 </span>            :   *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2396 </span>            :   return;
<span class="lineNum">    2397 </span>            : }
<span class="lineNum">    2398 </span>            : 
<span class="lineNum">    2399 </span>            : 
<span class="lineNum">    2400 </span>            : U_INTERNAL UVoidFunction* U_EXPORT2
<span class="lineNum">    2401 </span>            : uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
<span class="lineNum">    2402 </span>            :   if(U_SUCCESS(*status)) {
<span class="lineNum">    2403 </span>            :     *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2404 </span>            :   }
<span class="lineNum">    2405 </span>            :   return (UVoidFunction*)NULL;
<span class="lineNum">    2406 </span>            : }
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span>            : 
<span class="lineNum">    2409 </span>            : 
<span class="lineNum">    2410 </span>            : #endif
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            : #elif U_PLATFORM_USES_ONLY_WIN32_API
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            : U_INTERNAL void * U_EXPORT2
<span class="lineNum">    2415 </span>            : uprv_dl_open(const char *libName, UErrorCode *status) {
<span class="lineNum">    2416 </span>            :   HMODULE lib = NULL;
<span class="lineNum">    2417 </span>            :   
<span class="lineNum">    2418 </span>            :   if(U_FAILURE(*status)) return NULL;
<span class="lineNum">    2419 </span>            :   
<span class="lineNum">    2420 </span>            :   lib = LoadLibraryA(libName);
<span class="lineNum">    2421 </span>            :   
<span class="lineNum">    2422 </span>            :   if(lib==NULL) {
<span class="lineNum">    2423 </span>            :     *status = U_MISSING_RESOURCE_ERROR;
<span class="lineNum">    2424 </span>            :   }
<span class="lineNum">    2425 </span>            :   
<span class="lineNum">    2426 </span>            :   return (void*)lib;
<span class="lineNum">    2427 </span>            : }
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            : U_INTERNAL void U_EXPORT2
<span class="lineNum">    2430 </span>            : uprv_dl_close(void *lib, UErrorCode *status) {
<span class="lineNum">    2431 </span>            :   HMODULE handle = (HMODULE)lib;
<span class="lineNum">    2432 </span>            :   if(U_FAILURE(*status)) return;
<span class="lineNum">    2433 </span>            :   
<span class="lineNum">    2434 </span>            :   FreeLibrary(handle);
<span class="lineNum">    2435 </span>            :   
<span class="lineNum">    2436 </span>            :   return;
<span class="lineNum">    2437 </span>            : }
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span>            : U_INTERNAL UVoidFunction* U_EXPORT2
<span class="lineNum">    2441 </span>            : uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
<span class="lineNum">    2442 </span>            :   HMODULE handle = (HMODULE)lib;
<span class="lineNum">    2443 </span>            :   UVoidFunction* addr = NULL;
<span class="lineNum">    2444 </span>            :   
<span class="lineNum">    2445 </span>            :   if(U_FAILURE(*status) || lib==NULL) return NULL;
<span class="lineNum">    2446 </span>            :   
<span class="lineNum">    2447 </span>            :   addr = (UVoidFunction*)GetProcAddress(handle, sym);
<span class="lineNum">    2448 </span>            :   
<span class="lineNum">    2449 </span>            :   if(addr==NULL) {
<span class="lineNum">    2450 </span>            :     DWORD lastError = GetLastError();
<span class="lineNum">    2451 </span>            :     if(lastError == ERROR_PROC_NOT_FOUND) {
<span class="lineNum">    2452 </span>            :       *status = U_MISSING_RESOURCE_ERROR;
<span class="lineNum">    2453 </span>            :     } else {
<span class="lineNum">    2454 </span>            :       *status = U_UNSUPPORTED_ERROR; /* other unknown error. */
<span class="lineNum">    2455 </span>            :     }
<span class="lineNum">    2456 </span>            :   }
<span class="lineNum">    2457 </span>            :   
<span class="lineNum">    2458 </span>            :   return addr;
<span class="lineNum">    2459 </span>            : }
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span>            : #else
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span>            : /* No dynamic loading set. */
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span>            : U_INTERNAL void * U_EXPORT2
<span class="lineNum">    2467 </span>            : uprv_dl_open(const char *libName, UErrorCode *status) {
<span class="lineNum">    2468 </span>            :     (void)libName;
<span class="lineNum">    2469 </span>            :     if(U_FAILURE(*status)) return NULL;
<span class="lineNum">    2470 </span>            :     *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2471 </span>            :     return NULL;
<span class="lineNum">    2472 </span>            : }
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            : U_INTERNAL void U_EXPORT2
<span class="lineNum">    2475 </span>            : uprv_dl_close(void *lib, UErrorCode *status) {
<span class="lineNum">    2476 </span>            :     (void)lib;
<span class="lineNum">    2477 </span>            :     if(U_FAILURE(*status)) return;
<span class="lineNum">    2478 </span>            :     *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2479 </span>            :     return;
<span class="lineNum">    2480 </span>            : }
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            : U_INTERNAL UVoidFunction* U_EXPORT2
<span class="lineNum">    2484 </span>            : uprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {
<span class="lineNum">    2485 </span>            :   (void)lib;
<span class="lineNum">    2486 </span>            :   (void)sym;
<span class="lineNum">    2487 </span>            :   if(U_SUCCESS(*status)) {
<span class="lineNum">    2488 </span>            :     *status = U_UNSUPPORTED_ERROR;
<span class="lineNum">    2489 </span>            :   }
<span class="lineNum">    2490 </span>            :   return (UVoidFunction*)NULL;
<span class="lineNum">    2491 </span>            : }
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span>            : #endif /* U_ENABLE_DYLOAD */
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            : /*
<span class="lineNum">    2496 </span>            :  * Hey, Emacs, please set the following:
<span class="lineNum">    2497 </span>            :  *
<span class="lineNum">    2498 </span>            :  * Local Variables:
<span class="lineNum">    2499 </span>            :  * indent-tabs-mode: nil
<span class="lineNum">    2500 </span>            :  * End:
<span class="lineNum">    2501 </span>            :  *
<span class="lineNum">    2502 </span>            :  */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

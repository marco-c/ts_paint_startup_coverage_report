<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/ucurr.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - ucurr.cpp<span style="font-size: 80%;"> (source / <a href="ucurr.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1006</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">55</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : **********************************************************************
<span class="lineNum">       5 </span>            : * Copyright (c) 2002-2016, International Business Machines
<span class="lineNum">       6 </span>            : * Corporation and others.  All Rights Reserved.
<span class="lineNum">       7 </span>            : **********************************************************************
<span class="lineNum">       8 </span>            : */
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #if !UCONFIG_NO_FORMATTING
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;unicode/ucurr.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;unicode/locid.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;unicode/ures.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;unicode/ustring.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;unicode/parsepos.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;ustr_imp.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;cstring.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;umutex.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;ucln_cmn.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;uenumimp.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;uhash.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;hash.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;uresimp.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;ulist.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;ureslocs.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;ulocimp.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : //#define UCURR_DEBUG_EQUIV 1
<span class="lineNum">      34 </span>            : #ifdef UCURR_DEBUG_EQUIV
<span class="lineNum">      35 </span>            : #include &quot;stdio.h&quot;
<span class="lineNum">      36 </span>            : #endif
<span class="lineNum">      37 </span>            : //#define UCURR_DEBUG 1
<span class="lineNum">      38 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">      39 </span>            : #include &quot;stdio.h&quot;
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : typedef struct IsoCodeEntry {
<span class="lineNum">      43 </span>            :     const UChar *isoCode; /* const because it's a reference to a resource bundle string. */
<span class="lineNum">      44 </span>            :     UDate from;
<span class="lineNum">      45 </span>            :     UDate to;
<span class="lineNum">      46 </span>            : } IsoCodeEntry;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : //------------------------------------------------------------
<span class="lineNum">      49 </span>            : // Constants
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // Default currency meta data of last resort.  We try to use the
<span class="lineNum">      52 </span>            : // defaults encoded in the meta data resource bundle.  If there is a
<span class="lineNum">      53 </span>            : // configuration/build error and these are not available, we use these
<span class="lineNum">      54 </span>            : // hard-coded defaults (which should be identical).
<span class="lineNum">      55 </span>            : static const int32_t LAST_RESORT_DATA[] = { 2, 0, 2, 0 };
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : // POW10[i] = 10^i, i=0..MAX_POW10
<span class="lineNum">      58 </span>            : static const int32_t POW10[] = { 1, 10, 100, 1000, 10000, 100000,
<span class="lineNum">      59 </span>            :                                  1000000, 10000000, 100000000, 1000000000 };
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : static const int32_t MAX_POW10 = UPRV_LENGTHOF(POW10) - 1;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : // Defines equivalent currency symbols.
<span class="lineNum">      64 </span>            : static const char *EQUIV_CURRENCY_SYMBOLS[][2] = {
<span class="lineNum">      65 </span>            :     {&quot;\\u00a5&quot;, &quot;\\uffe5&quot;},
<span class="lineNum">      66 </span>            :     {&quot;$&quot;, &quot;\\ufe69&quot;},
<span class="lineNum">      67 </span>            :     {&quot;$&quot;, &quot;\\uff04&quot;},
<span class="lineNum">      68 </span>            :     {&quot;\\u20a8&quot;, &quot;\\u20b9&quot;},
<span class="lineNum">      69 </span>            :     {&quot;\\u00a3&quot;, &quot;\\u20a4&quot;}};
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : #define ISO_CURRENCY_CODE_LENGTH 3
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : //------------------------------------------------------------
<span class="lineNum">      74 </span>            : // Resource tags
<span class="lineNum">      75 </span>            : //
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : static const char CURRENCY_DATA[] = &quot;supplementalData&quot;;
<span class="lineNum">      78 </span>            : // Tag for meta-data, in root.
<span class="lineNum">      79 </span>            : static const char CURRENCY_META[] = &quot;CurrencyMeta&quot;;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : // Tag for map from countries to currencies, in root.
<span class="lineNum">      82 </span>            : static const char CURRENCY_MAP[] = &quot;CurrencyMap&quot;;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : // Tag for default meta-data, in CURRENCY_META
<span class="lineNum">      85 </span>            : static const char DEFAULT_META[] = &quot;DEFAULT&quot;;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : // Variant for legacy pre-euro mapping in CurrencyMap
<span class="lineNum">      88 </span>            : static const char VAR_PRE_EURO[] = &quot;PREEURO&quot;;
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : // Variant for legacy euro mapping in CurrencyMap
<span class="lineNum">      91 </span>            : static const char VAR_EURO[] = &quot;EURO&quot;;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : // Variant delimiter
<span class="lineNum">      94 </span>            : static const char VAR_DELIM = '_';
<span class="lineNum">      95 </span>            : static const char VAR_DELIM_STR[] = &quot;_&quot;;
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : // Variant for legacy euro mapping in CurrencyMap
<span class="lineNum">      98 </span>            : //static const char VAR_DELIM_EURO[] = &quot;_EURO&quot;;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : #define VARIANT_IS_EMPTY    0
<span class="lineNum">     101 </span>            : #define VARIANT_IS_EURO     0x1
<span class="lineNum">     102 </span>            : #define VARIANT_IS_PREEURO  0x2
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : // Tag for localized display names (symbols) of currencies
<span class="lineNum">     105 </span>            : static const char CURRENCIES[] = &quot;Currencies&quot;;
<span class="lineNum">     106 </span>            : static const char CURRENCYPLURALS[] = &quot;CurrencyPlurals&quot;;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : static const UChar EUR_STR[] = {0x0045,0x0055,0x0052,0};
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : // ISO codes mapping table
<span class="lineNum">     111 </span>            : static const UHashtable* gIsoCodes = NULL;
<span class="lineNum">     112 </span>            : static icu::UInitOnce gIsoCodesInitOnce = U_INITONCE_INITIALIZER;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : // Currency symbol equivalances
<span class="lineNum">     115 </span>            : static const icu::Hashtable* gCurrSymbolsEquiv = NULL;
<span class="lineNum">     116 </span>            : static icu::UInitOnce gCurrSymbolsEquivInitOnce = U_INITONCE_INITIALIZER;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : U_NAMESPACE_BEGIN
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : // EquivIterator iterates over all strings that are equivalent to a given
<span class="lineNum">     121 </span>            : // string, s. Note that EquivIterator will never yield s itself.
<span class="lineNum">     122 </span>            : class EquivIterator : public icu::UMemory {
<span class="lineNum">     123 </span>            : public:
<a name="124"><span class="lineNum">     124 </span>            :     // Constructor. hash stores the equivalence relationships; s is the string</a>
<span class="lineNum">     125 </span>            :     // for which we find equivalent strings.
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     inline EquivIterator(const icu::Hashtable&amp; hash, const icu::UnicodeString&amp; s)</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         : _hash(hash) { </span>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :         _start = _current = &amp;s;</span></a>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     inline ~EquivIterator() { }</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     // next returns the next equivalent string or NULL if there are no more.
<span class="lineNum">     133 </span>            :     // If s has no equivalent strings, next returns NULL on the first call.
<span class="lineNum">     134 </span>            :     const icu::UnicodeString *next();
<span class="lineNum">     135 </span>            : private:
<span class="lineNum">     136 </span>            :     const icu::Hashtable&amp; _hash;
<span class="lineNum">     137 </span>            :     const icu::UnicodeString* _start;
<span class="lineNum">     138 </span>            :     const icu::UnicodeString* _current;
<span class="lineNum">     139 </span>            : };
<a name="140"><span class="lineNum">     140 </span>            : </a>
<span class="lineNum">     141 </span>            : const icu::UnicodeString *
<span class="lineNum">     142 </span><span class="lineNoCov">          0 : EquivIterator::next() {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     const icu::UnicodeString* _next = (const icu::UnicodeString*) _hash.get(*_current);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     if (_next == NULL) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         U_ASSERT(_current == _start);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     147 </span>            :     }
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     if (*_next == *_start) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     150 </span>            :     }
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     _current = _next;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     return _next;</span>
<span class="lineNum">     153 </span>            : }
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : U_NAMESPACE_END
<span class="lineNum">     156 </span>            : 
<a name="157"><span class="lineNum">     157 </span>            : // makeEquivalent makes lhs and rhs equivalent by updating the equivalence</a>
<span class="lineNum">     158 </span>            : // relations in hash accordingly.
<span class="lineNum">     159 </span><span class="lineNoCov">          0 : static void makeEquivalent(</span>
<span class="lineNum">     160 </span>            :     const icu::UnicodeString &amp;lhs,
<span class="lineNum">     161 </span>            :     const icu::UnicodeString &amp;rhs,
<span class="lineNum">     162 </span>            :     icu::Hashtable* hash, UErrorCode &amp;status) {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     if (lhs == rhs) {</span>
<span class="lineNum">     167 </span>            :         // already equivalent
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     169 </span>            :     }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     icu::EquivIterator leftIter(*hash, lhs);</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     icu::EquivIterator rightIter(*hash, rhs);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     const icu::UnicodeString *firstLeft = leftIter.next();</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     const icu::UnicodeString *firstRight = rightIter.next();</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     const icu::UnicodeString *nextLeft = firstLeft;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     const icu::UnicodeString *nextRight = firstRight;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     while (nextLeft != NULL &amp;&amp; nextRight != NULL) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         if (*nextLeft == rhs || *nextRight == lhs) {</span>
<span class="lineNum">     178 </span>            :             // Already equivalent
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     180 </span>            :         }
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         nextLeft = leftIter.next();</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :         nextRight = rightIter.next();</span>
<span class="lineNum">     183 </span>            :     }
<span class="lineNum">     184 </span>            :     // Not equivalent. Must join.
<span class="lineNum">     185 </span>            :     icu::UnicodeString *newFirstLeft;
<span class="lineNum">     186 </span>            :     icu::UnicodeString *newFirstRight;
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     if (firstRight == NULL &amp;&amp; firstLeft == NULL) {</span>
<span class="lineNum">     188 </span>            :         // Neither lhs or rhs belong to an equivalence circle, so we form
<span class="lineNum">     189 </span>            :         // a new equivalnce circle of just lhs and rhs.
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :         newFirstLeft = new icu::UnicodeString(rhs);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         newFirstRight = new icu::UnicodeString(lhs);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     } else if (firstRight == NULL) {</span>
<span class="lineNum">     193 </span>            :         // lhs belongs to an equivalence circle, but rhs does not, so we link
<span class="lineNum">     194 </span>            :         // rhs into lhs' circle.
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         newFirstLeft = new icu::UnicodeString(rhs);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         newFirstRight = new icu::UnicodeString(*firstLeft);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     } else if (firstLeft == NULL) {</span>
<span class="lineNum">     198 </span>            :         // rhs belongs to an equivlance circle, but lhs does not, so we link
<span class="lineNum">     199 </span>            :         // lhs into rhs' circle.
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         newFirstLeft = new icu::UnicodeString(*firstRight);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         newFirstRight = new icu::UnicodeString(lhs);</span>
<span class="lineNum">     202 </span>            :     } else {
<span class="lineNum">     203 </span>            :         // Both lhs and rhs belong to different equivalnce circles. We link
<span class="lineNum">     204 </span>            :         // them together to form one single, larger equivalnce circle.
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :         newFirstLeft = new icu::UnicodeString(*firstRight);</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         newFirstRight = new icu::UnicodeString(*firstLeft);</span>
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     if (newFirstLeft == NULL || newFirstRight == NULL) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         delete newFirstLeft;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         delete newFirstRight;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     hash-&gt;put(lhs, (void *) newFirstLeft, status);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     hash-&gt;put(rhs, (void *) newFirstRight, status);</span>
<span class="lineNum">     216 </span>            : }
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : // countEquivalent counts how many strings are equivalent to s.
<a name="219"><span class="lineNum">     219 </span>            : // hash stores all the equivalnce relations.</a>
<span class="lineNum">     220 </span>            : // countEquivalent does not include s itself in the count.
<span class="lineNum">     221 </span><span class="lineNoCov">          0 : static int32_t countEquivalent(const icu::Hashtable &amp;hash, const icu::UnicodeString &amp;s) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     int32_t result = 0;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     icu::EquivIterator iter(hash, s);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     while (iter.next() != NULL) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         ++result;</span>
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span>            : #ifdef UCURR_DEBUG_EQUIV
<span class="lineNum">     228 </span>            :  {
<span class="lineNum">     229 </span>            :    char tmp[200];
<span class="lineNum">     230 </span>            :    s.extract(0,s.length(),tmp, &quot;UTF-8&quot;);
<span class="lineNum">     231 </span>            :    printf(&quot;CountEquivalent('%s') = %d\n&quot;, tmp, result);
<span class="lineNum">     232 </span>            :  }
<span class="lineNum">     233 </span>            : #endif
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     235 </span>            : }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : static const icu::Hashtable* getCurrSymbolsEquiv();
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : //------------------------------------------------------------
<span class="lineNum">     240 </span>            : // Code
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : /**
<span class="lineNum">     243 </span>            :  * Cleanup callback func
<a name="244"><span class="lineNum">     244 </span>            :  */</a>
<span class="lineNum">     245 </span>            : static UBool U_CALLCONV 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : isoCodes_cleanup(void)</span>
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     if (gIsoCodes != NULL) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         uhash_close(const_cast&lt;UHashtable *&gt;(gIsoCodes));</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         gIsoCodes = NULL;</span>
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     gIsoCodesInitOnce.reset();</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     254 </span>            : }
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : /**
<span class="lineNum">     257 </span>            :  * Cleanup callback func
<a name="258"><span class="lineNum">     258 </span>            :  */</a>
<span class="lineNum">     259 </span>            : static UBool U_CALLCONV 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : currSymbolsEquiv_cleanup(void)</span>
<span class="lineNum">     261 </span>            : {
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     delete const_cast&lt;icu::Hashtable *&gt;(gCurrSymbolsEquiv);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     gCurrSymbolsEquiv = NULL;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     gCurrSymbolsEquivInitOnce.reset();</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     266 </span>            : }
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : /**
<span class="lineNum">     269 </span>            :  * Deleter for OlsonToMetaMappingEntry
<a name="270"><span class="lineNum">     270 </span>            :  */</a>
<span class="lineNum">     271 </span>            : static void U_CALLCONV
<span class="lineNum">     272 </span><span class="lineNoCov">          0 : deleteIsoCodeEntry(void *obj) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     IsoCodeEntry *entry = (IsoCodeEntry*)obj;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     uprv_free(entry);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : /**
<span class="lineNum">     278 </span>            :  * Deleter for gCurrSymbolsEquiv.
<a name="279"><span class="lineNum">     279 </span>            :  */</a>
<span class="lineNum">     280 </span>            : static void U_CALLCONV
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : deleteUnicode(void *obj) {</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     icu::UnicodeString *entry = (icu::UnicodeString*)obj;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     delete entry;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /**
<span class="lineNum">     287 </span>            :  * Unfortunately, we have to convert the UChar* currency code to char*
<span class="lineNum">     288 </span>            :  * to use it as a resource key.
<a name="289"><span class="lineNum">     289 </span>            :  */</a>
<span class="lineNum">     290 </span>            : static inline char*
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : myUCharsToChars(char* resultOfLen4, const UChar* currency) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     u_UCharsToChars(currency, resultOfLen4, ISO_CURRENCY_CODE_LENGTH);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     resultOfLen4[ISO_CURRENCY_CODE_LENGTH] = 0;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     return resultOfLen4;</span>
<span class="lineNum">     295 </span>            : }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : /**
<span class="lineNum">     298 </span>            :  * Internal function to look up currency data.  Result is an array of
<span class="lineNum">     299 </span>            :  * four integers.  The first is the fraction digits.  The second is the
<span class="lineNum">     300 </span>            :  * rounding increment, or 0 if none.  The rounding increment is in
<span class="lineNum">     301 </span>            :  * units of 10^(-fraction_digits).  The third and fourth are the same
<span class="lineNum">     302 </span>            :  * except that they are those used in cash transations ( cashDigits
<span class="lineNum">     303 </span>            :  * and cashRounding ).
<a name="304"><span class="lineNum">     304 </span>            :  */</a>
<span class="lineNum">     305 </span>            : static const int32_t*
<span class="lineNum">     306 </span><span class="lineNoCov">          0 : _findMetaData(const UChar* currency, UErrorCode&amp; ec) {</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     if (currency == 0 || *currency == 0) {</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         if (U_SUCCESS(ec)) {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     311 </span>            :         }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         return LAST_RESORT_DATA;</span>
<span class="lineNum">     313 </span>            :     }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :     // Get CurrencyMeta resource out of root locale file.  [This may
<span class="lineNum">     316 </span>            :     // move out of the root locale file later; if it does, update this
<span class="lineNum">     317 </span>            :     // code.]
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     UResourceBundle* currencyData = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;ec);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     UResourceBundle* currencyMeta = ures_getByKey(currencyData, CURRENCY_META, currencyData, &amp;ec);</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec)) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         ures_close(currencyMeta);</span>
<span class="lineNum">     323 </span>            :         // Config/build error; return hard-coded defaults
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         return LAST_RESORT_DATA;</span>
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :     // Look up our currency, or if that's not available, then DEFAULT
<span class="lineNum">     328 </span>            :     char buf[ISO_CURRENCY_CODE_LENGTH+1];
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     UErrorCode ec2 = U_ZERO_ERROR; // local error code: soft failure</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     UResourceBundle* rb = ures_getByKey(currencyMeta, myUCharsToChars(buf, currency), NULL, &amp;ec2);</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :       if (U_FAILURE(ec2)) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         ures_close(rb);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         rb = ures_getByKey(currencyMeta,DEFAULT_META, NULL, &amp;ec);</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :         if (U_FAILURE(ec)) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :             ures_close(currencyMeta);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :             ures_close(rb);</span>
<span class="lineNum">     337 </span>            :             // Config/build error; return hard-coded defaults
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :             return LAST_RESORT_DATA;</span>
<span class="lineNum">     339 </span>            :         }
<span class="lineNum">     340 </span>            :     }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     int32_t len;
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     const int32_t *data = ures_getIntVector(rb, &amp;len, &amp;ec);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec) || len != 4) {</span>
<span class="lineNum">     345 </span>            :         // Config/build error; return hard-coded defaults
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         if (U_SUCCESS(ec)) {</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             ec = U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">     348 </span>            :         }
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         ures_close(currencyMeta);</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         ures_close(rb);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         return LAST_RESORT_DATA;</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     ures_close(currencyMeta);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     ures_close(rb);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     return data;</span>
<span class="lineNum">     357 </span>            : }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : // -------------------------------------
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : /**
<span class="lineNum">     362 </span>            :  * @see VARIANT_IS_EURO
<span class="lineNum">     363 </span>            :  * @see VARIANT_IS_PREEURO
<a name="364"><span class="lineNum">     364 </span>            :  */</a>
<span class="lineNum">     365 </span>            : static uint32_t
<span class="lineNum">     366 </span><span class="lineNoCov">          0 : idForLocale(const char* locale, char* countryAndVariant, int capacity, UErrorCode* ec)</span>
<span class="lineNum">     367 </span>            : {
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     uint32_t variantType = 0;</span>
<span class="lineNum">     369 </span>            :     // !!! this is internal only, assumes buffer is not null and capacity is sufficient
<span class="lineNum">     370 </span>            :     // Extract the country name and variant name.  We only
<span class="lineNum">     371 </span>            :     // recognize two variant names, EURO and PREEURO.
<span class="lineNum">     372 </span>            :     char variant[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     ulocimp_getRegionForSupplementalData(locale, FALSE, countryAndVariant, capacity, ec);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     uloc_getVariant(locale, variant, sizeof(variant), ec);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     if (variant[0] != 0) {</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         variantType = (uint32_t)(0 == uprv_strcmp(variant, VAR_EURO))</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                    | ((uint32_t)(0 == uprv_strcmp(variant, VAR_PRE_EURO)) &lt;&lt; 1);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         if (variantType)</span>
<span class="lineNum">     379 </span>            :         {
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             uprv_strcat(countryAndVariant, VAR_DELIM_STR);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             uprv_strcat(countryAndVariant, variant);</span>
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            :     }
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     return variantType;</span>
<span class="lineNum">     385 </span>            : }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : // ------------------------------------------
<span class="lineNum">     388 </span>            : //
<span class="lineNum">     389 </span>            : // Registration
<span class="lineNum">     390 </span>            : //
<span class="lineNum">     391 </span>            : //-------------------------------------------
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : // don't use ICUService since we don't need fallback
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : U_CDECL_BEGIN
<span class="lineNum">     396 </span>            : static UBool U_CALLCONV currency_cleanup(void);
<span class="lineNum">     397 </span>            : U_CDECL_END
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : #if !UCONFIG_NO_SERVICE
<span class="lineNum">     400 </span>            : struct CReg;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : static UMutex gCRegLock = U_MUTEX_INITIALIZER;
<span class="lineNum">     403 </span>            : static CReg* gCRegHead = 0;
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : struct CReg : public icu::UMemory {
<span class="lineNum">     406 </span>            :     CReg *next;
<span class="lineNum">     407 </span>            :     UChar iso[ISO_CURRENCY_CODE_LENGTH+1];
<a name="408"><span class="lineNum">     408 </span>            :     char  id[ULOC_FULLNAME_CAPACITY];</a>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     CReg(const UChar* _iso, const char* _id)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         : next(0)</span>
<span class="lineNum">     412 </span>            :     {
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         int32_t len = (int32_t)uprv_strlen(_id);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         if (len &gt; (int32_t)(sizeof(id)-1)) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :             len = (sizeof(id)-1);</span>
<span class="lineNum">     416 </span>            :         }
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         uprv_strncpy(id, _id, len);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         id[len] = 0;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         u_memcpy(iso, _iso, ISO_CURRENCY_CODE_LENGTH);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         iso[ISO_CURRENCY_CODE_LENGTH] = 0;</span>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     static UCurrRegistryKey reg(const UChar* _iso, const char* _id, UErrorCode* status)</span>
<span class="lineNum">     424 </span>            :     {
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         if (status &amp;&amp; U_SUCCESS(*status) &amp;&amp; _iso &amp;&amp; _id) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             CReg* n = new CReg(_iso, _id);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :             if (n) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                 umtx_lock(&amp;gCRegLock);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                 if (!gCRegHead) {</span>
<span class="lineNum">     430 </span>            :                     /* register for the first time */
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);</span>
<span class="lineNum">     432 </span>            :                 }
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                 n-&gt;next = gCRegHead;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 gCRegHead = n;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                 umtx_unlock(&amp;gCRegLock);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                 return n;</span>
<span class="lineNum">     437 </span>            :             }
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     439 </span>            :         }
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="441"><span class="lineNum">     441 </span>            :     }</a>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     static UBool unreg(UCurrRegistryKey key) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         UBool found = FALSE;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         umtx_lock(&amp;gCRegLock);</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         CReg** p = &amp;gCRegHead;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         while (*p) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :             if (*p == key) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 *p = ((CReg*)key)-&gt;next;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                 delete (CReg*)key;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                 found = TRUE;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     454 </span>            :             }
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :             p = &amp;((*p)-&gt;next);</span>
<span class="lineNum">     456 </span>            :         }
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         umtx_unlock(&amp;gCRegLock);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         return found;</span>
<a name="460"><span class="lineNum">     460 </span>            :     }</a>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     static const UChar* get(const char* id) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         const UChar* result = NULL;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         umtx_lock(&amp;gCRegLock);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         CReg* p = gCRegHead;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :         /* register cleanup of the mutex */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         while (p) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :             if (uprv_strcmp(id, p-&gt;id) == 0) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 result = p-&gt;iso;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     473 </span>            :             }
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :             p = p-&gt;next;</span>
<span class="lineNum">     475 </span>            :         }
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         umtx_unlock(&amp;gCRegLock);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     478 </span>            :     }
<a name="479"><span class="lineNum">     479 </span>            : </a>
<span class="lineNum">     480 </span>            :     /* This doesn't need to be thread safe. It's for u_cleanup only. */
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     static void cleanup(void) {</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         while (gCRegHead) {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :             CReg* n = gCRegHead;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :             gCRegHead = gCRegHead-&gt;next;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :             delete n;</span>
<span class="lineNum">     486 </span>            :         }
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     488 </span>            : };
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : // -------------------------------------
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : U_CAPI UCurrRegistryKey U_EXPORT2
<span class="lineNum">     493 </span><span class="lineNoCov">          0 : ucurr_register(const UChar* isoCode, const char* locale, UErrorCode *status)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     if (status &amp;&amp; U_SUCCESS(*status)) {</span>
<span class="lineNum">     496 </span>            :         char id[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         idForLocale(locale, id, sizeof(id), status);</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         return CReg::reg(isoCode, id, status);</span>
<span class="lineNum">     499 </span>            :     }
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     501 </span>            : }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : // -------------------------------------
<a name="504"><span class="lineNum">     504 </span>            : </a>
<span class="lineNum">     505 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     506 </span><span class="lineNoCov">          0 : ucurr_unregister(UCurrRegistryKey key, UErrorCode* status)</span>
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     if (status &amp;&amp; U_SUCCESS(*status)) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         return CReg::unreg(key);</span>
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">     512 </span>            : }
<span class="lineNum">     513 </span>            : #endif /* UCONFIG_NO_SERVICE */
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : // -------------------------------------
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : /**
<span class="lineNum">     518 </span>            :  * Release all static memory held by currency.
<span class="lineNum">     519 </span>            :  */
<span class="lineNum">     520 </span>            : /*The declaration here is needed so currency_cleanup(void)
<span class="lineNum">     521 </span>            :  * can call this function.
<span class="lineNum">     522 </span>            :  */
<span class="lineNum">     523 </span>            : static UBool U_CALLCONV
<span class="lineNum">     524 </span>            : currency_cache_cleanup(void);
<a name="525"><span class="lineNum">     525 </span>            : </a>
<span class="lineNum">     526 </span>            : U_CDECL_BEGIN
<span class="lineNum">     527 </span><span class="lineNoCov">          0 : static UBool U_CALLCONV currency_cleanup(void) {</span>
<span class="lineNum">     528 </span>            : #if !UCONFIG_NO_SERVICE
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     CReg::cleanup();</span>
<span class="lineNum">     530 </span>            : #endif
<span class="lineNum">     531 </span>            :     /*
<span class="lineNum">     532 </span>            :      * There might be some cached currency data or isoCodes data.
<span class="lineNum">     533 </span>            :      */
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     currency_cache_cleanup();</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     isoCodes_cleanup();</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     currSymbolsEquiv_cleanup();</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     539 </span>            : }
<span class="lineNum">     540 </span>            : U_CDECL_END
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            : // -------------------------------------
<a name="543"><span class="lineNum">     543 </span>            : </a>
<span class="lineNum">     544 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : ucurr_forLocale(const char* locale,</span>
<span class="lineNum">     546 </span>            :                 UChar* buff,
<span class="lineNum">     547 </span>            :                 int32_t buffCapacity,
<span class="lineNum">     548 </span>            :                 UErrorCode* ec)
<span class="lineNum">     549 </span>            : {
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     int32_t resLen = 0;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     if (ec != NULL &amp;&amp; U_SUCCESS(*ec)) {</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         if ((buff &amp;&amp; buffCapacity) || !buffCapacity) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :             UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">     555 </span>            :             char id[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :             if ((resLen = uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus))) {</span>
<span class="lineNum">     557 </span>            :                 // there is a currency keyword. Try to see if it's valid
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 if(buffCapacity &gt; resLen) {</span>
<span class="lineNum">     559 </span>            :                     /* Normalize the currency keyword value to upper case. */
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :                     T_CString_toUpperCase(id);</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                     u_charsToUChars(id, buff, resLen);</span>
<span class="lineNum">     562 </span>            :                 }
<span class="lineNum">     563 </span>            :             } else {
<span class="lineNum">     564 </span>            :                 // get country or country_variant in `id'
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :                 uint32_t variantType = idForLocale(locale, id, sizeof(id), ec);</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                 if (U_FAILURE(*ec)) {</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :                     return 0;</span>
<span class="lineNum">     569 </span>            :                 }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : #if !UCONFIG_NO_SERVICE
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                 const UChar* result = CReg::get(id);</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 if (result) {</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                     if(buffCapacity &gt; u_strlen(result)) {</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                         u_strcpy(buff, result);</span>
<span class="lineNum">     576 </span>            :                     }
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                     return u_strlen(result);</span>
<span class="lineNum">     578 </span>            :                 }
<span class="lineNum">     579 </span>            : #endif
<span class="lineNum">     580 </span>            :                 // Remove variants, which is only needed for registration.
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 char *idDelim = strchr(id, VAR_DELIM);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                 if (idDelim) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                     idDelim[0] = 0;</span>
<span class="lineNum">     584 </span>            :                 }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :                 // Look up the CurrencyMap element in the root bundle.
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                 UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                 UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                 UResourceBundle *currencyReq = ures_getByIndex(countryArray, 0, NULL, &amp;localStatus);</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 s = ures_getStringByKey(currencyReq, &quot;id&quot;, &amp;resLen, &amp;localStatus);</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :                 /*
<span class="lineNum">     594 </span>            :                 Get the second item when PREEURO is requested, and this is a known Euro country.
<span class="lineNum">     595 </span>            :                 If the requested variant is PREEURO, and this isn't a Euro country, assume
<span class="lineNum">     596 </span>            :                 that the country changed over to the Euro in the future. This is probably
<span class="lineNum">     597 </span>            :                 an old version of ICU that hasn't been updated yet. The latest currency is
<span class="lineNum">     598 </span>            :                 probably correct.
<span class="lineNum">     599 </span>            :                 */
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :                 if (U_SUCCESS(localStatus)) {</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                     if ((variantType &amp; VARIANT_IS_PREEURO) &amp;&amp; u_strcmp(s, EUR_STR) == 0) {</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                         currencyReq = ures_getByIndex(countryArray, 1, currencyReq, &amp;localStatus);</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                         s = ures_getStringByKey(currencyReq, &quot;id&quot;, &amp;resLen, &amp;localStatus);</span>
<span class="lineNum">     604 </span>            :                     }
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                     else if ((variantType &amp; VARIANT_IS_EURO)) {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                         s = EUR_STR;</span>
<span class="lineNum">     607 </span>            :                     }
<span class="lineNum">     608 </span>            :                 }
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                 ures_close(countryArray);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                 ures_close(currencyReq);</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                 if ((U_FAILURE(localStatus)) &amp;&amp; strchr(id, '_') != 0)</span>
<span class="lineNum">     613 </span>            :                 {
<span class="lineNum">     614 </span>            :                     // We don't know about it.  Check to see if we support the variant.
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                     uloc_getParent(locale, id, sizeof(id), ec);</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                     *ec = U_USING_FALLBACK_WARNING;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                     return ucurr_forLocale(id, buff, buffCapacity, ec);</span>
<span class="lineNum">     618 </span>            :                 }
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                 else if (*ec == U_ZERO_ERROR || localStatus != U_ZERO_ERROR) {</span>
<span class="lineNum">     620 </span>            :                     // There is nothing to fallback to. Report the failure/warning if possible.
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                     *ec = localStatus;</span>
<span class="lineNum">     622 </span>            :                 }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                 if (U_SUCCESS(*ec)) {</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :                     if(buffCapacity &gt; resLen) {</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                         u_strcpy(buff, s);</span>
<span class="lineNum">     626 </span>            :                     }
<span class="lineNum">     627 </span>            :                 }
<span class="lineNum">     628 </span>            :             }
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             return u_terminateUChars(buff, buffCapacity, resLen, ec);</span>
<span class="lineNum">     630 </span>            :         } else {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :             *ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     632 </span>            :         }
<span class="lineNum">     633 </span>            :     }
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     return resLen;</span>
<span class="lineNum">     635 </span>            : }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : // end registration
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            : /**
<span class="lineNum">     640 </span>            :  * Modify the given locale name by removing the rightmost _-delimited
<span class="lineNum">     641 </span>            :  * element.  If there is none, empty the string (&quot;&quot; == root).
<span class="lineNum">     642 </span>            :  * NOTE: The string &quot;root&quot; is not recognized; do not use it.
<span class="lineNum">     643 </span>            :  * @return TRUE if the fallback happened; FALSE if locale is already
<a name="644"><span class="lineNum">     644 </span>            :  * root (&quot;&quot;).</a>
<span class="lineNum">     645 </span>            :  */
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : static UBool fallback(char *loc) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     if (!*loc) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     uloc_getParent(loc, loc, (int32_t)uprv_strlen(loc), &amp;status);</span>
<span class="lineNum">     652 </span>            :  /*
<span class="lineNum">     653 </span>            :     char *i = uprv_strrchr(loc, '_');
<span class="lineNum">     654 </span>            :     if (i == NULL) {
<span class="lineNum">     655 </span>            :         i = loc;
<span class="lineNum">     656 </span>            :     }
<span class="lineNum">     657 </span>            :     *i = 0;
<span class="lineNum">     658 </span>            :  */
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     660 </span>            : }
<span class="lineNum">     661 </span>            : 
<a name="662"><span class="lineNum">     662 </span>            : </a>
<span class="lineNum">     663 </span>            : U_CAPI const UChar* U_EXPORT2
<span class="lineNum">     664 </span><span class="lineNoCov">          0 : ucurr_getName(const UChar* currency,</span>
<span class="lineNum">     665 </span>            :               const char* locale,
<span class="lineNum">     666 </span>            :               UCurrNameStyle nameStyle,
<span class="lineNum">     667 </span>            :               UBool* isChoiceFormat, // fillin
<span class="lineNum">     668 </span>            :               int32_t* len, // fillin
<span class="lineNum">     669 </span>            :               UErrorCode* ec) {
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :     // Look up the Currencies resource for the given locale.  The
<span class="lineNum">     672 </span>            :     // Currencies locale data looks like this:
<span class="lineNum">     673 </span>            :     //|en {
<span class="lineNum">     674 </span>            :     //|  Currencies {
<span class="lineNum">     675 </span>            :     //|    USD { &quot;US$&quot;, &quot;US Dollar&quot; }
<span class="lineNum">     676 </span>            :     //|    CHF { &quot;Sw F&quot;, &quot;Swiss Franc&quot; }
<span class="lineNum">     677 </span>            :     //|    INR { &quot;=0#Rs|1#Re|1&lt;Rs&quot;, &quot;=0#Rupees|1#Rupee|1&lt;Rupees&quot; }
<span class="lineNum">     678 </span>            :     //|    //...
<span class="lineNum">     679 </span>            :     //|  }
<span class="lineNum">     680 </span>            :     //|}
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     if (U_FAILURE(*ec)) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     int32_t choice = (int32_t) nameStyle;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     if (choice &lt; 0 || choice &gt; 1) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         *ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     690 </span>            :     }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     // In the future, resource bundles may implement multi-level
<span class="lineNum">     693 </span>            :     // fallback.  That is, if a currency is not found in the en_US
<span class="lineNum">     694 </span>            :     // Currencies data, then the en Currencies data will be searched.
<span class="lineNum">     695 </span>            :     // Currently, if a Currencies datum exists in en_US and en, the
<span class="lineNum">     696 </span>            :     // en_US entry hides that in en.
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :     // We want multi-level fallback for this resource, so we implement
<span class="lineNum">     699 </span>            :     // it manually.
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :     // Use a separate UErrorCode here that does not propagate out of
<span class="lineNum">     702 </span>            :     // this function.
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     UErrorCode ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :     char loc[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     uloc_getName(locale, loc, sizeof(loc), &amp;ec2);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec2) || ec2 == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         *ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :     char buf[ISO_CURRENCY_CODE_LENGTH+1];
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     myUCharsToChars(buf, currency);</span>
<span class="lineNum">     714 </span>            :     
<span class="lineNum">     715 </span>            :     /* Normalize the keyword value to uppercase */
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     T_CString_toUpperCase(buf);</span>
<span class="lineNum">     717 </span>            :     
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     UResourceBundle* rb = ures_open(U_ICUDATA_CURR, loc, &amp;ec2);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     rb = ures_getByKey(rb, CURRENCIES, rb, &amp;ec2);</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :     // Fetch resource with multi-level resource inheritance fallback
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     rb = ures_getByKeyWithFallback(rb, buf, rb, &amp;ec2);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     s = ures_getStringByIndex(rb, choice, len, &amp;ec2);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     ures_close(rb);</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     // If we've succeeded we're done.  Otherwise, try to fallback.
<span class="lineNum">     731 </span>            :     // If that fails (because we are already at root) then exit.
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(ec2)) {</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         if (ec2 == U_USING_DEFAULT_WARNING</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :             || (ec2 == U_USING_FALLBACK_WARNING &amp;&amp; *ec != U_USING_DEFAULT_WARNING)) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             *ec = ec2;</span>
<span class="lineNum">     736 </span>            :         }
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :     // We no longer support choice format data in names.  Data should not contain
<span class="lineNum">     740 </span>            :     // choice patterns.
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     *isChoiceFormat = FALSE;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(ec2)) {</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         U_ASSERT(s != NULL);</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         return s;</span>
<span class="lineNum">     745 </span>            :     }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :     // If we fail to find a match, use the ISO 4217 code
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     *len = u_strlen(currency); // Should == ISO_CURRENCY_CODE_LENGTH, but maybe not...?</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     *ec = U_USING_DEFAULT_WARNING;</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     return currency;</span>
<span class="lineNum">     751 </span>            : }
<a name="752"><span class="lineNum">     752 </span>            : </a>
<span class="lineNum">     753 </span>            : U_CAPI const UChar* U_EXPORT2
<span class="lineNum">     754 </span><span class="lineNoCov">          0 : ucurr_getPluralName(const UChar* currency,</span>
<span class="lineNum">     755 </span>            :                     const char* locale,
<span class="lineNum">     756 </span>            :                     UBool* isChoiceFormat,
<span class="lineNum">     757 </span>            :                     const char* pluralCount,
<span class="lineNum">     758 </span>            :                     int32_t* len, // fillin
<span class="lineNum">     759 </span>            :                     UErrorCode* ec) {
<span class="lineNum">     760 </span>            :     // Look up the Currencies resource for the given locale.  The
<span class="lineNum">     761 </span>            :     // Currencies locale data looks like this:
<span class="lineNum">     762 </span>            :     //|en {
<span class="lineNum">     763 </span>            :     //|  CurrencyPlurals {
<span class="lineNum">     764 </span>            :     //|    USD{
<span class="lineNum">     765 </span>            :     //|      one{&quot;US dollar&quot;}
<span class="lineNum">     766 </span>            :     //|      other{&quot;US dollars&quot;}
<span class="lineNum">     767 </span>            :     //|    }
<span class="lineNum">     768 </span>            :     //|  }
<span class="lineNum">     769 </span>            :     //|}
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     if (U_FAILURE(*ec)) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :     // Use a separate UErrorCode here that does not propagate out of
<span class="lineNum">     776 </span>            :     // this function.
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     UErrorCode ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :     char loc[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     uloc_getName(locale, loc, sizeof(loc), &amp;ec2);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec2) || ec2 == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :         *ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     784 </span>            :     }
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :     char buf[ISO_CURRENCY_CODE_LENGTH+1];
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     myUCharsToChars(buf, currency);</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     UResourceBundle* rb = ures_open(U_ICUDATA_CURR, loc, &amp;ec2);</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     rb = ures_getByKey(rb, CURRENCYPLURALS, rb, &amp;ec2);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     // Fetch resource with multi-level resource inheritance fallback
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     rb = ures_getByKeyWithFallback(rb, buf, rb, &amp;ec2);</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     s = ures_getStringByKeyWithFallback(rb, pluralCount, len, &amp;ec2);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec2)) {</span>
<span class="lineNum">     800 </span>            :         //  fall back to &quot;other&quot;
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         s = ures_getStringByKeyWithFallback(rb, &quot;other&quot;, len, &amp;ec2);     </span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         if (U_FAILURE(ec2)) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             ures_close(rb);</span>
<span class="lineNum">     805 </span>            :             // fall back to long name in Currencies
<span class="lineNum">     806 </span>            :             return ucurr_getName(currency, locale, UCURR_LONG_NAME, 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :                                  isChoiceFormat, len, ec);</span>
<span class="lineNum">     808 </span>            :         }
<span class="lineNum">     809 </span>            :     }
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     ures_close(rb);</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :     // If we've succeeded we're done.  Otherwise, try to fallback.
<span class="lineNum">     813 </span>            :     // If that fails (because we are already at root) then exit.
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(ec2)) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         if (ec2 == U_USING_DEFAULT_WARNING</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :             || (ec2 == U_USING_FALLBACK_WARNING &amp;&amp; *ec != U_USING_DEFAULT_WARNING)) {</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :             *ec = ec2;</span>
<span class="lineNum">     818 </span>            :         }
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :         U_ASSERT(s != NULL);</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         return s;</span>
<span class="lineNum">     821 </span>            :     }
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     // If we fail to find a match, use the ISO 4217 code
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     *len = u_strlen(currency); // Should == ISO_CURRENCY_CODE_LENGTH, but maybe not...?</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     *ec = U_USING_DEFAULT_WARNING;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     return currency;</span>
<span class="lineNum">     827 </span>            : }
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : //========================================================================
<span class="lineNum">     831 </span>            : // Following are structure and function for parsing currency names
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : #define NEED_TO_BE_DELETED 0x1
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            : // TODO: a better way to define this?
<span class="lineNum">     836 </span>            : #define MAX_CURRENCY_NAME_LEN 100
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : typedef struct {
<span class="lineNum">     839 </span>            :     const char* IsoCode;  // key
<span class="lineNum">     840 </span>            :     UChar* currencyName;  // value
<span class="lineNum">     841 </span>            :     int32_t currencyNameLen;  // value length
<span class="lineNum">     842 </span>            :     int32_t flag;  // flags
<span class="lineNum">     843 </span>            : } CurrencyNameStruct;
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : #ifndef MIN
<span class="lineNum">     847 </span>            : #define MIN(a,b) (((a)&lt;(b)) ? (a) : (b))
<span class="lineNum">     848 </span>            : #endif
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : #ifndef MAX
<span class="lineNum">     851 </span>            : #define MAX(a,b) (((a)&lt;(b)) ? (b) : (a))
<span class="lineNum">     852 </span>            : #endif
<span class="lineNum">     853 </span>            : 
<a name="854"><span class="lineNum">     854 </span>            : </a>
<span class="lineNum">     855 </span>            : // Comparason function used in quick sort.
<span class="lineNum">     856 </span><span class="lineNoCov">          0 : static int U_CALLCONV currencyNameComparator(const void* a, const void* b) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     const CurrencyNameStruct* currName_1 = (const CurrencyNameStruct*)a;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     const CurrencyNameStruct* currName_2 = (const CurrencyNameStruct*)b;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     for (int32_t i = 0; </span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :          i &lt; MIN(currName_1-&gt;currencyNameLen, currName_2-&gt;currencyNameLen);</span>
<span class="lineNum">     861 </span>            :          ++i) {
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         if (currName_1-&gt;currencyName[i] &lt; currName_2-&gt;currencyName[i]) {</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     864 </span>            :         }
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         if (currName_1-&gt;currencyName[i] &gt; currName_2-&gt;currencyName[i]) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :             return 1;</span>
<span class="lineNum">     867 </span>            :         }
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     if (currName_1-&gt;currencyNameLen &lt; currName_2-&gt;currencyNameLen) {</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     } else if (currName_1-&gt;currencyNameLen &gt; currName_2-&gt;currencyNameLen) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     873 </span>            :     }
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     875 </span>            : }
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : // Give a locale, return the maximum number of currency names associated with
<span class="lineNum">     879 </span>            : // this locale.
<span class="lineNum">     880 </span>            : // It gets currency names from resource bundles using fallback.
<span class="lineNum">     881 </span>            : // It is the maximum number because in the fallback chain, some of the 
<span class="lineNum">     882 </span>            : // currency names are duplicated.
<span class="lineNum">     883 </span>            : // For example, given locale as &quot;en_US&quot;, the currency names get from resource
<span class="lineNum">     884 </span>            : // bundle in &quot;en_US&quot; and &quot;en&quot; are duplicated. The fallback mechanism will count
<a name="885"><span class="lineNum">     885 </span>            : // all currency names in &quot;en_US&quot; and &quot;en&quot;.</a>
<span class="lineNum">     886 </span>            : static void
<span class="lineNum">     887 </span><span class="lineNoCov">          0 : getCurrencyNameCount(const char* loc, int32_t* total_currency_name_count, int32_t* total_currency_symbol_count) {</span>
<span class="lineNum">     888 </span>            :     U_NAMESPACE_USE
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     *total_currency_name_count = 0;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     *total_currency_symbol_count = 0;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;</span>
<span class="lineNum">     892 </span>            :     char locale[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     uprv_strcpy(locale, loc);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     const icu::Hashtable *currencySymbolsEquiv = getCurrSymbolsEquiv();</span>
<span class="lineNum">     895 </span>            :     for (;;) {
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         UErrorCode ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     897 </span>            :         // TODO: ures_openDirect?
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         UResourceBundle* rb = ures_open(U_ICUDATA_CURR, locale, &amp;ec2);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         UResourceBundle* curr = ures_getByKey(rb, CURRENCIES, NULL, &amp;ec2);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         int32_t n = ures_getSize(curr);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         for (int32_t i=0; i&lt;n; ++i) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             UResourceBundle* names = ures_getByIndex(curr, i, NULL, &amp;ec2);</span>
<span class="lineNum">     903 </span>            :             int32_t len;
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :             s = ures_getStringByIndex(names, UCURR_SYMBOL_NAME, &amp;len, &amp;ec2);</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :             ++(*total_currency_symbol_count);  // currency symbol</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :             if (currencySymbolsEquiv != NULL) {</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 *total_currency_symbol_count += countEquivalent(*currencySymbolsEquiv, UnicodeString(TRUE, s, len));</span>
<span class="lineNum">     908 </span>            :             }
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :             ++(*total_currency_symbol_count); // iso code</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :             ++(*total_currency_name_count); // long name</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :             ures_close(names);</span>
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            :         // currency plurals
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :         UErrorCode ec3 = U_ZERO_ERROR;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &amp;ec3);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         n = ures_getSize(curr_p);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         for (int32_t i=0; i&lt;n; ++i) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :             UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &amp;ec3);</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :             *total_currency_name_count += ures_getSize(names);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :             ures_close(names);</span>
<span class="lineNum">     922 </span>            :         }
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         ures_close(curr_p);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         ures_close(curr);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         ures_close(rb);</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :         if (!fallback(locale)) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 : }</span>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<span class="lineNum">     933 </span>            : static UChar* 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 : toUpperCase(const UChar* source, int32_t len, const char* locale) {</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     UChar* dest = NULL;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     UErrorCode ec = U_ZERO_ERROR;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     int32_t destLen = u_strToUpper(dest, 0, source, len, locale, &amp;ec);</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     ec = U_ZERO_ERROR;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     dest = (UChar*)uprv_malloc(sizeof(UChar) * MAX(destLen, len));</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     u_strToUpper(dest, destLen, source, len, locale, &amp;ec);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec)) {</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         u_memcpy(dest, source, len);</span>
<span class="lineNum">     944 </span>            :     } 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     return dest;</span>
<span class="lineNum">     946 </span>            : }
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            : // Collect all available currency names associated with the given locale
<span class="lineNum">     950 </span>            : // (enable fallback chain).
<span class="lineNum">     951 </span>            : // Read currenc names defined in resource bundle &quot;Currencies&quot; and
<span class="lineNum">     952 </span>            : // &quot;CurrencyPlural&quot;, enable fallback chain.
<span class="lineNum">     953 </span>            : // return the malloc-ed currency name arrays and the total number of currency
<a name="954"><span class="lineNum">     954 </span>            : // names in the array.</a>
<span class="lineNum">     955 </span>            : static void
<span class="lineNum">     956 </span><span class="lineNoCov">          0 : collectCurrencyNames(const char* locale, </span>
<span class="lineNum">     957 </span>            :                      CurrencyNameStruct** currencyNames, 
<span class="lineNum">     958 </span>            :                      int32_t* total_currency_name_count, 
<span class="lineNum">     959 </span>            :                      CurrencyNameStruct** currencySymbols, 
<span class="lineNum">     960 </span>            :                      int32_t* total_currency_symbol_count, 
<span class="lineNum">     961 </span>            :                      UErrorCode&amp; ec) {
<span class="lineNum">     962 </span>            :     U_NAMESPACE_USE
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     const icu::Hashtable *currencySymbolsEquiv = getCurrSymbolsEquiv();</span>
<span class="lineNum">     964 </span>            :     // Look up the Currencies resource for the given locale.
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     UErrorCode ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     char loc[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     uloc_getName(locale, loc, sizeof(loc), &amp;ec2);</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec2) || ec2 == U_STRING_NOT_TERMINATED_WARNING) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     971 </span>            :     }
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            :     // Get maximum currency name count first.
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     getCurrencyNameCount(loc, total_currency_name_count, total_currency_symbol_count);</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     *currencyNames = (CurrencyNameStruct*)uprv_malloc</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         (sizeof(CurrencyNameStruct) * (*total_currency_name_count));</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     *currencySymbols = (CurrencyNameStruct*)uprv_malloc</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         (sizeof(CurrencyNameStruct) * (*total_currency_symbol_count));</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     if(currencyNames == NULL || currencySymbols == NULL) {</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       ec = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     983 </span>            :     }
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec)) return;</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;  // currency name</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     char* iso = NULL;  // currency ISO code</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     *total_currency_name_count = 0;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     *total_currency_symbol_count = 0;</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     UErrorCode ec3 = U_ZERO_ERROR;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     UErrorCode ec4 = U_ZERO_ERROR;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     // Using hash to remove duplicates caused by locale fallback
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     UHashtable* currencyIsoCodes = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;ec3);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     UHashtable* currencyPluralIsoCodes = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &amp;ec4);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     for (int32_t localeLevel = 0; ; ++localeLevel) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :         ec2 = U_ZERO_ERROR;</span>
<span class="lineNum">    1001 </span>            :         // TODO: ures_openDirect
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         UResourceBundle* rb = ures_open(U_ICUDATA_CURR, loc, &amp;ec2);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         UResourceBundle* curr = ures_getByKey(rb, CURRENCIES, NULL, &amp;ec2);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         int32_t n = ures_getSize(curr);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         for (int32_t i=0; i&lt;n; ++i) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :             UResourceBundle* names = ures_getByIndex(curr, i, NULL, &amp;ec2);</span>
<span class="lineNum">    1007 </span>            :             int32_t len;
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :             s = ures_getStringByIndex(names, UCURR_SYMBOL_NAME, &amp;len, &amp;ec2);</span>
<span class="lineNum">    1009 </span>            :             // TODO: uhash_put wont change key/value?
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :             iso = (char*)ures_getKey(names);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :             if (localeLevel == 0) {</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                 uhash_put(currencyIsoCodes, iso, iso, &amp;ec3); </span>
<span class="lineNum">    1013 </span>            :             } else {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                 if (uhash_get(currencyIsoCodes, iso) != NULL) {</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                     ures_close(names);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1017 </span>            :                 } else {
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                     uhash_put(currencyIsoCodes, iso, iso, &amp;ec3); </span>
<span class="lineNum">    1019 </span>            :                 }
<span class="lineNum">    1020 </span>            :             }
<span class="lineNum">    1021 </span>            :             // Add currency symbol.
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].IsoCode = iso;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].currencyName = (UChar*)s;</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].flag = 0;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :             (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = len;</span>
<span class="lineNum">    1026 </span>            :             // Add equivalent symbols
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :             if (currencySymbolsEquiv != NULL) {</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                 UnicodeString str(TRUE, s, len);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                 icu::EquivIterator iter(*currencySymbolsEquiv, str);</span>
<span class="lineNum">    1030 </span>            :                 const UnicodeString *symbol;
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                 while ((symbol = iter.next()) != NULL) {</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                     (*currencySymbols)[*total_currency_symbol_count].IsoCode = iso;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                     (*currencySymbols)[*total_currency_symbol_count].currencyName =</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                         const_cast&lt;UChar*&gt;(symbol-&gt;getBuffer());</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                     (*currencySymbols)[*total_currency_symbol_count].flag = 0;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                     (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = symbol-&gt;length();</span>
<span class="lineNum">    1037 </span>            :                 }
<span class="lineNum">    1038 </span>            :             }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :             // Add currency long name.
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :             s = ures_getStringByIndex(names, UCURR_LONG_NAME, &amp;len, &amp;ec2);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :             (*currencyNames)[*total_currency_name_count].IsoCode = iso;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :             UChar* upperName = toUpperCase(s, len, locale);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :             (*currencyNames)[*total_currency_name_count].currencyName = upperName;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :             (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :             (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :             // put (iso, 3, and iso) in to array
<span class="lineNum">    1049 </span>            :             // Add currency ISO code.
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].IsoCode = iso;</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].currencyName = (UChar*)uprv_malloc(sizeof(UChar)*3);</span>
<span class="lineNum">    1052 </span>            :             // Must convert iso[] into Unicode
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :             u_charsToUChars(iso, (*currencySymbols)[*total_currency_symbol_count].currencyName, 3);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :             (*currencySymbols)[*total_currency_symbol_count].flag = NEED_TO_BE_DELETED;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :             (*currencySymbols)[(*total_currency_symbol_count)++].currencyNameLen = 3;</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :             ures_close(names);</span>
<span class="lineNum">    1058 </span>            :         }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :         // currency plurals
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         UErrorCode ec3 = U_ZERO_ERROR;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :         UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &amp;ec3);</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         n = ures_getSize(curr_p);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         for (int32_t i=0; i&lt;n; ++i) {</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :             UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &amp;ec3);</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :             iso = (char*)ures_getKey(names);</span>
<span class="lineNum">    1067 </span>            :             // Using hash to remove duplicated ISO codes in fallback chain.
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             if (localeLevel == 0) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                 uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4); </span>
<span class="lineNum">    1070 </span>            :             } else {
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                 if (uhash_get(currencyPluralIsoCodes, iso) != NULL) {</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                     ures_close(names);</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1074 </span>            :                 } else {
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                     uhash_put(currencyPluralIsoCodes, iso, iso, &amp;ec4); </span>
<span class="lineNum">    1076 </span>            :                 }
<span class="lineNum">    1077 </span>            :             }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             int32_t num = ures_getSize(names);</span>
<span class="lineNum">    1079 </span>            :             int32_t len;
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :             for (int32_t j = 0; j &lt; num; ++j) {</span>
<span class="lineNum">    1081 </span>            :                 // TODO: remove duplicates between singular name and 
<span class="lineNum">    1082 </span>            :                 // currency long name?
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                 s = ures_getStringByIndex(names, j, &amp;len, &amp;ec3);</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                 (*currencyNames)[*total_currency_name_count].IsoCode = iso;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                 UChar* upperName = toUpperCase(s, len, locale);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                 (*currencyNames)[*total_currency_name_count].currencyName = upperName;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                 (*currencyNames)[*total_currency_name_count].flag = NEED_TO_BE_DELETED;</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                 (*currencyNames)[(*total_currency_name_count)++].currencyNameLen = len;</span>
<span class="lineNum">    1089 </span>            :             }
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :             ures_close(names);</span>
<span class="lineNum">    1091 </span>            :         }
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         ures_close(curr_p);</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         ures_close(curr);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         ures_close(rb);</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         if (!fallback(loc)) {</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1098 </span>            :         }
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     uhash_close(currencyIsoCodes);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     uhash_close(currencyPluralIsoCodes);</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :     // quick sort the struct
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     qsort(*currencyNames, *total_currency_name_count, </span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :           sizeof(CurrencyNameStruct), currencyNameComparator);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     qsort(*currencySymbols, *total_currency_symbol_count, </span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :           sizeof(CurrencyNameStruct), currencyNameComparator);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1111 </span>            :     printf(&quot;currency name count: %d\n&quot;, *total_currency_name_count);
<span class="lineNum">    1112 </span>            :     for (int32_t index = 0; index &lt; *total_currency_name_count; ++index) {
<span class="lineNum">    1113 </span>            :         printf(&quot;index: %d\n&quot;, index);
<span class="lineNum">    1114 </span>            :         printf(&quot;iso: %s\n&quot;, (*currencyNames)[index].IsoCode);
<span class="lineNum">    1115 </span>            :         char curNameBuf[1024];
<span class="lineNum">    1116 </span>            :         memset(curNameBuf, 0, 1024);
<span class="lineNum">    1117 </span>            :         u_austrncpy(curNameBuf, (*currencyNames)[index].currencyName, (*currencyNames)[index].currencyNameLen);
<span class="lineNum">    1118 </span>            :         printf(&quot;currencyName: %s\n&quot;, curNameBuf);
<span class="lineNum">    1119 </span>            :         printf(&quot;len: %d\n&quot;, (*currencyNames)[index].currencyNameLen);
<span class="lineNum">    1120 </span>            :     }
<span class="lineNum">    1121 </span>            :     printf(&quot;currency symbol count: %d\n&quot;, *total_currency_symbol_count);
<span class="lineNum">    1122 </span>            :     for (int32_t index = 0; index &lt; *total_currency_symbol_count; ++index) {
<span class="lineNum">    1123 </span>            :         printf(&quot;index: %d\n&quot;, index);
<span class="lineNum">    1124 </span>            :         printf(&quot;iso: %s\n&quot;, (*currencySymbols)[index].IsoCode);
<span class="lineNum">    1125 </span>            :         char curNameBuf[1024];
<span class="lineNum">    1126 </span>            :         memset(curNameBuf, 0, 1024);
<span class="lineNum">    1127 </span>            :         u_austrncpy(curNameBuf, (*currencySymbols)[index].currencyName, (*currencySymbols)[index].currencyNameLen);
<span class="lineNum">    1128 </span>            :         printf(&quot;currencySymbol: %s\n&quot;, curNameBuf);
<span class="lineNum">    1129 </span>            :         printf(&quot;len: %d\n&quot;, (*currencySymbols)[index].currencyNameLen);
<span class="lineNum">    1130 </span>            :     }
<span class="lineNum">    1131 </span>            : #endif
<span class="lineNum">    1132 </span>            :     // fail on hashtable errors
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec3)) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       ec = ec3;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1136 </span>            :     }
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec4)) {</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :       ec = ec4;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span>            : }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : // @param  currencyNames: currency names array
<span class="lineNum">    1144 </span>            : // @param  indexInCurrencyNames: the index of the character in currency names 
<span class="lineNum">    1145 </span>            : //         array against which the comparison is done
<span class="lineNum">    1146 </span>            : // @param  key: input text char to compare against
<span class="lineNum">    1147 </span>            : // @param  begin(IN/OUT): the begin index of matching range in currency names array
<a name="1148"><span class="lineNum">    1148 </span>            : // @param  end(IN/OUT): the end index of matching range in currency names array.</a>
<span class="lineNum">    1149 </span>            : static int32_t
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 : binarySearch(const CurrencyNameStruct* currencyNames, </span>
<span class="lineNum">    1151 </span>            :              int32_t indexInCurrencyNames,
<span class="lineNum">    1152 </span>            :              const UChar key,
<span class="lineNum">    1153 </span>            :              int32_t* begin, int32_t* end) {
<span class="lineNum">    1154 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1155 </span>            :     printf(&quot;key = %x\n&quot;, key);
<span class="lineNum">    1156 </span>            : #endif
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :    int32_t first = *begin;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :    int32_t last = *end;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :    while (first &lt;= last) {</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :        int32_t mid = (first + last) / 2;  // compute mid point.</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :        if (indexInCurrencyNames &gt;= currencyNames[mid].currencyNameLen) {</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :            first = mid + 1;</span>
<span class="lineNum">    1163 </span>            :        } else {
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :            if (key &gt; currencyNames[mid].currencyName[indexInCurrencyNames]) {</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                first = mid + 1;</span>
<span class="lineNum">    1166 </span>            :            }
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :            else if (key &lt; currencyNames[mid].currencyName[indexInCurrencyNames]) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :                last = mid - 1;</span>
<span class="lineNum">    1169 </span>            :            }
<span class="lineNum">    1170 </span>            :            else {
<span class="lineNum">    1171 </span>            :                 // Find a match, and looking for ranges
<span class="lineNum">    1172 </span>            :                 // Now do two more binary searches. First, on the left side for
<span class="lineNum">    1173 </span>            :                 // the greatest L such that CurrencyNameStruct[L] &lt; key.
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 int32_t L = *begin;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                 int32_t R = mid;</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1178 </span>            :                 printf(&quot;mid = %d\n&quot;, mid);
<span class="lineNum">    1179 </span>            : #endif
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                 while (L &lt; R) {</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                     int32_t M = (L + R) / 2;</span>
<span class="lineNum">    1182 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1183 </span>            :                     printf(&quot;L = %d, R = %d, M = %d\n&quot;, L, R, M);
<span class="lineNum">    1184 </span>            : #endif
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :                     if (indexInCurrencyNames &gt;= currencyNames[M].currencyNameLen) {</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                         L = M + 1;</span>
<span class="lineNum">    1187 </span>            :                     } else {
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                         if (currencyNames[M].currencyName[indexInCurrencyNames] &lt; key) {</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :                             L = M + 1;</span>
<span class="lineNum">    1190 </span>            :                         } else {
<span class="lineNum">    1191 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1192 </span>            :                             U_ASSERT(currencyNames[M].currencyName[indexInCurrencyNames] == key);
<span class="lineNum">    1193 </span>            : #endif
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                             R = M;</span>
<span class="lineNum">    1195 </span>            :                         }
<span class="lineNum">    1196 </span>            :                     }
<span class="lineNum">    1197 </span>            :                 }
<span class="lineNum">    1198 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1199 </span>            :                 U_ASSERT(L == R);
<span class="lineNum">    1200 </span>            : #endif
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :                 *begin = L;</span>
<span class="lineNum">    1202 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1203 </span>            :                 printf(&quot;begin = %d\n&quot;, *begin);
<span class="lineNum">    1204 </span>            :                 U_ASSERT(currencyNames[*begin].currencyName[indexInCurrencyNames] == key);
<span class="lineNum">    1205 </span>            : #endif
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            :                 // Now for the second search, finding the least R such that
<span class="lineNum">    1208 </span>            :                 // key &lt; CurrencyNameStruct[R].
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :                 L = mid;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :                 R = *end;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :                 while (L &lt; R) {</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                     int32_t M = (L + R) / 2;</span>
<span class="lineNum">    1213 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1214 </span>            :                     printf(&quot;L = %d, R = %d, M = %d\n&quot;, L, R, M);
<span class="lineNum">    1215 </span>            : #endif
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                     if (currencyNames[M].currencyNameLen &lt; indexInCurrencyNames) {</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                         L = M + 1;</span>
<span class="lineNum">    1218 </span>            :                     } else {
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                         if (currencyNames[M].currencyName[indexInCurrencyNames] &gt; key) {</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                             R = M;</span>
<span class="lineNum">    1221 </span>            :                         } else {
<span class="lineNum">    1222 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1223 </span>            :                             U_ASSERT(currencyNames[M].currencyName[indexInCurrencyNames] == key);
<span class="lineNum">    1224 </span>            : #endif
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :                             L = M + 1;</span>
<span class="lineNum">    1226 </span>            :                         }
<span class="lineNum">    1227 </span>            :                     }
<span class="lineNum">    1228 </span>            :                 }
<span class="lineNum">    1229 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1230 </span>            :                 U_ASSERT(L == R);
<span class="lineNum">    1231 </span>            : #endif
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                 if (currencyNames[R].currencyName[indexInCurrencyNames] &gt; key) {</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                     *end = R - 1;</span>
<span class="lineNum">    1234 </span>            :                 } else {
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                     *end = R;</span>
<span class="lineNum">    1236 </span>            :                 }
<span class="lineNum">    1237 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1238 </span>            :                 printf(&quot;end = %d\n&quot;, *end);
<span class="lineNum">    1239 </span>            : #endif
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :                 // now, found the range. check whether there is exact match
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                 if (currencyNames[*begin].currencyNameLen == indexInCurrencyNames + 1) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                     return *begin;  // find range and exact match.</span>
<span class="lineNum">    1244 </span>            :                 }
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                 return -1;  // find range, but no exact match.</span>
<span class="lineNum">    1246 </span>            :            }
<span class="lineNum">    1247 </span>            :        }
<span class="lineNum">    1248 </span>            :    }
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :    *begin = -1;</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :    *end = -1;</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :    return -1;    // failed to find range.</span>
<span class="lineNum">    1252 </span>            : }
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            : // Linear search &quot;text&quot; in &quot;currencyNames&quot;.
<span class="lineNum">    1256 </span>            : // @param  begin, end: the begin and end index in currencyNames, within which
<span class="lineNum">    1257 </span>            : //         range should the search be performed.
<span class="lineNum">    1258 </span>            : // @param  textLen: the length of the text to be compared
<span class="lineNum">    1259 </span>            : // @param  maxMatchLen(IN/OUT): passing in the computed max matching length
<span class="lineNum">    1260 </span>            : //                              pass out the new max  matching length
<span class="lineNum">    1261 </span>            : // @param  maxMatchIndex: the index in currencyName which has the longest
<a name="1262"><span class="lineNum">    1262 </span>            : //                        match with input text.</a>
<span class="lineNum">    1263 </span>            : static void
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 : linearSearch(const CurrencyNameStruct* currencyNames, </span>
<span class="lineNum">    1265 </span>            :              int32_t begin, int32_t end,
<span class="lineNum">    1266 </span>            :              const UChar* text, int32_t textLen,
<span class="lineNum">    1267 </span>            :              int32_t *maxMatchLen, int32_t* maxMatchIndex) {
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     for (int32_t index = begin; index &lt;= end; ++index) {</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :         int32_t len = currencyNames[index].currencyNameLen;</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :         if (len &gt; *maxMatchLen &amp;&amp; len &lt;= textLen &amp;&amp;</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :             uprv_memcmp(currencyNames[index].currencyName, text, len * sizeof(UChar)) == 0) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             *maxMatchIndex = index;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :             *maxMatchLen = len;</span>
<span class="lineNum">    1274 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1275 </span>            :             printf(&quot;maxMatchIndex = %d, maxMatchLen = %d\n&quot;,
<span class="lineNum">    1276 </span>            :                    *maxMatchIndex, *maxMatchLen);
<span class="lineNum">    1277 </span>            : #endif
<span class="lineNum">    1278 </span>            :         }
<span class="lineNum">    1279 </span>            :     }
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span>            : #define LINEAR_SEARCH_THRESHOLD 10
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            : // Find longest match between &quot;text&quot; and currency names in &quot;currencyNames&quot;.
<span class="lineNum">    1285 </span>            : // @param  total_currency_count: total number of currency names in CurrencyNames.
<span class="lineNum">    1286 </span>            : // @param  textLen: the length of the text to be compared
<span class="lineNum">    1287 </span>            : // @param  maxMatchLen: passing in the computed max matching length
<span class="lineNum">    1288 </span>            : //                              pass out the new max  matching length
<span class="lineNum">    1289 </span>            : // @param  maxMatchIndex: the index in currencyName which has the longest
<a name="1290"><span class="lineNum">    1290 </span>            : //                        match with input text.</a>
<span class="lineNum">    1291 </span>            : static void
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 : searchCurrencyName(const CurrencyNameStruct* currencyNames, </span>
<span class="lineNum">    1293 </span>            :                    int32_t total_currency_count,
<span class="lineNum">    1294 </span>            :                    const UChar* text, int32_t textLen, 
<span class="lineNum">    1295 </span>            :                    int32_t* maxMatchLen, int32_t* maxMatchIndex) {
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     *maxMatchIndex = -1;</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     *maxMatchLen = 0;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     int32_t matchIndex = -1;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     int32_t binarySearchBegin = 0;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     int32_t binarySearchEnd = total_currency_count - 1;</span>
<span class="lineNum">    1301 </span>            :     // It is a variant of binary search.
<span class="lineNum">    1302 </span>            :     // For example, given the currency names in currencyNames array are:
<span class="lineNum">    1303 </span>            :     // A AB ABC AD AZ B BB BBEX BBEXYZ BS C D E....
<span class="lineNum">    1304 </span>            :     // and the input text is BBEXST
<span class="lineNum">    1305 </span>            :     // The first round binary search search &quot;B&quot; in the text against
<span class="lineNum">    1306 </span>            :     // the first char in currency names, and find the first char matching range
<span class="lineNum">    1307 </span>            :     // to be &quot;B BB BBEX BBEXYZ BS&quot; (and the maximum matching &quot;B&quot;).
<span class="lineNum">    1308 </span>            :     // The 2nd round binary search search the second &quot;B&quot; in the text against
<span class="lineNum">    1309 </span>            :     // the 2nd char in currency names, and narrow the matching range to
<span class="lineNum">    1310 </span>            :     // &quot;BB BBEX BBEXYZ&quot; (and the maximum matching &quot;BB&quot;).
<span class="lineNum">    1311 </span>            :     // The 3rd round returnes the range as &quot;BBEX BBEXYZ&quot; (without changing
<span class="lineNum">    1312 </span>            :     // maximum matching).
<span class="lineNum">    1313 </span>            :     // The 4th round returns the same range (the maximum matching is &quot;BBEX&quot;).
<span class="lineNum">    1314 </span>            :     // The 5th round returns no matching range.
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     for (int32_t index = 0; index &lt; textLen; ++index) {</span>
<span class="lineNum">    1316 </span>            :         // matchIndex saves the one with exact match till the current point.
<span class="lineNum">    1317 </span>            :         // [binarySearchBegin, binarySearchEnd] saves the matching range.
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         matchIndex = binarySearch(currencyNames, index,</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                                   text[index],</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                                   &amp;binarySearchBegin, &amp;binarySearchEnd);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         if (binarySearchBegin == -1) { // did not find the range</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1323 </span>            :         }
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         if (matchIndex != -1) { </span>
<span class="lineNum">    1325 </span>            :             // find an exact match for text from text[0] to text[index] 
<span class="lineNum">    1326 </span>            :             // in currencyNames array.
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :             *maxMatchLen = index + 1;</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             *maxMatchIndex = matchIndex;</span>
<span class="lineNum">    1329 </span>            :         }
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :         if (binarySearchEnd - binarySearchBegin &lt; LINEAR_SEARCH_THRESHOLD) {</span>
<span class="lineNum">    1331 </span>            :             // linear search if within threshold.
<span class="lineNum">    1332 </span>            :             linearSearch(currencyNames, binarySearchBegin, binarySearchEnd,
<span class="lineNum">    1333 </span>            :                          text, textLen,
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                          maxMatchLen, maxMatchIndex);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1336 </span>            :         }
<span class="lineNum">    1337 </span>            :     }
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1339 </span>            : }
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : //========================= currency name cache =====================
<span class="lineNum">    1342 </span>            : typedef struct {
<span class="lineNum">    1343 </span>            :     char locale[ULOC_FULLNAME_CAPACITY];  //key
<span class="lineNum">    1344 </span>            :     // currency names, case insensitive
<span class="lineNum">    1345 </span>            :     CurrencyNameStruct* currencyNames;  // value
<span class="lineNum">    1346 </span>            :     int32_t totalCurrencyNameCount;  // currency name count
<span class="lineNum">    1347 </span>            :     // currency symbols and ISO code, case sensitive
<span class="lineNum">    1348 </span>            :     CurrencyNameStruct* currencySymbols; // value
<span class="lineNum">    1349 </span>            :     int32_t totalCurrencySymbolCount;  // count
<span class="lineNum">    1350 </span>            :     // reference count.
<span class="lineNum">    1351 </span>            :     // reference count is set to 1 when an entry is put to cache.
<span class="lineNum">    1352 </span>            :     // it increases by 1 before accessing, and decreased by 1 after accessing.
<span class="lineNum">    1353 </span>            :     // The entry is deleted when ref count is zero, which means 
<span class="lineNum">    1354 </span>            :     // the entry is replaced out of cache and no process is accessing it.
<span class="lineNum">    1355 </span>            :     int32_t refCount;
<span class="lineNum">    1356 </span>            : } CurrencyNameCacheEntry;
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : #define CURRENCY_NAME_CACHE_NUM 10
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            : // Reserve 10 cache entries.
<span class="lineNum">    1362 </span>            : static CurrencyNameCacheEntry* currCache[CURRENCY_NAME_CACHE_NUM] = {NULL};
<span class="lineNum">    1363 </span>            : // Using an index to indicate which entry to be replaced when cache is full.
<span class="lineNum">    1364 </span>            : // It is a simple round-robin replacement strategy.
<span class="lineNum">    1365 </span>            : static int8_t currentCacheEntryIndex = 0;
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span>            : static UMutex gCurrencyCacheMutex = U_MUTEX_INITIALIZER;
<span class="lineNum">    1368 </span>            : 
<a name="1369"><span class="lineNum">    1369 </span>            : // Cache deletion</a>
<span class="lineNum">    1370 </span>            : static void
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 : deleteCurrencyNames(CurrencyNameStruct* currencyNames, int32_t count) {</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     for (int32_t index = 0; index &lt; count; ++index) {</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :         if ( (currencyNames[index].flag &amp; NEED_TO_BE_DELETED) ) {</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :             uprv_free(currencyNames[index].currencyName);</span>
<span class="lineNum">    1375 </span>            :         }
<span class="lineNum">    1376 </span>            :     }
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     uprv_free(currencyNames);</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1379 </span>            : 
<a name="1380"><span class="lineNum">    1380 </span>            : </a>
<span class="lineNum">    1381 </span>            : static void
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 : deleteCacheEntry(CurrencyNameCacheEntry* entry) {</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     deleteCurrencyNames(entry-&gt;currencyNames, entry-&gt;totalCurrencyNameCount);</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     deleteCurrencyNames(entry-&gt;currencySymbols, entry-&gt;totalCurrencySymbolCount);</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     uprv_free(entry);</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            : 
<a name="1389"><span class="lineNum">    1389 </span>            : // Cache clean up</a>
<span class="lineNum">    1390 </span>            : static UBool U_CALLCONV
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 : currency_cache_cleanup(void) {</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :     for (int32_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :         if (currCache[i]) {</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :             deleteCacheEntry(currCache[i]);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :             currCache[i] = 0;</span>
<span class="lineNum">    1396 </span>            :         }
<span class="lineNum">    1397 </span>            :     }
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1399 </span>            : }
<span class="lineNum">    1400 </span>            : 
<a name="1401"><span class="lineNum">    1401 </span>            : </a>
<span class="lineNum">    1402 </span>            : U_CAPI void
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 : uprv_parseCurrency(const char* locale,</span>
<span class="lineNum">    1404 </span>            :                    const icu::UnicodeString&amp; text,
<span class="lineNum">    1405 </span>            :                    icu::ParsePosition&amp; pos,
<span class="lineNum">    1406 </span>            :                    int8_t type,
<span class="lineNum">    1407 </span>            :                    UChar* result,
<span class="lineNum">    1408 </span>            :                    UErrorCode&amp; ec)
<span class="lineNum">    1409 </span>            : {
<span class="lineNum">    1410 </span>            :     U_NAMESPACE_USE
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     if (U_FAILURE(ec)) {</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1414 </span>            :     }
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     int32_t total_currency_name_count = 0;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     CurrencyNameStruct* currencyNames = NULL;</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :     int32_t total_currency_symbol_count = 0;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     CurrencyNameStruct* currencySymbols = NULL;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     CurrencyNameCacheEntry* cacheEntry = NULL;</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     umtx_lock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1423 </span>            :     // in order to handle racing correctly,
<span class="lineNum">    1424 </span>            :     // not putting 'search' in a separate function.
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     int8_t  found = -1;</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :     for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :         if (currCache[i]!= NULL &amp;&amp;</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :             uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :             found = i;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1431 </span>            :         }
<span class="lineNum">    1432 </span>            :     }
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     if (found != -1) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         cacheEntry = currCache[found];</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :         currencyNames = cacheEntry-&gt;currencyNames;</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :         total_currency_name_count = cacheEntry-&gt;totalCurrencyNameCount;</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         currencySymbols = cacheEntry-&gt;currencySymbols;</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :         total_currency_symbol_count = cacheEntry-&gt;totalCurrencySymbolCount;</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :         ++(cacheEntry-&gt;refCount);</span>
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     umtx_unlock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     if (found == -1) {</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :         collectCurrencyNames(locale, &amp;currencyNames, &amp;total_currency_name_count, &amp;currencySymbols, &amp;total_currency_symbol_count, ec);</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :         if (U_FAILURE(ec)) {</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1446 </span>            :         }
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :         umtx_lock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1448 </span>            :         // check again.
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :         int8_t  found = -1;</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :         for (int8_t i = 0; i &lt; CURRENCY_NAME_CACHE_NUM; ++i) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :             if (currCache[i]!= NULL &amp;&amp;</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                 uprv_strcmp(locale, currCache[i]-&gt;locale) == 0) {</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                 found = i;</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1455 </span>            :             }
<span class="lineNum">    1456 </span>            :         }
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :         if (found == -1) {</span>
<span class="lineNum">    1458 </span>            :             // insert new entry to 
<span class="lineNum">    1459 </span>            :             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
<span class="lineNum">    1460 </span>            :             // and remove the existing entry 
<span class="lineNum">    1461 </span>            :             // currentCacheEntryIndex % CURRENCY_NAME_CACHE_NUM
<span class="lineNum">    1462 </span>            :             // from cache.
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :             cacheEntry = currCache[currentCacheEntryIndex];</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :             if (cacheEntry) {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                 --(cacheEntry-&gt;refCount);</span>
<span class="lineNum">    1466 </span>            :                 // delete if the ref count is zero
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :                 if (cacheEntry-&gt;refCount == 0) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                     deleteCacheEntry(cacheEntry);</span>
<span class="lineNum">    1469 </span>            :                 }
<span class="lineNum">    1470 </span>            :             }
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :             cacheEntry = (CurrencyNameCacheEntry*)uprv_malloc(sizeof(CurrencyNameCacheEntry));</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :             currCache[currentCacheEntryIndex] = cacheEntry;</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :             uprv_strcpy(cacheEntry-&gt;locale, locale);</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :             cacheEntry-&gt;currencyNames = currencyNames;</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :             cacheEntry-&gt;totalCurrencyNameCount = total_currency_name_count;</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :             cacheEntry-&gt;currencySymbols = currencySymbols;</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :             cacheEntry-&gt;totalCurrencySymbolCount = total_currency_symbol_count;</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :             cacheEntry-&gt;refCount = 2; // one for cache, one for reference</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :             currentCacheEntryIndex = (currentCacheEntryIndex + 1) % CURRENCY_NAME_CACHE_NUM;</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :             ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cache_cleanup);</span>
<span class="lineNum">    1481 </span>            :         } else {
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :             deleteCurrencyNames(currencyNames, total_currency_name_count);</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             deleteCurrencyNames(currencySymbols, total_currency_symbol_count);</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :             cacheEntry = currCache[found];</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :             currencyNames = cacheEntry-&gt;currencyNames;</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :             total_currency_name_count = cacheEntry-&gt;totalCurrencyNameCount;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :             currencySymbols = cacheEntry-&gt;currencySymbols;</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :             total_currency_symbol_count = cacheEntry-&gt;totalCurrencySymbolCount;</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :             ++(cacheEntry-&gt;refCount);</span>
<span class="lineNum">    1490 </span>            :         }
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :         umtx_unlock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1492 </span>            :     }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :     int32_t start = pos.getIndex();</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :     UChar inputText[MAX_CURRENCY_NAME_LEN];  
<span class="lineNum">    1497 </span>            :     UChar upperText[MAX_CURRENCY_NAME_LEN];  
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     int32_t textLen = MIN(MAX_CURRENCY_NAME_LEN, text.length() - start);</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :     text.extract(start, textLen, inputText);</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :     UErrorCode ec1 = U_ZERO_ERROR;</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :     textLen = u_strToUpper(upperText, MAX_CURRENCY_NAME_LEN, inputText, textLen, locale, &amp;ec1);</span>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :     int32_t max = 0;</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     int32_t matchIndex = -1;</span>
<span class="lineNum">    1505 </span>            :     // case in-sensitive comparision against currency names
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :     searchCurrencyName(currencyNames, total_currency_name_count, </span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :                        upperText, textLen, &amp;max, &amp;matchIndex);</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1510 </span>            :     printf(&quot;search in names, max = %d, matchIndex = %d\n&quot;, max, matchIndex);
<span class="lineNum">    1511 </span>            : #endif
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     int32_t maxInSymbol = 0;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     int32_t matchIndexInSymbol = -1;</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     if (type != UCURR_LONG_NAME) {  // not name only</span>
<span class="lineNum">    1516 </span>            :         // case sensitive comparison against currency symbols and ISO code.
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :         searchCurrencyName(currencySymbols, total_currency_symbol_count, </span>
<span class="lineNum">    1518 </span>            :                            inputText, textLen, 
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :                            &amp;maxInSymbol, &amp;matchIndexInSymbol);</span>
<span class="lineNum">    1520 </span>            :     }
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span>            : #ifdef UCURR_DEBUG
<span class="lineNum">    1523 </span>            :     printf(&quot;search in symbols, maxInSymbol = %d, matchIndexInSymbol = %d\n&quot;, maxInSymbol, matchIndexInSymbol);
<span class="lineNum">    1524 </span>            :     if(matchIndexInSymbol != -1) {
<span class="lineNum">    1525 </span>            :       printf(&quot;== ISO=%s\n&quot;, currencySymbols[matchIndexInSymbol].IsoCode);
<span class="lineNum">    1526 </span>            :     }
<span class="lineNum">    1527 </span>            : #endif
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :     if (max &gt;= maxInSymbol &amp;&amp; matchIndex != -1) {</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :         u_charsToUChars(currencyNames[matchIndex].IsoCode, result, 4);</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         pos.setIndex(start + max);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     } else if (maxInSymbol &gt;= max &amp;&amp; matchIndexInSymbol != -1) {</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :         u_charsToUChars(currencySymbols[matchIndexInSymbol].IsoCode, result, 4);</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :         pos.setIndex(start + maxInSymbol);</span>
<span class="lineNum">    1535 </span>            :     } 
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span>            :     // decrease reference count
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     umtx_lock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     --(cacheEntry-&gt;refCount);</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     if (cacheEntry-&gt;refCount == 0) {  // remove </span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :         deleteCacheEntry(cacheEntry);</span>
<span class="lineNum">    1542 </span>            :     }
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     umtx_unlock(&amp;gCurrencyCacheMutex);</span>
<span class="lineNum">    1544 </span>            : }
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : /**
<span class="lineNum">    1548 </span>            :  * Internal method.  Given a currency ISO code and a locale, return
<span class="lineNum">    1549 </span>            :  * the &quot;static&quot; currency name.  This is usually the same as the
<span class="lineNum">    1550 </span>            :  * UCURR_SYMBOL_NAME, but if the latter is a choice format, then the
<span class="lineNum">    1551 </span>            :  * format is applied to the number 2.0 (to yield the more common
<span class="lineNum">    1552 </span>            :  * plural) to return a static name.
<span class="lineNum">    1553 </span>            :  *
<span class="lineNum">    1554 </span>            :  * This is used for backward compatibility with old currency logic in
<span class="lineNum">    1555 </span>            :  * DecimalFormat and DecimalFormatSymbols.
<a name="1556"><span class="lineNum">    1556 </span>            :  */</a>
<span class="lineNum">    1557 </span>            : U_CAPI void
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 : uprv_getStaticCurrencyName(const UChar* iso, const char* loc,</span>
<span class="lineNum">    1559 </span>            :                            icu::UnicodeString&amp; result, UErrorCode&amp; ec)
<span class="lineNum">    1560 </span>            : {
<span class="lineNum">    1561 </span>            :     U_NAMESPACE_USE
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :     UBool isChoiceFormat;
<span class="lineNum">    1564 </span>            :     int32_t len;
<span class="lineNum">    1565 </span>            :     const UChar* currname = ucurr_getName(iso, loc, UCURR_SYMBOL_NAME,
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :                                           &amp;isChoiceFormat, &amp;len, &amp;ec);</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(ec)) {</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :         result.setTo(currname, len);</span>
<span class="lineNum">    1569 </span>            :     }
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 : }</span>
<a name="1571"><span class="lineNum">    1571 </span>            : </a>
<span class="lineNum">    1572 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 : ucurr_getDefaultFractionDigits(const UChar* currency, UErrorCode* ec) {</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     return ucurr_getDefaultFractionDigitsForUsage(currency,UCURR_USAGE_STANDARD,ec);</span>
<span class="lineNum">    1575 </span>            : }
<a name="1576"><span class="lineNum">    1576 </span>            : </a>
<span class="lineNum">    1577 </span>            : U_DRAFT int32_t U_EXPORT2
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 : ucurr_getDefaultFractionDigitsForUsage(const UChar* currency, const UCurrencyUsage usage, UErrorCode* ec) {</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :     int32_t fracDigits = 0;</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(*ec)) {</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :         switch (usage) {</span>
<span class="lineNum">    1582 </span>            :             case UCURR_USAGE_STANDARD:
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :                 fracDigits = (_findMetaData(currency, *ec))[0];</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1585 </span>            :             case UCURR_USAGE_CASH:
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                 fracDigits = (_findMetaData(currency, *ec))[2];</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1588 </span>            :             default:
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :                 *ec = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">    1590 </span>            :         }
<span class="lineNum">    1591 </span>            :     }
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     return fracDigits;</span>
<span class="lineNum">    1593 </span>            : }
<a name="1594"><span class="lineNum">    1594 </span>            : </a>
<span class="lineNum">    1595 </span>            : U_CAPI double U_EXPORT2
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 : ucurr_getRoundingIncrement(const UChar* currency, UErrorCode* ec) {</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     return ucurr_getRoundingIncrementForUsage(currency, UCURR_USAGE_STANDARD, ec);</span>
<span class="lineNum">    1598 </span>            : }
<a name="1599"><span class="lineNum">    1599 </span>            : </a>
<span class="lineNum">    1600 </span>            : U_DRAFT double U_EXPORT2
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 : ucurr_getRoundingIncrementForUsage(const UChar* currency, const UCurrencyUsage usage, UErrorCode* ec) {</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :     double result = 0.0;</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :     const int32_t *data = _findMetaData(currency, *ec);</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(*ec)) {</span>
<span class="lineNum">    1606 </span>            :         int32_t fracDigits;
<span class="lineNum">    1607 </span>            :         int32_t increment;
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :         switch (usage) {</span>
<span class="lineNum">    1609 </span>            :             case UCURR_USAGE_STANDARD:
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :                 fracDigits = data[0];</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :                 increment = data[1];</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1613 </span>            :             case UCURR_USAGE_CASH:
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                 fracDigits = data[2];</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                 increment = data[3];</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1617 </span>            :             default:
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :                 *ec = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                 return result;</span>
<span class="lineNum">    1620 </span>            :         }
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :         // If the meta data is invalid, return 0.0
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :         if (fracDigits &lt; 0 || fracDigits &gt; MAX_POW10) {</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :             *ec = U_INVALID_FORMAT_ERROR;</span>
<span class="lineNum">    1625 </span>            :         } else {
<span class="lineNum">    1626 </span>            :             // A rounding value of 0 or 1 indicates no rounding.
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :             if (increment &gt;= 2) {</span>
<span class="lineNum">    1628 </span>            :                 // Return (increment) / 10^(fracDigits).  The only actual rounding data,
<span class="lineNum">    1629 </span>            :                 // as of this writing, is CHF { 2, 5 }.
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :                 result = double(increment) / POW10[fracDigits];</span>
<span class="lineNum">    1631 </span>            :             }
<span class="lineNum">    1632 </span>            :         }
<span class="lineNum">    1633 </span>            :     }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1636 </span>            : }
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : U_CDECL_BEGIN
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            : typedef struct UCurrencyContext {
<span class="lineNum">    1641 </span>            :     uint32_t currType; /* UCurrCurrencyType */
<span class="lineNum">    1642 </span>            :     uint32_t listIdx;
<span class="lineNum">    1643 </span>            : } UCurrencyContext;
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            : /*
<span class="lineNum">    1646 </span>            : Please keep this list in alphabetical order.
<span class="lineNum">    1647 </span>            : You can look at the CLDR supplemental data or ISO-4217 for the meaning of some
<span class="lineNum">    1648 </span>            : of these items.
<span class="lineNum">    1649 </span>            : ISO-4217: http://www.iso.org/iso/en/prods-services/popstds/currencycodeslist.html
<span class="lineNum">    1650 </span>            : */
<span class="lineNum">    1651 </span>            : static const struct CurrencyList {
<span class="lineNum">    1652 </span>            :     const char *currency;
<span class="lineNum">    1653 </span>            :     uint32_t currType;
<span class="lineNum">    1654 </span>            : } gCurrencyList[] = {
<span class="lineNum">    1655 </span>            :     {&quot;ADP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1656 </span>            :     {&quot;AED&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1657 </span>            :     {&quot;AFA&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1658 </span>            :     {&quot;AFN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1659 </span>            :     {&quot;ALK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1660 </span>            :     {&quot;ALL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1661 </span>            :     {&quot;AMD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1662 </span>            :     {&quot;ANG&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1663 </span>            :     {&quot;AOA&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1664 </span>            :     {&quot;AOK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1665 </span>            :     {&quot;AON&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1666 </span>            :     {&quot;AOR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1667 </span>            :     {&quot;ARA&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1668 </span>            :     {&quot;ARL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1669 </span>            :     {&quot;ARM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1670 </span>            :     {&quot;ARP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1671 </span>            :     {&quot;ARS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1672 </span>            :     {&quot;ATS&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1673 </span>            :     {&quot;AUD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1674 </span>            :     {&quot;AWG&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1675 </span>            :     {&quot;AZM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1676 </span>            :     {&quot;AZN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1677 </span>            :     {&quot;BAD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1678 </span>            :     {&quot;BAM&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1679 </span>            :     {&quot;BAN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1680 </span>            :     {&quot;BBD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1681 </span>            :     {&quot;BDT&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1682 </span>            :     {&quot;BEC&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1683 </span>            :     {&quot;BEF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1684 </span>            :     {&quot;BEL&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1685 </span>            :     {&quot;BGL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1686 </span>            :     {&quot;BGM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1687 </span>            :     {&quot;BGN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1688 </span>            :     {&quot;BGO&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1689 </span>            :     {&quot;BHD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1690 </span>            :     {&quot;BIF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1691 </span>            :     {&quot;BMD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1692 </span>            :     {&quot;BND&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1693 </span>            :     {&quot;BOB&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1694 </span>            :     {&quot;BOL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1695 </span>            :     {&quot;BOP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1696 </span>            :     {&quot;BOV&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1697 </span>            :     {&quot;BRB&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1698 </span>            :     {&quot;BRC&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1699 </span>            :     {&quot;BRE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1700 </span>            :     {&quot;BRL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1701 </span>            :     {&quot;BRN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1702 </span>            :     {&quot;BRR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1703 </span>            :     {&quot;BRZ&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1704 </span>            :     {&quot;BSD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1705 </span>            :     {&quot;BTN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1706 </span>            :     {&quot;BUK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1707 </span>            :     {&quot;BWP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1708 </span>            :     {&quot;BYB&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1709 </span>            :     {&quot;BYR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1710 </span>            :     {&quot;BZD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1711 </span>            :     {&quot;CAD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1712 </span>            :     {&quot;CDF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1713 </span>            :     {&quot;CHE&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1714 </span>            :     {&quot;CHF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1715 </span>            :     {&quot;CHW&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1716 </span>            :     {&quot;CLE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1717 </span>            :     {&quot;CLF&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1718 </span>            :     {&quot;CLP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1719 </span>            :     {&quot;CNX&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1720 </span>            :     {&quot;CNY&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1721 </span>            :     {&quot;COP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1722 </span>            :     {&quot;COU&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1723 </span>            :     {&quot;CRC&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1724 </span>            :     {&quot;CSD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1725 </span>            :     {&quot;CSK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1726 </span>            :     {&quot;CUC&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1727 </span>            :     {&quot;CUP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1728 </span>            :     {&quot;CVE&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1729 </span>            :     {&quot;CYP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1730 </span>            :     {&quot;CZK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1731 </span>            :     {&quot;DDM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1732 </span>            :     {&quot;DEM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1733 </span>            :     {&quot;DJF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1734 </span>            :     {&quot;DKK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1735 </span>            :     {&quot;DOP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1736 </span>            :     {&quot;DZD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1737 </span>            :     {&quot;ECS&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1738 </span>            :     {&quot;ECV&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1739 </span>            :     {&quot;EEK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1740 </span>            :     {&quot;EGP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1741 </span>            :     {&quot;EQE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1742 </span>            :     {&quot;ERN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1743 </span>            :     {&quot;ESA&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1744 </span>            :     {&quot;ESB&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1745 </span>            :     {&quot;ESP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1746 </span>            :     {&quot;ETB&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1747 </span>            :     {&quot;EUR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1748 </span>            :     {&quot;FIM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1749 </span>            :     {&quot;FJD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1750 </span>            :     {&quot;FKP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1751 </span>            :     {&quot;FRF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1752 </span>            :     {&quot;GBP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1753 </span>            :     {&quot;GEK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1754 </span>            :     {&quot;GEL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1755 </span>            :     {&quot;GHC&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1756 </span>            :     {&quot;GHS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1757 </span>            :     {&quot;GIP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1758 </span>            :     {&quot;GMD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1759 </span>            :     {&quot;GNF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1760 </span>            :     {&quot;GNS&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1761 </span>            :     {&quot;GQE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1762 </span>            :     {&quot;GRD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1763 </span>            :     {&quot;GTQ&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1764 </span>            :     {&quot;GWE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1765 </span>            :     {&quot;GWP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1766 </span>            :     {&quot;GYD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1767 </span>            :     {&quot;HKD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1768 </span>            :     {&quot;HNL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1769 </span>            :     {&quot;HRD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1770 </span>            :     {&quot;HRK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1771 </span>            :     {&quot;HTG&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1772 </span>            :     {&quot;HUF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1773 </span>            :     {&quot;IDR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1774 </span>            :     {&quot;IEP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1775 </span>            :     {&quot;ILP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1776 </span>            :     {&quot;ILR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1777 </span>            :     {&quot;ILS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1778 </span>            :     {&quot;INR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1779 </span>            :     {&quot;IQD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1780 </span>            :     {&quot;IRR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1781 </span>            :     {&quot;ISJ&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1782 </span>            :     {&quot;ISK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1783 </span>            :     {&quot;ITL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1784 </span>            :     {&quot;JMD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1785 </span>            :     {&quot;JOD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1786 </span>            :     {&quot;JPY&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1787 </span>            :     {&quot;KES&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1788 </span>            :     {&quot;KGS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1789 </span>            :     {&quot;KHR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1790 </span>            :     {&quot;KMF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1791 </span>            :     {&quot;KPW&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1792 </span>            :     {&quot;KRH&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1793 </span>            :     {&quot;KRO&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1794 </span>            :     {&quot;KRW&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1795 </span>            :     {&quot;KWD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1796 </span>            :     {&quot;KYD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1797 </span>            :     {&quot;KZT&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1798 </span>            :     {&quot;LAK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1799 </span>            :     {&quot;LBP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1800 </span>            :     {&quot;LKR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1801 </span>            :     {&quot;LRD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1802 </span>            :     {&quot;LSL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1803 </span>            :     {&quot;LSM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1804 </span>            :     {&quot;LTL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1805 </span>            :     {&quot;LTT&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1806 </span>            :     {&quot;LUC&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1807 </span>            :     {&quot;LUF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1808 </span>            :     {&quot;LUL&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1809 </span>            :     {&quot;LVL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1810 </span>            :     {&quot;LVR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1811 </span>            :     {&quot;LYD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1812 </span>            :     {&quot;MAD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1813 </span>            :     {&quot;MAF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1814 </span>            :     {&quot;MCF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1815 </span>            :     {&quot;MDC&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1816 </span>            :     {&quot;MDL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1817 </span>            :     {&quot;MGA&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1818 </span>            :     {&quot;MGF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1819 </span>            :     {&quot;MKD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1820 </span>            :     {&quot;MKN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1821 </span>            :     {&quot;MLF&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1822 </span>            :     {&quot;MMK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1823 </span>            :     {&quot;MNT&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1824 </span>            :     {&quot;MOP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1825 </span>            :     {&quot;MRO&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1826 </span>            :     {&quot;MTL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1827 </span>            :     {&quot;MTP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1828 </span>            :     {&quot;MUR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1829 </span>            :     {&quot;MVP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1830 </span>            :     {&quot;MVR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1831 </span>            :     {&quot;MWK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1832 </span>            :     {&quot;MXN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1833 </span>            :     {&quot;MXP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1834 </span>            :     {&quot;MXV&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1835 </span>            :     {&quot;MYR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1836 </span>            :     {&quot;MZE&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1837 </span>            :     {&quot;MZM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1838 </span>            :     {&quot;MZN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1839 </span>            :     {&quot;NAD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1840 </span>            :     {&quot;NGN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1841 </span>            :     {&quot;NIC&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1842 </span>            :     {&quot;NIO&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1843 </span>            :     {&quot;NLG&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1844 </span>            :     {&quot;NOK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1845 </span>            :     {&quot;NPR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1846 </span>            :     {&quot;NZD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1847 </span>            :     {&quot;OMR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1848 </span>            :     {&quot;PAB&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1849 </span>            :     {&quot;PEI&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1850 </span>            :     {&quot;PEN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1851 </span>            :     {&quot;PES&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1852 </span>            :     {&quot;PGK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1853 </span>            :     {&quot;PHP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1854 </span>            :     {&quot;PKR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1855 </span>            :     {&quot;PLN&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1856 </span>            :     {&quot;PLZ&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1857 </span>            :     {&quot;PTE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1858 </span>            :     {&quot;PYG&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1859 </span>            :     {&quot;QAR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1860 </span>            :     {&quot;RHD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1861 </span>            :     {&quot;ROL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1862 </span>            :     {&quot;RON&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1863 </span>            :     {&quot;RSD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1864 </span>            :     {&quot;RUB&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1865 </span>            :     {&quot;RUR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1866 </span>            :     {&quot;RWF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1867 </span>            :     {&quot;SAR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1868 </span>            :     {&quot;SBD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1869 </span>            :     {&quot;SCR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1870 </span>            :     {&quot;SDD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1871 </span>            :     {&quot;SDG&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1872 </span>            :     {&quot;SDP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1873 </span>            :     {&quot;SEK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1874 </span>            :     {&quot;SGD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1875 </span>            :     {&quot;SHP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1876 </span>            :     {&quot;SIT&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1877 </span>            :     {&quot;SKK&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1878 </span>            :     {&quot;SLL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1879 </span>            :     {&quot;SOS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1880 </span>            :     {&quot;SRD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1881 </span>            :     {&quot;SRG&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1882 </span>            :     {&quot;SSP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1883 </span>            :     {&quot;STD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1884 </span>            :     {&quot;SUR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1885 </span>            :     {&quot;SVC&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1886 </span>            :     {&quot;SYP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1887 </span>            :     {&quot;SZL&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1888 </span>            :     {&quot;THB&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1889 </span>            :     {&quot;TJR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1890 </span>            :     {&quot;TJS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1891 </span>            :     {&quot;TMM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1892 </span>            :     {&quot;TMT&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1893 </span>            :     {&quot;TND&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1894 </span>            :     {&quot;TOP&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1895 </span>            :     {&quot;TPE&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1896 </span>            :     {&quot;TRL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1897 </span>            :     {&quot;TRY&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1898 </span>            :     {&quot;TTD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1899 </span>            :     {&quot;TWD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1900 </span>            :     {&quot;TZS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1901 </span>            :     {&quot;UAH&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1902 </span>            :     {&quot;UAK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1903 </span>            :     {&quot;UGS&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1904 </span>            :     {&quot;UGX&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1905 </span>            :     {&quot;USD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1906 </span>            :     {&quot;USN&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1907 </span>            :     {&quot;USS&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1908 </span>            :     {&quot;UYI&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1909 </span>            :     {&quot;UYP&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1910 </span>            :     {&quot;UYU&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1911 </span>            :     {&quot;UZS&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1912 </span>            :     {&quot;VEB&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1913 </span>            :     {&quot;VEF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1914 </span>            :     {&quot;VND&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1915 </span>            :     {&quot;VNN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1916 </span>            :     {&quot;VUV&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1917 </span>            :     {&quot;WST&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1918 </span>            :     {&quot;XAF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1919 </span>            :     {&quot;XAG&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1920 </span>            :     {&quot;XAU&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1921 </span>            :     {&quot;XBA&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1922 </span>            :     {&quot;XBB&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1923 </span>            :     {&quot;XBC&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1924 </span>            :     {&quot;XBD&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1925 </span>            :     {&quot;XCD&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1926 </span>            :     {&quot;XDR&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1927 </span>            :     {&quot;XEU&quot;, UCURR_UNCOMMON|UCURR_DEPRECATED},
<span class="lineNum">    1928 </span>            :     {&quot;XFO&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1929 </span>            :     {&quot;XFU&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1930 </span>            :     {&quot;XOF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1931 </span>            :     {&quot;XPD&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1932 </span>            :     {&quot;XPF&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1933 </span>            :     {&quot;XPT&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1934 </span>            :     {&quot;XRE&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1935 </span>            :     {&quot;XSU&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1936 </span>            :     {&quot;XTS&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1937 </span>            :     {&quot;XUA&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1938 </span>            :     {&quot;XXX&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1939 </span>            :     {&quot;YDD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1940 </span>            :     {&quot;YER&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1941 </span>            :     {&quot;YUD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1942 </span>            :     {&quot;YUM&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1943 </span>            :     {&quot;YUN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1944 </span>            :     {&quot;YUR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1945 </span>            :     {&quot;ZAL&quot;, UCURR_UNCOMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1946 </span>            :     {&quot;ZAR&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1947 </span>            :     {&quot;ZMK&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1948 </span>            :     {&quot;ZMW&quot;, UCURR_COMMON|UCURR_NON_DEPRECATED},
<span class="lineNum">    1949 </span>            :     {&quot;ZRN&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1950 </span>            :     {&quot;ZRZ&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1951 </span>            :     {&quot;ZWL&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1952 </span>            :     {&quot;ZWR&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1953 </span>            :     {&quot;ZWD&quot;, UCURR_COMMON|UCURR_DEPRECATED},
<span class="lineNum">    1954 </span>            :     { NULL, 0 } // Leave here to denote the end of the list.
<span class="lineNum">    1955 </span>            : };
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            : #define UCURR_MATCHES_BITMASK(variable, typeToMatch) \
<span class="lineNum">    1958 </span>            :     ((typeToMatch) == UCURR_ALL || ((variable) &amp; (typeToMatch)) == (typeToMatch))
<a name="1959"><span class="lineNum">    1959 </span>            : </a>
<span class="lineNum">    1960 </span>            : static int32_t U_CALLCONV
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 : ucurr_countCurrencyList(UEnumeration *enumerator, UErrorCode * /*pErrorCode*/) {</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :     UCurrencyContext *myContext = (UCurrencyContext *)(enumerator-&gt;context);</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :     uint32_t currType = myContext-&gt;currType;</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     int32_t count = 0;</span>
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            :     /* Count the number of items matching the type we are looking for. */
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     for (int32_t idx = 0; gCurrencyList[idx].currency != NULL; idx++) {</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         if (UCURR_MATCHES_BITMASK(gCurrencyList[idx].currType, currType)) {</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :             count++;</span>
<span class="lineNum">    1970 </span>            :         }
<span class="lineNum">    1971 </span>            :     }
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     return count;</span>
<span class="lineNum">    1973 </span>            : }
<a name="1974"><span class="lineNum">    1974 </span>            : </a>
<span class="lineNum">    1975 </span>            : static const char* U_CALLCONV
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 : ucurr_nextCurrencyList(UEnumeration *enumerator,</span>
<span class="lineNum">    1977 </span>            :                         int32_t* resultLength,
<span class="lineNum">    1978 </span>            :                         UErrorCode * /*pErrorCode*/)
<span class="lineNum">    1979 </span>            : {
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     UCurrencyContext *myContext = (UCurrencyContext *)(enumerator-&gt;context);</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            :     /* Find the next in the list that matches the type we are looking for. */
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :     while (myContext-&gt;listIdx &lt; UPRV_LENGTHOF(gCurrencyList)-1) {</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         const struct CurrencyList *currItem = &amp;gCurrencyList[myContext-&gt;listIdx++];</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         if (UCURR_MATCHES_BITMASK(currItem-&gt;currType, myContext-&gt;currType))</span>
<span class="lineNum">    1986 </span>            :         {
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :             if (resultLength) {</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :                 *resultLength = 3; /* Currency codes are only 3 chars long */</span>
<span class="lineNum">    1989 </span>            :             }
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :             return currItem-&gt;currency;</span>
<span class="lineNum">    1991 </span>            :         }
<span class="lineNum">    1992 </span>            :     }
<span class="lineNum">    1993 </span>            :     /* We enumerated too far. */
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :     if (resultLength) {</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :         *resultLength = 0;</span>
<span class="lineNum">    1996 </span>            :     }
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1998 </span>            : }
<a name="1999"><span class="lineNum">    1999 </span>            : </a>
<span class="lineNum">    2000 </span>            : static void U_CALLCONV
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 : ucurr_resetCurrencyList(UEnumeration *enumerator, UErrorCode * /*pErrorCode*/) {</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :     ((UCurrencyContext *)(enumerator-&gt;context))-&gt;listIdx = 0;</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 : }</span>
<a name="2004"><span class="lineNum">    2004 </span>            : </a>
<span class="lineNum">    2005 </span>            : static void U_CALLCONV
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 : ucurr_closeCurrencyList(UEnumeration *enumerator) {</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :     uprv_free(enumerator-&gt;context);</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     uprv_free(enumerator);</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 : }</span>
<a name="2010"><span class="lineNum">    2010 </span>            : </a>
<span class="lineNum">    2011 </span>            : static void U_CALLCONV
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 : ucurr_createCurrencyList(UHashtable *isoCodes, UErrorCode* status){</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :     UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span>            :     // Look up the CurrencyMap element in the root bundle.
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     UResourceBundle *currencyMapArray = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(localStatus)) {</span>
<span class="lineNum">    2020 </span>            :         // process each entry in currency map 
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :         for (int32_t i=0; i&lt;ures_getSize(currencyMapArray); i++) {</span>
<span class="lineNum">    2022 </span>            :             // get the currency resource
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :             UResourceBundle *currencyArray = ures_getByIndex(currencyMapArray, i, NULL, &amp;localStatus);</span>
<span class="lineNum">    2024 </span>            :             // process each currency 
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :             if (U_SUCCESS(localStatus)) {</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :                 for (int32_t j=0; j&lt;ures_getSize(currencyArray); j++) {</span>
<span class="lineNum">    2027 </span>            :                     // get the currency resource
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :                     UResourceBundle *currencyRes = ures_getByIndex(currencyArray, j, NULL, &amp;localStatus);</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :                     IsoCodeEntry *entry = (IsoCodeEntry*)uprv_malloc(sizeof(IsoCodeEntry));</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :                     if (entry == NULL) {</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :                         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    2033 </span>            :                     }
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span>            :                     // get the ISO code
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :                     int32_t isoLength = 0;</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :                     UResourceBundle *idRes = ures_getByKey(currencyRes, &quot;id&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :                     if (idRes == NULL) {</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2040 </span>            :                     }
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :                     const UChar *isoCode = ures_getString(idRes, &amp;isoLength, &amp;localStatus);</span>
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            :                     // get from date
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :                     UDate fromDate = U_DATE_MIN;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :                     UResourceBundle *fromRes = ures_getByKey(currencyRes, &quot;from&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :                     if (U_SUCCESS(localStatus)) {</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :                         int32_t fromLength = 0;</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :                         const int32_t *fromArray = ures_getIntVector(fromRes, &amp;fromLength, &amp;localStatus);</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :                         int64_t currDate64 = (int64_t)fromArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :                         currDate64 |= ((int64_t)fromArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :                         fromDate = (UDate)currDate64;</span>
<span class="lineNum">    2053 </span>            :                     }
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :                     ures_close(fromRes);</span>
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            :                     // get to date
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :                     UDate toDate = U_DATE_MAX;</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :                     localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :                     UResourceBundle *toRes = ures_getByKey(currencyRes, &quot;to&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :                     if (U_SUCCESS(localStatus)) {</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :                         int32_t toLength = 0;</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :                         const int32_t *toArray = ures_getIntVector(toRes, &amp;toLength, &amp;localStatus);</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :                         int64_t currDate64 = (int64_t)toArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :                         currDate64 |= ((int64_t)toArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :                         toDate = (UDate)currDate64;</span>
<span class="lineNum">    2067 </span>            :                     }
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :                     ures_close(toRes);</span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :                     ures_close(idRes);</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :                     ures_close(currencyRes);</span>
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :                     entry-&gt;isoCode = isoCode;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :                     entry-&gt;from = fromDate;</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :                     entry-&gt;to = toDate;</span>
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :                     localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :                     uhash_put(isoCodes, (UChar *)isoCode, entry, &amp;localStatus);</span>
<span class="lineNum">    2079 </span>            :                 }
<span class="lineNum">    2080 </span>            :             } else {
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                 *status = localStatus;</span>
<span class="lineNum">    2082 </span>            :             }
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :             ures_close(currencyArray);</span>
<span class="lineNum">    2084 </span>            :         }
<span class="lineNum">    2085 </span>            :     } else {
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         *status = localStatus;</span>
<span class="lineNum">    2087 </span>            :     }
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     ures_close(currencyMapArray);</span>
<span class="lineNum">    2090 </span>            : }
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : static const UEnumeration gEnumCurrencyList = {
<span class="lineNum">    2093 </span>            :     NULL,
<span class="lineNum">    2094 </span>            :     NULL,
<span class="lineNum">    2095 </span>            :     ucurr_closeCurrencyList,
<span class="lineNum">    2096 </span>            :     ucurr_countCurrencyList,
<span class="lineNum">    2097 </span>            :     uenum_unextDefault,
<span class="lineNum">    2098 </span>            :     ucurr_nextCurrencyList,
<span class="lineNum">    2099 </span>            :     ucurr_resetCurrencyList
<span class="lineNum">    2100 </span>            : };
<span class="lineNum">    2101 </span>            : U_CDECL_END
<a name="2102"><span class="lineNum">    2102 </span>            : </a>
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 : static void U_CALLCONV initIsoCodes(UErrorCode &amp;status) {</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :     U_ASSERT(gIsoCodes == NULL);</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);</span>
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :     UHashtable *isoCodes = uhash_open(uhash_hashUChars, uhash_compareUChars, NULL, &amp;status);</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2111 </span>            :     }
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :     uhash_setValueDeleter(isoCodes, deleteIsoCodeEntry);</span>
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :     ucurr_createCurrencyList(isoCodes, &amp;status);</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :         uhash_close(isoCodes);</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2118 </span>            :     }
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :     gIsoCodes = isoCodes;  // Note: gIsoCodes is const. Once set up here it is never altered,</span>
<span class="lineNum">    2120 </span>            :                            //       and read only access is safe without synchronization.
<a name="2121"><span class="lineNum">    2121 </span>            : }</a>
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 : static void populateCurrSymbolsEquiv(icu::Hashtable *hash, UErrorCode &amp;status) {</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2126 </span>            :     }
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :     int32_t length = UPRV_LENGTHOF(EQUIV_CURRENCY_SYMBOLS);</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :     for (int32_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :         icu::UnicodeString lhs(EQUIV_CURRENCY_SYMBOLS[i][0], -1, US_INV);</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :         icu::UnicodeString rhs(EQUIV_CURRENCY_SYMBOLS[i][1], -1, US_INV);</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :         makeEquivalent(lhs.unescape(), rhs.unescape(), hash, status);</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :         if (U_FAILURE(status)) {</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2134 </span>            :         }
<span class="lineNum">    2135 </span>            :     }
<a name="2136"><span class="lineNum">    2136 </span>            : }</a>
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 : static void U_CALLCONV initCurrSymbolsEquiv() {</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     U_ASSERT(gCurrSymbolsEquiv == NULL);</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :     icu::Hashtable *temp = new icu::Hashtable(status);</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :     if (temp == NULL) {</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2145 </span>            :     }
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :         delete temp;</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2149 </span>            :     }
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :     temp-&gt;setValueDeleter(deleteUnicode);</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :     populateCurrSymbolsEquiv(temp, status);</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :         delete temp;</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2155 </span>            :     }
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :     gCurrSymbolsEquiv = temp;</span>
<span class="lineNum">    2157 </span>            : }
<a name="2158"><span class="lineNum">    2158 </span>            : </a>
<span class="lineNum">    2159 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 : ucurr_isAvailable(const UChar* isoCode, UDate from, UDate to, UErrorCode* eErrorCode) {</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :     umtx_initOnce(gIsoCodesInitOnce, &amp;initIsoCodes, *eErrorCode);</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :     if (U_FAILURE(*eErrorCode)) {</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2164 </span>            :     }
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :     IsoCodeEntry* result = (IsoCodeEntry *) uhash_get(gIsoCodes, isoCode);</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :     if (result == NULL) {</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :     } else if (from &gt; to) {</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :         *eErrorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :     } else if  ((from &gt; result-&gt;to) || (to &lt; result-&gt;from)) {</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    2174 </span>            :     }
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<a name="2176"><span class="lineNum">    2176 </span>            : }</a>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 : static const icu::Hashtable* getCurrSymbolsEquiv() {</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :     umtx_initOnce(gCurrSymbolsEquivInitOnce, &amp;initCurrSymbolsEquiv);</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :     return gCurrSymbolsEquiv;</span>
<span class="lineNum">    2181 </span>            : }
<a name="2182"><span class="lineNum">    2182 </span>            : </a>
<span class="lineNum">    2183 </span>            : U_CAPI UEnumeration * U_EXPORT2
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 : ucurr_openISOCurrencies(uint32_t currType, UErrorCode *pErrorCode) {</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :     UEnumeration *myEnum = NULL;</span>
<span class="lineNum">    2186 </span>            :     UCurrencyContext *myContext;
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :     myEnum = (UEnumeration*)uprv_malloc(sizeof(UEnumeration));</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :     if (myEnum == NULL) {</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :         *pErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2192 </span>            :     }
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :     uprv_memcpy(myEnum, &amp;gEnumCurrencyList, sizeof(UEnumeration));</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     myContext = (UCurrencyContext*)uprv_malloc(sizeof(UCurrencyContext));</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :     if (myContext == NULL) {</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         *pErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :         uprv_free(myEnum);</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2199 </span>            :     }
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     myContext-&gt;currType = currType;</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     myContext-&gt;listIdx = 0;</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :     myEnum-&gt;context = myContext;</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     return myEnum;</span>
<span class="lineNum">    2204 </span>            : }
<a name="2205"><span class="lineNum">    2205 </span>            : </a>
<span class="lineNum">    2206 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 : ucurr_countCurrencies(const char* locale, </span>
<span class="lineNum">    2208 </span>            :                  UDate date, 
<span class="lineNum">    2209 </span>            :                  UErrorCode* ec)
<span class="lineNum">    2210 </span>            : {
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     int32_t currCount = 0;</span>
<span class="lineNum">    2212 </span>            : 
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :     if (ec != NULL &amp;&amp; U_SUCCESS(*ec)) </span>
<span class="lineNum">    2214 </span>            :     {
<span class="lineNum">    2215 </span>            :         // local variables
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :         UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">    2217 </span>            :         char id[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :         uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);</span>
<span class="lineNum">    2219 </span>            :         // get country or country_variant in `id'
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :         /*uint32_t variantType =*/ idForLocale(locale, id, sizeof(id), ec);</span>
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :         if (U_FAILURE(*ec))</span>
<span class="lineNum">    2223 </span>            :         {
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    2225 </span>            :         }
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span>            :         // Remove variants, which is only needed for registration.
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :         char *idDelim = strchr(id, VAR_DELIM);</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :         if (idDelim)</span>
<span class="lineNum">    2230 </span>            :         {
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :             idDelim[0] = 0;</span>
<span class="lineNum">    2232 </span>            :         }
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span>            :         // Look up the CurrencyMap element in the root bundle.
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :         UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :         UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);</span>
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span>            :         // Using the id derived from the local, get the currency data
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :         UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);</span>
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span>            :         // process each currency to see which one is valid for the given date
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :         if (U_SUCCESS(localStatus))</span>
<span class="lineNum">    2243 </span>            :         {
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :             for (int32_t i=0; i&lt;ures_getSize(countryArray); i++)</span>
<span class="lineNum">    2245 </span>            :             {
<span class="lineNum">    2246 </span>            :                 // get the currency resource
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :                 UResourceBundle *currencyRes = ures_getByIndex(countryArray, i, NULL, &amp;localStatus);</span>
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span>            :                 // get the from date
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :                 int32_t fromLength = 0;</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :                 UResourceBundle *fromRes = ures_getByKey(currencyRes, &quot;from&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :                 const int32_t *fromArray = ures_getIntVector(fromRes, &amp;fromLength, &amp;localStatus);</span>
<span class="lineNum">    2253 </span>            : 
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :                 int64_t currDate64 = (int64_t)fromArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :                 currDate64 |= ((int64_t)fromArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :                 UDate fromDate = (UDate)currDate64;</span>
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                 if (ures_getSize(currencyRes)&gt; 2)</span>
<span class="lineNum">    2259 </span>            :                 {
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :                     int32_t toLength = 0;</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :                     UResourceBundle *toRes = ures_getByKey(currencyRes, &quot;to&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :                     const int32_t *toArray = ures_getIntVector(toRes, &amp;toLength, &amp;localStatus);</span>
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                     currDate64 = (int64_t)toArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                     currDate64 |= ((int64_t)toArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                     UDate toDate = (UDate)currDate64;</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :                     if ((fromDate &lt;= date) &amp;&amp; (date &lt; toDate))</span>
<span class="lineNum">    2269 </span>            :                     {
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :                         currCount++;</span>
<span class="lineNum">    2271 </span>            :                     }
<span class="lineNum">    2272 </span>            : 
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :                     ures_close(toRes);</span>
<span class="lineNum">    2274 </span>            :                 }
<span class="lineNum">    2275 </span>            :                 else
<span class="lineNum">    2276 </span>            :                 {
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :                     if (fromDate &lt;= date)</span>
<span class="lineNum">    2278 </span>            :                     {
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :                         currCount++;</span>
<span class="lineNum">    2280 </span>            :                     }
<span class="lineNum">    2281 </span>            :                 }
<span class="lineNum">    2282 </span>            : 
<span class="lineNum">    2283 </span>            :                 // close open resources
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                 ures_close(currencyRes);</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :                 ures_close(fromRes);</span>
<span class="lineNum">    2286 </span>            : 
<span class="lineNum">    2287 </span>            :             } // end For loop
<span class="lineNum">    2288 </span>            :         } // end if (U_SUCCESS(localStatus))
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         ures_close(countryArray);</span>
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span>            :         // Check for errors
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         if (*ec == U_ZERO_ERROR || localStatus != U_ZERO_ERROR)</span>
<span class="lineNum">    2294 </span>            :         {
<span class="lineNum">    2295 </span>            :             // There is nothing to fallback to. 
<span class="lineNum">    2296 </span>            :             // Report the failure/warning if possible.
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :             *ec = localStatus;</span>
<span class="lineNum">    2298 </span>            :         }
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :         if (U_SUCCESS(*ec))</span>
<span class="lineNum">    2301 </span>            :         {
<span class="lineNum">    2302 </span>            :             // no errors
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :             return currCount;</span>
<span class="lineNum">    2304 </span>            :         }
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            :     }
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span>            :     // If we got here, either error code is invalid or
<span class="lineNum">    2309 </span>            :     // some argument passed is no good.
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    2311 </span>            : }
<a name="2312"><span class="lineNum">    2312 </span>            : </a>
<span class="lineNum">    2313 </span>            : U_CAPI int32_t U_EXPORT2 
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 : ucurr_forLocaleAndDate(const char* locale, </span>
<span class="lineNum">    2315 </span>            :                 UDate date, 
<span class="lineNum">    2316 </span>            :                 int32_t index,
<span class="lineNum">    2317 </span>            :                 UChar* buff, 
<span class="lineNum">    2318 </span>            :                 int32_t buffCapacity, 
<span class="lineNum">    2319 </span>            :                 UErrorCode* ec)
<span class="lineNum">    2320 </span>            : {
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :     int32_t resLen = 0;</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :         int32_t currIndex = 0;</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :     const UChar* s = NULL;</span>
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :     if (ec != NULL &amp;&amp; U_SUCCESS(*ec))</span>
<span class="lineNum">    2326 </span>            :     {
<span class="lineNum">    2327 </span>            :         // check the arguments passed
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :         if ((buff &amp;&amp; buffCapacity) || !buffCapacity )</span>
<span class="lineNum">    2329 </span>            :         {
<span class="lineNum">    2330 </span>            :             // local variables
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :             UErrorCode localStatus = U_ZERO_ERROR;</span>
<span class="lineNum">    2332 </span>            :             char id[ULOC_FULLNAME_CAPACITY];
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :             resLen = uloc_getKeywordValue(locale, &quot;currency&quot;, id, ULOC_FULLNAME_CAPACITY, &amp;localStatus);</span>
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span>            :             // get country or country_variant in `id'
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :             /*uint32_t variantType =*/ idForLocale(locale, id, sizeof(id), ec);</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :             if (U_FAILURE(*ec))</span>
<span class="lineNum">    2338 </span>            :             {
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2340 </span>            :             }
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span>            :             // Remove variants, which is only needed for registration.
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :             char *idDelim = strchr(id, VAR_DELIM);</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :             if (idDelim)</span>
<span class="lineNum">    2345 </span>            :             {
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :                 idDelim[0] = 0;</span>
<span class="lineNum">    2347 </span>            :             }
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            :             // Look up the CurrencyMap element in the root bundle.
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :             UResourceBundle *rb = ures_openDirect(U_ICUDATA_CURR, CURRENCY_DATA, &amp;localStatus);</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :             UResourceBundle *cm = ures_getByKey(rb, CURRENCY_MAP, rb, &amp;localStatus);</span>
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            :             // Using the id derived from the local, get the currency data
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :             UResourceBundle *countryArray = ures_getByKey(rb, id, cm, &amp;localStatus);</span>
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span>            :             // process each currency to see which one is valid for the given date
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :             bool matchFound = false;</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :             if (U_SUCCESS(localStatus))</span>
<span class="lineNum">    2359 </span>            :             {
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :                 if ((index &lt;= 0) || (index&gt; ures_getSize(countryArray)))</span>
<span class="lineNum">    2361 </span>            :                 {
<span class="lineNum">    2362 </span>            :                     // requested index is out of bounds
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :                     ures_close(countryArray);</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :                     return 0;</span>
<span class="lineNum">    2365 </span>            :                 }
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :                 for (int32_t i=0; i&lt;ures_getSize(countryArray); i++)</span>
<span class="lineNum">    2368 </span>            :                 {
<span class="lineNum">    2369 </span>            :                     // get the currency resource
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :                     UResourceBundle *currencyRes = ures_getByIndex(countryArray, i, NULL, &amp;localStatus);</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :                     s = ures_getStringByKey(currencyRes, &quot;id&quot;, &amp;resLen, &amp;localStatus);</span>
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            :                     // get the from date
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :                     int32_t fromLength = 0;</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :                     UResourceBundle *fromRes = ures_getByKey(currencyRes, &quot;from&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :                     const int32_t *fromArray = ures_getIntVector(fromRes, &amp;fromLength, &amp;localStatus);</span>
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :                     int64_t currDate64 = (int64_t)fromArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :                     currDate64 |= ((int64_t)fromArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :                     UDate fromDate = (UDate)currDate64;</span>
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :                     if (ures_getSize(currencyRes)&gt; 2)</span>
<span class="lineNum">    2383 </span>            :                     {
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :                         int32_t toLength = 0;</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :                         UResourceBundle *toRes = ures_getByKey(currencyRes, &quot;to&quot;, NULL, &amp;localStatus);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :                         const int32_t *toArray = ures_getIntVector(toRes, &amp;toLength, &amp;localStatus);</span>
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :                         currDate64 = (int64_t)toArray[0] &lt;&lt; 32;</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :                         currDate64 |= ((int64_t)toArray[1] &amp; (int64_t)INT64_C(0x00000000FFFFFFFF));</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :                         UDate toDate = (UDate)currDate64;</span>
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :                         if ((fromDate &lt;= date) &amp;&amp; (date &lt; toDate))</span>
<span class="lineNum">    2393 </span>            :                         {
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :                             currIndex++;</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :                             if (currIndex == index)</span>
<span class="lineNum">    2396 </span>            :                             {
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :                                 matchFound = true;</span>
<span class="lineNum">    2398 </span>            :                             }
<span class="lineNum">    2399 </span>            :                         }
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :                         ures_close(toRes);</span>
<span class="lineNum">    2402 </span>            :                     }
<span class="lineNum">    2403 </span>            :                     else
<span class="lineNum">    2404 </span>            :                     {
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                         if (fromDate &lt;= date)</span>
<span class="lineNum">    2406 </span>            :                         {
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :                             currIndex++;</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :                             if (currIndex == index)</span>
<span class="lineNum">    2409 </span>            :                             {
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :                                 matchFound = true;</span>
<span class="lineNum">    2411 </span>            :                             }
<span class="lineNum">    2412 </span>            :                         }
<span class="lineNum">    2413 </span>            :                     }
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            :                     // close open resources
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :                     ures_close(currencyRes);</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :                     ures_close(fromRes);</span>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :                     // check for loop exit
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :                     if (matchFound)</span>
<span class="lineNum">    2421 </span>            :                     {
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2423 </span>            :                     }
<span class="lineNum">    2424 </span>            : 
<span class="lineNum">    2425 </span>            :                 } // end For loop
<span class="lineNum">    2426 </span>            :             }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :             ures_close(countryArray);</span>
<span class="lineNum">    2429 </span>            : 
<span class="lineNum">    2430 </span>            :             // Check for errors
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :             if (*ec == U_ZERO_ERROR || localStatus != U_ZERO_ERROR)</span>
<span class="lineNum">    2432 </span>            :             {
<span class="lineNum">    2433 </span>            :                 // There is nothing to fallback to. 
<span class="lineNum">    2434 </span>            :                 // Report the failure/warning if possible.
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :                 *ec = localStatus;</span>
<span class="lineNum">    2436 </span>            :             }
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :             if (U_SUCCESS(*ec))</span>
<span class="lineNum">    2439 </span>            :             {
<span class="lineNum">    2440 </span>            :                 // no errors
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :                 if((buffCapacity&gt; resLen) &amp;&amp; matchFound)</span>
<span class="lineNum">    2442 </span>            :                 {
<span class="lineNum">    2443 </span>            :                     // write out the currency value
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                     u_strcpy(buff, s);</span>
<span class="lineNum">    2445 </span>            :                 }
<span class="lineNum">    2446 </span>            :                 else
<span class="lineNum">    2447 </span>            :                 {
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :                     return 0;</span>
<span class="lineNum">    2449 </span>            :                 }
<span class="lineNum">    2450 </span>            :             }
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span>            :             // return null terminated currency string
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :             return u_terminateUChars(buff, buffCapacity, resLen, ec);</span>
<span class="lineNum">    2454 </span>            :         }
<span class="lineNum">    2455 </span>            :         else
<span class="lineNum">    2456 </span>            :         {
<span class="lineNum">    2457 </span>            :             // illegal argument encountered
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :             *ec = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">    2459 </span>            :         }
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span>            :     }
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span>            :     // If we got here, either error code is invalid or
<span class="lineNum">    2464 </span>            :     // some argument passed is no good.
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :     return resLen;</span>
<span class="lineNum">    2466 </span>            : }
<span class="lineNum">    2467 </span>            : 
<span class="lineNum">    2468 </span>            : static const UEnumeration defaultKeywordValues = {
<span class="lineNum">    2469 </span>            :     NULL,
<span class="lineNum">    2470 </span>            :     NULL,
<span class="lineNum">    2471 </span>            :     ulist_close_keyword_values_iterator,
<span class="lineNum">    2472 </span>            :     ulist_count_keyword_values,
<span class="lineNum">    2473 </span>            :     uenum_unextDefault,
<span class="lineNum">    2474 </span>            :     ulist_next_keyword_value, 
<span class="lineNum">    2475 </span>            :     ulist_reset_keyword_values_iterator
<a name="2476"><span class="lineNum">    2476 </span>            : };</a>
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 : U_CAPI UEnumeration *U_EXPORT2 ucurr_getKeywordValuesForLocale(const char *key, const char *locale, UBool commonlyUsed, UErrorCode* status) {</span>
<span class="lineNum">    2479 </span>            :     // Resolve region
<span class="lineNum">    2480 </span>            :     char prefRegion[ULOC_COUNTRY_CAPACITY];
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     ulocimp_getRegionForSupplementalData(locale, TRUE, prefRegion, sizeof(prefRegion), status);</span>
<span class="lineNum">    2482 </span>            :     
<span class="lineNum">    2483 </span>            :     // Read value from supplementalData
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :     UList *values = ulist_createEmptyList(status);</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :     UList *otherValues = ulist_createEmptyList(status);</span>
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :     UEnumeration *en = (UEnumeration *)uprv_malloc(sizeof(UEnumeration));</span>
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :     if (U_FAILURE(*status) || en == NULL) {</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :         if (en == NULL) {</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    2490 </span>            :         } else {
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :             uprv_free(en);</span>
<span class="lineNum">    2492 </span>            :         }
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :         ulist_deleteList(values);</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :         ulist_deleteList(otherValues);</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2496 </span>            :     }
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :     memcpy(en, &amp;defaultKeywordValues, sizeof(UEnumeration));</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :     en-&gt;context = values;</span>
<span class="lineNum">    2499 </span>            :     
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     UResourceBundle *bundle = ures_openDirect(U_ICUDATA_CURR, &quot;supplementalData&quot;, status);</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :     ures_getByKey(bundle, &quot;CurrencyMap&quot;, bundle, status);</span>
<span class="lineNum">    2502 </span>            :     UResourceBundle bundlekey, regbndl, curbndl, to;
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :     ures_initStackObject(&amp;bundlekey);</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :     ures_initStackObject(&amp;regbndl);</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :     ures_initStackObject(&amp;curbndl);</span>
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :     ures_initStackObject(&amp;to);</span>
<span class="lineNum">    2507 </span>            :     
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :     while (U_SUCCESS(*status) &amp;&amp; ures_hasNext(bundle)) {</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :         ures_getNextResource(bundle, &amp;bundlekey, status);</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :         if (U_FAILURE(*status)) {</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2512 </span>            :         }
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :         const char *region = ures_getKey(&amp;bundlekey);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :         UBool isPrefRegion = uprv_strcmp(region, prefRegion) == 0 ? TRUE : FALSE;</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :         if (!isPrefRegion &amp;&amp; commonlyUsed) {</span>
<span class="lineNum">    2516 </span>            :             // With commonlyUsed=true, we do not put
<span class="lineNum">    2517 </span>            :             // currencies for other regions in the
<span class="lineNum">    2518 </span>            :             // result list.
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2520 </span>            :         }
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :         ures_getByKey(bundle, region, &amp;regbndl, status);</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :         if (U_FAILURE(*status)) {</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2524 </span>            :         }
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :         while (U_SUCCESS(*status) &amp;&amp; ures_hasNext(&amp;regbndl)) {</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :             ures_getNextResource(&amp;regbndl, &amp;curbndl, status);</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :             if (ures_getType(&amp;curbndl) != URES_TABLE) {</span>
<span class="lineNum">    2528 </span>            :                 // Currently, an empty ARRAY is mixed in.
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2530 </span>            :             }
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :             char *curID = (char *)uprv_malloc(sizeof(char) * ULOC_KEYWORDS_CAPACITY);</span>
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :             int32_t curIDLength = ULOC_KEYWORDS_CAPACITY;</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :             if (curID == NULL) {</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :                 *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2536 </span>            :             }
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span>            : #if U_CHARSET_FAMILY==U_ASCII_FAMILY
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :             ures_getUTF8StringByKey(&amp;curbndl, &quot;id&quot;, curID, &amp;curIDLength, TRUE, status);</span>
<span class="lineNum">    2540 </span>            :             /* optimize - use the utf-8 string */
<span class="lineNum">    2541 </span>            : #else
<span class="lineNum">    2542 </span>            :             {
<span class="lineNum">    2543 </span>            :                        const UChar* defString = ures_getStringByKey(&amp;curbndl, &quot;id&quot;, &amp;curIDLength, status);
<span class="lineNum">    2544 </span>            :                        if(U_SUCCESS(*status)) {
<span class="lineNum">    2545 </span>            :                            if(curIDLength+1 &gt; ULOC_KEYWORDS_CAPACITY) {
<span class="lineNum">    2546 </span>            :                                 *status = U_BUFFER_OVERFLOW_ERROR;
<span class="lineNum">    2547 </span>            :                            } else {
<span class="lineNum">    2548 </span>            :                                 u_UCharsToChars(defString, curID, curIDLength+1);
<span class="lineNum">    2549 </span>            :                            }
<span class="lineNum">    2550 </span>            :                        }
<span class="lineNum">    2551 </span>            :             }
<span class="lineNum">    2552 </span>            : #endif  
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :             if (U_FAILURE(*status)) {</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2556 </span>            :             }
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :             UBool hasTo = FALSE;</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :             ures_getByKey(&amp;curbndl, &quot;to&quot;, &amp;to, status);</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :             if (U_FAILURE(*status)) {</span>
<span class="lineNum">    2560 </span>            :                 // Do nothing here...
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :                 *status = U_ZERO_ERROR;</span>
<span class="lineNum">    2562 </span>            :             } else {
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :                 hasTo = TRUE;</span>
<span class="lineNum">    2564 </span>            :             }
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :             if (isPrefRegion &amp;&amp; !hasTo &amp;&amp; !ulist_containsString(values, curID, (int32_t)uprv_strlen(curID))) {</span>
<span class="lineNum">    2566 </span>            :                 // Currently active currency for the target country
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :                 ulist_addItemEndList(values, curID, TRUE, status);</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :             } else if (!ulist_containsString(otherValues, curID, (int32_t)uprv_strlen(curID)) &amp;&amp; !commonlyUsed) {</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :                 ulist_addItemEndList(otherValues, curID, TRUE, status);</span>
<span class="lineNum">    2570 </span>            :             } else {
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :                 uprv_free(curID);</span>
<span class="lineNum">    2572 </span>            :             }
<span class="lineNum">    2573 </span>            :         }
<span class="lineNum">    2574 </span>            :         
<span class="lineNum">    2575 </span>            :     }
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(*status)) {</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :         if (commonlyUsed) {</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :             if (ulist_getListSize(values) == 0) {</span>
<span class="lineNum">    2579 </span>            :                 // This could happen if no valid region is supplied in the input
<span class="lineNum">    2580 </span>            :                 // locale. In this case, we use the CLDR's default.
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :                 uenum_close(en);</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :                 en = ucurr_getKeywordValuesForLocale(key, &quot;und&quot;, TRUE, status);</span>
<span class="lineNum">    2583 </span>            :             }
<span class="lineNum">    2584 </span>            :         } else {
<span class="lineNum">    2585 </span>            :             // Consolidate the list
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :             char *value = NULL;</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :             ulist_resetList(otherValues);</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :             while ((value = (char *)ulist_getNext(otherValues)) != NULL) {</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :                 if (!ulist_containsString(values, value, (int32_t)uprv_strlen(value))) {</span>
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :                     char *tmpValue = (char *)uprv_malloc(sizeof(char) * ULOC_KEYWORDS_CAPACITY);</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :                     uprv_memcpy(tmpValue, value, uprv_strlen(value) + 1);</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :                     ulist_addItemEndList(values, tmpValue, TRUE, status);</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :                     if (U_FAILURE(*status)) {</span>
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2595 </span>            :                     }
<span class="lineNum">    2596 </span>            :                 }
<span class="lineNum">    2597 </span>            :             }
<span class="lineNum">    2598 </span>            :         }
<span class="lineNum">    2599 </span>            :         
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :         ulist_resetList((UList *)(en-&gt;context));</span>
<span class="lineNum">    2601 </span>            :     } else {
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :         ulist_deleteList(values);</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :         uprv_free(en);</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :         values = NULL;</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :         en = NULL;</span>
<span class="lineNum">    2606 </span>            :     }
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :     ures_close(&amp;to);</span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :     ures_close(&amp;curbndl);</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :     ures_close(&amp;regbndl);</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :     ures_close(&amp;bundlekey);</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :     ures_close(bundle);</span>
<span class="lineNum">    2612 </span>            :     
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :     ulist_deleteList(otherValues);</span>
<span class="lineNum">    2614 </span>            :     
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :     return en;</span>
<span class="lineNum">    2616 </span>            : }
<span class="lineNum">    2617 </span>            : 
<a name="2618"><span class="lineNum">    2618 </span>            : </a>
<span class="lineNum">    2619 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 : ucurr_getNumericCode(const UChar* currency) {</span>
<span class="lineNum">    2621 </span><span class="lineNoCov">          0 :     int32_t code = 0;</span>
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :     if (currency &amp;&amp; u_strlen(currency) == ISO_CURRENCY_CODE_LENGTH) {</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 :         UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 :         UResourceBundle *bundle = ures_openDirect(0, &quot;currencyNumericCodes&quot;, &amp;status);</span>
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :         ures_getByKey(bundle, &quot;codeMap&quot;, bundle, &amp;status);</span>
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :         if (U_SUCCESS(status)) {</span>
<span class="lineNum">    2628 </span>            :             char alphaCode[ISO_CURRENCY_CODE_LENGTH+1];
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :             myUCharsToChars(alphaCode, currency);</span>
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :             T_CString_toUpperCase(alphaCode);</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :             ures_getByKey(bundle, alphaCode, bundle, &amp;status);</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :             int tmpCode = ures_getInt(bundle, &amp;status);</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :             if (U_SUCCESS(status)) {</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :                 code = tmpCode;</span>
<span class="lineNum">    2635 </span>            :             }
<span class="lineNum">    2636 </span>            :         }
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :         ures_close(bundle);</span>
<span class="lineNum">    2638 </span>            :     }
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :     return code;</span>
<span class="lineNum">    2640 </span>            : }
<span class="lineNum">    2641 </span>            : #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span>            : //eof
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/ucnv_u7.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - ucnv_u7.cpp<span style="font-size: 80%;"> (source / <a href="ucnv_u7.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">599</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*  
<span class="lineNum">       4 </span>            : **********************************************************************
<span class="lineNum">       5 </span>            : *   Copyright (C) 2002-2016, International Business Machines
<span class="lineNum">       6 </span>            : *   Corporation and others.  All Rights Reserved.
<span class="lineNum">       7 </span>            : **********************************************************************
<span class="lineNum">       8 </span>            : *   file name:  ucnv_u7.c
<span class="lineNum">       9 </span>            : *   encoding:   UTF-8
<span class="lineNum">      10 </span>            : *   tab size:   8 (not used)
<span class="lineNum">      11 </span>            : *   indentation:4
<span class="lineNum">      12 </span>            : *
<span class="lineNum">      13 </span>            : *   created on: 2002jul01
<span class="lineNum">      14 </span>            : *   created by: Markus W. Scherer
<span class="lineNum">      15 </span>            : *
<span class="lineNum">      16 </span>            : *   UTF-7 converter implementation. Used to be in ucnv_utf.c.
<span class="lineNum">      17 </span>            : */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #if !UCONFIG_NO_CONVERSION &amp;&amp; !UCONFIG_ONLY_HTML_CONVERSION
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;unicode/ucnv.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;ucnv_bld.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;ucnv_cnv.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : /* UTF-7 -------------------------------------------------------------------- */
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : /*
<span class="lineNum">      32 </span>            :  * UTF-7 is a stateful encoding of Unicode.
<span class="lineNum">      33 </span>            :  * It is defined in RFC 2152. (http://www.ietf.org/rfc/rfc2152.txt)
<span class="lineNum">      34 </span>            :  * It was intended for use in Internet email systems, using in its bytewise
<span class="lineNum">      35 </span>            :  * encoding only a subset of 7-bit US-ASCII.
<span class="lineNum">      36 </span>            :  * UTF-7 is deprecated in favor of UTF-8/16/32 and SCSU, but still
<span class="lineNum">      37 </span>            :  * occasionally used.
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * For converting Unicode to UTF-7, the RFC allows to encode some US-ASCII
<span class="lineNum">      40 </span>            :  * characters directly or in base64. Especially, the characters in set O
<span class="lineNum">      41 </span>            :  * as defined in the RFC (see below) may be encoded directly but are not
<span class="lineNum">      42 </span>            :  * allowed in, e.g., email headers.
<span class="lineNum">      43 </span>            :  * By default, the ICU UTF-7 converter encodes set O directly.
<span class="lineNum">      44 </span>            :  * By choosing the option &quot;version=1&quot;, set O will be escaped instead.
<span class="lineNum">      45 </span>            :  * For example:
<span class="lineNum">      46 </span>            :  *     utf7Converter=ucnv_open(&quot;UTF-7,version=1&quot;);
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * For details about email headers see RFC 2047.
<span class="lineNum">      49 </span>            :  */
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /*
<span class="lineNum">      52 </span>            :  * Tests for US-ASCII characters belonging to character classes
<span class="lineNum">      53 </span>            :  * defined in UTF-7.
<span class="lineNum">      54 </span>            :  *
<span class="lineNum">      55 </span>            :  * Set D (directly encoded characters) consists of the following
<span class="lineNum">      56 </span>            :  * characters: the upper and lower case letters A through Z
<span class="lineNum">      57 </span>            :  * and a through z, the 10 digits 0-9, and the following nine special
<span class="lineNum">      58 </span>            :  * characters (note that &quot;+&quot; and &quot;=&quot; are omitted):
<span class="lineNum">      59 </span>            :  *     '(),-./:?
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * Set O (optional direct characters) consists of the following
<span class="lineNum">      62 </span>            :  * characters (note that &quot;\&quot; and &quot;~&quot; are omitted):
<span class="lineNum">      63 </span>            :  *     !&quot;#$%&amp;*;&lt;=&gt;@[]^_`{|}
<span class="lineNum">      64 </span>            :  *
<span class="lineNum">      65 </span>            :  * According to the rules in RFC 2152, the byte values for the following
<span class="lineNum">      66 </span>            :  * US-ASCII characters are not used in UTF-7 and are therefore illegal:
<span class="lineNum">      67 </span>            :  * - all C0 control codes except for CR LF TAB
<span class="lineNum">      68 </span>            :  * - BACKSLASH
<span class="lineNum">      69 </span>            :  * - TILDE
<span class="lineNum">      70 </span>            :  * - DEL
<span class="lineNum">      71 </span>            :  * - all codes beyond US-ASCII, i.e. all &gt;127
<span class="lineNum">      72 </span>            :  */
<span class="lineNum">      73 </span>            : #define inSetD(c) \
<span class="lineNum">      74 </span>            :     ((uint8_t)((c)-97)&lt;26 || (uint8_t)((c)-65)&lt;26 || /* letters */ \
<span class="lineNum">      75 </span>            :      (uint8_t)((c)-48)&lt;10 ||    /* digits */ \
<span class="lineNum">      76 </span>            :      (uint8_t)((c)-39)&lt;3 ||     /* '() */ \
<span class="lineNum">      77 </span>            :      (uint8_t)((c)-44)&lt;4 ||     /* ,-./ */ \
<span class="lineNum">      78 </span>            :      (c)==58 || (c)==63         /* :? */ \
<span class="lineNum">      79 </span>            :     )
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #define inSetO(c) \
<span class="lineNum">      82 </span>            :     ((uint8_t)((c)-33)&lt;6 ||         /* !&quot;#$%&amp; */ \
<span class="lineNum">      83 </span>            :      (uint8_t)((c)-59)&lt;4 ||         /* ;&lt;=&gt; */ \
<span class="lineNum">      84 </span>            :      (uint8_t)((c)-93)&lt;4 ||         /* ]^_` */ \
<span class="lineNum">      85 </span>            :      (uint8_t)((c)-123)&lt;3 ||        /* {|} */ \
<span class="lineNum">      86 </span>            :      (c)==42 || (c)==64 || (c)==91  /* *@[ */ \
<span class="lineNum">      87 </span>            :     )
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : #define isCRLFTAB(c) ((c)==13 || (c)==10 || (c)==9)
<span class="lineNum">      90 </span>            : #define isCRLFSPTAB(c) ((c)==32 || (c)==13 || (c)==10 || (c)==9)
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : #define PLUS  43
<span class="lineNum">      93 </span>            : #define MINUS 45
<span class="lineNum">      94 </span>            : #define BACKSLASH 92
<span class="lineNum">      95 </span>            : #define TILDE 126
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /* legal byte values: all US-ASCII graphic characters from space to before tilde, and CR LF TAB */
<span class="lineNum">      98 </span>            : #define isLegalUTF7(c) (((uint8_t)((c)-32)&lt;94 &amp;&amp; (c)!=BACKSLASH) || isCRLFTAB(c))
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : /* encode directly sets D and O and CR LF SP TAB */
<span class="lineNum">     101 </span>            : static const UBool encodeDirectlyMaximum[128]={
<span class="lineNum">     102 </span>            :  /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f */
<span class="lineNum">     103 </span>            :     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
<span class="lineNum">     104 </span>            :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
<span class="lineNum">     107 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     110 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     113 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0
<span class="lineNum">     114 </span>            : };
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : /* encode directly set D and CR LF SP TAB but not set O */
<span class="lineNum">     117 </span>            : static const UBool encodeDirectlyRestricted[128]={
<span class="lineNum">     118 </span>            :  /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f */
<span class="lineNum">     119 </span>            :     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
<span class="lineNum">     120 </span>            :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1,
<span class="lineNum">     123 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     126 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     129 </span>            :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
<span class="lineNum">     130 </span>            : };
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : static const uint8_t
<span class="lineNum">     133 </span>            : toBase64[64]={
<span class="lineNum">     134 </span>            :     /* A-Z */
<span class="lineNum">     135 </span>            :     65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
<span class="lineNum">     136 </span>            :     78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
<span class="lineNum">     137 </span>            :     /* a-z */
<span class="lineNum">     138 </span>            :     97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
<span class="lineNum">     139 </span>            :     110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,
<span class="lineNum">     140 </span>            :     /* 0-9 */
<span class="lineNum">     141 </span>            :     48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
<span class="lineNum">     142 </span>            :     /* +/ */
<span class="lineNum">     143 </span>            :     43, 47
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : static const int8_t
<span class="lineNum">     147 </span>            : fromBase64[128]={
<span class="lineNum">     148 </span>            :     /* C0 controls, -1 for legal ones (CR LF TAB), -3 for illegal ones */
<span class="lineNum">     149 </span>            :     -3, -3, -3, -3, -3, -3, -3, -3, -3, -1, -1, -3, -3, -1, -3, -3,
<span class="lineNum">     150 </span>            :     -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     /* general punctuation with + and / and a special value (-2) for - */
<span class="lineNum">     153 </span>            :     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -2, -1, 63,
<span class="lineNum">     154 </span>            :     /* digits */
<span class="lineNum">     155 </span>            :     52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :     /* A-Z */
<span class="lineNum">     158 </span>            :     -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
<span class="lineNum">     159 </span>            :     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -3, -1, -1, -1,
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     /* a-z */
<span class="lineNum">     162 </span>            :     -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
<span class="lineNum">     163 </span>            :     41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -3, -3
<span class="lineNum">     164 </span>            : };
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : /*
<span class="lineNum">     167 </span>            :  * converter status values:
<span class="lineNum">     168 </span>            :  *
<span class="lineNum">     169 </span>            :  * toUnicodeStatus:
<span class="lineNum">     170 </span>            :  *     24 inDirectMode (boolean)
<span class="lineNum">     171 </span>            :  * 23..16 base64Counter (-1..7)
<span class="lineNum">     172 </span>            :  * 15..0  bits (up to 14 bits incoming base64)
<span class="lineNum">     173 </span>            :  *
<span class="lineNum">     174 </span>            :  * fromUnicodeStatus:
<span class="lineNum">     175 </span>            :  * 31..28 version (0: set O direct  1: set O escaped)
<span class="lineNum">     176 </span>            :  *     24 inDirectMode (boolean)
<span class="lineNum">     177 </span>            :  * 23..16 base64Counter (0..2)
<span class="lineNum">     178 </span>            :  *  7..0  bits (6 bits outgoing base64)
<span class="lineNum">     179 </span>            :  *
<span class="lineNum">     180 </span>            :  */
<span class="lineNum">     181 </span>            : 
<a name="182"><span class="lineNum">     182 </span>            : U_CDECL_BEGIN</a>
<span class="lineNum">     183 </span>            : static void U_CALLCONV
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : _UTF7Reset(UConverter *cnv, UConverterResetChoice choice) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     if(choice&lt;=UCNV_RESET_TO_UNICODE) {</span>
<span class="lineNum">     186 </span>            :         /* reset toUnicode */
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         cnv-&gt;toUnicodeStatus=0x1000000; /* inDirectMode=TRUE */</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         cnv-&gt;toULength=0;</span>
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     if(choice!=UCNV_RESET_TO_UNICODE) {</span>
<span class="lineNum">     191 </span>            :         /* reset fromUnicode */
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=(cnv-&gt;fromUnicodeStatus&amp;0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */</span>
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : }</span>
<a name="195"><span class="lineNum">     195 </span>            : </a>
<span class="lineNum">     196 </span>            : static void U_CALLCONV
<span class="lineNum">     197 </span><span class="lineNoCov">          0 : _UTF7Open(UConverter *cnv,</span>
<span class="lineNum">     198 </span>            :           UConverterLoadArgs *pArgs,
<span class="lineNum">     199 </span>            :           UErrorCode *pErrorCode) {
<span class="lineNum">     200 </span>            :     (void)pArgs;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     if(UCNV_GET_VERSION(cnv)&lt;=1) {</span>
<span class="lineNum">     202 </span>            :         /* TODO(markus): Should just use cnv-&gt;options rather than copying the version number. */
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=UCNV_GET_VERSION(cnv)&lt;&lt;28;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         _UTF7Reset(cnv, UCNV_RESET_BOTH);</span>
<span class="lineNum">     205 </span>            :     } else {
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span><span class="lineNoCov">          0 : }</span>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<span class="lineNum">     210 </span>            : static void U_CALLCONV
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : _UTF7ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,</span>
<span class="lineNum">     212 </span>            :                           UErrorCode *pErrorCode) {
<span class="lineNum">     213 </span>            :     UConverter *cnv;
<span class="lineNum">     214 </span>            :     const uint8_t *source, *sourceLimit;
<span class="lineNum">     215 </span>            :     UChar *target;
<span class="lineNum">     216 </span>            :     const UChar *targetLimit;
<span class="lineNum">     217 </span>            :     int32_t *offsets;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :     uint8_t *bytes;
<span class="lineNum">     220 </span>            :     uint8_t byteIndex;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     int32_t length, targetCapacity;
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :     /* UTF-7 state */
<span class="lineNum">     225 </span>            :     uint16_t bits;
<span class="lineNum">     226 </span>            :     int8_t base64Counter;
<span class="lineNum">     227 </span>            :     UBool inDirectMode;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     int8_t base64Value;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :     int32_t sourceIndex, nextSourceIndex;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :     uint8_t b;
<span class="lineNum">     234 </span>            :     /* set up the local pointers */
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     cnv=pArgs-&gt;converter;</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     source=(const uint8_t *)pArgs-&gt;source;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     sourceLimit=(const uint8_t *)pArgs-&gt;sourceLimit;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     target=pArgs-&gt;target;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     targetLimit=pArgs-&gt;targetLimit;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     offsets=pArgs-&gt;offsets;</span>
<span class="lineNum">     242 </span>            :     /* get the state machine state */
<span class="lineNum">     243 </span>            :     {
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         uint32_t status=cnv-&gt;toUnicodeStatus;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         inDirectMode=(UBool)((status&gt;&gt;24)&amp;1);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         base64Counter=(int8_t)(status&gt;&gt;16);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         bits=(uint16_t)status;</span>
<span class="lineNum">     248 </span>            :     }
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     bytes=cnv-&gt;toUBytes;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     byteIndex=cnv-&gt;toULength;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :     /* sourceIndex=-1 if the current character began in the previous buffer */
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     sourceIndex=byteIndex==0 ? 0 : -1;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     nextSourceIndex=0;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     if(inDirectMode) {</span>
<span class="lineNum">     257 </span>            : directMode:
<span class="lineNum">     258 </span>            :         /*
<span class="lineNum">     259 </span>            :          * In Direct Mode, most US-ASCII characters are encoded directly, i.e.,
<span class="lineNum">     260 </span>            :          * with their US-ASCII byte values.
<span class="lineNum">     261 </span>            :          * Backslash and Tilde and most control characters are not allowed in UTF-7.
<span class="lineNum">     262 </span>            :          * A plus sign starts Unicode (or &quot;escape&quot;) Mode.
<span class="lineNum">     263 </span>            :          *
<span class="lineNum">     264 </span>            :          * In Direct Mode, only the sourceIndex is used.
<span class="lineNum">     265 </span>            :          */
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         byteIndex=0;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         length=(int32_t)(sourceLimit-source);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         targetCapacity=(int32_t)(targetLimit-target);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         if(length&gt;targetCapacity) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :             length=targetCapacity;</span>
<span class="lineNum">     271 </span>            :         }
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         while(length&gt;0) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :             b=*source++;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :             if(!isLegalUTF7(b)) {</span>
<span class="lineNum">     275 </span>            :                 /* illegal */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 bytes[0]=b;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                 byteIndex=1;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             } else if(b!=PLUS) {</span>
<span class="lineNum">     281 </span>            :                 /* write directly encoded character */
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 *target++=b;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     285 </span>            :                 }
<span class="lineNum">     286 </span>            :             } else /* PLUS */ {
<span class="lineNum">     287 </span>            :                 /* switch to Unicode mode */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 nextSourceIndex=++sourceIndex;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                 inDirectMode=FALSE;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :                 byteIndex=0;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :                 bits=0;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                 base64Counter=-1;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                 goto unicodeMode;</span>
<span class="lineNum">     294 </span>            :             }
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :             --length;</span>
<span class="lineNum">     296 </span>            :         }
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         if(source&lt;sourceLimit &amp;&amp; target&gt;=targetLimit) {</span>
<span class="lineNum">     298 </span>            :             /* target is full */
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     300 </span>            :         }
<span class="lineNum">     301 </span>            :     } else {
<span class="lineNum">     302 </span>            : unicodeMode:
<span class="lineNum">     303 </span>            :         /*
<span class="lineNum">     304 </span>            :          * In Unicode (or &quot;escape&quot;) Mode, UTF-16BE is base64-encoded.
<span class="lineNum">     305 </span>            :          * The base64 sequence ends with any character that is not in the base64 alphabet.
<span class="lineNum">     306 </span>            :          * A terminating minus sign is consumed.
<span class="lineNum">     307 </span>            :          *
<span class="lineNum">     308 </span>            :          * In Unicode Mode, the sourceIndex has the index to the start of the current
<span class="lineNum">     309 </span>            :          * base64 bytes, while nextSourceIndex is precisely parallel to source,
<span class="lineNum">     310 </span>            :          * keeping the index to the following byte.
<span class="lineNum">     311 </span>            :          * Note that in 2 out of 3 cases, UChars overlap within a base64 byte.
<span class="lineNum">     312 </span>            :          */
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         while(source&lt;sourceLimit) {</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                 bytes[byteIndex++]=b=*source++;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 ++nextSourceIndex;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                 base64Value = -3; /* initialize as illegal */</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 if(b&gt;=126 || (base64Value=fromBase64[b])==-3 || base64Value==-1) {</span>
<span class="lineNum">     319 </span>            :                     /* either
<span class="lineNum">     320 </span>            :                      * base64Value==-1 for any legal character except base64 and minus sign, or
<span class="lineNum">     321 </span>            :                      * base64Value==-3 for illegal characters:
<span class="lineNum">     322 </span>            :                      * 1. In either case, leave Unicode mode.
<span class="lineNum">     323 </span>            :                      * 2.1. If we ended with an incomplete UChar or none after the +, then
<span class="lineNum">     324 </span>            :                      *      generate an error for the preceding erroneous sequence and deal with
<span class="lineNum">     325 </span>            :                      *      the current (possibly illegal) character next time through.
<span class="lineNum">     326 </span>            :                      * 2.2. Else the current char comes after a complete UChar, which was already
<span class="lineNum">     327 </span>            :                      *      pushed to the output buf, so:
<span class="lineNum">     328 </span>            :                      * 2.2.1. If the current char is legal, just save it for processing next time.
<span class="lineNum">     329 </span>            :                      *        It may be for example, a plus which we need to deal with in direct mode.
<span class="lineNum">     330 </span>            :                      * 2.2.2. Else if the current char is illegal, we might as well deal with it here.
<span class="lineNum">     331 </span>            :                      */
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                     if(base64Counter==-1) {</span>
<span class="lineNum">     334 </span>            :                         /* illegal: + immediately followed by something other than base64 or minus sign */
<span class="lineNum">     335 </span>            :                         /* include the plus sign in the reported sequence, but not the subsequent char */
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                         --source;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :                         bytes[0]=PLUS;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                         byteIndex=1;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                         *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                     } else if(bits!=0) {</span>
<span class="lineNum">     342 </span>            :                         /* bits are illegally left over, a UChar is incomplete */
<span class="lineNum">     343 </span>            :                         /* don't include current char (legal or illegal) in error seq */
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                         --source;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                         --byteIndex;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                         *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     348 </span>            :                     } else {
<span class="lineNum">     349 </span>            :                         /* previous UChar was complete */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                         if(base64Value==-3) {</span>
<span class="lineNum">     351 </span>            :                             /* current character is illegal, deal with it here */
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     354 </span>            :                         } else {
<span class="lineNum">     355 </span>            :                             /* un-read the current character in case it is a plus sign */
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                             --source;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex-1;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :                             goto directMode;</span>
<span class="lineNum">     359 </span>            :                         }
<span class="lineNum">     360 </span>            :                     }
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                 } else if(base64Value&gt;=0) {</span>
<span class="lineNum">     362 </span>            :                     /* collect base64 bytes into UChars */
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                     switch(base64Counter) {</span>
<span class="lineNum">     364 </span>            :                     case -1: /* -1 is immediately after the + */
<span class="lineNum">     365 </span>            :                     case 0:
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :                         bits=base64Value;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                         base64Counter=1;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     369 </span>            :                     case 1:
<span class="lineNum">     370 </span>            :                     case 3:
<span class="lineNum">     371 </span>            :                     case 4:
<span class="lineNum">     372 </span>            :                     case 6:
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)((bits&lt;&lt;6)|base64Value);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                         ++base64Counter;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     376 </span>            :                     case 2:
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :                         *target++=(UChar)((bits&lt;&lt;4)|(base64Value&gt;&gt;2));</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex-1;</span>
<span class="lineNum">     381 </span>            :                         }
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :                         bytes[0]=b; /* keep this byte in case an error occurs */</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :                         byteIndex=1;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)(base64Value&amp;3);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                         base64Counter=3;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     387 </span>            :                     case 5:
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :                         *target++=(UChar)((bits&lt;&lt;2)|(base64Value&gt;&gt;4));</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex-1;</span>
<span class="lineNum">     392 </span>            :                         }
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                         bytes[0]=b; /* keep this byte in case an error occurs */</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                         byteIndex=1;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)(base64Value&amp;15);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                         base64Counter=6;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     398 </span>            :                     case 7:
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                         *target++=(UChar)((bits&lt;&lt;6)|base64Value);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex;</span>
<span class="lineNum">     403 </span>            :                         }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                         byteIndex=0;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                         bits=0;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                         base64Counter=0;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     408 </span>            :                     default:
<span class="lineNum">     409 </span>            :                         /* will never occur */
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     411 </span>            :                     }
<span class="lineNum">     412 </span>            :                 } else /*base64Value==-2*/ {
<span class="lineNum">     413 </span>            :                     /* minus sign terminates the base64 sequence */
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :                     if(base64Counter==-1) {</span>
<span class="lineNum">     416 </span>            :                         /* +- i.e. a minus immediately following a plus */
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                         *target++=PLUS;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex-1;</span>
<span class="lineNum">     420 </span>            :                         }
<span class="lineNum">     421 </span>            :                     } else {
<span class="lineNum">     422 </span>            :                         /* absorb the minus and leave the Unicode Mode */
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :                         if(bits!=0) {</span>
<span class="lineNum">     424 </span>            :                             /* bits are illegally left over, a UChar is incomplete */
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     427 </span>            :                         }
<span class="lineNum">     428 </span>            :                     }
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                     sourceIndex=nextSourceIndex;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">     431 </span>            :                 }
<span class="lineNum">     432 </span>            :             } else {
<span class="lineNum">     433 </span>            :                 /* target is full */
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     436 </span>            :             }
<span class="lineNum">     437 </span>            :         }
<span class="lineNum">     438 </span>            :     }
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     if(U_SUCCESS(*pErrorCode) &amp;&amp; pArgs-&gt;flush &amp;&amp; source==sourceLimit &amp;&amp; bits==0) {</span>
<span class="lineNum">     441 </span>            :         /*
<span class="lineNum">     442 </span>            :          * if we are in Unicode mode, then the byteIndex might not be 0,
<span class="lineNum">     443 </span>            :          * but that is ok if bits==0
<span class="lineNum">     444 </span>            :          * -&gt; we set byteIndex=0 at the end of the stream to avoid a truncated error
<span class="lineNum">     445 </span>            :          * (not true for IMAP-mailbox-name where we must end in direct mode)
<span class="lineNum">     446 </span>            :          */
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         byteIndex=0;</span>
<span class="lineNum">     448 </span>            :     }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :     /* set the converter state back into UConverter */
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     cnv-&gt;toUnicodeStatus=((uint32_t)inDirectMode&lt;&lt;24)|((uint32_t)((uint8_t)base64Counter)&lt;&lt;16)|(uint32_t)bits;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     cnv-&gt;toULength=byteIndex;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :     /* write back the updated pointers */
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     pArgs-&gt;source=(const char *)source;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     pArgs-&gt;target=target;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     pArgs-&gt;offsets=offsets;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     459 </span>            : }
<a name="460"><span class="lineNum">     460 </span>            : </a>
<span class="lineNum">     461 </span>            : static void U_CALLCONV
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : _UTF7FromUnicodeWithOffsets(UConverterFromUnicodeArgs *pArgs,</span>
<span class="lineNum">     463 </span>            :                             UErrorCode *pErrorCode) {
<span class="lineNum">     464 </span>            :     UConverter *cnv;
<span class="lineNum">     465 </span>            :     const UChar *source, *sourceLimit;
<span class="lineNum">     466 </span>            :     uint8_t *target, *targetLimit;
<span class="lineNum">     467 </span>            :     int32_t *offsets;
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :     int32_t length, targetCapacity, sourceIndex;
<span class="lineNum">     470 </span>            :     UChar c;
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :     /* UTF-7 state */
<span class="lineNum">     473 </span>            :     const UBool *encodeDirectly;
<span class="lineNum">     474 </span>            :     uint8_t bits;
<span class="lineNum">     475 </span>            :     int8_t base64Counter;
<span class="lineNum">     476 </span>            :     UBool inDirectMode;
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :     /* set up the local pointers */
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     cnv=pArgs-&gt;converter;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :     /* set up the local pointers */
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     source=pArgs-&gt;source;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     sourceLimit=pArgs-&gt;sourceLimit;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     target=(uint8_t *)pArgs-&gt;target;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     targetLimit=(uint8_t *)pArgs-&gt;targetLimit;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     offsets=pArgs-&gt;offsets;</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     /* get the state machine state */
<span class="lineNum">     489 </span>            :     {
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         uint32_t status=cnv-&gt;fromUnicodeStatus;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         encodeDirectly= status&lt;0x10000000 ? encodeDirectlyMaximum : encodeDirectlyRestricted;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         inDirectMode=(UBool)((status&gt;&gt;24)&amp;1);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         base64Counter=(int8_t)(status&gt;&gt;16);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         bits=(uint8_t)status;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         U_ASSERT(bits&lt;=UPRV_LENGTHOF(toBase64));</span>
<span class="lineNum">     496 </span>            :     }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :     /* UTF-7 always encodes UTF-16 code units, therefore we need only a simple sourceIndex */
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     sourceIndex=0;</span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     if(inDirectMode) {</span>
<span class="lineNum">     502 </span>            : directMode:
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         length=(int32_t)(sourceLimit-source);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         targetCapacity=(int32_t)(targetLimit-target);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         if(length&gt;targetCapacity) {</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             length=targetCapacity;</span>
<span class="lineNum">     507 </span>            :         }
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         while(length&gt;0) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :             c=*source++;</span>
<span class="lineNum">     510 </span>            :             /* currently always encode CR LF SP TAB directly */
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             if(c&lt;=127 &amp;&amp; encodeDirectly[c]) {</span>
<span class="lineNum">     512 </span>            :                 /* encode directly */
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :                 *target++=(uint8_t)c;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     516 </span>            :                 }
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :             } else if(c==PLUS) {</span>
<span class="lineNum">     518 </span>            :                 /* output +- for + */
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                 *target++=PLUS;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :                 if(target&lt;targetLimit) {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                     *target++=MINUS;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex++;</span>
<span class="lineNum">     525 </span>            :                     }
<span class="lineNum">     526 </span>            :                     /* realign length and targetCapacity */
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">     528 </span>            :                 } else {
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex++;</span>
<span class="lineNum">     531 </span>            :                     }
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBuffer[0]=MINUS;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     536 </span>            :                 }
<span class="lineNum">     537 </span>            :             } else {
<span class="lineNum">     538 </span>            :                 /* un-read this character and switch to Unicode Mode */
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                 --source;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                 *target++=PLUS;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex;</span>
<span class="lineNum">     543 </span>            :                 }
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                 inDirectMode=FALSE;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 base64Counter=0;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                 goto unicodeMode;</span>
<span class="lineNum">     547 </span>            :             }
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :             --length;</span>
<span class="lineNum">     549 </span>            :         }
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         if(source&lt;sourceLimit &amp;&amp; target&gt;=targetLimit) {</span>
<span class="lineNum">     551 </span>            :             /* target is full */
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     553 </span>            :         }
<span class="lineNum">     554 </span>            :     } else {
<span class="lineNum">     555 </span>            : unicodeMode:
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         while(source&lt;sourceLimit) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 c=*source++;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 if(c&lt;=127 &amp;&amp; encodeDirectly[c]) {</span>
<span class="lineNum">     560 </span>            :                     /* encode directly */
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            :                     /* trick: back out this character to make this easier */
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                     --source;</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :                     /* terminate the base64 sequence */
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                     if(base64Counter!=0) {</span>
<span class="lineNum">     568 </span>            :                         /* write remaining bits for the previous character */
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                         *target++=toBase64[bits];</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex-1;</span>
<span class="lineNum">     572 </span>            :                         }
<span class="lineNum">     573 </span>            :                     }
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                     if(fromBase64[c]!=-1) {</span>
<span class="lineNum">     575 </span>            :                         /* need to terminate with a minus */
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :                             *target++=MINUS;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex-1;</span>
<span class="lineNum">     580 </span>            :                             }
<span class="lineNum">     581 </span>            :                         } else {
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=MINUS;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">     586 </span>            :                         }
<span class="lineNum">     587 </span>            :                     }
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">     589 </span>            :                 } else {
<span class="lineNum">     590 </span>            :                     /*
<span class="lineNum">     591 </span>            :                      * base64 this character:
<span class="lineNum">     592 </span>            :                      * Output 2 or 3 base64 bytes for the remaining bits of the previous character
<span class="lineNum">     593 </span>            :                      * and the bits of this character, each implicitly in UTF-16BE.
<span class="lineNum">     594 </span>            :                      *
<span class="lineNum">     595 </span>            :                      * Here, bits is an 8-bit variable because only 6 bits need to be kept from one
<span class="lineNum">     596 </span>            :                      * character to the next. The actual 2 or 4 bits are shifted to the left edge
<span class="lineNum">     597 </span>            :                      * of the 6-bits field 5..0 to make the termination of the base64 sequence easier.
<span class="lineNum">     598 </span>            :                      */
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                     switch(base64Counter) {</span>
<span class="lineNum">     600 </span>            :                     case 0:
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                         *target++=toBase64[c&gt;&gt;10];</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                             *target++=toBase64[(c&gt;&gt;4)&amp;0x3f];</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">     607 </span>            :                             }
<span class="lineNum">     608 </span>            :                         } else {
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">     611 </span>            :                             }
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=toBase64[(c&gt;&gt;4)&amp;0x3f];</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     615 </span>            :                         }
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                         bits=(uint8_t)((c&amp;15)&lt;&lt;2);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                         base64Counter=1;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     619 </span>            :                     case 1:
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                         *target++=toBase64[bits|(c&gt;&gt;14)];</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :                             *target++=toBase64[(c&gt;&gt;8)&amp;0x3f];</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :                             if(target&lt;targetLimit) {</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :                                 *target++=toBase64[(c&gt;&gt;2)&amp;0x3f];</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     629 </span>            :                                 }
<span class="lineNum">     630 </span>            :                             } else {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     634 </span>            :                                 }
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBuffer[0]=toBase64[(c&gt;&gt;2)&amp;0x3f];</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     638 </span>            :                             }
<span class="lineNum">     639 </span>            :                         } else {
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">     642 </span>            :                             }
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=toBase64[(c&gt;&gt;8)&amp;0x3f];</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[1]=toBase64[(c&gt;&gt;2)&amp;0x3f];</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=2;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     647 </span>            :                         }
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :                         bits=(uint8_t)((c&amp;3)&lt;&lt;4);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :                         base64Counter=2;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     651 </span>            :                     case 2:
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                         *target++=toBase64[bits|(c&gt;&gt;12)];</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                             *target++=toBase64[(c&gt;&gt;6)&amp;0x3f];</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :                             if(target&lt;targetLimit) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                                 *target++=toBase64[c&amp;0x3f];</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     661 </span>            :                                 }
<span class="lineNum">     662 </span>            :                             } else {
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     666 </span>            :                                 }
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBuffer[0]=toBase64[c&amp;0x3f];</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     670 </span>            :                             }
<span class="lineNum">     671 </span>            :                         } else {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">     674 </span>            :                             }
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=toBase64[(c&gt;&gt;6)&amp;0x3f];</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[1]=toBase64[c&amp;0x3f];</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=2;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     679 </span>            :                         }
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :                         bits=0;</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :                         base64Counter=0;</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     683 </span>            :                     default:
<span class="lineNum">     684 </span>            :                         /* will never occur */
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     686 </span>            :                     }
<span class="lineNum">     687 </span>            :                 }
<span class="lineNum">     688 </span>            :             } else {
<span class="lineNum">     689 </span>            :                 /* target is full */
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     692 </span>            :             }
<span class="lineNum">     693 </span>            :         }
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     if(pArgs-&gt;flush &amp;&amp; source&gt;=sourceLimit) {</span>
<span class="lineNum">     697 </span>            :         /* flush remaining bits to the target */
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         if(!inDirectMode) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :             if (base64Counter!=0) {</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                 if(target&lt;targetLimit) {</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :                     *target++=toBase64[bits];</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex-1;</span>
<span class="lineNum">     704 </span>            :                     }
<span class="lineNum">     705 </span>            :                 } else {
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++]=toBase64[bits];</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     708 </span>            :                 }
<span class="lineNum">     709 </span>            :             }
<span class="lineNum">     710 </span>            :             /* Add final MINUS to terminate unicodeMode */
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :                 *target++=MINUS;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex-1;</span>
<span class="lineNum">     715 </span>            :                 }
<span class="lineNum">     716 </span>            :             } else {
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                 cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++]=MINUS;</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     719 </span>            :             }
<span class="lineNum">     720 </span>            :         }
<span class="lineNum">     721 </span>            :         /* reset the state for the next conversion */
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=(cnv-&gt;fromUnicodeStatus&amp;0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */</span>
<span class="lineNum">     723 </span>            :     } else {
<span class="lineNum">     724 </span>            :         /* set the converter state back into UConverter */
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :             (cnv-&gt;fromUnicodeStatus&amp;0xf0000000)|    /* keep version*/</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :             ((uint32_t)inDirectMode&lt;&lt;24)|((uint32_t)base64Counter&lt;&lt;16)|(uint32_t)bits;</span>
<span class="lineNum">     728 </span>            :     }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     /* write back the updated pointers */
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     pArgs-&gt;source=source;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     pArgs-&gt;target=(char *)target;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     pArgs-&gt;offsets=offsets;</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     735 </span>            : }
<a name="736"><span class="lineNum">     736 </span>            : </a>
<span class="lineNum">     737 </span>            : static const char * U_CALLCONV
<span class="lineNum">     738 </span><span class="lineNoCov">          0 : _UTF7GetName(const UConverter *cnv) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     switch(cnv-&gt;fromUnicodeStatus&gt;&gt;28) {</span>
<span class="lineNum">     740 </span>            :     case 1:
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         return &quot;UTF-7,version=1&quot;;</span>
<span class="lineNum">     742 </span>            :     default:
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         return &quot;UTF-7&quot;;</span>
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span>            : }
<span class="lineNum">     746 </span>            : U_CDECL_END
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : static const UConverterImpl _UTF7Impl={
<span class="lineNum">     749 </span>            :     UCNV_UTF7,
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :     NULL,
<span class="lineNum">     752 </span>            :     NULL,
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :     _UTF7Open,
<span class="lineNum">     755 </span>            :     NULL,
<span class="lineNum">     756 </span>            :     _UTF7Reset,
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :     _UTF7ToUnicodeWithOffsets,
<span class="lineNum">     759 </span>            :     _UTF7ToUnicodeWithOffsets,
<span class="lineNum">     760 </span>            :     _UTF7FromUnicodeWithOffsets,
<span class="lineNum">     761 </span>            :     _UTF7FromUnicodeWithOffsets,
<span class="lineNum">     762 </span>            :     NULL,
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     NULL,
<span class="lineNum">     765 </span>            :     _UTF7GetName,
<span class="lineNum">     766 </span>            :     NULL, /* we don't need writeSub() because we never call a callback at fromUnicode() */
<span class="lineNum">     767 </span>            :     NULL,
<span class="lineNum">     768 </span>            :     ucnv_getCompleteUnicodeSet,
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     NULL,
<span class="lineNum">     771 </span>            :     NULL
<span class="lineNum">     772 </span>            : };
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : static const UConverterStaticData _UTF7StaticData={
<span class="lineNum">     775 </span>            :     sizeof(UConverterStaticData),
<span class="lineNum">     776 </span>            :     &quot;UTF-7&quot;,
<span class="lineNum">     777 </span>            :     0, /* TODO CCSID for UTF-7 */
<span class="lineNum">     778 </span>            :     UCNV_IBM, UCNV_UTF7,
<span class="lineNum">     779 </span>            :     1, 4,
<span class="lineNum">     780 </span>            :     { 0x3f, 0, 0, 0 }, 1, /* the subchar is not used */
<span class="lineNum">     781 </span>            :     FALSE, FALSE,
<span class="lineNum">     782 </span>            :     0,
<span class="lineNum">     783 </span>            :     0,
<span class="lineNum">     784 </span>            :     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
<span class="lineNum">     785 </span>            : };
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : const UConverterSharedData _UTF7Data=
<span class="lineNum">     788 </span>            :         UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&amp;_UTF7StaticData, &amp;_UTF7Impl);
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : /* IMAP mailbox name encoding ----------------------------------------------- */
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : /*
<span class="lineNum">     793 </span>            :  * RFC 2060: INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1
<span class="lineNum">     794 </span>            :  * http://www.ietf.org/rfc/rfc2060.txt
<span class="lineNum">     795 </span>            :  *
<span class="lineNum">     796 </span>            :  * 5.1.3.  Mailbox International Naming Convention
<span class="lineNum">     797 </span>            :  *
<span class="lineNum">     798 </span>            :  * By convention, international mailbox names are specified using a
<span class="lineNum">     799 </span>            :  * modified version of the UTF-7 encoding described in [UTF-7].  The
<span class="lineNum">     800 </span>            :  * purpose of these modifications is to correct the following problems
<span class="lineNum">     801 </span>            :  * with UTF-7:
<span class="lineNum">     802 </span>            :  *
<span class="lineNum">     803 </span>            :  *    1) UTF-7 uses the &quot;+&quot; character for shifting; this conflicts with
<span class="lineNum">     804 </span>            :  *       the common use of &quot;+&quot; in mailbox names, in particular USENET
<span class="lineNum">     805 </span>            :  *       newsgroup names.
<span class="lineNum">     806 </span>            :  *
<span class="lineNum">     807 </span>            :  *    2) UTF-7's encoding is BASE64 which uses the &quot;/&quot; character; this
<span class="lineNum">     808 </span>            :  *       conflicts with the use of &quot;/&quot; as a popular hierarchy delimiter.
<span class="lineNum">     809 </span>            :  *
<span class="lineNum">     810 </span>            :  *    3) UTF-7 prohibits the unencoded usage of &quot;\&quot;; this conflicts with
<span class="lineNum">     811 </span>            :  *       the use of &quot;\&quot; as a popular hierarchy delimiter.
<span class="lineNum">     812 </span>            :  *
<span class="lineNum">     813 </span>            :  *    4) UTF-7 prohibits the unencoded usage of &quot;~&quot;; this conflicts with
<span class="lineNum">     814 </span>            :  *       the use of &quot;~&quot; in some servers as a home directory indicator.
<span class="lineNum">     815 </span>            :  *
<span class="lineNum">     816 </span>            :  *    5) UTF-7 permits multiple alternate forms to represent the same
<span class="lineNum">     817 </span>            :  *       string; in particular, printable US-ASCII chararacters can be
<span class="lineNum">     818 </span>            :  *       represented in encoded form.
<span class="lineNum">     819 </span>            :  *
<span class="lineNum">     820 </span>            :  * In modified UTF-7, printable US-ASCII characters except for &quot;&amp;&quot;
<span class="lineNum">     821 </span>            :  * represent themselves; that is, characters with octet values 0x20-0x25
<span class="lineNum">     822 </span>            :  * and 0x27-0x7e.  The character &quot;&amp;&quot; (0x26) is represented by the two-
<span class="lineNum">     823 </span>            :  * octet sequence &quot;&amp;-&quot;.
<span class="lineNum">     824 </span>            :  *
<span class="lineNum">     825 </span>            :  * All other characters (octet values 0x00-0x1f, 0x7f-0xff, and all
<span class="lineNum">     826 </span>            :  * Unicode 16-bit octets) are represented in modified BASE64, with a
<span class="lineNum">     827 </span>            :  * further modification from [UTF-7] that &quot;,&quot; is used instead of &quot;/&quot;.
<span class="lineNum">     828 </span>            :  * Modified BASE64 MUST NOT be used to represent any printing US-ASCII
<span class="lineNum">     829 </span>            :  * character which can represent itself.
<span class="lineNum">     830 </span>            :  *
<span class="lineNum">     831 </span>            :  * &quot;&amp;&quot; is used to shift to modified BASE64 and &quot;-&quot; to shift back to US-
<span class="lineNum">     832 </span>            :  * ASCII.  All names start in US-ASCII, and MUST end in US-ASCII (that
<span class="lineNum">     833 </span>            :  * is, a name that ends with a Unicode 16-bit octet MUST end with a &quot;-
<span class="lineNum">     834 </span>            :  * &quot;).
<span class="lineNum">     835 </span>            :  *
<span class="lineNum">     836 </span>            :  * For example, here is a mailbox name which mixes English, Japanese,
<span class="lineNum">     837 </span>            :  * and Chinese text: ~peter/mail/&amp;ZeVnLIqe-/&amp;U,BTFw-
<span class="lineNum">     838 </span>            :  */
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            : /*
<span class="lineNum">     841 </span>            :  * Tests for US-ASCII characters belonging to character classes
<span class="lineNum">     842 </span>            :  * defined in UTF-7.
<span class="lineNum">     843 </span>            :  *
<span class="lineNum">     844 </span>            :  * Set D (directly encoded characters) consists of the following
<span class="lineNum">     845 </span>            :  * characters: the upper and lower case letters A through Z
<span class="lineNum">     846 </span>            :  * and a through z, the 10 digits 0-9, and the following nine special
<span class="lineNum">     847 </span>            :  * characters (note that &quot;+&quot; and &quot;=&quot; are omitted):
<span class="lineNum">     848 </span>            :  *     '(),-./:?
<span class="lineNum">     849 </span>            :  *
<span class="lineNum">     850 </span>            :  * Set O (optional direct characters) consists of the following
<span class="lineNum">     851 </span>            :  * characters (note that &quot;\&quot; and &quot;~&quot; are omitted):
<span class="lineNum">     852 </span>            :  *     !&quot;#$%&amp;*;&lt;=&gt;@[]^_`{|}
<span class="lineNum">     853 </span>            :  *
<span class="lineNum">     854 </span>            :  * According to the rules in RFC 2152, the byte values for the following
<span class="lineNum">     855 </span>            :  * US-ASCII characters are not used in UTF-7 and are therefore illegal:
<span class="lineNum">     856 </span>            :  * - all C0 control codes except for CR LF TAB
<span class="lineNum">     857 </span>            :  * - BACKSLASH
<span class="lineNum">     858 </span>            :  * - TILDE
<span class="lineNum">     859 </span>            :  * - DEL
<span class="lineNum">     860 </span>            :  * - all codes beyond US-ASCII, i.e. all &gt;127
<span class="lineNum">     861 </span>            :  */
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : /* uses '&amp;' not '+' to start a base64 sequence */
<span class="lineNum">     864 </span>            : #define AMPERSAND 0x26
<span class="lineNum">     865 </span>            : #define COMMA 0x2c
<span class="lineNum">     866 </span>            : #define SLASH 0x2f
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : /* legal byte values: all US-ASCII graphic characters 0x20..0x7e */
<span class="lineNum">     869 </span>            : #define isLegalIMAP(c) (0x20&lt;=(c) &amp;&amp; (c)&lt;=0x7e)
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : /* direct-encode all of printable ASCII 0x20..0x7e except '&amp;' 0x26 */
<span class="lineNum">     872 </span>            : #define inSetDIMAP(c) (isLegalIMAP(c) &amp;&amp; c!=AMPERSAND)
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : #define TO_BASE64_IMAP(n) ((n)&lt;63 ? toBase64[n] : COMMA)
<span class="lineNum">     875 </span>            : #define FROM_BASE64_IMAP(c) ((c)==COMMA ? 63 : (c)==SLASH ? -1 : fromBase64[c])
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : /*
<span class="lineNum">     878 </span>            :  * converter status values:
<span class="lineNum">     879 </span>            :  *
<span class="lineNum">     880 </span>            :  * toUnicodeStatus:
<span class="lineNum">     881 </span>            :  *     24 inDirectMode (boolean)
<span class="lineNum">     882 </span>            :  * 23..16 base64Counter (-1..7)
<span class="lineNum">     883 </span>            :  * 15..0  bits (up to 14 bits incoming base64)
<span class="lineNum">     884 </span>            :  *
<span class="lineNum">     885 </span>            :  * fromUnicodeStatus:
<span class="lineNum">     886 </span>            :  *     24 inDirectMode (boolean)
<span class="lineNum">     887 </span>            :  * 23..16 base64Counter (0..2)
<span class="lineNum">     888 </span>            :  *  7..0  bits (6 bits outgoing base64)
<span class="lineNum">     889 </span>            :  *
<span class="lineNum">     890 </span>            :  * ignore bits 31..25
<span class="lineNum">     891 </span>            :  */
<span class="lineNum">     892 </span>            : 
<a name="893"><span class="lineNum">     893 </span>            : U_CDECL_BEGIN</a>
<span class="lineNum">     894 </span>            : static void U_CALLCONV
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : _IMAPToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,</span>
<span class="lineNum">     896 </span>            :                           UErrorCode *pErrorCode) {
<span class="lineNum">     897 </span>            :     UConverter *cnv;
<span class="lineNum">     898 </span>            :     const uint8_t *source, *sourceLimit;
<span class="lineNum">     899 </span>            :     UChar *target;
<span class="lineNum">     900 </span>            :     const UChar *targetLimit;
<span class="lineNum">     901 </span>            :     int32_t *offsets;
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :     uint8_t *bytes;
<span class="lineNum">     904 </span>            :     uint8_t byteIndex;
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :     int32_t length, targetCapacity;
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :     /* UTF-7 state */
<span class="lineNum">     909 </span>            :     uint16_t bits;
<span class="lineNum">     910 </span>            :     int8_t base64Counter;
<span class="lineNum">     911 </span>            :     UBool inDirectMode;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     int8_t base64Value;
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            :     int32_t sourceIndex, nextSourceIndex;
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     UChar c;
<span class="lineNum">     918 </span>            :     uint8_t b;
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :     /* set up the local pointers */
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     cnv=pArgs-&gt;converter;</span>
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     source=(const uint8_t *)pArgs-&gt;source;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     sourceLimit=(const uint8_t *)pArgs-&gt;sourceLimit;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     target=pArgs-&gt;target;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     targetLimit=pArgs-&gt;targetLimit;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     offsets=pArgs-&gt;offsets;</span>
<span class="lineNum">     928 </span>            :     /* get the state machine state */
<span class="lineNum">     929 </span>            :     {
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         uint32_t status=cnv-&gt;toUnicodeStatus;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         inDirectMode=(UBool)((status&gt;&gt;24)&amp;1);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         base64Counter=(int8_t)(status&gt;&gt;16);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         bits=(uint16_t)status;</span>
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     bytes=cnv-&gt;toUBytes;</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     byteIndex=cnv-&gt;toULength;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            :     /* sourceIndex=-1 if the current character began in the previous buffer */
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     sourceIndex=byteIndex==0 ? 0 : -1;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     nextSourceIndex=0;</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     if(inDirectMode) {</span>
<span class="lineNum">     943 </span>            : directMode:
<span class="lineNum">     944 </span>            :         /*
<span class="lineNum">     945 </span>            :          * In Direct Mode, US-ASCII characters are encoded directly, i.e.,
<span class="lineNum">     946 </span>            :          * with their US-ASCII byte values.
<span class="lineNum">     947 </span>            :          * An ampersand starts Unicode (or &quot;escape&quot;) Mode.
<span class="lineNum">     948 </span>            :          *
<span class="lineNum">     949 </span>            :          * In Direct Mode, only the sourceIndex is used.
<span class="lineNum">     950 </span>            :          */
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         byteIndex=0;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         length=(int32_t)(sourceLimit-source);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         targetCapacity=(int32_t)(targetLimit-target);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         if(length&gt;targetCapacity) {</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :             length=targetCapacity;</span>
<span class="lineNum">     956 </span>            :         }
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         while(length&gt;0) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :             b=*source++;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :             if(!isLegalIMAP(b)) {</span>
<span class="lineNum">     960 </span>            :                 /* illegal */
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                 bytes[0]=b;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                 byteIndex=1;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :             } else if(b!=AMPERSAND) {</span>
<span class="lineNum">     966 </span>            :                 /* write directly encoded character */
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                 *target++=b;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex++;</span>
<span class="lineNum">     970 </span>            :                 }
<span class="lineNum">     971 </span>            :             } else /* AMPERSAND */ {
<span class="lineNum">     972 </span>            :                 /* switch to Unicode mode */
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :                 nextSourceIndex=++sourceIndex;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :                 inDirectMode=FALSE;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 byteIndex=0;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                 bits=0;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :                 base64Counter=-1;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 goto unicodeMode;</span>
<span class="lineNum">     979 </span>            :             }
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :             --length;</span>
<span class="lineNum">     981 </span>            :         }
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :         if(source&lt;sourceLimit &amp;&amp; target&gt;=targetLimit) {</span>
<span class="lineNum">     983 </span>            :             /* target is full */
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">     985 </span>            :         }
<span class="lineNum">     986 </span>            :     } else {
<span class="lineNum">     987 </span>            : unicodeMode:
<span class="lineNum">     988 </span>            :         /*
<span class="lineNum">     989 </span>            :          * In Unicode (or &quot;escape&quot;) Mode, UTF-16BE is base64-encoded.
<span class="lineNum">     990 </span>            :          * The base64 sequence ends with any character that is not in the base64 alphabet.
<span class="lineNum">     991 </span>            :          * A terminating minus sign is consumed.
<span class="lineNum">     992 </span>            :          * US-ASCII must not be base64-ed.
<span class="lineNum">     993 </span>            :          *
<span class="lineNum">     994 </span>            :          * In Unicode Mode, the sourceIndex has the index to the start of the current
<span class="lineNum">     995 </span>            :          * base64 bytes, while nextSourceIndex is precisely parallel to source,
<span class="lineNum">     996 </span>            :          * keeping the index to the following byte.
<span class="lineNum">     997 </span>            :          * Note that in 2 out of 3 cases, UChars overlap within a base64 byte.
<span class="lineNum">     998 </span>            :          */
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         while(source&lt;sourceLimit) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :                 bytes[byteIndex++]=b=*source++;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :                 ++nextSourceIndex;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :                 if(b&gt;0x7e) {</span>
<span class="lineNum">    1004 </span>            :                     /* illegal - test other illegal US-ASCII values by base64Value==-3 */
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :                 } else if((base64Value=FROM_BASE64_IMAP(b))&gt;=0) {</span>
<span class="lineNum">    1009 </span>            :                     /* collect base64 bytes into UChars */
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                     switch(base64Counter) {</span>
<span class="lineNum">    1011 </span>            :                     case -1: /* -1 is immediately after the &amp; */
<span class="lineNum">    1012 </span>            :                     case 0:
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                         bits=base64Value;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                         base64Counter=1;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1016 </span>            :                     case 1:
<span class="lineNum">    1017 </span>            :                     case 3:
<span class="lineNum">    1018 </span>            :                     case 4:
<span class="lineNum">    1019 </span>            :                     case 6:
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)((bits&lt;&lt;6)|base64Value);</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                         ++base64Counter;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1023 </span>            :                     case 2:
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                         c=(UChar)((bits&lt;&lt;4)|(base64Value&gt;&gt;2));</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                         if(isLegalIMAP(c)) {</span>
<span class="lineNum">    1026 </span>            :                             /* illegal */
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                             inDirectMode=TRUE;</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                             goto endloop;</span>
<span class="lineNum">    1030 </span>            :                         }
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                         *target++=c;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex-1;</span>
<span class="lineNum">    1035 </span>            :                         }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                         bytes[0]=b; /* keep this byte in case an error occurs */</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                         byteIndex=1;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)(base64Value&amp;3);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                         base64Counter=3;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1041 </span>            :                     case 5:
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                         c=(UChar)((bits&lt;&lt;2)|(base64Value&gt;&gt;4));</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                         if(isLegalIMAP(c)) {</span>
<span class="lineNum">    1044 </span>            :                             /* illegal */
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                             inDirectMode=TRUE;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                             goto endloop;</span>
<span class="lineNum">    1048 </span>            :                         }
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                         *target++=c;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex-1;</span>
<span class="lineNum">    1053 </span>            :                         }
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                         bytes[0]=b; /* keep this byte in case an error occurs */</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                         byteIndex=1;</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :                         bits=(uint16_t)(base64Value&amp;15);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :                         base64Counter=6;</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1059 </span>            :                     case 7:
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :                         c=(UChar)((bits&lt;&lt;6)|base64Value);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                         if(isLegalIMAP(c)) {</span>
<span class="lineNum">    1062 </span>            :                             /* illegal */
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                             inDirectMode=TRUE;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                             goto endloop;</span>
<span class="lineNum">    1066 </span>            :                         }
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                         *target++=c;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                             sourceIndex=nextSourceIndex;</span>
<span class="lineNum">    1071 </span>            :                         }
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                         byteIndex=0;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                         bits=0;</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                         base64Counter=0;</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1076 </span>            :                     default:
<span class="lineNum">    1077 </span>            :                         /* will never occur */
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1079 </span>            :                     }
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                 } else if(base64Value==-2) {</span>
<span class="lineNum">    1081 </span>            :                     /* minus sign terminates the base64 sequence */
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                     if(base64Counter==-1) {</span>
<span class="lineNum">    1084 </span>            :                         /* &amp;- i.e. a minus immediately following an ampersand */
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                         *target++=AMPERSAND;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex-1;</span>
<span class="lineNum">    1088 </span>            :                         }
<span class="lineNum">    1089 </span>            :                     } else {
<span class="lineNum">    1090 </span>            :                         /* absorb the minus and leave the Unicode Mode */
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                         if(bits!=0 || (base64Counter!=0 &amp;&amp; base64Counter!=3 &amp;&amp; base64Counter!=6)) {</span>
<span class="lineNum">    1092 </span>            :                             /* bits are illegally left over, a UChar is incomplete */
<span class="lineNum">    1093 </span>            :                             /* base64Counter other than 0, 3, 6 means non-minimal zero-padding, also illegal */
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    1096 </span>            :                         }
<span class="lineNum">    1097 </span>            :                     }
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                     sourceIndex=nextSourceIndex;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">    1100 </span>            :                 } else {
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :                     if(base64Counter==-1) {</span>
<span class="lineNum">    1102 </span>            :                         /* illegal: &amp; immediately followed by something other than base64 or minus sign */
<span class="lineNum">    1103 </span>            :                         /* include the ampersand in the reported sequence */
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                         --sourceIndex;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                         bytes[0]=AMPERSAND;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                         bytes[1]=b;</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                         byteIndex=2;</span>
<span class="lineNum">    1108 </span>            :                     }
<span class="lineNum">    1109 </span>            :                     /* base64Value==-1 for characters that are illegal only in Unicode mode */
<span class="lineNum">    1110 </span>            :                     /* base64Value==-3 for illegal characters */
<span class="lineNum">    1111 </span>            :                     /* illegal */
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_ILLEGAL_CHAR_FOUND;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1115 </span>            :                 }
<span class="lineNum">    1116 </span>            :             } else {
<span class="lineNum">    1117 </span>            :                 /* target is full */
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1120 </span>            :             }
<span class="lineNum">    1121 </span>            :         }
<span class="lineNum">    1122 </span>            :     }
<span class="lineNum">    1123 </span>            : endloop:
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            :     /*
<span class="lineNum">    1126 </span>            :      * the end of the input stream and detection of truncated input
<span class="lineNum">    1127 </span>            :      * are handled by the framework, but here we must check if we are in Unicode
<span class="lineNum">    1128 </span>            :      * mode and byteIndex==0 because we must end in direct mode
<span class="lineNum">    1129 </span>            :      *
<span class="lineNum">    1130 </span>            :      * conditions:
<span class="lineNum">    1131 </span>            :      *   successful
<span class="lineNum">    1132 </span>            :      *   in Unicode mode and byteIndex==0
<span class="lineNum">    1133 </span>            :      *   end of input and no truncated input
<span class="lineNum">    1134 </span>            :      */
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     if( U_SUCCESS(*pErrorCode) &amp;&amp;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         !inDirectMode &amp;&amp; byteIndex==0 &amp;&amp;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         pArgs-&gt;flush &amp;&amp; source&gt;=sourceLimit</span>
<span class="lineNum">    1138 </span>            :     ) {
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         if(base64Counter==-1) {</span>
<span class="lineNum">    1140 </span>            :             /* &amp; at the very end of the input */
<span class="lineNum">    1141 </span>            :             /* make the ampersand the reported sequence */
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :             bytes[0]=AMPERSAND;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :             byteIndex=1;</span>
<span class="lineNum">    1144 </span>            :         }
<span class="lineNum">    1145 </span>            :         /* else if(base64Counter!=-1) byteIndex remains 0 because there is no particular byte sequence */
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :         inDirectMode=TRUE; /* avoid looping */</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         *pErrorCode=U_TRUNCATED_CHAR_FOUND;</span>
<span class="lineNum">    1149 </span>            :     }
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :     /* set the converter state back into UConverter */
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     cnv-&gt;toUnicodeStatus=((uint32_t)inDirectMode&lt;&lt;24)|((uint32_t)((uint8_t)base64Counter)&lt;&lt;16)|(uint32_t)bits;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     cnv-&gt;toULength=byteIndex;</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            :     /* write back the updated pointers */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     pArgs-&gt;source=(const char *)source;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     pArgs-&gt;target=target;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     pArgs-&gt;offsets=offsets;</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1160 </span>            : }
<a name="1161"><span class="lineNum">    1161 </span>            : </a>
<span class="lineNum">    1162 </span>            : static void U_CALLCONV
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 : _IMAPFromUnicodeWithOffsets(UConverterFromUnicodeArgs *pArgs,</span>
<span class="lineNum">    1164 </span>            :                             UErrorCode *pErrorCode) {
<span class="lineNum">    1165 </span>            :     UConverter *cnv;
<span class="lineNum">    1166 </span>            :     const UChar *source, *sourceLimit;
<span class="lineNum">    1167 </span>            :     uint8_t *target, *targetLimit;
<span class="lineNum">    1168 </span>            :     int32_t *offsets;
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :     int32_t length, targetCapacity, sourceIndex;
<span class="lineNum">    1171 </span>            :     UChar c;
<span class="lineNum">    1172 </span>            :     uint8_t b;
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     /* UTF-7 state */
<span class="lineNum">    1175 </span>            :     uint8_t bits;
<span class="lineNum">    1176 </span>            :     int8_t base64Counter;
<span class="lineNum">    1177 </span>            :     UBool inDirectMode;
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            :     /* set up the local pointers */
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     cnv=pArgs-&gt;converter;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :     /* set up the local pointers */
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :     source=pArgs-&gt;source;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     sourceLimit=pArgs-&gt;sourceLimit;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     target=(uint8_t *)pArgs-&gt;target;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     targetLimit=(uint8_t *)pArgs-&gt;targetLimit;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     offsets=pArgs-&gt;offsets;</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :     /* get the state machine state */
<span class="lineNum">    1190 </span>            :     {
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         uint32_t status=cnv-&gt;fromUnicodeStatus;</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         inDirectMode=(UBool)((status&gt;&gt;24)&amp;1);</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         base64Counter=(int8_t)(status&gt;&gt;16);</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         bits=(uint8_t)status;</span>
<span class="lineNum">    1195 </span>            :     }
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            :     /* UTF-7 always encodes UTF-16 code units, therefore we need only a simple sourceIndex */
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     sourceIndex=0;</span>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     if(inDirectMode) {</span>
<span class="lineNum">    1201 </span>            : directMode:
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         length=(int32_t)(sourceLimit-source);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         targetCapacity=(int32_t)(targetLimit-target);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         if(length&gt;targetCapacity) {</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :             length=targetCapacity;</span>
<span class="lineNum">    1206 </span>            :         }
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :         while(length&gt;0) {</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :             c=*source++;</span>
<span class="lineNum">    1209 </span>            :             /* encode 0x20..0x7e except '&amp;' directly */
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :             if(inSetDIMAP(c)) {</span>
<span class="lineNum">    1211 </span>            :                 /* encode directly */
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                 *target++=(uint8_t)c;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex++;</span>
<span class="lineNum">    1215 </span>            :                 }
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :             } else if(c==AMPERSAND) {</span>
<span class="lineNum">    1217 </span>            :                 /* output &amp;- for &amp; */
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :                 *target++=AMPERSAND;</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                 if(target&lt;targetLimit) {</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                     *target++=MINUS;</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex;</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex++;</span>
<span class="lineNum">    1224 </span>            :                     }
<span class="lineNum">    1225 </span>            :                     /* realign length and targetCapacity */
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">    1227 </span>            :                 } else {
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex++;</span>
<span class="lineNum">    1230 </span>            :                     }
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBuffer[0]=MINUS;</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1235 </span>            :                 }
<span class="lineNum">    1236 </span>            :             } else {
<span class="lineNum">    1237 </span>            :                 /* un-read this character and switch to Unicode Mode */
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                 --source;</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :                 *target++=AMPERSAND;</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1242 </span>            :                 }
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                 inDirectMode=FALSE;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :                 base64Counter=0;</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                 goto unicodeMode;</span>
<span class="lineNum">    1246 </span>            :             }
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :             --length;</span>
<span class="lineNum">    1248 </span>            :         }
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :         if(source&lt;sourceLimit &amp;&amp; target&gt;=targetLimit) {</span>
<span class="lineNum">    1250 </span>            :             /* target is full */
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1252 </span>            :         }
<span class="lineNum">    1253 </span>            :     } else {
<span class="lineNum">    1254 </span>            : unicodeMode:
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         while(source&lt;sourceLimit) {</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :                 c=*source++;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                 if(isLegalIMAP(c)) {</span>
<span class="lineNum">    1259 </span>            :                     /* encode directly */
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :                     inDirectMode=TRUE;</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :                     /* trick: back out this character to make this easier */
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                     --source;</span>
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :                     /* terminate the base64 sequence */
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                     if(base64Counter!=0) {</span>
<span class="lineNum">    1267 </span>            :                         /* write remaining bits for the previous character */
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :                         *target++=TO_BASE64_IMAP(bits);</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex-1;</span>
<span class="lineNum">    1271 </span>            :                         }
<span class="lineNum">    1272 </span>            :                     }
<span class="lineNum">    1273 </span>            :                     /* need to terminate with a minus */
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                     if(target&lt;targetLimit) {</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                         *target++=MINUS;</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :                         if(offsets!=NULL) {</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :                             *offsets++=sourceIndex-1;</span>
<span class="lineNum">    1278 </span>            :                         }
<span class="lineNum">    1279 </span>            :                     } else {
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                         cnv-&gt;charErrorBuffer[0]=MINUS;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                         cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                         *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1284 </span>            :                     }
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :                     goto directMode;</span>
<span class="lineNum">    1286 </span>            :                 } else {
<span class="lineNum">    1287 </span>            :                     /*
<span class="lineNum">    1288 </span>            :                      * base64 this character:
<span class="lineNum">    1289 </span>            :                      * Output 2 or 3 base64 bytes for the remaining bits of the previous character
<span class="lineNum">    1290 </span>            :                      * and the bits of this character, each implicitly in UTF-16BE.
<span class="lineNum">    1291 </span>            :                      *
<span class="lineNum">    1292 </span>            :                      * Here, bits is an 8-bit variable because only 6 bits need to be kept from one
<span class="lineNum">    1293 </span>            :                      * character to the next. The actual 2 or 4 bits are shifted to the left edge
<span class="lineNum">    1294 </span>            :                      * of the 6-bits field 5..0 to make the termination of the base64 sequence easier.
<span class="lineNum">    1295 </span>            :                      */
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :                     switch(base64Counter) {</span>
<span class="lineNum">    1297 </span>            :                     case 0:
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :                         b=(uint8_t)(c&gt;&gt;10);</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :                         *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;4)&amp;0x3f);</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :                             *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex;</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">    1306 </span>            :                             }
<span class="lineNum">    1307 </span>            :                         } else {
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">    1310 </span>            :                             }
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;4)&amp;0x3f);</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1315 </span>            :                         }
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :                         bits=(uint8_t)((c&amp;15)&lt;&lt;2);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :                         base64Counter=1;</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1319 </span>            :                     case 1:
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                         b=(uint8_t)(bits|(c&gt;&gt;14));</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                         *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;8)&amp;0x3f);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :                             *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                             if(target&lt;targetLimit) {</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :                                 b=(uint8_t)((c&gt;&gt;2)&amp;0x3f);</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                                 *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">    1332 </span>            :                                 }
<span class="lineNum">    1333 </span>            :                             } else {
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">    1337 </span>            :                                 }
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :                                 b=(uint8_t)((c&gt;&gt;2)&amp;0x3f);</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBuffer[0]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :                                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1342 </span>            :                             }
<span class="lineNum">    1343 </span>            :                         } else {
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">    1346 </span>            :                             }
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;8)&amp;0x3f);</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;2)&amp;0x3f);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[1]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=2;</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1353 </span>            :                         }
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :                         bits=(uint8_t)((c&amp;3)&lt;&lt;4);</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :                         base64Counter=2;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1357 </span>            :                     case 2:
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :                         b=(uint8_t)(bits|(c&gt;&gt;12));</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :                         *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :                         if(target&lt;targetLimit) {</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;6)&amp;0x3f);</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :                             *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :                             if(target&lt;targetLimit) {</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :                                 b=(uint8_t)(c&amp;0x3f);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :                                 *target++=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">    1370 </span>            :                                 }
<span class="lineNum">    1371 </span>            :                             } else {
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :                                 if(offsets!=NULL) {</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex;</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                                     *offsets++=sourceIndex++;</span>
<span class="lineNum">    1375 </span>            :                                 }
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                                 b=(uint8_t)(c&amp;0x3f);</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBuffer[0]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                                 cnv-&gt;charErrorBufferLength=1;</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :                                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1380 </span>            :                             }
<span class="lineNum">    1381 </span>            :                         } else {
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                             if(offsets!=NULL) {</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :                                 *offsets++=sourceIndex++;</span>
<span class="lineNum">    1384 </span>            :                             }
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                             b=(uint8_t)((c&gt;&gt;6)&amp;0x3f);</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[0]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                             b=(uint8_t)(c&amp;0x3f);</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBuffer[1]=TO_BASE64_IMAP(b);</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :                             cnv-&gt;charErrorBufferLength=2;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1391 </span>            :                         }
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                         bits=0;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :                         base64Counter=0;</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1395 </span>            :                     default:
<span class="lineNum">    1396 </span>            :                         /* will never occur */
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1398 </span>            :                     }
<span class="lineNum">    1399 </span>            :                 }
<span class="lineNum">    1400 </span>            :             } else {
<span class="lineNum">    1401 </span>            :                 /* target is full */
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1404 </span>            :             }
<span class="lineNum">    1405 </span>            :         }
<span class="lineNum">    1406 </span>            :     }
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :     if(pArgs-&gt;flush &amp;&amp; source&gt;=sourceLimit) {</span>
<span class="lineNum">    1409 </span>            :         /* flush remaining bits to the target */
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :         if(!inDirectMode) {</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :             if(base64Counter!=0) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                 if(target&lt;targetLimit) {</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                     *target++=TO_BASE64_IMAP(bits);</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :                     if(offsets!=NULL) {</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :                         *offsets++=sourceIndex-1;</span>
<span class="lineNum">    1416 </span>            :                     }
<span class="lineNum">    1417 </span>            :                 } else {
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :                     cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++]=TO_BASE64_IMAP(bits);</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                     *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1420 </span>            :                 }
<span class="lineNum">    1421 </span>            :             }
<span class="lineNum">    1422 </span>            :             /* need to terminate with a minus */
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :             if(target&lt;targetLimit) {</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                 *target++=MINUS;</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :                 if(offsets!=NULL) {</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :                     *offsets++=sourceIndex-1;</span>
<span class="lineNum">    1427 </span>            :                 }
<span class="lineNum">    1428 </span>            :             } else {
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :                 cnv-&gt;charErrorBuffer[cnv-&gt;charErrorBufferLength++]=MINUS;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :                 *pErrorCode=U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1431 </span>            :             }
<span class="lineNum">    1432 </span>            :         }
<span class="lineNum">    1433 </span>            :         /* reset the state for the next conversion */
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=(cnv-&gt;fromUnicodeStatus&amp;0xf0000000)|0x1000000; /* keep version, inDirectMode=TRUE */</span>
<span class="lineNum">    1435 </span>            :     } else {
<span class="lineNum">    1436 </span>            :         /* set the converter state back into UConverter */
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         cnv-&gt;fromUnicodeStatus=</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :             (cnv-&gt;fromUnicodeStatus&amp;0xf0000000)|    /* keep version*/</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :             ((uint32_t)inDirectMode&lt;&lt;24)|((uint32_t)base64Counter&lt;&lt;16)|(uint32_t)bits;</span>
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :     /* write back the updated pointers */
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     pArgs-&gt;source=source;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     pArgs-&gt;target=(char *)target;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     pArgs-&gt;offsets=offsets;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1447 </span>            : }
<span class="lineNum">    1448 </span>            : U_CDECL_END
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            : static const UConverterImpl _IMAPImpl={
<span class="lineNum">    1451 </span>            :     UCNV_IMAP_MAILBOX,
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            :     NULL,
<span class="lineNum">    1454 </span>            :     NULL,
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            :     _UTF7Open,
<span class="lineNum">    1457 </span>            :     NULL,
<span class="lineNum">    1458 </span>            :     _UTF7Reset,
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :     _IMAPToUnicodeWithOffsets,
<span class="lineNum">    1461 </span>            :     _IMAPToUnicodeWithOffsets,
<span class="lineNum">    1462 </span>            :     _IMAPFromUnicodeWithOffsets,
<span class="lineNum">    1463 </span>            :     _IMAPFromUnicodeWithOffsets,
<span class="lineNum">    1464 </span>            :     NULL,
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            :     NULL,
<span class="lineNum">    1467 </span>            :     NULL,
<span class="lineNum">    1468 </span>            :     NULL, /* we don't need writeSub() because we never call a callback at fromUnicode() */
<span class="lineNum">    1469 </span>            :     NULL,
<span class="lineNum">    1470 </span>            :     ucnv_getCompleteUnicodeSet,
<span class="lineNum">    1471 </span>            :     NULL,
<span class="lineNum">    1472 </span>            :     NULL
<span class="lineNum">    1473 </span>            : };
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            : static const UConverterStaticData _IMAPStaticData={
<span class="lineNum">    1476 </span>            :     sizeof(UConverterStaticData),
<span class="lineNum">    1477 </span>            :     &quot;IMAP-mailbox-name&quot;,
<span class="lineNum">    1478 </span>            :     0, /* TODO CCSID for IMAP-mailbox-name */
<span class="lineNum">    1479 </span>            :     UCNV_IBM, UCNV_IMAP_MAILBOX,
<span class="lineNum">    1480 </span>            :     1, 4,
<span class="lineNum">    1481 </span>            :     { 0x3f, 0, 0, 0 }, 1, /* the subchar is not used */
<span class="lineNum">    1482 </span>            :     FALSE, FALSE,
<span class="lineNum">    1483 </span>            :     0,
<span class="lineNum">    1484 </span>            :     0,
<span class="lineNum">    1485 </span>            :     { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } /* reserved */
<span class="lineNum">    1486 </span>            : };
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            : const UConverterSharedData _IMAPData=
<span class="lineNum">    1489 </span>            :         UCNV_IMMUTABLE_SHARED_DATA_INITIALIZER(&amp;_IMAPStaticData, &amp;_IMAPImpl);
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

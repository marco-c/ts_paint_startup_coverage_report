<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/uhash.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - uhash.cpp<span style="font-size: 80%;"> (source / <a href="uhash.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">119</td>
            <td class="headerCovTableEntry">351</td>
            <td class="headerCovTableEntryLo">33.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryLo">30.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : ******************************************************************************
<span class="lineNum">       5 </span>            : *   Copyright (C) 1997-2016, International Business Machines
<span class="lineNum">       6 </span>            : *   Corporation and others.  All Rights Reserved.
<span class="lineNum">       7 </span>            : ******************************************************************************
<span class="lineNum">       8 </span>            : *   Date        Name        Description
<span class="lineNum">       9 </span>            : *   03/22/00    aliu        Adapted from original C++ ICU Hashtable.
<span class="lineNum">      10 </span>            : *   07/06/01    aliu        Modified to support int32_t keys on
<span class="lineNum">      11 </span>            : *                           platforms with sizeof(void*) &lt; 32.
<span class="lineNum">      12 </span>            : ******************************************************************************
<span class="lineNum">      13 </span>            : */
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;uhash.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;unicode/ustring.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;cstring.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;ustr_imp.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /* This hashtable is implemented as a double hash.  All elements are
<span class="lineNum">      23 </span>            :  * stored in a single array with no secondary storage for collision
<span class="lineNum">      24 </span>            :  * resolution (no linked list, etc.).  When there is a hash collision
<span class="lineNum">      25 </span>            :  * (when two unequal keys have the same hashcode) we resolve this by
<span class="lineNum">      26 </span>            :  * using a secondary hash.  The secondary hash is an increment
<span class="lineNum">      27 </span>            :  * computed as a hash function (a different one) of the primary
<span class="lineNum">      28 </span>            :  * hashcode.  This increment is added to the initial hash value to
<span class="lineNum">      29 </span>            :  * obtain further slots assigned to the same hash code.  For this to
<span class="lineNum">      30 </span>            :  * work, the length of the array and the increment must be relatively
<span class="lineNum">      31 </span>            :  * prime.  The easiest way to achieve this is to have the length of
<span class="lineNum">      32 </span>            :  * the array be prime, and the increment be any value from
<span class="lineNum">      33 </span>            :  * 1..length-1.
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  * Hashcodes are 32-bit integers.  We make sure all hashcodes are
<span class="lineNum">      36 </span>            :  * non-negative by masking off the top bit.  This has two effects: (1)
<span class="lineNum">      37 </span>            :  * modulo arithmetic is simplified.  If we allowed negative hashcodes,
<span class="lineNum">      38 </span>            :  * then when we computed hashcode % length, we could get a negative
<span class="lineNum">      39 </span>            :  * result, which we would then have to adjust back into range.  It's
<span class="lineNum">      40 </span>            :  * simpler to just make hashcodes non-negative. (2) It makes it easy
<span class="lineNum">      41 </span>            :  * to check for empty vs. occupied slots in the table.  We just mark
<span class="lineNum">      42 </span>            :  * empty or deleted slots with a negative hashcode.
<span class="lineNum">      43 </span>            :  *
<span class="lineNum">      44 </span>            :  * The central function is _uhash_find().  This function looks for a
<span class="lineNum">      45 </span>            :  * slot matching the given key and hashcode.  If one is found, it
<span class="lineNum">      46 </span>            :  * returns a pointer to that slot.  If the table is full, and no match
<span class="lineNum">      47 </span>            :  * is found, it returns NULL -- in theory.  This would make the code
<span class="lineNum">      48 </span>            :  * more complicated, since all callers of _uhash_find() would then
<span class="lineNum">      49 </span>            :  * have to check for a NULL result.  To keep this from happening, we
<span class="lineNum">      50 </span>            :  * don't allow the table to fill.  When there is only one
<span class="lineNum">      51 </span>            :  * empty/deleted slot left, uhash_put() will refuse to increase the
<span class="lineNum">      52 </span>            :  * count, and fail.  This simplifies the code.  In practice, one will
<span class="lineNum">      53 </span>            :  * seldom encounter this using default UHashtables.  However, if a
<span class="lineNum">      54 </span>            :  * hashtable is set to a U_FIXED resize policy, or if memory is
<span class="lineNum">      55 </span>            :  * exhausted, then the table may fill.
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  * High and low water ratios control rehashing.  They establish levels
<span class="lineNum">      58 </span>            :  * of fullness (from 0 to 1) outside of which the data array is
<span class="lineNum">      59 </span>            :  * reallocated and repopulated.  Setting the low water ratio to zero
<span class="lineNum">      60 </span>            :  * means the table will never shrink.  Setting the high water ratio to
<span class="lineNum">      61 </span>            :  * one means the table will never grow.  The ratios should be
<span class="lineNum">      62 </span>            :  * coordinated with the ratio between successive elements of the
<span class="lineNum">      63 </span>            :  * PRIMES table, so that when the primeIndex is incremented or
<span class="lineNum">      64 </span>            :  * decremented during rehashing, it brings the ratio of count / length
<span class="lineNum">      65 </span>            :  * back into the desired range (between low and high water ratios).
<span class="lineNum">      66 </span>            :  */
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : /********************************************************************
<span class="lineNum">      69 </span>            :  * PRIVATE Constants, Macros
<span class="lineNum">      70 </span>            :  ********************************************************************/
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* This is a list of non-consecutive primes chosen such that
<span class="lineNum">      73 </span>            :  * PRIMES[i+1] ~ 2*PRIMES[i].  (Currently, the ratio ranges from 1.81
<span class="lineNum">      74 </span>            :  * to 2.18; the inverse ratio ranges from 0.459 to 0.552.)  If this
<span class="lineNum">      75 </span>            :  * ratio is changed, the low and high water ratios should also be
<span class="lineNum">      76 </span>            :  * adjusted to suit.
<span class="lineNum">      77 </span>            :  *
<span class="lineNum">      78 </span>            :  * These prime numbers were also chosen so that they are the largest
<span class="lineNum">      79 </span>            :  * prime number while being less than a power of two.
<span class="lineNum">      80 </span>            :  */
<span class="lineNum">      81 </span>            : static const int32_t PRIMES[] = {
<span class="lineNum">      82 </span>            :     13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749,
<span class="lineNum">      83 </span>            :     65521, 131071, 262139, 524287, 1048573, 2097143, 4194301, 8388593,
<span class="lineNum">      84 </span>            :     16777213, 33554393, 67108859, 134217689, 268435399, 536870909,
<span class="lineNum">      85 </span>            :     1073741789, 2147483647 /*, 4294967291 */
<span class="lineNum">      86 </span>            : };
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : #define PRIMES_LENGTH UPRV_LENGTHOF(PRIMES)
<span class="lineNum">      89 </span>            : #define DEFAULT_PRIME_INDEX 3
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : /* These ratios are tuned to the PRIMES array such that a resize
<span class="lineNum">      92 </span>            :  * places the table back into the zone of non-resizing.  That is,
<span class="lineNum">      93 </span>            :  * after a call to _uhash_rehash(), a subsequent call to
<span class="lineNum">      94 </span>            :  * _uhash_rehash() should do nothing (should not churn).  This is only
<span class="lineNum">      95 </span>            :  * a potential problem with U_GROW_AND_SHRINK.
<span class="lineNum">      96 </span>            :  */
<span class="lineNum">      97 </span>            : static const float RESIZE_POLICY_RATIO_TABLE[6] = {
<span class="lineNum">      98 </span>            :     /* low, high water ratio */
<span class="lineNum">      99 </span>            :     0.0F, 0.5F, /* U_GROW: Grow on demand, do not shrink */
<span class="lineNum">     100 </span>            :     0.1F, 0.5F, /* U_GROW_AND_SHRINK: Grow and shrink on demand */
<span class="lineNum">     101 </span>            :     0.0F, 1.0F  /* U_FIXED: Never change size */
<span class="lineNum">     102 </span>            : };
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : /*
<span class="lineNum">     105 </span>            :   Invariants for hashcode values:
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   * DELETED &lt; 0
<span class="lineNum">     108 </span>            :   * EMPTY &lt; 0
<span class="lineNum">     109 </span>            :   * Real hashes &gt;= 0
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   Hashcodes may not start out this way, but internally they are
<span class="lineNum">     112 </span>            :   adjusted so that they are always positive.  We assume 32-bit
<span class="lineNum">     113 </span>            :   hashcodes; adjust these constants for other hashcode sizes.
<span class="lineNum">     114 </span>            : */
<span class="lineNum">     115 </span>            : #define HASH_DELETED    ((int32_t) 0x80000000)
<span class="lineNum">     116 </span>            : #define HASH_EMPTY      ((int32_t) HASH_DELETED + 1)
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : #define IS_EMPTY_OR_DELETED(x) ((x) &lt; 0)
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : /* This macro expects a UHashTok.pointer as its keypointer and
<span class="lineNum">     121 </span>            :    valuepointer parameters */
<span class="lineNum">     122 </span>            : #define HASH_DELETE_KEY_VALUE(hash, keypointer, valuepointer) \
<span class="lineNum">     123 </span>            :             if (hash-&gt;keyDeleter != NULL &amp;&amp; keypointer != NULL) { \
<span class="lineNum">     124 </span>            :                 (*hash-&gt;keyDeleter)(keypointer); \
<span class="lineNum">     125 </span>            :             } \
<span class="lineNum">     126 </span>            :             if (hash-&gt;valueDeleter != NULL &amp;&amp; valuepointer != NULL) { \
<span class="lineNum">     127 </span>            :                 (*hash-&gt;valueDeleter)(valuepointer); \
<span class="lineNum">     128 </span>            :             }
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /*
<span class="lineNum">     131 </span>            :  * Constants for hinting whether a key or value is an integer
<span class="lineNum">     132 </span>            :  * or a pointer.  If a hint bit is zero, then the associated
<span class="lineNum">     133 </span>            :  * token is assumed to be an integer.
<span class="lineNum">     134 </span>            :  */
<span class="lineNum">     135 </span>            : #define HINT_KEY_POINTER   (1)
<span class="lineNum">     136 </span>            : #define HINT_VALUE_POINTER (2)
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /********************************************************************
<span class="lineNum">     139 </span>            :  * PRIVATE Implementation
<span class="lineNum">     140 </span>            :  ********************************************************************/
<a name="141"><span class="lineNum">     141 </span>            : </a>
<span class="lineNum">     142 </span>            : static UHashTok
<span class="lineNum">     143 </span><span class="lineCov">          9 : _uhash_setElement(UHashtable *hash, UHashElement* e,</span>
<span class="lineNum">     144 </span>            :                   int32_t hashcode,
<span class="lineNum">     145 </span>            :                   UHashTok key, UHashTok value, int8_t hint) {
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov">          9 :     UHashTok oldValue = e-&gt;value;</span>
<span class="lineNum">     148 </span><span class="lineCov">          9 :     if (hash-&gt;keyDeleter != NULL &amp;&amp; e-&gt;key.pointer != NULL &amp;&amp;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         e-&gt;key.pointer != key.pointer) { /* Avoid double deletion */</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         (*hash-&gt;keyDeleter)(e-&gt;key.pointer);</span>
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span><span class="lineCov">          9 :     if (hash-&gt;valueDeleter != NULL) {</span>
<span class="lineNum">     153 </span><span class="lineCov">          8 :         if (oldValue.pointer != NULL &amp;&amp;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             oldValue.pointer != value.pointer) { /* Avoid double deletion */</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             (*hash-&gt;valueDeleter)(oldValue.pointer);</span>
<span class="lineNum">     156 </span>            :         }
<span class="lineNum">     157 </span><span class="lineCov">          8 :         oldValue.pointer = NULL;</span>
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span>            :     /* Compilers should copy the UHashTok union correctly, but even if
<span class="lineNum">     160 </span>            :      * they do, memory heap tools (e.g. BoundsChecker) can get
<span class="lineNum">     161 </span>            :      * confused when a pointer is cloaked in a union and then copied.
<span class="lineNum">     162 </span>            :      * TO ALLEVIATE THIS, we use hints (based on what API the user is
<span class="lineNum">     163 </span>            :      * calling) to copy pointers when we know the user thinks
<span class="lineNum">     164 </span>            :      * something is a pointer. */
<span class="lineNum">     165 </span><span class="lineCov">          9 :     if (hint &amp; HINT_KEY_POINTER) {</span>
<span class="lineNum">     166 </span><span class="lineCov">          9 :         e-&gt;key.pointer = key.pointer;</span>
<span class="lineNum">     167 </span>            :     } else {
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         e-&gt;key = key;</span>
<span class="lineNum">     169 </span>            :     }
<span class="lineNum">     170 </span><span class="lineCov">          9 :     if (hint &amp; HINT_VALUE_POINTER) {</span>
<span class="lineNum">     171 </span><span class="lineCov">          9 :         e-&gt;value.pointer = value.pointer;</span>
<span class="lineNum">     172 </span>            :     } else {
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :         e-&gt;value = value;</span>
<span class="lineNum">     174 </span>            :     }
<span class="lineNum">     175 </span><span class="lineCov">          9 :     e-&gt;hashcode = hashcode;</span>
<span class="lineNum">     176 </span><span class="lineCov">          9 :     return oldValue;</span>
<span class="lineNum">     177 </span>            : }
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /**
<span class="lineNum">     180 </span>            :  * Assumes that the given element is not empty or deleted.
<a name="181"><span class="lineNum">     181 </span>            :  */</a>
<span class="lineNum">     182 </span>            : static UHashTok
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : _uhash_internalRemoveElement(UHashtable *hash, UHashElement* e) {</span>
<span class="lineNum">     184 </span>            :     UHashTok empty;
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     U_ASSERT(!IS_EMPTY_OR_DELETED(e-&gt;hashcode));</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     --hash-&gt;count;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     empty.pointer = NULL; empty.integer = 0;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     return _uhash_setElement(hash, e, HASH_DELETED, empty, empty, 0);</span>
<span class="lineNum">     189 </span>            : }
<a name="190"><span class="lineNum">     190 </span>            : </a>
<span class="lineNum">     191 </span>            : static void
<span class="lineNum">     192 </span><span class="lineCov">          9 : _uhash_internalSetResizePolicy(UHashtable *hash, enum UHashResizePolicy policy) {</span>
<span class="lineNum">     193 </span><span class="lineCov">          9 :     U_ASSERT(hash != NULL);</span>
<span class="lineNum">     194 </span><span class="lineCov">          9 :     U_ASSERT(((int32_t)policy) &gt;= 0);</span>
<span class="lineNum">     195 </span><span class="lineCov">          9 :     U_ASSERT(((int32_t)policy) &lt; 3);</span>
<span class="lineNum">     196 </span><span class="lineCov">          9 :     hash-&gt;lowWaterRatio  = RESIZE_POLICY_RATIO_TABLE[policy * 2];</span>
<span class="lineNum">     197 </span><span class="lineCov">          9 :     hash-&gt;highWaterRatio = RESIZE_POLICY_RATIO_TABLE[policy * 2 + 1];</span>
<span class="lineNum">     198 </span><span class="lineCov">          9 : }</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /**
<span class="lineNum">     201 </span>            :  * Allocate internal data array of a size determined by the given
<span class="lineNum">     202 </span>            :  * prime index.  If the index is out of range it is pinned into range.
<span class="lineNum">     203 </span>            :  * If the allocation fails the status is set to
<span class="lineNum">     204 </span>            :  * U_MEMORY_ALLOCATION_ERROR and all array storage is freed.  In
<span class="lineNum">     205 </span>            :  * either case the previous array pointer is overwritten.
<span class="lineNum">     206 </span>            :  *
<span class="lineNum">     207 </span>            :  * Caller must ensure primeIndex is in range 0..PRIME_LENGTH-1.
<a name="208"><span class="lineNum">     208 </span>            :  */</a>
<span class="lineNum">     209 </span>            : static void
<span class="lineNum">     210 </span><span class="lineCov">          9 : _uhash_allocate(UHashtable *hash,</span>
<span class="lineNum">     211 </span>            :                 int32_t primeIndex,
<span class="lineNum">     212 </span>            :                 UErrorCode *status) {
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :     UHashElement *p, *limit;
<span class="lineNum">     215 </span>            :     UHashTok emptytok;
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) return;</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineCov">          9 :     U_ASSERT(primeIndex &gt;= 0 &amp;&amp; primeIndex &lt; PRIMES_LENGTH);</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineCov">          9 :     hash-&gt;primeIndex = primeIndex;</span>
<span class="lineNum">     222 </span><span class="lineCov">          9 :     hash-&gt;length = PRIMES[primeIndex];</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">          9 :     p = hash-&gt;elements = (UHashElement*)</span>
<span class="lineNum">     225 </span><span class="lineCov">          9 :         uprv_malloc(sizeof(UHashElement) * hash-&gt;length);</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineCov">          9 :     if (hash-&gt;elements == NULL) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     230 </span>            :     }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineCov">          9 :     emptytok.pointer = NULL; /* Only one of these two is needed */</span>
<span class="lineNum">     233 </span><span class="lineCov">          9 :     emptytok.integer = 0;    /* but we don't know which one. */</span>
<span class="lineNum">     234 </span>            :     
<span class="lineNum">     235 </span><span class="lineCov">          9 :     limit = p + hash-&gt;length;</span>
<span class="lineNum">     236 </span><span class="lineCov">       2295 :     while (p &lt; limit) {</span>
<span class="lineNum">     237 </span><span class="lineCov">       1143 :         p-&gt;key = emptytok;</span>
<span class="lineNum">     238 </span><span class="lineCov">       1143 :         p-&gt;value = emptytok;</span>
<span class="lineNum">     239 </span><span class="lineCov">       1143 :         p-&gt;hashcode = HASH_EMPTY;</span>
<span class="lineNum">     240 </span><span class="lineCov">       1143 :         ++p;</span>
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineCov">          9 :     hash-&gt;count = 0;</span>
<span class="lineNum">     244 </span><span class="lineCov">          9 :     hash-&gt;lowWaterMark = (int32_t)(hash-&gt;length * hash-&gt;lowWaterRatio);</span>
<span class="lineNum">     245 </span><span class="lineCov">          9 :     hash-&gt;highWaterMark = (int32_t)(hash-&gt;length * hash-&gt;highWaterRatio);</span>
<span class="lineNum">     246 </span>            : }
<a name="247"><span class="lineNum">     247 </span>            : </a>
<span class="lineNum">     248 </span>            : static UHashtable*
<span class="lineNum">     249 </span><span class="lineCov">          9 : _uhash_init(UHashtable *result,</span>
<span class="lineNum">     250 </span>            :               UHashFunction *keyHash, 
<span class="lineNum">     251 </span>            :               UKeyComparator *keyComp,
<span class="lineNum">     252 </span>            :               UValueComparator *valueComp,
<span class="lineNum">     253 </span>            :               int32_t primeIndex,
<span class="lineNum">     254 </span>            :               UErrorCode *status)
<span class="lineNum">     255 </span>            : {
<span class="lineNum">     256 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) return NULL;</span>
<span class="lineNum">     257 </span><span class="lineCov">          9 :     U_ASSERT(keyHash != NULL);</span>
<span class="lineNum">     258 </span><span class="lineCov">          9 :     U_ASSERT(keyComp != NULL);</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">          9 :     result-&gt;keyHasher       = keyHash;</span>
<span class="lineNum">     261 </span><span class="lineCov">          9 :     result-&gt;keyComparator   = keyComp;</span>
<span class="lineNum">     262 </span><span class="lineCov">          9 :     result-&gt;valueComparator = valueComp;</span>
<span class="lineNum">     263 </span><span class="lineCov">          9 :     result-&gt;keyDeleter      = NULL;</span>
<span class="lineNum">     264 </span><span class="lineCov">          9 :     result-&gt;valueDeleter    = NULL;</span>
<span class="lineNum">     265 </span><span class="lineCov">          9 :     result-&gt;allocated       = FALSE;</span>
<span class="lineNum">     266 </span><span class="lineCov">          9 :     _uhash_internalSetResizePolicy(result, U_GROW);</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">          9 :     _uhash_allocate(result, primeIndex, status);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineCov">          9 :     return result;</span>
<span class="lineNum">     275 </span>            : }
<a name="276"><span class="lineNum">     276 </span>            : </a>
<span class="lineNum">     277 </span>            : static UHashtable*
<span class="lineNum">     278 </span><span class="lineCov">          9 : _uhash_create(UHashFunction *keyHash, </span>
<span class="lineNum">     279 </span>            :               UKeyComparator *keyComp,
<span class="lineNum">     280 </span>            :               UValueComparator *valueComp,
<span class="lineNum">     281 </span>            :               int32_t primeIndex,
<span class="lineNum">     282 </span>            :               UErrorCode *status) {
<span class="lineNum">     283 </span>            :     UHashtable *result;
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) return NULL;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineCov">          9 :     result = (UHashtable*) uprv_malloc(sizeof(UHashtable));</span>
<span class="lineNum">     288 </span><span class="lineCov">          9 :     if (result == NULL) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineCov">          9 :     _uhash_init(result, keyHash, keyComp, valueComp, primeIndex, status);</span>
<span class="lineNum">     294 </span><span class="lineCov">          9 :     result-&gt;allocated       = TRUE;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) {</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         uprv_free(result);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">          9 :     return result;</span>
<span class="lineNum">     302 </span>            : }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /**
<span class="lineNum">     305 </span>            :  * Look for a key in the table, or if no such key exists, the first
<span class="lineNum">     306 </span>            :  * empty slot matching the given hashcode.  Keys are compared using
<span class="lineNum">     307 </span>            :  * the keyComparator function.
<span class="lineNum">     308 </span>            :  *
<span class="lineNum">     309 </span>            :  * First find the start position, which is the hashcode modulo
<span class="lineNum">     310 </span>            :  * the length.  Test it to see if it is:
<span class="lineNum">     311 </span>            :  *
<span class="lineNum">     312 </span>            :  * a. identical:  First check the hash values for a quick check,
<span class="lineNum">     313 </span>            :  *    then compare keys for equality using keyComparator.
<span class="lineNum">     314 </span>            :  * b. deleted
<span class="lineNum">     315 </span>            :  * c. empty
<span class="lineNum">     316 </span>            :  *
<span class="lineNum">     317 </span>            :  * Stop if it is identical or empty, otherwise continue by adding a
<span class="lineNum">     318 </span>            :  * &quot;jump&quot; value (moduloing by the length again to keep it within
<span class="lineNum">     319 </span>            :  * range) and retesting.  For efficiency, there need enough empty
<span class="lineNum">     320 </span>            :  * values so that the searchs stop within a reasonable amount of time.
<span class="lineNum">     321 </span>            :  * This can be changed by changing the high/low water marks.
<span class="lineNum">     322 </span>            :  *
<span class="lineNum">     323 </span>            :  * In theory, this function can return NULL, if it is full (no empty
<span class="lineNum">     324 </span>            :  * or deleted slots) and if no matching key is found.  In practice, we
<span class="lineNum">     325 </span>            :  * prevent this elsewhere (in uhash_put) by making sure the last slot
<span class="lineNum">     326 </span>            :  * in the table is never filled.
<span class="lineNum">     327 </span>            :  *
<span class="lineNum">     328 </span>            :  * The size of the table should be prime for this algorithm to work;
<span class="lineNum">     329 </span>            :  * otherwise we are not guaranteed that the jump value (the secondary
<span class="lineNum">     330 </span>            :  * hash) is relatively prime to the table length.
<a name="331"><span class="lineNum">     331 </span>            :  */</a>
<span class="lineNum">     332 </span>            : static UHashElement*
<span class="lineNum">     333 </span><span class="lineCov">         28 : _uhash_find(const UHashtable *hash, UHashTok key,</span>
<span class="lineNum">     334 </span>            :             int32_t hashcode) {
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">         28 :     int32_t firstDeleted = -1;  /* assume invalid index */</span>
<span class="lineNum">     337 </span>            :     int32_t theIndex, startIndex;
<span class="lineNum">     338 </span><span class="lineCov">         28 :     int32_t jump = 0; /* lazy evaluate */</span>
<span class="lineNum">     339 </span>            :     int32_t tableHash;
<span class="lineNum">     340 </span><span class="lineCov">         28 :     UHashElement *elements = hash-&gt;elements;</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineCov">         28 :     hashcode &amp;= 0x7FFFFFFF; /* must be positive */</span>
<span class="lineNum">     343 </span><span class="lineCov">         28 :     startIndex = theIndex = (hashcode ^ 0x4000000) % hash-&gt;length;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     346 </span><span class="lineCov">         28 :         tableHash = elements[theIndex].hashcode;</span>
<span class="lineNum">     347 </span><span class="lineCov">         28 :         if (tableHash == hashcode) {          /* quick check */</span>
<span class="lineNum">     348 </span><span class="lineCov">          6 :             if ((*hash-&gt;keyComparator)(key, elements[theIndex].key)) {</span>
<span class="lineNum">     349 </span><span class="lineCov">          6 :                 return &amp;(elements[theIndex]);</span>
<span class="lineNum">     350 </span>            :             }
<span class="lineNum">     351 </span><span class="lineCov">         22 :         } else if (!IS_EMPTY_OR_DELETED(tableHash)) {</span>
<span class="lineNum">     352 </span>            :             /* We have hit a slot which contains a key-value pair,
<span class="lineNum">     353 </span>            :              * but for which the hash code does not match.  Keep
<span class="lineNum">     354 </span>            :              * looking.
<span class="lineNum">     355 </span>            :              */
<span class="lineNum">     356 </span><span class="lineCov">         22 :         } else if (tableHash == HASH_EMPTY) { /* empty, end o' the line */</span>
<span class="lineNum">     357 </span><span class="lineCov">         22 :             break;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         } else if (firstDeleted &lt; 0) { /* remember first deleted */</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             firstDeleted = theIndex;</span>
<span class="lineNum">     360 </span>            :         }
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         if (jump == 0) { /* lazy compute jump */</span>
<span class="lineNum">     362 </span>            :             /* The jump value must be relatively prime to the table
<span class="lineNum">     363 </span>            :              * length.  As long as the length is prime, then any value
<span class="lineNum">     364 </span>            :              * 1..length-1 will be relatively prime to it.
<span class="lineNum">     365 </span>            :              */
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :             jump = (hashcode % (hash-&gt;length - 1)) + 1;</span>
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         theIndex = (theIndex + jump) % hash-&gt;length;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     } while (theIndex != startIndex);</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineCov">         22 :     if (firstDeleted &gt;= 0) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         theIndex = firstDeleted; /* reset if had deleted slot */</span>
<span class="lineNum">     373 </span><span class="lineCov">         22 :     } else if (tableHash != HASH_EMPTY) {</span>
<span class="lineNum">     374 </span>            :         /* We get to this point if the hashtable is full (no empty or
<span class="lineNum">     375 </span>            :          * deleted slots), and we've failed to find a match.  THIS
<span class="lineNum">     376 </span>            :          * WILL NEVER HAPPEN as long as uhash_put() makes sure that
<span class="lineNum">     377 </span>            :          * count is always &lt; length.
<span class="lineNum">     378 </span>            :          */
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         U_ASSERT(FALSE);</span>
<span class="lineNum">     380 </span>            :         return NULL; /* Never happens if uhash_put() behaves */
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span><span class="lineCov">         22 :     return &amp;(elements[theIndex]);</span>
<span class="lineNum">     383 </span>            : }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : /**
<span class="lineNum">     386 </span>            :  * Attempt to grow or shrink the data arrays in order to make the
<span class="lineNum">     387 </span>            :  * count fit between the high and low water marks.  hash_put() and
<span class="lineNum">     388 </span>            :  * hash_remove() call this method when the count exceeds the high or
<span class="lineNum">     389 </span>            :  * low water marks.  This method may do nothing, if memory allocation
<span class="lineNum">     390 </span>            :  * fails, or if the count is already in range, or if the length is
<span class="lineNum">     391 </span>            :  * already at the low or high limit.  In any case, upon return the
<span class="lineNum">     392 </span>            :  * arrays will be valid.
<a name="393"><span class="lineNum">     393 </span>            :  */</a>
<span class="lineNum">     394 </span>            : static void
<span class="lineNum">     395 </span><span class="lineNoCov">          0 : _uhash_rehash(UHashtable *hash, UErrorCode *status) {</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     UHashElement *old = hash-&gt;elements;</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     int32_t oldLength = hash-&gt;length;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     int32_t newPrimeIndex = hash-&gt;primeIndex;</span>
<span class="lineNum">     400 </span>            :     int32_t i;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (hash-&gt;count &gt; hash-&gt;highWaterMark) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         if (++newPrimeIndex &gt;= PRIMES_LENGTH) {</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     } else if (hash-&gt;count &lt; hash-&gt;lowWaterMark) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         if (--newPrimeIndex &lt; 0) {</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     409 </span>            :         }
<span class="lineNum">     410 </span>            :     } else {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     412 </span>            :     }
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     _uhash_allocate(hash, newPrimeIndex, status);</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     if (U_FAILURE(*status)) {</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :         hash-&gt;elements = old;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         hash-&gt;length = oldLength;       </span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     420 </span>            :     }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     for (i = oldLength - 1; i &gt;= 0; --i) {</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         if (!IS_EMPTY_OR_DELETED(old[i].hashcode)) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :             UHashElement *e = _uhash_find(hash, old[i].key, old[i].hashcode);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             U_ASSERT(e != NULL);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             U_ASSERT(e-&gt;hashcode == HASH_EMPTY);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :             e-&gt;key = old[i].key;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :             e-&gt;value = old[i].value;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             e-&gt;hashcode = old[i].hashcode;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :             ++hash-&gt;count;</span>
<span class="lineNum">     431 </span>            :         }
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     uprv_free(old);</span>
<span class="lineNum">     435 </span>            : }
<a name="436"><span class="lineNum">     436 </span>            : </a>
<span class="lineNum">     437 </span>            : static UHashTok
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : _uhash_remove(UHashtable *hash,</span>
<span class="lineNum">     439 </span>            :               UHashTok key) {
<span class="lineNum">     440 </span>            :     /* First find the position of the key in the table.  If the object
<span class="lineNum">     441 </span>            :      * has not been removed already, remove it.  If the user wanted
<span class="lineNum">     442 </span>            :      * keys deleted, then delete it also.  We have to put a special
<span class="lineNum">     443 </span>            :      * hashcode in that position that means that something has been
<span class="lineNum">     444 </span>            :      * deleted, since when we do a find, we have to continue PAST any
<span class="lineNum">     445 </span>            :      * deleted values.
<span class="lineNum">     446 </span>            :      */
<span class="lineNum">     447 </span>            :     UHashTok result;
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     UHashElement* e = _uhash_find(hash, key, hash-&gt;keyHasher(key));</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     U_ASSERT(e != NULL);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     result.pointer = NULL;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     result.integer = 0;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     if (!IS_EMPTY_OR_DELETED(e-&gt;hashcode)) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         result = _uhash_internalRemoveElement(hash, e);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         if (hash-&gt;count &lt; hash-&gt;lowWaterMark) {</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :             UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :             _uhash_rehash(hash, &amp;status);</span>
<span class="lineNum">     457 </span>            :         }
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     460 </span>            : }
<a name="461"><span class="lineNum">     461 </span>            : </a>
<span class="lineNum">     462 </span>            : static UHashTok
<span class="lineNum">     463 </span><span class="lineCov">          9 : _uhash_put(UHashtable *hash,</span>
<span class="lineNum">     464 </span>            :            UHashTok key,
<span class="lineNum">     465 </span>            :            UHashTok value,
<span class="lineNum">     466 </span>            :            int8_t hint,
<span class="lineNum">     467 </span>            :            UErrorCode *status) {
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :     /* Put finds the position in the table for the new value.  If the
<span class="lineNum">     470 </span>            :      * key is already in the table, it is deleted, if there is a
<span class="lineNum">     471 </span>            :      * non-NULL keyDeleter.  Then the key, the hash and the value are
<span class="lineNum">     472 </span>            :      * all put at the position in their respective arrays.
<span class="lineNum">     473 </span>            :      */
<span class="lineNum">     474 </span>            :     int32_t hashcode;
<span class="lineNum">     475 </span>            :     UHashElement* e;
<span class="lineNum">     476 </span>            :     UHashTok emptytok;
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">          9 :     if (U_FAILURE(*status)) {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         goto err;</span>
<span class="lineNum">     480 </span>            :     }
<span class="lineNum">     481 </span><span class="lineCov">          9 :     U_ASSERT(hash != NULL);</span>
<span class="lineNum">     482 </span>            :     /* Cannot always check pointer here or iSeries sees NULL every time. */
<span class="lineNum">     483 </span><span class="lineCov">          9 :     if ((hint &amp; HINT_VALUE_POINTER) &amp;&amp; value.pointer == NULL) {</span>
<span class="lineNum">     484 </span>            :         /* Disallow storage of NULL values, since NULL is returned by
<span class="lineNum">     485 </span>            :          * get() to indicate an absent key.  Storing NULL == removing.
<span class="lineNum">     486 </span>            :          */
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         return _uhash_remove(hash, key);</span>
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span><span class="lineCov">          9 :     if (hash-&gt;count &gt; hash-&gt;highWaterMark) {</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         _uhash_rehash(hash, status);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :         if (U_FAILURE(*status)) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :             goto err;</span>
<span class="lineNum">     493 </span>            :         }
<span class="lineNum">     494 </span>            :     }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineCov">          9 :     hashcode = (*hash-&gt;keyHasher)(key);</span>
<span class="lineNum">     497 </span><span class="lineCov">          9 :     e = _uhash_find(hash, key, hashcode);</span>
<span class="lineNum">     498 </span><span class="lineCov">          9 :     U_ASSERT(e != NULL);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">          9 :     if (IS_EMPTY_OR_DELETED(e-&gt;hashcode)) {</span>
<span class="lineNum">     501 </span>            :         /* Important: We must never actually fill the table up.  If we
<span class="lineNum">     502 </span>            :          * do so, then _uhash_find() will return NULL, and we'll have
<span class="lineNum">     503 </span>            :          * to check for NULL after every call to _uhash_find().  To
<span class="lineNum">     504 </span>            :          * avoid this we make sure there is always at least one empty
<span class="lineNum">     505 </span>            :          * or deleted slot in the table.  This only is a problem if we
<span class="lineNum">     506 </span>            :          * are out of memory and rehash isn't working.
<span class="lineNum">     507 </span>            :          */
<span class="lineNum">     508 </span><span class="lineCov">          9 :         ++hash-&gt;count;</span>
<span class="lineNum">     509 </span><span class="lineCov">          9 :         if (hash-&gt;count == hash-&gt;length) {</span>
<span class="lineNum">     510 </span>            :             /* Don't allow count to reach length */
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             --hash-&gt;count;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :             *status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :             goto err;</span>
<span class="lineNum">     514 </span>            :         }
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     /* We must in all cases handle storage properly.  If there was an
<span class="lineNum">     518 </span>            :      * old key, then it must be deleted (if the deleter != NULL).
<span class="lineNum">     519 </span>            :      * Make hashcodes stored in table positive.
<span class="lineNum">     520 </span>            :      */
<span class="lineNum">     521 </span><span class="lineCov">          9 :     return _uhash_setElement(hash, e, hashcode &amp; 0x7FFFFFFF, key, value, hint);</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :  err:
<span class="lineNum">     524 </span>            :     /* If the deleters are non-NULL, this method adopts its key and/or
<span class="lineNum">     525 </span>            :      * value arguments, and we must be sure to delete the key and/or
<span class="lineNum">     526 </span>            :      * value in all cases, even upon failure.
<span class="lineNum">     527 </span>            :      */
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     HASH_DELETE_KEY_VALUE(hash, key.pointer, value.pointer);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     emptytok.pointer = NULL; emptytok.integer = 0;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     return emptytok;</span>
<span class="lineNum">     531 </span>            : }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /********************************************************************
<span class="lineNum">     535 </span>            :  * PUBLIC API
<span class="lineNum">     536 </span>            :  ********************************************************************/
<a name="537"><span class="lineNum">     537 </span>            : </a>
<span class="lineNum">     538 </span>            : U_CAPI UHashtable* U_EXPORT2
<span class="lineNum">     539 </span><span class="lineCov">          9 : uhash_open(UHashFunction *keyHash, </span>
<span class="lineNum">     540 </span>            :            UKeyComparator *keyComp,
<span class="lineNum">     541 </span>            :            UValueComparator *valueComp,
<span class="lineNum">     542 </span>            :            UErrorCode *status) {
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineCov">          9 :     return _uhash_create(keyHash, keyComp, valueComp, DEFAULT_PRIME_INDEX, status);</span>
<span class="lineNum">     545 </span>            : }
<a name="546"><span class="lineNum">     546 </span>            : </a>
<span class="lineNum">     547 </span>            : U_CAPI UHashtable* U_EXPORT2
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : uhash_openSize(UHashFunction *keyHash, </span>
<span class="lineNum">     549 </span>            :                UKeyComparator *keyComp,
<span class="lineNum">     550 </span>            :                UValueComparator *valueComp,
<span class="lineNum">     551 </span>            :                int32_t size,
<span class="lineNum">     552 </span>            :                UErrorCode *status) {
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :     /* Find the smallest index i for which PRIMES[i] &gt;= size. */
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     int32_t i = 0;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     while (i&lt;(PRIMES_LENGTH-1) &amp;&amp; PRIMES[i]&lt;size) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         ++i;</span>
<span class="lineNum">     558 </span>            :     }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     return _uhash_create(keyHash, keyComp, valueComp, i, status);</span>
<span class="lineNum">     561 </span>            : }
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : U_CAPI UHashtable* U_EXPORT2
<span class="lineNum">     564 </span><span class="lineNoCov">          0 : uhash_init(UHashtable *fillinResult,</span>
<span class="lineNum">     565 </span>            :            UHashFunction *keyHash, 
<span class="lineNum">     566 </span>            :            UKeyComparator *keyComp,
<span class="lineNum">     567 </span>            :            UValueComparator *valueComp,
<span class="lineNum">     568 </span>            :            UErrorCode *status) {
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     return _uhash_init(fillinResult, keyHash, keyComp, valueComp, DEFAULT_PRIME_INDEX, status);</span>
<span class="lineNum">     571 </span>            : }
<a name="572"><span class="lineNum">     572 </span>            : </a>
<span class="lineNum">     573 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     574 </span><span class="lineNoCov">          0 : uhash_close(UHashtable *hash) {</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     if (hash == NULL) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     577 </span>            :     }
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     if (hash-&gt;elements != NULL) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :         if (hash-&gt;keyDeleter != NULL || hash-&gt;valueDeleter != NULL) {</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :             int32_t pos=UHASH_FIRST;</span>
<span class="lineNum">     581 </span>            :             UHashElement *e;
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :             while ((e = (UHashElement*) uhash_nextElement(hash, &amp;pos)) != NULL) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 HASH_DELETE_KEY_VALUE(hash, e-&gt;key.pointer, e-&gt;value.pointer);</span>
<span class="lineNum">     584 </span>            :             }
<span class="lineNum">     585 </span>            :         }
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :         uprv_free(hash-&gt;elements);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         hash-&gt;elements = NULL;</span>
<span class="lineNum">     588 </span>            :     }
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     if (hash-&gt;allocated) {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         uprv_free(hash);</span>
<span class="lineNum">     591 </span>            :     }
<span class="lineNum">     592 </span>            : }
<a name="593"><span class="lineNum">     593 </span>            : </a>
<span class="lineNum">     594 </span>            : U_CAPI UHashFunction *U_EXPORT2
<span class="lineNum">     595 </span><span class="lineNoCov">          0 : uhash_setKeyHasher(UHashtable *hash, UHashFunction *fn) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     UHashFunction *result = hash-&gt;keyHasher;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     hash-&gt;keyHasher = fn;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     599 </span>            : }
<a name="600"><span class="lineNum">     600 </span>            : </a>
<span class="lineNum">     601 </span>            : U_CAPI UKeyComparator *U_EXPORT2
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : uhash_setKeyComparator(UHashtable *hash, UKeyComparator *fn) {</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     UKeyComparator *result = hash-&gt;keyComparator;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     hash-&gt;keyComparator = fn;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     return result;</span>
<a name="606"><span class="lineNum">     606 </span>            : }</a>
<span class="lineNum">     607 </span>            : U_CAPI UValueComparator *U_EXPORT2 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 : uhash_setValueComparator(UHashtable *hash, UValueComparator *fn){</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     UValueComparator *result = hash-&gt;valueComparator;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     hash-&gt;valueComparator = fn;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     612 </span>            : }
<a name="613"><span class="lineNum">     613 </span>            : </a>
<span class="lineNum">     614 </span>            : U_CAPI UObjectDeleter *U_EXPORT2
<span class="lineNum">     615 </span><span class="lineCov">          3 : uhash_setKeyDeleter(UHashtable *hash, UObjectDeleter *fn) {</span>
<span class="lineNum">     616 </span><span class="lineCov">          3 :     UObjectDeleter *result = hash-&gt;keyDeleter;</span>
<span class="lineNum">     617 </span><span class="lineCov">          3 :     hash-&gt;keyDeleter = fn;</span>
<span class="lineNum">     618 </span><span class="lineCov">          3 :     return result;</span>
<span class="lineNum">     619 </span>            : }
<a name="620"><span class="lineNum">     620 </span>            : </a>
<span class="lineNum">     621 </span>            : U_CAPI UObjectDeleter *U_EXPORT2
<span class="lineNum">     622 </span><span class="lineCov">          8 : uhash_setValueDeleter(UHashtable *hash, UObjectDeleter *fn) {</span>
<span class="lineNum">     623 </span><span class="lineCov">          8 :     UObjectDeleter *result = hash-&gt;valueDeleter;</span>
<span class="lineNum">     624 </span><span class="lineCov">          8 :     hash-&gt;valueDeleter = fn;</span>
<span class="lineNum">     625 </span><span class="lineCov">          8 :     return result;</span>
<span class="lineNum">     626 </span>            : }
<a name="627"><span class="lineNum">     627 </span>            : </a>
<span class="lineNum">     628 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     629 </span><span class="lineNoCov">          0 : uhash_setResizePolicy(UHashtable *hash, enum UHashResizePolicy policy) {</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     _uhash_internalSetResizePolicy(hash, policy);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     hash-&gt;lowWaterMark  = (int32_t)(hash-&gt;length * hash-&gt;lowWaterRatio);</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     hash-&gt;highWaterMark = (int32_t)(hash-&gt;length * hash-&gt;highWaterRatio);    </span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     _uhash_rehash(hash, &amp;status);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 : }</span>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<span class="lineNum">     637 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     638 </span><span class="lineNoCov">          0 : uhash_count(const UHashtable *hash) {</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     return hash-&gt;count;</span>
<span class="lineNum">     640 </span>            : }
<a name="641"><span class="lineNum">     641 </span>            : </a>
<span class="lineNum">     642 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     643 </span><span class="lineCov">         19 : uhash_get(const UHashtable *hash,</span>
<span class="lineNum">     644 </span>            :           const void* key) {
<span class="lineNum">     645 </span>            :     UHashTok keyholder;
<span class="lineNum">     646 </span><span class="lineCov">         19 :     keyholder.pointer = (void*) key;</span>
<span class="lineNum">     647 </span><span class="lineCov">         19 :     return _uhash_find(hash, keyholder, hash-&gt;keyHasher(keyholder))-&gt;value.pointer;</span>
<span class="lineNum">     648 </span>            : }
<a name="649"><span class="lineNum">     649 </span>            : </a>
<span class="lineNum">     650 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     651 </span><span class="lineNoCov">          0 : uhash_iget(const UHashtable *hash,</span>
<span class="lineNum">     652 </span>            :            int32_t key) {
<span class="lineNum">     653 </span>            :     UHashTok keyholder;
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     return _uhash_find(hash, keyholder, hash-&gt;keyHasher(keyholder))-&gt;value.pointer;</span>
<span class="lineNum">     656 </span>            : }
<a name="657"><span class="lineNum">     657 </span>            : </a>
<span class="lineNum">     658 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     659 </span><span class="lineNoCov">          0 : uhash_geti(const UHashtable *hash,</span>
<span class="lineNum">     660 </span>            :            const void* key) {
<span class="lineNum">     661 </span>            :     UHashTok keyholder;
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     keyholder.pointer = (void*) key;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     return _uhash_find(hash, keyholder, hash-&gt;keyHasher(keyholder))-&gt;value.integer;</span>
<span class="lineNum">     664 </span>            : }
<a name="665"><span class="lineNum">     665 </span>            : </a>
<span class="lineNum">     666 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     667 </span><span class="lineNoCov">          0 : uhash_igeti(const UHashtable *hash,</span>
<span class="lineNum">     668 </span>            :            int32_t key) {
<span class="lineNum">     669 </span>            :     UHashTok keyholder;
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     return _uhash_find(hash, keyholder, hash-&gt;keyHasher(keyholder))-&gt;value.integer;</span>
<span class="lineNum">     672 </span>            : }
<a name="673"><span class="lineNum">     673 </span>            : </a>
<span class="lineNum">     674 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     675 </span><span class="lineCov">          9 : uhash_put(UHashtable *hash,</span>
<span class="lineNum">     676 </span>            :           void* key,
<span class="lineNum">     677 </span>            :           void* value,
<span class="lineNum">     678 </span>            :           UErrorCode *status) {
<span class="lineNum">     679 </span>            :     UHashTok keyholder, valueholder;
<span class="lineNum">     680 </span><span class="lineCov">          9 :     keyholder.pointer = key;</span>
<span class="lineNum">     681 </span><span class="lineCov">          9 :     valueholder.pointer = value;</span>
<span class="lineNum">     682 </span><span class="lineCov">          9 :     return _uhash_put(hash, keyholder, valueholder,</span>
<span class="lineNum">     683 </span>            :                       HINT_KEY_POINTER | HINT_VALUE_POINTER,
<span class="lineNum">     684 </span><span class="lineCov">          9 :                       status).pointer;</span>
<span class="lineNum">     685 </span>            : }
<a name="686"><span class="lineNum">     686 </span>            : </a>
<span class="lineNum">     687 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     688 </span><span class="lineNoCov">          0 : uhash_iput(UHashtable *hash,</span>
<span class="lineNum">     689 </span>            :            int32_t key,
<span class="lineNum">     690 </span>            :            void* value,
<span class="lineNum">     691 </span>            :            UErrorCode *status) {
<span class="lineNum">     692 </span>            :     UHashTok keyholder, valueholder;
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     valueholder.pointer = value;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     return _uhash_put(hash, keyholder, valueholder,</span>
<span class="lineNum">     696 </span>            :                       HINT_VALUE_POINTER,
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                       status).pointer;</span>
<span class="lineNum">     698 </span>            : }
<a name="699"><span class="lineNum">     699 </span>            : </a>
<span class="lineNum">     700 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     701 </span><span class="lineNoCov">          0 : uhash_puti(UHashtable *hash,</span>
<span class="lineNum">     702 </span>            :            void* key,
<span class="lineNum">     703 </span>            :            int32_t value,
<span class="lineNum">     704 </span>            :            UErrorCode *status) {
<span class="lineNum">     705 </span>            :     UHashTok keyholder, valueholder;
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     keyholder.pointer = key;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     valueholder.integer = value;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     return _uhash_put(hash, keyholder, valueholder,</span>
<span class="lineNum">     709 </span>            :                       HINT_KEY_POINTER,
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                       status).integer;</span>
<span class="lineNum">     711 </span>            : }
<span class="lineNum">     712 </span>            : 
<a name="713"><span class="lineNum">     713 </span>            : </a>
<span class="lineNum">     714 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     715 </span><span class="lineNoCov">          0 : uhash_iputi(UHashtable *hash,</span>
<span class="lineNum">     716 </span>            :            int32_t key,
<span class="lineNum">     717 </span>            :            int32_t value,
<span class="lineNum">     718 </span>            :            UErrorCode *status) {
<span class="lineNum">     719 </span>            :     UHashTok keyholder, valueholder;
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     valueholder.integer = value;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     return _uhash_put(hash, keyholder, valueholder,</span>
<span class="lineNum">     723 </span>            :                       0, /* neither is a ptr */
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :                       status).integer;</span>
<span class="lineNum">     725 </span>            : }
<a name="726"><span class="lineNum">     726 </span>            : </a>
<span class="lineNum">     727 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     728 </span><span class="lineNoCov">          0 : uhash_remove(UHashtable *hash,</span>
<span class="lineNum">     729 </span>            :              const void* key) {
<span class="lineNum">     730 </span>            :     UHashTok keyholder;
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     keyholder.pointer = (void*) key;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     return _uhash_remove(hash, keyholder).pointer;</span>
<span class="lineNum">     733 </span>            : }
<a name="734"><span class="lineNum">     734 </span>            : </a>
<span class="lineNum">     735 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     736 </span><span class="lineNoCov">          0 : uhash_iremove(UHashtable *hash,</span>
<span class="lineNum">     737 </span>            :               int32_t key) {
<span class="lineNum">     738 </span>            :     UHashTok keyholder;
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     return _uhash_remove(hash, keyholder).pointer;</span>
<span class="lineNum">     741 </span>            : }
<a name="742"><span class="lineNum">     742 </span>            : </a>
<span class="lineNum">     743 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     744 </span><span class="lineNoCov">          0 : uhash_removei(UHashtable *hash,</span>
<span class="lineNum">     745 </span>            :               const void* key) {
<span class="lineNum">     746 </span>            :     UHashTok keyholder;
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     keyholder.pointer = (void*) key;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     return _uhash_remove(hash, keyholder).integer;</span>
<span class="lineNum">     749 </span>            : }
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     752 </span><span class="lineNoCov">          0 : uhash_iremovei(UHashtable *hash,</span>
<span class="lineNum">     753 </span>            :                int32_t key) {
<span class="lineNum">     754 </span>            :     UHashTok keyholder;
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     keyholder.integer = key;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     return _uhash_remove(hash, keyholder).integer;</span>
<span class="lineNum">     757 </span>            : }
<a name="758"><span class="lineNum">     758 </span>            : </a>
<span class="lineNum">     759 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     760 </span><span class="lineNoCov">          0 : uhash_removeAll(UHashtable *hash) {</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     int32_t pos = UHASH_FIRST;</span>
<span class="lineNum">     762 </span>            :     const UHashElement *e;
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     U_ASSERT(hash != NULL);</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     if (hash-&gt;count != 0) {</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         while ((e = uhash_nextElement(hash, &amp;pos)) != NULL) {</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :             uhash_removeElement(hash, e);</span>
<span class="lineNum">     767 </span>            :         }
<span class="lineNum">     768 </span>            :     }
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     U_ASSERT(hash-&gt;count == 0);</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 : }</span>
<a name="771"><span class="lineNum">     771 </span>            : </a>
<span class="lineNum">     772 </span>            : U_CAPI const UHashElement* U_EXPORT2
<span class="lineNum">     773 </span><span class="lineNoCov">          0 : uhash_find(const UHashtable *hash, const void* key) {</span>
<span class="lineNum">     774 </span>            :     UHashTok keyholder;
<span class="lineNum">     775 </span>            :     const UHashElement *e;
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     keyholder.pointer = (void*) key;</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     e = _uhash_find(hash, keyholder, hash-&gt;keyHasher(keyholder));</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     return IS_EMPTY_OR_DELETED(e-&gt;hashcode) ? NULL : e;</span>
<span class="lineNum">     779 </span>            : }
<a name="780"><span class="lineNum">     780 </span>            : </a>
<span class="lineNum">     781 </span>            : U_CAPI const UHashElement* U_EXPORT2
<span class="lineNum">     782 </span><span class="lineNoCov">          0 : uhash_nextElement(const UHashtable *hash, int32_t *pos) {</span>
<span class="lineNum">     783 </span>            :     /* Walk through the array until we find an element that is not
<span class="lineNum">     784 </span>            :      * EMPTY and not DELETED.
<span class="lineNum">     785 </span>            :      */
<span class="lineNum">     786 </span>            :     int32_t i;
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     U_ASSERT(hash != NULL);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     for (i = *pos + 1; i &lt; hash-&gt;length; ++i) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         if (!IS_EMPTY_OR_DELETED(hash-&gt;elements[i].hashcode)) {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :             *pos = i;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :             return &amp;(hash-&gt;elements[i]);</span>
<span class="lineNum">     792 </span>            :         }
<span class="lineNum">     793 </span>            :     }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     /* No more elements */
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     797 </span>            : }
<a name="798"><span class="lineNum">     798 </span>            : </a>
<span class="lineNum">     799 </span>            : U_CAPI void* U_EXPORT2
<span class="lineNum">     800 </span><span class="lineNoCov">          0 : uhash_removeElement(UHashtable *hash, const UHashElement* e) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     U_ASSERT(hash != NULL);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     U_ASSERT(e != NULL);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     if (!IS_EMPTY_OR_DELETED(e-&gt;hashcode)) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         UHashElement *nce = (UHashElement *)e;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         return _uhash_internalRemoveElement(hash, nce).pointer;</span>
<span class="lineNum">     806 </span>            :     }
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     808 </span>            : }
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : /********************************************************************
<span class="lineNum">     811 </span>            :  * UHashTok convenience
<span class="lineNum">     812 </span>            :  ********************************************************************/
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /**
<span class="lineNum">     815 </span>            :  * Return a UHashTok for an integer.
<span class="lineNum">     816 </span>            :  */
<span class="lineNum">     817 </span>            : /*U_CAPI UHashTok U_EXPORT2
<span class="lineNum">     818 </span>            : uhash_toki(int32_t i) {
<span class="lineNum">     819 </span>            :     UHashTok tok;
<span class="lineNum">     820 </span>            :     tok.integer = i;
<span class="lineNum">     821 </span>            :     return tok;
<span class="lineNum">     822 </span>            : }*/
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : /**
<span class="lineNum">     825 </span>            :  * Return a UHashTok for a pointer.
<span class="lineNum">     826 </span>            :  */
<span class="lineNum">     827 </span>            : /*U_CAPI UHashTok U_EXPORT2
<span class="lineNum">     828 </span>            : uhash_tokp(void* p) {
<span class="lineNum">     829 </span>            :     UHashTok tok;
<span class="lineNum">     830 </span>            :     tok.pointer = p;
<span class="lineNum">     831 </span>            :     return tok;
<span class="lineNum">     832 </span>            : }*/
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            : /********************************************************************
<span class="lineNum">     835 </span>            :  * PUBLIC Key Hash Functions
<span class="lineNum">     836 </span>            :  ********************************************************************/
<a name="837"><span class="lineNum">     837 </span>            : </a>
<span class="lineNum">     838 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     839 </span><span class="lineNoCov">          0 : uhash_hashUChars(const UHashTok key) {</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     const UChar *s = (const UChar *)key.pointer;</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     return s == NULL ? 0 : ustr_hashUCharsN(s, u_strlen(s));</span>
<span class="lineNum">     842 </span>            : }
<a name="843"><span class="lineNum">     843 </span>            : </a>
<span class="lineNum">     844 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     845 </span><span class="lineCov">         34 : uhash_hashChars(const UHashTok key) {</span>
<span class="lineNum">     846 </span><span class="lineCov">         34 :     const char *s = (const char *)key.pointer;</span>
<span class="lineNum">     847 </span><span class="lineCov">         34 :     return s == NULL ? 0 : ustr_hashCharsN(s, uprv_strlen(s));</span>
<span class="lineNum">     848 </span>            : }
<a name="849"><span class="lineNum">     849 </span>            : </a>
<span class="lineNum">     850 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     851 </span><span class="lineNoCov">          0 : uhash_hashIChars(const UHashTok key) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     const char *s = (const char *)key.pointer;</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     return s == NULL ? 0 : ustr_hashICharsN(s, uprv_strlen(s));</span>
<span class="lineNum">     854 </span>            : }
<a name="855"><span class="lineNum">     855 </span>            : </a>
<span class="lineNum">     856 </span>            : U_CAPI UBool U_EXPORT2 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 : uhash_equals(const UHashtable* hash1, const UHashtable* hash2){</span>
<span class="lineNum">     858 </span>            :     int32_t count1, count2, pos, i;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     if(hash1==hash2){</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">     862 </span>            :     }
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :     /*
<span class="lineNum">     865 </span>            :      * Make sure that we are comparing 2 valid hashes of the same type
<span class="lineNum">     866 </span>            :      * with valid comparison functions.
<span class="lineNum">     867 </span>            :      * Without valid comparison functions, a binary comparison
<span class="lineNum">     868 </span>            :      * of the hash values will yield random results on machines
<span class="lineNum">     869 </span>            :      * with 64-bit pointers and 32-bit integer hashes.
<span class="lineNum">     870 </span>            :      * A valueComparator is normally optional.
<span class="lineNum">     871 </span>            :      */
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     if (hash1==NULL || hash2==NULL ||</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         hash1-&gt;keyComparator != hash2-&gt;keyComparator ||</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         hash1-&gt;valueComparator != hash2-&gt;valueComparator ||</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         hash1-&gt;valueComparator == NULL)</span>
<span class="lineNum">     876 </span>            :     {
<span class="lineNum">     877 </span>            :         /*
<span class="lineNum">     878 </span>            :         Normally we would return an error here about incompatible hash tables,
<span class="lineNum">     879 </span>            :         but we return FALSE instead.
<span class="lineNum">     880 </span>            :         */
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     882 </span>            :     }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     count1 = uhash_count(hash1);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     count2 = uhash_count(hash2);</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     if(count1!=count2){</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     888 </span>            :     }
<span class="lineNum">     889 </span>            :     
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     pos=UHASH_FIRST;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     for(i=0; i&lt;count1; i++){</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         const UHashElement* elem1 = uhash_nextElement(hash1, &amp;pos);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         const UHashTok key1 = elem1-&gt;key;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         const UHashTok val1 = elem1-&gt;value;</span>
<span class="lineNum">     895 </span>            :         /* here the keys are not compared, instead the key form hash1 is used to fetch
<span class="lineNum">     896 </span>            :          * value from hash2. If the hashes are equal then then both hashes should 
<span class="lineNum">     897 </span>            :          * contain equal values for the same key!
<span class="lineNum">     898 </span>            :          */
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         const UHashElement* elem2 = _uhash_find(hash2, key1, hash2-&gt;keyHasher(key1));</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         const UHashTok val2 = elem2-&gt;value;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         if(hash1-&gt;valueComparator(val1, val2)==FALSE){</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">     903 </span>            :         }
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     906 </span>            : }
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : /********************************************************************
<span class="lineNum">     909 </span>            :  * PUBLIC Comparator Functions
<span class="lineNum">     910 </span>            :  ********************************************************************/
<a name="911"><span class="lineNum">     911 </span>            : </a>
<span class="lineNum">     912 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     913 </span><span class="lineNoCov">          0 : uhash_compareUChars(const UHashTok key1, const UHashTok key2) {</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     const UChar *p1 = (const UChar*) key1.pointer;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     const UChar *p2 = (const UChar*) key2.pointer;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     if (p1 == p2) {</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">     918 </span>            :     }
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     if (p1 == NULL || p2 == NULL) {</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     while (*p1 != 0 &amp;&amp; *p1 == *p2) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         ++p1;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         ++p2;</span>
<span class="lineNum">     925 </span>            :     }
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     return (UBool)(*p1 == *p2);</span>
<span class="lineNum">     927 </span>            : }
<a name="928"><span class="lineNum">     928 </span>            : </a>
<span class="lineNum">     929 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     930 </span><span class="lineCov">          9 : uhash_compareChars(const UHashTok key1, const UHashTok key2) {</span>
<span class="lineNum">     931 </span><span class="lineCov">          9 :     const char *p1 = (const char*) key1.pointer;</span>
<span class="lineNum">     932 </span><span class="lineCov">          9 :     const char *p2 = (const char*) key2.pointer;</span>
<span class="lineNum">     933 </span><span class="lineCov">          9 :     if (p1 == p2) {</span>
<span class="lineNum">     934 </span><span class="lineCov">          3 :         return TRUE;</span>
<span class="lineNum">     935 </span>            :     }
<span class="lineNum">     936 </span><span class="lineCov">          6 :     if (p1 == NULL || p2 == NULL) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     938 </span>            :     }
<span class="lineNum">     939 </span><span class="lineCov">        132 :     while (*p1 != 0 &amp;&amp; *p1 == *p2) {</span>
<span class="lineNum">     940 </span><span class="lineCov">         63 :         ++p1;</span>
<span class="lineNum">     941 </span><span class="lineCov">         63 :         ++p2;</span>
<span class="lineNum">     942 </span>            :     }
<span class="lineNum">     943 </span><span class="lineCov">          6 :     return (UBool)(*p1 == *p2);</span>
<span class="lineNum">     944 </span>            : }
<a name="945"><span class="lineNum">     945 </span>            : </a>
<span class="lineNum">     946 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     947 </span><span class="lineNoCov">          0 : uhash_compareIChars(const UHashTok key1, const UHashTok key2) {</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     const char *p1 = (const char*) key1.pointer;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     const char *p2 = (const char*) key2.pointer;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     if (p1 == p2) {</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">     952 </span>            :     }
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if (p1 == NULL || p2 == NULL) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     955 </span>            :     }
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     while (*p1 != 0 &amp;&amp; uprv_tolower(*p1) == uprv_tolower(*p2)) {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         ++p1;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         ++p2;</span>
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     return (UBool)(*p1 == *p2);</span>
<span class="lineNum">     961 </span>            : }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : /********************************************************************
<span class="lineNum">     964 </span>            :  * PUBLIC int32_t Support Functions
<span class="lineNum">     965 </span>            :  ********************************************************************/
<a name="966"><span class="lineNum">     966 </span>            : </a>
<span class="lineNum">     967 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     968 </span><span class="lineNoCov">          0 : uhash_hashLong(const UHashTok key) {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     return key.integer;</span>
<span class="lineNum">     970 </span>            : }
<a name="971"><span class="lineNum">     971 </span>            : </a>
<span class="lineNum">     972 </span>            : U_CAPI UBool U_EXPORT2
<span class="lineNum">     973 </span><span class="lineNoCov">          0 : uhash_compareLong(const UHashTok key1, const UHashTok key2) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     return (UBool)(key1.integer == key2.integer);</span>
<span class="lineNum">     975 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/common/ubidiln.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/common</a> - ubidiln.cpp<span style="font-size: 80%;"> (source / <a href="ubidiln.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">615</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : ******************************************************************************
<span class="lineNum">       5 </span>            : *
<span class="lineNum">       6 </span>            : *   Copyright (C) 1999-2015, International Business Machines
<span class="lineNum">       7 </span>            : *   Corporation and others.  All Rights Reserved.
<span class="lineNum">       8 </span>            : *
<span class="lineNum">       9 </span>            : ******************************************************************************
<span class="lineNum">      10 </span>            : *   file name:  ubidiln.c
<span class="lineNum">      11 </span>            : *   encoding:   UTF-8
<span class="lineNum">      12 </span>            : *   tab size:   8 (not used)
<span class="lineNum">      13 </span>            : *   indentation:4
<span class="lineNum">      14 </span>            : *
<span class="lineNum">      15 </span>            : *   created on: 1999aug06
<span class="lineNum">      16 </span>            : *   created by: Markus W. Scherer, updated by Matitiahu Allouche
<span class="lineNum">      17 </span>            : */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;unicode/ustring.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;unicode/uchar.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;unicode/ubidi.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;ubidiimp.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : /*
<span class="lineNum">      28 </span>            :  * General remarks about the functions in this file:
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * These functions deal with the aspects of potentially mixed-directional
<span class="lineNum">      31 </span>            :  * text in a single paragraph or in a line of a single paragraph
<span class="lineNum">      32 </span>            :  * which has already been processed according to
<span class="lineNum">      33 </span>            :  * the Unicode 6.3 BiDi algorithm as defined in
<span class="lineNum">      34 </span>            :  * http://www.unicode.org/unicode/reports/tr9/ , version 28,
<span class="lineNum">      35 </span>            :  * also described in The Unicode Standard, Version 6.3.0 .
<span class="lineNum">      36 </span>            :  *
<span class="lineNum">      37 </span>            :  * This means that there is a UBiDi object with a levels
<span class="lineNum">      38 </span>            :  * and a dirProps array.
<span class="lineNum">      39 </span>            :  * paraLevel and direction are also set.
<span class="lineNum">      40 </span>            :  * Only if the length of the text is zero, then levels==dirProps==NULL.
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * The overall directionality of the paragraph
<span class="lineNum">      43 </span>            :  * or line is used to bypass the reordering steps if possible.
<span class="lineNum">      44 </span>            :  * Even purely RTL text does not need reordering there because
<span class="lineNum">      45 </span>            :  * the ubidi_getLogical/VisualIndex() functions can compute the
<span class="lineNum">      46 </span>            :  * index on the fly in such a case.
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * The implementation of the access to same-level-runs and of the reordering
<span class="lineNum">      49 </span>            :  * do attempt to provide better performance and less memory usage compared to
<span class="lineNum">      50 </span>            :  * a direct implementation of especially rule (L2) with an array of
<span class="lineNum">      51 </span>            :  * one (32-bit) integer per text character.
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  * Here, the levels array is scanned as soon as necessary, and a vector of
<span class="lineNum">      54 </span>            :  * same-level-runs is created. Reordering then is done on this vector.
<span class="lineNum">      55 </span>            :  * For each run of text positions that were resolved to the same level,
<span class="lineNum">      56 </span>            :  * only 8 bytes are stored: the first text position of the run and the visual
<span class="lineNum">      57 </span>            :  * position behind the run after reordering.
<span class="lineNum">      58 </span>            :  * One sign bit is used to hold the directionality of the run.
<span class="lineNum">      59 </span>            :  * This is inefficient if there are many very short runs. If the average run
<span class="lineNum">      60 </span>            :  * length is &lt;2, then this uses more memory.
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * In a further attempt to save memory, the levels array is never changed
<span class="lineNum">      63 </span>            :  * after all the resolution rules (Xn, Wn, Nn, In).
<span class="lineNum">      64 </span>            :  * Many functions have to consider the field trailingWSStart:
<span class="lineNum">      65 </span>            :  * if it is less than length, then there is an implicit trailing run
<span class="lineNum">      66 </span>            :  * at the paraLevel,
<span class="lineNum">      67 </span>            :  * which is not reflected in the levels array.
<span class="lineNum">      68 </span>            :  * This allows a line UBiDi object to use the same levels array as
<span class="lineNum">      69 </span>            :  * its paragraph parent object.
<span class="lineNum">      70 </span>            :  *
<span class="lineNum">      71 </span>            :  * When a UBiDi object is created for a line of a paragraph, then the
<span class="lineNum">      72 </span>            :  * paragraph's levels and dirProps arrays are reused by way of setting
<span class="lineNum">      73 </span>            :  * a pointer into them, not by copying. This again saves memory and forbids to
<span class="lineNum">      74 </span>            :  * change the now shared levels for (L1).
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* handle trailing WS (L1) -------------------------------------------------- */
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /*
<span class="lineNum">      80 </span>            :  * setTrailingWSStart() sets the start index for a trailing
<span class="lineNum">      81 </span>            :  * run of WS in the line. This is necessary because we do not modify
<span class="lineNum">      82 </span>            :  * the paragraph's levels array that we just point into.
<span class="lineNum">      83 </span>            :  * Using trailingWSStart is another form of performing (L1).
<span class="lineNum">      84 </span>            :  *
<span class="lineNum">      85 </span>            :  * To make subsequent operations easier, we also include the run
<span class="lineNum">      86 </span>            :  * before the WS if it is at the paraLevel - we merge the two here.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * This function is called only from ubidi_setLine(), so pBiDi-&gt;paraLevel is
<span class="lineNum">      89 </span>            :  * set correctly for the line even when contextual multiple paragraphs.
<a name="90"><span class="lineNum">      90 </span>            :  */</a>
<span class="lineNum">      91 </span>            : static void
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : setTrailingWSStart(UBiDi *pBiDi) {</span>
<span class="lineNum">      93 </span>            :     /* pBiDi-&gt;direction!=UBIDI_MIXED */
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     const DirProp *dirProps=pBiDi-&gt;dirProps;</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     UBiDiLevel *levels=pBiDi-&gt;levels;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     int32_t start=pBiDi-&gt;length;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     UBiDiLevel paraLevel=pBiDi-&gt;paraLevel;</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     /* If the line is terminated by a block separator, all preceding WS etc...
<span class="lineNum">     101 </span>            :        are already set to paragraph level.
<span class="lineNum">     102 </span>            :        Setting trailingWSStart to pBidi-&gt;length will avoid changing the
<span class="lineNum">     103 </span>            :        level of B chars from 0 to paraLevel in ubidi_getLevels when
<span class="lineNum">     104 </span>            :        orderParagraphsLTR==TRUE.
<span class="lineNum">     105 </span>            :      */
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     if(dirProps[start-1]==B) {</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         pBiDi-&gt;trailingWSStart=start;   /* currently == pBiDi-&gt;length */</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     109 </span>            :     }
<span class="lineNum">     110 </span>            :     /* go backwards across all WS, BN, explicit codes */
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     while(start&gt;0 &amp;&amp; DIRPROP_FLAG(dirProps[start-1])&amp;MASK_WS) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :         --start;</span>
<span class="lineNum">     113 </span>            :     }
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :     /* if the WS run can be merged with the previous run then do so here */
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     while(start&gt;0 &amp;&amp; levels[start-1]==paraLevel) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :         --start;</span>
<span class="lineNum">     118 </span>            :     }
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     pBiDi-&gt;trailingWSStart=start;</span>
<span class="lineNum">     121 </span>            : }
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /* ubidi_setLine ------------------------------------------------------------ */
<a name="124"><span class="lineNum">     124 </span>            : </a>
<span class="lineNum">     125 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     126 </span><span class="lineNoCov">          0 : ubidi_setLine(const UBiDi *pParaBiDi,</span>
<span class="lineNum">     127 </span>            :               int32_t start, int32_t limit,
<span class="lineNum">     128 </span>            :               UBiDi *pLineBiDi,
<span class="lineNum">     129 </span>            :               UErrorCode *pErrorCode) {
<span class="lineNum">     130 </span>            :     int32_t length;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     /* check the argument values */
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_NULL_OR_FAILING_ERRCODE(pErrorCode);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_NOT_VALID_PARA(pParaBiDi, *pErrorCode);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_BAD_RANGE(start, 0, limit, *pErrorCode);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_BAD_RANGE(limit, 0, pParaBiDi-&gt;length+1, *pErrorCode);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     if(pLineBiDi==NULL) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     140 </span>            :     }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     if(ubidi_getParagraph(pParaBiDi, start, NULL, NULL, NULL, pErrorCode) !=</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :        ubidi_getParagraph(pParaBiDi, limit-1, NULL, NULL, NULL, pErrorCode)) {</span>
<span class="lineNum">     143 </span>            :         /* the line crosses a paragraph boundary */
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     146 </span>            :     }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     /* set the values in pLineBiDi from its pParaBiDi parent */
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;pParaBiDi=NULL;          /* mark unfinished setLine */</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;text=pParaBiDi-&gt;text+start;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     length=pLineBiDi-&gt;length=limit-start;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;resultLength=pLineBiDi-&gt;originalLength=length;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;paraLevel=GET_PARALEVEL(pParaBiDi, start);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;paraCount=pParaBiDi-&gt;paraCount;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;runs=NULL;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;flags=0;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;reorderingMode=pParaBiDi-&gt;reorderingMode;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;reorderingOptions=pParaBiDi-&gt;reorderingOptions;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;controlCount=0;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     if(pParaBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">     161 </span>            :         int32_t j;
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :         for(j=start; j&lt;limit; j++) {</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :             if(IS_BIDI_CONTROL_CHAR(pParaBiDi-&gt;text[j])) {</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                 pLineBiDi-&gt;controlCount++;</span>
<span class="lineNum">     165 </span>            :             }
<span class="lineNum">     166 </span>            :         }
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         pLineBiDi-&gt;resultLength-=pLineBiDi-&gt;controlCount;</span>
<span class="lineNum">     168 </span>            :     }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;dirProps=pParaBiDi-&gt;dirProps+start;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;levels=pParaBiDi-&gt;levels+start;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;runCount=-1;</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     if(pParaBiDi-&gt;direction!=UBIDI_MIXED) {</span>
<span class="lineNum">     175 </span>            :         /* the parent is already trivial */
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         pLineBiDi-&gt;direction=pParaBiDi-&gt;direction;</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :         /*
<span class="lineNum">     179 </span>            :          * The parent's levels are all either
<span class="lineNum">     180 </span>            :          * implicitly or explicitly ==paraLevel;
<span class="lineNum">     181 </span>            :          * do the same here.
<span class="lineNum">     182 </span>            :          */
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         if(pParaBiDi-&gt;trailingWSStart&lt;=start) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;trailingWSStart=0;</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         } else if(pParaBiDi-&gt;trailingWSStart&lt;limit) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;trailingWSStart=pParaBiDi-&gt;trailingWSStart-start;</span>
<span class="lineNum">     187 </span>            :         } else {
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;trailingWSStart=length;</span>
<span class="lineNum">     189 </span>            :         }
<span class="lineNum">     190 </span>            :     } else {
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         const UBiDiLevel *levels=pLineBiDi-&gt;levels;</span>
<span class="lineNum">     192 </span>            :         int32_t i, trailingWSStart;
<span class="lineNum">     193 </span>            :         UBiDiLevel level;
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         setTrailingWSStart(pLineBiDi);</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         trailingWSStart=pLineBiDi-&gt;trailingWSStart;</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :         /* recalculate pLineBiDi-&gt;direction */
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         if(trailingWSStart==0) {</span>
<span class="lineNum">     200 </span>            :             /* all levels are at paraLevel */
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;direction=(UBiDiDirection)(pLineBiDi-&gt;paraLevel&amp;1);</span>
<span class="lineNum">     202 </span>            :         } else {
<span class="lineNum">     203 </span>            :             /* get the level of the first character */
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :             level=(UBiDiLevel)(levels[0]&amp;1);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :             /* if there is anything of a different level, then the line is mixed */
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :             if(trailingWSStart&lt;length &amp;&amp; (pLineBiDi-&gt;paraLevel&amp;1)!=level) {</span>
<span class="lineNum">     208 </span>            :                 /* the trailing WS is at paraLevel, which differs from levels[0] */
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :                 pLineBiDi-&gt;direction=UBIDI_MIXED;</span>
<span class="lineNum">     210 </span>            :             } else {
<span class="lineNum">     211 </span>            :                 /* see if levels[1..trailingWSStart-1] have the same direction as levels[0] and paraLevel */
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :                 i=1;</span>
<span class="lineNum">     213 </span>            :                 for(;;) {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :                     if(i==trailingWSStart) {</span>
<span class="lineNum">     215 </span>            :                         /* the direction values match those in level */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :                         pLineBiDi-&gt;direction=(UBiDiDirection)level;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :                     } else if((levels[i]&amp;1)!=level) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :                         pLineBiDi-&gt;direction=UBIDI_MIXED;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     221 </span>            :                     }
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                     ++i;</span>
<span class="lineNum">     223 </span>            :                 }
<span class="lineNum">     224 </span>            :             }
<span class="lineNum">     225 </span>            :         }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         switch(pLineBiDi-&gt;direction) {</span>
<span class="lineNum">     228 </span>            :         case UBIDI_LTR:
<span class="lineNum">     229 </span>            :             /* make sure paraLevel is even */
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;paraLevel=(UBiDiLevel)((pLineBiDi-&gt;paraLevel+1)&amp;~1);</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :             /* all levels are implicitly at paraLevel (important for ubidi_getLevels()) */
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;trailingWSStart=0;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     235 </span>            :         case UBIDI_RTL:
<span class="lineNum">     236 </span>            :             /* make sure paraLevel is odd */
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;paraLevel|=1;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :             /* all levels are implicitly at paraLevel (important for ubidi_getLevels()) */
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             pLineBiDi-&gt;trailingWSStart=0;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     242 </span>            :         default:
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     244 </span>            :         }
<span class="lineNum">     245 </span>            :     }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     pLineBiDi-&gt;pParaBiDi=pParaBiDi;     /* mark successful setLine */</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     248 </span>            : }
<a name="249"><span class="lineNum">     249 </span>            : </a>
<span class="lineNum">     250 </span>            : U_CAPI UBiDiLevel U_EXPORT2
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : ubidi_getLevelAt(const UBiDi *pBiDi, int32_t charIndex) {</span>
<span class="lineNum">     252 </span>            :     /* return paraLevel if in the trailing WS run, otherwise the real level */
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     if(!IS_VALID_PARA_OR_LINE(pBiDi) || charIndex&lt;0 || pBiDi-&gt;length&lt;=charIndex) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     } else if(pBiDi-&gt;direction!=UBIDI_MIXED || charIndex&gt;=pBiDi-&gt;trailingWSStart) {</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         return GET_PARALEVEL(pBiDi, charIndex);</span>
<span class="lineNum">     257 </span>            :     } else {
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         return pBiDi-&gt;levels[charIndex];</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            : }
<a name="261"><span class="lineNum">     261 </span>            : </a>
<span class="lineNum">     262 </span>            : U_CAPI const UBiDiLevel * U_EXPORT2
<span class="lineNum">     263 </span><span class="lineNoCov">          0 : ubidi_getLevels(UBiDi *pBiDi, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     264 </span>            :     int32_t start, length;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     RETURN_IF_NULL_OR_FAILING_ERRCODE(pErrorCode, NULL);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     RETURN_IF_NOT_VALID_PARA_OR_LINE(pBiDi, *pErrorCode, NULL);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     if((length=pBiDi-&gt;length)&lt;=0) {</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     if((start=pBiDi-&gt;trailingWSStart)==length) {</span>
<span class="lineNum">     273 </span>            :         /* the current levels array reflects the WS run */
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         return pBiDi-&gt;levels;</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :     /*
<span class="lineNum">     278 </span>            :      * After the previous if(), we know that the levels array
<span class="lineNum">     279 </span>            :      * has an implicit trailing WS run and therefore does not fully
<span class="lineNum">     280 </span>            :      * reflect itself all the levels.
<span class="lineNum">     281 </span>            :      * This must be a UBiDi object for a line, and
<span class="lineNum">     282 </span>            :      * we need to create a new levels array.
<span class="lineNum">     283 </span>            :      */
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     if(getLevelsMemory(pBiDi, length)) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         UBiDiLevel *levels=pBiDi-&gt;levelsMemory;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         if(start&gt;0 &amp;&amp; levels!=pBiDi-&gt;levels) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :             uprv_memcpy(levels, pBiDi-&gt;levels, start);</span>
<span class="lineNum">     289 </span>            :         }
<span class="lineNum">     290 </span>            :         /* pBiDi-&gt;paraLevel is ok even if contextual multiple paragraphs,
<span class="lineNum">     291 </span>            :            since pBidi is a line object                                     */
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         uprv_memset(levels+start, pBiDi-&gt;paraLevel, length-start);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :         /* this new levels array is set for the line and reflects the WS run */
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         pBiDi-&gt;trailingWSStart=length;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         return pBiDi-&gt;levels=levels;</span>
<span class="lineNum">     297 </span>            :     } else {
<span class="lineNum">     298 </span>            :         /* out of memory */
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     301 </span>            :     }
<span class="lineNum">     302 </span>            : }
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : ubidi_getLogicalRun(const UBiDi *pBiDi, int32_t logicalPosition,</span>
<span class="lineNum">     306 </span>            :                     int32_t *pLogicalLimit, UBiDiLevel *pLevel) {
<span class="lineNum">     307 </span>            :     UErrorCode errorCode;
<span class="lineNum">     308 </span>            :     int32_t runCount, visualStart, logicalLimit, logicalFirst, i;
<span class="lineNum">     309 </span>            :     Run iRun;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     errorCode=U_ZERO_ERROR;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_BAD_RANGE(logicalPosition, 0, pBiDi-&gt;length, errorCode);</span>
<span class="lineNum">     313 </span>            :     /* ubidi_countRuns will check VALID_PARA_OR_LINE */
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     runCount=ubidi_countRuns((UBiDi *)pBiDi, &amp;errorCode);</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     317 </span>            :     }
<span class="lineNum">     318 </span>            :     /* this is done based on runs rather than on levels since levels have
<span class="lineNum">     319 </span>            :        a special interpretation when UBIDI_REORDER_RUNS_ONLY
<span class="lineNum">     320 </span>            :      */
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     visualStart=logicalLimit=0;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     iRun=pBiDi-&gt;runs[0];</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     for(i=0; i&lt;runCount; i++) {</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         iRun = pBiDi-&gt;runs[i];</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         logicalFirst=GET_INDEX(iRun.logicalStart);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         logicalLimit=logicalFirst+iRun.visualLimit-visualStart;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         if((logicalPosition&gt;=logicalFirst) &amp;&amp;</span>
<span class="lineNum">     329 </span>            :            (logicalPosition&lt;logicalLimit)) {
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     331 </span>            :         }
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         visualStart = iRun.visualLimit;</span>
<span class="lineNum">     333 </span>            :     }
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     if(pLogicalLimit) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         *pLogicalLimit=logicalLimit;</span>
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     if(pLevel) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         if(pBiDi-&gt;reorderingMode==UBIDI_REORDER_RUNS_ONLY) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :             *pLevel=(UBiDiLevel)GET_ODD_BIT(iRun.logicalStart);</span>
<span class="lineNum">     340 </span>            :         }
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         else if(pBiDi-&gt;direction!=UBIDI_MIXED || logicalPosition&gt;=pBiDi-&gt;trailingWSStart) {</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :             *pLevel=GET_PARALEVEL(pBiDi, logicalPosition);</span>
<span class="lineNum">     343 </span>            :         } else {
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         *pLevel=pBiDi-&gt;levels[logicalPosition];</span>
<span class="lineNum">     345 </span>            :         }
<span class="lineNum">     346 </span>            :     }
<span class="lineNum">     347 </span>            : }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : /* runs API functions ------------------------------------------------------- */
<a name="350"><span class="lineNum">     350 </span>            : </a>
<span class="lineNum">     351 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : ubidi_countRuns(UBiDi *pBiDi, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     RETURN_IF_NULL_OR_FAILING_ERRCODE(pErrorCode, -1);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     RETURN_IF_NOT_VALID_PARA_OR_LINE(pBiDi, *pErrorCode, -1);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     ubidi_getRuns(pBiDi, pErrorCode);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     return pBiDi-&gt;runCount;</span>
<span class="lineNum">     360 </span>            : }
<a name="361"><span class="lineNum">     361 </span>            : </a>
<span class="lineNum">     362 </span>            : U_CAPI UBiDiDirection U_EXPORT2
<span class="lineNum">     363 </span><span class="lineNoCov">          0 : ubidi_getVisualRun(UBiDi *pBiDi, int32_t runIndex,</span>
<span class="lineNum">     364 </span>            :                    int32_t *pLogicalStart, int32_t *pLength)
<span class="lineNum">     365 </span>            : {
<span class="lineNum">     366 </span>            :     int32_t start;
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     UErrorCode errorCode = U_ZERO_ERROR;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     RETURN_IF_NOT_VALID_PARA_OR_LINE(pBiDi, errorCode, UBIDI_LTR);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     ubidi_getRuns(pBiDi, &amp;errorCode);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         return UBIDI_LTR;</span>
<span class="lineNum">     372 </span>            :     }
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     RETURN_IF_BAD_RANGE(runIndex, 0, pBiDi-&gt;runCount, errorCode, UBIDI_LTR);</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     start=pBiDi-&gt;runs[runIndex].logicalStart;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if(pLogicalStart!=NULL) {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         *pLogicalStart=GET_INDEX(start);</span>
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     if(pLength!=NULL) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         if(runIndex&gt;0) {</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             *pLength=pBiDi-&gt;runs[runIndex].visualLimit-</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :                      pBiDi-&gt;runs[runIndex-1].visualLimit;</span>
<span class="lineNum">     383 </span>            :         } else {
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             *pLength=pBiDi-&gt;runs[0].visualLimit;</span>
<span class="lineNum">     385 </span>            :         }
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     return (UBiDiDirection)GET_ODD_BIT(start);</span>
<span class="lineNum">     388 </span>            : }
<span class="lineNum">     389 </span>            : 
<a name="390"><span class="lineNum">     390 </span>            : /* in trivial cases there is only one trivial run; called by ubidi_getRuns() */</a>
<span class="lineNum">     391 </span>            : static void
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : getSingleRun(UBiDi *pBiDi, UBiDiLevel level) {</span>
<span class="lineNum">     393 </span>            :     /* simple, single-run case */
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     pBiDi-&gt;runs=pBiDi-&gt;simpleRuns;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     pBiDi-&gt;runCount=1;</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :     /* fill and reorder the single run */
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     pBiDi-&gt;runs[0].logicalStart=MAKE_INDEX_ODD_PAIR(0, level);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     pBiDi-&gt;runs[0].visualLimit=pBiDi-&gt;length;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     pBiDi-&gt;runs[0].insertRemove=0;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : /* reorder the runs array (L2) ---------------------------------------------- */
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : /*
<span class="lineNum">     406 </span>            :  * Reorder the same-level runs in the runs array.
<span class="lineNum">     407 </span>            :  * Here, runCount&gt;1 and maxLevel&gt;=minLevel&gt;=paraLevel.
<span class="lineNum">     408 </span>            :  * All the visualStart fields=logical start before reordering.
<span class="lineNum">     409 </span>            :  * The &quot;odd&quot; bits are not set yet.
<span class="lineNum">     410 </span>            :  *
<span class="lineNum">     411 </span>            :  * Reordering with this data structure lends itself to some handy shortcuts:
<span class="lineNum">     412 </span>            :  *
<span class="lineNum">     413 </span>            :  * Since each run is moved but not modified, and since at the initial maxLevel
<span class="lineNum">     414 </span>            :  * each sequence of same-level runs consists of only one run each, we
<span class="lineNum">     415 </span>            :  * don't need to do anything there and can predecrement maxLevel.
<span class="lineNum">     416 </span>            :  * In many simple cases, the reordering is thus done entirely in the
<span class="lineNum">     417 </span>            :  * index mapping.
<span class="lineNum">     418 </span>            :  * Also, reordering occurs only down to the lowest odd level that occurs,
<span class="lineNum">     419 </span>            :  * which is minLevel|1. However, if the lowest level itself is odd, then
<span class="lineNum">     420 </span>            :  * in the last reordering the sequence of the runs at this level or higher
<span class="lineNum">     421 </span>            :  * will be all runs, and we don't need the elaborate loop to search for them.
<span class="lineNum">     422 </span>            :  * This is covered by ++minLevel instead of minLevel|=1 followed
<span class="lineNum">     423 </span>            :  * by an extra reorder-all after the reorder-some loop.
<span class="lineNum">     424 </span>            :  * About a trailing WS run:
<span class="lineNum">     425 </span>            :  * Such a run would need special treatment because its level is not
<span class="lineNum">     426 </span>            :  * reflected in levels[] if this is not a paragraph object.
<span class="lineNum">     427 </span>            :  * Instead, all characters from trailingWSStart on are implicitly at
<span class="lineNum">     428 </span>            :  * paraLevel.
<span class="lineNum">     429 </span>            :  * However, for all maxLevel&gt;paraLevel, this run will never be reordered
<span class="lineNum">     430 </span>            :  * and does not need to be taken into account. maxLevel==paraLevel is only reordered
<span class="lineNum">     431 </span>            :  * if minLevel==paraLevel is odd, which is done in the extra segment.
<span class="lineNum">     432 </span>            :  * This means that for the main reordering loop we don't need to consider
<span class="lineNum">     433 </span>            :  * this run and can --runCount. If it is later part of the all-runs
<span class="lineNum">     434 </span>            :  * reordering, then runCount is adjusted accordingly.
<a name="435"><span class="lineNum">     435 </span>            :  */</a>
<span class="lineNum">     436 </span>            : static void
<span class="lineNum">     437 </span><span class="lineNoCov">          0 : reorderLine(UBiDi *pBiDi, UBiDiLevel minLevel, UBiDiLevel maxLevel) {</span>
<span class="lineNum">     438 </span>            :     Run *runs, tempRun;
<span class="lineNum">     439 </span>            :     UBiDiLevel *levels;
<span class="lineNum">     440 </span>            :     int32_t firstRun, endRun, limitRun, runCount;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :     /* nothing to do? */
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     if(maxLevel&lt;=(minLevel|1)) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :     /*
<span class="lineNum">     448 </span>            :      * Reorder only down to the lowest odd level
<span class="lineNum">     449 </span>            :      * and reorder at an odd minLevel in a separate, simpler loop.
<span class="lineNum">     450 </span>            :      * See comments above for why minLevel is always incremented.
<span class="lineNum">     451 </span>            :      */
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     ++minLevel;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     runs=pBiDi-&gt;runs;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     levels=pBiDi-&gt;levels;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     runCount=pBiDi-&gt;runCount;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :     /* do not include the WS run at paraLevel&lt;=old minLevel except in the simple loop */
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;trailingWSStart&lt;pBiDi-&gt;length) {</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         --runCount;</span>
<span class="lineNum">     461 </span>            :     }
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     while(--maxLevel&gt;=minLevel) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         firstRun=0;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :         /* loop for all sequences of runs */
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         for(;;) {</span>
<span class="lineNum">     468 </span>            :             /* look for a sequence of runs that are all at &gt;=maxLevel */
<span class="lineNum">     469 </span>            :             /* look for the first run of such a sequence */
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :             while(firstRun&lt;runCount &amp;&amp; levels[runs[firstRun].logicalStart]&lt;maxLevel) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 ++firstRun;</span>
<span class="lineNum">     472 </span>            :             }
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :             if(firstRun&gt;=runCount) {</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                 break;  /* no more such runs */</span>
<span class="lineNum">     475 </span>            :             }
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :             /* look for the limit run of such a sequence (the run behind it) */
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             for(limitRun=firstRun; ++limitRun&lt;runCount &amp;&amp; levels[runs[limitRun].logicalStart]&gt;=maxLevel;) {}</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :             /* Swap the entire sequence of runs from firstRun to limitRun-1. */
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :             endRun=limitRun-1;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :             while(firstRun&lt;endRun) {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                 tempRun = runs[firstRun];</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                 runs[firstRun]=runs[endRun];</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                 runs[endRun]=tempRun;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                 ++firstRun;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 --endRun;</span>
<span class="lineNum">     488 </span>            :             }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :             if(limitRun==runCount) {</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                 break;  /* no more such runs */</span>
<span class="lineNum">     492 </span>            :             } else {
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                 firstRun=limitRun+1;</span>
<span class="lineNum">     494 </span>            :             }
<span class="lineNum">     495 </span>            :         }
<span class="lineNum">     496 </span>            :     }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :     /* now do maxLevel==old minLevel (==odd!), see above */
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     if(!(minLevel&amp;1)) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         firstRun=0;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :         /* include the trailing WS run in this complete reordering */
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         if(pBiDi-&gt;trailingWSStart==pBiDi-&gt;length) {</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :             --runCount;</span>
<span class="lineNum">     505 </span>            :         }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :         /* Swap the entire sequence of all runs. (endRun==runCount) */
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         while(firstRun&lt;runCount) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :             tempRun=runs[firstRun];</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :             runs[firstRun]=runs[runCount];</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             runs[runCount]=tempRun;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :             ++firstRun;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :             --runCount;</span>
<span class="lineNum">     514 </span>            :         }
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<a name="518"><span class="lineNum">     518 </span>            : /* compute the runs array --------------------------------------------------- */</a>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : static int32_t getRunFromLogicalIndex(UBiDi *pBiDi, int32_t logicalIndex, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     Run *runs=pBiDi-&gt;runs;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     int32_t runCount=pBiDi-&gt;runCount, visualStart=0, i, length, logicalStart;</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     for(i=0; i&lt;runCount; i++) {</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         logicalStart=GET_INDEX(runs[i].logicalStart);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         if((logicalIndex&gt;=logicalStart) &amp;&amp; (logicalIndex&lt;(logicalStart+length))) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :             return i;</span>
<span class="lineNum">     529 </span>            :         }
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         visualStart+=length;</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            :     /* we should never get here */
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     U_ASSERT(FALSE);</span>
<span class="lineNum">     534 </span>            :     *pErrorCode = U_INVALID_STATE_ERROR;
<span class="lineNum">     535 </span>            :     return 0;
<span class="lineNum">     536 </span>            : }
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /*
<span class="lineNum">     539 </span>            :  * Compute the runs array from the levels array.
<span class="lineNum">     540 </span>            :  * After ubidi_getRuns() returns TRUE, runCount is guaranteed to be &gt;0
<span class="lineNum">     541 </span>            :  * and the runs are reordered.
<span class="lineNum">     542 </span>            :  * Odd-level runs have visualStart on their visual right edge and
<span class="lineNum">     543 </span>            :  * they progress visually to the left.
<span class="lineNum">     544 </span>            :  * If option UBIDI_OPTION_INSERT_MARKS is set, insertRemove will contain the
<span class="lineNum">     545 </span>            :  * sum of appropriate LRM/RLM_BEFORE/AFTER flags.
<span class="lineNum">     546 </span>            :  * If option UBIDI_OPTION_REMOVE_CONTROLS is set, insertRemove will contain the
<span class="lineNum">     547 </span>            :  * negative number of BiDi control characters within this run.
<a name="548"><span class="lineNum">     548 </span>            :  */</a>
<span class="lineNum">     549 </span>            : U_CFUNC UBool
<span class="lineNum">     550 </span><span class="lineNoCov">          0 : ubidi_getRuns(UBiDi *pBiDi, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     551 </span>            :     /*
<span class="lineNum">     552 </span>            :      * This method returns immediately if the runs are already set. This
<span class="lineNum">     553 </span>            :      * includes the case of length==0 (handled in setPara)..
<span class="lineNum">     554 </span>            :      */
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     if (pBiDi-&gt;runCount&gt;=0) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">     557 </span>            :     }
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;direction!=UBIDI_MIXED) {</span>
<span class="lineNum">     560 </span>            :         /* simple, single-run case - this covers length==0 */
<span class="lineNum">     561 </span>            :         /* pBiDi-&gt;paraLevel is ok even for contextual multiple paragraphs */
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         getSingleRun(pBiDi, pBiDi-&gt;paraLevel);</span>
<span class="lineNum">     563 </span>            :     } else /* UBIDI_MIXED, length&gt;0 */ {
<span class="lineNum">     564 </span>            :         /* mixed directionality */
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         int32_t length=pBiDi-&gt;length, limit;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :         UBiDiLevel *levels=pBiDi-&gt;levels;</span>
<span class="lineNum">     567 </span>            :         int32_t i, runCount;
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         UBiDiLevel level=UBIDI_DEFAULT_LTR;   /* initialize with no valid level */</span>
<span class="lineNum">     569 </span>            :         /*
<span class="lineNum">     570 </span>            :          * If there are WS characters at the end of the line
<span class="lineNum">     571 </span>            :          * and the run preceding them has a level different from
<span class="lineNum">     572 </span>            :          * paraLevel, then they will form their own run at paraLevel (L1).
<span class="lineNum">     573 </span>            :          * Count them separately.
<span class="lineNum">     574 </span>            :          * We need some special treatment for this in order to not
<span class="lineNum">     575 </span>            :          * modify the levels array which a line UBiDi object shares
<span class="lineNum">     576 </span>            :          * with its paragraph parent and its other line siblings.
<span class="lineNum">     577 </span>            :          * In other words, for the trailing WS, it may be
<span class="lineNum">     578 </span>            :          * levels[]!=paraLevel but we have to treat it like it were so.
<span class="lineNum">     579 </span>            :          */
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         limit=pBiDi-&gt;trailingWSStart;</span>
<span class="lineNum">     581 </span>            :         /* count the runs, there is at least one non-WS run, and limit&gt;0 */
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         runCount=0;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         for(i=0; i&lt;limit; ++i) {</span>
<span class="lineNum">     584 </span>            :             /* increment runCount at the start of each run */
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :             if(levels[i]!=level) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                 ++runCount;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 level=levels[i];</span>
<span class="lineNum">     588 </span>            :             }
<span class="lineNum">     589 </span>            :         }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :         /*
<span class="lineNum">     592 </span>            :          * We don't need to see if the last run can be merged with a trailing
<span class="lineNum">     593 </span>            :          * WS run because setTrailingWSStart() would have done that.
<span class="lineNum">     594 </span>            :          */
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         if(runCount==1 &amp;&amp; limit==length) {</span>
<span class="lineNum">     596 </span>            :             /* There is only one non-WS run and no trailing WS-run. */
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :             getSingleRun(pBiDi, levels[0]);</span>
<span class="lineNum">     598 </span>            :         } else /* runCount&gt;1 || limit&lt;length */ {
<span class="lineNum">     599 </span>            :             /* allocate and set the runs */
<span class="lineNum">     600 </span>            :             Run *runs;
<span class="lineNum">     601 </span>            :             int32_t runIndex, start;
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :             UBiDiLevel minLevel=UBIDI_MAX_EXPLICIT_LEVEL+1, maxLevel=0;</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :             /* now, count a (non-mergeable) WS run */
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :             if(limit&lt;length) {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 ++runCount;</span>
<span class="lineNum">     607 </span>            :             }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :             /* runCount&gt;1 */
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             if(getRunsMemory(pBiDi, runCount)) {</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                 runs=pBiDi-&gt;runsMemory;</span>
<span class="lineNum">     612 </span>            :             } else {
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">     614 </span>            :             }
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :             /* set the runs */
<span class="lineNum">     617 </span>            :             /* FOOD FOR THOUGHT: this could be optimized, e.g.:
<span class="lineNum">     618 </span>            :              * 464-&gt;444, 484-&gt;444, 575-&gt;555, 595-&gt;555
<span class="lineNum">     619 </span>            :              * However, that would take longer. Check also how it would
<span class="lineNum">     620 </span>            :              * interact with BiDi control removal and inserting Marks.
<span class="lineNum">     621 </span>            :              */
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             runIndex=0;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :             /* search for the run limits and initialize visualLimit values with the run lengths */
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :             i=0;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :             do {</span>
<span class="lineNum">     627 </span>            :                 /* prepare this run */
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                 start=i;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :                 level=levels[i];</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                 if(level&lt;minLevel) {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                     minLevel=level;</span>
<span class="lineNum">     632 </span>            :                 }
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                 if(level&gt;maxLevel) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                     maxLevel=level;</span>
<span class="lineNum">     635 </span>            :                 }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :                 /* look for the run limit */
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                 while(++i&lt;limit &amp;&amp; levels[i]==level) {}</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :                 /* i is another run limit */
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                 runs[runIndex].logicalStart=start;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :                 runs[runIndex].visualLimit=i-start;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :                 runs[runIndex].insertRemove=0;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                 ++runIndex;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :             } while(i&lt;limit);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :             if(limit&lt;length) {</span>
<span class="lineNum">     648 </span>            :                 /* there is a separate WS run */
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :                 runs[runIndex].logicalStart=limit;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                 runs[runIndex].visualLimit=length-limit;</span>
<span class="lineNum">     651 </span>            :                 /* For the trailing WS run, pBiDi-&gt;paraLevel is ok even
<span class="lineNum">     652 </span>            :                    if contextual multiple paragraphs.                   */
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :                 if(pBiDi-&gt;paraLevel&lt;minLevel) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                     minLevel=pBiDi-&gt;paraLevel;</span>
<span class="lineNum">     655 </span>            :                 }
<span class="lineNum">     656 </span>            :             }
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            :             /* set the object fields */
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :             pBiDi-&gt;runs=runs;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             pBiDi-&gt;runCount=runCount;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             reorderLine(pBiDi, minLevel, maxLevel);</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :             /* now add the direction flags and adjust the visualLimit's to be just that */
<span class="lineNum">     665 </span>            :             /* this loop will also handle the trailing WS run */
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :             limit=0;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;runCount; ++i) {</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                 ADD_ODD_BIT_FROM_LEVEL(runs[i].logicalStart, levels[runs[i].logicalStart]);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                 limit+=runs[i].visualLimit;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                 runs[i].visualLimit=limit;</span>
<span class="lineNum">     671 </span>            :             }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :             /* Set the &quot;odd&quot; bit for the trailing WS run. */
<span class="lineNum">     674 </span>            :             /* For a RTL paragraph, it will be the *first* run in visual order. */
<span class="lineNum">     675 </span>            :             /* For the trailing WS run, pBiDi-&gt;paraLevel is ok even if
<span class="lineNum">     676 </span>            :                contextual multiple paragraphs.                          */
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :             if(runIndex&lt;runCount) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                 int32_t trailingRun = ((pBiDi-&gt;paraLevel &amp; 1) != 0)? 0 : runIndex;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :                 ADD_ODD_BIT_FROM_LEVEL(runs[trailingRun].logicalStart, pBiDi-&gt;paraLevel);</span>
<span class="lineNum">     681 </span>            :             }
<span class="lineNum">     682 </span>            :         }
<span class="lineNum">     683 </span>            :     }
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :     /* handle insert LRM/RLM BEFORE/AFTER run */
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;insertPoints.size&gt;0) {</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :         Point *point, *start=pBiDi-&gt;insertPoints.points,</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                       *limit=start+pBiDi-&gt;insertPoints.size;</span>
<span class="lineNum">     689 </span>            :         int32_t runIndex;
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         for(point=start; point&lt;limit; point++) {</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :             runIndex=getRunFromLogicalIndex(pBiDi, point-&gt;pos, pErrorCode);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :             pBiDi-&gt;runs[runIndex].insertRemove|=point-&gt;flag;</span>
<span class="lineNum">     693 </span>            :         }
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :     /* handle remove BiDi control characters */
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">     698 </span>            :         int32_t runIndex;
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         const UChar *start=pBiDi-&gt;text, *limit=start+pBiDi-&gt;length, *pu;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         for(pu=start; pu&lt;limit; pu++) {</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :             if(IS_BIDI_CONTROL_CHAR(*pu)) {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                 runIndex=getRunFromLogicalIndex(pBiDi, (int32_t)(pu-start), pErrorCode);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :                 pBiDi-&gt;runs[runIndex].insertRemove--;</span>
<span class="lineNum">     704 </span>            :             }
<span class="lineNum">     705 </span>            :         }
<span class="lineNum">     706 </span>            :     }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     709 </span>            : }
<a name="710"><span class="lineNum">     710 </span>            : </a>
<span class="lineNum">     711 </span>            : static UBool
<span class="lineNum">     712 </span><span class="lineNoCov">          0 : prepareReorder(const UBiDiLevel *levels, int32_t length,</span>
<span class="lineNum">     713 </span>            :                int32_t *indexMap,
<span class="lineNum">     714 </span>            :                UBiDiLevel *pMinLevel, UBiDiLevel *pMaxLevel) {
<span class="lineNum">     715 </span>            :     int32_t start;
<span class="lineNum">     716 </span>            :     UBiDiLevel level, minLevel, maxLevel;
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     if(levels==NULL || length&lt;=0) {</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     /* determine minLevel and maxLevel */
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     minLevel=UBIDI_MAX_EXPLICIT_LEVEL+1;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     maxLevel=0;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     for(start=length; start&gt;0;) {</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         level=levels[--start];</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         if(level&gt;UBIDI_MAX_EXPLICIT_LEVEL+1) {</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">     729 </span>            :         }
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         if(level&lt;minLevel) {</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :             minLevel=level;</span>
<span class="lineNum">     732 </span>            :         }
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         if(level&gt;maxLevel) {</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :             maxLevel=level;</span>
<span class="lineNum">     735 </span>            :         }
<span class="lineNum">     736 </span>            :     }
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     *pMinLevel=minLevel;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     *pMaxLevel=maxLevel;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :     /* initialize the index map */
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     for(start=length; start&gt;0;) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         --start;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         indexMap[start]=start;</span>
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     747 </span>            : }
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            : /* reorder a line based on a levels array (L2) ------------------------------ */
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     752 </span><span class="lineNoCov">          0 : ubidi_reorderLogical(const UBiDiLevel *levels, int32_t length, int32_t *indexMap) {</span>
<span class="lineNum">     753 </span>            :     int32_t start, limit, sumOfSosEos;
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     UBiDiLevel minLevel = 0, maxLevel = 0;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     if(indexMap==NULL || !prepareReorder(levels, length, indexMap, &amp;minLevel, &amp;maxLevel)) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            :     /* nothing to do? */
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     if(minLevel==maxLevel &amp;&amp; (minLevel&amp;1)==0) {</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     763 </span>            :     }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     /* reorder only down to the lowest odd level */
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     minLevel|=1;</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :     /* loop maxLevel..minLevel */
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         start=0;</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :         /* loop for all sequences of levels to reorder at the current maxLevel */
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         for(;;) {</span>
<span class="lineNum">     774 </span>            :             /* look for a sequence of levels that are all at &gt;=maxLevel */
<span class="lineNum">     775 </span>            :             /* look for the first index of such a sequence */
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :             while(start&lt;length &amp;&amp; levels[start]&lt;maxLevel) {</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                 ++start;</span>
<span class="lineNum">     778 </span>            :             }
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :             if(start&gt;=length) {</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                 break;  /* no more such sequences */</span>
<span class="lineNum">     781 </span>            :             }
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :             /* look for the limit of such a sequence (the index behind it) */
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :             for(limit=start; ++limit&lt;length &amp;&amp; levels[limit]&gt;=maxLevel;) {}</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :             /*
<span class="lineNum">     787 </span>            :              * sos=start of sequence, eos=end of sequence
<span class="lineNum">     788 </span>            :              *
<span class="lineNum">     789 </span>            :              * The closed (inclusive) interval from sos to eos includes all the logical
<span class="lineNum">     790 </span>            :              * and visual indexes within this sequence. They are logically and
<span class="lineNum">     791 </span>            :              * visually contiguous and in the same range.
<span class="lineNum">     792 </span>            :              *
<span class="lineNum">     793 </span>            :              * For each run, the new visual index=sos+eos-old visual index;
<span class="lineNum">     794 </span>            :              * we pre-add sos+eos into sumOfSosEos -&gt;
<span class="lineNum">     795 </span>            :              * new visual index=sumOfSosEos-old visual index;
<span class="lineNum">     796 </span>            :              */
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :             sumOfSosEos=start+limit-1;</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :             /* reorder each index in the sequence */
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :             do {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :                 indexMap[start]=sumOfSosEos-indexMap[start];</span>
<span class="lineNum">     802 </span>            :             } while(++start&lt;limit);
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :             /* start==limit */
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :             if(limit==length) {</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                 break;  /* no more such sequences */</span>
<span class="lineNum">     807 </span>            :             } else {
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :                 start=limit+1;</span>
<span class="lineNum">     809 </span>            :             }
<span class="lineNum">     810 </span>            :         }
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     } while(--maxLevel&gt;=minLevel);</span>
<span class="lineNum">     812 </span>            : }
<a name="813"><span class="lineNum">     813 </span>            : </a>
<span class="lineNum">     814 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : ubidi_reorderVisual(const UBiDiLevel *levels, int32_t length, int32_t *indexMap) {</span>
<span class="lineNum">     816 </span>            :     int32_t start, end, limit, temp;
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     UBiDiLevel minLevel = 0, maxLevel = 0;</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     if(indexMap==NULL || !prepareReorder(levels, length, indexMap, &amp;minLevel, &amp;maxLevel)) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     821 </span>            :     }
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     /* nothing to do? */
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     if(minLevel==maxLevel &amp;&amp; (minLevel&amp;1)==0) {</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     826 </span>            :     }
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     /* reorder only down to the lowest odd level */
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     minLevel|=1;</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :     /* loop maxLevel..minLevel */
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         start=0;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :         /* loop for all sequences of levels to reorder at the current maxLevel */
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         for(;;) {</span>
<span class="lineNum">     837 </span>            :             /* look for a sequence of levels that are all at &gt;=maxLevel */
<span class="lineNum">     838 </span>            :             /* look for the first index of such a sequence */
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :             while(start&lt;length &amp;&amp; levels[start]&lt;maxLevel) {</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                 ++start;</span>
<span class="lineNum">     841 </span>            :             }
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :             if(start&gt;=length) {</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                 break;  /* no more such runs */</span>
<span class="lineNum">     844 </span>            :             }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :             /* look for the limit of such a sequence (the index behind it) */
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :             for(limit=start; ++limit&lt;length &amp;&amp; levels[limit]&gt;=maxLevel;) {}</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :             /*
<span class="lineNum">     850 </span>            :              * Swap the entire interval of indexes from start to limit-1.
<span class="lineNum">     851 </span>            :              * We don't need to swap the levels for the purpose of this
<span class="lineNum">     852 </span>            :              * algorithm: the sequence of levels that we look at does not
<span class="lineNum">     853 </span>            :              * move anyway.
<span class="lineNum">     854 </span>            :              */
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             end=limit-1;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :             while(start&lt;end) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                 temp=indexMap[start];</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                 indexMap[start]=indexMap[end];</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                 indexMap[end]=temp;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                 ++start;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                 --end;</span>
<span class="lineNum">     863 </span>            :             }
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :             if(limit==length) {</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                 break;  /* no more such sequences */</span>
<span class="lineNum">     867 </span>            :             } else {
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :                 start=limit+1;</span>
<span class="lineNum">     869 </span>            :             }
<span class="lineNum">     870 </span>            :         }
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     } while(--maxLevel&gt;=minLevel);</span>
<span class="lineNum">     872 </span>            : }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /* API functions for logical&lt;-&gt;visual mapping ------------------------------- */
<a name="875"><span class="lineNum">     875 </span>            : </a>
<span class="lineNum">     876 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     877 </span><span class="lineNoCov">          0 : ubidi_getVisualIndex(UBiDi *pBiDi, int32_t logicalIndex, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     int32_t visualIndex=UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     RETURN_IF_NULL_OR_FAILING_ERRCODE(pErrorCode, -1);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :     RETURN_IF_NOT_VALID_PARA_OR_LINE(pBiDi, *pErrorCode, -1);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     RETURN_IF_BAD_RANGE(logicalIndex, 0, pBiDi-&gt;length, *pErrorCode, -1);</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :     /* we can do the trivial cases without the runs array */
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     switch(pBiDi-&gt;direction) {</span>
<span class="lineNum">     885 </span>            :     case UBIDI_LTR:
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         visualIndex=logicalIndex;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     888 </span>            :     case UBIDI_RTL:
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         visualIndex=pBiDi-&gt;length-logicalIndex-1;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     891 </span>            :     default:
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         if(!ubidi_getRuns(pBiDi, pErrorCode)) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :             *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     895 </span>            :         } else {
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :             Run *runs=pBiDi-&gt;runs;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :             int32_t i, visualStart=0, offset, length;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :             /* linear search for the run, search on the visual runs */
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;pBiDi-&gt;runCount; ++i) {</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :                 length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                 offset=logicalIndex-GET_INDEX(runs[i].logicalStart);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 if(offset&gt;=0 &amp;&amp; offset&lt;length) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                     if(IS_EVEN_RUN(runs[i].logicalStart)) {</span>
<span class="lineNum">     905 </span>            :                         /* LTR */
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :                         visualIndex=visualStart+offset;</span>
<span class="lineNum">     907 </span>            :                     } else {
<span class="lineNum">     908 </span>            :                         /* RTL */
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                         visualIndex=visualStart+length-offset-1;</span>
<span class="lineNum">     910 </span>            :                     }
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                     break;          /* exit for loop */</span>
<span class="lineNum">     912 </span>            :                 }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                 visualStart+=length;</span>
<span class="lineNum">     914 </span>            :             }
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :             if(i&gt;=pBiDi-&gt;runCount) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 return UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">     917 </span>            :             }
<span class="lineNum">     918 </span>            :         }
<span class="lineNum">     919 </span>            :     }
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;insertPoints.size&gt;0) {</span>
<span class="lineNum">     922 </span>            :         /* add the number of added marks until the calculated visual index */
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         Run *runs=pBiDi-&gt;runs;</span>
<span class="lineNum">     924 </span>            :         int32_t i, length, insertRemove;
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         int32_t visualStart=0, markFound=0;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :         for(i=0; ; i++, visualStart+=length) {</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :             length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :             insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :             if(insertRemove &amp; (LRM_BEFORE|RLM_BEFORE)) {</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                 markFound++;</span>
<span class="lineNum">     931 </span>            :             }
<span class="lineNum">     932 </span>            :             /* is it the run containing the visual index? */
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :             if(visualIndex&lt;runs[i].visualLimit) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :                 return visualIndex+markFound;</span>
<span class="lineNum">     935 </span>            :             }
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :             if(insertRemove &amp; (LRM_AFTER|RLM_AFTER)) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :                 markFound++;</span>
<span class="lineNum">     938 </span>            :             }
<span class="lineNum">     939 </span>            :         }
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     else if(pBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">     942 </span>            :         /* subtract the number of controls until the calculated visual index */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         Run *runs=pBiDi-&gt;runs;</span>
<span class="lineNum">     944 </span>            :         int32_t i, j, start, limit, length, insertRemove;
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         int32_t visualStart=0, controlFound=0;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         UChar uchar=pBiDi-&gt;text[logicalIndex];</span>
<span class="lineNum">     947 </span>            :         /* is the logical index pointing to a control ? */
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         if(IS_BIDI_CONTROL_CHAR(uchar)) {</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :             return UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">     950 </span>            :         }
<span class="lineNum">     951 </span>            :         /* loop on runs */
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         for(i=0; ; i++, visualStart+=length) {</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :             length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :             insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">     955 </span>            :             /* calculated visual index is beyond this run? */
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :             if(visualIndex&gt;=runs[i].visualLimit) {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                 controlFound-=insertRemove;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     959 </span>            :             }
<span class="lineNum">     960 </span>            :             /* calculated visual index must be within current run */
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :             if(insertRemove==0) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                 return visualIndex-controlFound;</span>
<span class="lineNum">     963 </span>            :             }
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :             if(IS_EVEN_RUN(runs[i].logicalStart)) {</span>
<span class="lineNum">     965 </span>            :                 /* LTR: check from run start to logical index */
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                 start=runs[i].logicalStart;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :                 limit=logicalIndex;</span>
<span class="lineNum">     968 </span>            :             } else {
<span class="lineNum">     969 </span>            :                 /* RTL: check from logical index to run end */
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                 start=logicalIndex+1;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                 limit=GET_INDEX(runs[i].logicalStart)+length;</span>
<span class="lineNum">     972 </span>            :             }
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             for(j=start; j&lt;limit; j++) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :                 uchar=pBiDi-&gt;text[j];</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 if(IS_BIDI_CONTROL_CHAR(uchar)) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                     controlFound++;</span>
<span class="lineNum">     977 </span>            :                 }
<span class="lineNum">     978 </span>            :             }
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :             return visualIndex-controlFound;</span>
<span class="lineNum">     980 </span>            :         }
<span class="lineNum">     981 </span>            :     }
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     return visualIndex;</span>
<span class="lineNum">     984 </span>            : }
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">     987 </span><span class="lineNoCov">          0 : ubidi_getLogicalIndex(UBiDi *pBiDi, int32_t visualIndex, UErrorCode *pErrorCode) {</span>
<span class="lineNum">     988 </span>            :     Run *runs;
<span class="lineNum">     989 </span>            :     int32_t i, runCount, start;
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     RETURN_IF_NULL_OR_FAILING_ERRCODE(pErrorCode, -1);</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     RETURN_IF_NOT_VALID_PARA_OR_LINE(pBiDi, *pErrorCode, -1);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     RETURN_IF_BAD_RANGE(visualIndex, 0, pBiDi-&gt;resultLength, *pErrorCode, -1);</span>
<span class="lineNum">     993 </span>            :     /* we can do the trivial cases without the runs array */
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;insertPoints.size==0 &amp;&amp; pBiDi-&gt;controlCount==0) {</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         if(pBiDi-&gt;direction==UBIDI_LTR) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :             return visualIndex;</span>
<span class="lineNum">     997 </span>            :         }
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :         else if(pBiDi-&gt;direction==UBIDI_RTL) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :             return pBiDi-&gt;length-visualIndex-1;</span>
<span class="lineNum">    1000 </span>            :         }
<span class="lineNum">    1001 </span>            :     }
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     if(!ubidi_getRuns(pBiDi, pErrorCode)) {</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         *pErrorCode=U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    1005 </span>            :     }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     runs=pBiDi-&gt;runs;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     runCount=pBiDi-&gt;runCount;</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     if(pBiDi-&gt;insertPoints.size&gt;0) {</span>
<span class="lineNum">    1010 </span>            :         /* handle inserted LRM/RLM */
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         int32_t markFound=0, insertRemove;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         int32_t visualStart=0, length;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         runs=pBiDi-&gt;runs;</span>
<span class="lineNum">    1014 </span>            :         /* subtract number of marks until visual index */
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :         for(i=0; ; i++, visualStart+=length) {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :             length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :             insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :             if(insertRemove&amp;(LRM_BEFORE|RLM_BEFORE)) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                 if(visualIndex&lt;=(visualStart+markFound)) {</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                     return UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">    1021 </span>            :                 }
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                 markFound++;</span>
<span class="lineNum">    1023 </span>            :             }
<span class="lineNum">    1024 </span>            :             /* is adjusted visual index within this run? */
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :             if(visualIndex&lt;(runs[i].visualLimit+markFound)) {</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :                 visualIndex-=markFound;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1028 </span>            :             }
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :             if(insertRemove&amp;(LRM_AFTER|RLM_AFTER)) {</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                 if(visualIndex==(visualStart+length+markFound)) {</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                     return UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">    1032 </span>            :                 }
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                 markFound++;</span>
<span class="lineNum">    1034 </span>            :             }
<span class="lineNum">    1035 </span>            :         }
<span class="lineNum">    1036 </span>            :     }
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     else if(pBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">    1038 </span>            :         /* handle removed BiDi control characters */
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         int32_t controlFound=0, insertRemove, length;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         int32_t logicalStart, logicalEnd, visualStart=0, j, k;</span>
<span class="lineNum">    1041 </span>            :         UChar uchar;
<span class="lineNum">    1042 </span>            :         UBool evenRun;
<span class="lineNum">    1043 </span>            :         /* add number of controls until visual index */
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :         for(i=0; ; i++, visualStart+=length) {</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :             length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :             insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1047 </span>            :             /* is adjusted visual index beyond current run? */
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :             if(visualIndex&gt;=(runs[i].visualLimit-controlFound+insertRemove)) {</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                 controlFound-=insertRemove;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1051 </span>            :             }
<span class="lineNum">    1052 </span>            :             /* adjusted visual index is within current run */
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :             if(insertRemove==0) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                 visualIndex+=controlFound;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1056 </span>            :             }
<span class="lineNum">    1057 </span>            :             /* count non-control chars until visualIndex */
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :             logicalStart=runs[i].logicalStart;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :             evenRun=IS_EVEN_RUN(logicalStart);</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :             REMOVE_ODD_BIT(logicalStart);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :             logicalEnd=logicalStart+length-1;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :             for(j=0; j&lt;length; j++) {</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                 k= evenRun ? logicalStart+j : logicalEnd-j;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                 uchar=pBiDi-&gt;text[k];</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                 if(IS_BIDI_CONTROL_CHAR(uchar)) {</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                     controlFound++;</span>
<span class="lineNum">    1067 </span>            :                 }
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                 if((visualIndex+controlFound)==(visualStart+j)) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1070 </span>            :                 }
<span class="lineNum">    1071 </span>            :             }
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :             visualIndex+=controlFound;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1074 </span>            :         }
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span>            :     /* handle all cases */
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :     if(runCount&lt;=10) {</span>
<span class="lineNum">    1078 </span>            :         /* linear search for the run */
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         for(i=0; visualIndex&gt;=runs[i].visualLimit; ++i) {}</span>
<span class="lineNum">    1080 </span>            :     } else {
<span class="lineNum">    1081 </span>            :         /* binary search for the run */
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         int32_t begin=0, limit=runCount;</span>
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :         /* the middle if() is guaranteed to find the run, we don't need a loop limit */
<span class="lineNum">    1085 </span>            :         for(;;) {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :             i=(begin+limit)/2;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :             if(visualIndex&gt;=runs[i].visualLimit) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                 begin=i+1;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :             } else if(i==0 || visualIndex&gt;=runs[i-1].visualLimit) {</span>
<span class="lineNum">    1090 </span>            :                 break;
<span class="lineNum">    1091 </span>            :             } else {
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :                 limit=i;</span>
<span class="lineNum">    1093 </span>            :             }
<span class="lineNum">    1094 </span>            :         }
<span class="lineNum">    1095 </span>            :     }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     start=runs[i].logicalStart;</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     if(IS_EVEN_RUN(start)) {</span>
<span class="lineNum">    1099 </span>            :         /* LTR */
<span class="lineNum">    1100 </span>            :         /* the offset in runs[i] is visualIndex-runs[i-1].visualLimit */
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         if(i&gt;0) {</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :             visualIndex-=runs[i-1].visualLimit;</span>
<span class="lineNum">    1103 </span>            :         }
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         return start+visualIndex;</span>
<span class="lineNum">    1105 </span>            :     } else {
<span class="lineNum">    1106 </span>            :         /* RTL */
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         return GET_INDEX(start)+runs[i].visualLimit-visualIndex-1;</span>
<span class="lineNum">    1108 </span>            :     }
<span class="lineNum">    1109 </span>            : }
<a name="1110"><span class="lineNum">    1110 </span>            : </a>
<span class="lineNum">    1111 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 : ubidi_getLogicalMap(UBiDi *pBiDi, int32_t *indexMap, UErrorCode *pErrorCode) {</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_NULL_OR_FAILING_ERRCODE(pErrorCode);</span>
<span class="lineNum">    1114 </span>            :     /* ubidi_countRuns() checks for VALID_PARA_OR_LINE */
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     ubidi_countRuns(pBiDi, pErrorCode);</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1117 </span>            :         /* no op */
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     } else if(indexMap==NULL) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">    1120 </span>            :     } else {
<span class="lineNum">    1121 </span>            :         /* fill a logical-to-visual index map using the runs[] */
<span class="lineNum">    1122 </span>            :         int32_t visualStart, visualLimit, i, j, k;
<span class="lineNum">    1123 </span>            :         int32_t logicalStart, logicalLimit;
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :         Run *runs=pBiDi-&gt;runs;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :         if (pBiDi-&gt;length&lt;=0) {</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1127 </span>            :         }
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         if (pBiDi-&gt;length&gt;pBiDi-&gt;resultLength) {</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :             uprv_memset(indexMap, 0xFF, pBiDi-&gt;length*sizeof(int32_t));</span>
<span class="lineNum">    1130 </span>            :         }
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         visualStart=0;</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         for(j=0; j&lt;pBiDi-&gt;runCount; ++j) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             logicalStart=GET_INDEX(runs[j].logicalStart);</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             visualLimit=runs[j].visualLimit;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             if(IS_EVEN_RUN(runs[j].logicalStart)) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 do { /* LTR */</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                     indexMap[logicalStart++]=visualStart++;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :                 } while(visualStart&lt;visualLimit);</span>
<span class="lineNum">    1140 </span>            :             } else {
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                 logicalStart+=visualLimit-visualStart;  /* logicalLimit */</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 do { /* RTL */</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                     indexMap[--logicalStart]=visualStart++;</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 } while(visualStart&lt;visualLimit);</span>
<span class="lineNum">    1145 </span>            :             }
<span class="lineNum">    1146 </span>            :             /* visualStart==visualLimit; */
<span class="lineNum">    1147 </span>            :         }
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         if(pBiDi-&gt;insertPoints.size&gt;0) {</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :             int32_t markFound=0, runCount=pBiDi-&gt;runCount;</span>
<span class="lineNum">    1151 </span>            :             int32_t length, insertRemove;
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :             visualStart=0;</span>
<span class="lineNum">    1153 </span>            :             /* add number of marks found until each index */
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;runCount; i++, visualStart+=length) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                 length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                 insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_BEFORE|RLM_BEFORE)) {</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :                     markFound++;</span>
<span class="lineNum">    1159 </span>            :                 }
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :                 if(markFound&gt;0) {</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                     logicalStart=GET_INDEX(runs[i].logicalStart);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                     logicalLimit=logicalStart+length;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     for(j=logicalStart; j&lt;logicalLimit; j++) {</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :                         indexMap[j]+=markFound;</span>
<span class="lineNum">    1165 </span>            :                     }
<span class="lineNum">    1166 </span>            :                 }
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_AFTER|RLM_AFTER)) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :                     markFound++;</span>
<span class="lineNum">    1169 </span>            :                 }
<span class="lineNum">    1170 </span>            :             }
<span class="lineNum">    1171 </span>            :         }
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         else if(pBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :             int32_t controlFound=0, runCount=pBiDi-&gt;runCount;</span>
<span class="lineNum">    1174 </span>            :             int32_t length, insertRemove;
<span class="lineNum">    1175 </span>            :             UBool evenRun;
<span class="lineNum">    1176 </span>            :             UChar uchar;
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :             visualStart=0;</span>
<span class="lineNum">    1178 </span>            :             /* subtract number of controls found until each index */
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;runCount; i++, visualStart+=length) {</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                 length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                 insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1182 </span>            :                 /* no control found within previous runs nor within this run */
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                 if((controlFound-insertRemove)==0) {</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1185 </span>            :                 }
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                 logicalStart=runs[i].logicalStart;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :                 evenRun=IS_EVEN_RUN(logicalStart);</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                 REMOVE_ODD_BIT(logicalStart);</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :                 logicalLimit=logicalStart+length;</span>
<span class="lineNum">    1190 </span>            :                 /* if no control within this run */
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                 if(insertRemove==0) {</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :                     for(j=logicalStart; j&lt;logicalLimit; j++) {</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                         indexMap[j]-=controlFound;</span>
<span class="lineNum">    1194 </span>            :                     }
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1196 </span>            :                 }
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                 for(j=0; j&lt;length; j++) {</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                     k= evenRun ? logicalStart+j : logicalLimit-j-1;</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                     uchar=pBiDi-&gt;text[k];</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                     if(IS_BIDI_CONTROL_CHAR(uchar)) {</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :                         controlFound++;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :                         indexMap[k]=UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1204 </span>            :                     }
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                     indexMap[k]-=controlFound;</span>
<span class="lineNum">    1206 </span>            :                 }
<span class="lineNum">    1207 </span>            :             }
<span class="lineNum">    1208 </span>            :         }
<span class="lineNum">    1209 </span>            :     }
<span class="lineNum">    1210 </span>            : }
<a name="1211"><span class="lineNum">    1211 </span>            : </a>
<span class="lineNum">    1212 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 : ubidi_getVisualMap(UBiDi *pBiDi, int32_t *indexMap, UErrorCode *pErrorCode) {</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     RETURN_VOID_IF_NULL_OR_FAILING_ERRCODE(pErrorCode);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     if(indexMap==NULL) {</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :         *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1218 </span>            :     }
<span class="lineNum">    1219 </span>            :     /* ubidi_countRuns() checks for VALID_PARA_OR_LINE */
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     ubidi_countRuns(pBiDi, pErrorCode);</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     if(U_SUCCESS(*pErrorCode)) {</span>
<span class="lineNum">    1222 </span>            :         /* fill a visual-to-logical index map using the runs[] */
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :         Run *runs=pBiDi-&gt;runs, *runsLimit=runs+pBiDi-&gt;runCount;</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :         int32_t logicalStart, visualStart, visualLimit, *pi=indexMap;</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :         if (pBiDi-&gt;resultLength&lt;=0) {</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1228 </span>            :         }
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :         visualStart=0;</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :         for(; runs&lt;runsLimit; ++runs) {</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :             logicalStart=runs-&gt;logicalStart;</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :             visualLimit=runs-&gt;visualLimit;</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             if(IS_EVEN_RUN(logicalStart)) {</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                 do { /* LTR */</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                     *pi++ = logicalStart++;</span>
<span class="lineNum">    1236 </span>            :                 } while(++visualStart&lt;visualLimit);
<span class="lineNum">    1237 </span>            :             } else {
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                 REMOVE_ODD_BIT(logicalStart);</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :                 logicalStart+=visualLimit-visualStart;  /* logicalLimit */</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 do { /* RTL */</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                     *pi++ = --logicalStart;</span>
<span class="lineNum">    1242 </span>            :                 } while(++visualStart&lt;visualLimit);
<span class="lineNum">    1243 </span>            :             }
<span class="lineNum">    1244 </span>            :             /* visualStart==visualLimit; */
<span class="lineNum">    1245 </span>            :         }
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         if(pBiDi-&gt;insertPoints.size&gt;0) {</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :             int32_t markFound=0, runCount=pBiDi-&gt;runCount;</span>
<span class="lineNum">    1249 </span>            :             int32_t insertRemove, i, j, k;
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             runs=pBiDi-&gt;runs;</span>
<span class="lineNum">    1251 </span>            :             /* count all inserted marks */
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;runCount; i++) {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :                 insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_BEFORE|RLM_BEFORE)) {</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :                     markFound++;</span>
<span class="lineNum">    1256 </span>            :                 }
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_AFTER|RLM_AFTER)) {</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                     markFound++;</span>
<span class="lineNum">    1259 </span>            :                 }
<span class="lineNum">    1260 </span>            :             }
<span class="lineNum">    1261 </span>            :             /* move back indexes by number of preceding marks */
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :             k=pBiDi-&gt;resultLength;</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :             for(i=runCount-1; i&gt;=0 &amp;&amp; markFound&gt;0; i--) {</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :                 insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_AFTER|RLM_AFTER)) {</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                     indexMap[--k]= UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                     markFound--;</span>
<span class="lineNum">    1268 </span>            :                 }
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                 visualStart= i&gt;0 ? runs[i-1].visualLimit : 0;</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :                 for(j=runs[i].visualLimit-1; j&gt;=visualStart &amp;&amp; markFound&gt;0; j--) {</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                     indexMap[--k]=indexMap[j];</span>
<span class="lineNum">    1272 </span>            :                 }
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :                 if(insertRemove&amp;(LRM_BEFORE|RLM_BEFORE)) {</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                     indexMap[--k]= UBIDI_MAP_NOWHERE;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                     markFound--;</span>
<span class="lineNum">    1276 </span>            :                 }
<span class="lineNum">    1277 </span>            :             }
<span class="lineNum">    1278 </span>            :         }
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         else if(pBiDi-&gt;controlCount&gt;0) {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :             int32_t runCount=pBiDi-&gt;runCount, logicalEnd;</span>
<span class="lineNum">    1281 </span>            :             int32_t insertRemove, length, i, j, k, m;
<span class="lineNum">    1282 </span>            :             UChar uchar;
<span class="lineNum">    1283 </span>            :             UBool evenRun;
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             runs=pBiDi-&gt;runs;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :             visualStart=0;</span>
<span class="lineNum">    1286 </span>            :             /* move forward indexes by number of preceding controls */
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :             k=0;</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :             for(i=0; i&lt;runCount; i++, visualStart+=length) {</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :                 length=runs[i].visualLimit-visualStart;</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                 insertRemove=runs[i].insertRemove;</span>
<span class="lineNum">    1291 </span>            :                 /* if no control found yet, nothing to do in this run */
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :                 if((insertRemove==0)&amp;&amp;(k==visualStart)) {</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :                     k+=length;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1295 </span>            :                 }
<span class="lineNum">    1296 </span>            :                 /* if no control in this run */
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :                 if(insertRemove==0) {</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :                     visualLimit=runs[i].visualLimit;</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :                     for(j=visualStart; j&lt;visualLimit; j++) {</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                         indexMap[k++]=indexMap[j];</span>
<span class="lineNum">    1301 </span>            :                     }
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1303 </span>            :                 }
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                 logicalStart=runs[i].logicalStart;</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                 evenRun=IS_EVEN_RUN(logicalStart);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                 REMOVE_ODD_BIT(logicalStart);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :                 logicalEnd=logicalStart+length-1;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :                 for(j=0; j&lt;length; j++) {</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :                     m= evenRun ? logicalStart+j : logicalEnd-j;</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :                     uchar=pBiDi-&gt;text[m];</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                     if(!IS_BIDI_CONTROL_CHAR(uchar)) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                         indexMap[k++]=m;</span>
<span class="lineNum">    1313 </span>            :                     }
<span class="lineNum">    1314 </span>            :                 }
<span class="lineNum">    1315 </span>            :             }
<span class="lineNum">    1316 </span>            :         }
<span class="lineNum">    1317 </span>            :     }
<span class="lineNum">    1318 </span>            : }
<a name="1319"><span class="lineNum">    1319 </span>            : </a>
<span class="lineNum">    1320 </span>            : U_CAPI void U_EXPORT2
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 : ubidi_invertMap(const int32_t *srcMap, int32_t *destMap, int32_t length) {</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     if(srcMap!=NULL &amp;&amp; destMap!=NULL &amp;&amp; length&gt;0) {</span>
<span class="lineNum">    1323 </span>            :         const int32_t *pi;
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         int32_t destLength=-1, count=0;</span>
<span class="lineNum">    1325 </span>            :         /* find highest value and count positive indexes in srcMap */
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         pi=srcMap+length;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :         while(pi&gt;srcMap) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             if(*--pi&gt;destLength) {</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                 destLength=*pi;</span>
<span class="lineNum">    1330 </span>            :             }
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :             if(*pi&gt;=0) {</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                 count++;</span>
<span class="lineNum">    1333 </span>            :             }
<span class="lineNum">    1334 </span>            :         }
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         destLength++;           /* add 1 for origin 0 */</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         if(count&lt;destLength) {</span>
<span class="lineNum">    1337 </span>            :             /* we must fill unmatched destMap entries with -1 */
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :             uprv_memset(destMap, 0xFF, destLength*sizeof(int32_t));</span>
<span class="lineNum">    1339 </span>            :         }
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         pi=srcMap+length;</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :         while(length&gt;0) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :             if(*--pi&gt;=0) {</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                 destMap[*pi]=--length;</span>
<span class="lineNum">    1344 </span>            :             } else {
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :                 --length;</span>
<span class="lineNum">    1346 </span>            :             }
<span class="lineNum">    1347 </span>            :         }
<span class="lineNum">    1348 </span>            :     }
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

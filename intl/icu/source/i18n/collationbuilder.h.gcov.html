<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/i18n/collationbuilder.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/i18n</a> - collationbuilder.h<span style="font-size: 80%;"> (source / <a href="collationbuilder.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : *******************************************************************************
<span class="lineNum">       5 </span>            : * Copyright (C) 2013-2014, International Business Machines
<span class="lineNum">       6 </span>            : * Corporation and others.  All Rights Reserved.
<span class="lineNum">       7 </span>            : *******************************************************************************
<span class="lineNum">       8 </span>            : * collationbuilder.h
<span class="lineNum">       9 </span>            : *
<span class="lineNum">      10 </span>            : * created on: 2013may06
<span class="lineNum">      11 </span>            : * created by: Markus W. Scherer
<span class="lineNum">      12 </span>            : */
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #ifndef __COLLATIONBUILDER_H__
<span class="lineNum">      15 </span>            : #define __COLLATIONBUILDER_H__
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #if !UCONFIG_NO_COLLATION
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;unicode/uniset.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;unicode/unistr.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;collationrootelements.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;collationruleparser.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;uvectr32.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;uvectr64.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : struct UParseError;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : U_NAMESPACE_BEGIN
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : struct CollationData;
<span class="lineNum">      33 </span>            : struct CollationTailoring;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : class CEFinalizer;
<span class="lineNum">      36 </span>            : class CollationDataBuilder;
<span class="lineNum">      37 </span>            : class Normalizer2;
<span class="lineNum">      38 </span>            : class Normalizer2Impl;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : class U_I18N_API CollationBuilder : public CollationRuleParser::Sink {
<span class="lineNum">      41 </span>            : public:
<span class="lineNum">      42 </span>            :     CollationBuilder(const CollationTailoring *base, UErrorCode &amp;errorCode);
<span class="lineNum">      43 </span>            :     virtual ~CollationBuilder();
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :     void disableFastLatin() { fastLatinEnabled = FALSE; }
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :     CollationTailoring *parseAndBuild(const UnicodeString &amp;ruleString,
<span class="lineNum">      48 </span>            :                                       const UVersionInfo rulesVersion,
<span class="lineNum">      49 </span>            :                                       CollationRuleParser::Importer *importer,
<span class="lineNum">      50 </span>            :                                       UParseError *outParseError,
<a name="51"><span class="lineNum">      51 </span>            :                                       UErrorCode &amp;errorCode);</a>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     const char *getErrorReason() const { return errorReason; }</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : private:
<span class="lineNum">      56 </span>            :     friend class CEFinalizer;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :     /** Implements CollationRuleParser::Sink. */
<span class="lineNum">      59 </span>            :     virtual void addReset(int32_t strength, const UnicodeString &amp;str,
<span class="lineNum">      60 </span>            :                           const char *&amp;errorReason, UErrorCode &amp;errorCode);
<span class="lineNum">      61 </span>            :     /**
<span class="lineNum">      62 </span>            :      * Returns the secondary or tertiary weight preceding the current node's weight.
<span class="lineNum">      63 </span>            :      * node=nodes[index].
<span class="lineNum">      64 </span>            :      */
<span class="lineNum">      65 </span>            :     uint32_t getWeight16Before(int32_t index, int64_t node, int32_t level);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :     int64_t getSpecialResetPosition(const UnicodeString &amp;str,
<span class="lineNum">      68 </span>            :                                     const char *&amp;parserErrorReason, UErrorCode &amp;errorCode);
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :     /** Implements CollationRuleParser::Sink. */
<span class="lineNum">      71 </span>            :     virtual void addRelation(int32_t strength, const UnicodeString &amp;prefix,
<span class="lineNum">      72 </span>            :                              const UnicodeString &amp;str, const UnicodeString &amp;extension,
<span class="lineNum">      73 </span>            :                              const char *&amp;errorReason, UErrorCode &amp;errorCode);
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :     /**
<span class="lineNum">      76 </span>            :      * Picks one of the current CEs and finds or inserts a node in the graph
<span class="lineNum">      77 </span>            :      * for the CE + strength.
<span class="lineNum">      78 </span>            :      */
<span class="lineNum">      79 </span>            :     int32_t findOrInsertNodeForCEs(int32_t strength, const char *&amp;parserErrorReason,
<span class="lineNum">      80 </span>            :                                    UErrorCode &amp;errorCode);
<span class="lineNum">      81 </span>            :     int32_t findOrInsertNodeForRootCE(int64_t ce, int32_t strength, UErrorCode &amp;errorCode);
<span class="lineNum">      82 </span>            :     /** Finds or inserts the node for a root CE's primary weight. */
<span class="lineNum">      83 </span>            :     int32_t findOrInsertNodeForPrimary(uint32_t p, UErrorCode &amp;errorCode);
<span class="lineNum">      84 </span>            :     /** Finds or inserts the node for a secondary or tertiary weight. */
<span class="lineNum">      85 </span>            :     int32_t findOrInsertWeakNode(int32_t index, uint32_t weight16, int32_t level,
<span class="lineNum">      86 </span>            :                                  UErrorCode &amp;errorCode);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     /**
<span class="lineNum">      89 </span>            :      * Makes and inserts a new tailored node into the list, after the one at index.
<span class="lineNum">      90 </span>            :      * Skips over nodes of weaker strength to maintain collation order
<span class="lineNum">      91 </span>            :      * (&quot;postpone insertion&quot;).
<span class="lineNum">      92 </span>            :      * @return the new node's index
<span class="lineNum">      93 </span>            :      */
<span class="lineNum">      94 </span>            :     int32_t insertTailoredNodeAfter(int32_t index, int32_t strength, UErrorCode &amp;errorCode);
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :     /**
<span class="lineNum">      97 </span>            :      * Inserts a new node into the list, between list-adjacent items.
<span class="lineNum">      98 </span>            :      * The node's previous and next indexes must not be set yet.
<span class="lineNum">      99 </span>            :      * @return the new node's index
<span class="lineNum">     100 </span>            :      */
<span class="lineNum">     101 </span>            :     int32_t insertNodeBetween(int32_t index, int32_t nextIndex, int64_t node,
<span class="lineNum">     102 </span>            :                               UErrorCode &amp;errorCode);
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     /**
<span class="lineNum">     105 </span>            :      * Finds the node which implies or contains a common=05 weight of the given strength
<span class="lineNum">     106 </span>            :      * (secondary or tertiary), if the current node is stronger.
<span class="lineNum">     107 </span>            :      * Skips weaker nodes and tailored nodes if the current node is stronger
<span class="lineNum">     108 </span>            :      * and is followed by an explicit-common-weight node.
<span class="lineNum">     109 </span>            :      * Always returns the input index if that node is no stronger than the given strength.
<span class="lineNum">     110 </span>            :      */
<span class="lineNum">     111 </span>            :     int32_t findCommonNode(int32_t index, int32_t strength) const;
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :     void setCaseBits(const UnicodeString &amp;nfdString,
<span class="lineNum">     114 </span>            :                      const char *&amp;parserErrorReason, UErrorCode &amp;errorCode);
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :     /** Implements CollationRuleParser::Sink. */
<span class="lineNum">     117 </span>            :     virtual void suppressContractions(const UnicodeSet &amp;set, const char *&amp;parserErrorReason,
<span class="lineNum">     118 </span>            :                                       UErrorCode &amp;errorCode);
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :     /** Implements CollationRuleParser::Sink. */
<span class="lineNum">     121 </span>            :     virtual void optimize(const UnicodeSet &amp;set, const char *&amp;parserErrorReason,
<span class="lineNum">     122 </span>            :                           UErrorCode &amp;errorCode);
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     /**
<span class="lineNum">     125 </span>            :      * Adds the mapping and its canonical closure.
<span class="lineNum">     126 </span>            :      * Takes ce32=dataBuilder-&gt;encodeCEs(...) so that the data builder
<span class="lineNum">     127 </span>            :      * need not re-encode the CEs multiple times.
<span class="lineNum">     128 </span>            :      */
<span class="lineNum">     129 </span>            :     uint32_t addWithClosure(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,
<span class="lineNum">     130 </span>            :                             const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">     131 </span>            :                             UErrorCode &amp;errorCode);
<span class="lineNum">     132 </span>            :     uint32_t addOnlyClosure(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,
<span class="lineNum">     133 </span>            :                             const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">     134 </span>            :                             UErrorCode &amp;errorCode);
<span class="lineNum">     135 </span>            :     void addTailComposites(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,
<span class="lineNum">     136 </span>            :                            UErrorCode &amp;errorCode);
<span class="lineNum">     137 </span>            :     UBool mergeCompositeIntoString(const UnicodeString &amp;nfdString, int32_t indexAfterLastStarter,
<span class="lineNum">     138 </span>            :                                    UChar32 composite, const UnicodeString &amp;decomp,
<span class="lineNum">     139 </span>            :                                    UnicodeString &amp;newNFDString, UnicodeString &amp;newString,
<span class="lineNum">     140 </span>            :                                    UErrorCode &amp;errorCode) const;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :     UBool ignorePrefix(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const;
<span class="lineNum">     143 </span>            :     UBool ignoreString(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const;
<span class="lineNum">     144 </span>            :     UBool isFCD(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     void closeOverComposites(UErrorCode &amp;errorCode);
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     uint32_t addIfDifferent(const UnicodeString &amp;prefix, const UnicodeString &amp;str,
<span class="lineNum">     149 </span>            :                             const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">     150 </span>            :                             UErrorCode &amp;errorCode);
<span class="lineNum">     151 </span>            :     static UBool sameCEs(const int64_t ces1[], int32_t ces1Length,
<span class="lineNum">     152 </span>            :                          const int64_t ces2[], int32_t ces2Length);
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :     /**
<span class="lineNum">     155 </span>            :      * Walks the tailoring graph and overwrites tailored nodes with new CEs.
<span class="lineNum">     156 </span>            :      * After this, the graph is destroyed.
<span class="lineNum">     157 </span>            :      * The nodes array can then be used only as a source of tailored CEs.
<span class="lineNum">     158 </span>            :      */
<span class="lineNum">     159 </span>            :     void makeTailoredCEs(UErrorCode &amp;errorCode);
<span class="lineNum">     160 </span>            :     /**
<span class="lineNum">     161 </span>            :      * Counts the tailored nodes of the given strength up to the next node
<span class="lineNum">     162 </span>            :      * which is either stronger or has an explicit weight of this strength.
<span class="lineNum">     163 </span>            :      */
<span class="lineNum">     164 </span>            :     static int32_t countTailoredNodes(const int64_t *nodesArray, int32_t i, int32_t strength);
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :     /** Replaces temporary CEs with the final CEs they point to. */
<span class="lineNum">     167 </span>            :     void finalizeCEs(UErrorCode &amp;errorCode);
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :     /**
<span class="lineNum">     170 </span>            :      * Encodes &quot;temporary CE&quot; data into a CE that fits into the CE32 data structure,
<span class="lineNum">     171 </span>            :      * with 2-byte primary, 1-byte secondary and 6-bit tertiary,
<span class="lineNum">     172 </span>            :      * with valid CE byte values.
<span class="lineNum">     173 </span>            :      *
<span class="lineNum">     174 </span>            :      * The index must not exceed 20 bits (0xfffff).
<span class="lineNum">     175 </span>            :      * The strength must fit into 2 bits (UCOL_PRIMARY..UCOL_QUATERNARY).
<span class="lineNum">     176 </span>            :      *
<span class="lineNum">     177 </span>            :      * Temporary CEs are distinguished from real CEs by their use of
<span class="lineNum">     178 </span>            :      * secondary weights 06..45 which are otherwise reserved for compressed sort keys.
<span class="lineNum">     179 </span>            :      *
<a name="180"><span class="lineNum">     180 </span>            :      * The case bits are unused and available.</a>
<span class="lineNum">     181 </span>            :      */
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     static inline int64_t tempCEFromIndexAndStrength(int32_t index, int32_t strength) {</span>
<span class="lineNum">     183 </span>            :         return
<span class="lineNum">     184 </span>            :             // CE byte offsets, to ensure valid CE bytes, and case bits 11
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :             INT64_C(0x4040000006002000) +</span>
<span class="lineNum">     186 </span>            :             // index bits 19..13 -&gt; primary byte 1 = CE bits 63..56 (byte values 40..BF)
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :             ((int64_t)(index &amp; 0xfe000) &lt;&lt; 43) +</span>
<span class="lineNum">     188 </span>            :             // index bits 12..6 -&gt; primary byte 2 = CE bits 55..48 (byte values 40..BF)
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :             ((int64_t)(index &amp; 0x1fc0) &lt;&lt; 42) +</span>
<span class="lineNum">     190 </span>            :             // index bits 5..0 -&gt; secondary byte 1 = CE bits 31..24 (byte values 06..45)
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :             ((index &amp; 0x3f) &lt;&lt; 24) +</span>
<span class="lineNum">     192 </span>            :             // strength bits 1..0 -&gt; tertiary byte 1 = CE bits 13..8 (byte values 20..23)
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :             (strength &lt;&lt; 8);</span></a>
<span class="lineNum">     194 </span>            :     }
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     static inline int32_t indexFromTempCE(int64_t tempCE) {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         tempCE -= INT64_C(0x4040000006002000);</span>
<span class="lineNum">     197 </span>            :         return
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE &gt;&gt; 43) &amp; 0xfe000) |</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE &gt;&gt; 42) &amp; 0x1fc0) |</span>
<a name="200"><span class="lineNum">     200 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE &gt;&gt; 24) &amp; 0x3f);</span></a>
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     static inline int32_t strengthFromTempCE(int64_t tempCE) {</span>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 :         return ((int32_t)tempCE &gt;&gt; 8) &amp; 3;</span></a>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     static inline UBool isTempCE(int64_t ce) {</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         uint32_t sec = (uint32_t)ce &gt;&gt; 24;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         return 6 &lt;= sec &amp;&amp; sec &lt;= 0x45;</span>
<a name="208"><span class="lineNum">     208 </span>            :     }</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     static inline int32_t indexFromTempCE32(uint32_t tempCE32) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         tempCE32 -= 0x40400620;</span>
<span class="lineNum">     212 </span>            :         return
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE32 &gt;&gt; 11) &amp; 0xfe000) |</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE32 &gt;&gt; 10) &amp; 0x1fc0) |</span>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :             ((int32_t)(tempCE32 &gt;&gt; 8) &amp; 0x3f);</span></a>
<span class="lineNum">     216 </span>            :     }
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     static inline UBool isTempCE32(uint32_t ce32) {</span>
<span class="lineNum">     218 </span>            :         return
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :             (ce32 &amp; 0xff) &gt;= 2 &amp;&amp;  // not a long-primary/long-secondary CE32</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :             6 &lt;= ((ce32 &gt;&gt; 8) &amp; 0xff) &amp;&amp; ((ce32 &gt;&gt; 8) &amp; 0xff) &lt;= 0x45;</span>
<span class="lineNum">     221 </span>            :     }
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :     static int32_t ceStrength(int64_t ce);
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     /** At most 1M nodes, limited by the 20 bits in node bit fields. */
<span class="lineNum">     226 </span>            :     static const int32_t MAX_INDEX = 0xfffff;
<span class="lineNum">     227 </span>            :     /**
<span class="lineNum">     228 </span>            :      * Node bit 6 is set on a primary node if there are nodes
<span class="lineNum">     229 </span>            :      * with secondary values below the common secondary weight (05).
<span class="lineNum">     230 </span>            :      */
<span class="lineNum">     231 </span>            :     static const int32_t HAS_BEFORE2 = 0x40;
<span class="lineNum">     232 </span>            :     /**
<span class="lineNum">     233 </span>            :      * Node bit 5 is set on a primary or secondary node if there are nodes
<span class="lineNum">     234 </span>            :      * with tertiary values below the common tertiary weight (05).
<span class="lineNum">     235 </span>            :      */
<span class="lineNum">     236 </span>            :     static const int32_t HAS_BEFORE3 = 0x20;
<span class="lineNum">     237 </span>            :     /**
<span class="lineNum">     238 </span>            :      * Node bit 3 distinguishes a tailored node, which has no weight value,
<span class="lineNum">     239 </span>            :      * from a node with an explicit (root or default) weight.
<span class="lineNum">     240 </span>            :      */
<a name="241"><span class="lineNum">     241 </span>            :     static const int32_t IS_TAILORED = 8;</a>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     static inline int64_t nodeFromWeight32(uint32_t weight32) {</span>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :         return (int64_t)weight32 &lt;&lt; 32;</span></a>
<span class="lineNum">     245 </span>            :     }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     static inline int64_t nodeFromWeight16(uint32_t weight16) {</span>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :         return (int64_t)weight16 &lt;&lt; 48;</span></a>
<span class="lineNum">     248 </span>            :     }
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     static inline int64_t nodeFromPreviousIndex(int32_t previous) {</span>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :         return (int64_t)previous &lt;&lt; 28;</span></a>
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     static inline int64_t nodeFromNextIndex(int32_t next) {</span>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :         return next &lt;&lt; 8;</span></a>
<span class="lineNum">     254 </span>            :     }
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     static inline int64_t nodeFromStrength(int32_t strength) {</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         return strength;</span>
<a name="257"><span class="lineNum">     257 </span>            :     }</a>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     static inline uint32_t weight32FromNode(int64_t node) {</span>
<a name="260"><span class="lineNum">     260 </span><span class="lineNoCov">          0 :         return (uint32_t)(node &gt;&gt; 32);</span></a>
<span class="lineNum">     261 </span>            :     }
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     static inline uint32_t weight16FromNode(int64_t node) {</span>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :         return (uint32_t)(node &gt;&gt; 48) &amp; 0xffff;</span></a>
<span class="lineNum">     264 </span>            :     }
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     static inline int32_t previousIndexFromNode(int64_t node) {</span>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :         return (int32_t)(node &gt;&gt; 28) &amp; MAX_INDEX;</span></a>
<span class="lineNum">     267 </span>            :     }
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     static inline int32_t nextIndexFromNode(int64_t node) {</span>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :         return ((int32_t)node &gt;&gt; 8) &amp; MAX_INDEX;</span></a>
<span class="lineNum">     270 </span>            :     }
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     static inline int32_t strengthFromNode(int64_t node) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         return (int32_t)node &amp; 3;</span>
<a name="273"><span class="lineNum">     273 </span>            :     }</a>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     static inline UBool nodeHasBefore2(int64_t node) {</span>
<a name="276"><span class="lineNum">     276 </span><span class="lineNoCov">          0 :         return (node &amp; HAS_BEFORE2) != 0;</span></a>
<span class="lineNum">     277 </span>            :     }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     static inline UBool nodeHasBefore3(int64_t node) {</span>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :         return (node &amp; HAS_BEFORE3) != 0;</span></a>
<span class="lineNum">     280 </span>            :     }
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     static inline UBool nodeHasAnyBefore(int64_t node) {</span>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :         return (node &amp; (HAS_BEFORE2 | HAS_BEFORE3)) != 0;</span></a>
<span class="lineNum">     283 </span>            :     }
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     static inline UBool isTailoredNode(int64_t node) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         return (node &amp; IS_TAILORED) != 0;</span>
<a name="286"><span class="lineNum">     286 </span>            :     }</a>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     static inline int64_t changeNodePreviousIndex(int64_t node, int32_t previous) {</span>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :         return (node &amp; INT64_C(0xffff00000fffffff)) | nodeFromPreviousIndex(previous);</span></a>
<span class="lineNum">     290 </span>            :     }
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     static inline int64_t changeNodeNextIndex(int64_t node, int32_t next) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         return (node &amp; INT64_C(0xfffffffff00000ff)) | nodeFromNextIndex(next);</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     const Normalizer2 &amp;nfd, &amp;fcd;
<span class="lineNum">     296 </span>            :     const Normalizer2Impl &amp;nfcImpl;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :     const CollationTailoring *base;
<span class="lineNum">     299 </span>            :     const CollationData *baseData;
<span class="lineNum">     300 </span>            :     const CollationRootElements rootElements;
<span class="lineNum">     301 </span>            :     uint32_t variableTop;
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :     CollationDataBuilder *dataBuilder;
<span class="lineNum">     304 </span>            :     UBool fastLatinEnabled;
<span class="lineNum">     305 </span>            :     UnicodeSet optimizeSet;
<span class="lineNum">     306 </span>            :     const char *errorReason;
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     int64_t ces[Collation::MAX_EXPANSION_LENGTH];
<span class="lineNum">     309 </span>            :     int32_t cesLength;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :     /**
<span class="lineNum">     312 </span>            :      * Indexes of nodes with root primary weights, sorted by primary.
<span class="lineNum">     313 </span>            :      * Compact form of a TreeMap from root primary to node index.
<span class="lineNum">     314 </span>            :      *
<span class="lineNum">     315 </span>            :      * This is a performance optimization for finding reset positions.
<span class="lineNum">     316 </span>            :      * Without this, we would have to search through the entire nodes list.
<span class="lineNum">     317 </span>            :      * It also allows storing root primary weights in list head nodes,
<span class="lineNum">     318 </span>            :      * without previous index, leaving room in root primary nodes for 32-bit primary weights.
<span class="lineNum">     319 </span>            :      */
<span class="lineNum">     320 </span>            :     UVector32 rootPrimaryIndexes;
<span class="lineNum">     321 </span>            :     /**
<span class="lineNum">     322 </span>            :      * Data structure for assigning tailored weights and CEs.
<span class="lineNum">     323 </span>            :      * Doubly-linked lists of nodes in mostly collation order.
<span class="lineNum">     324 </span>            :      * Each list starts with a root primary node and ends with a nextIndex of 0.
<span class="lineNum">     325 </span>            :      *
<span class="lineNum">     326 </span>            :      * When there are any nodes in the list, then there is always a root primary node at index 0.
<span class="lineNum">     327 </span>            :      * This allows some code not to have to check explicitly for nextIndex==0.
<span class="lineNum">     328 </span>            :      *
<span class="lineNum">     329 </span>            :      * Root primary nodes have 32-bit weights but do not have previous indexes.
<span class="lineNum">     330 </span>            :      * All other nodes have at most 16-bit weights and do have previous indexes.
<span class="lineNum">     331 </span>            :      *
<span class="lineNum">     332 </span>            :      * Nodes with explicit weights store root collator weights,
<span class="lineNum">     333 </span>            :      * or default weak weights (e.g., secondary 05) for stronger nodes.
<span class="lineNum">     334 </span>            :      * &quot;Tailored&quot; nodes, with the IS_TAILORED bit set,
<span class="lineNum">     335 </span>            :      * do not store explicit weights but rather
<span class="lineNum">     336 </span>            :      * create a difference of a certain strength from the preceding node.
<span class="lineNum">     337 </span>            :      *
<span class="lineNum">     338 </span>            :      * A root node is followed by either
<span class="lineNum">     339 </span>            :      * - a root/default node of the same strength, or
<span class="lineNum">     340 </span>            :      * - a root/default node of the next-weaker strength, or
<span class="lineNum">     341 </span>            :      * - a tailored node of the same strength.
<span class="lineNum">     342 </span>            :      *
<span class="lineNum">     343 </span>            :      * A node of a given strength normally implies &quot;common&quot; weights on weaker levels.
<span class="lineNum">     344 </span>            :      *
<span class="lineNum">     345 </span>            :      * A node with HAS_BEFORE2 must be immediately followed by
<span class="lineNum">     346 </span>            :      * a secondary node with an explicit below-common weight, then a secondary tailored node,
<span class="lineNum">     347 </span>            :      * and later an explicit common-secondary node.
<span class="lineNum">     348 </span>            :      * The below-common weight can be a root weight,
<span class="lineNum">     349 </span>            :      * or it can be BEFORE_WEIGHT16 for tailoring before an implied common weight
<span class="lineNum">     350 </span>            :      * or before the lowest root weight.
<span class="lineNum">     351 </span>            :      * (&amp;[before 2] resets to an explicit secondary node so that
<span class="lineNum">     352 </span>            :      * the following addRelation(secondary) tailors right after that.
<span class="lineNum">     353 </span>            :      * If we did not have this node and instead were to reset on the primary node,
<span class="lineNum">     354 </span>            :      * then addRelation(secondary) would skip forward to the the COMMON_WEIGHT16 node.)
<span class="lineNum">     355 </span>            :      *
<span class="lineNum">     356 </span>            :      * If the flag is not set, then there are no explicit secondary nodes
<span class="lineNum">     357 </span>            :      * with the common or lower weights.
<span class="lineNum">     358 </span>            :      *
<span class="lineNum">     359 </span>            :      * Same for HAS_BEFORE3 for tertiary nodes and weights.
<span class="lineNum">     360 </span>            :      * A node must not have both flags set.
<span class="lineNum">     361 </span>            :      *
<span class="lineNum">     362 </span>            :      * Tailored CEs are initially represented in a CollationDataBuilder as temporary CEs
<span class="lineNum">     363 </span>            :      * which point to stable indexes in this list,
<span class="lineNum">     364 </span>            :      * and temporary CEs stored in a CollationDataBuilder only point to tailored nodes.
<span class="lineNum">     365 </span>            :      *
<span class="lineNum">     366 </span>            :      * A temporary CE in the ces[] array may point to a non-tailored reset-before-position node,
<span class="lineNum">     367 </span>            :      * until the next relation is added.
<span class="lineNum">     368 </span>            :      *
<span class="lineNum">     369 </span>            :      * At the end, the tailored weights are allocated as necessary,
<span class="lineNum">     370 </span>            :      * then the tailored nodes are replaced with final CEs,
<span class="lineNum">     371 </span>            :      * and the CollationData is rewritten by replacing temporary CEs with final ones.
<span class="lineNum">     372 </span>            :      *
<span class="lineNum">     373 </span>            :      * We cannot simply insert new nodes in the middle of the array
<span class="lineNum">     374 </span>            :      * because that would invalidate the indexes stored in existing temporary CEs.
<span class="lineNum">     375 </span>            :      * We need to use a linked graph with stable indexes to existing nodes.
<span class="lineNum">     376 </span>            :      * A doubly-linked list seems easiest to maintain.
<span class="lineNum">     377 </span>            :      *
<span class="lineNum">     378 </span>            :      * Each node is stored as an int64_t, with its fields stored as bit fields.
<span class="lineNum">     379 </span>            :      *
<span class="lineNum">     380 </span>            :      * Root primary node:
<span class="lineNum">     381 </span>            :      * - primary weight: 32 bits 63..32
<span class="lineNum">     382 </span>            :      * - reserved/unused/zero: 4 bits 31..28
<span class="lineNum">     383 </span>            :      *
<span class="lineNum">     384 </span>            :      * Weaker root nodes &amp; tailored nodes:
<span class="lineNum">     385 </span>            :      * - a weight: 16 bits 63..48
<span class="lineNum">     386 </span>            :      *   + a root or default weight for a non-tailored node
<span class="lineNum">     387 </span>            :      *   + unused/zero for a tailored node
<span class="lineNum">     388 </span>            :      * - index to the previous node: 20 bits 47..28
<span class="lineNum">     389 </span>            :      *
<span class="lineNum">     390 </span>            :      * All types of nodes:
<span class="lineNum">     391 </span>            :      * - index to the next node: 20 bits 27..8
<span class="lineNum">     392 </span>            :      *   + nextIndex=0 in last node per root-primary list
<span class="lineNum">     393 </span>            :      * - reserved/unused/zero bits: bits 7, 4, 2
<span class="lineNum">     394 </span>            :      * - HAS_BEFORE2: bit 6
<span class="lineNum">     395 </span>            :      * - HAS_BEFORE3: bit 5
<span class="lineNum">     396 </span>            :      * - IS_TAILORED: bit 3
<span class="lineNum">     397 </span>            :      * - the difference strength (primary/secondary/tertiary/quaternary): 2 bits 1..0
<span class="lineNum">     398 </span>            :      *
<span class="lineNum">     399 </span>            :      * We could allocate structs with pointers, but we would have to store them
<span class="lineNum">     400 </span>            :      * in a pointer list so that they can be indexed from temporary CEs,
<span class="lineNum">     401 </span>            :      * and they would require more memory allocations.
<span class="lineNum">     402 </span>            :      */
<span class="lineNum">     403 </span>            :     UVector64 nodes;
<span class="lineNum">     404 </span>            : };
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : U_NAMESPACE_END
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : #endif  // !UCONFIG_NO_COLLATION
<span class="lineNum">     409 </span>            : #endif  // __COLLATIONBUILDER_H__
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/i18n/collationbuilder.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/i18n</a> - collationbuilder.cpp<span style="font-size: 80%;"> (source / <a href="collationbuilder.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">890</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : *******************************************************************************
<span class="lineNum">       5 </span>            : * Copyright (C) 2013-2014, International Business Machines
<span class="lineNum">       6 </span>            : * Corporation and others.  All Rights Reserved.
<span class="lineNum">       7 </span>            : *******************************************************************************
<span class="lineNum">       8 </span>            : * collationbuilder.cpp
<span class="lineNum">       9 </span>            : *
<span class="lineNum">      10 </span>            : * (replaced the former ucol_bld.cpp)
<span class="lineNum">      11 </span>            : *
<span class="lineNum">      12 </span>            : * created on: 2013may06
<span class="lineNum">      13 </span>            : * created by: Markus W. Scherer
<span class="lineNum">      14 </span>            : */
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">      17 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      18 </span>            : #endif
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #if !UCONFIG_NO_COLLATION
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;unicode/caniter.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;unicode/normalizer2.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;unicode/tblcoll.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;unicode/parseerr.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;unicode/uchar.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;unicode/ucol.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;unicode/unistr.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;unicode/usetiter.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;unicode/utf16.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;unicode/uversion.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;collation.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;collationbuilder.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;collationdata.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;collationdatabuilder.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;collationfastlatin.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;collationroot.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;collationrootelements.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;collationruleparser.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;collationsettings.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;collationtailoring.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;collationweights.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;normalizer2impl.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;ucol_imp.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;utf16collationiterator.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : U_NAMESPACE_BEGIN
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : namespace {
<span class="lineNum">      54 </span>            : 
<a name="55"><span class="lineNum">      55 </span>            : class BundleImporter : public CollationRuleParser::Importer {</a>
<span class="lineNum">      56 </span>            : public:
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     BundleImporter() {}</span>
<span class="lineNum">      58 </span>            :     virtual ~BundleImporter();
<span class="lineNum">      59 </span>            :     virtual void getRules(
<span class="lineNum">      60 </span>            :             const char *localeID, const char *collationType,
<span class="lineNum">      61 </span>            :             UnicodeString &amp;rules,
<span class="lineNum">      62 </span>            :             const char *&amp;errorReason, UErrorCode &amp;errorCode);
<a name="63"><span class="lineNum">      63 </span>            : };</a>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span><span class="lineNoCov">          0 : BundleImporter::~BundleImporter() {}</span>
<a name="66"><span class="lineNum">      66 </span>            : </a>
<span class="lineNum">      67 </span>            : void
<span class="lineNum">      68 </span><span class="lineNoCov">          0 : BundleImporter::getRules(</span>
<span class="lineNum">      69 </span>            :         const char *localeID, const char *collationType,
<span class="lineNum">      70 </span>            :         UnicodeString &amp;rules,
<span class="lineNum">      71 </span>            :         const char *&amp; /*errorReason*/, UErrorCode &amp;errorCode) {
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     CollationLoader::loadRules(localeID, collationType, rules, errorCode);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : }  // namespace
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : // RuleBasedCollator implementation ---------------------------------------- ***
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : // These methods are here, rather than in rulebasedcollator.cpp,
<span class="lineNum">      80 </span>            : // for modularization:
<span class="lineNum">      81 </span>            : // Most code using Collator does not need to build a Collator from rules.
<span class="lineNum">      82 </span>            : // By moving these constructors and helper methods to a separate file,
<a name="83"><span class="lineNum">      83 </span>            : // most code will not have a static dependency on the builder code.</a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator()</span>
<span class="lineNum">      86 </span>            :         : data(NULL),
<span class="lineNum">      87 </span>            :           settings(NULL),
<span class="lineNum">      88 </span>            :           tailoring(NULL),
<span class="lineNum">      89 </span>            :           cacheEntry(NULL),
<span class="lineNum">      90 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">      91 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator(const UnicodeString &amp;rules, UErrorCode &amp;errorCode)</span>
<span class="lineNum">      96 </span>            :         : data(NULL),
<span class="lineNum">      97 </span>            :           settings(NULL),
<span class="lineNum">      98 </span>            :           tailoring(NULL),
<span class="lineNum">      99 </span>            :           cacheEntry(NULL),
<span class="lineNum">     100 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">     101 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     internalBuildTailoring(rules, UCOL_DEFAULT, UCOL_DEFAULT, NULL, NULL, errorCode);</span>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator(const UnicodeString &amp;rules, ECollationStrength strength,</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :                                      UErrorCode &amp;errorCode)</span>
<span class="lineNum">     108 </span>            :         : data(NULL),
<span class="lineNum">     109 </span>            :           settings(NULL),
<span class="lineNum">     110 </span>            :           tailoring(NULL),
<span class="lineNum">     111 </span>            :           cacheEntry(NULL),
<span class="lineNum">     112 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">     113 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     internalBuildTailoring(rules, strength, UCOL_DEFAULT, NULL, NULL, errorCode);</span>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator(const UnicodeString &amp;rules,</span>
<span class="lineNum">     119 </span>            :                                      UColAttributeValue decompositionMode,
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                                      UErrorCode &amp;errorCode)</span>
<span class="lineNum">     121 </span>            :         : data(NULL),
<span class="lineNum">     122 </span>            :           settings(NULL),
<span class="lineNum">     123 </span>            :           tailoring(NULL),
<span class="lineNum">     124 </span>            :           cacheEntry(NULL),
<span class="lineNum">     125 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">     126 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     internalBuildTailoring(rules, UCOL_DEFAULT, decompositionMode, NULL, NULL, errorCode);</span>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator(const UnicodeString &amp;rules,</span>
<span class="lineNum">     132 </span>            :                                      ECollationStrength strength,
<span class="lineNum">     133 </span>            :                                      UColAttributeValue decompositionMode,
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                                      UErrorCode &amp;errorCode)</span>
<span class="lineNum">     135 </span>            :         : data(NULL),
<span class="lineNum">     136 </span>            :           settings(NULL),
<span class="lineNum">     137 </span>            :           tailoring(NULL),
<span class="lineNum">     138 </span>            :           cacheEntry(NULL),
<span class="lineNum">     139 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">     140 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     internalBuildTailoring(rules, strength, decompositionMode, NULL, NULL, errorCode);</span>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : RuleBasedCollator::RuleBasedCollator(const UnicodeString &amp;rules,</span>
<span class="lineNum">     146 </span>            :                                      UParseError &amp;parseError, UnicodeString &amp;reason,
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :                                      UErrorCode &amp;errorCode)</span>
<span class="lineNum">     148 </span>            :         : data(NULL),
<span class="lineNum">     149 </span>            :           settings(NULL),
<span class="lineNum">     150 </span>            :           tailoring(NULL),
<span class="lineNum">     151 </span>            :           cacheEntry(NULL),
<span class="lineNum">     152 </span>            :           validLocale(&quot;&quot;),
<span class="lineNum">     153 </span>            :           explicitlySetAttributes(0),
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :           actualLocaleIsSameAsValid(FALSE) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     internalBuildTailoring(rules, UCOL_DEFAULT, UCOL_DEFAULT, &amp;parseError, &amp;reason, errorCode);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : }</span>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<span class="lineNum">     158 </span>            : void
<span class="lineNum">     159 </span><span class="lineNoCov">          0 : RuleBasedCollator::internalBuildTailoring(const UnicodeString &amp;rules,</span>
<span class="lineNum">     160 </span>            :                                           int32_t strength,
<span class="lineNum">     161 </span>            :                                           UColAttributeValue decompositionMode,
<span class="lineNum">     162 </span>            :                                           UParseError *outParseError, UnicodeString *outReason,
<span class="lineNum">     163 </span>            :                                           UErrorCode &amp;errorCode) {
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     const CollationTailoring *base = CollationRoot::getRoot(errorCode);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     if(outReason != NULL) { outReason-&gt;remove(); }</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     CollationBuilder builder(base, errorCode);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     UVersionInfo noVersion = { 0, 0, 0, 0 };</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     BundleImporter importer;</span>
<span class="lineNum">     170 </span>            :     LocalPointer&lt;CollationTailoring&gt; t(builder.parseAndBuild(rules, noVersion,
<span class="lineNum">     171 </span>            :                                                              &amp;importer,
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :                                                              outParseError, errorCode));</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         const char *reason = builder.getErrorReason();</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         if(reason != NULL &amp;&amp; outReason != NULL) {</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :             *outReason = UnicodeString(reason, -1, US_INV);</span>
<span class="lineNum">     177 </span>            :         }
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     179 </span>            :     }
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     t-&gt;actualLocale.setToBogus();</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     adoptTailoring(t.orphan(), errorCode);</span>
<span class="lineNum">     182 </span>            :     // Set attributes after building the collator,
<span class="lineNum">     183 </span>            :     // to keep the default settings consistent with the rule string.
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     if(strength != UCOL_DEFAULT) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         setAttribute(UCOL_STRENGTH, (UColAttributeValue)strength, errorCode);</span>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     if(decompositionMode != UCOL_DEFAULT) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         setAttribute(UCOL_NORMALIZATION_MODE, decompositionMode, errorCode);</span>
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span>            : }
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : // CollationBuilder implementation ----------------------------------------- ***
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : // Some compilers don't care if constants are defined in the .cpp file.
<span class="lineNum">     195 </span>            : // MS Visual C++ does not like it, but gcc requires it. clang does not care.
<span class="lineNum">     196 </span>            : #ifndef _MSC_VER
<span class="lineNum">     197 </span>            : const int32_t CollationBuilder::HAS_BEFORE2;
<span class="lineNum">     198 </span>            : const int32_t CollationBuilder::HAS_BEFORE3;
<a name="199"><span class="lineNum">     199 </span>            : #endif</a>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : CollationBuilder::CollationBuilder(const CollationTailoring *b, UErrorCode &amp;errorCode)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         : nfd(*Normalizer2::getNFDInstance(errorCode)),</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :           fcd(*Normalizer2Factory::getFCDInstance(errorCode)),</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :           nfcImpl(*Normalizer2Factory::getNFCImpl(errorCode)),</span>
<span class="lineNum">     205 </span>            :           base(b),
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :           baseData(b-&gt;data),</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :           rootElements(b-&gt;data-&gt;rootElements, b-&gt;data-&gt;rootElementsLength),</span>
<span class="lineNum">     208 </span>            :           variableTop(0),
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :           dataBuilder(new CollationDataBuilder(errorCode)), fastLatinEnabled(TRUE),</span>
<span class="lineNum">     210 </span>            :           errorReason(NULL),
<span class="lineNum">     211 </span>            :           cesLength(0),
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :           rootPrimaryIndexes(errorCode), nodes(errorCode) {</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     nfcImpl.ensureCanonIterData(errorCode);</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         errorReason = &quot;CollationBuilder fields initialization failed&quot;;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     217 </span>            :     }
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     if(dataBuilder == NULL) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     221 </span>            :     }
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     dataBuilder-&gt;initForTailoring(baseData, errorCode);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :         errorReason = &quot;CollationBuilder initialization failed&quot;;</span>
<span class="lineNum">     225 </span>            :     }
<a name="226"><span class="lineNum">     226 </span>            : }</a>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : CollationBuilder::~CollationBuilder() {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     delete dataBuilder;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : }</span>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<span class="lineNum">     232 </span>            : CollationTailoring *
<span class="lineNum">     233 </span><span class="lineNoCov">          0 : CollationBuilder::parseAndBuild(const UnicodeString &amp;ruleString,</span>
<span class="lineNum">     234 </span>            :                                 const UVersionInfo rulesVersion,
<span class="lineNum">     235 </span>            :                                 CollationRuleParser::Importer *importer,
<span class="lineNum">     236 </span>            :                                 UParseError *outParseError,
<span class="lineNum">     237 </span>            :                                 UErrorCode &amp;errorCode) {
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     if(baseData-&gt;rootElements == NULL) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         errorCode = U_MISSING_RESOURCE_ERROR;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         errorReason = &quot;missing root elements data, tailoring not supported&quot;;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     243 </span>            :     }
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     LocalPointer&lt;CollationTailoring&gt; tailoring(new CollationTailoring(base-&gt;settings));</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if(tailoring.isNull() || tailoring-&gt;isBogus()) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         errorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     248 </span>            :     }
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     CollationRuleParser parser(baseData, errorCode);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="lineNum">     251 </span>            :     // Note: This always bases &amp;[last variable] and &amp;[first regular]
<span class="lineNum">     252 </span>            :     // on the root collator's maxVariable/variableTop.
<span class="lineNum">     253 </span>            :     // If we wanted this to change after [maxVariable x], then we would keep
<span class="lineNum">     254 </span>            :     // the tailoring.settings pointer here and read its variableTop when we need it.
<span class="lineNum">     255 </span>            :     // See http://unicode.org/cldr/trac/ticket/6070
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     variableTop = base-&gt;settings-&gt;variableTop;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     parser.setSink(this);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     parser.setImporter(importer);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     CollationSettings &amp;ownedSettings = *SharedObject::copyOnWrite(tailoring-&gt;settings);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     parser.parse(ruleString, ownedSettings, outParseError, errorCode);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     errorReason = parser.getErrorReason();</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     if(dataBuilder-&gt;hasMappings()) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         makeTailoredCEs(errorCode);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         closeOverComposites(errorCode);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         finalizeCEs(errorCode);</span>
<span class="lineNum">     267 </span>            :         // Copy all of ASCII, and Latin-1 letters, into each tailoring.
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         optimizeSet.add(0, 0x7f);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         optimizeSet.add(0xc0, 0xff);</span>
<span class="lineNum">     270 </span>            :         // Hangul is decomposed on the fly during collation,
<span class="lineNum">     271 </span>            :         // and the tailoring data is always built with HANGUL_TAG specials.
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         optimizeSet.remove(Hangul::HANGUL_BASE, Hangul::HANGUL_END);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         dataBuilder-&gt;optimize(optimizeSet, errorCode);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         tailoring-&gt;ensureOwnedData(errorCode);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         if(fastLatinEnabled) { dataBuilder-&gt;enableFastLatin(); }</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :         dataBuilder-&gt;build(*tailoring-&gt;ownedData, errorCode);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         tailoring-&gt;builder = dataBuilder;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         dataBuilder = NULL;</span>
<span class="lineNum">     280 </span>            :     } else {
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         tailoring-&gt;data = baseData;</span>
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return NULL; }</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     ownedSettings.fastLatinOptions = CollationFastLatin::getOptions(</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         tailoring-&gt;data, ownedSettings,</span>
<span class="lineNum">     286 </span>            :         ownedSettings.fastLatinPrimaries, UPRV_LENGTHOF(ownedSettings.fastLatinPrimaries));
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     tailoring-&gt;rules = ruleString;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     tailoring-&gt;rules.getTerminatedBuffer();  // ensure NUL-termination</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     tailoring-&gt;setVersion(base-&gt;version, rulesVersion);</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     return tailoring.orphan();</span>
<span class="lineNum">     291 </span>            : }
<a name="292"><span class="lineNum">     292 </span>            : </a>
<span class="lineNum">     293 </span>            : void
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : CollationBuilder::addReset(int32_t strength, const UnicodeString &amp;str,</span>
<span class="lineNum">     295 </span>            :                            const char *&amp;parserErrorReason, UErrorCode &amp;errorCode) {
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     U_ASSERT(!str.isEmpty());</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if(str.charAt(0) == CollationRuleParser::POS_LEAD) {</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         ces[0] = getSpecialResetPosition(str, parserErrorReason, errorCode);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         cesLength = 1;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         U_ASSERT((ces[0] &amp; Collation::CASE_AND_QUATERNARY_MASK) == 0);</span>
<span class="lineNum">     303 </span>            :     } else {
<span class="lineNum">     304 </span>            :         // normal reset to a character or string
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         UnicodeString nfdString = nfd.normalize(str, errorCode);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;normalizing the reset position&quot;;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     309 </span>            :         }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         cesLength = dataBuilder-&gt;getCEs(nfdString, ces, 0);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         if(cesLength &gt; Collation::MAX_EXPANSION_LENGTH) {</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :             errorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;reset position maps to too many collation elements (more than 31)&quot;;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     315 </span>            :         }
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     if(strength == UCOL_IDENTICAL) { return; }  // simple reset-at-position</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     // &amp;[before strength]position
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     U_ASSERT(UCOL_PRIMARY &lt;= strength &amp;&amp; strength &lt;= UCOL_TERTIARY);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     int32_t index = findOrInsertNodeForCEs(strength, parserErrorReason, errorCode);</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     325 </span>            :     // If the index is for a &quot;weaker&quot; node,
<span class="lineNum">     326 </span>            :     // then skip backwards over this and further &quot;weaker&quot; nodes.
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     while(strengthFromNode(node) &gt; strength) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         index = previousIndexFromNode(node);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(index);</span>
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :     // Find or insert a node whose index we will put into a temporary CE.
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if(strengthFromNode(node) == strength &amp;&amp; isTailoredNode(node)) {</span>
<span class="lineNum">     334 </span>            :         // Reset to just before this same-strength tailored node.
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         index = previousIndexFromNode(node);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     } else if(strength == UCOL_PRIMARY) {</span>
<span class="lineNum">     337 </span>            :         // root primary node (has no previous index)
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         uint32_t p = weight32FromNode(node);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         if(p == 0) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;reset primary-before ignorable not possible&quot;;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     343 </span>            :         }
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         if(p &lt;= rootElements.getFirstPrimary()) {</span>
<span class="lineNum">     345 </span>            :             // There is no primary gap between ignorables and the space-first-primary.
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;reset primary-before first non-ignorable not supported&quot;;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     349 </span>            :         }
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         if(p == Collation::FIRST_TRAILING_PRIMARY) {</span>
<span class="lineNum">     351 </span>            :             // We do not support tailoring to an unassigned-implicit CE.
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;reset primary-before [first trailing] not supported&quot;;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     355 </span>            :         }
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         p = rootElements.getPrimaryBefore(p, baseData-&gt;isCompressiblePrimary(p));</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         index = findOrInsertNodeForPrimary(p, errorCode);</span>
<span class="lineNum">     358 </span>            :         // Go to the last node in this list:
<span class="lineNum">     359 </span>            :         // Tailor after the last node between adjacent root nodes.
<span class="lineNum">     360 </span>            :         for(;;) {
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             node = nodes.elementAti(index);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :             int32_t nextIndex = nextIndexFromNode(node);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :             if(nextIndex == 0) { break; }</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             index = nextIndex;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     366 </span>            :     } else {
<span class="lineNum">     367 </span>            :         // &amp;[before 2] or &amp;[before 3]
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         index = findCommonNode(index, UCOL_SECONDARY);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         if(strength &gt;= UCOL_TERTIARY) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :             index = findCommonNode(index, UCOL_TERTIARY);</span>
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span>            :         // findCommonNode() stayed on the stronger node or moved to
<span class="lineNum">     373 </span>            :         // an explicit common-weight node of the reset-before strength.
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(index);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         if(strengthFromNode(node) == strength) {</span>
<span class="lineNum">     376 </span>            :             // Found a same-strength node with an explicit weight.
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :             uint32_t weight16 = weight16FromNode(node);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             if(weight16 == 0) {</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                 if(strength == UCOL_SECONDARY) {</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                     parserErrorReason = &quot;reset secondary-before secondary ignorable not possible&quot;;</span>
<span class="lineNum">     382 </span>            :                 } else {
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :                     parserErrorReason = &quot;reset tertiary-before completely ignorable not possible&quot;;</span>
<span class="lineNum">     384 </span>            :                 }
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     386 </span>            :             }
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             U_ASSERT(weight16 &gt; Collation::BEFORE_WEIGHT16);</span>
<span class="lineNum">     388 </span>            :             // Reset to just before this node.
<span class="lineNum">     389 </span>            :             // Insert the preceding same-level explicit weight if it is not there already.
<span class="lineNum">     390 </span>            :             // Which explicit weight immediately precedes this one?
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             weight16 = getWeight16Before(index, node, strength);</span>
<span class="lineNum">     392 </span>            :             // Does this preceding weight have a node?
<span class="lineNum">     393 </span>            :             uint32_t previousWeight16;
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :             int32_t previousIndex = previousIndexFromNode(node);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :             for(int32_t i = previousIndex;; i = previousIndexFromNode(node)) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 node = nodes.elementAti(i);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 int32_t previousStrength = strengthFromNode(node);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                 if(previousStrength &lt; strength) {</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                     U_ASSERT(weight16 &gt;= Collation::COMMON_WEIGHT16 || i == previousIndex);</span>
<span class="lineNum">     400 </span>            :                     // Either the reset element has an above-common weight and
<span class="lineNum">     401 </span>            :                     // the parent node provides the implied common weight,
<span class="lineNum">     402 </span>            :                     // or the reset element has a weight&lt;=common in the node
<span class="lineNum">     403 </span>            :                     // right after the parent, and we need to insert the preceding weight.
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                     previousWeight16 = Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                 } else if(previousStrength == strength &amp;&amp; !isTailoredNode(node)) {</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                     previousWeight16 = weight16FromNode(node);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     409 </span>            :                 }
<span class="lineNum">     410 </span>            :                 // Skip weaker nodes and same-level tailored nodes.
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :             if(previousWeight16 == weight16) {</span>
<span class="lineNum">     413 </span>            :                 // The preceding weight has a node,
<span class="lineNum">     414 </span>            :                 // maybe with following weaker or tailored nodes.
<span class="lineNum">     415 </span>            :                 // Reset to the last of them.
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                 index = previousIndex;</span>
<span class="lineNum">     417 </span>            :             } else {
<span class="lineNum">     418 </span>            :                 // Insert a node with the preceding weight, reset to that.
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                 node = nodeFromWeight16(weight16) | nodeFromStrength(strength);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :                 index = insertNodeBetween(previousIndex, index, node, errorCode);</span>
<span class="lineNum">     421 </span>            :             }
<span class="lineNum">     422 </span>            :         } else {
<span class="lineNum">     423 </span>            :             // Found a stronger node with implied strength-common weight.
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :             uint32_t weight16 = getWeight16Before(index, node, strength);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             index = findOrInsertWeakNode(index, weight16, strength, errorCode);</span>
<span class="lineNum">     426 </span>            :         }
<span class="lineNum">     427 </span>            :         // Strength of the temporary CE = strength of its reset position.
<span class="lineNum">     428 </span>            :         // Code above raises an error if the before-strength is stronger.
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         strength = ceStrength(ces[cesLength - 1]);</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;inserting reset position for &amp;[before n]&quot;;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     ces[cesLength - 1] = tempCEFromIndexAndStrength(index, strength);</span>
<span class="lineNum">     436 </span>            : }
<a name="437"><span class="lineNum">     437 </span>            : </a>
<span class="lineNum">     438 </span>            : uint32_t
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : CollationBuilder::getWeight16Before(int32_t index, int64_t node, int32_t level) {</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     U_ASSERT(strengthFromNode(node) &lt; level || !isTailoredNode(node));</span>
<span class="lineNum">     441 </span>            :     // Collect the root CE weights if this node is for a root CE.
<span class="lineNum">     442 </span>            :     // If it is not, then return the low non-primary boundary for a tailored CE.
<span class="lineNum">     443 </span>            :     uint32_t t;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     if(strengthFromNode(node) == UCOL_TERTIARY) {</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         t = weight16FromNode(node);</span>
<span class="lineNum">     446 </span>            :     } else {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         t = Collation::COMMON_WEIGHT16;  // Stronger node with implied common weight.</span>
<span class="lineNum">     448 </span>            :     }
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     while(strengthFromNode(node) &gt; UCOL_SECONDARY) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         index = previousIndexFromNode(node);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(index);</span>
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     if(isTailoredNode(node)) {</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         return Collation::BEFORE_WEIGHT16;</span>
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span>            :     uint32_t s;
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     if(strengthFromNode(node) == UCOL_SECONDARY) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         s = weight16FromNode(node);</span>
<span class="lineNum">     459 </span>            :     } else {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         s = Collation::COMMON_WEIGHT16;  // Stronger node with implied common weight.</span>
<span class="lineNum">     461 </span>            :     }
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     while(strengthFromNode(node) &gt; UCOL_PRIMARY) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         index = previousIndexFromNode(node);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(index);</span>
<span class="lineNum">     465 </span>            :     }
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     if(isTailoredNode(node)) {</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         return Collation::BEFORE_WEIGHT16;</span>
<span class="lineNum">     468 </span>            :     }
<span class="lineNum">     469 </span>            :     // [p, s, t] is a root CE. Return the preceding weight for the requested level.
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     uint32_t p = weight32FromNode(node);</span>
<span class="lineNum">     471 </span>            :     uint32_t weight16;
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     if(level == UCOL_SECONDARY) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         weight16 = rootElements.getSecondaryBefore(p, s);</span>
<span class="lineNum">     474 </span>            :     } else {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         weight16 = rootElements.getTertiaryBefore(p, s, t);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         U_ASSERT((weight16 &amp; ~Collation::ONLY_TERTIARY_MASK) == 0);</span>
<span class="lineNum">     477 </span>            :     }
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     return weight16;</span>
<span class="lineNum">     479 </span>            : }
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : int64_t
<span class="lineNum">     482 </span><span class="lineNoCov">          0 : CollationBuilder::getSpecialResetPosition(const UnicodeString &amp;str,</span>
<span class="lineNum">     483 </span>            :                                           const char *&amp;parserErrorReason, UErrorCode &amp;errorCode) {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     U_ASSERT(str.length() == 2);</span>
<span class="lineNum">     485 </span>            :     int64_t ce;
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     int32_t strength = UCOL_PRIMARY;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     UBool isBoundary = FALSE;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     UChar32 pos = str.charAt(1) - CollationRuleParser::POS_BASE;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     U_ASSERT(0 &lt;= pos &amp;&amp; pos &lt;= CollationRuleParser::LAST_TRAILING);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     switch(pos) {</span>
<span class="lineNum">     491 </span>            :     case CollationRuleParser::FIRST_TERTIARY_IGNORABLE:
<span class="lineNum">     492 </span>            :         // Quaternary CEs are not supported.
<span class="lineNum">     493 </span>            :         // Non-zero quaternary weights are possible only on tertiary or stronger CEs.
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     495 </span>            :     case CollationRuleParser::LAST_TERTIARY_IGNORABLE:
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     497 </span>            :     case CollationRuleParser::FIRST_SECONDARY_IGNORABLE: {
<span class="lineNum">     498 </span>            :         // Look for a tailored tertiary node after [0, 0, 0].
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         int32_t index = findOrInsertNodeForRootCE(0, UCOL_TERTIARY, errorCode);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         if((index = nextIndexFromNode(node)) != 0) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :             node = nodes.elementAti(index);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :             U_ASSERT(strengthFromNode(node) &lt;= UCOL_TERTIARY);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :             if(isTailoredNode(node) &amp;&amp; strengthFromNode(node) == UCOL_TERTIARY) {</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                 return tempCEFromIndexAndStrength(index, UCOL_TERTIARY);</span>
<span class="lineNum">     507 </span>            :             }
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         return rootElements.getFirstTertiaryCE();</span>
<span class="lineNum">     510 </span>            :         // No need to look for nodeHasAnyBefore() on a tertiary node.
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span>            :     case CollationRuleParser::LAST_SECONDARY_IGNORABLE:
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         ce = rootElements.getLastTertiaryCE();</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         strength = UCOL_TERTIARY;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     516 </span>            :     case CollationRuleParser::FIRST_PRIMARY_IGNORABLE: {
<span class="lineNum">     517 </span>            :         // Look for a tailored secondary node after [0, 0, *].
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         int32_t index = findOrInsertNodeForRootCE(0, UCOL_SECONDARY, errorCode);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         while((index = nextIndexFromNode(node)) != 0) {</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :             node = nodes.elementAti(index);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :             strength = strengthFromNode(node);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :             if(strength &lt; UCOL_SECONDARY) { break; }</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :             if(strength == UCOL_SECONDARY) {</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 if(isTailoredNode(node)) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                     if(nodeHasBefore3(node)) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                         index = nextIndexFromNode(nodes.elementAti(nextIndexFromNode(node)));</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         U_ASSERT(isTailoredNode(nodes.elementAti(index)));</span>
<span class="lineNum">     530 </span>            :                     }
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                     return tempCEFromIndexAndStrength(index, UCOL_SECONDARY);</span>
<span class="lineNum">     532 </span>            :                 } else {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     534 </span>            :                 }
<span class="lineNum">     535 </span>            :             }
<span class="lineNum">     536 </span>            :         }
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         ce = rootElements.getFirstSecondaryCE();</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :         strength = UCOL_SECONDARY;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     540 </span>            :     }
<span class="lineNum">     541 </span>            :     case CollationRuleParser::LAST_PRIMARY_IGNORABLE:
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         ce = rootElements.getLastSecondaryCE();</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         strength = UCOL_SECONDARY;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     545 </span>            :     case CollationRuleParser::FIRST_VARIABLE:
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         ce = rootElements.getFirstPrimaryCE();</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         isBoundary = TRUE;  // FractionalUCA.txt: FDD1 00A0, SPACE first primary</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     549 </span>            :     case CollationRuleParser::LAST_VARIABLE:
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         ce = rootElements.lastCEWithPrimaryBefore(variableTop + 1);</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     552 </span>            :     case CollationRuleParser::FIRST_REGULAR:
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         ce = rootElements.firstCEWithPrimaryAtLeast(variableTop + 1);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         isBoundary = TRUE;  // FractionalUCA.txt: FDD1 263A, SYMBOL first primary</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     556 </span>            :     case CollationRuleParser::LAST_REGULAR:
<span class="lineNum">     557 </span>            :         // Use the Hani-first-primary rather than the actual last &quot;regular&quot; CE before it,
<span class="lineNum">     558 </span>            :         // for backward compatibility with behavior before the introduction of
<span class="lineNum">     559 </span>            :         // script-first-primary CEs in the root collator.
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         ce = rootElements.firstCEWithPrimaryAtLeast(</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :             baseData-&gt;getFirstPrimaryForGroup(USCRIPT_HAN));</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     563 </span>            :     case CollationRuleParser::FIRST_IMPLICIT:
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         ce = baseData-&gt;getSingleCE(0x4e00, errorCode);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     566 </span>            :     case CollationRuleParser::LAST_IMPLICIT:
<span class="lineNum">     567 </span>            :         // We do not support tailoring to an unassigned-implicit CE.
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;reset to [last implicit] not supported&quot;;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     571 </span>            :     case CollationRuleParser::FIRST_TRAILING:
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         ce = Collation::makeCE(Collation::FIRST_TRAILING_PRIMARY);</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         isBoundary = TRUE;  // trailing first primary (there is no mapping for it)</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     575 </span>            :     case CollationRuleParser::LAST_TRAILING:
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         errorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;LDML forbids tailoring to U+FFFF&quot;;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     579 </span>            :     default:
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         U_ASSERT(FALSE);</span>
<span class="lineNum">     581 </span>            :         return 0;
<span class="lineNum">     582 </span>            :     }
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     int32_t index = findOrInsertNodeForRootCE(ce, strength, errorCode);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     if((pos &amp; 1) == 0) {</span>
<span class="lineNum">     588 </span>            :         // even pos = [first xyz]
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         if(!nodeHasAnyBefore(node) &amp;&amp; isBoundary) {</span>
<span class="lineNum">     590 </span>            :             // A &lt;group&gt; first primary boundary is artificially added to FractionalUCA.txt.
<span class="lineNum">     591 </span>            :             // It is reachable via its special contraction, but is not normally used.
<span class="lineNum">     592 </span>            :             // Find the first character tailored after the boundary CE,
<span class="lineNum">     593 </span>            :             // or the first real root CE after it.
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :             if((index = nextIndexFromNode(node)) != 0) {</span>
<span class="lineNum">     595 </span>            :                 // If there is a following node, then it must be tailored
<span class="lineNum">     596 </span>            :                 // because there are no root CEs with a boundary primary
<span class="lineNum">     597 </span>            :                 // and non-common secondary/tertiary weights.
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                 node = nodes.elementAti(index);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                 U_ASSERT(isTailoredNode(node));</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :                 ce = tempCEFromIndexAndStrength(index, strength);</span>
<span class="lineNum">     601 </span>            :             } else {
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                 U_ASSERT(strength == UCOL_PRIMARY);</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :                 uint32_t p = (uint32_t)(ce &gt;&gt; 32);</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 int32_t pIndex = rootElements.findPrimary(p);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :                 UBool isCompressible = baseData-&gt;isCompressiblePrimary(p);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 p = rootElements.getPrimaryAfter(p, pIndex, isCompressible);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                 ce = Collation::makeCE(p);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                 index = findOrInsertNodeForRootCE(ce, UCOL_PRIMARY, errorCode);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                 if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                 node = nodes.elementAti(index);</span>
<span class="lineNum">     611 </span>            :             }
<span class="lineNum">     612 </span>            :         }
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         if(nodeHasAnyBefore(node)) {</span>
<span class="lineNum">     614 </span>            :             // Get the first node that was tailored before this one at a weaker strength.
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :             if(nodeHasBefore2(node)) {</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                 index = nextIndexFromNode(nodes.elementAti(nextIndexFromNode(node)));</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 node = nodes.elementAti(index);</span>
<span class="lineNum">     618 </span>            :             }
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             if(nodeHasBefore3(node)) {</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                 index = nextIndexFromNode(nodes.elementAti(nextIndexFromNode(node)));</span>
<span class="lineNum">     621 </span>            :             }
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             U_ASSERT(isTailoredNode(nodes.elementAti(index)));</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             ce = tempCEFromIndexAndStrength(index, strength);</span>
<span class="lineNum">     624 </span>            :         }
<span class="lineNum">     625 </span>            :     } else {
<span class="lineNum">     626 </span>            :         // odd pos = [last xyz]
<span class="lineNum">     627 </span>            :         // Find the last node that was tailored after the [last xyz]
<span class="lineNum">     628 </span>            :         // at a strength no greater than the position's strength.
<span class="lineNum">     629 </span>            :         for(;;) {
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :             int32_t nextIndex = nextIndexFromNode(node);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :             if(nextIndex == 0) { break; }</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :             int64_t nextNode = nodes.elementAti(nextIndex);</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :             if(strengthFromNode(nextNode) &lt; strength) { break; }</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :             index = nextIndex;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :             node = nextNode;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     637 </span>            :         // Do not make a temporary CE for a root node.
<span class="lineNum">     638 </span>            :         // This last node might be the node for the root CE itself,
<span class="lineNum">     639 </span>            :         // or a node with a common secondary or tertiary weight.
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         if(isTailoredNode(node)) {</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :             ce = tempCEFromIndexAndStrength(index, strength);</span>
<span class="lineNum">     642 </span>            :         }
<span class="lineNum">     643 </span>            :     }
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     return ce;</span>
<span class="lineNum">     645 </span>            : }
<a name="646"><span class="lineNum">     646 </span>            : </a>
<span class="lineNum">     647 </span>            : void
<span class="lineNum">     648 </span><span class="lineNoCov">          0 : CollationBuilder::addRelation(int32_t strength, const UnicodeString &amp;prefix,</span>
<span class="lineNum">     649 </span>            :                               const UnicodeString &amp;str, const UnicodeString &amp;extension,
<span class="lineNum">     650 </span>            :                               const char *&amp;parserErrorReason, UErrorCode &amp;errorCode) {
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     UnicodeString nfdPrefix;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     if(!prefix.isEmpty()) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :         nfd.normalize(prefix, nfdPrefix, errorCode);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;normalizing the relation prefix&quot;;</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     658 </span>            :         }
<span class="lineNum">     659 </span>            :     }
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     UnicodeString nfdString = nfd.normalize(str, errorCode);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;normalizing the relation string&quot;;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :     // The runtime code decomposes Hangul syllables on the fly,
<span class="lineNum">     667 </span>            :     // with recursive processing but without making the Jamo pieces visible for matching.
<span class="lineNum">     668 </span>            :     // It does not work with certain types of contextual mappings.
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     int32_t nfdLength = nfdString.length();</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     if(nfdLength &gt;= 2) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         UChar c = nfdString.charAt(0);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         if(Hangul::isJamoL(c) || Hangul::isJamoV(c)) {</span>
<span class="lineNum">     673 </span>            :             // While handling a Hangul syllable, contractions starting with Jamo L or V
<span class="lineNum">     674 </span>            :             // would not see the following Jamo of that syllable.
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;contractions starting with conjoining Jamo L or V not supported&quot;;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     678 </span>            :         }
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         c = nfdString.charAt(nfdLength - 1);</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         if(Hangul::isJamoL(c) ||</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :                 (Hangul::isJamoV(c) &amp;&amp; Hangul::isJamoL(nfdString.charAt(nfdLength - 2)))) {</span>
<span class="lineNum">     682 </span>            :             // A contraction ending with Jamo L or L+V would require
<span class="lineNum">     683 </span>            :             // generating Hangul syllables in addTailComposites() (588 for a Jamo L),
<span class="lineNum">     684 </span>            :             // or decomposing a following Hangul syllable on the fly, during contraction matching.
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;contractions ending with conjoining Jamo L or L+V not supported&quot;;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span>            :         // A Hangul syllable completely inside a contraction is ok.
<span class="lineNum">     690 </span>            :     }
<span class="lineNum">     691 </span>            :     // Note: If there is a prefix, then the parser checked that
<span class="lineNum">     692 </span>            :     // both the prefix and the string beging with NFC boundaries (not Jamo V or T).
<span class="lineNum">     693 </span>            :     // Therefore: prefix.isEmpty() || !isJamoVOrT(nfdString.charAt(0))
<span class="lineNum">     694 </span>            :     // (While handling a Hangul syllable, prefixes on Jamo V or T
<span class="lineNum">     695 </span>            :     // would not see the previous Jamo of that syllable.)
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     if(strength != UCOL_IDENTICAL) {</span>
<span class="lineNum">     698 </span>            :         // Find the node index after which we insert the new tailored node.
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         int32_t index = findOrInsertNodeForCEs(strength, parserErrorReason, errorCode);</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         U_ASSERT(cesLength &gt; 0);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         int64_t ce = ces[cesLength - 1];</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         if(strength == UCOL_PRIMARY &amp;&amp; !isTempCE(ce) &amp;&amp; (uint32_t)(ce &gt;&gt; 32) == 0) {</span>
<span class="lineNum">     703 </span>            :             // There is no primary gap between ignorables and the space-first-primary.
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;tailoring primary after ignorables not supported&quot;;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     707 </span>            :         }
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         if(strength == UCOL_QUATERNARY &amp;&amp; ce == 0) {</span>
<span class="lineNum">     709 </span>            :             // The CE data structure does not support non-zero quaternary weights
<span class="lineNum">     710 </span>            :             // on tertiary ignorables.
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :             errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;tailoring quaternary after tertiary ignorables not supported&quot;;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     714 </span>            :         }
<span class="lineNum">     715 </span>            :         // Insert the new tailored node.
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         index = insertTailoredNodeAfter(index, strength, errorCode);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;modifying collation elements&quot;;</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     720 </span>            :         }
<span class="lineNum">     721 </span>            :         // Strength of the temporary CE:
<span class="lineNum">     722 </span>            :         // The new relation may yield a stronger CE but not a weaker one.
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :         int32_t tempStrength = ceStrength(ce);</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         if(strength &lt; tempStrength) { tempStrength = strength; }</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         ces[cesLength - 1] = tempCEFromIndexAndStrength(index, tempStrength);</span>
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     setCaseBits(nfdString, parserErrorReason, errorCode);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     int32_t cesLengthBeforeExtension = cesLength;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     if(!extension.isEmpty()) {</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :         UnicodeString nfdExtension = nfd.normalize(extension, errorCode);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;normalizing the relation extension&quot;;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     737 </span>            :         }
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         cesLength = dataBuilder-&gt;getCEs(nfdExtension, ces, cesLength);</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :         if(cesLength &gt; Collation::MAX_EXPANSION_LENGTH) {</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             errorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :             parserErrorReason =</span>
<span class="lineNum">     742 </span>            :                 &quot;extension string adds too many collation elements (more than 31 total)&quot;;
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     744 </span>            :         }
<span class="lineNum">     745 </span>            :     }
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     uint32_t ce32 = Collation::UNASSIGNED_CE32;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if((prefix != nfdPrefix || str != nfdString) &amp;&amp;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :             !ignorePrefix(prefix, errorCode) &amp;&amp; !ignoreString(str, errorCode)) {</span>
<span class="lineNum">     749 </span>            :         // Map from the original input to the CEs.
<span class="lineNum">     750 </span>            :         // We do this in case the canonical closure is incomplete,
<span class="lineNum">     751 </span>            :         // so that it is possible to explicitly provide the missing mappings.
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         ce32 = addIfDifferent(prefix, str, ces, cesLength, ce32, errorCode);</span>
<span class="lineNum">     753 </span>            :     }
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     addWithClosure(nfdPrefix, nfdString, ces, cesLength, ce32, errorCode);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;writing collation elements&quot;;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     cesLength = cesLengthBeforeExtension;</span>
<span class="lineNum">     760 </span>            : }
<a name="761"><span class="lineNum">     761 </span>            : </a>
<span class="lineNum">     762 </span>            : int32_t
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : CollationBuilder::findOrInsertNodeForCEs(int32_t strength, const char *&amp;parserErrorReason,</span>
<span class="lineNum">     764 </span>            :                                          UErrorCode &amp;errorCode) {
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     U_ASSERT(UCOL_PRIMARY &lt;= strength &amp;&amp; strength &lt;= UCOL_QUATERNARY);</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :     // Find the last CE that is at least as &quot;strong&quot; as the requested difference.
<span class="lineNum">     769 </span>            :     // Note: Stronger is smaller (UCOL_PRIMARY=0).
<span class="lineNum">     770 </span>            :     int64_t ce;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     for(;; --cesLength) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         if(cesLength == 0) {</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :             ce = ces[0] = 0;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :             cesLength = 1;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     776 </span>            :         } else {
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :             ce = ces[cesLength - 1];</span>
<span class="lineNum">     778 </span>            :         }
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         if(ceStrength(ce) &lt;= strength) { break; }</span>
<span class="lineNum">     780 </span>            :     }
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     if(isTempCE(ce)) {</span>
<span class="lineNum">     783 </span>            :         // No need to findCommonNode() here for lower levels
<span class="lineNum">     784 </span>            :         // because insertTailoredNodeAfter() will do that anyway.
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         return indexFromTempCE(ce);</span>
<span class="lineNum">     786 </span>            :     }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     // root CE
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     if((uint8_t)(ce &gt;&gt; 56) == Collation::UNASSIGNED_IMPLICIT_BYTE) {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         errorCode = U_UNSUPPORTED_ERROR;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;tailoring relative to an unassigned code point not supported&quot;;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     793 </span>            :     }
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     return findOrInsertNodeForRootCE(ce, strength, errorCode);</span>
<span class="lineNum">     795 </span>            : }
<a name="796"><span class="lineNum">     796 </span>            : </a>
<span class="lineNum">     797 </span>            : int32_t
<span class="lineNum">     798 </span><span class="lineNoCov">          0 : CollationBuilder::findOrInsertNodeForRootCE(int64_t ce, int32_t strength, UErrorCode &amp;errorCode) {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     U_ASSERT((uint8_t)(ce &gt;&gt; 56) != Collation::UNASSIGNED_IMPLICIT_BYTE);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :     // Find or insert the node for each of the root CE's weights,
<span class="lineNum">     803 </span>            :     // down to the requested level/strength.
<span class="lineNum">     804 </span>            :     // Root CEs must have common=zero quaternary weights (for which we never insert any nodes).
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     U_ASSERT((ce &amp; 0xc0) == 0);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     int32_t index = findOrInsertNodeForPrimary((uint32_t)(ce &gt;&gt; 32), errorCode);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     if(strength &gt;= UCOL_SECONDARY) {</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         uint32_t lower32 = (uint32_t)ce;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         index = findOrInsertWeakNode(index, lower32 &gt;&gt; 16, UCOL_SECONDARY, errorCode);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         if(strength &gt;= UCOL_TERTIARY) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :             index = findOrInsertWeakNode(index, lower32 &amp; Collation::ONLY_TERTIARY_MASK,</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                                          UCOL_TERTIARY, errorCode);</span>
<span class="lineNum">     813 </span>            :         }
<span class="lineNum">     814 </span>            :     }
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     return index;</span>
<span class="lineNum">     816 </span>            : }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : namespace {
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : /**
<span class="lineNum">     821 </span>            :  * Like Java Collections.binarySearch(List, key, Comparator).
<span class="lineNum">     822 </span>            :  *
<span class="lineNum">     823 </span>            :  * @return the index&gt;=0 where the item was found,
<span class="lineNum">     824 </span>            :  *         or the index&lt;0 for inserting the string at ~index in sorted order
<span class="lineNum">     825 </span>            :  *         (index into rootPrimaryIndexes)
<a name="826"><span class="lineNum">     826 </span>            :  */</a>
<span class="lineNum">     827 </span>            : int32_t
<span class="lineNum">     828 </span><span class="lineNoCov">          0 : binarySearchForRootPrimaryNode(const int32_t *rootPrimaryIndexes, int32_t length,</span>
<span class="lineNum">     829 </span>            :                                const int64_t *nodes, uint32_t p) {
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     if(length == 0) { return ~0; }</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     int32_t start = 0;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     int32_t limit = length;</span>
<span class="lineNum">     833 </span>            :     for (;;) {
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         int32_t i = (start + limit) / 2;</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :         int64_t node = nodes[rootPrimaryIndexes[i]];</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         uint32_t nodePrimary = (uint32_t)(node &gt;&gt; 32);  // weight32FromNode(node)</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :         if (p == nodePrimary) {</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :             return i;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         } else if (p &lt; nodePrimary) {</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :             if (i == start) {</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                 return ~start;  // insert s before i</span>
<span class="lineNum">     842 </span>            :             }
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :             limit = i;</span>
<span class="lineNum">     844 </span>            :         } else {
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :             if (i == start) {</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                 return ~(start + 1);  // insert s after i</span>
<span class="lineNum">     847 </span>            :             }
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             start = i;</span>
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     851 </span>            : }
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : }  // namespace
<a name="854"><span class="lineNum">     854 </span>            : </a>
<span class="lineNum">     855 </span>            : int32_t
<span class="lineNum">     856 </span><span class="lineNoCov">          0 : CollationBuilder::findOrInsertNodeForPrimary(uint32_t p, UErrorCode &amp;errorCode) {</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     int32_t rootIndex = binarySearchForRootPrimaryNode(</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :         rootPrimaryIndexes.getBuffer(), rootPrimaryIndexes.size(), nodes.getBuffer(), p);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     if(rootIndex &gt;= 0) {</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         return rootPrimaryIndexes.elementAti(rootIndex);</span>
<span class="lineNum">     863 </span>            :     } else {
<span class="lineNum">     864 </span>            :         // Start a new list of nodes with this primary.
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         int32_t index = nodes.size();</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :         nodes.addElement(nodeFromWeight32(p), errorCode);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         rootPrimaryIndexes.insertElementAt(index, ~rootIndex, errorCode);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         return index;</span>
<span class="lineNum">     869 </span>            :     }
<span class="lineNum">     870 </span>            : }
<a name="871"><span class="lineNum">     871 </span>            : </a>
<span class="lineNum">     872 </span>            : int32_t
<span class="lineNum">     873 </span><span class="lineNoCov">          0 : CollationBuilder::findOrInsertWeakNode(int32_t index, uint32_t weight16, int32_t level, UErrorCode &amp;errorCode) {</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     U_ASSERT(0 &lt;= index &amp;&amp; index &lt; nodes.size());</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     U_ASSERT(UCOL_SECONDARY &lt;= level &amp;&amp; level &lt;= UCOL_TERTIARY);</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     if(weight16 == Collation::COMMON_WEIGHT16) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         return findCommonNode(index, level);</span>
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :     // If this will be the first below-common weight for the parent node,
<span class="lineNum">     883 </span>            :     // then we will also need to insert a common weight after it.
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     U_ASSERT(strengthFromNode(node) &lt; level);  // parent node is stronger</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     if(weight16 != 0 &amp;&amp; weight16 &lt; Collation::COMMON_WEIGHT16) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         int32_t hasThisLevelBefore = level == UCOL_SECONDARY ? HAS_BEFORE2 : HAS_BEFORE3;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         if((node &amp; hasThisLevelBefore) == 0) {</span>
<span class="lineNum">     889 </span>            :             // The parent node has an implied level-common weight.
<span class="lineNum">     890 </span>            :             int64_t commonNode =
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                 nodeFromWeight16(Collation::COMMON_WEIGHT16) | nodeFromStrength(level);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :             if(level == UCOL_SECONDARY) {</span>
<span class="lineNum">     893 </span>            :                 // Move the HAS_BEFORE3 flag from the parent node
<span class="lineNum">     894 </span>            :                 // to the new secondary common node.
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                 commonNode |= node &amp; HAS_BEFORE3;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 node &amp;= ~(int64_t)HAS_BEFORE3;</span>
<span class="lineNum">     897 </span>            :             }
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :             nodes.setElementAt(node | hasThisLevelBefore, index);</span>
<span class="lineNum">     899 </span>            :             // Insert below-common-weight node.
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :             int32_t nextIndex = nextIndexFromNode(node);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :             node = nodeFromWeight16(weight16) | nodeFromStrength(level);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             index = insertNodeBetween(index, nextIndex, node, errorCode);</span>
<span class="lineNum">     903 </span>            :             // Insert common-weight node.
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :             insertNodeBetween(index, nextIndex, commonNode, errorCode);</span>
<span class="lineNum">     905 </span>            :             // Return index of below-common-weight node.
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :             return index;</span>
<span class="lineNum">     907 </span>            :         }
<span class="lineNum">     908 </span>            :     }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :     // Find the root CE's weight for this level.
<span class="lineNum">     911 </span>            :     // Postpone insertion if not found:
<span class="lineNum">     912 </span>            :     // Insert the new root node before the next stronger node,
<span class="lineNum">     913 </span>            :     // or before the next root node with the same strength and a larger weight.
<span class="lineNum">     914 </span>            :     int32_t nextIndex;
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     while((nextIndex = nextIndexFromNode(node)) != 0) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(nextIndex);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         int32_t nextStrength = strengthFromNode(node);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         if(nextStrength &lt;= level) {</span>
<span class="lineNum">     919 </span>            :             // Insert before a stronger node.
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :             if(nextStrength &lt; level) { break; }</span>
<span class="lineNum">     921 </span>            :             // nextStrength == level
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :             if(!isTailoredNode(node)) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                 uint32_t nextWeight16 = weight16FromNode(node);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                 if(nextWeight16 == weight16) {</span>
<span class="lineNum">     925 </span>            :                     // Found the node for the root CE up to this level.
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                     return nextIndex;</span>
<span class="lineNum">     927 </span>            :                 }
<span class="lineNum">     928 </span>            :                 // Insert before a node with a larger same-strength weight.
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                 if(nextWeight16 &gt; weight16) { break; }</span>
<span class="lineNum">     930 </span>            :             }
<span class="lineNum">     931 </span>            :         }
<span class="lineNum">     932 </span>            :         // Skip the next node.
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         index = nextIndex;</span>
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     node = nodeFromWeight16(weight16) | nodeFromStrength(level);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     return insertNodeBetween(index, nextIndex, node, errorCode);</span>
<span class="lineNum">     937 </span>            : }
<a name="938"><span class="lineNum">     938 </span>            : </a>
<span class="lineNum">     939 </span>            : int32_t
<span class="lineNum">     940 </span><span class="lineNoCov">          0 : CollationBuilder::insertTailoredNodeAfter(int32_t index, int32_t strength, UErrorCode &amp;errorCode) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     U_ASSERT(0 &lt;= index &amp;&amp; index &lt; nodes.size());</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     if(strength &gt;= UCOL_SECONDARY) {</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         index = findCommonNode(index, UCOL_SECONDARY);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         if(strength &gt;= UCOL_TERTIARY) {</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :             index = findCommonNode(index, UCOL_TERTIARY);</span>
<span class="lineNum">     947 </span>            :         }
<span class="lineNum">     948 </span>            :     }
<span class="lineNum">     949 </span>            :     // Postpone insertion:
<span class="lineNum">     950 </span>            :     // Insert the new node before the next one with a strength at least as strong.
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     952 </span>            :     int32_t nextIndex;
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     while((nextIndex = nextIndexFromNode(node)) != 0) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(nextIndex);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         if(strengthFromNode(node) &lt;= strength) { break; }</span>
<span class="lineNum">     956 </span>            :         // Skip the next node which has a weaker (larger) strength than the new one.
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         index = nextIndex;</span>
<span class="lineNum">     958 </span>            :     }
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     node = IS_TAILORED | nodeFromStrength(strength);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     return insertNodeBetween(index, nextIndex, node, errorCode);</span>
<span class="lineNum">     961 </span>            : }
<a name="962"><span class="lineNum">     962 </span>            : </a>
<span class="lineNum">     963 </span>            : int32_t
<span class="lineNum">     964 </span><span class="lineNoCov">          0 : CollationBuilder::insertNodeBetween(int32_t index, int32_t nextIndex, int64_t node,</span>
<span class="lineNum">     965 </span>            :                                     UErrorCode &amp;errorCode) {
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     U_ASSERT(previousIndexFromNode(node) == 0);</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     U_ASSERT(nextIndexFromNode(node) == 0);</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     U_ASSERT(nextIndexFromNode(nodes.elementAti(index)) == nextIndex);</span>
<span class="lineNum">     970 </span>            :     // Append the new node and link it to the existing nodes.
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     int32_t newIndex = nodes.size();</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     node |= nodeFromPreviousIndex(index) | nodeFromNextIndex(nextIndex);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     nodes.addElement(node, errorCode);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return 0; }</span>
<span class="lineNum">     975 </span>            :     // nodes[index].nextIndex = newIndex
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     node = nodes.elementAti(index);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     nodes.setElementAt(changeNodeNextIndex(node, newIndex), index);</span>
<span class="lineNum">     978 </span>            :     // nodes[nextIndex].previousIndex = newIndex
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     if(nextIndex != 0) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(nextIndex);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         nodes.setElementAt(changeNodePreviousIndex(node, newIndex), nextIndex);</span>
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     return newIndex;</span>
<span class="lineNum">     984 </span>            : }
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : int32_t
<span class="lineNum">     987 </span><span class="lineNoCov">          0 : CollationBuilder::findCommonNode(int32_t index, int32_t strength) const {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     U_ASSERT(UCOL_SECONDARY &lt;= strength &amp;&amp; strength &lt;= UCOL_TERTIARY);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     int64_t node = nodes.elementAti(index);</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     if(strengthFromNode(node) &gt;= strength) {</span>
<span class="lineNum">     991 </span>            :         // The current node is no stronger.
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         return index;</span>
<span class="lineNum">     993 </span>            :     }
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     if(strength == UCOL_SECONDARY ? !nodeHasBefore2(node) : !nodeHasBefore3(node)) {</span>
<span class="lineNum">     995 </span>            :         // The current node implies the strength-common weight.
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         return index;</span>
<span class="lineNum">     997 </span>            :     }
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     index = nextIndexFromNode(node);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     node = nodes.elementAti(index);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     U_ASSERT(!isTailoredNode(node) &amp;&amp; strengthFromNode(node) == strength &amp;&amp;</span>
<span class="lineNum">    1001 </span>            :             weight16FromNode(node) &lt; Collation::COMMON_WEIGHT16);
<span class="lineNum">    1002 </span>            :     // Skip to the explicit common node.
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         index = nextIndexFromNode(node);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         node = nodes.elementAti(index);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         U_ASSERT(strengthFromNode(node) &gt;= strength);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     } while(isTailoredNode(node) || strengthFromNode(node) &gt; strength ||</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :             weight16FromNode(node) &lt; Collation::COMMON_WEIGHT16);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     U_ASSERT(weight16FromNode(node) == Collation::COMMON_WEIGHT16);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     return index;</span>
<span class="lineNum">    1011 </span>            : }
<a name="1012"><span class="lineNum">    1012 </span>            : </a>
<span class="lineNum">    1013 </span>            : void
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 : CollationBuilder::setCaseBits(const UnicodeString &amp;nfdString,</span>
<span class="lineNum">    1015 </span>            :                               const char *&amp;parserErrorReason, UErrorCode &amp;errorCode) {
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :     int32_t numTailoredPrimaries = 0;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     for(int32_t i = 0; i &lt; cesLength; ++i) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         if(ceStrength(ces[i]) == UCOL_PRIMARY) { ++numTailoredPrimaries; }</span>
<span class="lineNum">    1020 </span>            :     }
<span class="lineNum">    1021 </span>            :     // We should not be able to get too many case bits because
<span class="lineNum">    1022 </span>            :     // cesLength&lt;=31==MAX_EXPANSION_LENGTH.
<span class="lineNum">    1023 </span>            :     // 31 pairs of case bits fit into an int64_t without setting its sign bit.
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     U_ASSERT(numTailoredPrimaries &lt;= 31);</span>
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :     int64_t cases = 0;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     if(numTailoredPrimaries &gt; 0) {</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         const UChar *s = nfdString.getBuffer();</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         UTF16CollationIterator baseCEs(baseData, FALSE, s, s, s + nfdString.length());</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         int32_t baseCEsLength = baseCEs.fetchCEs(errorCode) - 1;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :             parserErrorReason = &quot;fetching root CEs for tailored string&quot;;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1034 </span>            :         }
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         U_ASSERT(baseCEsLength &gt;= 0 &amp;&amp; baseCEs.getCE(baseCEsLength) == Collation::NO_CE);</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :         uint32_t lastCase = 0;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         int32_t numBasePrimaries = 0;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         for(int32_t i = 0; i &lt; baseCEsLength; ++i) {</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :             int64_t ce = baseCEs.getCE(i);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :             if((ce &gt;&gt; 32) != 0) {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                 ++numBasePrimaries;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                 uint32_t c = ((uint32_t)ce &gt;&gt; 14) &amp; 3;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                 U_ASSERT(c == 0 || c == 2);  // lowercase or uppercase, no mixed case in any base CE</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                 if(numBasePrimaries &lt; numTailoredPrimaries) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                     cases |= (int64_t)c &lt;&lt; ((numBasePrimaries - 1) * 2);</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                 } else if(numBasePrimaries == numTailoredPrimaries) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                     lastCase = c;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                 } else if(c != lastCase) {</span>
<span class="lineNum">    1050 </span>            :                     // There are more base primary CEs than tailored primaries.
<span class="lineNum">    1051 </span>            :                     // Set mixed case if the case bits of the remainder differ.
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :                     lastCase = 1;</span>
<span class="lineNum">    1053 </span>            :                     // Nothing more can change.
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1055 </span>            :                 }
<span class="lineNum">    1056 </span>            :             }
<span class="lineNum">    1057 </span>            :         }
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         if(numBasePrimaries &gt;= numTailoredPrimaries) {</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :             cases |= (int64_t)lastCase &lt;&lt; ((numTailoredPrimaries - 1) * 2);</span>
<span class="lineNum">    1060 </span>            :         }
<span class="lineNum">    1061 </span>            :     }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     for(int32_t i = 0; i &lt; cesLength; ++i) {</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         int64_t ce = ces[i] &amp; INT64_C(0xffffffffffff3fff);  // clear old case bits</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         int32_t strength = ceStrength(ce);</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         if(strength == UCOL_PRIMARY) {</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :             ce |= (cases &amp; 3) &lt;&lt; 14;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             cases &gt;&gt;= 2;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         } else if(strength == UCOL_TERTIARY) {</span>
<span class="lineNum">    1070 </span>            :             // Tertiary CEs must have uppercase bits.
<span class="lineNum">    1071 </span>            :             // See the LDML spec, and comments in class CollationCompare.
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :             ce |= 0x8000;</span>
<span class="lineNum">    1073 </span>            :         }
<span class="lineNum">    1074 </span>            :         // Tertiary ignorable CEs must have 0 case bits.
<span class="lineNum">    1075 </span>            :         // We set 0 case bits for secondary CEs too
<span class="lineNum">    1076 </span>            :         // since currently only U+0345 is cased and maps to a secondary CE,
<span class="lineNum">    1077 </span>            :         // and it is lowercase. Other secondaries are uncased.
<span class="lineNum">    1078 </span>            :         // See [[:Cased:]&amp;[:uca1=:]] where uca1 queries the root primary weight.
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :         ces[i] = ce;</span>
<span class="lineNum">    1080 </span>            :     }
<span class="lineNum">    1081 </span>            : }
<a name="1082"><span class="lineNum">    1082 </span>            : </a>
<span class="lineNum">    1083 </span>            : void
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : CollationBuilder::suppressContractions(const UnicodeSet &amp;set, const char *&amp;parserErrorReason,</span>
<span class="lineNum">    1085 </span>            :                                        UErrorCode &amp;errorCode) {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     dataBuilder-&gt;suppressContractions(set, errorCode);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         parserErrorReason = &quot;application of [suppressContractions [set]] failed&quot;;</span>
<span class="lineNum">    1090 </span>            :     }
<span class="lineNum">    1091 </span>            : }
<a name="1092"><span class="lineNum">    1092 </span>            : </a>
<span class="lineNum">    1093 </span>            : void
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 : CollationBuilder::optimize(const UnicodeSet &amp;set, const char *&amp; /* parserErrorReason */,</span>
<span class="lineNum">    1095 </span>            :                            UErrorCode &amp;errorCode) {
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     optimizeSet.addAll(set);</span>
<span class="lineNum">    1098 </span>            : }
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<span class="lineNum">    1100 </span>            : uint32_t
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 : CollationBuilder::addWithClosure(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,</span>
<span class="lineNum">    1102 </span>            :                                  const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">    1103 </span>            :                                  UErrorCode &amp;errorCode) {
<span class="lineNum">    1104 </span>            :     // Map from the NFD input to the CEs.
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     ce32 = addIfDifferent(nfdPrefix, nfdString, newCEs, newCEsLength, ce32, errorCode);</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     ce32 = addOnlyClosure(nfdPrefix, nfdString, newCEs, newCEsLength, ce32, errorCode);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     addTailComposites(nfdPrefix, nfdString, errorCode);</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     return ce32;</span>
<span class="lineNum">    1109 </span>            : }
<a name="1110"><span class="lineNum">    1110 </span>            : </a>
<span class="lineNum">    1111 </span>            : uint32_t
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 : CollationBuilder::addOnlyClosure(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,</span>
<span class="lineNum">    1113 </span>            :                                  const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">    1114 </span>            :                                  UErrorCode &amp;errorCode) {
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :     // Map from canonically equivalent input to the CEs. (But not from the all-NFD input.)
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     if(nfdPrefix.isEmpty()) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :         CanonicalIterator stringIter(nfdString, errorCode);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         UnicodeString prefix;</span>
<span class="lineNum">    1122 </span>            :         for(;;) {
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :             UnicodeString str = stringIter.next();</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :             if(str.isBogus()) { break; }</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :             if(ignoreString(str, errorCode) || str == nfdString) { continue; }</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :             ce32 = addIfDifferent(prefix, str, newCEs, newCEsLength, ce32, errorCode);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :             if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1129 </span>            :     } else {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         CanonicalIterator prefixIter(nfdPrefix, errorCode);</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :         CanonicalIterator stringIter(nfdString, errorCode);</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1133 </span>            :         for(;;) {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             UnicodeString prefix = prefixIter.next();</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             if(prefix.isBogus()) { break; }</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             if(ignorePrefix(prefix, errorCode)) { continue; }</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :             UBool samePrefix = prefix == nfdPrefix;</span>
<span class="lineNum">    1138 </span>            :             for(;;) {
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :                 UnicodeString str = stringIter.next();</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                 if(str.isBogus()) { break; }</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                 if(ignoreString(str, errorCode) || (samePrefix &amp;&amp; str == nfdString)) { continue; }</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 ce32 = addIfDifferent(prefix, str, newCEs, newCEsLength, ce32, errorCode);</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :             stringIter.reset();</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1147 </span>            :     }
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     return ce32;</span>
<span class="lineNum">    1149 </span>            : }
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<span class="lineNum">    1151 </span>            : void
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 : CollationBuilder::addTailComposites(const UnicodeString &amp;nfdPrefix, const UnicodeString &amp;nfdString,</span>
<span class="lineNum">    1153 </span>            :                                     UErrorCode &amp;errorCode) {
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            :     // Look for the last starter in the NFD string.
<span class="lineNum">    1157 </span>            :     UChar32 lastStarter;
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     int32_t indexAfterLastStarter = nfdString.length();</span>
<span class="lineNum">    1159 </span>            :     for(;;) {
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         if(indexAfterLastStarter == 0) { return; }  // no starter at all</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :         lastStarter = nfdString.char32At(indexAfterLastStarter - 1);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         if(nfd.getCombiningClass(lastStarter) == 0) { break; }</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         indexAfterLastStarter -= U16_LENGTH(lastStarter);</span>
<span class="lineNum">    1164 </span>            :     }
<span class="lineNum">    1165 </span>            :     // No closure to Hangul syllables since we decompose them on the fly.
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     if(Hangul::isJamoL(lastStarter)) { return; }</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span>            :     // Are there any composites whose decomposition starts with the lastStarter?
<span class="lineNum">    1169 </span>            :     // Note: Normalizer2Impl does not currently return start sets for NFC_QC=Maybe characters.
<span class="lineNum">    1170 </span>            :     // We might find some more equivalent mappings here if it did.
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     UnicodeSet composites;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     if(!nfcImpl.getCanonStartSet(lastStarter, composites)) { return; }</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     UnicodeString decomp;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     UnicodeString newNFDString, newString;</span>
<span class="lineNum">    1176 </span>            :     int64_t newCEs[Collation::MAX_EXPANSION_LENGTH];
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     UnicodeSetIterator iter(composites);</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     while(iter.next()) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         U_ASSERT(!iter.isString());</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :         UChar32 composite = iter.getCodepoint();</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :         nfd.getDecomposition(composite, decomp);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         if(!mergeCompositeIntoString(nfdString, indexAfterLastStarter, composite, decomp,</span>
<span class="lineNum">    1183 </span>            :                                      newNFDString, newString, errorCode)) {
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1185 </span>            :         }
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         int32_t newCEsLength = dataBuilder-&gt;getCEs(nfdPrefix, newNFDString, newCEs, 0);</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         if(newCEsLength &gt; Collation::MAX_EXPANSION_LENGTH) {</span>
<span class="lineNum">    1188 </span>            :             // Ignore mappings that we cannot store.
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1190 </span>            :         }
<span class="lineNum">    1191 </span>            :         // Note: It is possible that the newCEs do not make use of the mapping
<span class="lineNum">    1192 </span>            :         // for which we are adding the tail composites, in which case we might be adding
<span class="lineNum">    1193 </span>            :         // unnecessary mappings.
<span class="lineNum">    1194 </span>            :         // For example, when we add tail composites for ae^ (^=combining circumflex),
<span class="lineNum">    1195 </span>            :         // UCA discontiguous-contraction matching does not find any matches
<span class="lineNum">    1196 </span>            :         // for ae_^ (_=any combining diacritic below) *unless* there is also
<span class="lineNum">    1197 </span>            :         // a contraction mapping for ae.
<span class="lineNum">    1198 </span>            :         // Thus, if there is no ae contraction, then the ae^ mapping is ignored
<span class="lineNum">    1199 </span>            :         // while fetching the newCEs for ae_^.
<span class="lineNum">    1200 </span>            :         // TODO: Try to detect this effectively.
<span class="lineNum">    1201 </span>            :         // (Alternatively, print a warning when prefix contractions are missing.)
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :         // We do not need an explicit mapping for the NFD strings.
<span class="lineNum">    1204 </span>            :         // It is fine if the NFD input collates like this via a sequence of mappings.
<span class="lineNum">    1205 </span>            :         // It also saves a little bit of space, and may reduce the set of characters with contractions.
<span class="lineNum">    1206 </span>            :         uint32_t ce32 = addIfDifferent(nfdPrefix, newString,
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                                        newCEs, newCEsLength, Collation::UNASSIGNED_CE32, errorCode);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :         if(ce32 != Collation::UNASSIGNED_CE32) {</span>
<span class="lineNum">    1209 </span>            :             // was different, was added
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :             addOnlyClosure(nfdPrefix, newNFDString, newCEs, newCEsLength, ce32, errorCode);</span>
<span class="lineNum">    1211 </span>            :         }
<span class="lineNum">    1212 </span>            :     }
<span class="lineNum">    1213 </span>            : }
<a name="1214"><span class="lineNum">    1214 </span>            : </a>
<span class="lineNum">    1215 </span>            : UBool
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 : CollationBuilder::mergeCompositeIntoString(const UnicodeString &amp;nfdString,</span>
<span class="lineNum">    1217 </span>            :                                            int32_t indexAfterLastStarter,
<span class="lineNum">    1218 </span>            :                                            UChar32 composite, const UnicodeString &amp;decomp,
<span class="lineNum">    1219 </span>            :                                            UnicodeString &amp;newNFDString, UnicodeString &amp;newString,
<span class="lineNum">    1220 </span>            :                                            UErrorCode &amp;errorCode) const {
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return FALSE; }</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     U_ASSERT(nfdString.char32At(indexAfterLastStarter - 1) == decomp.char32At(0));</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     int32_t lastStarterLength = decomp.moveIndex32(0, 1);</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     if(lastStarterLength == decomp.length()) {</span>
<span class="lineNum">    1225 </span>            :         // Singleton decompositions should be found by addWithClosure()
<span class="lineNum">    1226 </span>            :         // and the CanonicalIterator, so we can ignore them here.
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     if(nfdString.compare(indexAfterLastStarter, 0x7fffffff,</span>
<span class="lineNum">    1230 </span>            :                          decomp, lastStarterLength, 0x7fffffff) == 0) {
<span class="lineNum">    1231 </span>            :         // same strings, nothing new to be found here
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :     // Make new FCD strings that combine a composite, or its decomposition,
<span class="lineNum">    1236 </span>            :     // into the nfdString's last starter and the combining marks following it.
<span class="lineNum">    1237 </span>            :     // Make an NFD version, and a version with the composite.
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     newNFDString.setTo(nfdString, 0, indexAfterLastStarter);</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     newString.setTo(nfdString, 0, indexAfterLastStarter - lastStarterLength).append(composite);</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :     // The following is related to discontiguous contraction matching,
<span class="lineNum">    1242 </span>            :     // but builds only FCD strings (or else returns FALSE).
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     int32_t sourceIndex = indexAfterLastStarter;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     int32_t decompIndex = lastStarterLength;</span>
<span class="lineNum">    1245 </span>            :     // Small optimization: We keep the source character across loop iterations
<span class="lineNum">    1246 </span>            :     // because we do not always consume it,
<span class="lineNum">    1247 </span>            :     // and then need not fetch it again nor look up its combining class again.
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :     UChar32 sourceChar = U_SENTINEL;</span>
<span class="lineNum">    1249 </span>            :     // The cc variables need to be declared before the loop so that at the end
<span class="lineNum">    1250 </span>            :     // they are set to the last combining classes seen.
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     uint8_t sourceCC = 0;</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     uint8_t decompCC = 0;</span>
<span class="lineNum">    1253 </span>            :     for(;;) {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         if(sourceChar &lt; 0) {</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :             if(sourceIndex &gt;= nfdString.length()) { break; }</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             sourceChar = nfdString.char32At(sourceIndex);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :             sourceCC = nfd.getCombiningClass(sourceChar);</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :             U_ASSERT(sourceCC != 0);</span>
<span class="lineNum">    1259 </span>            :         }
<span class="lineNum">    1260 </span>            :         // We consume a decomposition character in each iteration.
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :         if(decompIndex &gt;= decomp.length()) { break; }</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :         UChar32 decompChar = decomp.char32At(decompIndex);</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :         decompCC = nfd.getCombiningClass(decompChar);</span>
<span class="lineNum">    1264 </span>            :         // Compare the two characters and their combining classes.
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :         if(decompCC == 0) {</span>
<span class="lineNum">    1266 </span>            :             // Unable to merge because the source contains a non-zero combining mark
<span class="lineNum">    1267 </span>            :             // but the composite's decomposition contains another starter.
<span class="lineNum">    1268 </span>            :             // The strings would not be equivalent.
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :         } else if(sourceCC &lt; decompCC) {</span>
<span class="lineNum">    1271 </span>            :             // Composite + sourceChar would not be FCD.
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :         } else if(decompCC &lt; sourceCC) {</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :             newNFDString.append(decompChar);</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :             decompIndex += U16_LENGTH(decompChar);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         } else if(decompChar != sourceChar) {</span>
<span class="lineNum">    1277 </span>            :             // Blocked because same combining class.
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1279 </span>            :         } else {  // match: decompChar == sourceChar
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :             newNFDString.append(decompChar);</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :             decompIndex += U16_LENGTH(decompChar);</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :             sourceIndex += U16_LENGTH(decompChar);</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :             sourceChar = U_SENTINEL;</span>
<span class="lineNum">    1284 </span>            :         }
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1286 </span>            :     // We are at the end of at least one of the two inputs.
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :     if(sourceChar &gt;= 0) {  // more characters from nfdString but not from decomp</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :         if(sourceCC &lt; decompCC) {</span>
<span class="lineNum">    1289 </span>            :             // Appending the next source character to the composite would not be FCD.
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">    1291 </span>            :         }
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :         newNFDString.append(nfdString, sourceIndex, 0x7fffffff);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         newString.append(nfdString, sourceIndex, 0x7fffffff);</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :     } else if(decompIndex &lt; decomp.length()) {  // more characters from decomp, not from nfdString</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         newNFDString.append(decomp, decompIndex, 0x7fffffff);</span>
<span class="lineNum">    1296 </span>            :     }
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     U_ASSERT(nfd.isNormalized(newNFDString, errorCode));</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :     U_ASSERT(fcd.isNormalized(newString, errorCode));</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     U_ASSERT(nfd.normalize(newString, errorCode) == newNFDString);  // canonically equivalent</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1301 </span>            : }
<a name="1302"><span class="lineNum">    1302 </span>            : </a>
<span class="lineNum">    1303 </span>            : UBool
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 : CollationBuilder::ignorePrefix(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">    1305 </span>            :     // Do not map non-FCD prefixes.
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     return !isFCD(s, errorCode);</span>
<span class="lineNum">    1307 </span>            : }
<a name="1308"><span class="lineNum">    1308 </span>            : </a>
<span class="lineNum">    1309 </span>            : UBool
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 : CollationBuilder::ignoreString(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">    1311 </span>            :     // Do not map non-FCD strings.
<span class="lineNum">    1312 </span>            :     // Do not map strings that start with Hangul syllables: We decompose those on the fly.
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     return !isFCD(s, errorCode) || Hangul::isHangul(s.charAt(0));</span>
<span class="lineNum">    1314 </span>            : }
<a name="1315"><span class="lineNum">    1315 </span>            : </a>
<span class="lineNum">    1316 </span>            : UBool
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 : CollationBuilder::isFCD(const UnicodeString &amp;s, UErrorCode &amp;errorCode) const {</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :     return U_SUCCESS(errorCode) &amp;&amp; fcd.isNormalized(s, errorCode);</span>
<span class="lineNum">    1319 </span>            : }
<a name="1320"><span class="lineNum">    1320 </span>            : </a>
<span class="lineNum">    1321 </span>            : void
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 : CollationBuilder::closeOverComposites(UErrorCode &amp;errorCode) {</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     UnicodeSet composites(UNICODE_STRING_SIMPLE(&quot;[:NFD_QC=N:]&quot;), errorCode);  // Java: static final</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1325 </span>            :     // Hangul is decomposed on the fly during collation.
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     composites.remove(Hangul::HANGUL_BASE, Hangul::HANGUL_END);</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :     UnicodeString prefix;  // empty</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     UnicodeString nfdString;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :     UnicodeSetIterator iter(composites);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     while(iter.next()) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         U_ASSERT(!iter.isString());</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         nfd.getDecomposition(iter.getCodepoint(), nfdString);</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :         cesLength = dataBuilder-&gt;getCEs(nfdString, ces, 0);</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :         if(cesLength &gt; Collation::MAX_EXPANSION_LENGTH) {</span>
<span class="lineNum">    1335 </span>            :             // Too many CEs from the decomposition (unusual), ignore this composite.
<span class="lineNum">    1336 </span>            :             // We could add a capacity parameter to getCEs() and reallocate if necessary.
<span class="lineNum">    1337 </span>            :             // However, this can only really happen in contrived cases.
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1339 </span>            :         }
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         const UnicodeString &amp;composite(iter.getString());</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :         addIfDifferent(prefix, composite, ces, cesLength, Collation::UNASSIGNED_CE32, errorCode);</span>
<span class="lineNum">    1342 </span>            :     }
<span class="lineNum">    1343 </span>            : }
<a name="1344"><span class="lineNum">    1344 </span>            : </a>
<span class="lineNum">    1345 </span>            : uint32_t
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 : CollationBuilder::addIfDifferent(const UnicodeString &amp;prefix, const UnicodeString &amp;str,</span>
<span class="lineNum">    1347 </span>            :                                  const int64_t newCEs[], int32_t newCEsLength, uint32_t ce32,
<span class="lineNum">    1348 </span>            :                                  UErrorCode &amp;errorCode) {
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return ce32; }</span>
<span class="lineNum">    1350 </span>            :     int64_t oldCEs[Collation::MAX_EXPANSION_LENGTH];
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :     int32_t oldCEsLength = dataBuilder-&gt;getCEs(prefix, str, oldCEs, 0);</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :     if(!sameCEs(newCEs, newCEsLength, oldCEs, oldCEsLength)) {</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :         if(ce32 == Collation::UNASSIGNED_CE32) {</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :             ce32 = dataBuilder-&gt;encodeCEs(newCEs, newCEsLength, errorCode);</span>
<span class="lineNum">    1355 </span>            :         }
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :         dataBuilder-&gt;addCE32(prefix, str, ce32, errorCode);</span>
<span class="lineNum">    1357 </span>            :     }
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     return ce32;</span>
<span class="lineNum">    1359 </span>            : }
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<span class="lineNum">    1361 </span>            : UBool
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 : CollationBuilder::sameCEs(const int64_t ces1[], int32_t ces1Length,</span>
<span class="lineNum">    1363 </span>            :                           const int64_t ces2[], int32_t ces2Length) {
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :     if(ces1Length != ces2Length) {</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1366 </span>            :     }
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :     U_ASSERT(ces1Length &lt;= Collation::MAX_EXPANSION_LENGTH);</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     for(int32_t i = 0; i &lt; ces1Length; ++i) {</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         if(ces1[i] != ces2[i]) { return FALSE; }</span>
<span class="lineNum">    1370 </span>            :     }
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1372 </span>            : }
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : uint32_t
<span class="lineNum">    1377 </span>            : alignWeightRight(uint32_t w) {
<span class="lineNum">    1378 </span>            :     if(w != 0) {
<span class="lineNum">    1379 </span>            :         while((w &amp; 0xff) == 0) { w &gt;&gt;= 8; }
<span class="lineNum">    1380 </span>            :     }
<span class="lineNum">    1381 </span>            :     return w;
<span class="lineNum">    1382 </span>            : }
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : #endif
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<span class="lineNum">    1386 </span>            : void
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 : CollationBuilder::makeTailoredCEs(UErrorCode &amp;errorCode) {</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     CollationWeights primaries, secondaries, tertiaries;</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     int64_t *nodesArray = nodes.getBuffer();</span>
<span class="lineNum">    1392 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1393 </span>            :         puts(&quot;\nCollationBuilder::makeTailoredCEs()&quot;);
<span class="lineNum">    1394 </span>            : #endif
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     for(int32_t rpi = 0; rpi &lt; rootPrimaryIndexes.size(); ++rpi) {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         int32_t i = rootPrimaryIndexes.elementAti(rpi);</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         int64_t node = nodesArray[i];</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :         uint32_t p = weight32FromNode(node);</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         uint32_t s = p == 0 ? 0 : Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         uint32_t t = s;</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         uint32_t q = 0;</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :         UBool pIsTailored = FALSE;</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         UBool sIsTailored = FALSE;</span>
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :         UBool tIsTailored = FALSE;</span>
<span class="lineNum">    1406 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1407 </span>            :         printf(&quot;\nprimary     %lx\n&quot;, (long)alignWeightRight(p));
<span class="lineNum">    1408 </span>            : #endif
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :         int32_t pIndex = p == 0 ? 0 : rootElements.findPrimary(p);</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :         int32_t nextIndex = nextIndexFromNode(node);</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :         while(nextIndex != 0) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :             i = nextIndex;</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :             node = nodesArray[i];</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :             nextIndex = nextIndexFromNode(node);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :             int32_t strength = strengthFromNode(node);</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :             if(strength == UCOL_QUATERNARY) {</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                 U_ASSERT(isTailoredNode(node));</span>
<span class="lineNum">    1418 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1419 </span>            :                 printf(&quot;      quat+     &quot;);
<span class="lineNum">    1420 </span>            : #endif
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :                 if(q == 3) {</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                     errorCode = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                     errorReason = &quot;quaternary tailoring gap too small&quot;;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1425 </span>            :                 }
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :                 ++q;</span>
<span class="lineNum">    1427 </span>            :             } else {
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :                 if(strength == UCOL_TERTIARY) {</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :                     if(isTailoredNode(node)) {</span>
<span class="lineNum">    1430 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1431 </span>            :                         printf(&quot;    ter+        &quot;);
<span class="lineNum">    1432 </span>            : #endif
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :                         if(!tIsTailored) {</span>
<span class="lineNum">    1434 </span>            :                             // First tailored tertiary node for [p, s].
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                             int32_t tCount = countTailoredNodes(nodesArray, nextIndex,</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :                                                                 UCOL_TERTIARY) + 1;</span>
<span class="lineNum">    1437 </span>            :                             uint32_t tLimit;
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :                             if(t == 0) {</span>
<span class="lineNum">    1439 </span>            :                                 // Gap at the beginning of the tertiary CE range.
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                                 t = rootElements.getTertiaryBoundary() - 0x100;</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                                 tLimit = rootElements.getFirstTertiaryCE() &amp; Collation::ONLY_TERTIARY_MASK;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                             } else if(!pIsTailored &amp;&amp; !sIsTailored) {</span>
<span class="lineNum">    1443 </span>            :                                 // p and s are root weights.
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                                 tLimit = rootElements.getTertiaryAfter(pIndex, s, t);</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                             } else if(t == Collation::BEFORE_WEIGHT16) {</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                                 tLimit = Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">    1447 </span>            :                             } else {
<span class="lineNum">    1448 </span>            :                                 // [p, s] is tailored.
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                                 U_ASSERT(t == Collation::COMMON_WEIGHT16);</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                                 tLimit = rootElements.getTertiaryBoundary();</span>
<span class="lineNum">    1451 </span>            :                             }
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                             U_ASSERT(tLimit == 0x4000 || (tLimit &amp; ~Collation::ONLY_TERTIARY_MASK) == 0);</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                             tertiaries.initForTertiary();</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                             if(!tertiaries.allocWeights(t, tLimit, tCount)) {</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :                                 errorCode = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                                 errorReason = &quot;tertiary tailoring gap too small&quot;;</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1458 </span>            :                             }
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                             tIsTailored = TRUE;</span>
<span class="lineNum">    1460 </span>            :                         }
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :                         t = tertiaries.nextWeight();</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                         U_ASSERT(t != 0xffffffff);</span>
<span class="lineNum">    1463 </span>            :                     } else {
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :                         t = weight16FromNode(node);</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                         tIsTailored = FALSE;</span>
<span class="lineNum">    1466 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1467 </span>            :                         printf(&quot;    ter     %lx\n&quot;, (long)alignWeightRight(t));
<span class="lineNum">    1468 </span>            : #endif
<span class="lineNum">    1469 </span>            :                     }
<span class="lineNum">    1470 </span>            :                 } else {
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                     if(strength == UCOL_SECONDARY) {</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :                         if(isTailoredNode(node)) {</span>
<span class="lineNum">    1473 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1474 </span>            :                             printf(&quot;  sec+          &quot;);
<span class="lineNum">    1475 </span>            : #endif
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :                             if(!sIsTailored) {</span>
<span class="lineNum">    1477 </span>            :                                 // First tailored secondary node for p.
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :                                 int32_t sCount = countTailoredNodes(nodesArray, nextIndex,</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :                                                                     UCOL_SECONDARY) + 1;</span>
<span class="lineNum">    1480 </span>            :                                 uint32_t sLimit;
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :                                 if(s == 0) {</span>
<span class="lineNum">    1482 </span>            :                                     // Gap at the beginning of the secondary CE range.
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :                                     s = rootElements.getSecondaryBoundary() - 0x100;</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                                     sLimit = rootElements.getFirstSecondaryCE() &gt;&gt; 16;</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :                                 } else if(!pIsTailored) {</span>
<span class="lineNum">    1486 </span>            :                                     // p is a root primary.
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :                                     sLimit = rootElements.getSecondaryAfter(pIndex, s);</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :                                 } else if(s == Collation::BEFORE_WEIGHT16) {</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :                                     sLimit = Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">    1490 </span>            :                                 } else {
<span class="lineNum">    1491 </span>            :                                     // p is a tailored primary.
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                                     U_ASSERT(s == Collation::COMMON_WEIGHT16);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :                                     sLimit = rootElements.getSecondaryBoundary();</span>
<span class="lineNum">    1494 </span>            :                                 }
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :                                 if(s == Collation::COMMON_WEIGHT16) {</span>
<span class="lineNum">    1496 </span>            :                                     // Do not tailor into the getSortKey() range of
<span class="lineNum">    1497 </span>            :                                     // compressed common secondaries.
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :                                     s = rootElements.getLastCommonSecondary();</span>
<span class="lineNum">    1499 </span>            :                                 }
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :                                 secondaries.initForSecondary();</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :                                 if(!secondaries.allocWeights(s, sLimit, sCount)) {</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :                                     errorCode = U_BUFFER_OVERFLOW_ERROR;</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :                                     errorReason = &quot;secondary tailoring gap too small&quot;;</span>
<span class="lineNum">    1504 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1505 </span>            :                                     printf(&quot;!secondaries.allocWeights(%lx, %lx, sCount=%ld)\n&quot;,
<span class="lineNum">    1506 </span>            :                                            (long)alignWeightRight(s), (long)alignWeightRight(sLimit),
<span class="lineNum">    1507 </span>            :                                            (long)alignWeightRight(sCount));
<span class="lineNum">    1508 </span>            : #endif
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :                                     return;</span>
<span class="lineNum">    1510 </span>            :                                 }
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                                 sIsTailored = TRUE;</span>
<span class="lineNum">    1512 </span>            :                             }
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :                             s = secondaries.nextWeight();</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :                             U_ASSERT(s != 0xffffffff);</span>
<span class="lineNum">    1515 </span>            :                         } else {
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :                             s = weight16FromNode(node);</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :                             sIsTailored = FALSE;</span>
<span class="lineNum">    1518 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1519 </span>            :                             printf(&quot;  sec       %lx\n&quot;, (long)alignWeightRight(s));
<span class="lineNum">    1520 </span>            : #endif
<span class="lineNum">    1521 </span>            :                         }
<span class="lineNum">    1522 </span>            :                     } else /* UCOL_PRIMARY */ {
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :                         U_ASSERT(isTailoredNode(node));</span>
<span class="lineNum">    1524 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1525 </span>            :                         printf(&quot;pri+            &quot;);
<span class="lineNum">    1526 </span>            : #endif
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :                         if(!pIsTailored) {</span>
<span class="lineNum">    1528 </span>            :                             // First tailored primary node in this list.
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :                             int32_t pCount = countTailoredNodes(nodesArray, nextIndex,</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :                                                                 UCOL_PRIMARY) + 1;</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :                             UBool isCompressible = baseData-&gt;isCompressiblePrimary(p);</span>
<span class="lineNum">    1532 </span>            :                             uint32_t pLimit =
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :                                 rootElements.getPrimaryAfter(p, pIndex, isCompressible);</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                             primaries.initForPrimary(isCompressible);</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :                             if(!primaries.allocWeights(p, pLimit, pCount)) {</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :                                 errorCode = U_BUFFER_OVERFLOW_ERROR;  // TODO: introduce a more specific UErrorCode?</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :                                 errorReason = &quot;primary tailoring gap too small&quot;;</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1539 </span>            :                             }
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :                             pIsTailored = TRUE;</span>
<span class="lineNum">    1541 </span>            :                         }
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :                         p = primaries.nextWeight();</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                         U_ASSERT(p != 0xffffffff);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :                         s = Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :                         sIsTailored = FALSE;</span>
<span class="lineNum">    1546 </span>            :                     }
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :                     t = s == 0 ? 0 : Collation::COMMON_WEIGHT16;</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :                     tIsTailored = FALSE;</span>
<span class="lineNum">    1549 </span>            :                 }
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :                 q = 0;</span>
<span class="lineNum">    1551 </span>            :             }
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :             if(isTailoredNode(node)) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :                 nodesArray[i] = Collation::makeCE(p, s, t, q);</span>
<span class="lineNum">    1554 </span>            : #ifdef DEBUG_COLLATION_BUILDER
<span class="lineNum">    1555 </span>            :                 printf(&quot;%016llx\n&quot;, (long long)nodesArray[i]);
<span class="lineNum">    1556 </span>            : #endif
<span class="lineNum">    1557 </span>            :             }
<span class="lineNum">    1558 </span>            :         }
<span class="lineNum">    1559 </span>            :     }
<span class="lineNum">    1560 </span>            : }
<a name="1561"><span class="lineNum">    1561 </span>            : </a>
<span class="lineNum">    1562 </span>            : int32_t
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 : CollationBuilder::countTailoredNodes(const int64_t *nodesArray, int32_t i, int32_t strength) {</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     int32_t count = 0;</span>
<span class="lineNum">    1565 </span>            :     for(;;) {
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :         if(i == 0) { break; }</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :         int64_t node = nodesArray[i];</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :         if(strengthFromNode(node) &lt; strength) { break; }</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :         if(strengthFromNode(node) == strength) {</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :             if(isTailoredNode(node)) {</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :                 ++count;</span>
<span class="lineNum">    1572 </span>            :             } else {
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1574 </span>            :             }
<span class="lineNum">    1575 </span>            :         }
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :         i = nextIndexFromNode(node);</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :     return count;</span>
<span class="lineNum">    1579 </span>            : }
<span class="lineNum">    1580 </span>            : 
<a name="1581"><span class="lineNum">    1581 </span>            : class CEFinalizer : public CollationDataBuilder::CEModifier {</a>
<span class="lineNum">    1582 </span>            : public:
<a name="1583"><span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     CEFinalizer(const int64_t *ces) : finalCEs(ces) {}</span></a>
<span class="lineNum">    1584 </span>            :     virtual ~CEFinalizer();
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     virtual int64_t modifyCE32(uint32_t ce32) const {</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :         U_ASSERT(!Collation::isSpecialCE32(ce32));</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :         if(CollationBuilder::isTempCE32(ce32)) {</span>
<span class="lineNum">    1588 </span>            :             // retain case bits
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :             return finalCEs[CollationBuilder::indexFromTempCE32(ce32)] | ((ce32 &amp; 0xc0) &lt;&lt; 8);</span>
<span class="lineNum">    1590 </span>            :         } else {
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :             return Collation::NO_CE;</span>
<a name="1592"><span class="lineNum">    1592 </span>            :         }</a>
<span class="lineNum">    1593 </span>            :     }
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :     virtual int64_t modifyCE(int64_t ce) const {</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :         if(CollationBuilder::isTempCE(ce)) {</span>
<span class="lineNum">    1596 </span>            :             // retain case bits
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :             return finalCEs[CollationBuilder::indexFromTempCE(ce)] | (ce &amp; 0xc000);</span>
<span class="lineNum">    1598 </span>            :         } else {
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :             return Collation::NO_CE;</span>
<span class="lineNum">    1600 </span>            :         }
<span class="lineNum">    1601 </span>            :     }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            : private:
<span class="lineNum">    1604 </span>            :     const int64_t *finalCEs;
<a name="1605"><span class="lineNum">    1605 </span>            : };</a>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 : CEFinalizer::~CEFinalizer() {}</span>
<a name="1608"><span class="lineNum">    1608 </span>            : </a>
<span class="lineNum">    1609 </span>            : void
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 : CollationBuilder::finalizeCEs(UErrorCode &amp;errorCode) {</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     LocalPointer&lt;CollationDataBuilder&gt; newBuilder(new CollationDataBuilder(errorCode), errorCode);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) {</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1615 </span>            :     }
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     newBuilder-&gt;initForTailoring(baseData, errorCode);</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     CEFinalizer finalizer(nodes.getBuffer());</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     newBuilder-&gt;copyFrom(*dataBuilder, finalizer, errorCode);</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :     if(U_FAILURE(errorCode)) { return; }</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     delete dataBuilder;</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :     dataBuilder = newBuilder.orphan();</span>
<span class="lineNum">    1622 </span>            : }
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<span class="lineNum">    1624 </span>            : int32_t
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 : CollationBuilder::ceStrength(int64_t ce) {</span>
<span class="lineNum">    1626 </span>            :     return
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :         isTempCE(ce) ? strengthFromTempCE(ce) :</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :         (ce &amp; INT64_C(0xff00000000000000)) != 0 ? UCOL_PRIMARY :</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :         ((uint32_t)ce &amp; 0xff000000) != 0 ? UCOL_SECONDARY :</span>
<span class="lineNum">    1630 </span>            :         ce != 0 ? UCOL_TERTIARY :
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :         UCOL_IDENTICAL;</span>
<span class="lineNum">    1632 </span>            : }
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            : U_NAMESPACE_END
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            : U_NAMESPACE_USE
<a name="1637"><span class="lineNum">    1637 </span>            : </a>
<span class="lineNum">    1638 </span>            : U_CAPI UCollator * U_EXPORT2
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 : ucol_openRules(const UChar *rules, int32_t rulesLength,</span>
<span class="lineNum">    1640 </span>            :                UColAttributeValue normalizationMode, UCollationStrength strength,
<span class="lineNum">    1641 </span>            :                UParseError *parseError, UErrorCode *pErrorCode) {
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     if(U_FAILURE(*pErrorCode)) { return NULL; }</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :     if(rules == NULL &amp;&amp; rulesLength != 0) {</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1646 </span>            :     }
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     RuleBasedCollator *coll = new RuleBasedCollator();</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     if(coll == NULL) {</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         *pErrorCode = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1651 </span>            :     }
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :     UnicodeString r((UBool)(rulesLength &lt; 0), rules, rulesLength);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :     coll-&gt;internalBuildTailoring(r, strength, normalizationMode, parseError, NULL, *pErrorCode);</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :     if(U_FAILURE(*pErrorCode)) {</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :         delete coll;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     return coll-&gt;toUCollator();</span>
<span class="lineNum">    1659 </span>            : }
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : static const int32_t internalBufferSize = 512;
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span>            : // The @internal ucol_getUnsafeSet() was moved here from ucol_sit.cpp
<span class="lineNum">    1664 </span>            : // because it calls UnicodeSet &quot;builder&quot; code that depends on all Unicode properties,
<span class="lineNum">    1665 </span>            : // and the rest of the collation &quot;runtime&quot; code only depends on normalization.
<span class="lineNum">    1666 </span>            : // This function is not related to the collation builder,
<span class="lineNum">    1667 </span>            : // but it did not seem worth moving it into its own .cpp file,
<a name="1668"><span class="lineNum">    1668 </span>            : // nor rewriting it to use lower-level UnicodeSet and Normalizer2Impl methods.</a>
<span class="lineNum">    1669 </span>            : U_CAPI int32_t U_EXPORT2
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 : ucol_getUnsafeSet( const UCollator *coll,</span>
<span class="lineNum">    1671 </span>            :                   USet *unsafe,
<span class="lineNum">    1672 </span>            :                   UErrorCode *status)
<span class="lineNum">    1673 </span>            : {
<span class="lineNum">    1674 </span>            :     UChar buffer[internalBufferSize];
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :     int32_t len = 0;</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     uset_clear(unsafe);</span>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            :     // cccpattern = &quot;[[:^tccc=0:][:^lccc=0:]]&quot;, unfortunately variant
<span class="lineNum">    1680 </span>            :     static const UChar cccpattern[25] = { 0x5b, 0x5b, 0x3a, 0x5e, 0x74, 0x63, 0x63, 0x63, 0x3d, 0x30, 0x3a, 0x5d,
<span class="lineNum">    1681 </span>            :                                     0x5b, 0x3a, 0x5e, 0x6c, 0x63, 0x63, 0x63, 0x3d, 0x30, 0x3a, 0x5d, 0x5d, 0x00 };
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            :     // add chars that fail the fcd check
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :     uset_applyPattern(unsafe, cccpattern, 24, USET_IGNORE_SPACE, status);</span>
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span>            :     // add lead/trail surrogates
<span class="lineNum">    1687 </span>            :     // (trail surrogates should need to be unsafe only if the caller tests for UTF-16 code *units*,
<span class="lineNum">    1688 </span>            :     // not when testing code *points*)
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :     uset_addRange(unsafe, 0xd800, 0xdfff);</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :     USet *contractions = uset_open(0,0);</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     int32_t i = 0, j = 0;</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     ucol_getContractionsAndExpansions(coll, contractions, NULL, FALSE, status);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     int32_t contsSize = uset_size(contractions);</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :     UChar32 c = 0;</span>
<span class="lineNum">    1697 </span>            :     // Contraction set consists only of strings
<span class="lineNum">    1698 </span>            :     // to get unsafe code points, we need to
<span class="lineNum">    1699 </span>            :     // break the strings apart and add them to the unsafe set
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     for(i = 0; i &lt; contsSize; i++) {</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         len = uset_getItem(contractions, i, NULL, NULL, buffer, internalBufferSize, status);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :         if(len &gt; 0) {</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :             j = 0;</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :             while(j &lt; len) {</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :                 U16_NEXT(buffer, j, len, c);</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :                 if(j &lt; len) {</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :                     uset_add(unsafe, c);</span>
<span class="lineNum">    1708 </span>            :                 }
<span class="lineNum">    1709 </span>            :             }
<span class="lineNum">    1710 </span>            :         }
<span class="lineNum">    1711 </span>            :     }
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :     uset_close(contractions);</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :     return uset_size(unsafe);</span>
<span class="lineNum">    1716 </span>            : }
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            : #endif  // !UCONFIG_NO_COLLATION
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

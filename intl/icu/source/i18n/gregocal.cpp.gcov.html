<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/i18n/gregocal.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/i18n</a> - gregocal.cpp<span style="font-size: 80%;"> (source / <a href="gregocal.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">403</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">53</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            : *******************************************************************************
<span class="lineNum">       5 </span>            : * Copyright (C) 1997-2016, International Business Machines Corporation and
<span class="lineNum">       6 </span>            : * others. All Rights Reserved.
<span class="lineNum">       7 </span>            : *******************************************************************************
<span class="lineNum">       8 </span>            : *
<span class="lineNum">       9 </span>            : * File GREGOCAL.CPP
<span class="lineNum">      10 </span>            : *
<span class="lineNum">      11 </span>            : * Modification History:
<span class="lineNum">      12 </span>            : *
<span class="lineNum">      13 </span>            : *   Date        Name        Description
<span class="lineNum">      14 </span>            : *   02/05/97    clhuang     Creation.
<span class="lineNum">      15 </span>            : *   03/28/97    aliu        Made highly questionable fix to computeFields to
<span class="lineNum">      16 </span>            : *                           handle DST correctly.
<span class="lineNum">      17 </span>            : *   04/22/97    aliu        Cleaned up code drastically.  Added monthLength().
<span class="lineNum">      18 </span>            : *                           Finished unimplemented parts of computeTime() for
<span class="lineNum">      19 </span>            : *                           week-based date determination.  Removed quetionable
<span class="lineNum">      20 </span>            : *                           fix and wrote correct fix for computeFields() and
<span class="lineNum">      21 </span>            : *                           daylight time handling.  Rewrote inDaylightTime()
<span class="lineNum">      22 </span>            : *                           and computeFields() to handle sensitive Daylight to
<span class="lineNum">      23 </span>            : *                           Standard time transitions correctly.
<span class="lineNum">      24 </span>            : *   05/08/97    aliu        Added code review changes.  Fixed isLeapYear() to
<span class="lineNum">      25 </span>            : *                           not cutover.
<span class="lineNum">      26 </span>            : *   08/12/97    aliu        Added equivalentTo.  Misc other fixes.  Updated
<span class="lineNum">      27 </span>            : *                           add() from Java source.
<span class="lineNum">      28 </span>            : *    07/28/98    stephen        Sync up with JDK 1.2
<span class="lineNum">      29 </span>            : *    09/14/98    stephen        Changed type of kOneDay, kOneWeek to double.
<span class="lineNum">      30 </span>            : *                            Fixed bug in roll() 
<span class="lineNum">      31 </span>            : *   10/15/99    aliu        Fixed j31, incorrect WEEK_OF_YEAR computation.
<span class="lineNum">      32 </span>            : *   10/15/99    aliu        Fixed j32, cannot set date to Feb 29 2000 AD.
<span class="lineNum">      33 </span>            : *                           {JDK bug 4210209 4209272}
<span class="lineNum">      34 </span>            : *   11/15/99    weiv        Added YEAR_WOY and DOW_LOCAL computation
<span class="lineNum">      35 </span>            : *                           to timeToFields method, updated kMinValues, kMaxValues &amp; kLeastMaxValues
<span class="lineNum">      36 </span>            : *   12/09/99    aliu        Fixed j81, calculation errors and roll bugs
<span class="lineNum">      37 </span>            : *                           in year of cutover.
<span class="lineNum">      38 </span>            : *   01/24/2000  aliu        Revised computeJulianDay for YEAR YEAR_WOY WOY.
<span class="lineNum">      39 </span>            : ********************************************************************************
<span class="lineNum">      40 </span>            : */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #include &quot;unicode/utypes.h&quot;
<span class="lineNum">      43 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #if !UCONFIG_NO_FORMATTING
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #include &quot;unicode/gregocal.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;gregoimp.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;umutex.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;uassert.h&quot;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : // *****************************************************************************
<span class="lineNum">      53 </span>            : // class GregorianCalendar
<span class="lineNum">      54 </span>            : // *****************************************************************************
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /**
<span class="lineNum">      57 </span>            : * Note that the Julian date used here is not a true Julian date, since
<span class="lineNum">      58 </span>            : * it is measured from midnight, not noon.  This value is the Julian
<span class="lineNum">      59 </span>            : * day number of January 1, 1970 (Gregorian calendar) at noon UTC. [LIU]
<span class="lineNum">      60 </span>            : */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : static const int16_t kNumDays[]
<span class="lineNum">      63 </span>            : = {0,31,59,90,120,151,181,212,243,273,304,334}; // 0-based, for day-in-year
<span class="lineNum">      64 </span>            : static const int16_t kLeapNumDays[]
<span class="lineNum">      65 </span>            : = {0,31,60,91,121,152,182,213,244,274,305,335}; // 0-based, for day-in-year
<span class="lineNum">      66 </span>            : static const int8_t kMonthLength[]
<span class="lineNum">      67 </span>            : = {31,28,31,30,31,30,31,31,30,31,30,31}; // 0-based
<span class="lineNum">      68 </span>            : static const int8_t kLeapMonthLength[]
<span class="lineNum">      69 </span>            : = {31,29,31,30,31,30,31,31,30,31,30,31}; // 0-based
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : // setTimeInMillis() limits the Julian day range to +/-7F000000.
<span class="lineNum">      72 </span>            : // This would seem to limit the year range to:
<span class="lineNum">      73 </span>            : //  ms=+183882168921600000  jd=7f000000  December 20, 5828963 AD
<span class="lineNum">      74 </span>            : //  ms=-184303902528000000  jd=81000000  September 20, 5838270 BC
<span class="lineNum">      75 </span>            : // HOWEVER, CalendarRegressionTest/Test4167060 shows that the actual
<span class="lineNum">      76 </span>            : // range limit on the year field is smaller (~ +/-140000). [alan 3.0]
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : static const int32_t kGregorianCalendarLimits[UCAL_FIELD_COUNT][4] = {
<span class="lineNum">      79 </span>            :     // Minimum  Greatest    Least  Maximum
<span class="lineNum">      80 </span>            :     //           Minimum  Maximum
<span class="lineNum">      81 </span>            :     {        0,        0,        1,        1}, // ERA
<span class="lineNum">      82 </span>            :     {        1,        1,   140742,   144683}, // YEAR
<span class="lineNum">      83 </span>            :     {        0,        0,       11,       11}, // MONTH
<span class="lineNum">      84 </span>            :     {        1,        1,       52,       53}, // WEEK_OF_YEAR
<span class="lineNum">      85 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // WEEK_OF_MONTH
<span class="lineNum">      86 </span>            :     {        1,        1,       28,       31}, // DAY_OF_MONTH
<span class="lineNum">      87 </span>            :     {        1,        1,      365,      366}, // DAY_OF_YEAR
<span class="lineNum">      88 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DAY_OF_WEEK
<span class="lineNum">      89 </span>            :     {       -1,       -1,        4,        5}, // DAY_OF_WEEK_IN_MONTH
<span class="lineNum">      90 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // AM_PM
<span class="lineNum">      91 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR
<span class="lineNum">      92 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // HOUR_OF_DAY
<span class="lineNum">      93 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MINUTE
<span class="lineNum">      94 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // SECOND
<span class="lineNum">      95 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECOND
<span class="lineNum">      96 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // ZONE_OFFSET
<span class="lineNum">      97 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DST_OFFSET
<span class="lineNum">      98 </span>            :     {  -140742,  -140742,   140742,   144683}, // YEAR_WOY
<span class="lineNum">      99 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // DOW_LOCAL
<span class="lineNum">     100 </span>            :     {  -140742,  -140742,   140742,   144683}, // EXTENDED_YEAR
<span class="lineNum">     101 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // JULIAN_DAY
<span class="lineNum">     102 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // MILLISECONDS_IN_DAY
<span class="lineNum">     103 </span>            :     {/*N/A*/-1,/*N/A*/-1,/*N/A*/-1,/*N/A*/-1}, // IS_LEAP_MONTH
<span class="lineNum">     104 </span>            : };
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /*
<span class="lineNum">     107 </span>            : * &lt;pre&gt;
<span class="lineNum">     108 </span>            : *                            Greatest       Least 
<span class="lineNum">     109 </span>            : * Field name        Minimum   Minimum     Maximum     Maximum
<span class="lineNum">     110 </span>            : * ----------        -------   -------     -------     -------
<span class="lineNum">     111 </span>            : * ERA                     0         0           1           1
<span class="lineNum">     112 </span>            : * YEAR                    1         1      140742      144683
<span class="lineNum">     113 </span>            : * MONTH                   0         0          11          11
<span class="lineNum">     114 </span>            : * WEEK_OF_YEAR            1         1          52          53
<span class="lineNum">     115 </span>            : * WEEK_OF_MONTH           0         0           4           6
<span class="lineNum">     116 </span>            : * DAY_OF_MONTH            1         1          28          31
<span class="lineNum">     117 </span>            : * DAY_OF_YEAR             1         1         365         366
<span class="lineNum">     118 </span>            : * DAY_OF_WEEK             1         1           7           7
<span class="lineNum">     119 </span>            : * DAY_OF_WEEK_IN_MONTH   -1        -1           4           5
<span class="lineNum">     120 </span>            : * AM_PM                   0         0           1           1
<span class="lineNum">     121 </span>            : * HOUR                    0         0          11          11
<span class="lineNum">     122 </span>            : * HOUR_OF_DAY             0         0          23          23
<span class="lineNum">     123 </span>            : * MINUTE                  0         0          59          59
<span class="lineNum">     124 </span>            : * SECOND                  0         0          59          59
<span class="lineNum">     125 </span>            : * MILLISECOND             0         0         999         999
<span class="lineNum">     126 </span>            : * ZONE_OFFSET           -12*      -12*         12*         12*
<span class="lineNum">     127 </span>            : * DST_OFFSET              0         0           1*          1*
<span class="lineNum">     128 </span>            : * YEAR_WOY                1         1      140742      144683
<span class="lineNum">     129 </span>            : * DOW_LOCAL               1         1           7           7
<span class="lineNum">     130 </span>            : * &lt;/pre&gt;
<span class="lineNum">     131 </span>            : * (*) In units of one-hour
<span class="lineNum">     132 </span>            : */
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : #if defined( U_DEBUG_CALSVC ) || defined (U_DEBUG_CAL)
<span class="lineNum">     135 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : 
<a name="138"><span class="lineNum">     138 </span>            : U_NAMESPACE_BEGIN</a>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 : UOBJECT_DEFINE_RTTI_IMPLEMENTATION(GregorianCalendar)</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : // 00:00:00 UTC, October 15, 1582, expressed in ms from the epoch.
<span class="lineNum">     143 </span>            : // Note that only Italy and other Catholic countries actually
<span class="lineNum">     144 </span>            : // observed this cutover.  Most other countries followed in
<span class="lineNum">     145 </span>            : // the next few centuries, some as late as 1928. [LIU]
<span class="lineNum">     146 </span>            : // in Java, -12219292800000L
<span class="lineNum">     147 </span>            : //const UDate GregorianCalendar::kPapalCutover = -12219292800000L;
<span class="lineNum">     148 </span>            : static const uint32_t kCutoverJulianDay = 2299161;
<span class="lineNum">     149 </span>            : static const UDate kPapalCutover = (2299161.0 - kEpochStartAsJulianDay) * U_MILLIS_PER_DAY;
<span class="lineNum">     150 </span>            : //static const UDate kPapalCutoverJulian = (2299161.0 - kEpochStartAsJulianDay);
<span class="lineNum">     151 </span>            : 
<a name="152"><span class="lineNum">     152 </span>            : // -------------------------------------</a>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(UErrorCode&amp; status)</span>
<span class="lineNum">     155 </span>            : :   Calendar(status),
<span class="lineNum">     156 </span>            : fGregorianCutover(kPapalCutover),
<span class="lineNum">     157 </span><span class="lineNoCov">          0 : fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 : fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     162 </span>            : 
<a name="163"><span class="lineNum">     163 </span>            : // -------------------------------------</a>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(TimeZone* zone, UErrorCode&amp; status)</span>
<span class="lineNum">     166 </span>            : :   Calendar(zone, Locale::getDefault(), status),
<span class="lineNum">     167 </span>            : fGregorianCutover(kPapalCutover),
<span class="lineNum">     168 </span><span class="lineNoCov">          0 : fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 : fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     170 </span>            : {
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     173 </span>            : 
<a name="174"><span class="lineNum">     174 </span>            : // -------------------------------------</a>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(const TimeZone&amp; zone, UErrorCode&amp; status)</span>
<span class="lineNum">     177 </span>            : :   Calendar(zone, Locale::getDefault(), status),
<span class="lineNum">     178 </span>            : fGregorianCutover(kPapalCutover),
<span class="lineNum">     179 </span><span class="lineNoCov">          0 : fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     184 </span>            : 
<a name="185"><span class="lineNum">     185 </span>            : // -------------------------------------</a>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(const Locale&amp; aLocale, UErrorCode&amp; status)</span>
<span class="lineNum">     188 </span>            : :   Calendar(TimeZone::createDefault(), aLocale, status),
<span class="lineNum">     189 </span>            : fGregorianCutover(kPapalCutover),
<span class="lineNum">     190 </span><span class="lineNoCov">          0 : fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 : fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     195 </span>            : 
<a name="196"><span class="lineNum">     196 </span>            : // -------------------------------------</a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(TimeZone* zone, const Locale&amp; aLocale,</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                                      UErrorCode&amp; status)</span>
<span class="lineNum">     200 </span>            :                                      :   Calendar(zone, aLocale, status),
<span class="lineNum">     201 </span>            :                                      fGregorianCutover(kPapalCutover),
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                                      fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     207 </span>            : 
<a name="208"><span class="lineNum">     208 </span>            : // -------------------------------------</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(const TimeZone&amp; zone, const Locale&amp; aLocale,</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                                      UErrorCode&amp; status)</span>
<span class="lineNum">     212 </span>            :                                      :   Calendar(zone, aLocale, status),
<span class="lineNum">     213 </span>            :                                      fGregorianCutover(kPapalCutover),
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                                      fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     216 </span>            : {
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     setTimeInMillis(getNow(), status);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     219 </span>            : 
<a name="220"><span class="lineNum">     220 </span>            : // -------------------------------------</a>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                                      UErrorCode&amp; status)</span>
<span class="lineNum">     224 </span>            :                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
<span class="lineNum">     225 </span>            :                                      fGregorianCutover(kPapalCutover),
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                                      fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     set(UCAL_ERA, AD);</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     set(UCAL_YEAR, year);</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     set(UCAL_MONTH, month);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     set(UCAL_DATE, date);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     234 </span>            : 
<a name="235"><span class="lineNum">     235 </span>            : // -------------------------------------</a>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                                      int32_t hour, int32_t minute, UErrorCode&amp; status)</span>
<span class="lineNum">     239 </span>            :                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
<span class="lineNum">     240 </span>            :                                      fGregorianCutover(kPapalCutover),
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :                                      fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     243 </span>            : {
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     set(UCAL_ERA, AD);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     set(UCAL_YEAR, year);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     set(UCAL_MONTH, month);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     set(UCAL_DATE, date);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     set(UCAL_HOUR_OF_DAY, hour);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     set(UCAL_MINUTE, minute);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     251 </span>            : 
<a name="252"><span class="lineNum">     252 </span>            : // -------------------------------------</a>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(int32_t year, int32_t month, int32_t date,</span>
<span class="lineNum">     255 </span>            :                                      int32_t hour, int32_t minute, int32_t second,
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                                      UErrorCode&amp; status)</span>
<span class="lineNum">     257 </span>            :                                      :   Calendar(TimeZone::createDefault(), Locale::getDefault(), status),
<span class="lineNum">     258 </span>            :                                      fGregorianCutover(kPapalCutover),
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                                      fCutoverJulianDay(kCutoverJulianDay), fNormalizedGregorianCutover(fGregorianCutover), fGregorianCutoverYear(1582),</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :                                      fIsGregorian(TRUE), fInvertGregorian(FALSE)</span>
<span class="lineNum">     261 </span>            : {
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     set(UCAL_ERA, AD);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     set(UCAL_YEAR, year);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     set(UCAL_MONTH, month);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     set(UCAL_DATE, date);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     set(UCAL_HOUR_OF_DAY, hour);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     set(UCAL_MINUTE, minute);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     set(UCAL_SECOND, second);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     270 </span>            : 
<a name="271"><span class="lineNum">     271 </span>            : // -------------------------------------</a>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 : GregorianCalendar::~GregorianCalendar()</span>
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     276 </span>            : 
<a name="277"><span class="lineNum">     277 </span>            : // -------------------------------------</a>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : GregorianCalendar::GregorianCalendar(const GregorianCalendar &amp;source)</span>
<span class="lineNum">     280 </span>            : :   Calendar(source),
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : fGregorianCutover(source.fGregorianCutover),</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : fCutoverJulianDay(source.fCutoverJulianDay), fNormalizedGregorianCutover(source.fNormalizedGregorianCutover), fGregorianCutoverYear(source.fGregorianCutoverYear),</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 : fIsGregorian(source.fIsGregorian), fInvertGregorian(source.fInvertGregorian)</span>
<span class="lineNum">     284 </span>            : {
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     286 </span>            : 
<a name="287"><span class="lineNum">     287 </span>            : // -------------------------------------</a>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : Calendar* GregorianCalendar::clone() const</span>
<span class="lineNum">     290 </span>            : {
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     return new GregorianCalendar(*this);</span>
<span class="lineNum">     292 </span>            : }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : // -------------------------------------
<a name="295"><span class="lineNum">     295 </span>            : </a>
<span class="lineNum">     296 </span>            : GregorianCalendar &amp;
<span class="lineNum">     297 </span><span class="lineNoCov">          0 : GregorianCalendar::operator=(const GregorianCalendar &amp;right)</span>
<span class="lineNum">     298 </span>            : {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     if (this != &amp;right)</span>
<span class="lineNum">     300 </span>            :     {
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         Calendar::operator=(right);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         fGregorianCutover = right.fGregorianCutover;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         fNormalizedGregorianCutover = right.fNormalizedGregorianCutover;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         fGregorianCutoverYear = right.fGregorianCutoverYear;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         fCutoverJulianDay = right.fCutoverJulianDay;</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     308 </span>            : }
<span class="lineNum">     309 </span>            : 
<a name="310"><span class="lineNum">     310 </span>            : // -------------------------------------</a>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 : UBool GregorianCalendar::isEquivalentTo(const Calendar&amp; other) const</span>
<span class="lineNum">     313 </span>            : {
<span class="lineNum">     314 </span>            :     // Calendar override.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     return Calendar::isEquivalentTo(other) &amp;&amp;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         fGregorianCutover == ((GregorianCalendar*)&amp;other)-&gt;fGregorianCutover;</span>
<span class="lineNum">     317 </span>            : }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : // -------------------------------------
<a name="320"><span class="lineNum">     320 </span>            : </a>
<span class="lineNum">     321 </span>            : void
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : GregorianCalendar::setGregorianChange(UDate date, UErrorCode&amp; status)</span>
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) </span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     fGregorianCutover = date;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     // Precompute two internal variables which we use to do the actual
<span class="lineNum">     330 </span>            :     // cutover computations.  These are the normalized cutover, which is the
<span class="lineNum">     331 </span>            :     // midnight at or before the cutover, and the cutover year.  The
<span class="lineNum">     332 </span>            :     // normalized cutover is in pure date milliseconds; it contains no time
<span class="lineNum">     333 </span>            :     // of day or timezone component, and it used to compare against other
<span class="lineNum">     334 </span>            :     // pure date values.
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     int32_t cutoverDay = (int32_t)ClockMath::floorDivide(fGregorianCutover, (double)kOneDay);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     fNormalizedGregorianCutover = cutoverDay * kOneDay;</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     // Handle the rare case of numeric overflow.  If the user specifies a
<span class="lineNum">     339 </span>            :     // change of UDate(Long.MIN_VALUE), in order to get a pure Gregorian
<span class="lineNum">     340 </span>            :     // calendar, then the epoch day is -106751991168, which when multiplied
<span class="lineNum">     341 </span>            :     // by ONE_DAY gives 9223372036794351616 -- the negative value is too
<span class="lineNum">     342 </span>            :     // large for 64 bits, and overflows into a positive value.  We correct
<span class="lineNum">     343 </span>            :     // this by using the next day, which for all intents is semantically
<span class="lineNum">     344 </span>            :     // equivalent.
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     if (cutoverDay &lt; 0 &amp;&amp; fNormalizedGregorianCutover &gt; 0) {</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         fNormalizedGregorianCutover = (cutoverDay + 1) * kOneDay;</span>
<span class="lineNum">     347 </span>            :     }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     // Normalize the year so BC values are represented as 0 and negative
<span class="lineNum">     350 </span>            :     // values.
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     GregorianCalendar *cal = new GregorianCalendar(getTimeZone(), status);</span>
<span class="lineNum">     352 </span>            :     /* test for NULL */
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     if (cal == 0) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     if(U_FAILURE(status))</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     cal-&gt;setTime(date, status);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     fGregorianCutoverYear = cal-&gt;get(UCAL_YEAR, status);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     if (cal-&gt;get(UCAL_ERA, status) == BC) </span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         fGregorianCutoverYear = 1 - fGregorianCutoverYear;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     fCutoverJulianDay = cutoverDay;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     delete cal;</span>
<span class="lineNum">     365 </span>            : }
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : void GregorianCalendar::handleComputeFields(int32_t julianDay, UErrorCode&amp; status) {</span>
<span class="lineNum">     369 </span>            :     int32_t eyear, month, dayOfMonth, dayOfYear, unusedRemainder;
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     if(U_FAILURE(status)) { </span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         return; </span>
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     377 </span>            :     fprintf(stderr, &quot;%s:%d: jd%d- (greg's %d)- [cut=%d]\n&quot;, 
<span class="lineNum">     378 </span>            :         __FILE__, __LINE__, julianDay, getGregorianDayOfYear(), fCutoverJulianDay);
<span class="lineNum">     379 </span>            : #endif
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     if (julianDay &gt;= fCutoverJulianDay) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         month = getGregorianMonth();</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         dayOfMonth = getGregorianDayOfMonth();</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         dayOfYear = getGregorianDayOfYear();</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         eyear = getGregorianYear();</span>
<span class="lineNum">     387 </span>            :     } else {
<span class="lineNum">     388 </span>            :         // The Julian epoch day (not the same as Julian Day)
<span class="lineNum">     389 </span>            :         // is zero on Saturday December 30, 0 (Gregorian).
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         int32_t julianEpochDay = julianDay - (kJan1_1JulianDay - 2);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                 eyear = (int32_t) ClockMath::floorDivide((4.0*julianEpochDay) + 1464.0, (int32_t) 1461, unusedRemainder);</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :         // Compute the Julian calendar day number for January 1, eyear
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         int32_t january1 = 365*(eyear-1) + ClockMath::floorDivide(eyear-1, (int32_t)4);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         dayOfYear = (julianEpochDay - january1); // 0-based</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :         // Julian leap years occurred historically every 4 years starting
<span class="lineNum">     398 </span>            :         // with 8 AD.  Before 8 AD the spacing is irregular; every 3 years
<span class="lineNum">     399 </span>            :         // from 45 BC to 9 BC, and then none until 8 AD.  However, we don't
<span class="lineNum">     400 </span>            :         // implement this historical detail; instead, we implement the
<span class="lineNum">     401 </span>            :         // computatinally cleaner proleptic calendar, which assumes
<span class="lineNum">     402 </span>            :         // consistent 4-year cycles throughout time.
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :         UBool isLeap = ((eyear&amp;0x3) == 0); // equiv. to (eyear%4 == 0)</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :         // Common Julian/Gregorian calculation
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         int32_t correction = 0;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         int32_t march1 = isLeap ? 60 : 59; // zero-based DOY for March 1</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         if (dayOfYear &gt;= march1) {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :             correction = isLeap ? 1 : 2;</span>
<span class="lineNum">     410 </span>            :         }
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         month = (12 * (dayOfYear + correction) + 6) / 367; // zero-based month</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         dayOfMonth = dayOfYear - (isLeap?kLeapNumDays[month]:kNumDays[month]) + 1; // one-based DOM</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         ++dayOfYear;</span>
<span class="lineNum">     414 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     415 </span>            :         //     fprintf(stderr, &quot;%d - %d[%d] + 1\n&quot;, dayOfYear, isLeap?kLeapNumDays[month]:kNumDays[month], month );
<span class="lineNum">     416 </span>            :         //           fprintf(stderr, &quot;%s:%d:  greg's HCF %d -&gt; %d/%d/%d not %d/%d/%d\n&quot;, 
<span class="lineNum">     417 </span>            :         //                   __FILE__, __LINE__,julianDay,
<span class="lineNum">     418 </span>            :         //          eyear,month,dayOfMonth,
<span class="lineNum">     419 </span>            :         //          getGregorianYear(), getGregorianMonth(), getGregorianDayOfMonth()  );
<span class="lineNum">     420 </span>            :         fprintf(stderr, &quot;%s:%d: doy %d (greg's %d)- [cut=%d]\n&quot;, 
<span class="lineNum">     421 </span>            :             __FILE__, __LINE__, dayOfYear, getGregorianDayOfYear(), fCutoverJulianDay);
<span class="lineNum">     422 </span>            : #endif
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :     }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :     // [j81] if we are after the cutover in its year, shift the day of the year
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     if((eyear == fGregorianCutoverYear) &amp;&amp; (julianDay &gt;= fCutoverJulianDay)) {</span>
<span class="lineNum">     428 </span>            :         //from handleComputeMonthStart
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         int32_t gregShift = Grego::gregorianShift(eyear);</span>
<span class="lineNum">     430 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     431 </span>            :         fprintf(stderr, &quot;%s:%d:  gregorian shift %d :::  doy%d =&gt; %d [cut=%d]\n&quot;,
<span class="lineNum">     432 </span>            :             __FILE__, __LINE__,gregShift, dayOfYear, dayOfYear+gregShift, fCutoverJulianDay);
<span class="lineNum">     433 </span>            : #endif
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         dayOfYear += gregShift;</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     internalSet(UCAL_MONTH, month);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     internalSet(UCAL_DAY_OF_MONTH, dayOfMonth);</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     internalSet(UCAL_DAY_OF_YEAR, dayOfYear);</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     internalSet(UCAL_EXTENDED_YEAR, eyear);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     int32_t era = AD;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     if (eyear &lt; 1) {</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :         era = BC;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         eyear = 1 - eyear;</span>
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     internalSet(UCAL_ERA, era);</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     internalSet(UCAL_YEAR, eyear);</span>
<span class="lineNum">     448 </span>            : }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : // -------------------------------------
<a name="452"><span class="lineNum">     452 </span>            : </a>
<span class="lineNum">     453 </span>            : UDate
<span class="lineNum">     454 </span><span class="lineNoCov">          0 : GregorianCalendar::getGregorianChange() const</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     return fGregorianCutover;</span>
<span class="lineNum">     457 </span>            : }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : // -------------------------------------
<a name="460"><span class="lineNum">     460 </span>            : </a>
<span class="lineNum">     461 </span>            : UBool 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : GregorianCalendar::isLeapYear(int32_t year) const</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span>            :     // MSVC complains bitterly if we try to use Grego::isLeapYear here
<span class="lineNum">     465 </span>            :     // NOTE: year&amp;0x3 == year%4
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     return (year &gt;= fGregorianCutoverYear ?</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         (((year&amp;0x3) == 0) &amp;&amp; ((year%100 != 0) || (year%400 == 0))) : // Gregorian</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     ((year&amp;0x3) == 0)); // Julian</span>
<span class="lineNum">     469 </span>            : }
<span class="lineNum">     470 </span>            : 
<a name="471"><span class="lineNum">     471 </span>            : // -------------------------------------</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleComputeJulianDay(UCalendarDateFields bestField) </span>
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     fInvertGregorian = FALSE;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     int32_t jd = Calendar::handleComputeJulianDay(bestField);</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     if((bestField == UCAL_WEEK_OF_YEAR) &amp;&amp;  // if we are doing WOY calculations, we are counting relative to Jan 1 *julian*</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         (internalGet(UCAL_EXTENDED_YEAR)==fGregorianCutoverYear) &amp;&amp; </span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         jd &gt;= fCutoverJulianDay) { </span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :             fInvertGregorian = TRUE;  // So that the Julian Jan 1 will be used in handleComputeMonthStart</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :             return Calendar::handleComputeJulianDay(bestField);</span>
<span class="lineNum">     484 </span>            :         }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :         // The following check handles portions of the cutover year BEFORE the
<span class="lineNum">     488 </span>            :         // cutover itself happens.
<span class="lineNum">     489 </span>            :         //if ((fIsGregorian==TRUE) != (jd &gt;= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         if ((fIsGregorian==TRUE) != (jd &gt;= fCutoverJulianDay)) {  /*  cutoverJulianDay)) { */</span>
<span class="lineNum">     491 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     492 </span>            :             fprintf(stderr, &quot;%s:%d: jd [invert] %d\n&quot;, 
<span class="lineNum">     493 </span>            :                 __FILE__, __LINE__, jd);
<span class="lineNum">     494 </span>            : #endif
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             fInvertGregorian = TRUE;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             jd = Calendar::handleComputeJulianDay(bestField);</span>
<span class="lineNum">     497 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     498 </span>            :             fprintf(stderr, &quot;%s:%d:  fIsGregorian %s, fInvertGregorian %s - &quot;, 
<span class="lineNum">     499 </span>            :                 __FILE__, __LINE__,fIsGregorian?&quot;T&quot;:&quot;F&quot;, fInvertGregorian?&quot;T&quot;:&quot;F&quot;);
<span class="lineNum">     500 </span>            :             fprintf(stderr, &quot; jd NOW %d\n&quot;, 
<span class="lineNum">     501 </span>            :                 jd);
<span class="lineNum">     502 </span>            : #endif
<span class="lineNum">     503 </span>            :         } else {
<span class="lineNum">     504 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     505 </span>            :             fprintf(stderr, &quot;%s:%d: jd [==] %d - %sfIsGregorian %sfInvertGregorian, %d\n&quot;, 
<span class="lineNum">     506 </span>            :                 __FILE__, __LINE__, jd, fIsGregorian?&quot;T&quot;:&quot;F&quot;, fInvertGregorian?&quot;T&quot;:&quot;F&quot;, bestField);
<span class="lineNum">     507 </span>            : #endif
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         if(fIsGregorian &amp;&amp; (internalGet(UCAL_EXTENDED_YEAR) == fGregorianCutoverYear)) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :             int32_t gregShift = Grego::gregorianShift(internalGet(UCAL_EXTENDED_YEAR));</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :             if (bestField == UCAL_DAY_OF_YEAR) {</span>
<span class="lineNum">     513 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     514 </span>            :                 fprintf(stderr, &quot;%s:%d: [DOY%d] gregorian shift of JD %d += %d\n&quot;, 
<span class="lineNum">     515 </span>            :                     __FILE__, __LINE__, fFields[bestField],jd, gregShift);
<span class="lineNum">     516 </span>            : #endif
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                 jd -= gregShift;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :             } else if ( bestField == UCAL_WEEK_OF_MONTH ) {</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                 int32_t weekShift = 14;</span>
<span class="lineNum">     520 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     521 </span>            :                 fprintf(stderr, &quot;%s:%d: [WOY/WOM] gregorian week shift of %d += %d\n&quot;, 
<span class="lineNum">     522 </span>            :                     __FILE__, __LINE__, jd, weekShift);
<span class="lineNum">     523 </span>            : #endif
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 jd += weekShift; // shift by weeks for week based fields.</span>
<span class="lineNum">     525 </span>            :             }
<span class="lineNum">     526 </span>            :         }
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         return jd;</span>
<a name="529"><span class="lineNum">     529 </span>            : }</a>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month,</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :                                                    UBool /* useMonth */) const
<span class="lineNum">     534 </span>            : {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     GregorianCalendar *nonConstThis = (GregorianCalendar*)this; // cast away const</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     // If the month is out of range, adjust it into range, and
<span class="lineNum">     538 </span>            :     // modify the extended year value accordingly.
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     if (month &lt; 0 || month &gt; 11) {</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         eyear += ClockMath::floorDivide(month, 12, month);</span>
<span class="lineNum">     541 </span>            :     }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     UBool isLeap = eyear%4 == 0;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     int32_t y = eyear-1;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     int32_t julianDay = 365*y + ClockMath::floorDivide(y, 4) + (kJan1_1JulianDay - 3);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     nonConstThis-&gt;fIsGregorian = (eyear &gt;= fGregorianCutoverYear);</span>
<span class="lineNum">     548 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     549 </span>            :     fprintf(stderr, &quot;%s:%d: (hcms%d/%d) fIsGregorian %s, fInvertGregorian %s\n&quot;, 
<span class="lineNum">     550 </span>            :         __FILE__, __LINE__, eyear,month, fIsGregorian?&quot;T&quot;:&quot;F&quot;, fInvertGregorian?&quot;T&quot;:&quot;F&quot;);
<span class="lineNum">     551 </span>            : #endif
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     if (fInvertGregorian) {</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         nonConstThis-&gt;fIsGregorian = !fIsGregorian;</span>
<span class="lineNum">     554 </span>            :     }
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     if (fIsGregorian) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         isLeap = isLeap &amp;&amp; ((eyear%100 != 0) || (eyear%400 == 0));</span>
<span class="lineNum">     557 </span>            :         // Add 2 because Gregorian calendar starts 2 days after
<span class="lineNum">     558 </span>            :         // Julian calendar
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         int32_t gregShift = Grego::gregorianShift(eyear);</span>
<span class="lineNum">     560 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     561 </span>            :         fprintf(stderr, &quot;%s:%d: (hcms%d/%d) gregorian shift of %d += %d\n&quot;, 
<span class="lineNum">     562 </span>            :             __FILE__, __LINE__, eyear, month, julianDay, gregShift);
<span class="lineNum">     563 </span>            : #endif
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         julianDay += gregShift;</span>
<span class="lineNum">     565 </span>            :     }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :     // At this point julianDay indicates the day BEFORE the first
<span class="lineNum">     568 </span>            :     // day of January 1, &lt;eyear&gt; of either the Julian or Gregorian
<span class="lineNum">     569 </span>            :     // calendar.
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     if (month != 0) {</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         julianDay += isLeap?kLeapNumDays[month]:kNumDays[month];</span>
<span class="lineNum">     573 </span>            :     }
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     return julianDay;</span>
<a name="576"><span class="lineNum">     576 </span>            : }</a>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleGetMonthLength(int32_t extendedYear, int32_t month)  const</span>
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span>            :     // If the month is out of range, adjust it into range, and
<span class="lineNum">     581 </span>            :     // modify the extended year value accordingly.
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     if (month &lt; 0 || month &gt; 11) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         extendedYear += ClockMath::floorDivide(month, 12, month);</span>
<span class="lineNum">     584 </span>            :     }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     return isLeapYear(extendedYear) ? kLeapMonthLength[month] : kMonthLength[month];</span>
<a name="587"><span class="lineNum">     587 </span>            : }</a>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleGetYearLength(int32_t eyear) const {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     return isLeapYear(eyear) ? 366 : 365;</span>
<span class="lineNum">     591 </span>            : }
<span class="lineNum">     592 </span>            : 
<a name="593"><span class="lineNum">     593 </span>            : </a>
<span class="lineNum">     594 </span>            : int32_t
<span class="lineNum">     595 </span><span class="lineNoCov">          0 : GregorianCalendar::monthLength(int32_t month) const</span>
<span class="lineNum">     596 </span>            : {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     int32_t year = internalGet(UCAL_EXTENDED_YEAR);</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     return handleGetMonthLength(year, month);</span>
<span class="lineNum">     599 </span>            : }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : // -------------------------------------
<a name="602"><span class="lineNum">     602 </span>            : </a>
<span class="lineNum">     603 </span>            : int32_t
<span class="lineNum">     604 </span><span class="lineNoCov">          0 : GregorianCalendar::monthLength(int32_t month, int32_t year) const</span>
<span class="lineNum">     605 </span>            : {
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     return isLeapYear(year) ? kLeapMonthLength[month] : kMonthLength[month];</span>
<span class="lineNum">     607 </span>            : }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : // -------------------------------------
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : int32_t
<span class="lineNum">     612 </span><span class="lineNoCov">          0 : GregorianCalendar::yearLength(int32_t year) const</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     return isLeapYear(year) ? 366 : 365;</span>
<span class="lineNum">     615 </span>            : }
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            : // -------------------------------------
<a name="618"><span class="lineNum">     618 </span>            : </a>
<span class="lineNum">     619 </span>            : int32_t
<span class="lineNum">     620 </span><span class="lineNoCov">          0 : GregorianCalendar::yearLength() const</span>
<span class="lineNum">     621 </span>            : {
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     return isLeapYear(internalGet(UCAL_YEAR)) ? 366 : 365;</span>
<span class="lineNum">     623 </span>            : }
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : // -------------------------------------
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : /**
<span class="lineNum">     628 </span>            : * After adjustments such as add(MONTH), add(YEAR), we don't want the
<span class="lineNum">     629 </span>            : * month to jump around.  E.g., we don't want Jan 31 + 1 month to go to Mar
<span class="lineNum">     630 </span>            : * 3, we want it to go to Feb 28.  Adjustments which might run into this
<span class="lineNum">     631 </span>            : * problem call this method to retain the proper month.
<a name="632"><span class="lineNum">     632 </span>            : */</a>
<span class="lineNum">     633 </span>            : void 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 : GregorianCalendar::pinDayOfMonth() </span>
<span class="lineNum">     635 </span>            : {
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     int32_t monthLen = monthLength(internalGet(UCAL_MONTH));</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     int32_t dom = internalGet(UCAL_DATE);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     if(dom &gt; monthLen) </span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         set(UCAL_DATE, monthLen);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : // -------------------------------------
<span class="lineNum">     643 </span>            : 
<a name="644"><span class="lineNum">     644 </span>            : </a>
<span class="lineNum">     645 </span>            : UBool
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : GregorianCalendar::validateFields() const</span>
<span class="lineNum">     647 </span>            : {
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     for (int32_t field = 0; field &lt; UCAL_FIELD_COUNT; field++) {</span>
<span class="lineNum">     649 </span>            :         // Ignore DATE and DAY_OF_YEAR which are handled below
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         if (field != UCAL_DATE &amp;&amp;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :             field != UCAL_DAY_OF_YEAR &amp;&amp;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             isSet((UCalendarDateFields)field) &amp;&amp;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :             ! boundsCheck(internalGet((UCalendarDateFields)field), (UCalendarDateFields)field))</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">     655 </span>            :     }
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :     // Values differ in Least-Maximum and Maximum should be handled
<span class="lineNum">     658 </span>            :     // specially.
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     if (isSet(UCAL_DATE)) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         int32_t date = internalGet(UCAL_DATE);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         if (date &lt; getMinimum(UCAL_DATE) ||</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             date &gt; monthLength(internalGet(UCAL_MONTH))) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 return FALSE;</span>
<span class="lineNum">     664 </span>            :             }
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     if (isSet(UCAL_DAY_OF_YEAR)) {</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         int32_t days = internalGet(UCAL_DAY_OF_YEAR);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         if (days &lt; 1 || days &gt; yearLength()) {</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">     671 </span>            :         }
<span class="lineNum">     672 </span>            :     }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :     // Handle DAY_OF_WEEK_IN_MONTH, which must not have the value zero.
<span class="lineNum">     675 </span>            :     // We've checked against minimum and maximum above already.
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     if (isSet(UCAL_DAY_OF_WEEK_IN_MONTH) &amp;&amp;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :         0 == internalGet(UCAL_DAY_OF_WEEK_IN_MONTH)) {</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :             return FALSE;</span>
<span class="lineNum">     679 </span>            :         }
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         return TRUE;</span>
<span class="lineNum">     682 </span>            : }
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : // -------------------------------------
<a name="685"><span class="lineNum">     685 </span>            : </a>
<span class="lineNum">     686 </span>            : UBool
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : GregorianCalendar::boundsCheck(int32_t value, UCalendarDateFields field) const</span>
<span class="lineNum">     688 </span>            : {
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     return value &gt;= getMinimum(field) &amp;&amp; value &lt;= getMaximum(field);</span>
<span class="lineNum">     690 </span>            : }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : // -------------------------------------
<a name="693"><span class="lineNum">     693 </span>            : </a>
<span class="lineNum">     694 </span>            : UDate 
<span class="lineNum">     695 </span><span class="lineNoCov">          0 : GregorianCalendar::getEpochDay(UErrorCode&amp; status) </span>
<span class="lineNum">     696 </span>            : {
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     complete(status);</span>
<span class="lineNum">     698 </span>            :     // Divide by 1000 (convert to seconds) in order to prevent overflow when
<span class="lineNum">     699 </span>            :     // dealing with UDate(Long.MIN_VALUE) and UDate(Long.MAX_VALUE).
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     double wallSec = internalGetTime()/1000 + (internalGet(UCAL_ZONE_OFFSET) + internalGet(UCAL_DST_OFFSET))/1000;</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     return ClockMath::floorDivide(wallSec, kOneDay/1000.0);</span>
<span class="lineNum">     703 </span>            : }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : // -------------------------------------
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : // -------------------------------------
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            : /**
<span class="lineNum">     711 </span>            : * Compute the julian day number of the day BEFORE the first day of
<span class="lineNum">     712 </span>            : * January 1, year 1 of the given calendar.  If julianDay == 0, it
<span class="lineNum">     713 </span>            : * specifies (Jan. 1, 1) - 1, in whatever calendar we are using (Julian
<a name="714"><span class="lineNum">     714 </span>            : * or Gregorian).</a>
<span class="lineNum">     715 </span>            : */
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : double GregorianCalendar::computeJulianDayOfYear(UBool isGregorian,</span>
<span class="lineNum">     717 </span>            :                                                  int32_t year, UBool&amp; isLeap)
<span class="lineNum">     718 </span>            : {
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     isLeap = year%4 == 0;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     int32_t y = year - 1;</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     double julianDay = 365.0*y + ClockMath::floorDivide(y, 4) + (kJan1_1JulianDay - 3);</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :     if (isGregorian) {</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         isLeap = isLeap &amp;&amp; ((year%100 != 0) || (year%400 == 0));</span>
<span class="lineNum">     725 </span>            :         // Add 2 because Gregorian calendar starts 2 days after Julian calendar
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         julianDay += Grego::gregorianShift(year);</span>
<span class="lineNum">     727 </span>            :     }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     return julianDay;</span>
<span class="lineNum">     730 </span>            : }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : // /**
<span class="lineNum">     733 </span>            : //  * Compute the day of week, relative to the first day of week, from
<span class="lineNum">     734 </span>            : //  * 0..6, of the current DOW_LOCAL or DAY_OF_WEEK fields.  This is
<span class="lineNum">     735 </span>            : //  * equivalent to get(DOW_LOCAL) - 1.
<span class="lineNum">     736 </span>            : //  */
<span class="lineNum">     737 </span>            : // int32_t GregorianCalendar::computeRelativeDOW() const {
<span class="lineNum">     738 </span>            : //     int32_t relDow = 0;
<span class="lineNum">     739 </span>            : //     if (fStamp[UCAL_DOW_LOCAL] &gt; fStamp[UCAL_DAY_OF_WEEK]) {
<span class="lineNum">     740 </span>            : //         relDow = internalGet(UCAL_DOW_LOCAL) - 1; // 1-based
<span class="lineNum">     741 </span>            : //     } else if (fStamp[UCAL_DAY_OF_WEEK] != kUnset) {
<span class="lineNum">     742 </span>            : //         relDow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();
<span class="lineNum">     743 </span>            : //         if (relDow &lt; 0) relDow += 7;
<span class="lineNum">     744 </span>            : //     }
<span class="lineNum">     745 </span>            : //     return relDow;
<span class="lineNum">     746 </span>            : // }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : // /**
<span class="lineNum">     749 </span>            : //  * Compute the day of week, relative to the first day of week,
<span class="lineNum">     750 </span>            : //  * from 0..6 of the given julian day.
<span class="lineNum">     751 </span>            : //  */
<span class="lineNum">     752 </span>            : // int32_t GregorianCalendar::computeRelativeDOW(double julianDay) const {
<span class="lineNum">     753 </span>            : //   int32_t relDow = julianDayToDayOfWeek(julianDay) - getFirstDayOfWeek();
<span class="lineNum">     754 </span>            : //     if (relDow &lt; 0) {
<span class="lineNum">     755 </span>            : //         relDow += 7;
<span class="lineNum">     756 </span>            : //     }
<span class="lineNum">     757 </span>            : //     return relDow;
<span class="lineNum">     758 </span>            : // }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : // /**
<span class="lineNum">     761 </span>            : //  * Compute the DOY using the WEEK_OF_YEAR field and the julian day
<span class="lineNum">     762 </span>            : //  * of the day BEFORE January 1 of a year (a return value from
<span class="lineNum">     763 </span>            : //  * computeJulianDayOfYear).
<span class="lineNum">     764 </span>            : //  */
<span class="lineNum">     765 </span>            : // int32_t GregorianCalendar::computeDOYfromWOY(double julianDayOfYear) const {
<span class="lineNum">     766 </span>            : //     // Compute DOY from day of week plus week of year
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            : //     // Find the day of the week for the first of this year.  This
<span class="lineNum">     769 </span>            : //     // is zero-based, with 0 being the locale-specific first day of
<span class="lineNum">     770 </span>            : //     // the week.  Add 1 to get first day of year.
<span class="lineNum">     771 </span>            : //     int32_t fdy = computeRelativeDOW(julianDayOfYear + 1);
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : //     return
<span class="lineNum">     774 </span>            : //         // Compute doy of first (relative) DOW of WOY 1
<span class="lineNum">     775 </span>            : //         (((7 - fdy) &lt; getMinimalDaysInFirstWeek())
<span class="lineNum">     776 </span>            : //          ? (8 - fdy) : (1 - fdy))
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : //         // Adjust for the week number.
<span class="lineNum">     779 </span>            : //         + (7 * (internalGet(UCAL_WEEK_OF_YEAR) - 1))
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : //         // Adjust for the DOW
<span class="lineNum">     782 </span>            : //         + computeRelativeDOW();
<span class="lineNum">     783 </span>            : // }
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            : // -------------------------------------
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : double 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 : GregorianCalendar::millisToJulianDay(UDate millis)</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     return (double)kEpochStartAsJulianDay + ClockMath::floorDivide(millis, (double)kOneDay);</span>
<span class="lineNum">     791 </span>            : }
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            : // -------------------------------------
<a name="794"><span class="lineNum">     794 </span>            : </a>
<span class="lineNum">     795 </span>            : UDate
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : GregorianCalendar::julianDayToMillis(double julian)</span>
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     return (UDate) ((julian - kEpochStartAsJulianDay) * (double) kOneDay);</span>
<span class="lineNum">     799 </span>            : }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : // -------------------------------------
<a name="802"><span class="lineNum">     802 </span>            : </a>
<span class="lineNum">     803 </span>            : int32_t
<span class="lineNum">     804 </span><span class="lineNoCov">          0 : GregorianCalendar::aggregateStamp(int32_t stamp_a, int32_t stamp_b) </span>
<span class="lineNum">     805 </span>            : {
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     return (((stamp_a != kUnset &amp;&amp; stamp_b != kUnset) </span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         ? uprv_max(stamp_a, stamp_b)</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         : (int32_t)kUnset));</span>
<span class="lineNum">     809 </span>            : }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : // -------------------------------------
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : /**
<span class="lineNum">     814 </span>            : * Roll a field by a signed amount.
<span class="lineNum">     815 </span>            : * Note: This will be made public later. [LIU]
<span class="lineNum">     816 </span>            : */
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : void 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 : GregorianCalendar::roll(EDateFields field, int32_t amount, UErrorCode&amp; status) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     roll((UCalendarDateFields) field, amount, status); </span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 : }</span>
<a name="822"><span class="lineNum">     822 </span>            : </a>
<span class="lineNum">     823 </span>            : void
<span class="lineNum">     824 </span><span class="lineNoCov">          0 : GregorianCalendar::roll(UCalendarDateFields field, int32_t amount, UErrorCode&amp; status)</span>
<span class="lineNum">     825 </span>            : {
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     if((amount == 0) || U_FAILURE(status)) {</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     828 </span>            :     }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            :     // J81 processing. (gregorian cutover)
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     UBool inCutoverMonth = FALSE;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     int32_t cMonthLen=0; // 'c' for cutover; in days</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :     int32_t cDayOfMonth=0; // no discontinuity: [0, cMonthLen)</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     double cMonthStart=0.0; // in ms</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :     // Common code - see if we're in the cutover month of the cutover year
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     if(get(UCAL_EXTENDED_YEAR, status) == fGregorianCutoverYear) {</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :         switch (field) {</span>
<span class="lineNum">     839 </span>            :         case UCAL_DAY_OF_MONTH:
<span class="lineNum">     840 </span>            :         case UCAL_WEEK_OF_MONTH:
<span class="lineNum">     841 </span>            :             {
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                 int32_t max = monthLength(internalGet(UCAL_MONTH));</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                 UDate t = internalGetTime();</span>
<span class="lineNum">     844 </span>            :                 // We subtract 1 from the DAY_OF_MONTH to make it zero-based, and an
<span class="lineNum">     845 </span>            :                 // additional 10 if we are after the cutover. Thus the monthStart
<span class="lineNum">     846 </span>            :                 // value will be correct iff we actually are in the cutover month.
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                 cDayOfMonth = internalGet(UCAL_DAY_OF_MONTH) - ((t &gt;= fGregorianCutover) ? 10 : 0);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :                 cMonthStart = t - ((cDayOfMonth - 1) * kOneDay);</span>
<span class="lineNum">     849 </span>            :                 // A month containing the cutover is 10 days shorter.
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :                 if ((cMonthStart &lt; fGregorianCutover) &amp;&amp;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :                     (cMonthStart + (cMonthLen=(max-10))*kOneDay &gt;= fGregorianCutover)) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :                         inCutoverMonth = TRUE;</span>
<span class="lineNum">     853 </span>            :                     }
<span class="lineNum">     854 </span>            :             }
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     856 </span>            :         default:
<span class="lineNum">     857 </span>            :             ;
<span class="lineNum">     858 </span>            :         }
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     switch (field) {</span>
<span class="lineNum">     862 </span>            :     case UCAL_WEEK_OF_YEAR: {
<span class="lineNum">     863 </span>            :         // Unlike WEEK_OF_MONTH, WEEK_OF_YEAR never shifts the day of the
<span class="lineNum">     864 </span>            :         // week.  Also, rolling the week of the year can have seemingly
<span class="lineNum">     865 </span>            :         // strange effects simply because the year of the week of year
<span class="lineNum">     866 </span>            :         // may be different from the calendar year.  For example, the
<span class="lineNum">     867 </span>            :         // date Dec 28, 1997 is the first day of week 1 of 1998 (if
<span class="lineNum">     868 </span>            :         // weeks start on Sunday and the minimal days in first week is
<span class="lineNum">     869 </span>            :         // &lt;= 3).
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :         int32_t woy = get(UCAL_WEEK_OF_YEAR, status);</span>
<span class="lineNum">     871 </span>            :         // Get the ISO year, which matches the week of year.  This
<span class="lineNum">     872 </span>            :         // may be one year before or after the calendar year.
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         int32_t isoYear = get(UCAL_YEAR_WOY, status);</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         int32_t isoDoy = internalGet(UCAL_DAY_OF_YEAR);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         if (internalGet(UCAL_MONTH) == UCAL_JANUARY) {</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :             if (woy &gt;= 52) {</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :                 isoDoy += handleGetYearLength(isoYear);</span>
<span class="lineNum">     878 </span>            :             }
<span class="lineNum">     879 </span>            :         } else {
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :             if (woy == 1) {</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                 isoDoy -= handleGetYearLength(isoYear - 1);</span>
<span class="lineNum">     882 </span>            :             }
<span class="lineNum">     883 </span>            :         }
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         woy += amount;</span>
<span class="lineNum">     885 </span>            :         // Do fast checks to avoid unnecessary computation:
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         if (woy &lt; 1 || woy &gt; 52) {</span>
<span class="lineNum">     887 </span>            :             // Determine the last week of the ISO year.
<span class="lineNum">     888 </span>            :             // We do this using the standard formula we use
<span class="lineNum">     889 </span>            :             // everywhere in this file.  If we can see that the
<span class="lineNum">     890 </span>            :             // days at the end of the year are going to fall into
<span class="lineNum">     891 </span>            :             // week 1 of the next year, we drop the last week by
<span class="lineNum">     892 </span>            :             // subtracting 7 from the last day of the year.
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :             int32_t lastDoy = handleGetYearLength(isoYear);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :             int32_t lastRelDow = (lastDoy - isoDoy + internalGet(UCAL_DAY_OF_WEEK) -</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                 getFirstDayOfWeek()) % 7;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :             if (lastRelDow &lt; 0) lastRelDow += 7;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :             if ((6 - lastRelDow) &gt;= getMinimalDaysInFirstWeek()) lastDoy -= 7;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :             int32_t lastWoy = weekNumber(lastDoy, lastRelDow + 1);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :             woy = ((woy + lastWoy - 1) % lastWoy) + 1;</span>
<span class="lineNum">     900 </span>            :         }
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         set(UCAL_WEEK_OF_YEAR, woy);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         set(UCAL_YEAR_WOY,isoYear);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     904 </span>            :                             }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :     case UCAL_DAY_OF_MONTH:
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :         if( !inCutoverMonth ) { </span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :             Calendar::roll(field, amount, status);</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     910 </span>            :         } else {
<span class="lineNum">     911 </span>            :             // [j81] 1582 special case for DOM
<span class="lineNum">     912 </span>            :             // The default computation works except when the current month
<span class="lineNum">     913 </span>            :             // contains the Gregorian cutover.  We handle this special case
<span class="lineNum">     914 </span>            :             // here.  [j81 - aliu]
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :             double monthLen = cMonthLen * kOneDay;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :             double msIntoMonth = uprv_fmod(internalGetTime() - cMonthStart +</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                 amount * kOneDay, monthLen);</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :             if (msIntoMonth &lt; 0) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 msIntoMonth += monthLen;</span>
<span class="lineNum">     920 </span>            :             }
<span class="lineNum">     921 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     922 </span>            :             fprintf(stderr, &quot;%s:%d: roll DOM %d  -&gt; %.0lf ms  \n&quot;, 
<span class="lineNum">     923 </span>            :                 __FILE__, __LINE__,amount, cMonthLen, cMonthStart+msIntoMonth);
<span class="lineNum">     924 </span>            : #endif
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :             setTimeInMillis(cMonthStart + msIntoMonth, status);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     927 </span>            :         }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            :     case UCAL_WEEK_OF_MONTH:
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         if( !inCutoverMonth ) { </span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :             Calendar::roll(field, amount, status);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     933 </span>            :         } else {
<span class="lineNum">     934 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">     935 </span>            :             fprintf(stderr, &quot;%s:%d: roll WOM %d ??????????????????? \n&quot;, 
<span class="lineNum">     936 </span>            :                 __FILE__, __LINE__,amount);
<span class="lineNum">     937 </span>            : #endif
<span class="lineNum">     938 </span>            :             // NOTE: following copied from  the old
<span class="lineNum">     939 </span>            :             //     GregorianCalendar::roll( WEEK_OF_MONTH )  code 
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :             // This is tricky, because during the roll we may have to shift
<span class="lineNum">     942 </span>            :             // to a different day of the week.  For example:
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :             //    s  m  t  w  r  f  s
<span class="lineNum">     945 </span>            :             //          1  2  3  4  5
<span class="lineNum">     946 </span>            :             //    6  7  8  9 10 11 12
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :             // When rolling from the 6th or 7th back one week, we go to the
<span class="lineNum">     949 </span>            :             // 1st (assuming that the first partial week counts).  The same
<span class="lineNum">     950 </span>            :             // thing happens at the end of the month.
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :             // The other tricky thing is that we have to figure out whether
<span class="lineNum">     953 </span>            :             // the first partial week actually counts or not, based on the
<span class="lineNum">     954 </span>            :             // minimal first days in the week.  And we have to use the
<span class="lineNum">     955 </span>            :             // correct first day of the week to delineate the week
<span class="lineNum">     956 </span>            :             // boundaries.
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :             // Here's our algorithm.  First, we find the real boundaries of
<span class="lineNum">     959 </span>            :             // the month.  Then we discard the first partial week if it
<span class="lineNum">     960 </span>            :             // doesn't count in this locale.  Then we fill in the ends with
<span class="lineNum">     961 </span>            :             // phantom days, so that the first partial week and the last
<span class="lineNum">     962 </span>            :             // partial week are full weeks.  We then have a nice square
<span class="lineNum">     963 </span>            :             // block of weeks.  We do the usual rolling within this block,
<span class="lineNum">     964 </span>            :             // as is done elsewhere in this method.  If we wind up on one of
<span class="lineNum">     965 </span>            :             // the phantom days that we added, we recognize this and pin to
<span class="lineNum">     966 </span>            :             // the first or the last day of the month.  Easy, eh?
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :             // Another wrinkle: To fix jitterbug 81, we have to make all this
<span class="lineNum">     969 </span>            :             // work in the oddball month containing the Gregorian cutover.
<span class="lineNum">     970 </span>            :             // This month is 10 days shorter than usual, and also contains
<span class="lineNum">     971 </span>            :             // a discontinuity in the days; e.g., the default cutover month
<span class="lineNum">     972 </span>            :             // is Oct 1582, and goes from day of month 4 to day of month 15.
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :             // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
<span class="lineNum">     975 </span>            :             // in this locale.  We have dow in 0..6.
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :             int32_t dow = internalGet(UCAL_DAY_OF_WEEK) - getFirstDayOfWeek();</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :             if (dow &lt; 0) </span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 dow += 7;</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :             // Find the day of month, compensating for cutover discontinuity.
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :             int32_t dom = cDayOfMonth;</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :             // Find the day of the week (normalized for locale) for the first
<span class="lineNum">     984 </span>            :             // of the month.
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :             int32_t fdm = (dow - dom + 1) % 7;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :             if (fdm &lt; 0) </span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :                 fdm += 7;</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :             // Get the first day of the first full week of the month,
<span class="lineNum">     990 </span>            :             // including phantom days, if any.  Figure out if the first week
<span class="lineNum">     991 </span>            :             // counts or not; if it counts, then fill in phantom days.  If
<span class="lineNum">     992 </span>            :             // not, advance to the first real full week (skip the partial week).
<span class="lineNum">     993 </span>            :             int32_t start;
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :             if ((7 - fdm) &lt; getMinimalDaysInFirstWeek())</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :                 start = 8 - fdm; // Skip the first partial week</span>
<span class="lineNum">     996 </span>            :             else
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :                 start = 1 - fdm; // This may be zero or negative</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :             // Get the day of the week (normalized for locale) for the last
<span class="lineNum">    1000 </span>            :             // day of the month.
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :             int32_t monthLen = cMonthLen;</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :             int32_t ldm = (monthLen - dom + dow) % 7;</span>
<span class="lineNum">    1003 </span>            :             // We know monthLen &gt;= DAY_OF_MONTH so we skip the += 7 step here.
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            :             // Get the limit day for the blocked-off rectangular month; that
<span class="lineNum">    1006 </span>            :             // is, the day which is one past the last day of the month,
<span class="lineNum">    1007 </span>            :             // after the month has already been filled in with phantom days
<span class="lineNum">    1008 </span>            :             // to fill out the last week.  This day has a normalized DOW of 0.
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :             int32_t limit = monthLen + 7 - ldm;</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :             // Now roll between start and (limit - 1).
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :             int32_t gap = limit - start;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :             int32_t newDom = (dom + amount*7 - start) % gap;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :             if (newDom &lt; 0) </span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                 newDom += gap;</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :             newDom += start;</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            :             // Finally, pin to the real start and end of the month.
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :             if (newDom &lt; 1) </span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                 newDom = 1;</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :             if (newDom &gt; monthLen) </span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                 newDom = monthLen;</span>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :             // Set the DAY_OF_MONTH.  We rely on the fact that this field
<span class="lineNum">    1025 </span>            :             // takes precedence over everything else (since all other fields
<span class="lineNum">    1026 </span>            :             // are also set at this point).  If this fact changes (if the
<span class="lineNum">    1027 </span>            :             // disambiguation algorithm changes) then we will have to unset
<span class="lineNum">    1028 </span>            :             // the appropriate fields here so that DAY_OF_MONTH is attended
<span class="lineNum">    1029 </span>            :             // to.
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :             // If we are in the cutover month, manipulate ms directly.  Don't do
<span class="lineNum">    1032 </span>            :             // this in general because it doesn't work across DST boundaries
<span class="lineNum">    1033 </span>            :             // (details, details).  This takes care of the discontinuity.
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :             setTimeInMillis(cMonthStart + (newDom-1)*kOneDay, status);                </span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1036 </span>            :         }
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :     default:
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         Calendar::roll(field, amount, status);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1041 </span>            :     }
<span class="lineNum">    1042 </span>            : }
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : // -------------------------------------
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            : /**
<span class="lineNum">    1048 </span>            : * Return the minimum value that this field could have, given the current date.
<span class="lineNum">    1049 </span>            : * For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
<span class="lineNum">    1050 </span>            : * @param field    the time field.
<span class="lineNum">    1051 </span>            : * @return         the minimum value that this field could have, given the current date.
<a name="1052"><span class="lineNum">    1052 </span>            : * @deprecated ICU 2.6. Use getActualMinimum(UCalendarDateFields field) instead.</a>
<span class="lineNum">    1053 </span>            : */
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::getActualMinimum(EDateFields field) const</span>
<span class="lineNum">    1055 </span>            : {
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     return getMinimum((UCalendarDateFields)field);</span>
<a name="1057"><span class="lineNum">    1057 </span>            : }</a>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::getActualMinimum(EDateFields field, UErrorCode&amp; /* status */) const</span>
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     return getMinimum((UCalendarDateFields)field);</span>
<span class="lineNum">    1062 </span>            : }
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            : /**
<span class="lineNum">    1065 </span>            : * Return the minimum value that this field could have, given the current date.
<span class="lineNum">    1066 </span>            : * For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
<span class="lineNum">    1067 </span>            : * @param field    the time field.
<span class="lineNum">    1068 </span>            : * @return         the minimum value that this field could have, given the current date.
<a name="1069"><span class="lineNum">    1069 </span>            : * @draft ICU 2.6.</a>
<span class="lineNum">    1070 </span>            : */
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::getActualMinimum(UCalendarDateFields field, UErrorCode&amp; /* status */) const</span>
<span class="lineNum">    1072 </span>            : {
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     return getMinimum(field);</span>
<span class="lineNum">    1074 </span>            : }
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            : // ------------------------------------
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : /**
<span class="lineNum">    1080 </span>            : * Old year limits were least max 292269054, max 292278994.
<span class="lineNum">    1081 </span>            : */
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            : /**
<a name="1084"><span class="lineNum">    1084 </span>            : * @stable ICU 2.0</a>
<span class="lineNum">    1085 </span>            : */
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleGetLimit(UCalendarDateFields field, ELimitType limitType) const {</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     return kGregorianCalendarLimits[field][limitType];</span>
<span class="lineNum">    1088 </span>            : }
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : /**
<span class="lineNum">    1091 </span>            : * Return the maximum value that this field could have, given the current date.
<span class="lineNum">    1092 </span>            : * For example, with the date &quot;Feb 3, 1997&quot; and the DAY_OF_MONTH field, the actual
<span class="lineNum">    1093 </span>            : * maximum would be 28; for &quot;Feb 3, 1996&quot; it s 29.  Similarly for a Hebrew calendar,
<span class="lineNum">    1094 </span>            : * for some years the actual maximum for MONTH is 12, and for others 13.
<a name="1095"><span class="lineNum">    1095 </span>            : * @stable ICU 2.0</a>
<span class="lineNum">    1096 </span>            : */
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::getActualMaximum(UCalendarDateFields field, UErrorCode&amp; status) const</span>
<span class="lineNum">    1098 </span>            : {
<span class="lineNum">    1099 </span>            :     /* It is a known limitation that the code here (and in getActualMinimum)
<span class="lineNum">    1100 </span>            :     * won't behave properly at the extreme limits of GregorianCalendar's
<span class="lineNum">    1101 </span>            :     * representable range (except for the code that handles the YEAR
<span class="lineNum">    1102 </span>            :     * field).  That's because the ends of the representable range are at
<span class="lineNum">    1103 </span>            :     * odd spots in the year.  For calendars with the default Gregorian
<span class="lineNum">    1104 </span>            :     * cutover, these limits are Sun Dec 02 16:47:04 GMT 292269055 BC to Sun
<span class="lineNum">    1105 </span>            :     * Aug 17 07:12:55 GMT 292278994 AD, somewhat different for non-GMT
<span class="lineNum">    1106 </span>            :     * zones.  As a result, if the calendar is set to Aug 1 292278994 AD,
<span class="lineNum">    1107 </span>            :     * the actual maximum of DAY_OF_MONTH is 17, not 30.  If the date is Mar
<span class="lineNum">    1108 </span>            :     * 31 in that year, the actual maximum month might be Jul, whereas is
<span class="lineNum">    1109 </span>            :     * the date is Mar 15, the actual maximum might be Aug -- depending on
<span class="lineNum">    1110 </span>            :     * the precise semantics that are desired.  Similar considerations
<span class="lineNum">    1111 </span>            :     * affect all fields.  Nonetheless, this effect is sufficiently arcane
<span class="lineNum">    1112 </span>            :     * that we permit it, rather than complicating the code to handle such
<span class="lineNum">    1113 </span>            :     * intricacies. - liu 8/20/98
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :     * UPDATE: No longer true, since we have pulled in the limit values on
<span class="lineNum">    1116 </span>            :     * the year. - Liu 11/6/00 */
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     switch (field) {</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :     case UCAL_YEAR:
<span class="lineNum">    1121 </span>            :         /* The year computation is no different, in principle, from the
<span class="lineNum">    1122 </span>            :         * others, however, the range of possible maxima is large.  In
<span class="lineNum">    1123 </span>            :         * addition, the way we know we've exceeded the range is different.
<span class="lineNum">    1124 </span>            :         * For these reasons, we use the special case code below to handle
<span class="lineNum">    1125 </span>            :         * this field.
<span class="lineNum">    1126 </span>            :         *
<span class="lineNum">    1127 </span>            :         * The actual maxima for YEAR depend on the type of calendar:
<span class="lineNum">    1128 </span>            :         *
<span class="lineNum">    1129 </span>            :         *     Gregorian = May 17, 292275056 BC - Aug 17, 292278994 AD
<span class="lineNum">    1130 </span>            :         *     Julian    = Dec  2, 292269055 BC - Jan  3, 292272993 AD
<span class="lineNum">    1131 </span>            :         *     Hybrid    = Dec  2, 292269055 BC - Aug 17, 292278994 AD
<span class="lineNum">    1132 </span>            :         *
<span class="lineNum">    1133 </span>            :         * We know we've exceeded the maximum when either the month, date,
<span class="lineNum">    1134 </span>            :         * time, or era changes in response to setting the year.  We don't
<span class="lineNum">    1135 </span>            :         * check for month, date, and time here because the year and era are
<span class="lineNum">    1136 </span>            :         * sufficient to detect an invalid year setting.  NOTE: If code is
<span class="lineNum">    1137 </span>            :         * added to check the month and date in the future for some reason,
<span class="lineNum">    1138 </span>            :         * Feb 29 must be allowed to shift to Mar 1 when setting the year.
<span class="lineNum">    1139 </span>            :         */
<span class="lineNum">    1140 </span>            :         {
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :             if(U_FAILURE(status)) return 0;</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :             Calendar *cal = clone();</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :             if(!cal) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1146 </span>            :             }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :             cal-&gt;setLenient(TRUE);</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :             int32_t era = cal-&gt;get(UCAL_ERA, status);</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :             UDate d = cal-&gt;getTime(status);</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :             /* Perform a binary search, with the invariant that lowGood is a
<span class="lineNum">    1154 </span>            :             * valid year, and highBad is an out of range year.
<span class="lineNum">    1155 </span>            :             */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :             int32_t lowGood = kGregorianCalendarLimits[UCAL_YEAR][1];</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :             int32_t highBad = kGregorianCalendarLimits[UCAL_YEAR][2]+1;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :             while ((lowGood + 1) &lt; highBad) {</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                 int32_t y = (lowGood + highBad) / 2;</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :                 cal-&gt;set(UCAL_YEAR, y);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                 if (cal-&gt;get(UCAL_YEAR, status) == y &amp;&amp; cal-&gt;get(UCAL_ERA, status) == era) {</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                     lowGood = y;</span>
<span class="lineNum">    1163 </span>            :                 } else {
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :                     highBad = y;</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                     cal-&gt;setTime(d, status); // Restore original fields</span>
<span class="lineNum">    1166 </span>            :                 }
<span class="lineNum">    1167 </span>            :             }
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :             delete cal;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :             return lowGood;</span>
<span class="lineNum">    1171 </span>            :         }
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :     default:
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         return Calendar::getActualMaximum(field,status);</span>
<span class="lineNum">    1175 </span>            :     }
<span class="lineNum">    1176 </span>            : }
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleGetExtendedYear() {</span>
<span class="lineNum">    1180 </span>            :     // the year to return
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     int32_t year = kEpochYear;</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :     // year field to use
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :     int32_t yearField = UCAL_EXTENDED_YEAR;</span>
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            :     // There are three separate fields which could be used to
<span class="lineNum">    1187 </span>            :     // derive the proper year.  Use the one most recently set.
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :     if (fStamp[yearField] &lt; fStamp[UCAL_YEAR])</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         yearField = UCAL_YEAR;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     if (fStamp[yearField] &lt; fStamp[UCAL_YEAR_WOY])</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         yearField = UCAL_YEAR_WOY;</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :     // based on the &quot;best&quot; year field, get the year
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     switch(yearField) {</span>
<span class="lineNum">    1195 </span>            :     case UCAL_EXTENDED_YEAR:
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         year = internalGet(UCAL_EXTENDED_YEAR, kEpochYear);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            :     case UCAL_YEAR:
<span class="lineNum">    1200 </span>            :         {
<span class="lineNum">    1201 </span>            :             // The year defaults to the epoch start, the era to AD
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :             int32_t era = internalGet(UCAL_ERA, AD);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             if (era == BC) {</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                 year = 1 - internalGet(UCAL_YEAR, 1); // Convert to extended year</span>
<span class="lineNum">    1205 </span>            :             } else {
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                 year = internalGet(UCAL_YEAR, kEpochYear);</span>
<span class="lineNum">    1207 </span>            :             }
<span class="lineNum">    1208 </span>            :         }
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :     case UCAL_YEAR_WOY:
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :         year = handleGetExtendedYearFromWeekFields(internalGet(UCAL_YEAR_WOY), internalGet(UCAL_WEEK_OF_YEAR));</span>
<span class="lineNum">    1213 </span>            : #if defined (U_DEBUG_CAL)
<span class="lineNum">    1214 </span>            :         //    if(internalGet(UCAL_YEAR_WOY) != year) {
<span class="lineNum">    1215 </span>            :         fprintf(stderr, &quot;%s:%d: hGEYFWF[%d,%d] -&gt;  %d\n&quot;, 
<span class="lineNum">    1216 </span>            :             __FILE__, __LINE__,internalGet(UCAL_YEAR_WOY),internalGet(UCAL_WEEK_OF_YEAR),year);
<span class="lineNum">    1217 </span>            :         //}
<span class="lineNum">    1218 </span>            : #endif
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            :     default:
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         year = kEpochYear;</span>
<span class="lineNum">    1223 </span>            :     }
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     return year;</span>
<a name="1225"><span class="lineNum">    1225 </span>            : }</a>
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::handleGetExtendedYearFromWeekFields(int32_t yearWoy, int32_t woy)</span>
<span class="lineNum">    1228 </span>            : {
<span class="lineNum">    1229 </span>            :     // convert year to extended form
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     int32_t era = internalGet(UCAL_ERA, AD);</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     if(era == BC) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         yearWoy = 1 - yearWoy;</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     return Calendar::handleGetExtendedYearFromWeekFields(yearWoy, woy);</span>
<span class="lineNum">    1235 </span>            : }
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            : // -------------------------------------
<a name="1239"><span class="lineNum">    1239 </span>            : </a>
<span class="lineNum">    1240 </span>            : UBool
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 : GregorianCalendar::inDaylightTime(UErrorCode&amp; status) const</span>
<span class="lineNum">    1242 </span>            : {
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status) || !getTimeZone().useDaylightTime()) </span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         return FALSE;</span>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :     // Force an update of the state of the Calendar.
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     ((GregorianCalendar*)this)-&gt;complete(status); // cast away const</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);</span>
<span class="lineNum">    1250 </span>            : }
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            : // -------------------------------------
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : /**
<span class="lineNum">    1255 </span>            : * Return the ERA.  We need a special method for this because the
<span class="lineNum">    1256 </span>            : * default ERA is AD, but a zero (unset) ERA is BC.
<a name="1257"><span class="lineNum">    1257 </span>            : */</a>
<span class="lineNum">    1258 </span>            : int32_t
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 : GregorianCalendar::internalGetEra() const {</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     return isSet(UCAL_ERA) ? internalGet(UCAL_ERA) : (int32_t)AD;</span>
<span class="lineNum">    1261 </span>            : }
<a name="1262"><span class="lineNum">    1262 </span>            : </a>
<span class="lineNum">    1263 </span>            : const char *
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 : GregorianCalendar::getType() const {</span>
<span class="lineNum">    1265 </span>            :     //static const char kGregorianType = &quot;gregorian&quot;;
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     return &quot;gregorian&quot;;</span>
<span class="lineNum">    1268 </span>            : }
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            : /**
<span class="lineNum">    1271 </span>            :  * The system maintains a static default century start date and Year.  They are
<span class="lineNum">    1272 </span>            :  * initialized the first time they are used.  Once the system default century date 
<span class="lineNum">    1273 </span>            :  * and year are set, they do not change.
<span class="lineNum">    1274 </span>            :  */
<span class="lineNum">    1275 </span>            : static UDate           gSystemDefaultCenturyStart       = DBL_MIN;
<span class="lineNum">    1276 </span>            : static int32_t         gSystemDefaultCenturyStartYear   = -1;
<span class="lineNum">    1277 </span>            : static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 : UBool GregorianCalendar::haveDefaultCentury() const</span>
<span class="lineNum">    1281 </span>            : {
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">    1283 </span>            : }
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<span class="lineNum">    1285 </span>            : static void U_CALLCONV
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 : initializeSystemDefaultCentury()</span>
<span class="lineNum">    1287 </span>            : {
<span class="lineNum">    1288 </span>            :     // initialize systemDefaultCentury and systemDefaultCenturyYear based
<span class="lineNum">    1289 </span>            :     // on the current time.  They'll be set to 80 years before
<span class="lineNum">    1290 </span>            :     // the current time.
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     GregorianCalendar calendar(status);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     if (U_SUCCESS(status)) {</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :         calendar.setTime(Calendar::getNow(), status);</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         calendar.add(UCAL_YEAR, -80, status);</span>
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :         gSystemDefaultCenturyStart = calendar.getTime(status);</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :         gSystemDefaultCenturyStartYear = calendar.get(UCAL_YEAR, status);</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span>            :     // We have no recourse upon failure unless we want to propagate the failure
<span class="lineNum">    1301 </span>            :     // out.
<a name="1302"><span class="lineNum">    1302 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 : UDate GregorianCalendar::defaultCenturyStart() const {</span>
<span class="lineNum">    1305 </span>            :     // lazy-evaluate systemDefaultCenturyStart
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     umtx_initOnce(gSystemDefaultCenturyInit, &amp;initializeSystemDefaultCentury);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     return gSystemDefaultCenturyStart;</span>
<a name="1308"><span class="lineNum">    1308 </span>            : }</a>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 : int32_t GregorianCalendar::defaultCenturyStartYear() const {</span>
<span class="lineNum">    1311 </span>            :     // lazy-evaluate systemDefaultCenturyStartYear
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     umtx_initOnce(gSystemDefaultCenturyInit, &amp;initializeSystemDefaultCentury);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     return gSystemDefaultCenturyStartYear;</span>
<span class="lineNum">    1314 </span>            : }
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            : U_NAMESPACE_END
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            : #endif /* #if !UCONFIG_NO_FORMATTING */
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            : //eof
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

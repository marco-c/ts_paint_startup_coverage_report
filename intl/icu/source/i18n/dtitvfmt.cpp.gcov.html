<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - intl/icu/source/i18n/dtitvfmt.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">intl/icu/source/i18n</a> - dtitvfmt.cpp<span style="font-size: 80%;"> (source / <a href="dtitvfmt.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">648</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">40</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Â© 2016 and later: Unicode, Inc. and others.</a>
<span class="lineNum">       2 </span>            : // License &amp; terms of use: http://www.unicode.org/copyright.html
<span class="lineNum">       3 </span>            : /*******************************************************************************
<span class="lineNum">       4 </span>            : * Copyright (C) 2008-2016, International Business Machines Corporation and
<span class="lineNum">       5 </span>            : * others. All Rights Reserved.
<span class="lineNum">       6 </span>            : *******************************************************************************
<span class="lineNum">       7 </span>            : *
<span class="lineNum">       8 </span>            : * File DTITVFMT.CPP
<span class="lineNum">       9 </span>            : *
<span class="lineNum">      10 </span>            : *******************************************************************************
<span class="lineNum">      11 </span>            : */
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;utypeinfo.h&quot;  // for 'typeid' to work
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;unicode/dtitvfmt.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #if !UCONFIG_NO_FORMATTING
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : //TODO: put in compilation
<span class="lineNum">      20 </span>            : //#define DTITVFMT_DEBUG 1
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;unicode/calendar.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;unicode/dtptngen.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;unicode/dtitvinf.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;unicode/simpleformatter.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;cmemory.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;cstring.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;dtitv_impl.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;mutex.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;uresimp.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #ifdef DTITVFMT_DEBUG
<span class="lineNum">      33 </span>            : #include &lt;iostream&gt;
<span class="lineNum">      34 </span>            : #endif
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : U_NAMESPACE_BEGIN
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #ifdef DTITVFMT_DEBUG
<span class="lineNum">      41 </span>            : #define PRINTMESG(msg) { std::cout &lt;&lt; &quot;(&quot; &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;) &quot; &lt;&lt; msg &lt;&lt; &quot;\n&quot;; }
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : static const UChar gDateFormatSkeleton[][11] = {
<span class="lineNum">      46 </span>            : //yMMMMEEEEd
<span class="lineNum">      47 </span>            : {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, CAP_E, CAP_E, CAP_E, CAP_E, LOW_D, 0},
<span class="lineNum">      48 </span>            : //yMMMMd
<span class="lineNum">      49 </span>            : {LOW_Y, CAP_M, CAP_M, CAP_M, CAP_M, LOW_D, 0},
<span class="lineNum">      50 </span>            : //yMMMd
<span class="lineNum">      51 </span>            : {LOW_Y, CAP_M, CAP_M, CAP_M, LOW_D, 0},
<span class="lineNum">      52 </span>            : //yMd
<span class="lineNum">      53 </span>            : {LOW_Y, CAP_M, LOW_D, 0} };
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : static const char gCalendarTag[] = &quot;calendar&quot;;
<span class="lineNum">      57 </span>            : static const char gGregorianTag[] = &quot;gregorian&quot;;
<span class="lineNum">      58 </span>            : static const char gDateTimePatternsTag[] = &quot;DateTimePatterns&quot;;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : // latestFirst:
<span class="lineNum">      62 </span>            : static const UChar gLaterFirstPrefix[] = {LOW_L, LOW_A, LOW_T, LOW_E, LOW_S,LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : // earliestFirst:
<span class="lineNum">      65 </span>            : static const UChar gEarlierFirstPrefix[] = {LOW_E, LOW_A, LOW_R, LOW_L, LOW_I, LOW_E, LOW_S, LOW_T, CAP_F, LOW_I, LOW_R, LOW_S, LOW_T, COLON};
<a name="66"><span class="lineNum">      66 </span>            : </a>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineNoCov">          0 : UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
<span class="lineNum">      71 </span>            : //        Needed because these data members are modified by const methods of DateIntervalFormat.
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : static UMutex gFormatterMutex = U_MUTEX_INITIALIZER;
<a name="74"><span class="lineNum">      74 </span>            : </a>
<span class="lineNum">      75 </span>            : DateIntervalFormat* U_EXPORT2
<span class="lineNum">      76 </span><span class="lineNoCov">          0 : DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,</span>
<span class="lineNum">      77 </span>            :                                    UErrorCode&amp; status) {
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :     return createInstance(skeleton, Locale::getDefault(), status);</span>
<span class="lineNum">      79 </span>            : }
<span class="lineNum">      80 </span>            : 
<a name="81"><span class="lineNum">      81 </span>            : </a>
<span class="lineNum">      82 </span>            : DateIntervalFormat* U_EXPORT2
<span class="lineNum">      83 </span><span class="lineNoCov">          0 : DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,</span>
<span class="lineNum">      84 </span>            :                                    const Locale&amp; locale,
<span class="lineNum">      85 </span>            :                                    UErrorCode&amp; status) {
<span class="lineNum">      86 </span>            : #ifdef DTITVFMT_DEBUG
<span class="lineNum">      87 </span>            :     char result[1000];
<span class="lineNum">      88 </span>            :     char result_1[1000];
<span class="lineNum">      89 </span>            :     char mesg[2000];
<span class="lineNum">      90 </span>            :     skeleton.extract(0,  skeleton.length(), result, &quot;UTF-8&quot;);
<span class="lineNum">      91 </span>            :     UnicodeString pat;
<span class="lineNum">      92 </span>            :     ((SimpleDateFormat*)dtfmt)-&gt;toPattern(pat);
<span class="lineNum">      93 </span>            :     pat.extract(0,  pat.length(), result_1, &quot;UTF-8&quot;);
<span class="lineNum">      94 </span>            :     sprintf(mesg, &quot;skeleton: %s; pattern: %s\n&quot;, result, result_1);
<span class="lineNum">      95 </span>            :     PRINTMESG(mesg)
<span class="lineNum">      96 </span>            : #endif
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     DateIntervalInfo* dtitvinf = new DateIntervalInfo(locale, status);</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     return create(locale, dtitvinf, &amp;skeleton, status);</span>
<span class="lineNum">     100 </span>            : }
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : 
<a name="103"><span class="lineNum">     103 </span>            : </a>
<span class="lineNum">     104 </span>            : DateIntervalFormat* U_EXPORT2
<span class="lineNum">     105 </span><span class="lineNoCov">          0 : DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,</span>
<span class="lineNum">     106 </span>            :                                    const DateIntervalInfo&amp; dtitvinf,
<span class="lineNum">     107 </span>            :                                    UErrorCode&amp; status) {
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     return createInstance(skeleton, Locale::getDefault(), dtitvinf, status);</span>
<span class="lineNum">     109 </span>            : }
<span class="lineNum">     110 </span>            : 
<a name="111"><span class="lineNum">     111 </span>            : </a>
<span class="lineNum">     112 </span>            : DateIntervalFormat* U_EXPORT2
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : DateIntervalFormat::createInstance(const UnicodeString&amp; skeleton,</span>
<span class="lineNum">     114 </span>            :                                    const Locale&amp; locale,
<span class="lineNum">     115 </span>            :                                    const DateIntervalInfo&amp; dtitvinf,
<span class="lineNum">     116 </span>            :                                    UErrorCode&amp; status) {
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     DateIntervalInfo* ptn = dtitvinf.clone();</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :     return create(locale, ptn, &amp;skeleton, status);</span>
<span class="lineNum">     119 </span>            : }
<a name="120"><span class="lineNum">     120 </span>            : </a>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 : DateIntervalFormat::DateIntervalFormat()</span>
<span class="lineNum">     123 </span>            : :   fInfo(NULL),
<span class="lineNum">     124 </span>            :     fDateFormat(NULL),
<span class="lineNum">     125 </span>            :     fFromCalendar(NULL),
<span class="lineNum">     126 </span>            :     fToCalendar(NULL),
<span class="lineNum">     127 </span>            :     fLocale(Locale::getRoot()),
<span class="lineNum">     128 </span>            :     fDatePattern(NULL),
<span class="lineNum">     129 </span>            :     fTimePattern(NULL),
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     fDateTimeFormat(NULL)</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 : {}</span>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 : DateIntervalFormat::DateIntervalFormat(const DateIntervalFormat&amp; itvfmt)</span>
<span class="lineNum">     135 </span>            : :   Format(itvfmt),
<span class="lineNum">     136 </span>            :     fInfo(NULL),
<span class="lineNum">     137 </span>            :     fDateFormat(NULL),
<span class="lineNum">     138 </span>            :     fFromCalendar(NULL),
<span class="lineNum">     139 </span>            :     fToCalendar(NULL),
<span class="lineNum">     140 </span>            :     fLocale(itvfmt.fLocale),
<span class="lineNum">     141 </span>            :     fDatePattern(NULL),
<span class="lineNum">     142 </span>            :     fTimePattern(NULL),
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     fDateTimeFormat(NULL) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     *this = itvfmt;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     146 </span>            : 
<a name="147"><span class="lineNum">     147 </span>            : </a>
<span class="lineNum">     148 </span>            : DateIntervalFormat&amp;
<span class="lineNum">     149 </span><span class="lineNoCov">          0 : DateIntervalFormat::operator=(const DateIntervalFormat&amp; itvfmt) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     if ( this != &amp;itvfmt ) {</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         delete fDateFormat;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         delete fInfo;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :         delete fFromCalendar;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         delete fToCalendar;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         delete fDatePattern;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         delete fTimePattern;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         delete fDateTimeFormat;</span>
<span class="lineNum">     158 </span>            :         {
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :             Mutex lock(&amp;gFormatterMutex);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :             if ( itvfmt.fDateFormat ) {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                 fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat-&gt;clone();</span>
<span class="lineNum">     162 </span>            :             } else {
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                 fDateFormat = NULL;</span>
<span class="lineNum">     164 </span>            :             }
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :             if ( itvfmt.fFromCalendar ) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :                 fFromCalendar = itvfmt.fFromCalendar-&gt;clone();</span>
<span class="lineNum">     167 </span>            :             } else {
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :                 fFromCalendar = NULL;</span>
<span class="lineNum">     169 </span>            :             }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :             if ( itvfmt.fToCalendar ) {</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 fToCalendar = itvfmt.fToCalendar-&gt;clone();</span>
<span class="lineNum">     172 </span>            :             } else {
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :                 fToCalendar = NULL;</span>
<span class="lineNum">     174 </span>            :             }
<span class="lineNum">     175 </span>            :         }
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         if ( itvfmt.fInfo ) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :             fInfo = itvfmt.fInfo-&gt;clone();</span>
<span class="lineNum">     178 </span>            :         } else {
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :             fInfo = NULL;</span>
<span class="lineNum">     180 </span>            :         }
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         fSkeleton = itvfmt.fSkeleton;</span>
<span class="lineNum">     182 </span>            :         int8_t i;
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         for ( i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :             fIntervalPatterns[i] = itvfmt.fIntervalPatterns[i];</span>
<span class="lineNum">     185 </span>            :         }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :         fLocale = itvfmt.fLocale;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         fDatePattern    = (itvfmt.fDatePattern)?    (UnicodeString*)itvfmt.fDatePattern-&gt;clone(): NULL;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         fTimePattern    = (itvfmt.fTimePattern)?    (UnicodeString*)itvfmt.fTimePattern-&gt;clone(): NULL;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         fDateTimeFormat = (itvfmt.fDateTimeFormat)? (UnicodeString*)itvfmt.fDateTimeFormat-&gt;clone(): NULL;</span>
<span class="lineNum">     190 </span>            :     }
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     192 </span>            : }
<a name="193"><span class="lineNum">     193 </span>            : </a>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 : DateIntervalFormat::~DateIntervalFormat() {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     delete fInfo;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     delete fDateFormat;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     delete fFromCalendar;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     delete fToCalendar;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     delete fDatePattern;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     delete fTimePattern;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     delete fDateTimeFormat;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     204 </span>            : 
<a name="205"><span class="lineNum">     205 </span>            : </a>
<span class="lineNum">     206 </span>            : Format*
<span class="lineNum">     207 </span><span class="lineNoCov">          0 : DateIntervalFormat::clone(void) const {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     return new DateIntervalFormat(*this);</span>
<span class="lineNum">     209 </span>            : }
<span class="lineNum">     210 </span>            : 
<a name="211"><span class="lineNum">     211 </span>            : </a>
<span class="lineNum">     212 </span>            : UBool
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : DateIntervalFormat::operator==(const Format&amp; other) const {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     if (typeid(*this) != typeid(other)) {return FALSE;}</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     const DateIntervalFormat* fmt = (DateIntervalFormat*)&amp;other;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     if (this == fmt) {return TRUE;}</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     if (!Format::operator==(other)) {return FALSE;}</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     if ((fInfo != fmt-&gt;fInfo) &amp;&amp; (fInfo == NULL || fmt-&gt;fInfo == NULL)) {return FALSE;}</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     if (fInfo &amp;&amp; fmt-&gt;fInfo &amp;&amp; (*fInfo != *fmt-&gt;fInfo )) {return FALSE;}</span>
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         Mutex lock(&amp;gFormatterMutex);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         if (fDateFormat != fmt-&gt;fDateFormat &amp;&amp; (fDateFormat == NULL || fmt-&gt;fDateFormat == NULL)) {return FALSE;}</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         if (fDateFormat &amp;&amp; fmt-&gt;fDateFormat &amp;&amp; (*fDateFormat != *fmt-&gt;fDateFormat)) {return FALSE;}</span>
<span class="lineNum">     224 </span>            :     }
<span class="lineNum">     225 </span>            :     // note: fFromCalendar and fToCalendar hold no persistent state, and therefore do not participate in operator ==.
<span class="lineNum">     226 </span>            :     //       fDateFormat has the master calendar for the DateIntervalFormat.
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     if (fSkeleton != fmt-&gt;fSkeleton) {return FALSE;}</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     if (fDatePattern != fmt-&gt;fDatePattern &amp;&amp; (fDatePattern == NULL || fmt-&gt;fDatePattern == NULL)) {return FALSE;}</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     if (fDatePattern &amp;&amp; fmt-&gt;fDatePattern &amp;&amp; (*fDatePattern != *fmt-&gt;fDatePattern)) {return FALSE;}</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     if (fTimePattern != fmt-&gt;fTimePattern &amp;&amp; (fTimePattern == NULL || fmt-&gt;fTimePattern == NULL)) {return FALSE;}</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     if (fTimePattern &amp;&amp; fmt-&gt;fTimePattern &amp;&amp; (*fTimePattern != *fmt-&gt;fTimePattern)) {return FALSE;}</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (fDateTimeFormat != fmt-&gt;fDateTimeFormat &amp;&amp; (fDateTimeFormat == NULL || fmt-&gt;fDateTimeFormat == NULL)) {return FALSE;}</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     if (fDateTimeFormat &amp;&amp; fmt-&gt;fDateTimeFormat &amp;&amp; (*fDateTimeFormat != *fmt-&gt;fDateTimeFormat)) {return FALSE;}</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     if (fLocale != fmt-&gt;fLocale) {return FALSE;}</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     for (int32_t i = 0; i&lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         if (fIntervalPatterns[i].firstPart != fmt-&gt;fIntervalPatterns[i].firstPart) {return FALSE;}</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         if (fIntervalPatterns[i].secondPart != fmt-&gt;fIntervalPatterns[i].secondPart ) {return FALSE;}</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         if (fIntervalPatterns[i].laterDateFirst != fmt-&gt;fIntervalPatterns[i].laterDateFirst) {return FALSE;}</span>
<span class="lineNum">     240 </span>            :     }
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     return TRUE;</span>
<span class="lineNum">     242 </span>            : }
<span class="lineNum">     243 </span>            : 
<a name="244"><span class="lineNum">     244 </span>            : </a>
<span class="lineNum">     245 </span>            : UnicodeString&amp;
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : DateIntervalFormat::format(const Formattable&amp; obj,</span>
<span class="lineNum">     247 </span>            :                            UnicodeString&amp; appendTo,
<span class="lineNum">     248 </span>            :                            FieldPosition&amp; fieldPosition,
<span class="lineNum">     249 </span>            :                            UErrorCode&amp; status) const {
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     252 </span>            :     }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     if ( obj.getType() == Formattable::kObject ) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         const UObject* formatObj = obj.getObject();</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         const DateInterval* interval = dynamic_cast&lt;const DateInterval*&gt;(formatObj);</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         if (interval != NULL) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             return format(interval, appendTo, fieldPosition, status);</span>
<span class="lineNum">     259 </span>            :         }
<span class="lineNum">     260 </span>            :     }
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     return appendTo;</span>
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<a name="265"><span class="lineNum">     265 </span>            : </a>
<span class="lineNum">     266 </span>            : UnicodeString&amp;
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : DateIntervalFormat::format(const DateInterval* dtInterval,</span>
<span class="lineNum">     268 </span>            :                            UnicodeString&amp; appendTo,
<span class="lineNum">     269 </span>            :                            FieldPosition&amp; fieldPosition,
<span class="lineNum">     270 </span>            :                            UErrorCode&amp; status) const {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     273 </span>            :     }
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     if (fFromCalendar == NULL || fToCalendar == NULL || fDateFormat == NULL || fInfo == NULL) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         status = U_INVALID_STATE_ERROR;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     277 </span>            :     }
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     Mutex lock(&amp;gFormatterMutex);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     fFromCalendar-&gt;setTime(dtInterval-&gt;getFromDate(), status);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     fToCalendar-&gt;setTime(dtInterval-&gt;getToDate(), status);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     return formatImpl(*fFromCalendar, *fToCalendar, appendTo,fieldPosition, status);</span>
<span class="lineNum">     283 </span>            : }
<span class="lineNum">     284 </span>            : 
<a name="285"><span class="lineNum">     285 </span>            : </a>
<span class="lineNum">     286 </span>            : UnicodeString&amp;
<span class="lineNum">     287 </span><span class="lineNoCov">          0 : DateIntervalFormat::format(Calendar&amp; fromCalendar,</span>
<span class="lineNum">     288 </span>            :                            Calendar&amp; toCalendar,
<span class="lineNum">     289 </span>            :                            UnicodeString&amp; appendTo,
<span class="lineNum">     290 </span>            :                            FieldPosition&amp; pos,
<span class="lineNum">     291 </span>            :                            UErrorCode&amp; status) const {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     Mutex lock(&amp;gFormatterMutex);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     return formatImpl(fromCalendar, toCalendar, appendTo, pos, status);</span>
<span class="lineNum">     294 </span>            : }
<span class="lineNum">     295 </span>            : 
<a name="296"><span class="lineNum">     296 </span>            : </a>
<span class="lineNum">     297 </span>            : UnicodeString&amp;
<span class="lineNum">     298 </span><span class="lineNoCov">          0 : DateIntervalFormat::formatImpl(Calendar&amp; fromCalendar,</span>
<span class="lineNum">     299 </span>            :                            Calendar&amp; toCalendar,
<span class="lineNum">     300 </span>            :                            UnicodeString&amp; appendTo,
<span class="lineNum">     301 </span>            :                            FieldPosition&amp; pos,
<span class="lineNum">     302 </span>            :                            UErrorCode&amp; status) const {
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     305 </span>            :     }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     // not support different calendar types and time zones
<span class="lineNum">     308 </span>            :     //if ( fromCalendar.getType() != toCalendar.getType() ) {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     if ( !fromCalendar.isEquivalentTo(toCalendar) ) {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         status = U_ILLEGAL_ARGUMENT_ERROR;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     312 </span>            :     }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     // First, find the largest different calendar field.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     UCalendarDateFields field = UCAL_FIELD_COUNT;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     if ( fromCalendar.get(UCAL_ERA,status) != toCalendar.get(UCAL_ERA,status)) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         field = UCAL_ERA;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_YEAR, status) !=</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_YEAR, status) ) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         field = UCAL_YEAR;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_MONTH, status) !=</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_MONTH, status) ) {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         field = UCAL_MONTH;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_DATE, status) !=</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_DATE, status) ) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         field = UCAL_DATE;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_AM_PM, status) !=</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_AM_PM, status) ) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         field = UCAL_AM_PM;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_HOUR, status) !=</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_HOUR, status) ) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         field = UCAL_HOUR;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_MINUTE, status) !=</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_MINUTE, status) ) {</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         field = UCAL_MINUTE;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     } else if ( fromCalendar.get(UCAL_SECOND, status) !=</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                 toCalendar.get(UCAL_SECOND, status) ) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         field = UCAL_SECOND;</span>
<span class="lineNum">     340 </span>            :     }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     344 </span>            :     }
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     if ( field == UCAL_FIELD_COUNT ) {</span>
<span class="lineNum">     346 </span>            :         /* ignore the millisecond etc. small fields' difference.
<span class="lineNum">     347 </span>            :          * use single date when all the above are the same.
<span class="lineNum">     348 </span>            :          */
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     UBool fromToOnSameDay = (field==UCAL_AM_PM || field==UCAL_HOUR || field==UCAL_MINUTE || field==UCAL_SECOND);</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :     // following call should not set wrong status,
<span class="lineNum">     354 </span>            :     // all the pass-in fields are valid till here
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                                                                         status);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     const PatternInfo&amp; intervalPattern = fIntervalPatterns[itvPtnIndex];</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if ( intervalPattern.firstPart.isEmpty() &amp;&amp;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :          intervalPattern.secondPart.isEmpty() ) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         if ( fDateFormat-&gt;isFieldUnitIgnored(field) ) {</span>
<span class="lineNum">     362 </span>            :             /* the largest different calendar field is small than
<span class="lineNum">     363 </span>            :              * the smallest calendar field in pattern,
<span class="lineNum">     364 </span>            :              * return single date format.
<span class="lineNum">     365 </span>            :              */
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :             return fDateFormat-&gt;format(fromCalendar, appendTo, pos);</span>
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         return fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            :     // If the first part in interval pattern is empty,
<span class="lineNum">     371 </span>            :     // the 2nd part of it saves the full-pattern used in fall-back.
<span class="lineNum">     372 </span>            :     // For a 'real' interval pattern, the first part will never be empty.
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     if ( intervalPattern.firstPart.isEmpty() ) {</span>
<span class="lineNum">     374 </span>            :         // fall back
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         UnicodeString originalPattern;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;toPattern(originalPattern);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         appendTo = fallbackFormat(fromCalendar, toCalendar, fromToOnSameDay, appendTo, pos, status);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(originalPattern);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span>            :     Calendar* firstCal;
<span class="lineNum">     383 </span>            :     Calendar* secondCal;
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     if ( intervalPattern.laterDateFirst ) {</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         firstCal = &amp;toCalendar;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         secondCal = &amp;fromCalendar;</span>
<span class="lineNum">     387 </span>            :     } else {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         firstCal = &amp;fromCalendar;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         secondCal = &amp;toCalendar;</span>
<span class="lineNum">     390 </span>            :     }
<span class="lineNum">     391 </span>            :     // break the interval pattern into 2 parts,
<span class="lineNum">     392 </span>            :     // first part should not be empty,
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     UnicodeString originalPattern;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;toPattern(originalPattern);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;applyPattern(intervalPattern.firstPart);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;format(*firstCal, appendTo, pos);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     if ( !intervalPattern.secondPart.isEmpty() ) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(intervalPattern.secondPart);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         FieldPosition otherPos;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         otherPos.setField(pos.getField());</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;format(*secondCal, appendTo, otherPos);</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         if (pos.getEndIndex() == 0 &amp;&amp; otherPos.getEndIndex() &gt; 0) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             pos = otherPos;</span>
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span>            :     }
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;applyPattern(originalPattern);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     return appendTo;</span>
<span class="lineNum">     408 </span>            : }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : 
<a name="411"><span class="lineNum">     411 </span>            : </a>
<span class="lineNum">     412 </span>            : void
<span class="lineNum">     413 </span><span class="lineNoCov">          0 : DateIntervalFormat::parseObject(const UnicodeString&amp; /* source */,</span>
<span class="lineNum">     414 </span>            :                                 Formattable&amp; /* result */,
<span class="lineNum">     415 </span>            :                                 ParsePosition&amp; /* parse_pos */) const {
<span class="lineNum">     416 </span>            :     // parseObject(const UnicodeString&amp;, Formattable&amp;, UErrorCode&amp;) const
<span class="lineNum">     417 </span>            :     // will set status as U_INVALID_FORMAT_ERROR if
<span class="lineNum">     418 </span>            :     // parse_pos is still 0
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : 
<a name="423"><span class="lineNum">     423 </span>            : </a>
<span class="lineNum">     424 </span>            : const DateIntervalInfo*
<span class="lineNum">     425 </span><span class="lineNoCov">          0 : DateIntervalFormat::getDateIntervalInfo() const {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     return fInfo;</span>
<span class="lineNum">     427 </span>            : }
<span class="lineNum">     428 </span>            : 
<a name="429"><span class="lineNum">     429 </span>            : </a>
<span class="lineNum">     430 </span>            : void
<span class="lineNum">     431 </span><span class="lineNoCov">          0 : DateIntervalFormat::setDateIntervalInfo(const DateIntervalInfo&amp; newItvPattern,</span>
<span class="lineNum">     432 </span>            :                                         UErrorCode&amp; status) {
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     delete fInfo;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     fInfo = new DateIntervalInfo(newItvPattern);</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :     // Delete patterns that get reset by initializePattern
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     delete fDatePattern;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     fDatePattern = NULL;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     delete fTimePattern;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     fTimePattern = NULL;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     delete fDateTimeFormat;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     fDateTimeFormat = NULL;</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     if (fDateFormat) {</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         initializePattern(status);</span>
<span class="lineNum">     446 </span>            :     }
<span class="lineNum">     447 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : 
<a name="450"><span class="lineNum">     450 </span>            : </a>
<span class="lineNum">     451 </span>            : const DateFormat*
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : DateIntervalFormat::getDateFormat() const {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     return fDateFormat;</span>
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<a name="456"><span class="lineNum">     456 </span>            : </a>
<span class="lineNum">     457 </span>            : void
<span class="lineNum">     458 </span><span class="lineNoCov">          0 : DateIntervalFormat::adoptTimeZone(TimeZone* zone)</span>
<span class="lineNum">     459 </span>            : {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     if (fDateFormat != NULL) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;adoptTimeZone(zone);</span>
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            :     // The fDateFormat has the master calendar for the DateIntervalFormat and has
<span class="lineNum">     464 </span>            :     // ownership of any adopted TimeZone; fFromCalendar and fToCalendar are internal
<span class="lineNum">     465 </span>            :     // work clones of that calendar (and should not also be given ownership of the
<span class="lineNum">     466 </span>            :     // adopted TimeZone).
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     if (fFromCalendar) {</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         fFromCalendar-&gt;setTimeZone(*zone);</span>
<span class="lineNum">     469 </span>            :     }
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     if (fToCalendar) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         fToCalendar-&gt;setTimeZone(*zone);</span>
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : }</span>
<a name="474"><span class="lineNum">     474 </span>            : </a>
<span class="lineNum">     475 </span>            : void
<span class="lineNum">     476 </span><span class="lineNoCov">          0 : DateIntervalFormat::setTimeZone(const TimeZone&amp; zone)</span>
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     if (fDateFormat != NULL) {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;setTimeZone(zone);</span>
<span class="lineNum">     480 </span>            :     }
<span class="lineNum">     481 </span>            :     // The fDateFormat has the master calendar for the DateIntervalFormat;
<span class="lineNum">     482 </span>            :     // fFromCalendar and fToCalendar are internal work clones of that calendar.
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     if (fFromCalendar) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         fFromCalendar-&gt;setTimeZone(zone);</span>
<span class="lineNum">     485 </span>            :     }
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     if (fToCalendar) {</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         fToCalendar-&gt;setTimeZone(zone);</span>
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span><span class="lineNoCov">          0 : }</span>
<a name="490"><span class="lineNum">     490 </span>            : </a>
<span class="lineNum">     491 </span>            : const TimeZone&amp;
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : DateIntervalFormat::getTimeZone() const</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     if (fDateFormat != NULL) {</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         Mutex lock(&amp;gFormatterMutex);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         return fDateFormat-&gt;getTimeZone();</span>
<span class="lineNum">     497 </span>            :     }
<span class="lineNum">     498 </span>            :     // If fDateFormat is NULL (unexpected), create default timezone.
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     return *(TimeZone::createDefault());</span>
<a name="500"><span class="lineNum">     500 </span>            : }</a>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : DateIntervalFormat::DateIntervalFormat(const Locale&amp; locale,</span>
<span class="lineNum">     503 </span>            :                                        DateIntervalInfo* dtItvInfo,
<span class="lineNum">     504 </span>            :                                        const UnicodeString* skeleton,
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                                        UErrorCode&amp; status)</span>
<span class="lineNum">     506 </span>            : :   fInfo(NULL),
<span class="lineNum">     507 </span>            :     fDateFormat(NULL),
<span class="lineNum">     508 </span>            :     fFromCalendar(NULL),
<span class="lineNum">     509 </span>            :     fToCalendar(NULL),
<span class="lineNum">     510 </span>            :     fLocale(locale),
<span class="lineNum">     511 </span>            :     fDatePattern(NULL),
<span class="lineNum">     512 </span>            :     fTimePattern(NULL),
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     fDateTimeFormat(NULL)</span>
<span class="lineNum">     514 </span>            : {
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     LocalPointer&lt;DateIntervalInfo&gt; info(dtItvInfo, status);</span>
<span class="lineNum">     516 </span>            :     LocalPointer&lt;SimpleDateFormat&gt; dtfmt(static_cast&lt;SimpleDateFormat *&gt;(
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :             DateFormat::createInstanceForSkeleton(*skeleton, locale, status)), status);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     if (U_FAILURE(status)) {</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     520 </span>            :     }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     if ( skeleton ) {</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         fSkeleton = *skeleton;</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     fInfo = info.orphan();</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     fDateFormat = dtfmt.orphan();</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     if ( fDateFormat-&gt;getCalendar() ) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         fFromCalendar = fDateFormat-&gt;getCalendar()-&gt;clone();</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         fToCalendar = fDateFormat-&gt;getCalendar()-&gt;clone();</span>
<span class="lineNum">     530 </span>            :     }
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     initializePattern(status);</span>
<span class="lineNum">     532 </span>            : }
<a name="533"><span class="lineNum">     533 </span>            : </a>
<span class="lineNum">     534 </span>            : DateIntervalFormat* U_EXPORT2
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : DateIntervalFormat::create(const Locale&amp; locale,</span>
<span class="lineNum">     536 </span>            :                            DateIntervalInfo* dtitvinf,
<span class="lineNum">     537 </span>            :                            const UnicodeString* skeleton,
<span class="lineNum">     538 </span>            :                            UErrorCode&amp; status) {
<span class="lineNum">     539 </span>            :     DateIntervalFormat* f = new DateIntervalFormat(locale, dtitvinf,
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                                                    skeleton, status);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     if ( f == NULL ) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         status = U_MEMORY_ALLOCATION_ERROR;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         delete dtitvinf;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     } else if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     545 </span>            :         // safe to delete f, although nothing acutally is saved
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         delete f;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         f = 0;</span>
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     return f;</span>
<span class="lineNum">     550 </span>            : }
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : /**
<span class="lineNum">     555 </span>            :  * Initialize interval patterns locale to this formatter
<span class="lineNum">     556 </span>            :  *
<span class="lineNum">     557 </span>            :  * This code is a bit complicated since
<span class="lineNum">     558 </span>            :  * 1. the interval patterns saved in resource bundle files are interval
<span class="lineNum">     559 </span>            :  *    patterns based on date or time only.
<span class="lineNum">     560 </span>            :  *    It does not have interval patterns based on both date and time.
<span class="lineNum">     561 </span>            :  *    Interval patterns on both date and time are algorithm generated.
<span class="lineNum">     562 </span>            :  *
<span class="lineNum">     563 </span>            :  *    For example, it has interval patterns on skeleton &quot;dMy&quot; and &quot;hm&quot;,
<span class="lineNum">     564 </span>            :  *    but it does not have interval patterns on skeleton &quot;dMyhm&quot;.
<span class="lineNum">     565 </span>            :  *
<span class="lineNum">     566 </span>            :  *    The rule to genearte interval patterns for both date and time skeleton are
<span class="lineNum">     567 </span>            :  *    1) when the year, month, or day differs, concatenate the two original
<span class="lineNum">     568 </span>            :  *    expressions with a separator between,
<span class="lineNum">     569 </span>            :  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
<span class="lineNum">     570 </span>            :  *    to &quot;Jan 11, 2007 10:10am&quot; is
<span class="lineNum">     571 </span>            :  *    &quot;Jan 10, 2007 10:10 am - Jan 11, 2007 10:10am&quot;
<span class="lineNum">     572 </span>            :  *
<span class="lineNum">     573 </span>            :  *    2) otherwise, present the date followed by the range expression
<span class="lineNum">     574 </span>            :  *    for the time.
<span class="lineNum">     575 </span>            :  *    For example, interval pattern from &quot;Jan 10, 2007 10:10 am&quot;
<span class="lineNum">     576 </span>            :  *    to &quot;Jan 10, 2007 11:10am&quot; is
<span class="lineNum">     577 </span>            :  *    &quot;Jan 10, 2007 10:10 am - 11:10am&quot;
<span class="lineNum">     578 </span>            :  *
<span class="lineNum">     579 </span>            :  * 2. even a pattern does not request a certion calendar field,
<span class="lineNum">     580 </span>            :  *    the interval pattern needs to include such field if such fields are
<span class="lineNum">     581 </span>            :  *    different between 2 dates.
<span class="lineNum">     582 </span>            :  *    For example, a pattern/skeleton is &quot;hm&quot;, but the interval pattern
<span class="lineNum">     583 </span>            :  *    includes year, month, and date when year, month, and date differs.
<span class="lineNum">     584 </span>            :  *
<span class="lineNum">     585 </span>            :  * @param status          output param set to success/failure code on exit
<span class="lineNum">     586 </span>            :  * @stable ICU 4.0
<a name="587"><span class="lineNum">     587 </span>            :  */</a>
<span class="lineNum">     588 </span>            : void
<span class="lineNum">     589 </span><span class="lineNoCov">          0 : DateIntervalFormat::initializePattern(UErrorCode&amp; status) {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     592 </span>            :     }
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     const Locale&amp; locale = fDateFormat-&gt;getSmpFmtLocale();</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     if ( fSkeleton.isEmpty() ) {</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         UnicodeString fullPattern;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;toPattern(fullPattern);</span>
<span class="lineNum">     597 </span>            : #ifdef DTITVFMT_DEBUG
<span class="lineNum">     598 </span>            :     char result[1000];
<span class="lineNum">     599 </span>            :     char result_1[1000];
<span class="lineNum">     600 </span>            :     char mesg[2000];
<span class="lineNum">     601 </span>            :     fSkeleton.extract(0,  fSkeleton.length(), result, &quot;UTF-8&quot;);
<span class="lineNum">     602 </span>            :     sprintf(mesg, &quot;in getBestSkeleton: fSkeleton: %s; \n&quot;, result);
<span class="lineNum">     603 </span>            :     PRINTMESG(mesg)
<span class="lineNum">     604 </span>            : #endif
<span class="lineNum">     605 </span>            :         // fSkeleton is already set by createDateIntervalInstance()
<span class="lineNum">     606 </span>            :         // or by createInstance(UnicodeString skeleton, .... )
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         fSkeleton = DateTimePatternGenerator::staticGetSkeleton(</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                 fullPattern, status);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :         if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     611 </span>            :         }
<span class="lineNum">     612 </span>            :     }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :     // initialize the fIntervalPattern ordering
<span class="lineNum">     615 </span>            :     int8_t i;
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     for ( i = 0; i &lt; DateIntervalInfo::kIPI_MAX_INDEX; ++i ) {</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         fIntervalPatterns[i].laterDateFirst = fInfo-&gt;getDefaultOrder();</span>
<span class="lineNum">     618 </span>            :     }
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     /* Check whether the skeleton is a combination of date and time.
<span class="lineNum">     621 </span>            :      * For the complication reason 1 explained above.
<span class="lineNum">     622 </span>            :      */
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     UnicodeString dateSkeleton;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     UnicodeString timeSkeleton;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     UnicodeString normalizedTimeSkeleton;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     UnicodeString normalizedDateSkeleton;</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     /* the difference between time skeleton and normalizedTimeSkeleton are:
<span class="lineNum">     630 </span>            :      * 1. (Formerly, normalized time skeleton folded 'H' to 'h'; no longer true)
<span class="lineNum">     631 </span>            :      * 2. 'a' is omitted in normalized time skeleton.
<span class="lineNum">     632 </span>            :      * 3. there is only one appearance for 'h' or 'H', 'm','v', 'z' in normalized
<span class="lineNum">     633 </span>            :      *    time skeleton
<span class="lineNum">     634 </span>            :      *
<span class="lineNum">     635 </span>            :      * The difference between date skeleton and normalizedDateSkeleton are:
<span class="lineNum">     636 </span>            :      * 1. both 'y' and 'd' appear only once in normalizeDateSkeleton
<span class="lineNum">     637 </span>            :      * 2. 'E' and 'EE' are normalized into 'EEE'
<span class="lineNum">     638 </span>            :      * 3. 'MM' is normalized into 'M'
<span class="lineNum">     639 </span>            :      */
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     getDateTimeSkeleton(fSkeleton, dateSkeleton, normalizedDateSkeleton,</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :                         timeSkeleton, normalizedTimeSkeleton);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : #ifdef DTITVFMT_DEBUG
<span class="lineNum">     644 </span>            :     char result[1000];
<span class="lineNum">     645 </span>            :     char result_1[1000];
<span class="lineNum">     646 </span>            :     char mesg[2000];
<span class="lineNum">     647 </span>            :     fSkeleton.extract(0,  fSkeleton.length(), result, &quot;UTF-8&quot;);
<span class="lineNum">     648 </span>            :     sprintf(mesg, &quot;in getBestSkeleton: fSkeleton: %s; \n&quot;, result);
<span class="lineNum">     649 </span>            :     PRINTMESG(mesg)
<span class="lineNum">     650 </span>            : #endif
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     // move this up here since we need it for fallbacks
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     if ( timeSkeleton.length() &gt; 0 &amp;&amp; dateSkeleton.length() &gt; 0 ) {</span>
<span class="lineNum">     654 </span>            :         // Need the Date/Time pattern for concatenation of the date
<span class="lineNum">     655 </span>            :         // with the time interval.
<span class="lineNum">     656 </span>            :         // The date/time pattern ( such as {0} {1} ) is saved in
<span class="lineNum">     657 </span>            :         // calendar, that is why need to get the CalendarData here.
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         LocalUResourceBundlePointer dateTimePatternsRes(ures_open(NULL, locale.getBaseName(), &amp;status));</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         ures_getByKey(dateTimePatternsRes.getAlias(), gCalendarTag,</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :                       dateTimePatternsRes.getAlias(), &amp;status);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         ures_getByKeyWithFallback(dateTimePatternsRes.getAlias(), gGregorianTag,</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                                   dateTimePatternsRes.getAlias(), &amp;status);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         ures_getByKeyWithFallback(dateTimePatternsRes.getAlias(), gDateTimePatternsTag,</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                                   dateTimePatternsRes.getAlias(), &amp;status);</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :         int32_t dateTimeFormatLength;
<span class="lineNum">     667 </span>            :         const UChar* dateTimeFormat = ures_getStringByIndex(
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                                             dateTimePatternsRes.getAlias(),</span>
<span class="lineNum">     669 </span>            :                                             (int32_t)DateFormat::kDateTime,
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                                             &amp;dateTimeFormatLength, &amp;status);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :         if ( U_SUCCESS(status) &amp;&amp; dateTimeFormatLength &gt;= 3 ) {</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :             fDateTimeFormat = new UnicodeString(dateTimeFormat, dateTimeFormatLength);</span>
<span class="lineNum">     673 </span>            :         }
<span class="lineNum">     674 </span>            :     }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :     UBool found = setSeparateDateTimePtn(normalizedDateSkeleton,
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                                          normalizedTimeSkeleton);</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :     // for skeletons with seconds, found is false and we enter this block
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     if ( found == false ) {</span>
<span class="lineNum">     681 </span>            :         // use fallback
<span class="lineNum">     682 </span>            :         // TODO: if user asks &quot;m&quot;(minute), but &quot;d&quot;(day) differ
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         if ( timeSkeleton.length() != 0 ) {</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :             if ( dateSkeleton.length() == 0 ) {</span>
<span class="lineNum">     685 </span>            :                 // prefix with yMd
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :                 timeSkeleton.insert(0, gDateFormatSkeleton[DateFormat::kShort], -1);</span>
<span class="lineNum">     687 </span>            :                 UnicodeString pattern = DateFormat::getBestPattern(
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                         locale, timeSkeleton, status);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                 if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">     691 </span>            :                 }
<span class="lineNum">     692 </span>            :                 // for fall back interval patterns,
<span class="lineNum">     693 </span>            :                 // the first part of the pattern is empty,
<span class="lineNum">     694 </span>            :                 // the second part of the pattern is the full-pattern
<span class="lineNum">     695 </span>            :                 // should be used in fall-back.
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :                 setPatternInfo(UCAL_DATE, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :                 setPatternInfo(UCAL_MONTH, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                 setPatternInfo(UCAL_YEAR, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     699 </span>            :             } else {
<span class="lineNum">     700 </span>            :                 // TODO: fall back
<span class="lineNum">     701 </span>            :             }
<span class="lineNum">     702 </span>            :         } else {
<span class="lineNum">     703 </span>            :             // TODO: fall back
<span class="lineNum">     704 </span>            :         }
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     706 </span>            :     } // end of skeleton not found
<span class="lineNum">     707 </span>            :     // interval patterns for skeleton are found in resource
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     if ( timeSkeleton.length() == 0 ) {</span>
<span class="lineNum">     709 </span>            :         // done
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     } else if ( dateSkeleton.length() == 0 ) {</span>
<span class="lineNum">     711 </span>            :         // prefix with yMd
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         timeSkeleton.insert(0, gDateFormatSkeleton[DateFormat::kShort], -1);</span>
<span class="lineNum">     713 </span>            :         UnicodeString pattern = DateFormat::getBestPattern(
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                 locale, timeSkeleton, status);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         if ( U_FAILURE(status) ) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     717 </span>            :         }
<span class="lineNum">     718 </span>            :         // for fall back interval patterns,
<span class="lineNum">     719 </span>            :         // the first part of the pattern is empty,
<span class="lineNum">     720 </span>            :         // the second part of the pattern is the full-pattern
<span class="lineNum">     721 </span>            :         // should be used in fall-back.
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         setPatternInfo(UCAL_DATE, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :         setPatternInfo(UCAL_MONTH, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         setPatternInfo(UCAL_YEAR, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">     725 </span>            :     } else {
<span class="lineNum">     726 </span>            :         /* if both present,
<span class="lineNum">     727 </span>            :          * 1) when the year, month, or day differs,
<span class="lineNum">     728 </span>            :          * concatenate the two original expressions with a separator between,
<span class="lineNum">     729 </span>            :          * 2) otherwise, present the date followed by the
<span class="lineNum">     730 </span>            :          * range expression for the time.
<span class="lineNum">     731 </span>            :          */
<span class="lineNum">     732 </span>            :         /*
<span class="lineNum">     733 </span>            :          * 1) when the year, month, or day differs,
<span class="lineNum">     734 </span>            :          * concatenate the two original expressions with a separator between,
<span class="lineNum">     735 </span>            :          */
<span class="lineNum">     736 </span>            :         // if field exists, use fall back
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         UnicodeString skeleton = fSkeleton;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if ( !fieldExistsInSkeleton(UCAL_DATE, dateSkeleton) ) {</span>
<span class="lineNum">     739 </span>            :             // prefix skeleton with 'd'
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             skeleton.insert(0, LOW_D);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :             setFallbackPattern(UCAL_DATE, skeleton, status);</span>
<span class="lineNum">     742 </span>            :         }
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         if ( !fieldExistsInSkeleton(UCAL_MONTH, dateSkeleton) ) {</span>
<span class="lineNum">     744 </span>            :             // then prefix skeleton with 'M'
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :             skeleton.insert(0, CAP_M);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :             setFallbackPattern(UCAL_MONTH, skeleton, status);</span>
<span class="lineNum">     747 </span>            :         }
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         if ( !fieldExistsInSkeleton(UCAL_YEAR, dateSkeleton) ) {</span>
<span class="lineNum">     749 </span>            :             // then prefix skeleton with 'y'
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :             skeleton.insert(0, LOW_Y);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :             setFallbackPattern(UCAL_YEAR, skeleton, status);</span>
<span class="lineNum">     752 </span>            :         }
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :         /*
<span class="lineNum">     755 </span>            :          * 2) otherwise, present the date followed by the
<span class="lineNum">     756 </span>            :          * range expression for the time.
<span class="lineNum">     757 </span>            :          */
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         if ( fDateTimeFormat == NULL ) {</span>
<span class="lineNum">     760 </span>            :             // earlier failure getting dateTimeFormat
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     762 </span>            :         }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :         UnicodeString datePattern = DateFormat::getBestPattern(
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :                 locale, dateSkeleton, status);</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_AM_PM, status);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_HOUR, status);</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         concatSingleDate2TimeInterval(*fDateTimeFormat, datePattern, UCAL_MINUTE, status);</span>
<span class="lineNum">     770 </span>            :     }
<span class="lineNum">     771 </span>            : }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : 
<a name="774"><span class="lineNum">     774 </span>            : </a>
<span class="lineNum">     775 </span>            : void  U_EXPORT2
<span class="lineNum">     776 </span><span class="lineNoCov">          0 : DateIntervalFormat::getDateTimeSkeleton(const UnicodeString&amp; skeleton,</span>
<span class="lineNum">     777 </span>            :                                         UnicodeString&amp; dateSkeleton,
<span class="lineNum">     778 </span>            :                                         UnicodeString&amp; normalizedDateSkeleton,
<span class="lineNum">     779 </span>            :                                         UnicodeString&amp; timeSkeleton,
<span class="lineNum">     780 </span>            :                                         UnicodeString&amp; normalizedTimeSkeleton) {
<span class="lineNum">     781 </span>            :     // dateSkeleton follows the sequence of y*M*E*d*
<span class="lineNum">     782 </span>            :     // timeSkeleton follows the sequence of hm*[v|z]?
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     int32_t ECount = 0;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     int32_t dCount = 0;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     int32_t MCount = 0;</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     int32_t yCount = 0;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     int32_t hCount = 0;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     int32_t HCount = 0;</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     int32_t mCount = 0;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     int32_t vCount = 0;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     int32_t zCount = 0;</span>
<span class="lineNum">     792 </span>            :     int32_t i;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; skeleton.length(); ++i) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         UChar ch = skeleton[i];</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         switch ( ch ) {</span>
<span class="lineNum">     797 </span>            :           case CAP_E:
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             dateSkeleton.append(ch);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :             ++ECount;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     801 </span>            :           case LOW_D:
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :             dateSkeleton.append(ch);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :             ++dCount;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     805 </span>            :           case CAP_M:
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :             dateSkeleton.append(ch);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :             ++MCount;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     809 </span>            :           case LOW_Y:
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :             dateSkeleton.append(ch);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :             ++yCount;</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     813 </span>            :           case CAP_G:
<span class="lineNum">     814 </span>            :           case CAP_Y:
<span class="lineNum">     815 </span>            :           case LOW_U:
<span class="lineNum">     816 </span>            :           case CAP_Q:
<span class="lineNum">     817 </span>            :           case LOW_Q:
<span class="lineNum">     818 </span>            :           case CAP_L:
<span class="lineNum">     819 </span>            :           case LOW_L:
<span class="lineNum">     820 </span>            :           case CAP_W:
<span class="lineNum">     821 </span>            :           case LOW_W:
<span class="lineNum">     822 </span>            :           case CAP_D:
<span class="lineNum">     823 </span>            :           case CAP_F:
<span class="lineNum">     824 </span>            :           case LOW_G:
<span class="lineNum">     825 </span>            :           case LOW_E:
<span class="lineNum">     826 </span>            :           case LOW_C:
<span class="lineNum">     827 </span>            :           case CAP_U:
<span class="lineNum">     828 </span>            :           case LOW_R:
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :             normalizedDateSkeleton.append(ch);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :             dateSkeleton.append(ch);</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     832 </span>            :           case LOW_A:
<span class="lineNum">     833 </span>            :             // 'a' is implicitly handled
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     836 </span>            :           case LOW_H:
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :             ++hCount;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     840 </span>            :           case CAP_H:
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :             ++HCount;</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     844 </span>            :           case LOW_M:
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :             ++mCount;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     848 </span>            :           case LOW_Z:
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :             ++zCount;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     852 </span>            :           case LOW_V:
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :             ++vCount;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     856 </span>            :           case CAP_V:
<span class="lineNum">     857 </span>            :           case CAP_Z:
<span class="lineNum">     858 </span>            :           case LOW_K:
<span class="lineNum">     859 </span>            :           case CAP_K:
<span class="lineNum">     860 </span>            :           case LOW_J:
<span class="lineNum">     861 </span>            :           case LOW_S:
<span class="lineNum">     862 </span>            :           case CAP_S:
<span class="lineNum">     863 </span>            :           case CAP_A:
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :             timeSkeleton.append(ch);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :             normalizedTimeSkeleton.append(ch);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     867 </span>            :         }
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :     /* generate normalized form for date*/
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     if ( yCount != 0 ) {</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; yCount; ++i) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :             normalizedDateSkeleton.append(LOW_Y);</span>
<span class="lineNum">     874 </span>            :         }
<span class="lineNum">     875 </span>            :     }
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     if ( MCount != 0 ) {</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :         if ( MCount &lt; 3 ) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :             normalizedDateSkeleton.append(CAP_M);</span>
<span class="lineNum">     879 </span>            :         } else {
<span class="lineNum">     880 </span>            :             int32_t i;
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :             for ( i = 0; i &lt; MCount &amp;&amp; i &lt; MAX_M_COUNT; ++i ) {</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                  normalizedDateSkeleton.append(CAP_M);</span>
<span class="lineNum">     883 </span>            :             }
<span class="lineNum">     884 </span>            :         }
<span class="lineNum">     885 </span>            :     }
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     if ( ECount != 0 ) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         if ( ECount &lt;= 3 ) {</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :             normalizedDateSkeleton.append(CAP_E);</span>
<span class="lineNum">     889 </span>            :         } else {
<span class="lineNum">     890 </span>            :             int32_t i;
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :             for ( i = 0; i &lt; ECount &amp;&amp; i &lt; MAX_E_COUNT; ++i ) {</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :                  normalizedDateSkeleton.append(CAP_E);</span>
<span class="lineNum">     893 </span>            :             }
<span class="lineNum">     894 </span>            :         }
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     if ( dCount != 0 ) {</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         normalizedDateSkeleton.append(LOW_D);</span>
<span class="lineNum">     898 </span>            :     }
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :     /* generate normalized form for time */
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     if ( HCount != 0 ) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         normalizedTimeSkeleton.append(CAP_H);</span>
<span class="lineNum">     903 </span>            :     }
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     else if ( hCount != 0 ) {</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :         normalizedTimeSkeleton.append(LOW_H);</span>
<span class="lineNum">     906 </span>            :     }
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     if ( mCount != 0 ) {</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :         normalizedTimeSkeleton.append(LOW_M);</span>
<span class="lineNum">     909 </span>            :     }
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     if ( zCount != 0 ) {</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :         normalizedTimeSkeleton.append(LOW_Z);</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     if ( vCount != 0 ) {</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         normalizedTimeSkeleton.append(LOW_V);</span>
<span class="lineNum">     915 </span>            :     }
<span class="lineNum">     916 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : /**
<span class="lineNum">     920 </span>            :  * Generate date or time interval pattern from resource,
<span class="lineNum">     921 </span>            :  * and set them into the interval pattern locale to this formatter.
<span class="lineNum">     922 </span>            :  *
<span class="lineNum">     923 </span>            :  * It needs to handle the following:
<span class="lineNum">     924 </span>            :  * 1. need to adjust field width.
<span class="lineNum">     925 </span>            :  *    For example, the interval patterns saved in DateIntervalInfo
<span class="lineNum">     926 </span>            :  *    includes &quot;dMMMy&quot;, but not &quot;dMMMMy&quot;.
<span class="lineNum">     927 </span>            :  *    Need to get interval patterns for dMMMMy from dMMMy.
<span class="lineNum">     928 </span>            :  *    Another example, the interval patterns saved in DateIntervalInfo
<span class="lineNum">     929 </span>            :  *    includes &quot;hmv&quot;, but not &quot;hmz&quot;.
<span class="lineNum">     930 </span>            :  *    Need to get interval patterns for &quot;hmz' from 'hmv'
<span class="lineNum">     931 </span>            :  *
<span class="lineNum">     932 </span>            :  * 2. there might be no pattern for 'y' differ for skeleton &quot;Md&quot;,
<span class="lineNum">     933 </span>            :  *    in order to get interval patterns for 'y' differ,
<span class="lineNum">     934 </span>            :  *    need to look for it from skeleton 'yMd'
<span class="lineNum">     935 </span>            :  *
<span class="lineNum">     936 </span>            :  * @param dateSkeleton   normalized date skeleton
<span class="lineNum">     937 </span>            :  * @param timeSkeleton   normalized time skeleton
<span class="lineNum">     938 </span>            :  * @return               whether the resource is found for the skeleton.
<span class="lineNum">     939 </span>            :  *                       TRUE if interval pattern found for the skeleton,
<span class="lineNum">     940 </span>            :  *                       FALSE otherwise.
<span class="lineNum">     941 </span>            :  * @stable ICU 4.0
<a name="942"><span class="lineNum">     942 </span>            :  */</a>
<span class="lineNum">     943 </span>            : UBool
<span class="lineNum">     944 </span><span class="lineNoCov">          0 : DateIntervalFormat::setSeparateDateTimePtn(</span>
<span class="lineNum">     945 </span>            :                                  const UnicodeString&amp; dateSkeleton,
<span class="lineNum">     946 </span>            :                                  const UnicodeString&amp; timeSkeleton) {
<span class="lineNum">     947 </span>            :     const UnicodeString* skeleton;
<span class="lineNum">     948 </span>            :     // if both date and time skeleton present,
<span class="lineNum">     949 </span>            :     // the final interval pattern might include time interval patterns
<span class="lineNum">     950 </span>            :     // ( when, am_pm, hour, minute differ ),
<span class="lineNum">     951 </span>            :     // but not date interval patterns ( when year, month, day differ ).
<span class="lineNum">     952 </span>            :     // For year/month/day differ, it falls back to fall-back pattern.
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if ( timeSkeleton.length() != 0  ) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         skeleton = &amp;timeSkeleton;</span>
<span class="lineNum">     955 </span>            :     } else {
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         skeleton = &amp;dateSkeleton;</span>
<span class="lineNum">     957 </span>            :     }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :     /* interval patterns for skeleton &quot;dMMMy&quot; (but not &quot;dMMMMy&quot;)
<span class="lineNum">     960 </span>            :      * are defined in resource,
<span class="lineNum">     961 </span>            :      * interval patterns for skeleton &quot;dMMMMy&quot; are calculated by
<span class="lineNum">     962 </span>            :      * 1. get the best match skeleton for &quot;dMMMMy&quot;, which is &quot;dMMMy&quot;
<span class="lineNum">     963 </span>            :      * 2. get the interval patterns for &quot;dMMMy&quot;,
<span class="lineNum">     964 </span>            :      * 3. extend &quot;MMM&quot; to &quot;MMMM&quot; in above interval patterns for &quot;dMMMMy&quot;
<span class="lineNum">     965 </span>            :      * getBestSkeleton() is step 1.
<span class="lineNum">     966 </span>            :      */
<span class="lineNum">     967 </span>            :     // best skeleton, and the difference information
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     int8_t differenceInfo = 0;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     const UnicodeString* bestSkeleton = fInfo-&gt;getBestSkeleton(*skeleton,</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                                                                differenceInfo);</span>
<span class="lineNum">     971 </span>            :     /* best skeleton could be NULL.
<span class="lineNum">     972 </span>            :        For example: in &quot;ca&quot; resource file,
<span class="lineNum">     973 </span>            :        interval format is defined as following
<span class="lineNum">     974 </span>            :            intervalFormats{
<span class="lineNum">     975 </span>            :                 fallback{&quot;{0} - {1}&quot;}
<span class="lineNum">     976 </span>            :             }
<span class="lineNum">     977 </span>            :        there is no skeletons/interval patterns defined,
<span class="lineNum">     978 </span>            :        and the best skeleton match could be NULL
<span class="lineNum">     979 </span>            :      */
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     if ( bestSkeleton == NULL ) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :     // Set patterns for fallback use, need to do this
<span class="lineNum">     985 </span>            :     // before returning if differenceInfo == -1
<span class="lineNum">     986 </span>            :     UErrorCode status;
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     if ( dateSkeleton.length() != 0) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         status = U_ZERO_ERROR;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         fDatePattern = new UnicodeString(DateFormat::getBestPattern(</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :                 fLocale, dateSkeleton, status));</span>
<span class="lineNum">     991 </span>            :     }
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     if ( timeSkeleton.length() != 0) {</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :         status = U_ZERO_ERROR;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :         fTimePattern = new UnicodeString(DateFormat::getBestPattern(</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :                 fLocale, timeSkeleton, status));</span>
<span class="lineNum">     996 </span>            :     }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :     // difference:
<span class="lineNum">     999 </span>            :     // 0 means the best matched skeleton is the same as input skeleton
<span class="lineNum">    1000 </span>            :     // 1 means the fields are the same, but field width are different
<span class="lineNum">    1001 </span>            :     // 2 means the only difference between fields are v/z,
<span class="lineNum">    1002 </span>            :     // -1 means there are other fields difference
<span class="lineNum">    1003 </span>            :     // (this will happen, for instance, if the supplied skeleton has seconds,
<span class="lineNum">    1004 </span>            :     //  but no skeletons in the intervalFormats data do)
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     if ( differenceInfo == -1 ) {</span>
<span class="lineNum">    1006 </span>            :         // skeleton has different fields, not only  v/z difference
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1008 </span>            :     }
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     if ( timeSkeleton.length() == 0 ) {</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         UnicodeString extendedSkeleton;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         UnicodeString extendedBestSkeleton;</span>
<span class="lineNum">    1013 </span>            :         // only has date skeleton
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :         setIntervalPattern(UCAL_DATE, skeleton, bestSkeleton, differenceInfo,</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         UBool extended = setIntervalPattern(UCAL_MONTH, skeleton, bestSkeleton,</span>
<span class="lineNum">    1018 </span>            :                                      differenceInfo,
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                                      &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         if ( extended ) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             bestSkeleton = &amp;extendedBestSkeleton;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :             skeleton = &amp;extendedSkeleton;</span>
<span class="lineNum">    1024 </span>            :         }
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         setIntervalPattern(UCAL_YEAR, skeleton, bestSkeleton, differenceInfo,</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :                            &amp;extendedSkeleton, &amp;extendedBestSkeleton);</span>
<span class="lineNum">    1027 </span>            :     } else {
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :         setIntervalPattern(UCAL_MINUTE, skeleton, bestSkeleton, differenceInfo);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         setIntervalPattern(UCAL_HOUR, skeleton, bestSkeleton, differenceInfo);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         setIntervalPattern(UCAL_AM_PM, skeleton, bestSkeleton, differenceInfo);</span>
<span class="lineNum">    1031 </span>            :     }
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1033 </span>            : }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            : 
<a name="1036"><span class="lineNum">    1036 </span>            : </a>
<span class="lineNum">    1037 </span>            : void
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 : DateIntervalFormat::setFallbackPattern(UCalendarDateFields field,</span>
<span class="lineNum">    1039 </span>            :                                        const UnicodeString&amp; skeleton,
<span class="lineNum">    1040 </span>            :                                        UErrorCode&amp; status) {
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1043 </span>            :     }
<span class="lineNum">    1044 </span>            :     UnicodeString pattern = DateFormat::getBestPattern(
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :             fLocale, skeleton, status);</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1048 </span>            :     }
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :     setPatternInfo(field, NULL, &amp;pattern, fInfo-&gt;getDefaultOrder());</span>
<span class="lineNum">    1050 </span>            : }
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            : 
<a name="1054"><span class="lineNum">    1054 </span>            : </a>
<span class="lineNum">    1055 </span>            : void
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 : DateIntervalFormat::setPatternInfo(UCalendarDateFields field,</span>
<span class="lineNum">    1057 </span>            :                                    const UnicodeString* firstPart,
<span class="lineNum">    1058 </span>            :                                    const UnicodeString* secondPart,
<span class="lineNum">    1059 </span>            :                                    UBool laterDateFirst) {
<span class="lineNum">    1060 </span>            :     // for fall back interval patterns,
<span class="lineNum">    1061 </span>            :     // the first part of the pattern is empty,
<span class="lineNum">    1062 </span>            :     // the second part of the pattern is the full-pattern
<span class="lineNum">    1063 </span>            :     // should be used in fall-back.
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">    1065 </span>            :     // following should not set any wrong status.
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                                                                         status);</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1070 </span>            :     }
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     PatternInfo&amp; ptn = fIntervalPatterns[itvPtnIndex];</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     if ( firstPart ) {</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         ptn.firstPart = *firstPart;</span>
<span class="lineNum">    1074 </span>            :     }
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     if ( secondPart ) {</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         ptn.secondPart = *secondPart;</span>
<span class="lineNum">    1077 </span>            :     }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     ptn.laterDateFirst = laterDateFirst;</span>
<span class="lineNum">    1079 </span>            : }
<a name="1080"><span class="lineNum">    1080 </span>            : </a>
<span class="lineNum">    1081 </span>            : void
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 : DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,</span>
<span class="lineNum">    1083 </span>            :                                        const UnicodeString&amp; intervalPattern) {
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :     UBool order = fInfo-&gt;getDefaultOrder();</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     setIntervalPattern(field, intervalPattern, order);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1087 </span>            : 
<a name="1088"><span class="lineNum">    1088 </span>            : </a>
<span class="lineNum">    1089 </span>            : void
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 : DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,</span>
<span class="lineNum">    1091 </span>            :                                        const UnicodeString&amp; intervalPattern,
<span class="lineNum">    1092 </span>            :                                        UBool laterDateFirst) {
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :     const UnicodeString* pattern = &amp;intervalPattern;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     UBool order = laterDateFirst;</span>
<span class="lineNum">    1095 </span>            :     // check for &quot;latestFirst:&quot; or &quot;earliestFirst:&quot; prefix
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     int8_t prefixLength = UPRV_LENGTHOF(gLaterFirstPrefix);</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     int8_t earliestFirstLength = UPRV_LENGTHOF(gEarlierFirstPrefix);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     UnicodeString realPattern;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     if ( intervalPattern.startsWith(gLaterFirstPrefix, prefixLength) ) {</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         order = true;</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         intervalPattern.extract(prefixLength,</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :                                 intervalPattern.length() - prefixLength,</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                                 realPattern);</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :         pattern = &amp;realPattern;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     } else if ( intervalPattern.startsWith(gEarlierFirstPrefix,</span>
<span class="lineNum">    1106 </span>            :                                            earliestFirstLength) ) {
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         order = false;</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         intervalPattern.extract(earliestFirstLength,</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :                                 intervalPattern.length() - earliestFirstLength,</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                                 realPattern);</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         pattern = &amp;realPattern;</span>
<span class="lineNum">    1112 </span>            :     }
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     int32_t splitPoint = splitPatternInto2Part(*pattern);</span>
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     UnicodeString firstPart;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     UnicodeString secondPart;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     pattern-&gt;extract(0, splitPoint, firstPart);</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     if ( splitPoint &lt; pattern-&gt;length() ) {</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         pattern-&gt;extract(splitPoint, pattern-&gt;length()-splitPoint, secondPart);</span>
<span class="lineNum">    1121 </span>            :     }
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :     setPatternInfo(field, &amp;firstPart, &amp;secondPart, order);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : /**
<span class="lineNum">    1129 </span>            :  * Generate interval pattern from existing resource
<span class="lineNum">    1130 </span>            :  *
<span class="lineNum">    1131 </span>            :  * It not only save the interval patterns,
<span class="lineNum">    1132 </span>            :  * but also return the extended skeleton and its best match skeleton.
<span class="lineNum">    1133 </span>            :  *
<span class="lineNum">    1134 </span>            :  * @param field           largest different calendar field
<span class="lineNum">    1135 </span>            :  * @param skeleton        skeleton
<span class="lineNum">    1136 </span>            :  * @param bestSkeleton    the best match skeleton which has interval pattern
<span class="lineNum">    1137 </span>            :  *                        defined in resource
<span class="lineNum">    1138 </span>            :  * @param differenceInfo  the difference between skeleton and best skeleton
<span class="lineNum">    1139 </span>            :  *         0 means the best matched skeleton is the same as input skeleton
<span class="lineNum">    1140 </span>            :  *         1 means the fields are the same, but field width are different
<span class="lineNum">    1141 </span>            :  *         2 means the only difference between fields are v/z,
<span class="lineNum">    1142 </span>            :  *        -1 means there are other fields difference
<span class="lineNum">    1143 </span>            :  *
<span class="lineNum">    1144 </span>            :  * @param extendedSkeleton      extended skeleton
<span class="lineNum">    1145 </span>            :  * @param extendedBestSkeleton  extended best match skeleton
<span class="lineNum">    1146 </span>            :  * @return                      whether the interval pattern is found
<span class="lineNum">    1147 </span>            :  *                              through extending skeleton or not.
<span class="lineNum">    1148 </span>            :  *                              TRUE if interval pattern is found by
<span class="lineNum">    1149 </span>            :  *                              extending skeleton, FALSE otherwise.
<span class="lineNum">    1150 </span>            :  * @stable ICU 4.0
<a name="1151"><span class="lineNum">    1151 </span>            :  */</a>
<span class="lineNum">    1152 </span>            : UBool
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 : DateIntervalFormat::setIntervalPattern(UCalendarDateFields field,</span>
<span class="lineNum">    1154 </span>            :                                        const UnicodeString* skeleton,
<span class="lineNum">    1155 </span>            :                                        const UnicodeString* bestSkeleton,
<span class="lineNum">    1156 </span>            :                                        int8_t differenceInfo,
<span class="lineNum">    1157 </span>            :                                        UnicodeString* extendedSkeleton,
<span class="lineNum">    1158 </span>            :                                        UnicodeString* extendedBestSkeleton) {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :     UErrorCode status = U_ZERO_ERROR;</span>
<span class="lineNum">    1160 </span>            :     // following getIntervalPattern() should not generate error status
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     UnicodeString pattern;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :     fInfo-&gt;getIntervalPattern(*bestSkeleton, field, pattern, status);</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :     if ( pattern.isEmpty() ) {</span>
<span class="lineNum">    1164 </span>            :         // single date
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         if ( SimpleDateFormat::isFieldUnitIgnored(*bestSkeleton, field) ) {</span>
<span class="lineNum">    1166 </span>            :             // do nothing, format will handle it
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1168 </span>            :         }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :         // for 24 hour system, interval patterns in resource file
<span class="lineNum">    1171 </span>            :         // might not include pattern when am_pm differ,
<span class="lineNum">    1172 </span>            :         // which should be the same as hour differ.
<span class="lineNum">    1173 </span>            :         // add it here for simplicity
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         if ( field == UCAL_AM_PM ) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :             fInfo-&gt;getIntervalPattern(*bestSkeleton, UCAL_HOUR, pattern,status);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :             if ( !pattern.isEmpty() ) {</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :                 setIntervalPattern(field, pattern);</span>
<span class="lineNum">    1178 </span>            :             }
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1180 </span>            :         }
<span class="lineNum">    1181 </span>            :         // else, looking for pattern when 'y' differ for 'dMMMM' skeleton,
<span class="lineNum">    1182 </span>            :         // first, get best match pattern &quot;MMMd&quot;,
<span class="lineNum">    1183 </span>            :         // since there is no pattern for 'y' differs for skeleton 'MMMd',
<span class="lineNum">    1184 </span>            :         // need to look for it from skeleton 'yMMMd',
<span class="lineNum">    1185 </span>            :         // if found, adjust field width in interval pattern from
<span class="lineNum">    1186 </span>            :         // &quot;MMM&quot; to &quot;MMMM&quot;.
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         UChar fieldLetter = fgCalendarFieldToPatternLetter[field];</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :         if ( extendedSkeleton ) {</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :             *extendedSkeleton = *skeleton;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             *extendedBestSkeleton = *bestSkeleton;</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             extendedSkeleton-&gt;insert(0, fieldLetter);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :             extendedBestSkeleton-&gt;insert(0, fieldLetter);</span>
<span class="lineNum">    1193 </span>            :             // for example, looking for patterns when 'y' differ for
<span class="lineNum">    1194 </span>            :             // skeleton &quot;MMMM&quot;.
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :             fInfo-&gt;getIntervalPattern(*extendedBestSkeleton,field,pattern,status);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :             if ( pattern.isEmpty() &amp;&amp; differenceInfo == 0 ) {</span>
<span class="lineNum">    1197 </span>            :                 // if there is no skeleton &quot;yMMMM&quot; defined,
<span class="lineNum">    1198 </span>            :                 // look for the best match skeleton, for example: &quot;yMMM&quot;
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                 const UnicodeString* tmpBest = fInfo-&gt;getBestSkeleton(</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                                         *extendedBestSkeleton, differenceInfo);</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :                 if ( tmpBest != 0 &amp;&amp; differenceInfo != -1 ) {</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :                     fInfo-&gt;getIntervalPattern(*tmpBest, field, pattern, status);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                     bestSkeleton = tmpBest;</span>
<span class="lineNum">    1204 </span>            :                 }
<span class="lineNum">    1205 </span>            :             }
<span class="lineNum">    1206 </span>            :         }
<span class="lineNum">    1207 </span>            :     }
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     if ( !pattern.isEmpty() ) {</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :         if ( differenceInfo != 0 ) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :             UnicodeString adjustIntervalPattern;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :             adjustFieldWidth(*skeleton, *bestSkeleton, pattern, differenceInfo,</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                               adjustIntervalPattern);</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :             setIntervalPattern(field, adjustIntervalPattern);</span>
<span class="lineNum">    1214 </span>            :         } else {
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :             setIntervalPattern(field, pattern);</span>
<span class="lineNum">    1216 </span>            :         }
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :         if ( extendedSkeleton &amp;&amp; !extendedSkeleton-&gt;isEmpty() ) {</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :             return TRUE;</span>
<span class="lineNum">    1219 </span>            :         }
<span class="lineNum">    1220 </span>            :     }
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     return FALSE;</span>
<span class="lineNum">    1222 </span>            : }
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : 
<a name="1225"><span class="lineNum">    1225 </span>            : </a>
<span class="lineNum">    1226 </span>            : int32_t  U_EXPORT2
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 : DateIntervalFormat::splitPatternInto2Part(const UnicodeString&amp; intervalPattern) {</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     UBool inQuote = false;</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     UChar prevCh = 0;</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     int32_t count = 0;</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            :     /* repeatedPattern used to record whether a pattern has already seen.
<span class="lineNum">    1233 </span>            :        It is a pattern applies to first calendar if it is first time seen,
<span class="lineNum">    1234 </span>            :        otherwise, it is a pattern applies to the second calendar
<span class="lineNum">    1235 </span>            :      */
<span class="lineNum">    1236 </span>            :     UBool patternRepeated[] =
<span class="lineNum">    1237 </span>            :     {
<span class="lineNum">    1238 </span>            :     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
<span class="lineNum">    1239 </span>            :              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1240 </span>            :     //   P   Q   R   S   T   U   V   W   X   Y   Z
<span class="lineNum">    1241 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
<span class="lineNum">    1242 </span>            :     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
<span class="lineNum">    1243 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1244 </span>            :     //   p   q   r   s   t   u   v   w   x   y   z
<span class="lineNum">    1245 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :     int8_t PATTERN_CHAR_BASE = 0x41;</span>
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :     /* loop through the pattern string character by character looking for
<span class="lineNum">    1251 </span>            :      * the first repeated pattern letter, which breaks the interval pattern
<span class="lineNum">    1252 </span>            :      * into 2 parts.
<span class="lineNum">    1253 </span>            :      */
<span class="lineNum">    1254 </span>            :     int32_t i;
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :     UBool foundRepetition = false;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; intervalPattern.length(); ++i) {</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :         UChar ch = intervalPattern.charAt(i);</span>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         if (ch != prevCh &amp;&amp; count &gt; 0) {</span>
<span class="lineNum">    1260 </span>            :             // check the repeativeness of pattern letter
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             UBool repeated = patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)];</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :             if ( repeated == FALSE ) {</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                 patternRepeated[prevCh - PATTERN_CHAR_BASE] = TRUE;</span>
<span class="lineNum">    1264 </span>            :             } else {
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                 foundRepetition = true;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1267 </span>            :             }
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :             count = 0;</span>
<span class="lineNum">    1269 </span>            :         }
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :         if (ch == 0x0027 /*'*/) {</span>
<span class="lineNum">    1271 </span>            :             // Consecutive single quotes are a single quote literal,
<span class="lineNum">    1272 </span>            :             // either outside of quotes or between quotes
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :             if ((i+1) &lt; intervalPattern.length() &amp;&amp;</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                 intervalPattern.charAt(i+1) == 0x0027 /*'*/) {</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                 ++i;</span>
<span class="lineNum">    1276 </span>            :             } else {
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :                 inQuote = ! inQuote;</span>
<span class="lineNum">    1278 </span>            :             }
<span class="lineNum">    1279 </span>            :         }
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :         else if (!inQuote &amp;&amp; ((ch &gt;= 0x0061 /*'a'*/ &amp;&amp; ch &lt;= 0x007A /*'z'*/)</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                     || (ch &gt;= 0x0041 /*'A'*/ &amp;&amp; ch &lt;= 0x005A /*'Z'*/))) {</span>
<span class="lineNum">    1282 </span>            :             // ch is a date-time pattern character
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :             prevCh = ch;</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             ++count;</span>
<span class="lineNum">    1285 </span>            :         }
<span class="lineNum">    1286 </span>            :     }
<span class="lineNum">    1287 </span>            :     // check last pattern char, distinguish
<span class="lineNum">    1288 </span>            :     // &quot;dd MM&quot; ( no repetition ),
<span class="lineNum">    1289 </span>            :     // &quot;d-d&quot;(last char repeated ), and
<span class="lineNum">    1290 </span>            :     // &quot;d-d MM&quot; ( repetition found )
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     if ( count &gt; 0 &amp;&amp; foundRepetition == FALSE ) {</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :         if ( patternRepeated[(int)(prevCh - PATTERN_CHAR_BASE)] == FALSE ) {</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :             count = 0;</span>
<span class="lineNum">    1294 </span>            :         }
<span class="lineNum">    1295 </span>            :     }
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     return (i - count);</span>
<span class="lineNum">    1297 </span>            : }
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : static const UChar bracketedZero[] = {0x7B,0x30,0x7D};
<span class="lineNum">    1300 </span>            : static const UChar bracketedOne[]  = {0x7B,0x31,0x7D};
<a name="1301"><span class="lineNum">    1301 </span>            : </a>
<span class="lineNum">    1302 </span>            : void
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 : DateIntervalFormat::adjustPosition(UnicodeString&amp; combiningPattern, // has {0} and {1} in it</span>
<span class="lineNum">    1304 </span>            :                                    UnicodeString&amp; pat0, FieldPosition&amp; pos0, // pattern and pos corresponding to {0}
<span class="lineNum">    1305 </span>            :                                    UnicodeString&amp; pat1, FieldPosition&amp; pos1, // pattern and pos corresponding to {1}
<span class="lineNum">    1306 </span>            :                                    FieldPosition&amp; posResult)  {
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     int32_t index0 = combiningPattern.indexOf(bracketedZero, 3, 0);</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     int32_t index1 = combiningPattern.indexOf(bracketedOne,  3, 0);</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     if (index0 &lt; 0 || index1 &lt; 0) {</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1311 </span>            :     }
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     int32_t placeholderLen = 3; // length of &quot;{0}&quot; or &quot;{1}&quot;</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     if (index0 &lt; index1) {</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :         if (pos0.getEndIndex() &gt; 0) {</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         } else if (pos1.getEndIndex() &gt; 0) {</span>
<span class="lineNum">    1318 </span>            :             // here index1 &gt;= 3
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :             index1 += pat0.length() - placeholderLen; // adjust for pat0 replacing {0}</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="lineNum">    1322 </span>            :         }
<span class="lineNum">    1323 </span>            :     } else {
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         if (pos1.getEndIndex() &gt; 0) {</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :             posResult.setBeginIndex(pos1.getBeginIndex() + index1);</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :             posResult.setEndIndex(pos1.getEndIndex() + index1);</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :         } else if (pos0.getEndIndex() &gt; 0) {</span>
<span class="lineNum">    1328 </span>            :             // here index0 &gt;= 3
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :             index0 += pat1.length() - placeholderLen; // adjust for pat1 replacing {1}</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :             posResult.setBeginIndex(pos0.getBeginIndex() + index0);</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :             posResult.setEndIndex(pos0.getEndIndex() + index0);</span>
<span class="lineNum">    1332 </span>            :         }
<span class="lineNum">    1333 </span>            :     }
<span class="lineNum">    1334 </span>            : }
<a name="1335"><span class="lineNum">    1335 </span>            : </a>
<span class="lineNum">    1336 </span>            : UnicodeString&amp;
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 : DateIntervalFormat::fallbackFormat(Calendar&amp; fromCalendar,</span>
<span class="lineNum">    1338 </span>            :                                    Calendar&amp; toCalendar,
<span class="lineNum">    1339 </span>            :                                    UBool fromToOnSameDay, // new
<span class="lineNum">    1340 </span>            :                                    UnicodeString&amp; appendTo,
<span class="lineNum">    1341 </span>            :                                    FieldPosition&amp; pos,
<span class="lineNum">    1342 </span>            :                                    UErrorCode&amp; status) const {
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         return appendTo;</span>
<span class="lineNum">    1345 </span>            :     }
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :     UnicodeString fullPattern; // for saving the pattern in fDateFormat</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :     UBool formatDatePlusTimeRange = (fromToOnSameDay &amp;&amp; fDatePattern &amp;&amp; fTimePattern);</span>
<span class="lineNum">    1348 </span>            :     // the fall back
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     if (formatDatePlusTimeRange) {</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;toPattern(fullPattern); // save current pattern, restore later</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(*fTimePattern);</span>
<span class="lineNum">    1352 </span>            :     }
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     FieldPosition otherPos;</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :     otherPos.setField(pos.getField());</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     UnicodeString earlierDate;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;format(fromCalendar, earlierDate, pos);</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :     UnicodeString laterDate;</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     fDateFormat-&gt;format(toCalendar, laterDate, otherPos);</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     UnicodeString fallbackPattern;</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :     fInfo-&gt;getFallbackIntervalPattern(fallbackPattern);</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :     adjustPosition(fallbackPattern, earlierDate, pos, laterDate, otherPos, pos);</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :     UnicodeString fallbackRange;</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :     SimpleFormatter(fallbackPattern, 2, 2, status).</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :             format(earlierDate, laterDate, fallbackRange, status);</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     if ( U_SUCCESS(status) &amp;&amp; formatDatePlusTimeRange ) {</span>
<span class="lineNum">    1366 </span>            :         // fallbackRange has just the time range, need to format the date part and combine that
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(*fDatePattern);</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :         UnicodeString datePortion;</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         otherPos.setBeginIndex(0);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         otherPos.setEndIndex(0);</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;format(fromCalendar, datePortion, otherPos);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :         adjustPosition(*fDateTimeFormat, fallbackRange, pos, datePortion, otherPos, pos);</span>
<span class="lineNum">    1373 </span>            :         const UnicodeString *values[2] = {
<span class="lineNum">    1374 </span>            :             &amp;fallbackRange,  // {0} is time range
<span class="lineNum">    1375 </span>            :             &amp;datePortion,  // {1} is single date portion
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :         };</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :         SimpleFormatter(*fDateTimeFormat, 2, 2, status).</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                 formatAndReplace(values, 2, fallbackRange, NULL, 0, status);</span>
<span class="lineNum">    1379 </span>            :     }
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     if ( U_SUCCESS(status) ) {</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :         appendTo.append(fallbackRange);</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     if (formatDatePlusTimeRange) {</span>
<span class="lineNum">    1384 </span>            :         // restore full pattern
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :         fDateFormat-&gt;applyPattern(fullPattern);</span>
<span class="lineNum">    1386 </span>            :     }
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     return appendTo;</span>
<span class="lineNum">    1388 </span>            : }
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : 
<a name="1392"><span class="lineNum">    1392 </span>            : </a>
<span class="lineNum">    1393 </span>            : UBool  U_EXPORT2
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 : DateIntervalFormat::fieldExistsInSkeleton(UCalendarDateFields field,</span>
<span class="lineNum">    1395 </span>            :                                           const UnicodeString&amp; skeleton)
<span class="lineNum">    1396 </span>            : {
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     const UChar fieldChar = fgCalendarFieldToPatternLetter[field];</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     return ( (skeleton.indexOf(fieldChar) == -1)?FALSE:TRUE ) ;</span>
<span class="lineNum">    1399 </span>            : }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            : 
<a name="1402"><span class="lineNum">    1402 </span>            : </a>
<span class="lineNum">    1403 </span>            : void  U_EXPORT2
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : DateIntervalFormat::adjustFieldWidth(const UnicodeString&amp; inputSkeleton,</span>
<span class="lineNum">    1405 </span>            :                  const UnicodeString&amp; bestMatchSkeleton,
<span class="lineNum">    1406 </span>            :                  const UnicodeString&amp; bestIntervalPattern,
<span class="lineNum">    1407 </span>            :                  int8_t differenceInfo,
<span class="lineNum">    1408 </span>            :                  UnicodeString&amp; adjustedPtn) {
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     adjustedPtn = bestIntervalPattern;</span>
<span class="lineNum">    1410 </span>            :     int32_t inputSkeletonFieldWidth[] =
<span class="lineNum">    1411 </span>            :     {
<span class="lineNum">    1412 </span>            :     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
<span class="lineNum">    1413 </span>            :              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1414 </span>            :     //   P   Q   R   S   T   U   V   W   X   Y   Z
<span class="lineNum">    1415 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
<span class="lineNum">    1416 </span>            :     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
<span class="lineNum">    1417 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1418 </span>            :     //   p   q   r   s   t   u   v   w   x   y   z
<span class="lineNum">    1419 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            :     int32_t bestMatchSkeletonFieldWidth[] =
<span class="lineNum">    1423 </span>            :     {
<span class="lineNum">    1424 </span>            :     //       A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
<span class="lineNum">    1425 </span>            :              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1426 </span>            :     //   P   Q   R   S   T   U   V   W   X   Y   Z
<span class="lineNum">    1427 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0,  0, 0, 0,
<span class="lineNum">    1428 </span>            :     //       a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
<span class="lineNum">    1429 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
<span class="lineNum">    1430 </span>            :     //   p   q   r   s   t   u   v   w   x   y   z
<span class="lineNum">    1431 </span>            :          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     };</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     DateIntervalInfo::parseSkeleton(inputSkeleton, inputSkeletonFieldWidth);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     DateIntervalInfo::parseSkeleton(bestMatchSkeleton, bestMatchSkeletonFieldWidth);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     if ( differenceInfo == 2 ) {</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         adjustedPtn.findAndReplace(UnicodeString((UChar)0x76 /* v */),</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :                                    UnicodeString((UChar)0x7a /* z */));</span>
<span class="lineNum">    1439 </span>            :     }
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     UBool inQuote = false;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     UChar prevCh = 0;</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     int32_t count = 0;</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     const int8_t PATTERN_CHAR_BASE = 0x41;</span>
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :     // loop through the pattern string character by character
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     int32_t adjustedPtnLength = adjustedPtn.length();</span>
<span class="lineNum">    1449 </span>            :     int32_t i;
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; adjustedPtnLength; ++i) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         UChar ch = adjustedPtn.charAt(i);</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :         if (ch != prevCh &amp;&amp; count &gt; 0) {</span>
<span class="lineNum">    1453 </span>            :             // check the repeativeness of pattern letter
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :             UChar skeletonChar = prevCh;</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :             if ( skeletonChar ==  CAP_L ) {</span>
<span class="lineNum">    1456 </span>            :                 // there is no &quot;L&quot; (always be &quot;M&quot;) in skeleton,
<span class="lineNum">    1457 </span>            :                 // but there is &quot;L&quot; in pattern.
<span class="lineNum">    1458 </span>            :                 // for skeleton &quot;M+&quot;, the pattern might be &quot;...L...&quot;
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                 skeletonChar = CAP_M;</span>
<span class="lineNum">    1460 </span>            :             }
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :             int32_t fieldCount = bestMatchSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :             int32_t inputFieldCount = inputSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :             if ( fieldCount == count &amp;&amp; inputFieldCount &gt; fieldCount ) {</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :                 count = inputFieldCount - fieldCount;</span>
<span class="lineNum">    1465 </span>            :                 int32_t j;
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :                 for ( j = 0; j &lt; count; ++j ) {</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :                     adjustedPtn.insert(i, prevCh);</span>
<span class="lineNum">    1468 </span>            :                 }
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :                 i += count;</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                 adjustedPtnLength += count;</span>
<span class="lineNum">    1471 </span>            :             }
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :             count = 0;</span>
<span class="lineNum">    1473 </span>            :         }
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         if (ch == 0x0027 /*'*/) {</span>
<span class="lineNum">    1475 </span>            :             // Consecutive single quotes are a single quote literal,
<span class="lineNum">    1476 </span>            :             // either outside of quotes or between quotes
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :             if ((i+1) &lt; adjustedPtn.length() &amp;&amp; adjustedPtn.charAt(i+1) == 0x0027 /* ' */) {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :                 ++i;</span>
<span class="lineNum">    1479 </span>            :             } else {
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :                 inQuote = ! inQuote;</span>
<span class="lineNum">    1481 </span>            :             }
<span class="lineNum">    1482 </span>            :         }
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         else if ( ! inQuote &amp;&amp; ((ch &gt;= 0x0061 /*'a'*/ &amp;&amp; ch &lt;= 0x007A /*'z'*/)</span>
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                     || (ch &gt;= 0x0041 /*'A'*/ &amp;&amp; ch &lt;= 0x005A /*'Z'*/))) {</span>
<span class="lineNum">    1485 </span>            :             // ch is a date-time pattern character
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :             prevCh = ch;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :             ++count;</span>
<span class="lineNum">    1488 </span>            :         }
<span class="lineNum">    1489 </span>            :     }
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     if ( count &gt; 0 ) {</span>
<span class="lineNum">    1491 </span>            :         // last item
<span class="lineNum">    1492 </span>            :         // check the repeativeness of pattern letter
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         UChar skeletonChar = prevCh;</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         if ( skeletonChar == CAP_L ) {</span>
<span class="lineNum">    1495 </span>            :             // there is no &quot;L&quot; (always be &quot;M&quot;) in skeleton,
<span class="lineNum">    1496 </span>            :             // but there is &quot;L&quot; in pattern.
<span class="lineNum">    1497 </span>            :             // for skeleton &quot;M+&quot;, the pattern might be &quot;...L...&quot;
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :             skeletonChar = CAP_M;</span>
<span class="lineNum">    1499 </span>            :         }
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         int32_t fieldCount = bestMatchSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         int32_t inputFieldCount = inputSkeletonFieldWidth[(int)(skeletonChar - PATTERN_CHAR_BASE)];</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         if ( fieldCount == count &amp;&amp; inputFieldCount &gt; fieldCount ) {</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :             count = inputFieldCount - fieldCount;</span>
<span class="lineNum">    1504 </span>            :             int32_t j;
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :             for ( j = 0; j &lt; count; ++j ) {</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :                 adjustedPtn.append(prevCh);</span>
<span class="lineNum">    1507 </span>            :             }
<span class="lineNum">    1508 </span>            :         }
<span class="lineNum">    1509 </span>            :     }
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            : 
<a name="1513"><span class="lineNum">    1513 </span>            : </a>
<span class="lineNum">    1514 </span>            : void
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 : DateIntervalFormat::concatSingleDate2TimeInterval(UnicodeString&amp; format,</span>
<span class="lineNum">    1516 </span>            :                                               const UnicodeString&amp; datePattern,
<span class="lineNum">    1517 </span>            :                                               UCalendarDateFields field,
<span class="lineNum">    1518 </span>            :                                               UErrorCode&amp; status) {
<span class="lineNum">    1519 </span>            :     // following should not set wrong status
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     int32_t itvPtnIndex = DateIntervalInfo::calendarFieldToIntervalIndex(field,</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :                                                                         status);</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :     if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1524 </span>            :     }
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :     PatternInfo&amp;  timeItvPtnInfo = fIntervalPatterns[itvPtnIndex];</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     if ( !timeItvPtnInfo.firstPart.isEmpty() ) {</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :         UnicodeString timeIntervalPattern(timeItvPtnInfo.firstPart);</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         timeIntervalPattern.append(timeItvPtnInfo.secondPart);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         UnicodeString combinedPattern;</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :         SimpleFormatter(format, 2, 2, status).</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :                 format(timeIntervalPattern, datePattern, combinedPattern, status);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         if ( U_FAILURE(status) ) {</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1534 </span>            :         }
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :         setIntervalPattern(field, combinedPattern, timeItvPtnInfo.laterDateFirst);</span>
<span class="lineNum">    1536 </span>            :     }
<span class="lineNum">    1537 </span>            :     // else: fall back
<span class="lineNum">    1538 </span>            :     // it should not happen if the interval format defined is valid
<span class="lineNum">    1539 </span>            : }
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            : const UChar
<span class="lineNum">    1544 </span>            : DateIntervalFormat::fgCalendarFieldToPatternLetter[] =
<span class="lineNum">    1545 </span>            : {
<span class="lineNum">    1546 </span>            :     /*GyM*/ CAP_G, LOW_Y, CAP_M,
<span class="lineNum">    1547 </span>            :     /*wWd*/ LOW_W, CAP_W, LOW_D,
<span class="lineNum">    1548 </span>            :     /*DEF*/ CAP_D, CAP_E, CAP_F,
<span class="lineNum">    1549 </span>            :     /*ahH*/ LOW_A, LOW_H, CAP_H,
<span class="lineNum">    1550 </span>            :     /*msS*/ LOW_M, LOW_S, CAP_S, // MINUTE, SECOND, MILLISECOND
<span class="lineNum">    1551 </span>            :     /*z.Y*/ LOW_Z, SPACE, CAP_Y, // ZONE_OFFSET, DST_OFFSET, YEAR_WOY,
<span class="lineNum">    1552 </span>            :     /*eug*/ LOW_E, LOW_U, LOW_G, // DOW_LOCAL, EXTENDED_YEAR, JULIAN_DAY,
<span class="lineNum">    1553 </span>            :     /*A..*/ CAP_A, SPACE, SPACE, // MILLISECONDS_IN_DAY, IS_LEAP_MONTH, FIELD_COUNT
<span class="lineNum">    1554 </span>            : };
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            : U_NAMESPACE_END
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - netwerk/mime/nsMIMEHeaderParamImpl.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">netwerk/mime</a> - nsMIMEHeaderParamImpl.cpp<span style="font-size: 80%;"> (source / <a href="nsMIMEHeaderParamImpl.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">109</td>
            <td class="headerCovTableEntry">631</td>
            <td class="headerCovTableEntryLo">17.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntryLo">31.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set sw=4 ts=8 et tw=80 : */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &lt;string.h&gt;
<span class="lineNum">       8 </span>            : #include &quot;prprf.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;plstr.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;plbase64.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsCRT.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsMemory.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsEscape.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsIUTF8ConverterService.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsUConvCID.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsMIMEHeaderParamImpl.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsReadableUtils.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsNativeCharsetUtils.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsError.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/Encoding.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : using mozilla::Encoding;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // static functions declared below are moved from mailnews/mime/src/comi18n.cpp
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : static char *DecodeQ(const char *, uint32_t);
<span class="lineNum">      30 </span>            : static bool Is7bitNonAsciiString(const char *, uint32_t);
<span class="lineNum">      31 </span>            : static void CopyRawHeader(const char *, uint32_t, const char *, nsACString &amp;);
<span class="lineNum">      32 </span>            : static nsresult DecodeRFC2047Str(const char *, const char *, bool, nsACString&amp;);
<span class="lineNum">      33 </span>            : static nsresult internalDecodeParameter(const nsACString&amp;, const char*,
<span class="lineNum">      34 </span>            :                                         const char*, bool, bool, nsACString&amp;);
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : // XXX The chance of UTF-7 being used in the message header is really
<span class="lineNum">      37 </span>            : // low, but in theory it's possible.
<span class="lineNum">      38 </span>            : #define IS_7BIT_NON_ASCII_CHARSET(cset)            \
<span class="lineNum">      39 </span>            :     (!nsCRT::strncasecmp((cset), &quot;ISO-2022&quot;, 8) || \
<span class="lineNum">      40 </span>            :      !nsCRT::strncasecmp((cset), &quot;HZ-GB&quot;, 5)    || \
<a name="41"><span class="lineNum">      41 </span>            :      !nsCRT::strncasecmp((cset), &quot;UTF-7&quot;, 5))</a>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineCov">         18 : NS_IMPL_ISUPPORTS(nsMIMEHeaderParamImpl, nsIMIMEHeaderParam)</span>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<span class="lineNum">      45 </span>            : NS_IMETHODIMP
<span class="lineNum">      46 </span><span class="lineNoCov">          0 : nsMIMEHeaderParamImpl::GetParameter(const nsACString&amp; aHeaderVal,</span>
<span class="lineNum">      47 </span>            :                                     const char *aParamName,
<span class="lineNum">      48 </span>            :                                     const nsACString&amp; aFallbackCharset,
<span class="lineNum">      49 </span>            :                                     bool aTryLocaleCharset,
<span class="lineNum">      50 </span>            :                                     char **aLang, nsAString&amp; aResult)
<span class="lineNum">      51 </span>            : {
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   return DoGetParameter(aHeaderVal, aParamName, MIME_FIELD_ENCODING,</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :                         aFallbackCharset, aTryLocaleCharset, aLang, aResult);</span>
<span class="lineNum">      54 </span>            : }
<a name="55"><span class="lineNum">      55 </span>            : </a>
<span class="lineNum">      56 </span>            : NS_IMETHODIMP
<span class="lineNum">      57 </span><span class="lineCov">         10 : nsMIMEHeaderParamImpl::GetParameterHTTP(const nsACString&amp; aHeaderVal,</span>
<span class="lineNum">      58 </span>            :                                         const char *aParamName,
<span class="lineNum">      59 </span>            :                                         const nsACString&amp; aFallbackCharset,
<span class="lineNum">      60 </span>            :                                         bool aTryLocaleCharset,
<span class="lineNum">      61 </span>            :                                         char **aLang, nsAString&amp; aResult)
<span class="lineNum">      62 </span>            : {
<span class="lineNum">      63 </span><span class="lineCov">         10 :   return DoGetParameter(aHeaderVal, aParamName, HTTP_FIELD_ENCODING,</span>
<span class="lineNum">      64 </span><span class="lineCov">         10 :                         aFallbackCharset, aTryLocaleCharset, aLang, aResult);</span>
<span class="lineNum">      65 </span>            : }
<span class="lineNum">      66 </span>            : 
<a name="67"><span class="lineNum">      67 </span>            : // XXX : aTryLocaleCharset is not yet effective.</a>
<span class="lineNum">      68 </span>            : nsresult
<span class="lineNum">      69 </span><span class="lineCov">         10 : nsMIMEHeaderParamImpl::DoGetParameter(const nsACString&amp; aHeaderVal,</span>
<span class="lineNum">      70 </span>            :                                       const char *aParamName,
<span class="lineNum">      71 </span>            :                                       ParamDecoding aDecoding,
<span class="lineNum">      72 </span>            :                                       const nsACString&amp; aFallbackCharset,
<span class="lineNum">      73 </span>            :                                       bool aTryLocaleCharset,
<span class="lineNum">      74 </span>            :                                       char **aLang, nsAString&amp; aResult)
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span><span class="lineCov">         10 :     aResult.Truncate();</span>
<span class="lineNum">      77 </span>            :     nsresult rv;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :     // get parameter (decode RFC 2231/5987 when applicable, as specified by
<span class="lineNum">      80 </span>            :     // aDecoding (5987 being a subset of 2231) and return charset.)
<span class="lineNum">      81 </span><span class="lineCov">         20 :     nsXPIDLCString med;</span>
<span class="lineNum">      82 </span><span class="lineCov">         20 :     nsXPIDLCString charset;</span>
<span class="lineNum">      83 </span><span class="lineCov">         30 :     rv = DoParameterInternal(PromiseFlatCString(aHeaderVal).get(), aParamName,</span>
<span class="lineNum">      84 </span><span class="lineCov">         20 :                              aDecoding, getter_Copies(charset), aLang,</span>
<span class="lineNum">      85 </span><span class="lineCov">         30 :                              getter_Copies(med));</span>
<span class="lineNum">      86 </span><span class="lineCov">         10 :     if (NS_FAILED(rv))</span>
<span class="lineNum">      87 </span><span class="lineCov">          5 :         return rv;</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     // convert to UTF-8 after charset conversion and RFC 2047 decoding
<span class="lineNum">      90 </span>            :     // if necessary.
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span><span class="lineCov">         10 :     nsAutoCString str1;</span>
<span class="lineNum">      93 </span><span class="lineCov">          5 :     rv = internalDecodeParameter(med, charset.get(), nullptr, false,</span>
<span class="lineNum">      94 </span>            :                                  // was aDecoding == MIME_FIELD_ENCODING
<span class="lineNum">      95 </span>            :                                  // see bug 875615
<span class="lineNum">      96 </span>            :                                  true,
<span class="lineNum">      97 </span><span class="lineCov">          5 :                                  str1);</span>
<span class="lineNum">      98 </span><span class="lineCov">          5 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span><span class="lineCov">          5 :     if (!aFallbackCharset.IsEmpty())</span>
<span class="lineNum">     101 </span>            :     {
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         const Encoding* encoding = Encoding::ForLabel(aFallbackCharset);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         nsAutoCString str2;</span>
<span class="lineNum">     104 </span>            :         nsCOMPtr&lt;nsIUTF8ConverterService&gt;
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :           cvtUTF8(do_GetService(NS_UTF8CONVERTERSERVICE_CONTRACTID));</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :         if (cvtUTF8 &amp;&amp;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :             NS_SUCCEEDED(cvtUTF8-&gt;ConvertStringToUTF8(str1,</span>
<span class="lineNum">     108 </span>            :                 PromiseFlatCString(aFallbackCharset).get(), false,
<span class="lineNum">     109 </span>            :                                    encoding != UTF_8_ENCODING,
<span class="lineNum">     110 </span>            :                                    1, str2))) {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :           CopyUTF8toUTF16(str2, aResult);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :           return NS_OK;</span>
<span class="lineNum">     113 </span>            :         }
<span class="lineNum">     114 </span>            :     }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineCov">          5 :     if (IsUTF8(str1)) {</span>
<span class="lineNum">     117 </span><span class="lineCov">          5 :       CopyUTF8toUTF16(str1, aResult);</span>
<span class="lineNum">     118 </span><span class="lineCov">          5 :       return NS_OK;</span>
<span class="lineNum">     119 </span>            :     }
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     if (aTryLocaleCharset &amp;&amp; !NS_IsNativeUTF8())</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       return NS_CopyNativeToUnicode(str1, aResult);</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     CopyASCIItoUTF16(str1, aResult);</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     126 </span>            : }
<span class="lineNum">     127 </span>            : 
<a name="128"><span class="lineNum">     128 </span>            : // remove backslash-encoded sequences from quoted-strings</a>
<span class="lineNum">     129 </span>            : // modifies string in place, potentially shortening it
<span class="lineNum">     130 </span><span class="lineNoCov">          0 : void RemoveQuotedStringEscapes(char *src)</span>
<span class="lineNum">     131 </span>            : {
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   char *dst = src;</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   for (char *c = src; *c; ++c)</span>
<span class="lineNum">     135 </span>            :   {
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     if (c[0] == '\\' &amp;&amp; c[1])</span>
<span class="lineNum">     137 </span>            :     {
<span class="lineNum">     138 </span>            :       // skip backslash if not at end
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :       ++c;</span>
<span class="lineNum">     140 </span>            :     }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     *dst++ = *c;</span>
<span class="lineNum">     142 </span>            :   }
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   *dst = 0;</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 : }</span>
<a name="145"><span class="lineNum">     145 </span>            : </a>
<span class="lineNum">     146 </span>            : // true is character is a hex digit
<span class="lineNum">     147 </span><span class="lineNoCov">          0 : bool IsHexDigit(char aChar)</span>
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   char c = aChar;</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   return (c &gt;= 'a' &amp;&amp; c &lt;= 'f') ||</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :          (c &gt;= 'A' &amp;&amp; c &lt;= 'F') ||</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :          (c &gt;= '0' &amp;&amp; c &lt;= '9');</span>
<span class="lineNum">     154 </span>            : }
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : // validate that a C String containing %-escapes is syntactically valid
<span class="lineNum">     157 </span><span class="lineNoCov">          0 : bool IsValidPercentEscaped(const char *aValue, int32_t len)</span>
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   for (int32_t i = 0; i &lt; len; i++) {</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     if (aValue[i] == '%') {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       if (!IsHexDigit(aValue[i + 1]) || !IsHexDigit(aValue[i + 2])) {</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     163 </span>            :       }
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span>            :   }
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     167 </span>            : }
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : // Support for continuations (RFC 2231, Section 3)
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : // only a sane number supported
<span class="lineNum">     172 </span>            : #define MAX_CONTINUATIONS 999
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : // part of a continuation
<span class="lineNum">     175 </span>            : 
<a name="176"><span class="lineNum">     176 </span>            : class Continuation {</a>
<span class="lineNum">     177 </span>            :   public:
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     Continuation(const char *aValue, uint32_t aLength,</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                  bool aNeedsPercentDecoding, bool aWasQuotedString) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :       value = aValue;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       length = aLength;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       needsPercentDecoding = aNeedsPercentDecoding;</span>
<a name="183"><span class="lineNum">     183 </span><span class="lineNoCov">          0 :       wasQuotedString = aWasQuotedString;</span></a>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     Continuation() {</span>
<span class="lineNum">     186 </span>            :       // empty constructor needed for nsTArray
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       value = nullptr;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :       length = 0;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       needsPercentDecoding = false;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       wasQuotedString = false;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     192 </span>            :     ~Continuation() = default;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     const char *value;
<span class="lineNum">     195 </span>            :     uint32_t length;
<span class="lineNum">     196 </span>            :     bool needsPercentDecoding;
<span class="lineNum">     197 </span>            :     bool wasQuotedString;
<span class="lineNum">     198 </span>            : };
<span class="lineNum">     199 </span>            : 
<a name="200"><span class="lineNum">     200 </span>            : // combine segments into a single string, returning the allocated string</a>
<span class="lineNum">     201 </span>            : // (or nullptr) while emptying the list
<span class="lineNum">     202 </span><span class="lineCov">          5 : char *combineContinuations(nsTArray&lt;Continuation&gt;&amp; aArray)</span>
<span class="lineNum">     203 </span>            : {
<span class="lineNum">     204 </span>            :   // Sanity check
<span class="lineNum">     205 </span><span class="lineCov">          5 :   if (aArray.Length() == 0)</span>
<span class="lineNum">     206 </span><span class="lineCov">          5 :     return nullptr;</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :   // Get an upper bound for the length
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   uint32_t length = 0;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; aArray.Length(); i++) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     length += aArray[i].length;</span>
<span class="lineNum">     212 </span>            :   }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :   // Allocate
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   char *result = (char *) moz_xmalloc(length + 1);</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   // Concatenate
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   if (result) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     *result = '\0';</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; aArray.Length(); i++) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       Continuation cont = aArray[i];</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       if (! cont.value) break;</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       char *c = result + strlen(result);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       strncat(result, cont.value, cont.length);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       if (cont.needsPercentDecoding) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         nsUnescape(c);</span>
<span class="lineNum">     229 </span>            :       }
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :       if (cont.wasQuotedString) {</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         RemoveQuotedStringEscapes(c);</span>
<span class="lineNum">     232 </span>            :       }
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :     // return null if empty value
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     if (*result == '\0') {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       free(result);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       result = nullptr;</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            :   } else {
<span class="lineNum">     241 </span>            :     // Handle OOM
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Out of memory\n&quot;);</span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     246 </span>            : }
<a name="247"><span class="lineNum">     247 </span>            : </a>
<span class="lineNum">     248 </span>            : // add a continuation, return false on error if segment already has been seen
<span class="lineNum">     249 </span><span class="lineNoCov">          0 : bool addContinuation(nsTArray&lt;Continuation&gt;&amp; aArray, uint32_t aIndex,</span>
<span class="lineNum">     250 </span>            :                      const char *aValue, uint32_t aLength,
<span class="lineNum">     251 </span>            :                      bool aNeedsPercentDecoding, bool aWasQuotedString)
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   if (aIndex &lt; aArray.Length() &amp;&amp; aArray[aIndex].value) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;duplicate RC2231 continuation segment #\n&quot;);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     256 </span>            :   }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   if (aIndex &gt; MAX_CONTINUATIONS) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;RC2231 continuation segment # exceeds limit\n&quot;);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     261 </span>            :   }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   if (aNeedsPercentDecoding &amp;&amp; aWasQuotedString) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;RC2231 continuation segment can't use percent encoding and quoted string form at the same time\n&quot;);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     266 </span>            :   }
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   Continuation cont(aValue, aLength, aNeedsPercentDecoding, aWasQuotedString);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   if (aArray.Length() &lt;= aIndex) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     aArray.SetLength(aIndex + 1);</span>
<span class="lineNum">     272 </span>            :   }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   aArray[aIndex] = cont;</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     276 </span>            : }
<a name="277"><span class="lineNum">     277 </span>            : </a>
<span class="lineNum">     278 </span>            : // parse a segment number; return -1 on error
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : int32_t parseSegmentNumber(const char *aValue, int32_t aLen)</span>
<span class="lineNum">     280 </span>            : {
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   if (aLen &lt; 1) {</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;segment number missing\n&quot;);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     284 </span>            :   }
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   if (aLen &gt; 1 &amp;&amp; aValue[0] == '0') {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;leading '0' not allowed in segment number\n&quot;);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     289 </span>            :   }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   int32_t segmentNumber = 0;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   for (int32_t i = 0; i &lt; aLen; i++) {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     if (! (aValue[i] &gt;= '0' &amp;&amp; aValue[i] &lt;= '9')) {</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       NS_WARNING(&quot;invalid characters in segment number\n&quot;);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     segmentNumber *= 10;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     segmentNumber += aValue[i] - '0';</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     if (segmentNumber &gt; MAX_CONTINUATIONS) {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       NS_WARNING(&quot;Segment number exceeds sane size\n&quot;);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            :   }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   return segmentNumber;</span>
<span class="lineNum">     308 </span>            : }
<span class="lineNum">     309 </span>            : 
<a name="310"><span class="lineNum">     310 </span>            : // validate a given octet sequence for compliance with the specified</a>
<span class="lineNum">     311 </span>            : // encoding
<span class="lineNum">     312 </span><span class="lineNoCov">          0 : bool IsValidOctetSequenceForCharset(nsACString&amp; aCharset, const char *aOctets)</span>
<span class="lineNum">     313 </span>            : {
<span class="lineNum">     314 </span>            :   nsCOMPtr&lt;nsIUTF8ConverterService&gt; cvtUTF8(do_GetService
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     (NS_UTF8CONVERTERSERVICE_CONTRACTID));</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if (!cvtUTF8) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Can't get UTF8ConverterService\n&quot;);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     319 </span>            :   }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   nsAutoCString tmpRaw;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   tmpRaw.Assign(aOctets);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   nsAutoCString tmpDecoded;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   nsresult rv = cvtUTF8-&gt;ConvertStringToUTF8(tmpRaw,</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                                              PromiseFlatCString(aCharset).get(),</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                                              false, false, 1, tmpDecoded);</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   if (rv != NS_OK) {</span>
<span class="lineNum">     330 </span>            :     // we can't decode; charset may be unsupported, or the octet sequence
<span class="lineNum">     331 </span>            :     // is broken (illegal or incomplete octet sequence contained)
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;RFC2231/5987 parameter value does not decode according to specified charset\n&quot;);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     337 </span>            : }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : // moved almost verbatim from mimehdrs.cpp
<span class="lineNum">     340 </span>            : // char *
<span class="lineNum">     341 </span>            : // MimeHeaders_get_parameter (const char *header_value, const char *parm_name,
<span class="lineNum">     342 </span>            : //                            char **charset, char **language)
<span class="lineNum">     343 </span>            : //
<span class="lineNum">     344 </span>            : // The format of these header lines  is
<a name="345"><span class="lineNum">     345 </span>            : // &lt;token&gt; [ ';' &lt;token&gt; '=' &lt;token-or-quoted-string&gt; ]*</a>
<span class="lineNum">     346 </span>            : NS_IMETHODIMP
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : nsMIMEHeaderParamImpl::GetParameterInternal(const char *aHeaderValue,</span>
<span class="lineNum">     348 </span>            :                                             const char *aParamName,
<span class="lineNum">     349 </span>            :                                             char **aCharset,
<span class="lineNum">     350 </span>            :                                             char **aLang,
<span class="lineNum">     351 </span>            :                                             char **aResult)
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span>            :   return DoParameterInternal(aHeaderValue, aParamName, MIME_FIELD_ENCODING,
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                              aCharset, aLang, aResult);</span>
<span class="lineNum">     355 </span>            : }
<span class="lineNum">     356 </span>            : 
<a name="357"><span class="lineNum">     357 </span>            : </a>
<span class="lineNum">     358 </span>            : nsresult
<span class="lineNum">     359 </span><span class="lineCov">         10 : nsMIMEHeaderParamImpl::DoParameterInternal(const char *aHeaderValue,</span>
<span class="lineNum">     360 </span>            :                                            const char *aParamName,
<span class="lineNum">     361 </span>            :                                            ParamDecoding aDecoding,
<span class="lineNum">     362 </span>            :                                            char **aCharset,
<span class="lineNum">     363 </span>            :                                            char **aLang,
<span class="lineNum">     364 </span>            :                                            char **aResult)
<span class="lineNum">     365 </span>            : {
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineCov">         10 :   if (!aHeaderValue ||  !*aHeaderValue || !aResult)</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineCov">         10 :   *aResult = nullptr;</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineCov">         10 :   if (aCharset) *aCharset = nullptr;</span>
<span class="lineNum">     373 </span><span class="lineCov">         10 :   if (aLang) *aLang = nullptr;</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">         20 :   nsAutoCString charset;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   // change to (aDecoding != HTTP_FIELD_ENCODING) when we want to disable
<span class="lineNum">     378 </span>            :   // them for HTTP header fields later on, see bug 776324
<span class="lineNum">     379 </span><span class="lineCov">         10 :   bool acceptContinuations = true;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">         10 :   const char *str = aHeaderValue;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   // skip leading white space.
<span class="lineNum">     384 </span><span class="lineCov">         10 :   for (; *str &amp;&amp;  nsCRT::IsAsciiSpace(*str); ++str)</span>
<span class="lineNum">     385 </span>            :     ;
<span class="lineNum">     386 </span><span class="lineCov">         10 :   const char *start = str;</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   // aParamName is empty. return the first (possibly) _unnamed_ 'parameter'
<span class="lineNum">     389 </span>            :   // For instance, return 'inline' in the following case:
<span class="lineNum">     390 </span>            :   // Content-Disposition: inline; filename=.....
<span class="lineNum">     391 </span><span class="lineCov">         10 :   if (!aParamName || !*aParamName)</span>
<span class="lineNum">     392 </span>            :     {
<span class="lineNum">     393 </span><span class="lineCov">         80 :       for (; *str &amp;&amp; *str != ';' &amp;&amp; !nsCRT::IsAsciiSpace(*str); ++str)</span>
<span class="lineNum">     394 </span>            :         ;
<span class="lineNum">     395 </span><span class="lineCov">          5 :       if (str == start)</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         return NS_ERROR_FIRST_HEADER_FIELD_COMPONENT_EMPTY;</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineCov">          5 :       *aResult = (char *) nsMemory::Clone(start, (str - start) + 1);</span>
<span class="lineNum">     399 </span><span class="lineCov">          5 :       NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     400 </span><span class="lineCov">          5 :       (*aResult)[str - start] = '\0';  // null-terminate</span>
<span class="lineNum">     401 </span><span class="lineCov">          5 :       return NS_OK;</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   /* Skip forward to first ';' */
<span class="lineNum">     405 </span><span class="lineCov">         80 :   for (; *str &amp;&amp; *str != ';' &amp;&amp; *str != ','; ++str)</span>
<span class="lineNum">     406 </span>            :     ;
<span class="lineNum">     407 </span><span class="lineCov">          5 :   if (*str)</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     str++;</span>
<span class="lineNum">     409 </span>            :   /* Skip over following whitespace */
<span class="lineNum">     410 </span><span class="lineCov">          5 :   for (; *str &amp;&amp; nsCRT::IsAsciiSpace(*str); ++str)</span>
<span class="lineNum">     411 </span>            :     ;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :   // Some broken http servers just specify parameters
<span class="lineNum">     414 </span>            :   // like 'filename' without specifying disposition
<span class="lineNum">     415 </span>            :   // method. Rewind to the first non-white-space
<span class="lineNum">     416 </span>            :   // character.
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">          5 :   if (!*str)</span>
<span class="lineNum">     419 </span><span class="lineCov">          5 :     str = start;</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :   // RFC2231 - The legitimate parm format can be:
<span class="lineNum">     422 </span>            :   // A. title=ThisIsTitle
<span class="lineNum">     423 </span>            :   // B. title*=us-ascii'en-us'This%20is%20wierd.
<span class="lineNum">     424 </span>            :   // C. title*0*=us-ascii'en'This%20is%20wierd.%20We
<span class="lineNum">     425 </span>            :   //    title*1*=have%20to%20support%20this.
<span class="lineNum">     426 </span>            :   //    title*2=&quot;Else...&quot;
<span class="lineNum">     427 </span>            :   // D. title*0=&quot;Hey, what you think you are doing?&quot;
<span class="lineNum">     428 </span>            :   //    title*1=&quot;There is no charset and lang info.&quot;
<span class="lineNum">     429 </span>            :   // RFC5987: only A and B
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   // collect results for the different algorithms (plain filename,
<span class="lineNum">     432 </span>            :   // RFC5987/2231-encoded filename, + continuations) separately and decide
<span class="lineNum">     433 </span>            :   // which to use at the end
<span class="lineNum">     434 </span><span class="lineCov">          5 :   char *caseAResult = nullptr;</span>
<span class="lineNum">     435 </span><span class="lineCov">          5 :   char *caseBResult = nullptr;</span>
<span class="lineNum">     436 </span><span class="lineCov">          5 :   char *caseCDResult = nullptr;</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // collect continuation segments
<span class="lineNum">     439 </span><span class="lineCov">         10 :   nsTArray&lt;Continuation&gt; segments;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :   // our copies of the charset parameter, kept separately as they might
<span class="lineNum">     443 </span>            :   // differ for the two formats
<span class="lineNum">     444 </span><span class="lineCov">         10 :   nsDependentCSubstring charsetB, charsetCD;</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineCov">         10 :   nsDependentCSubstring lang;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">          5 :   int32_t paramLen = strlen(aParamName);</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineCov">          5 :   while (*str) {</span>
<span class="lineNum">     451 </span>            :     // find name/value
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">          5 :     const char *nameStart = str;</span>
<span class="lineNum">     454 </span><span class="lineCov">          5 :     const char *nameEnd = nullptr;</span>
<span class="lineNum">     455 </span><span class="lineCov">          5 :     const char *valueStart = str;</span>
<span class="lineNum">     456 </span><span class="lineCov">          5 :     const char *valueEnd = nullptr;</span>
<span class="lineNum">     457 </span><span class="lineCov">          5 :     bool isQuotedString = false;</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">          5 :     NS_ASSERTION(!nsCRT::IsAsciiSpace(*str), &quot;should be after whitespace.&quot;);</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :     // Skip forward to the end of this token.
<span class="lineNum">     462 </span><span class="lineCov">         80 :     for (; *str &amp;&amp; !nsCRT::IsAsciiSpace(*str) &amp;&amp; *str != '=' &amp;&amp; *str != ';'; str++)</span>
<span class="lineNum">     463 </span>            :       ;
<span class="lineNum">     464 </span><span class="lineCov">          5 :     nameEnd = str;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">          5 :     int32_t nameLen = nameEnd - nameStart;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :     // Skip over whitespace, '=', and whitespace
<span class="lineNum">     469 </span><span class="lineCov">          5 :     while (nsCRT::IsAsciiSpace(*str)) ++str;</span>
<span class="lineNum">     470 </span><span class="lineCov">          5 :     if (!*str) {</span>
<span class="lineNum">     471 </span><span class="lineCov">          5 :       break;</span>
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     if (*str++ != '=') {</span>
<span class="lineNum">     474 </span>            :       // don't accept parameters without &quot;=&quot;
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       goto increment_str;</span>
<span class="lineNum">     476 </span>            :     }
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     while (nsCRT::IsAsciiSpace(*str)) ++str;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     if (*str != '&quot;') {</span>
<span class="lineNum">     480 </span>            :       // The value is a token, not a quoted string.
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       valueStart = str;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       for (valueEnd = str;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :            *valueEnd &amp;&amp; !nsCRT::IsAsciiSpace (*valueEnd) &amp;&amp; *valueEnd != ';';</span>
<span class="lineNum">     484 </span>            :            valueEnd++)
<span class="lineNum">     485 </span>            :         ;
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       str = valueEnd;</span>
<span class="lineNum">     487 </span>            :     } else {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       isQuotedString = true;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       ++str;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       valueStart = str;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       for (valueEnd = str; *valueEnd; ++valueEnd) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         if (*valueEnd == '\\' &amp;&amp; *(valueEnd + 1))</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :           ++valueEnd;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         else if (*valueEnd == '&quot;')</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     497 </span>            :       }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       str = valueEnd;</span>
<span class="lineNum">     499 </span>            :       // *valueEnd != null means that *valueEnd is quote character.
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       if (*valueEnd)</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         str++;</span>
<span class="lineNum">     502 </span>            :     }
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :     // See if this is the simplest case (case A above),
<span class="lineNum">     505 </span>            :     // a 'single' line value with no charset and lang.
<span class="lineNum">     506 </span>            :     // If so, copy it and return.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     if (nameLen == paramLen &amp;&amp;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         !nsCRT::strncasecmp(nameStart, aParamName, paramLen)) {</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :       if (caseAResult) {</span>
<span class="lineNum">     511 </span>            :         // we already have one caseA result, ignore subsequent ones
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         goto increment_str;</span>
<span class="lineNum">     513 </span>            :       }
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :       // if the parameter spans across multiple lines we have to strip out the
<span class="lineNum">     516 </span>            :       //     line continuation -- jht 4/29/98
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       nsAutoCString tempStr(valueStart, valueEnd - valueStart);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       tempStr.StripCRLF();</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       char *res = ToNewCString(tempStr);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       NS_ENSURE_TRUE(res, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       if (isQuotedString)</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         RemoveQuotedStringEscapes(res);</span>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :       caseAResult = res;</span>
<span class="lineNum">     526 </span>            :       // keep going, we may find a RFC 2231/5987 encoded alternative
<span class="lineNum">     527 </span>            :     }
<span class="lineNum">     528 </span>            :     // case B, C, and D
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     else if (nameLen &gt; paramLen &amp;&amp;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :              !nsCRT::strncasecmp(nameStart, aParamName, paramLen) &amp;&amp;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :              *(nameStart + paramLen) == '*') {</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :       // 1st char past '*'
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       const char *cp = nameStart + paramLen + 1;</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :       // if param name ends in &quot;*&quot; we need do to RFC5987 &quot;ext-value&quot; decoding
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       bool needExtDecoding = *(nameEnd - 1) == '*';</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :       bool caseB = nameLen == paramLen + 1;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       bool caseCStart = (*cp == '0') &amp;&amp; needExtDecoding;</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            :       // parse the segment number
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       int32_t segmentNumber = -1;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :       if (!caseB) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         int32_t segLen = (nameEnd - cp) - (needExtDecoding ? 1 : 0);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         segmentNumber = parseSegmentNumber(cp, segLen);</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         if (segmentNumber == -1) {</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :           acceptContinuations = false;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :           goto increment_str;</span>
<span class="lineNum">     551 </span>            :         }
<span class="lineNum">     552 </span>            :       }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :       // CaseB and start of CaseC: requires charset and optional language
<span class="lineNum">     555 </span>            :       // in quotes (quotes required even if lang is blank)
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       if (caseB || (caseCStart &amp;&amp; acceptContinuations)) {</span>
<span class="lineNum">     557 </span>            :         // look for single quotation mark(')
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :         const char *sQuote1 = PL_strchr(valueStart, 0x27);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         const char *sQuote2 = sQuote1 ? PL_strchr(sQuote1 + 1, 0x27) : nullptr;</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :         // Two single quotation marks must be present even in
<span class="lineNum">     562 </span>            :         // absence of charset and lang.
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         if (!sQuote1 || !sQuote2) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :           NS_WARNING(&quot;Mandatory two single quotes are missing in header parameter\n&quot;);</span>
<span class="lineNum">     565 </span>            :         }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         const char *charsetStart = nullptr;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         int32_t charsetLength = 0;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         const char *langStart = nullptr;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         int32_t langLength = 0;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         const char *rawValStart = nullptr;</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         int32_t rawValLength = 0;</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         if (sQuote2 &amp;&amp; sQuote1) {</span>
<span class="lineNum">     575 </span>            :           // both delimiters present: charSet'lang'rawVal
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :           rawValStart = sQuote2 + 1;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :           rawValLength = valueEnd - rawValStart;</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :           langStart = sQuote1 + 1;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :           langLength = sQuote2 - langStart;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :           charsetStart = valueStart;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :           charsetLength = sQuote1 - charsetStart;</span>
<span class="lineNum">     584 </span>            :         }
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :         else if (sQuote1) {</span>
<span class="lineNum">     586 </span>            :           // one delimiter; assume charset'rawVal
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :           rawValStart = sQuote1 + 1;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :           rawValLength = valueEnd - rawValStart;</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :           charsetStart = valueStart;</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :           charsetLength = sQuote1 - valueStart;</span>
<span class="lineNum">     592 </span>            :         }
<span class="lineNum">     593 </span>            :         else {
<span class="lineNum">     594 </span>            :           // no delimiter: just rawVal
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :           rawValStart = valueStart;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :           rawValLength = valueEnd - valueStart;</span>
<span class="lineNum">     597 </span>            :         }
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :         if (langLength != 0) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :           lang.Assign(langStart, langLength);</span>
<span class="lineNum">     601 </span>            :         }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :         // keep the charset for later
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         if (caseB) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :           charsetB.Assign(charsetStart, charsetLength);</span>
<span class="lineNum">     606 </span>            :         } else {
<span class="lineNum">     607 </span>            :           // if caseCorD
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :           charsetCD.Assign(charsetStart, charsetLength);</span>
<span class="lineNum">     609 </span>            :         }
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :         // non-empty value part
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         if (rawValLength &gt; 0) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           if (!caseBResult &amp;&amp; caseB) {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :             if (!IsValidPercentEscaped(rawValStart, rawValLength)) {</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :               goto increment_str;</span>
<span class="lineNum">     616 </span>            :             }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :             // allocate buffer for the raw value
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :             char *tmpResult = (char *) nsMemory::Clone(rawValStart, rawValLength + 1);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             if (!tmpResult) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :               goto increment_str;</span>
<span class="lineNum">     622 </span>            :             }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             *(tmpResult + rawValLength) = 0;</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :             nsUnescape(tmpResult);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :             caseBResult = tmpResult;</span>
<span class="lineNum">     627 </span>            :           } else {
<span class="lineNum">     628 </span>            :             // caseC
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             bool added = addContinuation(segments, 0, rawValStart,</span>
<span class="lineNum">     630 </span>            :                                          rawValLength, needExtDecoding,
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                                          isQuotedString);</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :             if (!added) {</span>
<span class="lineNum">     634 </span>            :               // continuation not added, stop processing them
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :               acceptContinuations = false;</span>
<span class="lineNum">     636 </span>            :             }
<span class="lineNum">     637 </span>            :           }
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     639 </span>            :       }  // end of if-block :  title*0*=  or  title*=
<span class="lineNum">     640 </span>            :       // caseD: a line of multiline param with no need for unescaping : title*[0-9]=
<span class="lineNum">     641 </span>            :       // or 2nd or later lines of a caseC param : title*[1-9]*=
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       else if (acceptContinuations &amp;&amp; segmentNumber != -1) {</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :         uint32_t valueLength = valueEnd - valueStart;</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         bool added = addContinuation(segments, segmentNumber, valueStart,</span>
<span class="lineNum">     646 </span>            :                                      valueLength, needExtDecoding,
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :                                      isQuotedString);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         if (!added) {</span>
<span class="lineNum">     650 </span>            :           // continuation not added, stop processing them
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :           acceptContinuations = false;</span>
<span class="lineNum">     652 </span>            :         }
<span class="lineNum">     653 </span>            :       } // end of if-block :  title*[0-9]= or title*[1-9]*=
<span class="lineNum">     654 </span>            :     }
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :     // str now points after the end of the value.
<span class="lineNum">     657 </span>            :     //   skip over whitespace, ';', whitespace.
<span class="lineNum">     658 </span>            : increment_str:
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     while (nsCRT::IsAsciiSpace(*str)) ++str;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     if (*str == ';') {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :       ++str;</span>
<span class="lineNum">     662 </span>            :     } else {
<span class="lineNum">     663 </span>            :       // stop processing the header field; either we are done or the
<span class="lineNum">     664 </span>            :       // separator was missing
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     666 </span>            :     }
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     while (nsCRT::IsAsciiSpace(*str)) ++str;</span>
<span class="lineNum">     668 </span>            :   }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineCov">          5 :   caseCDResult = combineContinuations(segments);</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineCov">          5 :   if (caseBResult &amp;&amp; !charsetB.IsEmpty()) {</span>
<span class="lineNum">     673 </span>            :     // check that the 2231/5987 result decodes properly given the
<span class="lineNum">     674 </span>            :     // specified character set
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     if (!IsValidOctetSequenceForCharset(charsetB, caseBResult))</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :       caseBResult = nullptr;</span>
<span class="lineNum">     677 </span>            :   }
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span><span class="lineCov">          5 :   if (caseCDResult &amp;&amp; !charsetCD.IsEmpty()) {</span>
<span class="lineNum">     680 </span>            :     // check that the 2231/5987 result decodes properly given the
<span class="lineNum">     681 </span>            :     // specified character set
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     if (!IsValidOctetSequenceForCharset(charsetCD, caseCDResult))</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :       caseCDResult = nullptr;</span>
<span class="lineNum">     684 </span>            :   }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineCov">          5 :   if (caseBResult) {</span>
<span class="lineNum">     687 </span>            :     // prefer simple 5987 format over 2231 with continuations
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     *aResult = caseBResult;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     caseBResult = nullptr;</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     charset.Assign(charsetB);</span>
<span class="lineNum">     691 </span>            :   }
<span class="lineNum">     692 </span><span class="lineCov">          5 :   else if (caseCDResult) {</span>
<span class="lineNum">     693 </span>            :     // prefer 2231/5987 with or without continuations over plain format
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     *aResult = caseCDResult;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     caseCDResult = nullptr;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     charset.Assign(charsetCD);</span>
<span class="lineNum">     697 </span>            :   }
<span class="lineNum">     698 </span><span class="lineCov">          5 :   else if (caseAResult) {</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     *aResult = caseAResult;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     caseAResult = nullptr;</span>
<span class="lineNum">     701 </span>            :   }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :   // free unused stuff
<span class="lineNum">     704 </span><span class="lineCov">          5 :   free(caseAResult);</span>
<span class="lineNum">     705 </span><span class="lineCov">          5 :   free(caseBResult);</span>
<span class="lineNum">     706 </span><span class="lineCov">          5 :   free(caseCDResult);</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :   // if we have a result
<span class="lineNum">     709 </span><span class="lineCov">          5 :   if (*aResult) {</span>
<span class="lineNum">     710 </span>            :     // then return charset and lang as well
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     if (aLang &amp;&amp; !lang.IsEmpty()) {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       uint32_t len = lang.Length();</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       *aLang = (char *) nsMemory::Clone(lang.BeginReading(), len + 1);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :       if (*aLang) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         *(*aLang + len) = 0;</span>
<span class="lineNum">     716 </span>            :       }
<span class="lineNum">     717 </span>            :    }
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     if (aCharset &amp;&amp; !charset.IsEmpty()) {</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       uint32_t len = charset.Length();</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       *aCharset = (char *) nsMemory::Clone(charset.BeginReading(), len + 1);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       if (*aCharset) {</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         *(*aCharset + len) = 0;</span>
<span class="lineNum">     723 </span>            :       }
<span class="lineNum">     724 </span>            :     }
<span class="lineNum">     725 </span>            :   }
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">          5 :   return *aResult ? NS_OK : NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     728 </span>            : }
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : nsresult
<span class="lineNum">     731 </span><span class="lineCov">          5 : internalDecodeRFC2047Header(const char* aHeaderVal, const char* aDefaultCharset,</span>
<span class="lineNum">     732 </span>            :                             bool aOverrideCharset, bool aEatContinuations,
<span class="lineNum">     733 </span>            :                             nsACString&amp; aResult)
<span class="lineNum">     734 </span>            : {
<span class="lineNum">     735 </span><span class="lineCov">          5 :   aResult.Truncate();</span>
<span class="lineNum">     736 </span><span class="lineCov">          5 :   if (!aHeaderVal)</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     738 </span><span class="lineCov">          5 :   if (!*aHeaderVal)</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :   // If aHeaderVal is RFC 2047 encoded or is not a UTF-8 string  but
<span class="lineNum">     743 </span>            :   // aDefaultCharset is specified, decodes RFC 2047 encoding and converts
<span class="lineNum">     744 </span>            :   // to UTF-8. Otherwise, just strips away CRLF.
<span class="lineNum">     745 </span><span class="lineCov">         15 :   if (PL_strstr(aHeaderVal, &quot;=?&quot;) ||</span>
<span class="lineNum">     746 </span><span class="lineCov">          5 :       (aDefaultCharset &amp;&amp; (!IsUTF8(nsDependentCString(aHeaderVal)) ||</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       Is7bitNonAsciiString(aHeaderVal, strlen(aHeaderVal))))) {</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     DecodeRFC2047Str(aHeaderVal, aDefaultCharset, aOverrideCharset, aResult);</span>
<span class="lineNum">     749 </span><span class="lineCov">         10 :   } else if (aEatContinuations &amp;&amp;</span>
<span class="lineNum">     750 </span><span class="lineCov">         10 :              (PL_strchr(aHeaderVal, '\n') || PL_strchr(aHeaderVal, '\r'))) {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     aResult = aHeaderVal;</span>
<span class="lineNum">     752 </span>            :   } else {
<span class="lineNum">     753 </span><span class="lineCov">          5 :     aEatContinuations = false;</span>
<span class="lineNum">     754 </span><span class="lineCov">          5 :     aResult = aHeaderVal;</span>
<span class="lineNum">     755 </span>            :   }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineCov">          5 :   if (aEatContinuations) {</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     nsAutoCString temp(aResult);</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     temp.ReplaceSubstring(&quot;\n\t&quot;, &quot; &quot;);</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     temp.ReplaceSubstring(&quot;\r\t&quot;, &quot; &quot;);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     temp.StripCRLF();</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     aResult = temp;</span>
<span class="lineNum">     763 </span>            :   }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineCov">          5 :   return NS_OK;</span>
<span class="lineNum">     766 </span>            : }
<a name="767"><span class="lineNum">     767 </span>            : </a>
<span class="lineNum">     768 </span>            : NS_IMETHODIMP
<span class="lineNum">     769 </span><span class="lineNoCov">          0 : nsMIMEHeaderParamImpl::DecodeRFC2047Header(const char* aHeaderVal,</span>
<span class="lineNum">     770 </span>            :                                            const char* aDefaultCharset,
<span class="lineNum">     771 </span>            :                                            bool aOverrideCharset,
<span class="lineNum">     772 </span>            :                                            bool aEatContinuations,
<span class="lineNum">     773 </span>            :                                            nsACString&amp; aResult)
<span class="lineNum">     774 </span>            : {
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   return internalDecodeRFC2047Header(aHeaderVal, aDefaultCharset,</span>
<span class="lineNum">     776 </span>            :                                      aOverrideCharset, aEatContinuations,
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                                      aResult);</span>
<span class="lineNum">     778 </span>            : }
<span class="lineNum">     779 </span>            : 
<a name="780"><span class="lineNum">     780 </span>            : // true if the character is allowed in a RFC 5987 value</a>
<span class="lineNum">     781 </span>            : // see RFC 5987, Section 3.2.1, &quot;attr-char&quot;
<span class="lineNum">     782 </span><span class="lineNoCov">          0 : bool IsRFC5987AttrChar(char aChar)</span>
<span class="lineNum">     783 </span>            : {
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   char c = aChar;</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ||</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :          (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :          (c &gt;= '0' &amp;&amp; c &lt;= '9') ||</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :          (c == '!' || c == '#' || c == '$' || c == '&amp;' ||</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           c == '+' || c == '-' || c == '.' || c == '^' ||</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :           c == '_' || c == '`' || c == '|' || c == '~');</span>
<span class="lineNum">     792 </span>            : }
<span class="lineNum">     793 </span>            : 
<a name="794"><span class="lineNum">     794 </span>            : // percent-decode a value</a>
<span class="lineNum">     795 </span>            : // returns false on failure
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : bool PercentDecode(nsACString&amp; aValue)</span>
<span class="lineNum">     797 </span>            : {
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   char *c = (char *) moz_xmalloc(aValue.Length() + 1);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   if (!c) {</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     801 </span>            :   }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   strcpy(c, PromiseFlatCString(aValue).get());</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   nsUnescape(c);</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   aValue.Assign(c);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   free(c);</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     809 </span>            : }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : // Decode a parameter value using the encoding defined in RFC 5987
<span class="lineNum">     812 </span>            : //
<a name="813"><span class="lineNum">     813 </span>            : // charset  &quot;'&quot; [ language ] &quot;'&quot; value-chars</a>
<span class="lineNum">     814 </span>            : NS_IMETHODIMP
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : nsMIMEHeaderParamImpl::DecodeRFC5987Param(const nsACString&amp; aParamVal,</span>
<span class="lineNum">     816 </span>            :                                           nsACString&amp; aLang,
<span class="lineNum">     817 </span>            :                                           nsAString&amp; aResult)
<span class="lineNum">     818 </span>            : {
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   nsAutoCString charset;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   nsAutoCString language;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   nsAutoCString value;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   uint32_t delimiters = 0;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   const char *encoded = PromiseFlatCString(aParamVal).get();</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   const char *c = encoded;</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   while (*c) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     char tc = *c++;</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     if (tc == '\'') {</span>
<span class="lineNum">     831 </span>            :       // single quote
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       delimiters++;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :     } else if (((unsigned char)tc) &gt;= 128) {</span>
<span class="lineNum">     834 </span>            :       // fail early, not ASCII
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :       NS_WARNING(&quot;non-US-ASCII character in RFC5987-encoded param&quot;);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :       return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     837 </span>            :     } else {
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       if (delimiters == 0) {</span>
<span class="lineNum">     839 </span>            :         // valid characters are checked later implicitly
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         charset.Append(tc);</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :       } else if (delimiters == 1) {</span>
<span class="lineNum">     842 </span>            :         // no value checking for now
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         language.Append(tc);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :       } else if (delimiters == 2) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :         if (IsRFC5987AttrChar(tc)) {</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :           value.Append(tc);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         } else if (tc == '%') {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :           if (!IsHexDigit(c[0]) || !IsHexDigit(c[1])) {</span>
<span class="lineNum">     849 </span>            :             // we expect two more characters
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :             NS_WARNING(&quot;broken %-escape in RFC5987-encoded param&quot;);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     852 </span>            :           }
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :           value.Append(tc);</span>
<span class="lineNum">     854 </span>            :           // we consume two more
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :           value.Append(*c++);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :           value.Append(*c++);</span>
<span class="lineNum">     857 </span>            :         } else {
<span class="lineNum">     858 </span>            :           // character not allowed here
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :           NS_WARNING(&quot;invalid character in RFC5987-encoded param&quot;);</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :           return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     861 </span>            :         }
<span class="lineNum">     862 </span>            :       }
<span class="lineNum">     863 </span>            :     }
<span class="lineNum">     864 </span>            :   }
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   if (delimiters != 2) {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;missing delimiters in RFC5987-encoded param&quot;);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     869 </span>            :   }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   // abort early for unsupported encodings
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   if (!charset.LowerCaseEqualsLiteral(&quot;utf-8&quot;)) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;unsupported charset in RFC5987-encoded param&quot;);</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     875 </span>            :   }
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :   // percent-decode
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   if (!PercentDecode(value)) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     880 </span>            :   }
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            :   // return the encoding
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   aLang.Assign(language);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   // finally convert octet sequence to UTF-8 and be done
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   nsresult rv = NS_OK;</span>
<span class="lineNum">     887 </span>            :   nsCOMPtr&lt;nsIUTF8ConverterService&gt; cvtUTF8 =
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     do_GetService(NS_UTF8CONVERTERSERVICE_CONTRACTID, &amp;rv);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   nsAutoCString utf8;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   rv = cvtUTF8-&gt;ConvertStringToUTF8(value, charset.get(), true, false, 1, utf8);</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   CopyUTF8toUTF16(utf8, aResult);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     897 </span>            : }
<a name="898"><span class="lineNum">     898 </span>            : </a>
<span class="lineNum">     899 </span>            : nsresult
<span class="lineNum">     900 </span><span class="lineCov">          5 : internalDecodeParameter(const nsACString&amp; aParamValue, const char* aCharset,</span>
<span class="lineNum">     901 </span>            :                         const char* aDefaultCharset, bool aOverrideCharset,
<span class="lineNum">     902 </span>            :                         bool aDecode2047, nsACString&amp; aResult)
<span class="lineNum">     903 </span>            : {
<span class="lineNum">     904 </span><span class="lineCov">          5 :   aResult.Truncate();</span>
<span class="lineNum">     905 </span>            :   // If aCharset is given, aParamValue was obtained from RFC2231/5987
<span class="lineNum">     906 </span>            :   // encoding and we're pretty sure that it's in aCharset.
<span class="lineNum">     907 </span><span class="lineCov">          5 :   if (aCharset &amp;&amp; *aCharset)</span>
<span class="lineNum">     908 </span>            :   {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIUTF8ConverterService&gt; cvtUTF8(do_GetService(NS_UTF8CONVERTERSERVICE_CONTRACTID));</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     if (cvtUTF8)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       return cvtUTF8-&gt;ConvertStringToUTF8(aParamValue, aCharset,</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :           true, true, 1, aResult);</span>
<span class="lineNum">     913 </span>            :   }
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineCov">         10 :   const nsCString&amp; param = PromiseFlatCString(aParamValue);</span>
<span class="lineNum">     916 </span><span class="lineCov">         10 :   nsAutoCString unQuoted;</span>
<span class="lineNum">     917 </span><span class="lineCov">          5 :   nsACString::const_iterator s, e;</span>
<span class="lineNum">     918 </span><span class="lineCov">          5 :   param.BeginReading(s);</span>
<span class="lineNum">     919 </span><span class="lineCov">          5 :   param.EndReading(e);</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :   // strip '\' when used to quote CR, LF, '&quot;' and '\'
<span class="lineNum">     922 </span><span class="lineCov">        155 :   for ( ; s != e; ++s) {</span>
<span class="lineNum">     923 </span><span class="lineCov">         75 :     if ((*s == '\\')) {</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       if (++s == e) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         --s; // '\' is at the end. move back and append '\'.</span>
<span class="lineNum">     926 </span>            :       }
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       else if (*s != nsCRT::CR &amp;&amp; *s != nsCRT::LF &amp;&amp; *s != '&quot;' &amp;&amp; *s != '\\') {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         --s; // '\' is not foll. by CR,LF,'&quot;','\'. move back and append '\'</span>
<span class="lineNum">     929 </span>            :       }
<span class="lineNum">     930 </span>            :       // else : skip '\' and append the quoted character.
<span class="lineNum">     931 </span>            :     }
<span class="lineNum">     932 </span><span class="lineCov">         75 :     unQuoted.Append(*s);</span>
<span class="lineNum">     933 </span>            :   }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineCov">          5 :   aResult = unQuoted;</span>
<span class="lineNum">     936 </span><span class="lineCov">          5 :   nsresult rv = NS_OK;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineCov">          5 :   if (aDecode2047) {</span>
<span class="lineNum">     939 </span><span class="lineCov">         10 :     nsAutoCString decoded;</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :     // Try RFC 2047 encoding, instead.
<span class="lineNum">     942 </span><span class="lineCov">          5 :     rv = internalDecodeRFC2047Header(unQuoted.get(), aDefaultCharset,</span>
<span class="lineNum">     943 </span><span class="lineCov">          5 :                                      aOverrideCharset, true, decoded);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineCov">          5 :     if (NS_SUCCEEDED(rv) &amp;&amp; !decoded.IsEmpty())</span>
<span class="lineNum">     946 </span><span class="lineCov">          5 :       aResult = decoded;</span>
<span class="lineNum">     947 </span>            :   }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">          5 :   return rv;</span>
<span class="lineNum">     950 </span>            : }
<a name="951"><span class="lineNum">     951 </span>            : </a>
<span class="lineNum">     952 </span>            : NS_IMETHODIMP
<span class="lineNum">     953 </span><span class="lineNoCov">          0 : nsMIMEHeaderParamImpl::DecodeParameter(const nsACString&amp; aParamValue,</span>
<span class="lineNum">     954 </span>            :                                        const char* aCharset,
<span class="lineNum">     955 </span>            :                                        const char* aDefaultCharset,
<span class="lineNum">     956 </span>            :                                        bool aOverrideCharset,
<span class="lineNum">     957 </span>            :                                        nsACString&amp; aResult)
<span class="lineNum">     958 </span>            : {
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   return internalDecodeParameter(aParamValue, aCharset, aDefaultCharset,</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :                                  aOverrideCharset, true, aResult);</span>
<span class="lineNum">     961 </span>            : }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : #define ISHEXCHAR(c) \
<span class="lineNum">     964 </span>            :         ((0x30 &lt;= uint8_t(c) &amp;&amp; uint8_t(c) &lt;= 0x39)  ||  \
<span class="lineNum">     965 </span>            :          (0x41 &lt;= uint8_t(c) &amp;&amp; uint8_t(c) &lt;= 0x46)  ||  \
<span class="lineNum">     966 </span>            :          (0x61 &lt;= uint8_t(c) &amp;&amp; uint8_t(c) &lt;= 0x66))
<span class="lineNum">     967 </span>            : 
<a name="968"><span class="lineNum">     968 </span>            : // Decode Q encoding (RFC 2047).</a>
<span class="lineNum">     969 </span>            : // static
<span class="lineNum">     970 </span><span class="lineNoCov">          0 : char *DecodeQ(const char *in, uint32_t length)</span>
<span class="lineNum">     971 </span>            : {
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   char *out, *dest = nullptr;</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   out = dest = (char*) calloc(length + 1, sizeof(char));</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   if (dest == nullptr)</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   while (length &gt; 0) {</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     unsigned c = 0;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     switch (*in) {</span>
<span class="lineNum">     980 </span>            :     case '=':
<span class="lineNum">     981 </span>            :       // check if |in| in the form of '=hh'  where h is [0-9a-fA-F].
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :       if (length &lt; 3 || !ISHEXCHAR(in[1]) || !ISHEXCHAR(in[2]))</span>
<span class="lineNum">     983 </span>            :         goto badsyntax;
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       PR_sscanf(in + 1, &quot;%2X&quot;, &amp;c);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       *out++ = (char) c;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       in += 3;</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :       length -= 3;</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            :     case '_':
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :       *out++ = ' ';</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :       in++;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :       length--;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     default:
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       if (*in &amp; 0x80) goto badsyntax;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       *out++ = *in++;</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       length--;</span>
<span class="lineNum">    1000 </span>            :     }
<span class="lineNum">    1001 </span>            :   }
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   *out++ = '\0';</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   for (out = dest; *out ; ++out) {</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     if (*out == '\t')</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :       *out = ' ';</span>
<span class="lineNum">    1007 </span>            :   }
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   return dest;</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :  badsyntax:
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   free(dest);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">    1014 </span>            : }
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            : // check if input is HZ (a 7bit encoding for simplified Chinese : RFC 1842))
<span class="lineNum">    1017 </span>            : // or has  ESC which may be an  indication that  it's in one of many ISO
<a name="1018"><span class="lineNum">    1018 </span>            : // 2022 7bit  encodings (e.g. ISO-2022-JP(-2)/CN : see RFC 1468, 1922, 1554).</a>
<span class="lineNum">    1019 </span>            : // static
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 : bool Is7bitNonAsciiString(const char *input, uint32_t len)</span>
<span class="lineNum">    1021 </span>            : {
<span class="lineNum">    1022 </span>            :   int32_t c;
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :   enum { hz_initial, // No HZ seen yet
<span class="lineNum">    1025 </span>            :          hz_escaped, // Inside an HZ ~{ escape sequence
<span class="lineNum">    1026 </span>            :          hz_seen, // Have seen at least one complete HZ sequence
<span class="lineNum">    1027 </span>            :          hz_notpresent // Have seen something that is not legal HZ
<span class="lineNum">    1028 </span>            :   } hz_state;
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   hz_state = hz_initial;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   while (len) {</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     c = uint8_t(*input++);</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     len--;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     if (c &amp; 0x80) return false;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     if (c == 0x1B) return true;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     if (c == '~') {</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       switch (hz_state) {</span>
<span class="lineNum">    1038 </span>            :       case hz_initial:
<span class="lineNum">    1039 </span>            :       case hz_seen:
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         if (*input == '{') {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :           hz_state = hz_escaped;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         } else if (*input == '~') {</span>
<span class="lineNum">    1043 </span>            :           // ~~ is the HZ encoding of ~.  Skip over second ~ as well
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :           hz_state = hz_seen;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :           input++;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :           len--;</span>
<span class="lineNum">    1047 </span>            :         } else {
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :           hz_state = hz_notpresent;</span>
<span class="lineNum">    1049 </span>            :         }
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :       case hz_escaped:
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :         if (*input == '}') hz_state = hz_seen;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1055 </span>            :       default:
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1057 </span>            :       }
<span class="lineNum">    1058 </span>            :     }
<span class="lineNum">    1059 </span>            :   }
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   return hz_state == hz_seen;</span>
<span class="lineNum">    1061 </span>            : }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            : #define REPLACEMENT_CHAR &quot;\357\277\275&quot; // EF BF BD (UTF-8 encoding of U+FFFD)
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            : // copy 'raw' sequences of octets in aInput to aOutput.
<span class="lineNum">    1066 </span>            : // If aDefaultCharset is specified, the input is assumed to be in the
<span class="lineNum">    1067 </span>            : // charset and converted to UTF-8. Otherwise, a blind copy is made.
<span class="lineNum">    1068 </span>            : // If aDefaultCharset is specified, but the conversion to UTF-8
<span class="lineNum">    1069 </span>            : // is not successful, each octet is replaced by Unicode replacement
<a name="1070"><span class="lineNum">    1070 </span>            : // chars. *aOutput is advanced by the number of output octets.</a>
<span class="lineNum">    1071 </span>            : // static
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 : void CopyRawHeader(const char *aInput, uint32_t aLen,</span>
<span class="lineNum">    1073 </span>            :                    const char *aDefaultCharset, nsACString &amp;aOutput)
<span class="lineNum">    1074 </span>            : {
<span class="lineNum">    1075 </span>            :   int32_t c;
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            :   // If aDefaultCharset is not specified, make a blind copy.
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   if (!aDefaultCharset || !*aDefaultCharset) {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     aOutput.Append(aInput, aLen);</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1081 </span>            :   }
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :   // Copy as long as it's US-ASCII.  An ESC may indicate ISO 2022
<span class="lineNum">    1084 </span>            :   // A ~ may indicate it is HZ
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :   while (aLen &amp;&amp; (c = uint8_t(*aInput++)) != 0x1B &amp;&amp; c != '~' &amp;&amp; !(c &amp; 0x80)) {</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     aOutput.Append(char(c));</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     aLen--;</span>
<span class="lineNum">    1088 </span>            :   }
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   if (!aLen) {</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1091 </span>            :   }
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   aInput--;</span>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            :   // skip ASCIIness/UTF8ness test if aInput is supected to be a 7bit non-ascii
<span class="lineNum">    1095 </span>            :   // string and aDefaultCharset is a 7bit non-ascii charset.
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   bool skipCheck = (c == 0x1B || c == '~') &amp;&amp;</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :                      IS_7BIT_NON_ASCII_CHARSET(aDefaultCharset);</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :   // If not UTF-8, treat as default charset
<span class="lineNum">    1100 </span>            :   nsCOMPtr&lt;nsIUTF8ConverterService&gt;
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     cvtUTF8(do_GetService(NS_UTF8CONVERTERSERVICE_CONTRACTID));</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   nsAutoCString utf8Text;</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (cvtUTF8 &amp;&amp;</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       NS_SUCCEEDED(</span>
<span class="lineNum">    1105 </span>            :       cvtUTF8-&gt;ConvertStringToUTF8(Substring(aInput, aInput + aLen),
<span class="lineNum">    1106 </span>            :                                    aDefaultCharset, skipCheck, true, 1,
<span class="lineNum">    1107 </span>            :                                    utf8Text))) {
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     aOutput.Append(utf8Text);</span>
<span class="lineNum">    1109 </span>            :   } else { // replace each octet with Unicode replacement char in UTF-8.
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; aLen; i++) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       c = uint8_t(*aInput++);</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       if (c &amp; 0x80)</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         aOutput.Append(REPLACEMENT_CHAR);</span>
<span class="lineNum">    1114 </span>            :       else
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         aOutput.Append(char(c));</span>
<span class="lineNum">    1116 </span>            :     }
<span class="lineNum">    1117 </span>            :   }
<a name="1118"><span class="lineNum">    1118 </span>            : }</a>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 : nsresult DecodeQOrBase64Str(const char *aEncoded, size_t aLen, char aQOrBase64,</span>
<span class="lineNum">    1121 </span>            :                             const char *aCharset, nsACString &amp;aResult)
<span class="lineNum">    1122 </span>            : {
<span class="lineNum">    1123 </span>            :   char *decodedText;
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aQOrBase64 == 'Q' || aQOrBase64 == 'B', &quot;Should be 'Q' or 'B'&quot;);</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :   if(aQOrBase64 == 'Q')</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     decodedText = DecodeQ(aEncoded, aLen);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   else if (aQOrBase64 == 'B') {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     decodedText = PL_Base64Decode(aEncoded, aLen, nullptr);</span>
<span class="lineNum">    1129 </span>            :   } else {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">    1131 </span>            :   }
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   if (!decodedText) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">    1135 </span>            :   }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :   nsresult rv;
<span class="lineNum">    1138 </span>            :   nsCOMPtr&lt;nsIUTF8ConverterService&gt;
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :     cvtUTF8(do_GetService(NS_UTF8CONVERTERSERVICE_CONTRACTID, &amp;rv));</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   nsAutoCString utf8Text;</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">    1142 </span>            :     // skip ASCIIness/UTF8ness test if aCharset is 7bit non-ascii charset.
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :     rv = cvtUTF8-&gt;ConvertStringToUTF8(nsDependentCString(decodedText),</span>
<span class="lineNum">    1144 </span>            :                                       aCharset,
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                                       IS_7BIT_NON_ASCII_CHARSET(aCharset),</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                                       true, 1, utf8Text);</span>
<span class="lineNum">    1147 </span>            :   }
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   free(decodedText);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1151 </span>            :   }
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   aResult.Append(utf8Text);</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1155 </span>            : }
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            : static const char especials[] = R&quot;(()&lt;&gt;@,;:\&quot;/[]?.=)&quot;;
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : // |decode_mime_part2_str| taken from comi18n.c
<span class="lineNum">    1160 </span>            : // Decode RFC2047-encoded words in the input and convert the result to UTF-8.
<span class="lineNum">    1161 </span>            : // If aOverrideCharset is true, charset in RFC2047-encoded words is
<span class="lineNum">    1162 </span>            : // ignored and aDefaultCharset is assumed, instead. aDefaultCharset
<a name="1163"><span class="lineNum">    1163 </span>            : // is also used to convert raw octets (without RFC 2047 encoding) to UTF-8.</a>
<span class="lineNum">    1164 </span>            : //static
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 : nsresult DecodeRFC2047Str(const char *aHeader, const char *aDefaultCharset,</span>
<span class="lineNum">    1166 </span>            :                           bool aOverrideCharset, nsACString &amp;aResult)
<span class="lineNum">    1167 </span>            : {
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   const char *p, *q = nullptr, *r;</span>
<span class="lineNum">    1169 </span>            :   const char *begin; // tracking pointer for where we are in the input buffer
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   int32_t isLastEncodedWord = 0;</span>
<span class="lineNum">    1171 </span>            :   const char *charsetStart, *charsetEnd;
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   nsAutoCString prevCharset, curCharset;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   nsAutoCString encodedText;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   char prevEncoding = '\0', curEncoding;</span>
<span class="lineNum">    1175 </span>            :   nsresult rv;
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   begin = aHeader;</span>
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            :   // To avoid buffer realloc, if possible, set capacity in advance. No
<span class="lineNum">    1180 </span>            :   // matter what,  more than 3x expansion can never happen for all charsets
<span class="lineNum">    1181 </span>            :   // supported by Mozilla. SCSU/BCSU with the sliding window set to a
<span class="lineNum">    1182 </span>            :   // non-BMP block may be exceptions, but Mozilla does not support them.
<span class="lineNum">    1183 </span>            :   // Neither any known mail/news program use them. Even if there's, we're
<span class="lineNum">    1184 </span>            :   // safe because we don't use a raw *char any more.
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :   aResult.SetCapacity(3 * strlen(aHeader));</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :   while ((p = PL_strstr(begin, &quot;=?&quot;)) != nullptr) {</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :     if (isLastEncodedWord) {</span>
<span class="lineNum">    1189 </span>            :       // See if it's all whitespace.
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :       for (q = begin; q &lt; p; ++q) {</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         if (!PL_strchr(&quot; \t\r\n&quot;, *q)) break;</span>
<span class="lineNum">    1192 </span>            :       }
<span class="lineNum">    1193 </span>            :     }
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     if (!isLastEncodedWord || q &lt; p) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :       if (!encodedText.IsEmpty()) {</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :         rv = DecodeQOrBase64Str(encodedText.get(), encodedText.Length(),</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                                 prevEncoding, prevCharset.get(), aResult);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :           aResult.Append(encodedText);</span>
<span class="lineNum">    1201 </span>            :         }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         encodedText.Truncate();</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         prevCharset.Truncate();</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         prevEncoding = '\0';</span>
<span class="lineNum">    1205 </span>            :       }
<span class="lineNum">    1206 </span>            :       // copy the part before the encoded-word
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       CopyRawHeader(begin, p - begin, aDefaultCharset, aResult);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :       begin = p;</span>
<span class="lineNum">    1209 </span>            :     }
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     p += 2;</span>
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            :     // Get charset info
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     charsetStart = p;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     charsetEnd = nullptr;</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     for (q = p; *q != '?'; q++) {</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :       if (*q &lt;= ' ' || PL_strchr(especials, *q)) {</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :         goto badsyntax;</span>
<span class="lineNum">    1219 </span>            :       }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            :       // RFC 2231 section 5
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :       if (!charsetEnd &amp;&amp; *q == '*') {</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :         charsetEnd = q;</span>
<span class="lineNum">    1224 </span>            :       }
<span class="lineNum">    1225 </span>            :     }
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     if (!charsetEnd) {</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :       charsetEnd = q;</span>
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     q++;</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     curEncoding = nsCRT::ToUpper(*q);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     if (curEncoding != 'Q' &amp;&amp; curEncoding != 'B')</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :       goto badsyntax;</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     if (q[1] != '?')</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :       goto badsyntax;</span>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :     // loop-wise, keep going until we hit &quot;?=&quot;.  the inner check handles the
<span class="lineNum">    1239 </span>            :     //  nul terminator should the string terminate before we hit the right
<span class="lineNum">    1240 </span>            :     //  marker.  (And the r[1] will never reach beyond the end of the string
<span class="lineNum">    1241 </span>            :     //  because *r != '?' is true if r is the nul character.)
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     for (r = q + 2; *r != '?' || r[1] != '='; r++) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :       if (*r &lt; ' ') goto badsyntax;</span>
<span class="lineNum">    1244 </span>            :     }
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     if (r == q + 2) {</span>
<span class="lineNum">    1246 </span>            :         // it's empty, skip
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         begin = r + 2;</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         isLastEncodedWord = 1;</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1250 </span>            :     }
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :     curCharset.Assign(charsetStart, charsetEnd - charsetStart);</span>
<span class="lineNum">    1253 </span>            :     // Override charset if requested.  Never override labeled UTF-8.
<span class="lineNum">    1254 </span>            :     // Use default charset instead of UNKNOWN-8BIT
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :     if ((aOverrideCharset &amp;&amp; 0 != nsCRT::strcasecmp(curCharset.get(), &quot;UTF-8&quot;))</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     || (aDefaultCharset &amp;&amp; 0 == nsCRT::strcasecmp(curCharset.get(), &quot;UNKNOWN-8BIT&quot;))</span>
<span class="lineNum">    1257 </span>            :     ) {
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :       curCharset = aDefaultCharset;</span>
<span class="lineNum">    1259 </span>            :     }
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :     const char *R;
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     R = r;</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     if (curEncoding == 'B') {</span>
<span class="lineNum">    1264 </span>            :       // bug 227290. ignore an extraneous '=' at the end.
<span class="lineNum">    1265 </span>            :       // (# of characters in B-encoded part has to be a multiple of 4)
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :       int32_t n = r - (q + 2);</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :       R -= (n % 4 == 1 &amp;&amp; !PL_strncmp(r - 3, &quot;===&quot;, 3)) ? 1 : 0;</span>
<span class="lineNum">    1268 </span>            :     }
<span class="lineNum">    1269 </span>            :     // Bug 493544. Don't decode the encoded text until it ends
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     if (R[-1] != '='</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :       &amp;&amp; (prevCharset.IsEmpty()</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         || (curCharset == prevCharset &amp;&amp; curEncoding == prevEncoding))</span>
<span class="lineNum">    1273 </span>            :     ) {
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :       encodedText.Append(q + 2, R - (q + 2));</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :       prevCharset = curCharset;</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :       prevEncoding = curEncoding;</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :       begin = r + 2;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :       isLastEncodedWord = 1;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1281 </span>            :     }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :     bool bDecoded; // If the current line has been decoded.
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     bDecoded = false;</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     if (!encodedText.IsEmpty()) {</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :       if (curCharset == prevCharset &amp;&amp; curEncoding == prevEncoding) {</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         encodedText.Append(q + 2, R - (q + 2));</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :         bDecoded = true;</span>
<span class="lineNum">    1289 </span>            :       }
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :       rv = DecodeQOrBase64Str(encodedText.get(), encodedText.Length(),</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                               prevEncoding, prevCharset.get(), aResult);</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         aResult.Append(encodedText);</span>
<span class="lineNum">    1294 </span>            :       }
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :       encodedText.Truncate();</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :       prevCharset.Truncate();</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :       prevEncoding = '\0';</span>
<span class="lineNum">    1298 </span>            :     }
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     if (!bDecoded) {</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :       rv = DecodeQOrBase64Str(q + 2, R - (q + 2), curEncoding,</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :                               curCharset.get(), aResult);</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :         aResult.Append(encodedText);</span>
<span class="lineNum">    1304 </span>            :       }
<span class="lineNum">    1305 </span>            :     }
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     begin = r + 2;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     isLastEncodedWord = 1;</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            :   badsyntax:
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     if (!encodedText.IsEmpty()) {</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       rv = DecodeQOrBase64Str(encodedText.get(), encodedText.Length(),</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                               prevEncoding, prevCharset.get(), aResult);</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         aResult.Append(encodedText);</span>
<span class="lineNum">    1317 </span>            :       }
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       encodedText.Truncate();</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :       prevCharset.Truncate();</span>
<span class="lineNum">    1320 </span>            :     }
<span class="lineNum">    1321 </span>            :     // copy the part before the encoded-word
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :     aResult.Append(begin, p - begin);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     begin = p;</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     isLastEncodedWord = 0;</span>
<span class="lineNum">    1325 </span>            :   }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   if (!encodedText.IsEmpty()) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     rv = DecodeQOrBase64Str(encodedText.get(), encodedText.Length(),</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                             prevEncoding, prevCharset.get(), aResult);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       aResult.Append(encodedText);</span>
<span class="lineNum">    1332 </span>            :     }
<span class="lineNum">    1333 </span>            :   }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :   // put the tail back
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   CopyRawHeader(begin, strlen(begin), aDefaultCharset, aResult);</span>
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   nsAutoCString tempStr(aResult);</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :   tempStr.ReplaceChar('\t', ' ');</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :   aResult = tempStr;</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1343 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

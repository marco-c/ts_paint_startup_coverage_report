<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - netwerk/protocol/http/nsHttpNTLMAuth.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">netwerk/protocol/http</a> - nsHttpNTLMAuth.cpp<span style="font-size: 80%;"> (source / <a href="nsHttpNTLMAuth.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">131</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* vim:set ts=4 sw=4 sts=4 et ci: */</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       4 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : // HttpLog.h should generally be included first
<span class="lineNum">       7 </span>            : #include &quot;HttpLog.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;nsHttpNTLMAuth.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsIAuthModule.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsServiceManagerUtils.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;plbase64.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;plstr.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;prnetdb.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;nsIPrefBranch.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsIPrefService.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsIHttpAuthenticableChannel.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIURI.h&quot;
<span class="lineNum">      23 </span>            : #ifdef XP_WIN
<span class="lineNum">      24 </span>            : #include &quot;nsIChannel.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIX509Cert.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsISSLStatus.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsISSLStatusProvider.h&quot;
<span class="lineNum">      28 </span>            : #endif
<span class="lineNum">      29 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;mozilla/Base64.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;mozilla/CheckedInt.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/Tokenizer.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsNetUtil.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsIChannel.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsUnicharUtils.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;mozilla/net/HttpAuthUtils.h&quot;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : namespace mozilla {
<span class="lineNum">      41 </span>            : namespace net {
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : static const char kAllowProxies[] = &quot;network.automatic-ntlm-auth.allow-proxies&quot;;
<span class="lineNum">      44 </span>            : static const char kAllowNonFqdn[] = &quot;network.automatic-ntlm-auth.allow-non-fqdn&quot;;
<span class="lineNum">      45 </span>            : static const char kTrustedURIs[]  = &quot;network.automatic-ntlm-auth.trusted-uris&quot;;
<span class="lineNum">      46 </span>            : static const char kForceGeneric[] = &quot;network.auth.force-generic-ntlm&quot;;
<span class="lineNum">      47 </span>            : static const char kSSOinPBmode[] = &quot;network.auth.private-browsing-sso&quot;;
<a name="48"><span class="lineNum">      48 </span>            : </a>
<span class="lineNum">      49 </span>            : static bool
<span class="lineNum">      50 </span><span class="lineNoCov">          0 : IsNonFqdn(nsIURI *uri)</span>
<span class="lineNum">      51 </span>            : {
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :     nsAutoCString host;</span>
<span class="lineNum">      53 </span>            :     PRNetAddr addr;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     if (NS_FAILED(uri-&gt;GetAsciiHost(host)))</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :     // return true if host does not contain a dot and is not an ip address
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :     return !host.IsEmpty() &amp;&amp; !host.Contains('.') &amp;&amp;</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :            PR_StringToNetAddr(host.BeginReading(), &amp;addr) != PR_SUCCESS;</span>
<span class="lineNum">      61 </span>            : }
<span class="lineNum">      62 </span>            : 
<a name="63"><span class="lineNum">      63 </span>            : // Check to see if we should use our generic (internal) NTLM auth module.</a>
<span class="lineNum">      64 </span>            : static bool
<span class="lineNum">      65 </span><span class="lineNoCov">          0 : ForceGenericNTLM()</span>
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIPrefBranch&gt; prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     if (!prefs)</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     bool flag = false;</span>
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     if (NS_FAILED(prefs-&gt;GetBoolPref(kForceGeneric, &amp;flag)))</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         flag = false;</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     LOG((&quot;Force use of generic ntlm auth module: %d\n&quot;, flag));</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     return flag;</span>
<span class="lineNum">      77 </span>            : }
<span class="lineNum">      78 </span>            : 
<a name="79"><span class="lineNum">      79 </span>            : // Check to see if we should use default credentials for this host or proxy.</a>
<span class="lineNum">      80 </span>            : static bool
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : CanUseDefaultCredentials(nsIHttpAuthenticableChannel *channel,</span>
<span class="lineNum">      82 </span>            :                          bool isProxyAuth)
<span class="lineNum">      83 </span>            : {
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIPrefBranch&gt; prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     if (!prefs) {</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      87 </span>            :     }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     // Proxy should go all the time, it's not considered a privacy leak
<span class="lineNum">      90 </span>            :     // to send default credentials to a proxy.
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     if (isProxyAuth) {</span>
<span class="lineNum">      92 </span>            :         bool val;
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :         if (NS_FAILED(prefs-&gt;GetBoolPref(kAllowProxies, &amp;val)))</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :             val = false;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         LOG((&quot;Default credentials allowed for proxy: %d\n&quot;, val));</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         return val;</span>
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :     // Prevent using default credentials for authentication when we are in the
<span class="lineNum">     100 </span>            :     // private browsing mode (but not in &quot;never remember history&quot; mode) and when
<span class="lineNum">     101 </span>            :     // not explicitely allowed.  Otherwise, it would cause a privacy data leak.
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIChannel&gt; bareChannel = do_QueryInterface(channel);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(bareChannel);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     if (NS_UsePrivateBrowsing(bareChannel)) {</span>
<span class="lineNum">     106 </span>            :         bool ssoInPb;
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(prefs-&gt;GetBoolPref(kSSOinPBmode, &amp;ssoInPb)) &amp;&amp;</span>
<span class="lineNum">     108 </span>            :             ssoInPb) {
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     110 </span>            :         }
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :         bool dontRememberHistory;
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(prefs-&gt;GetBoolPref(&quot;browser.privatebrowsing.autostart&quot;,</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                                             &amp;dontRememberHistory)) &amp;&amp;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             !dontRememberHistory) {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     117 </span>            :         }
<span class="lineNum">     118 </span>            :     }
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     Unused &lt;&lt; channel-&gt;GetURI(getter_AddRefs(uri));</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :     bool allowNonFqdn;
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     if (NS_FAILED(prefs-&gt;GetBoolPref(kAllowNonFqdn, &amp;allowNonFqdn)))</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         allowNonFqdn = false;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     if (allowNonFqdn &amp;&amp; uri &amp;&amp; IsNonFqdn(uri)) {</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         LOG((&quot;Host is non-fqdn, default credentials are allowed\n&quot;));</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     129 </span>            :     }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     bool isTrustedHost = (uri &amp;&amp; auth::URIMatchesPrefPattern(uri, kTrustedURIs));</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     LOG((&quot;Default credentials allowed for host: %d\n&quot;, isTrustedHost));</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     return isTrustedHost;</span>
<span class="lineNum">     134 </span>            : }
<span class="lineNum">     135 </span>            : 
<a name="136"><span class="lineNum">     136 </span>            : // Dummy class for session state object.  This class doesn't hold any data.</a>
<span class="lineNum">     137 </span>            : // Instead we use its existence as a flag.  See ChallengeReceived.
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 : class nsNTLMSessionState final : public nsISupports</span></a>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     ~nsNTLMSessionState() {}</span>
<span class="lineNum">     141 </span>            : public:
<a name="142"><span class="lineNum">     142 </span>            :     NS_DECL_ISUPPORTS</a>
<span class="lineNum">     143 </span>            : };
<span class="lineNum">     144 </span><span class="lineNoCov">          0 : NS_IMPL_ISUPPORTS0(nsNTLMSessionState)</span>
<span class="lineNum">     145 </span>            : 
<a name="146"><span class="lineNum">     146 </span>            : //-----------------------------------------------------------------------------</a>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : NS_IMPL_ISUPPORTS(nsHttpNTLMAuth, nsIHttpAuthenticator)</span>
<a name="149"><span class="lineNum">     149 </span>            : </a>
<span class="lineNum">     150 </span>            : NS_IMETHODIMP
<span class="lineNum">     151 </span><span class="lineNoCov">          0 : nsHttpNTLMAuth::ChallengeReceived(nsIHttpAuthenticableChannel *channel,</span>
<span class="lineNum">     152 </span>            :                                   const char     *challenge,
<span class="lineNum">     153 </span>            :                                   bool            isProxyAuth,
<span class="lineNum">     154 </span>            :                                   nsISupports   **sessionState,
<span class="lineNum">     155 </span>            :                                   nsISupports   **continuationState,
<span class="lineNum">     156 </span>            :                                   bool           *identityInvalid)
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     LOG((&quot;nsHttpNTLMAuth::ChallengeReceived [ss=%p cs=%p]\n&quot;,</span>
<span class="lineNum">     159 </span>            :          *sessionState, *continuationState));
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     // Use the native NTLM if available
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     mUseNative = true;</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     // NOTE: we don't define any session state, but we do use the pointer.
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     *identityInvalid = false;</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :     // Start a new auth sequence if the challenge is exactly &quot;NTLM&quot;.
<span class="lineNum">     169 </span>            :     // If native NTLM auth apis are available and enabled through prefs,
<span class="lineNum">     170 </span>            :     // try to use them.
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     if (PL_strcasecmp(challenge, &quot;NTLM&quot;) == 0) {</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsISupports&gt; module;</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :         // Check to see if we should default to our generic NTLM auth module
<span class="lineNum">     175 </span>            :         // through UseGenericNTLM. (We use native auth by default if the
<span class="lineNum">     176 </span>            :         // system provides it.) If *sessionState is non-null, we failed to
<span class="lineNum">     177 </span>            :         // instantiate a native NTLM module the last time, so skip trying again.
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         bool forceGeneric = ForceGenericNTLM();</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         if (!forceGeneric &amp;&amp; !*sessionState) {</span>
<span class="lineNum">     180 </span>            :             // Check for approved default credentials hosts and proxies. If
<span class="lineNum">     181 </span>            :             // *continuationState is non-null, the last authentication attempt
<span class="lineNum">     182 </span>            :             // failed so skip default credential use.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :             if (!*continuationState &amp;&amp; CanUseDefaultCredentials(channel, isProxyAuth)) {</span>
<span class="lineNum">     184 </span>            :                 // Try logging in with the user's default credentials. If
<span class="lineNum">     185 </span>            :                 // successful, |identityInvalid| is false, which will trigger
<span class="lineNum">     186 </span>            :                 // a default credentials attempt once we return.
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :                 module = do_CreateInstance(NS_AUTH_MODULE_CONTRACTID_PREFIX &quot;sys-ntlm&quot;);</span>
<span class="lineNum">     188 </span>            :             }
<span class="lineNum">     189 </span>            : #ifdef XP_WIN
<span class="lineNum">     190 </span>            :             else {
<span class="lineNum">     191 </span>            :                 // Try to use native NTLM and prompt the user for their domain,
<span class="lineNum">     192 </span>            :                 // username, and password. (only supported by windows nsAuthSSPI module.)
<span class="lineNum">     193 </span>            :                 // Note, for servers that use LMv1 a weak hash of the user's password
<span class="lineNum">     194 </span>            :                 // will be sent. We rely on windows internal apis to decide whether
<span class="lineNum">     195 </span>            :                 // we should support this older, less secure version of the protocol.
<span class="lineNum">     196 </span>            :                 module = do_CreateInstance(NS_AUTH_MODULE_CONTRACTID_PREFIX &quot;sys-ntlm&quot;);
<span class="lineNum">     197 </span>            :                 *identityInvalid = true;
<span class="lineNum">     198 </span>            :             }
<span class="lineNum">     199 </span>            : #endif // XP_WIN
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :             if (!module)</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 LOG((&quot;Native sys-ntlm auth module not found.\n&quot;));</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : #ifdef XP_WIN
<span class="lineNum">     205 </span>            :         // On windows, never fall back unless the user has specifically requested so.
<span class="lineNum">     206 </span>            :         if (!forceGeneric &amp;&amp; !module)
<span class="lineNum">     207 </span>            :             return NS_ERROR_UNEXPECTED;
<span class="lineNum">     208 </span>            : #endif
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :         // If no native support was available. Fall back on our internal NTLM implementation.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         if (!module) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :             if (!*sessionState) {</span>
<span class="lineNum">     213 </span>            :                 // Remember the fact that we cannot use the &quot;sys-ntlm&quot; module,
<span class="lineNum">     214 </span>            :                 // so we don't ever bother trying again for this auth domain.
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                 *sessionState = new nsNTLMSessionState();</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :                 if (!*sessionState)</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                     return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :                 NS_ADDREF(*sessionState);</span>
<span class="lineNum">     219 </span>            :             }
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :             // Use our internal NTLM implementation. Note, this is less secure,
<span class="lineNum">     222 </span>            :             // see bug 520607 for details.
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :             LOG((&quot;Trying to fall back on internal ntlm auth.\n&quot;));</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :             module = do_CreateInstance(NS_AUTH_MODULE_CONTRACTID_PREFIX &quot;ntlm&quot;);</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             mUseNative = false;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :             // Prompt user for domain, username, and password.
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :             *identityInvalid = true;</span>
<span class="lineNum">     230 </span>            :         }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :         // If this fails, then it means that we cannot do NTLM auth.
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         if (!module) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :             LOG((&quot;No ntlm auth modules available.\n&quot;));</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :             return NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">     236 </span>            :         }
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :         // A non-null continuation state implies that we failed to authenticate.
<span class="lineNum">     239 </span>            :         // Blow away the old authentication state, and use the new one.
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         module.swap(*continuationState);</span>
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     243 </span>            : }
<a name="244"><span class="lineNum">     244 </span>            : </a>
<span class="lineNum">     245 </span>            : NS_IMETHODIMP
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : nsHttpNTLMAuth::GenerateCredentialsAsync(nsIHttpAuthenticableChannel *authChannel,</span>
<span class="lineNum">     247 </span>            :                                          nsIHttpAuthenticatorCallback* aCallback,
<span class="lineNum">     248 </span>            :                                          const char *challenge,
<span class="lineNum">     249 </span>            :                                          bool isProxyAuth,
<span class="lineNum">     250 </span>            :                                          const char16_t *domain,
<span class="lineNum">     251 </span>            :                                          const char16_t *username,
<span class="lineNum">     252 </span>            :                                          const char16_t *password,
<span class="lineNum">     253 </span>            :                                          nsISupports *sessionState,
<span class="lineNum">     254 </span>            :                                          nsISupports *continuationState,
<span class="lineNum">     255 </span>            :                                          nsICancelable **aCancellable)
<span class="lineNum">     256 </span>            : {
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   return NS_ERROR_NOT_IMPLEMENTED;</span>
<span class="lineNum">     258 </span>            : }
<a name="259"><span class="lineNum">     259 </span>            : </a>
<span class="lineNum">     260 </span>            : NS_IMETHODIMP
<span class="lineNum">     261 </span><span class="lineNoCov">          0 : nsHttpNTLMAuth::GenerateCredentials(nsIHttpAuthenticableChannel *authChannel,</span>
<span class="lineNum">     262 </span>            :                                     const char      *challenge,
<span class="lineNum">     263 </span>            :                                     bool             isProxyAuth,
<span class="lineNum">     264 </span>            :                                     const char16_t *domain,
<span class="lineNum">     265 </span>            :                                     const char16_t *user,
<span class="lineNum">     266 </span>            :                                     const char16_t *pass,
<span class="lineNum">     267 </span>            :                                     nsISupports    **sessionState,
<span class="lineNum">     268 </span>            :                                     nsISupports    **continuationState,
<span class="lineNum">     269 </span>            :                                     uint32_t       *aFlags,
<span class="lineNum">     270 </span>            :                                     char           **creds)
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : {
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     LOG((&quot;nsHttpNTLMAuth::GenerateCredentials\n&quot;));</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     *creds = nullptr;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     *aFlags = 0;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     // if user or password is empty, ChallengeReceived returned
<span class="lineNum">     279 </span>            :     // identityInvalid = false, that means we are using default user
<span class="lineNum">     280 </span>            :     // credentials; see  nsAuthSSPI::Init method for explanation of this
<span class="lineNum">     281 </span>            :     // condition
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     if (!user || !pass)</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         *aFlags = USING_INTERNAL_IDENTITY;</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :     nsresult rv;
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIAuthModule&gt; module = do_QueryInterface(*continuationState, &amp;rv);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :     void *inBuf, *outBuf;
<span class="lineNum">     290 </span>            :     uint32_t inBufLen, outBufLen;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     // initial challenge
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     if (PL_strcasecmp(challenge, &quot;NTLM&quot;) == 0) {</span>
<span class="lineNum">     294 </span>            :         // NTLM service name format is 'HTTP@host' for both http and https
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         rv = authChannel-&gt;GetURI(getter_AddRefs(uri));</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv))</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         nsAutoCString serviceName, host;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         rv = uri-&gt;GetAsciiHost(host);</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv))</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         serviceName.AppendLiteral(&quot;HTTP@&quot;);</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :         serviceName.Append(host);</span>
<span class="lineNum">     305 </span>            :         // initialize auth module
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         uint32_t reqFlags = nsIAuthModule::REQ_DEFAULT;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         if (isProxyAuth)</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :             reqFlags |= nsIAuthModule::REQ_PROXY_AUTH;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :         rv = module-&gt;Init(serviceName.get(), reqFlags, domain, user, pass);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv))</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : // This update enables updated Windows machines (Win7 or patched previous
<span class="lineNum">     315 </span>            : // versions) and Linux machines running Samba (updated for Channel
<span class="lineNum">     316 </span>            : // Binding), to perform Channel Binding when authenticating using NTLMv2
<span class="lineNum">     317 </span>            : // and an outer secure channel.
<span class="lineNum">     318 </span>            : //
<span class="lineNum">     319 </span>            : // Currently only implemented for Windows, linux support will be landing in
<span class="lineNum">     320 </span>            : // a separate patch, update this #ifdef accordingly then.
<span class="lineNum">     321 </span>            : #if defined (XP_WIN) /* || defined (LINUX) */
<span class="lineNum">     322 </span>            :         // We should retrieve the server certificate and compute the CBT,
<span class="lineNum">     323 </span>            :         // but only when we are using the native NTLM implementation and
<span class="lineNum">     324 </span>            :         // not the internal one.
<span class="lineNum">     325 </span>            :         // It is a valid case not having the security info object.  This
<span class="lineNum">     326 </span>            :         // occures when we connect an https site through an ntlm proxy.
<span class="lineNum">     327 </span>            :         // After the ssl tunnel has been created, we get here the second
<span class="lineNum">     328 </span>            :         // time and now generate the CBT from now valid security info.
<span class="lineNum">     329 </span>            :         nsCOMPtr&lt;nsIChannel&gt; channel = do_QueryInterface(authChannel, &amp;rv);
<span class="lineNum">     330 </span>            :         if (NS_FAILED(rv))
<span class="lineNum">     331 </span>            :             return rv;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :         nsCOMPtr&lt;nsISupports&gt; security;
<span class="lineNum">     334 </span>            :         rv = channel-&gt;GetSecurityInfo(getter_AddRefs(security));
<span class="lineNum">     335 </span>            :         if (NS_FAILED(rv))
<span class="lineNum">     336 </span>            :             return rv;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :         nsCOMPtr&lt;nsISSLStatusProvider&gt; statusProvider =
<span class="lineNum">     339 </span>            :             do_QueryInterface(security);
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :         if (mUseNative &amp;&amp; statusProvider) {
<span class="lineNum">     342 </span>            :             nsCOMPtr&lt;nsISSLStatus&gt; status;
<span class="lineNum">     343 </span>            :             rv = statusProvider-&gt;GetSSLStatus(getter_AddRefs(status));
<span class="lineNum">     344 </span>            :             if (NS_FAILED(rv))
<span class="lineNum">     345 </span>            :                 return rv;
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :             nsCOMPtr&lt;nsIX509Cert&gt; cert;
<span class="lineNum">     348 </span>            :             rv = status-&gt;GetServerCert(getter_AddRefs(cert));
<span class="lineNum">     349 </span>            :             if (NS_FAILED(rv))
<span class="lineNum">     350 </span>            :                 return rv;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :             uint32_t length;
<span class="lineNum">     353 </span>            :             uint8_t* certArray;
<span class="lineNum">     354 </span>            :             cert-&gt;GetRawDER(&amp;length, &amp;certArray);
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :             // If there is a server certificate, we pass it along the
<span class="lineNum">     357 </span>            :             // first time we call GetNextToken().
<span class="lineNum">     358 </span>            :             inBufLen = length;
<span class="lineNum">     359 </span>            :             inBuf = certArray;
<span class="lineNum">     360 </span>            :         } else {
<span class="lineNum">     361 </span>            :             // If there is no server certificate, we don't pass anything.
<span class="lineNum">     362 </span>            :             inBufLen = 0;
<span class="lineNum">     363 </span>            :             inBuf = nullptr;
<span class="lineNum">     364 </span>            :         }
<span class="lineNum">     365 </span>            : #else // Extended protection update is just for Linux and Windows machines.
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         inBufLen = 0;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         inBuf = nullptr;</span>
<span class="lineNum">     368 </span>            : #endif
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            :     else {
<span class="lineNum">     371 </span>            :         // decode challenge; skip past &quot;NTLM &quot; to the start of the base64
<span class="lineNum">     372 </span>            :         // encoded data.
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         int len = strlen(challenge);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         if (len &lt; 6)</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :             return NS_ERROR_UNEXPECTED; // bogus challenge</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         challenge += 5;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         len -= 5;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :         // strip off any padding (see bug 230351)
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         while (challenge[len - 1] == '=')</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :           len--;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :         // decode into the input secbuffer
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         rv = Base64Decode(challenge, len, (char**)&amp;inBuf, &amp;inBufLen);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">     387 </span>            :         }
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     rv = module-&gt;GetNextToken(inBuf, inBufLen, &amp;outBuf, &amp;outBufLen);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     392 </span>            :         // base64 encode data in output buffer and prepend &quot;NTLM &quot;
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         CheckedUint32 credsLen = ((CheckedUint32(outBufLen) + 2) / 3) * 4;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :         credsLen += 5; // &quot;NTLM &quot;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         credsLen += 1; // null terminate</span>
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         if (!credsLen.isValid()) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :           rv = NS_ERROR_FAILURE;</span>
<span class="lineNum">     399 </span>            :         } else {
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :           *creds = (char *) moz_xmalloc(credsLen.value());</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :           memcpy(*creds, &quot;NTLM &quot;, 5);</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :           PL_Base64Encode((char *) outBuf, outBufLen, *creds + 5);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :           (*creds)[credsLen.value() - 1] = '\0'; // null terminate</span>
<span class="lineNum">     404 </span>            :         }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :         // OK, we are done with |outBuf|
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         free(outBuf);</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     if (inBuf)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         free(inBuf);</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     414 </span>            : }
<a name="415"><span class="lineNum">     415 </span>            : </a>
<span class="lineNum">     416 </span>            : NS_IMETHODIMP
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : nsHttpNTLMAuth::GetAuthFlags(uint32_t *flags)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     *flags = CONNECTION_BASED | IDENTITY_INCLUDES_DOMAIN | IDENTITY_ENCRYPTED;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     421 </span>            : }
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : } // namespace net
<span class="lineNum">     424 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

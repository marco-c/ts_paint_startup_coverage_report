<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - netwerk/protocol/http/Http2Stream.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">netwerk/protocol/http</a> - Http2Stream.cpp<span style="font-size: 80%;"> (source / <a href="Http2Stream.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">709</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set sw=2 ts=8 et tw=80 : */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : // HttpLog.h should generally be included first
<span class="lineNum">       8 </span>            : #include &quot;HttpLog.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : // Log on level :5, instead of default :4.
<span class="lineNum">      11 </span>            : #undef LOG
<span class="lineNum">      12 </span>            : #define LOG(args) LOG5(args)
<span class="lineNum">      13 </span>            : #undef LOG_ENABLED
<span class="lineNum">      14 </span>            : #define LOG_ENABLED() LOG5_ENABLED()
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;Http2Compression.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;Http2Session.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;Http2Stream.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;Http2Push.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;TunnelUtils.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;mozilla/BasePrincipal.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsAlgorithm.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsHttp.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsHttpHandler.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsHttpRequestHead.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsIClassOfService.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsIPipe.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsISocketTransport.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsStandardURL.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;prnetdb.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : namespace mozilla {
<a name="37"><span class="lineNum">      37 </span>            : namespace net {</a>
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span><span class="lineNoCov">          0 : Http2Stream::Http2Stream(nsAHttpTransaction *httpTransaction,</span>
<span class="lineNum">      40 </span>            :                          Http2Session *session,
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :                          int32_t priority)</span>
<span class="lineNum">      42 </span>            :   : mStreamID(0)
<span class="lineNum">      43 </span>            :   , mSession(session)
<span class="lineNum">      44 </span>            :   , mSegmentReader(nullptr)
<span class="lineNum">      45 </span>            :   , mSegmentWriter(nullptr)
<span class="lineNum">      46 </span>            :   , mUpstreamState(GENERATING_HEADERS)
<span class="lineNum">      47 </span>            :   , mState(IDLE)
<span class="lineNum">      48 </span>            :   , mRequestHeadersDone(0)
<span class="lineNum">      49 </span>            :   , mOpenGenerated(0)
<span class="lineNum">      50 </span>            :   , mAllHeadersReceived(0)
<span class="lineNum">      51 </span>            :   , mQueued(0)
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   , mSocketTransport(session-&gt;SocketTransport())</span>
<span class="lineNum">      53 </span>            :   , mTransaction(httpTransaction)
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   , mChunkSize(session-&gt;SendingChunkSize())</span>
<span class="lineNum">      55 </span>            :   , mRequestBlockedOnRead(0)
<span class="lineNum">      56 </span>            :   , mRecvdFin(0)
<span class="lineNum">      57 </span>            :   , mReceivedData(0)
<span class="lineNum">      58 </span>            :   , mRecvdReset(0)
<span class="lineNum">      59 </span>            :   , mSentReset(0)
<span class="lineNum">      60 </span>            :   , mCountAsActive(0)
<span class="lineNum">      61 </span>            :   , mSentFin(0)
<span class="lineNum">      62 </span>            :   , mSentWaitingFor(0)
<span class="lineNum">      63 </span>            :   , mSetTCPSocketBuffer(0)
<span class="lineNum">      64 </span>            :   , mBypassInputBuffer(0)
<span class="lineNum">      65 </span>            :   , mTxInlineFrameSize(Http2Session::kDefaultBufferSize)
<span class="lineNum">      66 </span>            :   , mTxInlineFrameUsed(0)
<span class="lineNum">      67 </span>            :   , mTxStreamFrameSize(0)
<span class="lineNum">      68 </span>            :   , mRequestBodyLenRemaining(0)
<span class="lineNum">      69 </span>            :   , mLocalUnacked(0)
<span class="lineNum">      70 </span>            :   , mBlockedOnRwin(false)
<span class="lineNum">      71 </span>            :   , mTotalSent(0)
<span class="lineNum">      72 </span>            :   , mTotalRead(0)
<span class="lineNum">      73 </span>            :   , mPushSource(nullptr)
<span class="lineNum">      74 </span>            :   , mAttempting0RTT(false)
<span class="lineNum">      75 </span>            :   , mIsTunnel(false)
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   , mPlainTextTunnel(false)</span>
<span class="lineNum">      77 </span>            : {
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::Http2Stream %p&quot;, this));</span>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   mServerReceiveWindow = session-&gt;GetServerInitialStreamWindow();</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   mClientReceiveWindow = session-&gt;PushAllowance();</span>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   mTxInlineFrame = MakeUnique&lt;uint8_t[]&gt;(mTxInlineFrameSize);</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :   static_assert(nsISupportsPriority::PRIORITY_LOWEST &lt;= kNormalPriority,
<span class="lineNum">      88 </span>            :                 &quot;Lowest Priority should be less than kNormalPriority&quot;);
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :   // values of priority closer to 0 are higher priority for the priority
<span class="lineNum">      91 </span>            :   // argument. This value is used as a group, which maps to a
<span class="lineNum">      92 </span>            :   // weight that is related to the nsISupportsPriority that we are given.
<span class="lineNum">      93 </span>            :   int32_t httpPriority;
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   if (priority &gt;= nsISupportsPriority::PRIORITY_LOWEST) {</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     httpPriority = kWorstPriority;</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   } else if (priority &lt;= nsISupportsPriority::PRIORITY_HIGHEST) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     httpPriority = kBestPriority;</span>
<span class="lineNum">      98 </span>            :   } else {
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     httpPriority = kNormalPriority + priority;</span>
<span class="lineNum">     100 </span>            :   }
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(httpPriority &gt;= 0);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   SetPriority(static_cast&lt;uint32_t&gt;(httpPriority));</span>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineNoCov">          0 : Http2Stream::~Http2Stream()</span>
<span class="lineNum">     106 </span>            : {
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   ClearTransactionsBlockedOnTunnel();</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   mStreamID = Http2Session::kDeadStreamID;</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::~Http2Stream %p&quot;, this));</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : // ReadSegments() is used to write data down the socket. Generally, HTTP
<span class="lineNum">     114 </span>            : // request data is pulled from the approriate transaction and
<span class="lineNum">     115 </span>            : // converted to HTTP/2 data. Sometimes control data like a window-update is
<span class="lineNum">     116 </span>            : // generated instead.
<a name="117"><span class="lineNum">     117 </span>            : </a>
<span class="lineNum">     118 </span>            : nsresult
<span class="lineNum">     119 </span><span class="lineNoCov">          0 : Http2Stream::ReadSegments(nsAHttpSegmentReader *reader,</span>
<span class="lineNum">     120 </span>            :                           uint32_t count,
<span class="lineNum">     121 </span>            :                           uint32_t *countRead)
<span class="lineNum">     122 </span>            : {
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream %p ReadSegments reader=%p count=%d state=%x&quot;,</span>
<span class="lineNum">     124 </span>            :         this, reader, count, mUpstreamState));
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   nsresult rv = NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   mRequestBlockedOnRead = 0;</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   if (mRecvdFin || mRecvdReset) {</span>
<span class="lineNum">     132 </span>            :     // Don't transmit any request frames if the peer cannot respond
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream %p ReadSegments request stream aborted due to&quot;</span>
<span class="lineNum">     134 </span>            :           &quot; response side closure\n&quot;, this));
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     return NS_ERROR_ABORT;</span>
<span class="lineNum">     136 </span>            :   }
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // avoid runt chunks if possible by anticipating
<span class="lineNum">     139 </span>            :   // full data frames
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   if (count &gt; (mChunkSize + 8)) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     uint32_t numchunks = count / (mChunkSize + 8);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     count = numchunks * (mChunkSize + 8);</span>
<span class="lineNum">     143 </span>            :   }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   switch (mUpstreamState) {</span>
<span class="lineNum">     146 </span>            :   case GENERATING_HEADERS:
<span class="lineNum">     147 </span>            :   case GENERATING_BODY:
<span class="lineNum">     148 </span>            :   case SENDING_BODY:
<span class="lineNum">     149 </span>            :     // Call into the HTTP Transaction to generate the HTTP request
<span class="lineNum">     150 </span>            :     // stream. That stream will show up in OnReadSegment().
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     mSegmentReader = reader;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     rv = mTransaction-&gt;ReadSegments(this, count, countRead);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     mSegmentReader = nullptr;</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ReadSegments %p trans readsegments rv %&quot; PRIx32 &quot; read=%d\n&quot;,</span>
<span class="lineNum">     156 </span>            :           this, static_cast&lt;uint32_t&gt;(rv), *countRead));
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :     // Check to see if the transaction's request could be written out now.
<span class="lineNum">     159 </span>            :     // If not, mark the stream for callback when writing can proceed.
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :         mUpstreamState == GENERATING_HEADERS &amp;&amp;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :         !mRequestHeadersDone)</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       mSession-&gt;TransactionHasDataToWrite(this);</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     // mTxinlineFrameUsed represents any queued un-sent frame. It might
<span class="lineNum">     166 </span>            :     // be 0 if there is no such frame, which is not a gurantee that we
<span class="lineNum">     167 </span>            :     // don't have more request body to send - just that any data that was
<span class="lineNum">     168 </span>            :     // sent comprised a complete HTTP/2 frame. Likewise, a non 0 value is
<span class="lineNum">     169 </span>            :     // a queued, but complete, http/2 frame length.
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     // Mark that we are blocked on read if the http transaction needs to
<span class="lineNum">     172 </span>            :     // provide more of the request message body and there is nothing queued
<span class="lineNum">     173 </span>            :     // for writing
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     if (rv == NS_BASE_STREAM_WOULD_BLOCK &amp;&amp; !mTxInlineFrameUsed)</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       mRequestBlockedOnRead = 1;</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :     // A transaction that had already generated its headers before it was
<span class="lineNum">     178 </span>            :     // queued at the session level (due to concurrency concerns) may not call
<span class="lineNum">     179 </span>            :     // onReadSegment off the ReadSegments() stack above.
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     if (mUpstreamState == GENERATING_HEADERS &amp;&amp; NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       LOG3((&quot;Http2Stream %p ReadSegments forcing OnReadSegment call\n&quot;, this));</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       uint32_t wasted = 0;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       mSegmentReader = reader;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       Unused &lt;&lt; OnReadSegment(&quot;&quot;, 0, &amp;wasted);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       mSegmentReader = nullptr;</span>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :     // If the sending flow control window is open (!mBlockedOnRwin) then
<span class="lineNum">     189 </span>            :     // continue sending the request
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     if (!mBlockedOnRwin &amp;&amp; mOpenGenerated &amp;&amp;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         !mTxInlineFrameUsed &amp;&amp; NS_SUCCEEDED(rv) &amp;&amp; (!*countRead)) {</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(!mQueued);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(mRequestHeadersDone);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       LOG3((&quot;Http2Stream::ReadSegments %p 0x%X: Sending request data complete, &quot;</span>
<span class="lineNum">     195 </span>            :             &quot;mUpstreamState=%x\n&quot;,this, mStreamID, mUpstreamState));
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       if (mSentFin) {</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         ChangeState(UPSTREAM_COMPLETE);</span>
<span class="lineNum">     198 </span>            :       } else {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         GenerateDataFrameHeader(0, true);</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         ChangeState(SENDING_FIN_STREAM);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         mSession-&gt;TransactionHasDataToWrite(this);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         rv = NS_BASE_STREAM_WOULD_BLOCK;</span>
<span class="lineNum">     203 </span>            :       }
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   case SENDING_FIN_STREAM:
<span class="lineNum">     208 </span>            :     // We were trying to send the FIN-STREAM but were blocked from
<span class="lineNum">     209 </span>            :     // sending it out - try again.
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :     if (!mSentFin) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :       mSegmentReader = reader;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       rv = TransmitFrame(nullptr, nullptr, false);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       mSegmentReader = nullptr;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(NS_FAILED(rv) || !mTxInlineFrameUsed,</span>
<span class="lineNum">     215 </span>            :                  &quot;Transmit Frame should be all or nothing&quot;);
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :       if (NS_SUCCEEDED(rv))</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         ChangeState(UPSTREAM_COMPLETE);</span>
<span class="lineNum">     218 </span>            :     } else {
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :       rv = NS_OK;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       mTxInlineFrameUsed = 0;         // cancel fin data packet</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       ChangeState(UPSTREAM_COMPLETE);</span>
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     *countRead = 0;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     // don't change OK to WOULD BLOCK. we are really done sending if OK
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   case UPSTREAM_COMPLETE:
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     *countRead = 0;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     rv = NS_OK;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :   default:
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;Http2Stream::ReadSegments unknown state&quot;);</span>
<span class="lineNum">     236 </span>            :     break;
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">     240 </span>            : }
<a name="241"><span class="lineNum">     241 </span>            : </a>
<span class="lineNum">     242 </span>            : uint64_t
<span class="lineNum">     243 </span><span class="lineNoCov">          0 : Http2Stream::LocalUnAcked()</span>
<span class="lineNum">     244 </span>            : {
<span class="lineNum">     245 </span>            :   // reduce unacked by the amount of undelivered data
<span class="lineNum">     246 </span>            :   // to help assert flow control
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   uint64_t undelivered = mSimpleBuffer.Available();</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   if (undelivered &gt; mLocalUnacked) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     251 </span>            :   }
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   return mLocalUnacked - undelivered;</span>
<span class="lineNum">     253 </span>            : }
<a name="254"><span class="lineNum">     254 </span>            : </a>
<span class="lineNum">     255 </span>            : nsresult
<span class="lineNum">     256 </span><span class="lineNoCov">          0 : Http2Stream::BufferInput(uint32_t count, uint32_t *countWritten)</span>
<span class="lineNum">     257 </span>            : {
<span class="lineNum">     258 </span>            :   char buf[SimpleBufferPage::kSimpleBufferPageSize];
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   if (SimpleBufferPage::kSimpleBufferPageSize &lt; count) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     count = SimpleBufferPage::kSimpleBufferPageSize;</span>
<span class="lineNum">     261 </span>            :   }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   mBypassInputBuffer = 1;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   nsresult rv = mSegmentWriter-&gt;OnWriteSegment(buf, count, countWritten);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   mBypassInputBuffer = 0;</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     rv = mSimpleBuffer.Write(buf, *countWritten);</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(rv == NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span>            :   }
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">     275 </span>            : }
<a name="276"><span class="lineNum">     276 </span>            : </a>
<span class="lineNum">     277 </span>            : bool
<span class="lineNum">     278 </span><span class="lineNoCov">          0 : Http2Stream::DeferCleanup(nsresult status)</span>
<span class="lineNum">     279 </span>            : {
<span class="lineNum">     280 </span>            :   // do not cleanup a stream that has data buffered for the transaction
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   return (NS_SUCCEEDED(status) &amp;&amp; mSimpleBuffer.Available());</span>
<span class="lineNum">     282 </span>            : }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : // WriteSegments() is used to read data off the socket. Generally this is
<span class="lineNum">     285 </span>            : // just a call through to the associated nsHttpTransaction for this stream
<span class="lineNum">     286 </span>            : // for the remaining data bytes indicated by the current DATA frame.
<a name="287"><span class="lineNum">     287 </span>            : </a>
<span class="lineNum">     288 </span>            : nsresult
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : Http2Stream::WriteSegments(nsAHttpSegmentWriter *writer,</span>
<span class="lineNum">     290 </span>            :                            uint32_t count,
<span class="lineNum">     291 </span>            :                            uint32_t *countWritten)
<span class="lineNum">     292 </span>            : {
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mSegmentWriter, &quot;segment writer in progress&quot;);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::WriteSegments %p count=%d state=%x&quot;,</span>
<span class="lineNum">     297 </span>            :         this, count, mUpstreamState));
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   mSegmentWriter = writer;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   nsresult rv = mTransaction-&gt;WriteSegments(this, count, countWritten);</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (rv == NS_BASE_STREAM_WOULD_BLOCK) {</span>
<span class="lineNum">     303 </span>            :     // consuming transaction won't take data. but we need to read it into a buffer so that it
<span class="lineNum">     304 </span>            :     // won't block other streams. but we should not advance the flow control window
<span class="lineNum">     305 </span>            :     // so that we'll eventually push back on the sender.
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     // with tunnels you need to make sure that this is an underlying connction established
<span class="lineNum">     308 </span>            :     // that can be meaningfully giving this signal
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     bool doBuffer = true;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     if (mIsTunnel) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       RefPtr&lt;SpdyConnectTransaction&gt; qiTrans(mTransaction-&gt;QuerySpdyConnectTransaction());</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :       if (qiTrans) {</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         doBuffer = qiTrans-&gt;ConnectedReadyForInput();</span>
<span class="lineNum">     314 </span>            :       }
<span class="lineNum">     315 </span>            :     }
<span class="lineNum">     316 </span>            :     // stash this data
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     if (doBuffer) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :       rv = BufferInput(count, countWritten);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       LOG3((&quot;Http2Stream::WriteSegments %p Buffered %&quot; PRIX32 &quot; %d\n&quot;, this,</span>
<span class="lineNum">     320 </span>            :             static_cast&lt;uint32_t&gt;(rv), *countWritten));
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            :   }
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   mSegmentWriter = nullptr;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">     325 </span>            : }
<a name="326"><span class="lineNum">     326 </span>            : </a>
<span class="lineNum">     327 </span>            : nsresult
<span class="lineNum">     328 </span><span class="lineNoCov">          0 : Http2Stream::MakeOriginURL(const nsACString &amp;origin, RefPtr&lt;nsStandardURL&gt; &amp;url)</span>
<span class="lineNum">     329 </span>            : {
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   nsAutoCString scheme;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   nsresult rv = net_ExtractURLScheme(origin, scheme);</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   return MakeOriginURL(scheme, origin, url);</span>
<span class="lineNum">     334 </span>            : }
<a name="335"><span class="lineNum">     335 </span>            : </a>
<span class="lineNum">     336 </span>            : nsresult
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : Http2Stream::MakeOriginURL(const nsACString &amp;scheme, const nsACString &amp;origin,</span>
<span class="lineNum">     338 </span>            :                            RefPtr&lt;nsStandardURL&gt; &amp;url)
<span class="lineNum">     339 </span>            : {
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   url = new nsStandardURL();</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   nsresult rv = url-&gt;Init(nsIStandardURL::URLTYPE_AUTHORITY,</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                           scheme.EqualsLiteral(&quot;http&quot;) ?</span>
<span class="lineNum">     343 </span>            :                               NS_HTTP_DEFAULT_PORT :
<span class="lineNum">     344 </span>            :                               NS_HTTPS_DEFAULT_PORT,
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                           origin, nullptr, nullptr);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">     347 </span>            : }
<a name="348"><span class="lineNum">     348 </span>            : </a>
<span class="lineNum">     349 </span>            : void
<span class="lineNum">     350 </span><span class="lineNoCov">          0 : Http2Stream::CreatePushHashKey(const nsCString &amp;scheme,</span>
<span class="lineNum">     351 </span>            :                                const nsCString &amp;hostHeader,
<span class="lineNum">     352 </span>            :                                const mozilla::OriginAttributes &amp;originAttributes,
<span class="lineNum">     353 </span>            :                                uint64_t serial,
<span class="lineNum">     354 </span>            :                                const nsACString&amp; pathInfo,
<span class="lineNum">     355 </span>            :                                nsCString &amp;outOrigin,
<span class="lineNum">     356 </span>            :                                nsCString &amp;outKey)
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   nsCString fullOrigin = scheme;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   fullOrigin.AppendLiteral(&quot;://&quot;);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   fullOrigin.Append(hostHeader);</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsStandardURL&gt; origin;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   nsresult rv = Http2Stream::MakeOriginURL(scheme, fullOrigin, origin);</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     rv = origin-&gt;GetAsciiSpec(outOrigin);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     outOrigin.Trim(&quot;/&quot;, false, true, false);</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">     371 </span>            :     // Fallback to plain text copy - this may end up behaving poorly
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     outOrigin = fullOrigin;</span>
<span class="lineNum">     373 </span>            :   }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   outKey = outOrigin;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   outKey.AppendLiteral(&quot;/[&quot;);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   nsAutoCString suffix;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   originAttributes.CreateSuffix(suffix);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   outKey.Append(suffix);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   outKey.Append(']');</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   outKey.AppendLiteral(&quot;/[http2.&quot;);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   outKey.AppendInt(serial);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   outKey.Append(']');</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   outKey.Append(pathInfo);</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 : }</span>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<span class="lineNum">     387 </span>            : nsresult
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : Http2Stream::ParseHttpRequestHeaders(const char *buf,</span>
<span class="lineNum">     389 </span>            :                                      uint32_t avail,
<span class="lineNum">     390 </span>            :                                      uint32_t *countUsed)
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :   // Returns NS_OK even if the headers are incomplete
<span class="lineNum">     393 </span>            :   // set mRequestHeadersDone flag if they are complete
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mUpstreamState == GENERATING_HEADERS);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mRequestHeadersDone);</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::ParseHttpRequestHeaders %p avail=%d state=%x&quot;,</span>
<span class="lineNum">     400 </span>            :         this, avail, mUpstreamState));
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   mFlatHttpRequestHeaders.Append(buf, avail);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   nsHttpRequestHead *head = mTransaction-&gt;RequestHead();</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :   // We can use the simple double crlf because firefox is the
<span class="lineNum">     406 </span>            :   // only client we are parsing
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   int32_t endHeader = mFlatHttpRequestHeaders.Find(&quot;\r\n\r\n&quot;);</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   if (endHeader == kNotFound) {</span>
<span class="lineNum">     410 </span>            :     // We don't have all the headers yet
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ParseHttpRequestHeaders %p &quot;</span>
<span class="lineNum">     412 </span>            :           &quot;Need more header bytes. Len = %d&quot;,
<span class="lineNum">     413 </span>            :           this, mFlatHttpRequestHeaders.Length()));
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     *countUsed = avail;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     416 </span>            :   }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   // We have recvd all the headers, trim the local
<span class="lineNum">     419 </span>            :   // buffer of the final empty line, and set countUsed to reflect
<span class="lineNum">     420 </span>            :   // the whole header has been consumed.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   uint32_t oldLen = mFlatHttpRequestHeaders.Length();</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   mFlatHttpRequestHeaders.SetLength(endHeader + 2);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   *countUsed = avail - (oldLen - endHeader) + 4;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   mRequestHeadersDone = 1;</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   nsAutoCString authorityHeader;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   nsAutoCString hashkey;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   nsresult rv = head-&gt;GetHeader(nsHttp::Host, authorityHeader);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false);</span>
<span class="lineNum">     431 </span>            :     return rv;
<span class="lineNum">     432 </span>            :   }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   nsAutoCString requestURI;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   head-&gt;RequestURI(requestURI);</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   mozilla::OriginAttributes originAttributes;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   mSocketTransport-&gt;GetOriginAttributes(&amp;originAttributes);</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   CreatePushHashKey(nsDependentCString(head-&gt;IsHTTPS() ? &quot;https&quot; : &quot;http&quot;),</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                     authorityHeader, originAttributes, mSession-&gt;Serial(),</span>
<span class="lineNum">     442 </span>            :                     requestURI,
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                     mOrigin, hashkey);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // check the push cache for GET
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if (head-&gt;IsGet()) {</span>
<span class="lineNum">     447 </span>            :     // from :scheme, :authority, :path
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     nsIRequestContext *requestContext = mTransaction-&gt;RequestContext();</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     SpdyPushCache *cache = nullptr;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     if (requestContext) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       requestContext-&gt;GetSpdyPushCache(&amp;cache);</span>
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     Http2PushedStream *pushedStream = nullptr;</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :     // If a push stream is attached to the transaction via onPush, match only with that
<span class="lineNum">     457 </span>            :     // one. This occurs when a push was made with in conjunction with a nsIHttpPushListener
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     nsHttpTransaction *trans = mTransaction-&gt;QueryHttpTransaction();</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     if (trans &amp;&amp; (pushedStream = trans-&gt;TakePushedStream())) {</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       if (pushedStream-&gt;mSession == mSession) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         LOG3((&quot;Pushed Stream match based on OnPush correlation %p&quot;, pushedStream));</span>
<span class="lineNum">     462 </span>            :       } else {
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :         LOG3((&quot;Pushed Stream match failed due to stream mismatch %p %&quot; PRId64 &quot; %&quot; PRId64 &quot;\n&quot;,</span>
<span class="lineNum">     464 </span>            :               pushedStream, pushedStream-&gt;mSession-&gt;Serial(), mSession-&gt;Serial()));
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         pushedStream-&gt;OnPushFailed();</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :         pushedStream = nullptr;</span>
<span class="lineNum">     467 </span>            :       }
<span class="lineNum">     468 </span>            :     }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :     // we remove the pushedstream from the push cache so that
<span class="lineNum">     471 </span>            :     // it will not be used for another GET. This does not destroy the
<span class="lineNum">     472 </span>            :     // stream itself - that is done when the transactionhash is done with it.
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     if (cache &amp;&amp; !pushedStream){</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         pushedStream = cache-&gt;RemovePushedStreamHttp2(hashkey);</span>
<span class="lineNum">     475 </span>            :     }
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     LOG3((&quot;Pushed Stream Lookup &quot;</span>
<span class="lineNum">     478 </span>            :           &quot;session=%p key=%s requestcontext=%p cache=%p hit=%p\n&quot;,
<span class="lineNum">     479 </span>            :           mSession, hashkey.get(), requestContext, cache, pushedStream));
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     if (pushedStream) {</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       LOG3((&quot;Pushed Stream Match located %p id=0x%X key=%s\n&quot;,</span>
<span class="lineNum">     483 </span>            :             pushedStream, pushedStream-&gt;StreamID(), hashkey.get()));
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       pushedStream-&gt;SetConsumerStream(this);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       mPushSource = pushedStream;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       SetSentFin(true);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       AdjustPushedPriority();</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :       // There is probably pushed data buffered so trigger a read manually
<span class="lineNum">     490 </span>            :       // as we can't rely on future network events to do it
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       mSession-&gt;ConnectPushedStream(this);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       mOpenGenerated = 1;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">     494 </span>            :     }
<span class="lineNum">     495 </span>            :   }
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     497 </span>            : }
<span class="lineNum">     498 </span>            : 
<a name="499"><span class="lineNum">     499 </span>            : // This is really a headers frame, but open is pretty clear from a workflow pov</a>
<span class="lineNum">     500 </span>            : nsresult
<span class="lineNum">     501 </span><span class="lineNoCov">          0 : Http2Stream::GenerateOpen()</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span>            :   // It is now OK to assign a streamID that we are assured will
<span class="lineNum">     504 </span>            :   // be monotonically increasing amongst new streams on this
<span class="lineNum">     505 </span>            :   // session
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   mStreamID = mSession-&gt;RegisterStreamID(this);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mStreamID &amp; 1, &quot;Http2 Stream Channel ID must be odd&quot;);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mOpenGenerated);</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   mOpenGenerated = 1;</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   nsHttpRequestHead *head = mTransaction-&gt;RequestHead();</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   nsAutoCString requestURI;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   head-&gt;RequestURI(requestURI);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream %p Stream ID 0x%X [session=%p] for URI %s\n&quot;,</span>
<span class="lineNum">     516 </span>            :         this, mStreamID, mSession, requestURI.get()));
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   if (mStreamID &gt;= 0x80000000) {</span>
<span class="lineNum">     519 </span>            :     // streamID must fit in 31 bits. Evading This is theoretically possible
<span class="lineNum">     520 </span>            :     // because stream ID assignment is asynchronous to stream creation
<span class="lineNum">     521 </span>            :     // because of the protocol requirement that the new stream ID
<span class="lineNum">     522 </span>            :     // be monotonically increasing. In reality this is really not possible
<span class="lineNum">     523 </span>            :     // because new streams stop being added to a session with millions of
<span class="lineNum">     524 </span>            :     // IDs still available and no race condition is going to bridge that gap;
<span class="lineNum">     525 </span>            :     // so we can be comfortable on just erroring out for correctness in that
<span class="lineNum">     526 </span>            :     // case.
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     LOG3((&quot;Stream assigned out of range ID: 0x%X&quot;, mStreamID));</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     return NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">     529 </span>            :   }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :   // Now we need to convert the flat http headers into a set
<span class="lineNum">     532 </span>            :   // of HTTP/2 headers by writing to mTxInlineFrame{sz}
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   nsCString compressedData;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   nsAutoCString authorityHeader;</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   nsresult rv = head-&gt;GetHeader(nsHttp::Host, authorityHeader);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false);</span>
<span class="lineNum">     539 </span>            :     return rv;
<span class="lineNum">     540 </span>            :   }
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   nsDependentCString scheme(head-&gt;IsHTTPS() ? &quot;https&quot; : &quot;http&quot;);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   if (head-&gt;IsConnect()) {</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mTransaction-&gt;QuerySpdyConnectTransaction());</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     mIsTunnel = true;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     mRequestBodyLenRemaining = 0x0fffffffffffffffULL;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :     // Our normal authority has an implicit port, best to use an
<span class="lineNum">     549 </span>            :     // explicit one with a tunnel
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     nsHttpConnectionInfo *ci = mTransaction-&gt;ConnectionInfo();</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     if (!ci) {</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       return NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">     553 </span>            :     }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     authorityHeader = ci-&gt;GetOrigin();</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     authorityHeader.Append(':');</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     authorityHeader.AppendInt(ci-&gt;OriginPort());</span>
<span class="lineNum">     558 </span>            :   }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   nsAutoCString method;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   nsAutoCString path;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   head-&gt;Method(method);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   head-&gt;Path(path);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   rv = mSession-&gt;Compressor()-&gt;EncodeHeaderBlock(mFlatHttpRequestHeaders,</span>
<span class="lineNum">     565 </span>            :                                                  method,
<span class="lineNum">     566 </span>            :                                                  path,
<span class="lineNum">     567 </span>            :                                                  authorityHeader,
<span class="lineNum">     568 </span>            :                                                  scheme,
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                                                  head-&gt;IsConnect(),</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                                                  compressedData);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   int64_t clVal = mSession-&gt;Compressor()-&gt;GetParsedContentLength();</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   if (clVal != -1) {</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     mRequestBodyLenRemaining = clVal;</span>
<span class="lineNum">     576 </span>            :   }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   // Determine whether to put the fin bit on the header frame or whether
<span class="lineNum">     579 </span>            :   // to wait for a data packet to put it on.
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   uint8_t firstFrameFlags =  Http2Session::kFlag_PRIORITY;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   if (head-&gt;IsGet() ||</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       head-&gt;IsHead()) {</span>
<span class="lineNum">     584 </span>            :     // for GET and HEAD place the fin bit right on the
<span class="lineNum">     585 </span>            :     // header packet
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     SetSentFin(true);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     firstFrameFlags |= Http2Session::kFlag_END_STREAM;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   } else if (head-&gt;IsPost() ||</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :              head-&gt;IsPut() ||</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :              head-&gt;IsConnect()) {</span>
<span class="lineNum">     592 </span>            :     // place fin in a data frame even for 0 length messages for iterop
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   } else if (!mRequestBodyLenRemaining) {</span>
<span class="lineNum">     594 </span>            :     // for other HTTP extension methods, rely on the content-length
<span class="lineNum">     595 </span>            :     // to determine whether or not to put fin on headers
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     SetSentFin(true);</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     firstFrameFlags |= Http2Session::kFlag_END_STREAM;</span>
<span class="lineNum">     598 </span>            :   }
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :   // split this one HEADERS frame up into N HEADERS + CONTINUATION frames if it exceeds the
<span class="lineNum">     601 </span>            :   // 2^14-1 limit for 1 frame. Do it by inserting header size gaps in the existing
<span class="lineNum">     602 </span>            :   // frame for the new headers and for the first one a priority field. There is
<span class="lineNum">     603 </span>            :   // no question this is ugly, but a 16KB HEADERS frame should be a long
<span class="lineNum">     604 </span>            :   // tail event, so this is really just for correctness and a nop in the base case.
<span class="lineNum">     605 </span>            :   //
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mTxInlineFrameUsed);</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   uint32_t dataLength = compressedData.Length();</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   uint32_t maxFrameData = Http2Session::kMaxFrameData - 5; // 5 bytes for priority</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   uint32_t numFrames = 1;</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   if (dataLength &gt; maxFrameData) {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     numFrames += ((dataLength - maxFrameData) + Http2Session::kMaxFrameData - 1) /</span>
<span class="lineNum">     615 </span>            :       Http2Session::kMaxFrameData;
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     MOZ_ASSERT (numFrames &gt; 1);</span>
<span class="lineNum">     617 </span>            :   }
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   // note that we could still have 1 frame for 0 bytes of data. that's ok.
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   uint32_t messageSize = dataLength;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   messageSize += Http2Session::kFrameHeaderBytes + 5; // frame header + priority overhead in HEADERS frame</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   messageSize += (numFrames - 1) * Http2Session::kFrameHeaderBytes; // frame header overhead in CONTINUATION frames</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   EnsureBuffer(mTxInlineFrame, messageSize,</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                mTxInlineFrameUsed, mTxInlineFrameSize);</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   mTxInlineFrameUsed += messageSize;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   UpdatePriorityDependency();</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream %p Generating %d bytes of HEADERS for stream 0x%X with &quot;</span>
<span class="lineNum">     631 </span>            :         &quot;priority weight %u dep 0x%X frames %u uri=%s\n&quot;,
<span class="lineNum">     632 </span>            :         this, mTxInlineFrameUsed, mStreamID, mPriorityWeight,
<span class="lineNum">     633 </span>            :         mPriorityDependency, numFrames, requestURI.get()));
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   uint32_t outputOffset = 0;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   uint32_t compressedDataOffset = 0;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   for (uint32_t idx = 0; idx &lt; numFrames; ++idx) {</span>
<span class="lineNum">     638 </span>            :     uint32_t flags, frameLen;
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     bool lastFrame = (idx == numFrames - 1);</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     flags = 0;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     frameLen = maxFrameData;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     if (!idx) {</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :       flags |= firstFrameFlags;</span>
<span class="lineNum">     645 </span>            :       // Only the first frame needs the 4-byte offset
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :       maxFrameData = Http2Session::kMaxFrameData;</span>
<span class="lineNum">     647 </span>            :     }
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     if (lastFrame) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       frameLen = dataLength;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       flags |= Http2Session::kFlag_END_HEADERS;</span>
<span class="lineNum">     651 </span>            :     }
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     dataLength -= frameLen;</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     mSession-&gt;CreateFrameHeader(</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :       mTxInlineFrame.get() + outputOffset,</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       frameLen + (idx ? 0 : 5),</span>
<span class="lineNum">     657 </span>            :       (idx) ? Http2Session::FRAME_TYPE_CONTINUATION : Http2Session::FRAME_TYPE_HEADERS,
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :       flags, mStreamID);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     outputOffset += Http2Session::kFrameHeaderBytes;</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     if (!idx) {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       uint32_t wireDep = PR_htonl(mPriorityDependency);</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       memcpy(mTxInlineFrame.get() + outputOffset, &amp;wireDep, 4);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       memcpy(mTxInlineFrame.get() + outputOffset + 4, &amp;mPriorityWeight, 1);</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       outputOffset += 5;</span>
<span class="lineNum">     666 </span>            :     }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     memcpy(mTxInlineFrame.get() + outputOffset,</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :            compressedData.BeginReading() + compressedDataOffset, frameLen);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     compressedDataOffset += frameLen;</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     outputOffset += frameLen;</span>
<span class="lineNum">     672 </span>            :   }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   Telemetry::Accumulate(Telemetry::SPDY_SYN_SIZE, compressedData.Length());</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   // The size of the input headers is approximate
<span class="lineNum">     677 </span>            :   uint32_t ratio =
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     compressedData.Length() * 100 /</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     (11 + requestURI.Length() +</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :      mFlatHttpRequestHeaders.Length());</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :   mFlatHttpRequestHeaders.Truncate();</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   Telemetry::Accumulate(Telemetry::SPDY_SYN_RATIO, ratio);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     685 </span>            : }
<a name="686"><span class="lineNum">     686 </span>            : </a>
<span class="lineNum">     687 </span>            : void
<span class="lineNum">     688 </span><span class="lineNoCov">          0 : Http2Stream::AdjustInitialWindow()</span>
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span>            :   // The default initial_window is sized for pushed streams. When we
<span class="lineNum">     691 </span>            :   // generate a client pulled stream we want to disable flow control for
<span class="lineNum">     692 </span>            :   // the stream with a window update. Do the same for pushed streams
<span class="lineNum">     693 </span>            :   // when they connect to a pull.
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   // &gt;0 even numbered IDs are pushed streams.
<span class="lineNum">     696 </span>            :   // odd numbered IDs are pulled streams.
<span class="lineNum">     697 </span>            :   // 0 is the sink for a pushed stream.
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   Http2Stream *stream = this;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   if (!mStreamID) {</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mPushSource);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     if (!mPushSource)</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     stream = mPushSource;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(stream-&gt;mStreamID);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!(stream-&gt;mStreamID &amp; 1)); // is a push stream</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :     // If the pushed stream has recvd a FIN, there is no reason to update
<span class="lineNum">     708 </span>            :     // the window
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     if (stream-&gt;RecvdFin() || stream-&gt;RecvdReset())</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     711 </span>            :   }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   if (stream-&gt;mState == RESERVED_BY_REMOTE) {</span>
<span class="lineNum">     714 </span>            :     // h2-14 prevents sending a window update in this state
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     716 </span>            :   }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :   // right now mClientReceiveWindow is the lower push limit
<span class="lineNum">     719 </span>            :   // bump it up to the pull limit set by the channel or session
<span class="lineNum">     720 </span>            :   // don't allow windows less than push
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   uint32_t bump = 0;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   nsHttpTransaction *trans = mTransaction-&gt;QueryHttpTransaction();</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   if (trans &amp;&amp; trans-&gt;InitialRwin()) {</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     bump = (trans-&gt;InitialRwin() &gt; mClientReceiveWindow) ?</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       (trans-&gt;InitialRwin() - mClientReceiveWindow) : 0;</span>
<span class="lineNum">     726 </span>            :   } else {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mSession-&gt;InitialRwin() &gt;= mClientReceiveWindow);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :     bump = mSession-&gt;InitialRwin() - mClientReceiveWindow;</span>
<span class="lineNum">     729 </span>            :   }
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   LOG3((&quot;AdjustInitialwindow increased flow control window %p 0x%X %u\n&quot;,</span>
<span class="lineNum">     732 </span>            :         this, stream-&gt;mStreamID, bump));
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   if (!bump) { // nothing to do</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     735 </span>            :   }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   EnsureBuffer(mTxInlineFrame, mTxInlineFrameUsed + Http2Session::kFrameHeaderBytes + 4,</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :                mTxInlineFrameUsed, mTxInlineFrameSize);</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   uint8_t *packet = mTxInlineFrame.get() + mTxInlineFrameUsed;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   mTxInlineFrameUsed += Http2Session::kFrameHeaderBytes + 4;</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   mSession-&gt;CreateFrameHeader(packet, 4,</span>
<span class="lineNum">     743 </span>            :                               Http2Session::FRAME_TYPE_WINDOW_UPDATE,
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                               0, stream-&gt;mStreamID);</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   mClientReceiveWindow += bump;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   bump = PR_htonl(bump);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   memcpy(packet + Http2Session::kFrameHeaderBytes, &amp;bump, 4);</span>
<span class="lineNum">     749 </span>            : }
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : void
<span class="lineNum">     752 </span><span class="lineNoCov">          0 : Http2Stream::AdjustPushedPriority()</span>
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span>            :   // &gt;0 even numbered IDs are pushed streams. odd numbered IDs are pulled streams.
<span class="lineNum">     755 </span>            :   // 0 is the sink for a pushed stream.
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   if (mStreamID || !mPushSource)</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mPushSource-&gt;mStreamID &amp;&amp; !(mPushSource-&gt;mStreamID &amp; 1));</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :   // If the pushed stream has recvd a FIN, there is no reason to update
<span class="lineNum">     763 </span>            :   // the window
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   if (mPushSource-&gt;RecvdFin() || mPushSource-&gt;RecvdReset())</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   EnsureBuffer(mTxInlineFrame, mTxInlineFrameUsed + Http2Session::kFrameHeaderBytes + 5,</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :                mTxInlineFrameUsed, mTxInlineFrameSize);</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   uint8_t *packet = mTxInlineFrame.get() + mTxInlineFrameUsed;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   mTxInlineFrameUsed += Http2Session::kFrameHeaderBytes + 5;</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   mSession-&gt;CreateFrameHeader(packet, 5,</span>
<span class="lineNum">     773 </span>            :                               Http2Session::FRAME_TYPE_PRIORITY, 0,
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                               mPushSource-&gt;mStreamID);</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   mPushSource-&gt;SetPriority(mPriority);</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   memset(packet + Http2Session::kFrameHeaderBytes, 0, 4);</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   memcpy(packet + Http2Session::kFrameHeaderBytes + 4, &amp;mPriorityWeight, 1);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   LOG3((&quot;AdjustPushedPriority %p id 0x%X to weight %X\n&quot;, this, mPushSource-&gt;mStreamID,</span>
<span class="lineNum">     781 </span>            :         mPriorityWeight));
<span class="lineNum">     782 </span>            : }
<a name="783"><span class="lineNum">     783 </span>            : </a>
<span class="lineNum">     784 </span>            : void
<span class="lineNum">     785 </span><span class="lineNoCov">          0 : Http2Stream::UpdateTransportReadEvents(uint32_t count)</span>
<span class="lineNum">     786 </span>            : {
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :   mTotalRead += count;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   if (!mSocketTransport) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   mTransaction-&gt;OnTransportStatus(mSocketTransport,</span>
<span class="lineNum">     793 </span>            :                                   NS_NET_STATUS_RECEIVING_FROM,
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :                                   mTotalRead);</span>
<span class="lineNum">     795 </span>            : }
<a name="796"><span class="lineNum">     796 </span>            : </a>
<span class="lineNum">     797 </span>            : void
<span class="lineNum">     798 </span><span class="lineNoCov">          0 : Http2Stream::UpdateTransportSendEvents(uint32_t count)</span>
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   mTotalSent += count;</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :   // normally on non-windows platform we use TCP autotuning for
<span class="lineNum">     803 </span>            :   // the socket buffers, and this works well (managing enough
<span class="lineNum">     804 </span>            :   // buffers for BDP while conserving memory) for HTTP even when
<span class="lineNum">     805 </span>            :   // it creates really deep queues. However this 'buffer bloat' is
<span class="lineNum">     806 </span>            :   // a problem for http/2 because it ruins the low latency properties
<span class="lineNum">     807 </span>            :   // necessary for PING and cancel to work meaningfully.
<span class="lineNum">     808 </span>            :   //
<span class="lineNum">     809 </span>            :   // If this stream represents a large upload, disable autotuning for
<span class="lineNum">     810 </span>            :   // the session and cap the send buffers by default at 128KB.
<span class="lineNum">     811 </span>            :   // (10Mbit/sec @ 100ms)
<span class="lineNum">     812 </span>            :   //
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   uint32_t bufferSize = gHttpHandler-&gt;SpdySendBufferSize();</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   if ((mTotalSent &gt; bufferSize) &amp;&amp; !mSetTCPSocketBuffer) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     mSetTCPSocketBuffer = 1;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     mSocketTransport-&gt;SetSendBufferSize(bufferSize);</span>
<span class="lineNum">     817 </span>            :   }
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   if (mUpstreamState != SENDING_FIN_STREAM)</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     mTransaction-&gt;OnTransportStatus(mSocketTransport,</span>
<span class="lineNum">     821 </span>            :                                     NS_NET_STATUS_SENDING_TO,
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :                                     mTotalSent);</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   if (!mSentWaitingFor &amp;&amp; !mRequestBodyLenRemaining) {</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     mSentWaitingFor = 1;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     mTransaction-&gt;OnTransportStatus(mSocketTransport,</span>
<span class="lineNum">     827 </span>            :                                     NS_NET_STATUS_WAITING_FOR,
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :                                     0);</span>
<span class="lineNum">     829 </span>            :   }
<span class="lineNum">     830 </span><span class="lineNoCov">          0 : }</span>
<a name="831"><span class="lineNum">     831 </span>            : </a>
<span class="lineNum">     832 </span>            : nsresult
<span class="lineNum">     833 </span><span class="lineNoCov">          0 : Http2Stream::TransmitFrame(const char *buf,</span>
<span class="lineNum">     834 </span>            :                            uint32_t *countUsed,
<span class="lineNum">     835 </span>            :                            bool forceCommitment)
<span class="lineNum">     836 </span>            : {
<span class="lineNum">     837 </span>            :   // If TransmitFrame returns SUCCESS than all the data is sent (or at least
<span class="lineNum">     838 </span>            :   // buffered at the session level), if it returns WOULD_BLOCK then none of
<span class="lineNum">     839 </span>            :   // the data is sent.
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :   // You can call this function with no data and no out parameter in order to
<span class="lineNum">     842 </span>            :   // flush internal buffers that were previously blocked on writing. You can
<span class="lineNum">     843 </span>            :   // of course feed new data to it as well.
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::TransmitFrame %p inline=%d stream=%d&quot;,</span>
<span class="lineNum">     846 </span>            :         this, mTxInlineFrameUsed, mTxStreamFrameSize));
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   if (countUsed)</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     *countUsed = 0;</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   if (!mTxInlineFrameUsed) {</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!buf);</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     853 </span>            :   }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mTxInlineFrameUsed, &quot;empty stream frame in transmit&quot;);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mSegmentReader, &quot;TransmitFrame with null mSegmentReader&quot;);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   MOZ_ASSERT((buf &amp;&amp; countUsed) || (!buf &amp;&amp; !countUsed),</span>
<span class="lineNum">     858 </span>            :              &quot;TransmitFrame arguments inconsistent&quot;);
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   uint32_t transmittedCount;
<span class="lineNum">     861 </span>            :   nsresult rv;
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :   // In the (relatively common) event that we have a small amount of data
<span class="lineNum">     864 </span>            :   // split between the inlineframe and the streamframe, then move the stream
<span class="lineNum">     865 </span>            :   // data into the inlineframe via copy in order to coalesce into one write.
<span class="lineNum">     866 </span>            :   // Given the interaction with ssl this is worth the small copy cost.
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   if (mTxStreamFrameSize &amp;&amp; mTxInlineFrameUsed &amp;&amp;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       mTxStreamFrameSize &lt; Http2Session::kDefaultBufferSize &amp;&amp;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :       mTxInlineFrameUsed + mTxStreamFrameSize &lt; mTxInlineFrameSize) {</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     LOG3((&quot;Coalesce Transmit&quot;));</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     memcpy (&amp;mTxInlineFrame[mTxInlineFrameUsed], buf, mTxStreamFrameSize);</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     if (countUsed)</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       *countUsed += mTxStreamFrameSize;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     mTxInlineFrameUsed += mTxStreamFrameSize;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     mTxStreamFrameSize = 0;</span>
<span class="lineNum">     876 </span>            :   }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   rv =
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     mSegmentReader-&gt;CommitToSegmentSize(mTxStreamFrameSize + mTxInlineFrameUsed,</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                                         forceCommitment);</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   if (rv == NS_BASE_STREAM_WOULD_BLOCK) {</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!forceCommitment, &quot;forceCommitment with WOULD_BLOCK&quot;);</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     mSession-&gt;TransactionHasDataToWrite(this);</span>
<span class="lineNum">     885 </span>            :   }
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv))     // this will include WOULD_BLOCK</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   // This function calls mSegmentReader-&gt;OnReadSegment to report the actual http/2
<span class="lineNum">     890 </span>            :   // bytes through to the session object and then the HttpConnection which calls
<span class="lineNum">     891 </span>            :   // the socket write function. It will accept all of the inline and stream
<span class="lineNum">     892 </span>            :   // data because of the above 'commitment' even if it has to buffer
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   rv = mSession-&gt;BufferOutput(reinterpret_cast&lt;char*&gt;(mTxInlineFrame.get()),</span>
<span class="lineNum">     895 </span>            :                               mTxInlineFrameUsed,
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                               &amp;transmittedCount);</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::TransmitFrame for inline BufferOutput session=%p &quot;</span>
<span class="lineNum">     898 </span>            :         &quot;stream=%p result %&quot; PRIx32 &quot; len=%d&quot;,
<span class="lineNum">     899 </span>            :         mSession, this, static_cast&lt;uint32_t&gt;(rv), transmittedCount));
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(rv != NS_BASE_STREAM_WOULD_BLOCK,</span>
<span class="lineNum">     902 </span>            :              &quot;inconsistent inline commitment result&quot;);
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv))</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(transmittedCount == mTxInlineFrameUsed,</span>
<span class="lineNum">     908 </span>            :              &quot;inconsistent inline commitment count&quot;);
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   Http2Session::LogIO(mSession, this, &quot;Writing from Inline Buffer&quot;,</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                        reinterpret_cast&lt;char*&gt;(mTxInlineFrame.get()),</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                        transmittedCount);</span>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   if (mTxStreamFrameSize) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     if (!buf) {</span>
<span class="lineNum">     916 </span>            :       // this cannot happen
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(false, &quot;Stream transmit with null buf argument to &quot;</span>
<span class="lineNum">     918 </span>            :                  &quot;TransmitFrame()&quot;);
<span class="lineNum">     919 </span>            :       LOG3((&quot;Stream transmit with null buf argument to TransmitFrame()\n&quot;));
<span class="lineNum">     920 </span>            :       return NS_ERROR_UNEXPECTED;
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :     // If there is already data buffered, just add to that to form
<span class="lineNum">     924 </span>            :     // a single TLS Application Data Record - otherwise skip the memcpy
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     if (mSession-&gt;AmountOfOutputBuffered()) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       rv = mSession-&gt;BufferOutput(buf, mTxStreamFrameSize,</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :                                   &amp;transmittedCount);</span>
<span class="lineNum">     928 </span>            :     } else {
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :       rv = mSession-&gt;OnReadSegment(buf, mTxStreamFrameSize,</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                                    &amp;transmittedCount);</span>
<span class="lineNum">     931 </span>            :     }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::TransmitFrame for regular session=%p &quot;</span>
<span class="lineNum">     934 </span>            :           &quot;stream=%p result %&quot; PRIx32 &quot; len=%d&quot;,
<span class="lineNum">     935 </span>            :           mSession, this, static_cast&lt;uint32_t&gt;(rv), transmittedCount));
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(rv != NS_BASE_STREAM_WOULD_BLOCK,</span>
<span class="lineNum">     938 </span>            :                &quot;inconsistent stream commitment result&quot;);
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv))</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       return rv;</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(transmittedCount == mTxStreamFrameSize,</span>
<span class="lineNum">     944 </span>            :                &quot;inconsistent stream commitment count&quot;);
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     Http2Session::LogIO(mSession, this, &quot;Writing from Transaction Buffer&quot;,</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :                          buf, transmittedCount);</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     *countUsed += mTxStreamFrameSize;</span>
<span class="lineNum">     950 </span>            :   }
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   if (!mAttempting0RTT) {</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     mSession-&gt;FlushOutputQueue();</span>
<span class="lineNum">     954 </span>            :   }
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :   // calling this will trigger waiting_for if mRequestBodyLenRemaining is 0
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   UpdateTransportSendEvents(mTxInlineFrameUsed + mTxStreamFrameSize);</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   mTxInlineFrameUsed = 0;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   mTxStreamFrameSize = 0;</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     963 </span>            : }
<a name="964"><span class="lineNum">     964 </span>            : </a>
<span class="lineNum">     965 </span>            : void
<span class="lineNum">     966 </span><span class="lineNoCov">          0 : Http2Stream::ChangeState(enum upstreamStateType newState)</span>
<span class="lineNum">     967 </span>            : {
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::ChangeState() %p from %X to %X&quot;,</span>
<span class="lineNum">     969 </span>            :         this, mUpstreamState, newState));
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   mUpstreamState = newState;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 : }</span>
<a name="972"><span class="lineNum">     972 </span>            : </a>
<span class="lineNum">     973 </span>            : void
<span class="lineNum">     974 </span><span class="lineNoCov">          0 : Http2Stream::GenerateDataFrameHeader(uint32_t dataLength, bool lastFrame)</span>
<span class="lineNum">     975 </span>            : {
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::GenerateDataFrameHeader %p len=%d last=%d&quot;,</span>
<span class="lineNum">     977 </span>            :         this, dataLength, lastFrame));
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mTxInlineFrameUsed, &quot;inline frame not empty&quot;);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mTxStreamFrameSize, &quot;stream frame not empty&quot;);</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   uint8_t frameFlags = 0;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   if (lastFrame) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     frameFlags |= Http2Session::kFlag_END_STREAM;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     if (dataLength)</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :       SetSentFin(true);</span>
<span class="lineNum">     988 </span>            :   }
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   mSession-&gt;CreateFrameHeader(mTxInlineFrame.get(),</span>
<span class="lineNum">     991 </span>            :                               dataLength,
<span class="lineNum">     992 </span>            :                               Http2Session::FRAME_TYPE_DATA,
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :                               frameFlags, mStreamID);</span>
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   mTxInlineFrameUsed = Http2Session::kFrameHeaderBytes;</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   mTxStreamFrameSize = dataLength;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            : // ConvertResponseHeaders is used to convert the response headers
<a name="1000"><span class="lineNum">    1000 </span>            : // into HTTP/1 format and report some telemetry</a>
<span class="lineNum">    1001 </span>            : nsresult
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 : Http2Stream::ConvertResponseHeaders(Http2Decompressor *decompressor,</span>
<span class="lineNum">    1003 </span>            :                                     nsACString &amp;aHeadersIn,
<span class="lineNum">    1004 </span>            :                                     nsACString &amp;aHeadersOut,
<span class="lineNum">    1005 </span>            :                                     int32_t &amp;httpResponseCode)
<span class="lineNum">    1006 </span>            : {
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :   aHeadersOut.Truncate();</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   aHeadersOut.SetCapacity(aHeadersIn.Length() + 512);</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :   nsresult rv =
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     decompressor-&gt;DecodeHeaderBlock(reinterpret_cast&lt;const uint8_t *&gt;(aHeadersIn.BeginReading()),</span>
<span class="lineNum">    1012 </span>            :                                     aHeadersIn.Length(),
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                                     aHeadersOut, false);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertResponseHeaders %p decode Error\n&quot;, this));</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1017 </span>            :   }
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   nsAutoCString statusString;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   decompressor-&gt;GetStatus(statusString);</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   if (statusString.IsEmpty()) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertResponseHeaders %p Error - no status\n&quot;, this));</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     return NS_ERROR_ILLEGAL_VALUE;</span>
<span class="lineNum">    1024 </span>            :   }
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            :   nsresult errcode;
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   httpResponseCode = statusString.ToInteger(&amp;errcode);</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            :   // Ensure the :status is just an HTTP status code
<span class="lineNum">    1030 </span>            :   // https://tools.ietf.org/html/rfc7540#section-8.1.2.4
<span class="lineNum">    1031 </span>            :   // https://bugzilla.mozilla.org/show_bug.cgi?id=1352146
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   nsAutoCString parsedStatusString;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   parsedStatusString.AppendInt(httpResponseCode);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   if (!parsedStatusString.Equals(statusString)) {</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertResposeHeaders %p status %s is not just a code&quot;,</span>
<span class="lineNum">    1036 </span>            :           this, statusString.BeginReading()));
<span class="lineNum">    1037 </span>            :     // Results in stream reset with PROTOCOL_ERROR
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     return NS_ERROR_ILLEGAL_VALUE;</span>
<span class="lineNum">    1039 </span>            :   }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::ConvertResponseHeaders %p response code %d\n&quot;, this, httpResponseCode));</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   if (mIsTunnel) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream %p Tunnel Response code %d&quot;, this, httpResponseCode));</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :     if ((httpResponseCode / 100) != 2) {</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :       MapStreamToPlainText();</span>
<span class="lineNum">    1046 </span>            :     }
<span class="lineNum">    1047 </span>            :   }
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if (httpResponseCode == 101) {</span>
<span class="lineNum">    1050 </span>            :     // 8.1.1 of h2 disallows 101.. throw PROTOCOL_ERROR on stream
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertResponseHeaders %p Error - status == 101\n&quot;, this));</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     return NS_ERROR_ILLEGAL_VALUE;</span>
<span class="lineNum">    1053 </span>            :   }
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   if (httpResponseCode == 421) {</span>
<span class="lineNum">    1056 </span>            :     // Origin Frame requires 421 to remove this origin from the origin set
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     mSession-&gt;Received421(mTransaction-&gt;ConnectionInfo());</span>
<span class="lineNum">    1058 </span>            :   }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   if (aHeadersIn.Length() &amp;&amp; aHeadersOut.Length()) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_SIZE, aHeadersIn.Length());</span>
<span class="lineNum">    1062 </span>            :     uint32_t ratio =
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       aHeadersIn.Length() * 100 / aHeadersOut.Length();</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     Telemetry::Accumulate(Telemetry::SPDY_SYN_REPLY_RATIO, ratio);</span>
<span class="lineNum">    1065 </span>            :   }
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :   // The decoding went ok. Now we can customize and clean up.
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   aHeadersIn.Truncate();</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   aHeadersOut.Append(&quot;X-Firefox-Spdy: h2&quot;);</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   aHeadersOut.Append(&quot;\r\n\r\n&quot;);</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   LOG ((&quot;decoded response headers are:\n%s&quot;, aHeadersOut.BeginReading()));</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   if (mIsTunnel &amp;&amp; !mPlainTextTunnel) {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     aHeadersOut.Truncate();</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     LOG((&quot;Http2Stream::ConvertHeaders %p 0x%X headers removed for tunnel\n&quot;,</span>
<span class="lineNum">    1076 </span>            :          this, mStreamID));
<span class="lineNum">    1077 </span>            :   }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1079 </span>            : }
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            : // ConvertPushHeaders is used to convert the pushed request headers
<a name="1082"><span class="lineNum">    1082 </span>            : // into HTTP/1 format and report some telemetry</a>
<span class="lineNum">    1083 </span>            : nsresult
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : Http2Stream::ConvertPushHeaders(Http2Decompressor *decompressor,</span>
<span class="lineNum">    1085 </span>            :                                 nsACString &amp;aHeadersIn,
<span class="lineNum">    1086 </span>            :                                 nsACString &amp;aHeadersOut)
<span class="lineNum">    1087 </span>            : {
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   aHeadersOut.Truncate();</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   aHeadersOut.SetCapacity(aHeadersIn.Length() + 512);</span>
<span class="lineNum">    1090 </span>            :   nsresult rv =
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     decompressor-&gt;DecodeHeaderBlock(reinterpret_cast&lt;const uint8_t *&gt;(aHeadersIn.BeginReading()),</span>
<span class="lineNum">    1092 </span>            :                                     aHeadersIn.Length(),
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                                     aHeadersOut, true);</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertPushHeaders %p Error\n&quot;, this));</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1097 </span>            :   }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   nsCString method;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   decompressor-&gt;GetHost(mHeaderHost);</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   decompressor-&gt;GetScheme(mHeaderScheme);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   decompressor-&gt;GetPath(mHeaderPath);</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   if (mHeaderHost.IsEmpty() || mHeaderScheme.IsEmpty() || mHeaderPath.IsEmpty()) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertPushHeaders %p Error - missing required &quot;</span>
<span class="lineNum">    1106 </span>            :           &quot;host=%s scheme=%s path=%s\n&quot;, this, mHeaderHost.get(), mHeaderScheme.get(),
<span class="lineNum">    1107 </span>            :           mHeaderPath.get()));
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     return NS_ERROR_ILLEGAL_VALUE;</span>
<span class="lineNum">    1109 </span>            :   }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   decompressor-&gt;GetMethod(method);</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :   if (!method.EqualsLiteral(&quot;GET&quot;)) {</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ConvertPushHeaders %p Error - method not supported: %s\n&quot;,</span>
<span class="lineNum">    1114 </span>            :           this, method.get()));
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_IMPLEMENTED;</span>
<span class="lineNum">    1116 </span>            :   }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   aHeadersIn.Truncate();</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   LOG ((&quot;id 0x%X decoded push headers %s %s %s are:\n%s&quot;, mStreamID,</span>
<span class="lineNum">    1120 </span>            :         mHeaderScheme.get(), mHeaderHost.get(), mHeaderPath.get(),
<span class="lineNum">    1121 </span>            :         aHeadersOut.BeginReading()));
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1123 </span>            : }
<a name="1124"><span class="lineNum">    1124 </span>            : </a>
<span class="lineNum">    1125 </span>            : void
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 : Http2Stream::Close(nsresult reason)</span>
<span class="lineNum">    1127 </span>            : {
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   mTransaction-&gt;Close(reason);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 : }</span>
<a name="1130"><span class="lineNum">    1130 </span>            : </a>
<span class="lineNum">    1131 </span>            : void
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 : Http2Stream::SetResponseIsComplete()</span>
<span class="lineNum">    1133 </span>            : {
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   nsHttpTransaction *trans = mTransaction-&gt;QueryHttpTransaction();</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   if (trans) {</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     trans-&gt;SetResponseIsComplete();</span>
<span class="lineNum">    1137 </span>            :   }
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 : }</span>
<a name="1139"><span class="lineNum">    1139 </span>            : </a>
<span class="lineNum">    1140 </span>            : void
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 : Http2Stream::SetAllHeadersReceived()</span>
<span class="lineNum">    1142 </span>            : {
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   if (mAllHeadersReceived) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1145 </span>            :   }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :   if (mState == RESERVED_BY_REMOTE) {</span>
<span class="lineNum">    1148 </span>            :     // pushed streams needs to wait until headers have
<span class="lineNum">    1149 </span>            :     // arrived to open up their window
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::SetAllHeadersReceived %p state OPEN from reserved\n&quot;, this));</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     mState = OPEN;</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     AdjustInitialWindow();</span>
<span class="lineNum">    1153 </span>            :   }
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   mAllHeadersReceived = 1;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   if (mIsTunnel) {</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     MapStreamToHttpConnection();</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     ClearTransactionsBlockedOnTunnel();</span>
<span class="lineNum">    1159 </span>            :   }
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">    1161 </span>            : }
<a name="1162"><span class="lineNum">    1162 </span>            : </a>
<span class="lineNum">    1163 </span>            : bool
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 : Http2Stream::AllowFlowControlledWrite()</span>
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   return (mSession-&gt;ServerSessionWindow() &gt; 0) &amp;&amp; (mServerReceiveWindow &gt; 0);</span>
<span class="lineNum">    1167 </span>            : }
<a name="1168"><span class="lineNum">    1168 </span>            : </a>
<span class="lineNum">    1169 </span>            : void
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 : Http2Stream::UpdateServerReceiveWindow(int32_t delta)</span>
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   mServerReceiveWindow += delta;</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   if (mBlockedOnRwin &amp;&amp; AllowFlowControlledWrite()) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::UpdateServerReceived UnPause %p 0x%X &quot;</span>
<span class="lineNum">    1176 </span>            :           &quot;Open stream window\n&quot;, this, mStreamID));
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     mSession-&gt;TransactionHasDataToWrite(this);  }</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 : }</span>
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<span class="lineNum">    1180 </span>            : void
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : Http2Stream::SetPriority(uint32_t newPriority)</span>
<span class="lineNum">    1182 </span>            : {
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   int32_t httpPriority = static_cast&lt;int32_t&gt;(newPriority);</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   if (httpPriority &gt; kWorstPriority) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     httpPriority = kWorstPriority;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   } else if (httpPriority &lt; kBestPriority) {</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     httpPriority = kBestPriority;</span>
<span class="lineNum">    1188 </span>            :   }
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   mPriority = static_cast&lt;uint32_t&gt;(httpPriority);</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :   mPriorityWeight = (nsISupportsPriority::PRIORITY_LOWEST + 1) -</span>
<span class="lineNum">    1191 </span>            :     (httpPriority - kNormalPriority);
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :   mPriorityDependency = 0; // maybe adjusted later</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 : }</span>
<a name="1195"><span class="lineNum">    1195 </span>            : </a>
<span class="lineNum">    1196 </span>            : void
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 : Http2Stream::SetPriorityDependency(uint32_t newDependency, uint8_t newWeight,</span>
<span class="lineNum">    1198 </span>            :                                    bool exclusive)
<span class="lineNum">    1199 </span>            : {
<span class="lineNum">    1200 </span>            :   // undefined what it means when the server sends a priority frame. ignore it.
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::SetPriorityDependency %p 0x%X received dependency=0x%X &quot;</span>
<span class="lineNum">    1202 </span>            :         &quot;weight=%u exclusive=%d&quot;, this, mStreamID, newDependency, newWeight,
<span class="lineNum">    1203 </span>            :         exclusive));
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 : }</span>
<a name="1205"><span class="lineNum">    1205 </span>            : </a>
<span class="lineNum">    1206 </span>            : void
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 : Http2Stream::UpdatePriorityDependency()</span>
<span class="lineNum">    1208 </span>            : {
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   if (!mSession-&gt;UseH2Deps()) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1211 </span>            :   }
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   nsHttpTransaction *trans = mTransaction-&gt;QueryHttpTransaction();</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   if (!trans) {</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1216 </span>            :   }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   // we create 6 fake dependency streams per session,
<span class="lineNum">    1219 </span>            :   // these streams are never opened with HEADERS. our first opened stream is 0xd
<span class="lineNum">    1220 </span>            :   // 3 depends 0, weight 200, leader class (kLeaderGroupID)
<span class="lineNum">    1221 </span>            :   // 5 depends 0, weight 100, other (kOtherGroupID)
<span class="lineNum">    1222 </span>            :   // 7 depends 0, weight 0, background (kBackgroundGroupID)
<span class="lineNum">    1223 </span>            :   // 9 depends 7, weight 0, speculative (kSpeculativeGroupID)
<span class="lineNum">    1224 </span>            :   // b depends 3, weight 0, follower class (kFollowerGroupID)
<span class="lineNum">    1225 </span>            :   // d depends 0, weight 240, urgent-start class (kUrgentStartGroupID)
<span class="lineNum">    1226 </span>            :   //
<span class="lineNum">    1227 </span>            :   // streams for leaders (html, js, css) depend on 3
<span class="lineNum">    1228 </span>            :   // streams for folowers (images) depend on b
<span class="lineNum">    1229 </span>            :   // default streams (xhr, async js) depend on 5
<span class="lineNum">    1230 </span>            :   // explicit bg streams (beacon, etc..) depend on 7
<span class="lineNum">    1231 </span>            :   // spculative bg streams depend on 9
<span class="lineNum">    1232 </span>            :   // urgent-start streams depend on d
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :   uint32_t classFlags = trans-&gt;ClassOfService();</span>
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   if (classFlags &amp; nsIClassOfService::Leader) {</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kLeaderGroupID;</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   } else if (classFlags &amp; nsIClassOfService::Follower) {</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kFollowerGroupID;</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :   } else if (classFlags &amp; nsIClassOfService::Speculative) {</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kSpeculativeGroupID;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   } else if (classFlags &amp; nsIClassOfService::Background) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kBackgroundGroupID;</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   } else if (classFlags &amp; nsIClassOfService::Unblocked) {</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kOtherGroupID;</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :   } else if (classFlags &amp; nsIClassOfService::UrgentStart) {</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kUrgentStartGroupID;</span>
<span class="lineNum">    1248 </span>            :   } else {
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     mPriorityDependency = Http2Session::kFollowerGroupID; // unmarked followers</span>
<span class="lineNum">    1250 </span>            :   }
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::UpdatePriorityDependency %p &quot;</span>
<span class="lineNum">    1253 </span>            :         &quot;classFlags %X depends on stream 0x%X\n&quot;,
<span class="lineNum">    1254 </span>            :         this, classFlags, mPriorityDependency));
<span class="lineNum">    1255 </span>            : }
<a name="1256"><span class="lineNum">    1256 </span>            : </a>
<span class="lineNum">    1257 </span>            : void
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 : Http2Stream::SetRecvdFin(bool aStatus)</span>
<span class="lineNum">    1259 </span>            : {
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :   mRecvdFin = aStatus ? 1 : 0;</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   if (!aStatus)</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :   if (mState == OPEN || mState == RESERVED_BY_REMOTE) {</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     mState = CLOSED_BY_REMOTE;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   } else if (mState == CLOSED_BY_LOCAL) {</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     mState = CLOSED;</span>
<span class="lineNum">    1268 </span>            :   }
<span class="lineNum">    1269 </span>            : }
<a name="1270"><span class="lineNum">    1270 </span>            : </a>
<span class="lineNum">    1271 </span>            : void
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 : Http2Stream::SetSentFin(bool aStatus)</span>
<span class="lineNum">    1273 </span>            : {
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   mSentFin = aStatus ? 1 : 0;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :   if (!aStatus)</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   if (mState == OPEN || mState == RESERVED_BY_REMOTE) {</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     mState = CLOSED_BY_LOCAL;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :   } else if (mState == CLOSED_BY_REMOTE) {</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     mState = CLOSED;</span>
<span class="lineNum">    1282 </span>            :   }
<span class="lineNum">    1283 </span>            : }
<a name="1284"><span class="lineNum">    1284 </span>            : </a>
<span class="lineNum">    1285 </span>            : void
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 : Http2Stream::SetRecvdReset(bool aStatus)</span>
<span class="lineNum">    1287 </span>            : {
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   mRecvdReset = aStatus ? 1 : 0;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :   if (!aStatus)</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   mState = CLOSED;</span>
<span class="lineNum">    1292 </span>            : }
<a name="1293"><span class="lineNum">    1293 </span>            : </a>
<span class="lineNum">    1294 </span>            : void
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 : Http2Stream::SetSentReset(bool aStatus)</span>
<span class="lineNum">    1296 </span>            : {
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   mSentReset = aStatus ? 1 : 0;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   if (!aStatus)</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   mState = CLOSED;</span>
<span class="lineNum">    1301 </span>            : }
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">    1304 </span>            : // nsAHttpSegmentReader
<span class="lineNum">    1305 </span>            : //-----------------------------------------------------------------------------
<a name="1306"><span class="lineNum">    1306 </span>            : </a>
<span class="lineNum">    1307 </span>            : nsresult
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 : Http2Stream::OnReadSegment(const char *buf,</span>
<span class="lineNum">    1309 </span>            :                            uint32_t count,
<span class="lineNum">    1310 </span>            :                            uint32_t *countRead)
<span class="lineNum">    1311 </span>            : {
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::OnReadSegment %p count=%d state=%x&quot;,</span>
<span class="lineNum">    1313 </span>            :         this, count, mUpstreamState));
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mSegmentReader, &quot;OnReadSegment with null mSegmentReader&quot;);</span>
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   nsresult rv = NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">    1319 </span>            :   uint32_t dataLength;
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   switch (mUpstreamState) {</span>
<span class="lineNum">    1322 </span>            :   case GENERATING_HEADERS:
<span class="lineNum">    1323 </span>            :     // The buffer is the HTTP request stream, including at least part of the
<span class="lineNum">    1324 </span>            :     // HTTP request header. This state's job is to build a HEADERS frame
<span class="lineNum">    1325 </span>            :     // from the header information. count is the number of http bytes available
<span class="lineNum">    1326 </span>            :     // (which may include more than the header), and in countRead we return
<span class="lineNum">    1327 </span>            :     // the number of those bytes that we consume (i.e. the portion that are
<span class="lineNum">    1328 </span>            :     // header bytes)
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     if (!mRequestHeadersDone) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv = ParseHttpRequestHeaders(buf, count, countRead))) {</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         return rv;</span>
<span class="lineNum">    1333 </span>            :       }
<span class="lineNum">    1334 </span>            :     }
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     if (mRequestHeadersDone &amp;&amp; !mOpenGenerated) {</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :       if (!mSession-&gt;TryToActivate(this)) {</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :         LOG3((&quot;Http2Stream::OnReadSegment %p cannot activate now. queued.\n&quot;, this));</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :         return *countRead ? NS_OK : NS_BASE_STREAM_WOULD_BLOCK;</span>
<span class="lineNum">    1340 </span>            :       }
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv = GenerateOpen())) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         return rv;</span>
<span class="lineNum">    1343 </span>            :       }
<span class="lineNum">    1344 </span>            :    }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :     LOG3((&quot;ParseHttpRequestHeaders %p used %d of %d. &quot;</span>
<span class="lineNum">    1347 </span>            :           &quot;requestheadersdone = %d mOpenGenerated = %d\n&quot;,
<span class="lineNum">    1348 </span>            :           this, *countRead, count, mRequestHeadersDone, mOpenGenerated));
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     if (mOpenGenerated) {</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :       SetHTTPState(OPEN);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       AdjustInitialWindow();</span>
<span class="lineNum">    1352 </span>            :       // This version of TransmitFrame cannot block
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :       rv = TransmitFrame(nullptr, nullptr, true);</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :       ChangeState(GENERATING_BODY);</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1356 </span>            :     }
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(*countRead == count, &quot;Header parsing not complete but unused data&quot;);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span>            :   case GENERATING_BODY:
<span class="lineNum">    1361 </span>            :     // if there is session flow control and either the stream window is active and
<span class="lineNum">    1362 </span>            :     // exhaused or the session window is exhausted then suspend
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :     if (!AllowFlowControlledWrite()) {</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :       *countRead = 0;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :       LOG3((&quot;Http2Stream this=%p, id 0x%X request body suspended because &quot;</span>
<span class="lineNum">    1366 </span>            :             &quot;remote window is stream=%&quot; PRId64 &quot; session=%&quot; PRId64 &quot;.\n&quot;, this, mStreamID,
<span class="lineNum">    1367 </span>            :             mServerReceiveWindow, mSession-&gt;ServerSessionWindow()));
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :       mBlockedOnRwin = true;</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :       return NS_BASE_STREAM_WOULD_BLOCK;</span>
<span class="lineNum">    1370 </span>            :     }
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     mBlockedOnRwin = false;</span>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :     // The chunk is the smallest of: availableData, configured chunkSize,
<span class="lineNum">    1374 </span>            :     // stream window, session window, or 14 bit framing limit.
<span class="lineNum">    1375 </span>            :     // Its amazing we send anything at all.
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :     dataLength = std::min(count, mChunkSize);</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :     if (dataLength &gt; Http2Session::kMaxFrameData)</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :       dataLength = Http2Session::kMaxFrameData;</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :     if (dataLength &gt; mSession-&gt;ServerSessionWindow())</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       dataLength = static_cast&lt;uint32_t&gt;(mSession-&gt;ServerSessionWindow());</span>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :     if (dataLength &gt; mServerReceiveWindow)</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :       dataLength = static_cast&lt;uint32_t&gt;(mServerReceiveWindow);</span>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream this=%p id 0x%X send calculation &quot;</span>
<span class="lineNum">    1388 </span>            :           &quot;avail=%d chunksize=%d stream window=%&quot; PRId64 &quot; session window=%&quot; PRId64 &quot; &quot;
<span class="lineNum">    1389 </span>            :           &quot;max frame=%d USING=%u\n&quot;, this, mStreamID,
<span class="lineNum">    1390 </span>            :           count, mChunkSize, mServerReceiveWindow, mSession-&gt;ServerSessionWindow(),
<span class="lineNum">    1391 </span>            :           Http2Session::kMaxFrameData, dataLength));
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     mSession-&gt;DecrementServerSessionWindow(dataLength);</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     mServerReceiveWindow -= dataLength;</span>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream %p id 0x%x request len remaining %&quot; PRId64 &quot;, &quot;</span>
<span class="lineNum">    1397 </span>            :           &quot;count avail %u, chunk used %u&quot;,
<span class="lineNum">    1398 </span>            :           this, mStreamID, mRequestBodyLenRemaining, count, dataLength));
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :     if (!dataLength &amp;&amp; mRequestBodyLenRemaining) {</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :       return NS_BASE_STREAM_WOULD_BLOCK;</span>
<span class="lineNum">    1401 </span>            :     }
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :     if (dataLength &gt; mRequestBodyLenRemaining) {</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :       return NS_ERROR_UNEXPECTED;</span>
<span class="lineNum">    1404 </span>            :     }
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     mRequestBodyLenRemaining -= dataLength;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     GenerateDataFrameHeader(dataLength, !mRequestBodyLenRemaining);</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :     ChangeState(SENDING_BODY);</span>
<span class="lineNum">    1408 </span>            :     MOZ_FALLTHROUGH;
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :   case SENDING_BODY:
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mTxInlineFrameUsed, &quot;OnReadSegment Send Data Header 0b&quot;);</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     rv = TransmitFrame(buf, countRead, false);</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(NS_FAILED(rv) || !mTxInlineFrameUsed,</span>
<span class="lineNum">    1414 </span>            :                &quot;Transmit Frame should be all or nothing&quot;);
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     LOG3((&quot;TransmitFrame() rv=%&quot; PRIx32 &quot; returning %d data bytes. &quot;</span>
<span class="lineNum">    1417 </span>            :           &quot;Header is %d Body is %d.&quot;,
<span class="lineNum">    1418 </span>            :           static_cast&lt;uint32_t&gt;(rv), *countRead, mTxInlineFrameUsed, mTxStreamFrameSize));
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :     // normalize a partial write with a WOULD_BLOCK into just a partial write
<span class="lineNum">    1421 </span>            :     // as some code will take WOULD_BLOCK to mean an error with nothing
<span class="lineNum">    1422 </span>            :     // written (e.g. nsHttpTransaction::ReadRequestSegment()
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :     if (rv == NS_BASE_STREAM_WOULD_BLOCK &amp;&amp; *countRead)</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :       rv = NS_OK;</span>
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :     // If that frame was all sent, look for another one
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :     if (!mTxInlineFrameUsed)</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :       ChangeState(GENERATING_BODY);</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :   case SENDING_FIN_STREAM:
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;resuming partial fin stream out of OnReadSegment&quot;);</span>
<span class="lineNum">    1433 </span>            :     break;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :   case UPSTREAM_COMPLETE:
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mPushSource);</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     rv = TransmitFrame(nullptr, nullptr, true);</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            :   default:
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false, &quot;Http2Stream::OnReadSegment non-write state&quot;);</span>
<span class="lineNum">    1442 </span>            :     break;
<span class="lineNum">    1443 </span>            :   }
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">    1446 </span>            : }
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : //-----------------------------------------------------------------------------
<span class="lineNum">    1449 </span>            : // nsAHttpSegmentWriter
<span class="lineNum">    1450 </span>            : //-----------------------------------------------------------------------------
<a name="1451"><span class="lineNum">    1451 </span>            : </a>
<span class="lineNum">    1452 </span>            : nsresult
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 : Http2Stream::OnWriteSegment(char *buf,</span>
<span class="lineNum">    1454 </span>            :                             uint32_t count,
<span class="lineNum">    1455 </span>            :                             uint32_t *countWritten)
<span class="lineNum">    1456 </span>            : {
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   LOG3((&quot;Http2Stream::OnWriteSegment %p count=%d state=%x 0x%X\n&quot;,</span>
<span class="lineNum">    1458 </span>            :         this, count, mUpstreamState, mStreamID));
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mSegmentWriter);</span>
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   if (mPushSource) {</span>
<span class="lineNum">    1464 </span>            :     nsresult rv;
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     rv = mPushSource-&gt;GetBufferedData(buf, count, countWritten);</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv))</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :       return rv;</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     mSession-&gt;ConnectPushedStream(this);</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1471 </span>            :   }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            :   // sometimes we have read data from the network and stored it in a pipe
<span class="lineNum">    1474 </span>            :   // so that other streams can proceed when the gecko caller is not processing
<span class="lineNum">    1475 </span>            :   // data events fast enough and flow control hasn't caught up yet. This
<span class="lineNum">    1476 </span>            :   // gets the stored data out of that pipe
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :   if (!mBypassInputBuffer &amp;&amp; mSimpleBuffer.Available()) {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     *countWritten = mSimpleBuffer.Read(buf, count);</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(*countWritten);</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::OnWriteSegment read from flow control buffer %p %x %d\n&quot;,</span>
<span class="lineNum">    1481 </span>            :           this, mStreamID, *countWritten));
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1483 </span>            :   }
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :   // read from the network
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   return mSegmentWriter-&gt;OnWriteSegment(buf, count, countWritten);</span>
<span class="lineNum">    1487 </span>            : }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            : /// connect tunnels
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<span class="lineNum">    1491 </span>            : void
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 : Http2Stream::ClearTransactionsBlockedOnTunnel()</span>
<span class="lineNum">    1493 </span>            : {
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(OnSocketThread(), &quot;not on socket thread&quot;);</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :   if (!mIsTunnel) {</span>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1498 </span>            :   }
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :   nsresult rv = gHttpHandler-&gt;ConnMgr()-&gt;ProcessPendingQ(mTransaction-&gt;ConnectionInfo());</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :     LOG3((&quot;Http2Stream::ClearTransactionsBlockedOnTunnel %p\n&quot;</span>
<span class="lineNum">    1502 </span>            :           &quot;  ProcessPendingQ failed: %08x\n&quot;,
<span class="lineNum">    1503 </span>            :           this, static_cast&lt;uint32_t&gt;(rv)));
<span class="lineNum">    1504 </span>            :   }
<span class="lineNum">    1505 </span>            : }
<a name="1506"><span class="lineNum">    1506 </span>            : </a>
<span class="lineNum">    1507 </span>            : void
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 : Http2Stream::MapStreamToPlainText()</span>
<span class="lineNum">    1509 </span>            : {
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :   RefPtr&lt;SpdyConnectTransaction&gt; qiTrans(mTransaction-&gt;QuerySpdyConnectTransaction());</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(qiTrans);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   mPlainTextTunnel = true;</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   qiTrans-&gt;ForcePlainText();</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 : }</span>
<a name="1515"><span class="lineNum">    1515 </span>            : </a>
<span class="lineNum">    1516 </span>            : void
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 : Http2Stream::MapStreamToHttpConnection()</span>
<span class="lineNum">    1518 </span>            : {
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   RefPtr&lt;SpdyConnectTransaction&gt; qiTrans(mTransaction-&gt;QuerySpdyConnectTransaction());</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(qiTrans);</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :   qiTrans-&gt;MapStreamToHttpConnection(mSocketTransport,</span>
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :                                      mTransaction-&gt;ConnectionInfo());</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">    1526 </span>            : // mirror nsAHttpTransaction
<span class="lineNum">    1527 </span>            : // -----------------------------------------------------------------------------
<a name="1528"><span class="lineNum">    1528 </span>            : </a>
<span class="lineNum">    1529 </span>            : bool
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 : Http2Stream::Do0RTT()</span>
<span class="lineNum">    1531 </span>            : {
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mTransaction);</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   mAttempting0RTT = mTransaction-&gt;Do0RTT();</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :   return mAttempting0RTT;</span>
<span class="lineNum">    1535 </span>            : }
<a name="1536"><span class="lineNum">    1536 </span>            : </a>
<span class="lineNum">    1537 </span>            : nsresult
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 : Http2Stream::Finish0RTT(bool aRestart, bool aAlpnChanged)</span>
<span class="lineNum">    1539 </span>            : {
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mTransaction);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :   mAttempting0RTT = false;</span>
<span class="lineNum">    1542 </span>            :   // Instead of passing (aRestart, aAlpnChanged) here, we use aAlpnChanged for
<span class="lineNum">    1543 </span>            :   // both arguments because as long as the alpn token stayed the same, we can
<span class="lineNum">    1544 </span>            :   // just reuse what we have in our buffer to send instead of having to have
<span class="lineNum">    1545 </span>            :   // the transaction rewind and read it all over again. We only need to rewind
<span class="lineNum">    1546 </span>            :   // the transaction if we're switching to a new protocol, because our buffer
<span class="lineNum">    1547 </span>            :   // won't get used in that case.
<span class="lineNum">    1548 </span>            :   // ..
<span class="lineNum">    1549 </span>            :   // however, we send in the aRestart value to indicate that early data failed
<span class="lineNum">    1550 </span>            :   // for devtools purposes
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   nsresult rv = mTransaction-&gt;Finish0RTT(aAlpnChanged, aAlpnChanged);</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   if (aRestart) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :     nsHttpTransaction *trans = mTransaction-&gt;QueryHttpTransaction();</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     if (trans) {</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :       trans-&gt;Refused0RTT();</span>
<span class="lineNum">    1556 </span>            :     }
<span class="lineNum">    1557 </span>            :   }
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">    1559 </span>            : }
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : } // namespace net
<span class="lineNum">    1562 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - netwerk/cache2/CacheStorageService.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">netwerk/cache2</a> - CacheStorageService.cpp<span style="font-size: 80%;"> (source / <a href="CacheStorageService.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">248</td>
            <td class="headerCovTableEntry">1025</td>
            <td class="headerCovTableEntryLo">24.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">42</td>
            <td class="headerCovTableEntry">123</td>
            <td class="headerCovTableEntryLo">34.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;CacheLog.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;CacheStorageService.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;CacheFileIOManager.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;CacheObserver.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;CacheIndex.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;CacheIndexIterator.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;CacheStorage.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;AppCacheStorage.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;CacheEntry.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;CacheFileUtils.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;OldWrappers.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsCacheService.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsDeleteDir.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;nsICacheStorageVisitor.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIObserverService.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIFile.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIURI.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsAutoPtr.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsNetCID.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsNetUtil.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsServiceManagerUtils.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsWeakReference.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/TimeStamp.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/Services.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;mozilla/IntegerPrintfMacros.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mozilla/SizePrintfMacros.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : namespace mozilla {
<span class="lineNum">      39 </span>            : namespace net {
<span class="lineNum">      40 </span>            : 
<a name="41"><span class="lineNum">      41 </span>            : namespace {</a>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineCov">          5 : void AppendMemoryStorageID(nsAutoCString &amp;key)</span>
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span><span class="lineCov">          5 :   key.Append('/');</span>
<span class="lineNum">      46 </span><span class="lineCov">          5 :   key.Append('M');</span>
<span class="lineNum">      47 </span><span class="lineCov">          5 : }</span>
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : } // namespace
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : // Not defining as static or class member of CacheStorageService since
<span class="lineNum">      52 </span>            : // it would otherwise need to include CacheEntry.h and that then would
<span class="lineNum">      53 </span>            : // need to be exported to make nsNetModule.cpp compilable.
<span class="lineNum">      54 </span>            : typedef nsClassHashtable&lt;nsCStringHashKey, CacheEntryTable&gt;
<span class="lineNum">      55 </span>            :         GlobalEntryTables;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /**
<span class="lineNum">      58 </span>            :  * Keeps tables of entries.  There is one entries table for each distinct load
<span class="lineNum">      59 </span>            :  * context type.  The distinction is based on following load context info states:
<span class="lineNum">      60 </span>            :  * &lt;isPrivate|isAnon|appId|inIsolatedMozBrowser&gt; which builds a mapping key.
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * Thread-safe to access, protected by the service mutex.
<span class="lineNum">      63 </span>            :  */
<a name="64"><span class="lineNum">      64 </span>            : static GlobalEntryTables* sGlobalEntryTables;</a>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineCov">          9 : CacheMemoryConsumer::CacheMemoryConsumer(uint32_t aFlags)</span>
<span class="lineNum">      67 </span>            : : mReportedMemoryConsumption(0)
<span class="lineNum">      68 </span><span class="lineCov">          9 : , mFlags(aFlags)</span>
<span class="lineNum">      69 </span>            : {
<span class="lineNum">      70 </span><span class="lineCov">          9 : }</span>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<span class="lineNum">      72 </span>            : void
<span class="lineNum">      73 </span><span class="lineCov">         38 : CacheMemoryConsumer::DoMemoryReport(uint32_t aCurrentSize)</span>
<span class="lineNum">      74 </span>            : {
<span class="lineNum">      75 </span><span class="lineCov">         38 :   if (!(mFlags &amp; DONT_REPORT) &amp;&amp; CacheStorageService::Self()) {</span>
<span class="lineNum">      76 </span><span class="lineCov">         26 :     CacheStorageService::Self()-&gt;OnMemoryConsumptionChange(this, aCurrentSize);</span>
<span class="lineNum">      77 </span>            :   }
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">         38 : }</span></a>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span><span class="lineCov">          2 : CacheStorageService::MemoryPool::MemoryPool(EType aType)</span>
<span class="lineNum">      81 </span>            : : mType(aType)
<span class="lineNum">      82 </span><span class="lineCov">          2 : , mMemorySize(0)</span>
<span class="lineNum">      83 </span>            : {
<a name="84"><span class="lineNum">      84 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : CacheStorageService::MemoryPool::~MemoryPool()</span>
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   if (mMemorySize != 0) {</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Network cache reported memory consumption is not at 0, probably leaking?&quot;);</span>
<span class="lineNum">      90 </span>            :   }
<span class="lineNum">      91 </span><span class="lineNoCov">          0 : }</span>
<a name="92"><span class="lineNum">      92 </span>            : </a>
<span class="lineNum">      93 </span>            : uint32_t
<span class="lineNum">      94 </span><span class="lineCov">         15 : CacheStorageService::MemoryPool::Limit() const</span>
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span><span class="lineCov">         15 :   switch (mType) {</span>
<span class="lineNum">      97 </span>            :   case DISK:
<span class="lineNum">      98 </span><span class="lineCov">         15 :     return CacheObserver::MetadataMemoryLimit();</span>
<span class="lineNum">      99 </span>            :   case MEMORY:
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     return CacheObserver::MemoryCacheCapacity();</span>
<span class="lineNum">     101 </span>            :   }
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   MOZ_CRASH(&quot;Bad pool type&quot;);</span>
<span class="lineNum">     104 </span>            :   return 0;
<a name="105"><span class="lineNum">     105 </span>            : }</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineCov">        225 : NS_IMPL_ISUPPORTS(CacheStorageService,</span>
<span class="lineNum">     108 </span>            :                   nsICacheStorageService,
<span class="lineNum">     109 </span>            :                   nsIMemoryReporter,
<span class="lineNum">     110 </span>            :                   nsITimerCallback,
<span class="lineNum">     111 </span>            :                   nsICacheTesting)
<span class="lineNum">     112 </span>            : 
<a name="113"><span class="lineNum">     113 </span>            : CacheStorageService* CacheStorageService::sSelf = nullptr;</a>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineCov">          1 : CacheStorageService::CacheStorageService()</span>
<span class="lineNum">     116 </span>            : : mLock(&quot;CacheStorageService.mLock&quot;)
<span class="lineNum">     117 </span>            : , mForcedValidEntriesLock(&quot;CacheStorageService.mForcedValidEntriesLock&quot;)
<span class="lineNum">     118 </span>            : , mShutdown(false)
<span class="lineNum">     119 </span>            : , mDiskPool(MemoryPool::DISK)
<span class="lineNum">     120 </span><span class="lineCov">          1 : , mMemoryPool(MemoryPool::MEMORY)</span>
<span class="lineNum">     121 </span>            : {
<span class="lineNum">     122 </span><span class="lineCov">          1 :   CacheFileIOManager::Init();</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">          1 :   MOZ_ASSERT(!sSelf);</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineCov">          1 :   sSelf = this;</span>
<span class="lineNum">     127 </span><span class="lineCov">          1 :   sGlobalEntryTables = new GlobalEntryTables();</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineCov">          1 :   RegisterStrongMemoryReporter(this);</span>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineNoCov">          0 : CacheStorageService::~CacheStorageService()</span>
<span class="lineNum">     133 </span>            : {
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::~CacheStorageService&quot;));</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   sSelf = nullptr;</span>
<a name="136"><span class="lineNum">     136 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : void CacheStorageService::Shutdown()</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   if (mShutdown)</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::Shutdown - start&quot;));</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   mShutdown = true;</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   nsCOMPtr&lt;nsIRunnable&gt; event =
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     NewRunnableMethod(&quot;net::CacheStorageService::ShutdownBackground&quot;,</span>
<span class="lineNum">     151 </span>            :                       this,
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :                       &amp;CacheStorageService::ShutdownBackground);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   Dispatch(event);</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : #ifdef NS_FREE_PERMANENT_DATA
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   sGlobalEntryTables-&gt;Clear();</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   delete sGlobalEntryTables;</span>
<span class="lineNum">     158 </span>            : #endif
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   sGlobalEntryTables = nullptr;</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::Shutdown - done&quot;));</span>
<a name="162"><span class="lineNum">     162 </span>            : }</a>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineNoCov">          0 : void CacheStorageService::ShutdownBackground()</span>
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::ShutdownBackground - start&quot;));</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   {
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :     // Cancel purge timer to avoid leaking.
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     if (mPurgeTimer) {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       LOG((&quot;  freeing the timer&quot;));</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       mPurgeTimer-&gt;Cancel();</span>
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span>            :   }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : #ifdef NS_FREE_PERMANENT_DATA
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   Pool(false).mFrecencyArray.Clear();</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   Pool(false).mExpirationArray.Clear();</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   Pool(true).mFrecencyArray.Clear();</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   Pool(true).mExpirationArray.Clear();</span>
<span class="lineNum">     185 </span>            : #endif
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::ShutdownBackground - done&quot;));</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : // Internal management methods
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : namespace {
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : // WalkCacheRunnable
<span class="lineNum">     195 </span>            : // Base class for particular storage entries visiting
<span class="lineNum">     196 </span>            : class WalkCacheRunnable : public Runnable
<span class="lineNum">     197 </span>            :                         , public CacheStorageService::EntryInfoCallback
<a name="198"><span class="lineNum">     198 </span>            : {</a>
<span class="lineNum">     199 </span>            : protected:
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   WalkCacheRunnable(nsICacheStorageVisitor* aVisitor, bool aVisitEntries)</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     : Runnable(&quot;net::WalkCacheRunnable&quot;)</span>
<span class="lineNum">     202 </span>            :     , mService(CacheStorageService::Self())
<span class="lineNum">     203 </span>            :     , mCallback(aVisitor)
<span class="lineNum">     204 </span>            :     , mSize(0)
<span class="lineNum">     205 </span>            :     , mNotifyStorage(true)
<span class="lineNum">     206 </span>            :     , mVisitEntries(aVisitEntries)
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     , mCancel(false)</span>
<span class="lineNum">     208 </span>            :   {
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(NS_IsMainThread());</span>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   virtual ~WalkCacheRunnable()</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     if (mCallback) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :       ProxyReleaseMainThread(</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         &quot;WalkCacheRunnable::mCallback&quot;, mCallback);</span>
<span class="lineNum">     217 </span>            :     }
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :   RefPtr&lt;CacheStorageService&gt; mService;
<span class="lineNum">     221 </span>            :   nsCOMPtr&lt;nsICacheStorageVisitor&gt; mCallback;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   uint64_t mSize;
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   bool mNotifyStorage : 1;
<span class="lineNum">     226 </span>            :   bool mVisitEntries : 1;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   Atomic&lt;bool&gt; mCancel;
<span class="lineNum">     229 </span>            : };
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : // WalkMemoryCacheRunnable
<span class="lineNum">     232 </span>            : // Responsible to visit memory storage and walk
<span class="lineNum">     233 </span>            : // all entries on it asynchronously.
<span class="lineNum">     234 </span>            : class WalkMemoryCacheRunnable : public WalkCacheRunnable
<a name="235"><span class="lineNum">     235 </span>            : {</a>
<span class="lineNum">     236 </span>            : public:
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   WalkMemoryCacheRunnable(nsILoadContextInfo *aLoadInfo,</span>
<span class="lineNum">     238 </span>            :                           bool aVisitEntries,
<span class="lineNum">     239 </span>            :                           nsICacheStorageVisitor* aVisitor)
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     : WalkCacheRunnable(aVisitor, aVisitEntries)</span>
<span class="lineNum">     241 </span>            :   {
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     CacheFileUtils::AppendKeyPrefix(aLoadInfo, mContextKey);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(NS_IsMainThread());</span>
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   nsresult Walk()</span>
<span class="lineNum">     247 </span>            :   {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     return mService-&gt;Dispatch(this);</span>
<span class="lineNum">     249 </span>            :   }
<a name="250"><span class="lineNum">     250 </span>            : </a>
<span class="lineNum">     251 </span>            : private:
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   NS_IMETHOD Run() override</span>
<span class="lineNum">     253 </span>            :   {
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     if (CacheStorageService::IsOnManagementThread()) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       LOG((&quot;WalkMemoryCacheRunnable::Run - collecting [this=%p]&quot;, this));</span>
<span class="lineNum">     256 </span>            :       // First, walk, count and grab all entries from the storage
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       mozilla::MutexAutoLock lock(CacheStorageService::Self()-&gt;Lock());</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       if (!CacheStorageService::IsRunning())</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         return NS_ERROR_NOT_INITIALIZED;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :       CacheEntryTable* entries;
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       if (sGlobalEntryTables-&gt;Get(mContextKey, &amp;entries)) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         for (auto iter = entries-&gt;Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :           CacheEntry* entry = iter.UserData();</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :           // Ignore disk entries
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :           if (entry-&gt;IsUsingDisk()) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     271 </span>            :           }
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :           mSize += entry-&gt;GetMetadataMemoryConsumption();</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :           int64_t size;
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :           if (NS_SUCCEEDED(entry-&gt;GetDataSize(&amp;size))) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :             mSize += size;</span>
<span class="lineNum">     278 </span>            :           }
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :           mEntryArray.AppendElement(entry);</span>
<span class="lineNum">     280 </span>            :         }
<span class="lineNum">     281 </span>            :       }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :       // Next, we dispatch to the main thread
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     } else if (NS_IsMainThread()) {</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :       LOG((&quot;WalkMemoryCacheRunnable::Run - notifying [this=%p]&quot;, this));</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       if (mNotifyStorage) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         LOG((&quot;  storage&quot;));</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :         // Second, notify overall storage info
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         mCallback-&gt;OnCacheStorageInfo(mEntryArray.Length(), mSize,</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                                       CacheObserver::MemoryCacheCapacity(), nullptr);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         if (!mVisitEntries)</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :           return NS_OK; // done</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         mNotifyStorage = false;</span>
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :       } else {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         LOG((&quot;  entry [left=%&quot; PRIuSIZE &quot;, canceled=%d]&quot;, mEntryArray.Length(), (bool)mCancel));</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :         // Third, notify each entry until depleted or canceled
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         if (!mEntryArray.Length() || mCancel) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :           mCallback-&gt;OnCacheEntryVisitCompleted();</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :           return NS_OK; // done</span>
<span class="lineNum">     305 </span>            :         }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :         // Grab the next entry
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         RefPtr&lt;CacheEntry&gt; entry = mEntryArray[0];</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         mEntryArray.RemoveElementAt(0);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :         // Invokes this-&gt;OnEntryInfo, that calls the callback with all
<span class="lineNum">     312 </span>            :         // information of the entry.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         CacheStorageService::GetCacheEntryInfo(entry, this);</span>
<span class="lineNum">     314 </span>            :       }
<span class="lineNum">     315 </span>            :     } else {
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;Bad thread&quot;);</span>
<span class="lineNum">     317 </span>            :       return NS_ERROR_FAILURE;
<span class="lineNum">     318 </span>            :     }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     NS_DispatchToMainThread(this);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<a name="322"><span class="lineNum">     322 </span>            :   }</a>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   virtual ~WalkMemoryCacheRunnable()</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     if (mCallback)</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       ProxyReleaseMainThread(</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         &quot;WalkMemoryCacheRunnable::mCallback&quot;, mCallback);</span>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   virtual void OnEntryInfo(const nsACString &amp; aURISpec, const nsACString &amp; aIdEnhance,</span>
<span class="lineNum">     332 </span>            :                            int64_t aDataSize, int32_t aFetchCount,
<span class="lineNum">     333 </span>            :                            uint32_t aLastModifiedTime, uint32_t aExpirationTime,
<span class="lineNum">     334 </span>            :                            bool aPinned, nsILoadContextInfo* aInfo) override
<span class="lineNum">     335 </span>            :   {
<span class="lineNum">     336 </span>            :     nsresult rv;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     rv = NS_NewURI(getter_AddRefs(uri), aURISpec);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     342 </span>            :     }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     rv = mCallback-&gt;OnCacheEntryInfo(uri, aIdEnhance, aDataSize, aFetchCount,</span>
<span class="lineNum">     345 </span>            :                                      aLastModifiedTime, aExpirationTime,
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                                      aPinned, aInfo);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       LOG((&quot;  callback failed, canceling the walk&quot;));</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       mCancel = true;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span>            :   }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : private:
<span class="lineNum">     354 </span>            :   nsCString mContextKey;
<span class="lineNum">     355 </span>            :   nsTArray&lt;RefPtr&lt;CacheEntry&gt; &gt; mEntryArray;
<span class="lineNum">     356 </span>            : };
<span class="lineNum">     357 </span>            : 
<a name="358"><span class="lineNum">     358 </span>            : // WalkDiskCacheRunnable</a>
<span class="lineNum">     359 </span>            : // Using the cache index information to get the list of files per context.
<span class="lineNum">     360 </span><span class="lineNoCov">          0 : class WalkDiskCacheRunnable : public WalkCacheRunnable</span>
<a name="361"><span class="lineNum">     361 </span>            : {</a>
<span class="lineNum">     362 </span>            : public:
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   WalkDiskCacheRunnable(nsILoadContextInfo *aLoadInfo,</span>
<span class="lineNum">     364 </span>            :                         bool aVisitEntries,
<span class="lineNum">     365 </span>            :                         nsICacheStorageVisitor* aVisitor)
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     : WalkCacheRunnable(aVisitor, aVisitEntries)</span>
<span class="lineNum">     367 </span>            :     , mLoadInfo(aLoadInfo)
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     , mPass(COLLECT_STATS)</span>
<span class="lineNum">     369 </span>            :   {
<a name="370"><span class="lineNum">     370 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   nsresult Walk()</span>
<span class="lineNum">     373 </span>            :   {
<span class="lineNum">     374 </span>            :     // TODO, bug 998693
<span class="lineNum">     375 </span>            :     // Initial index build should be forced here so that about:cache soon
<span class="lineNum">     376 </span>            :     // after startup gives some meaningfull results.
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :     // Dispatch to the INDEX level in hope that very recent cache entries
<span class="lineNum">     379 </span>            :     // information gets to the index list before we grab the index iterator
<span class="lineNum">     380 </span>            :     // for the first time.  This tries to avoid miss of entries that has
<span class="lineNum">     381 </span>            :     // been created right before the visit is required.
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     RefPtr&lt;CacheIOThread&gt; thread = CacheFileIOManager::IOThread();</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(thread, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     return thread-&gt;Dispatch(this, CacheIOThread::INDEX);</span>
<span class="lineNum">     386 </span>            :   }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : private:
<a name="389"><span class="lineNum">     389 </span>            :   // Invokes OnCacheEntryInfo callback for each single found entry.</a>
<span class="lineNum">     390 </span>            :   // There is one instance of this class per one entry.
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   class OnCacheEntryInfoRunnable : public Runnable</span>
<a name="392"><span class="lineNum">     392 </span>            :   {</a>
<span class="lineNum">     393 </span>            :   public:
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     explicit OnCacheEntryInfoRunnable(WalkDiskCacheRunnable* aWalker)</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       : Runnable(&quot;net::WalkDiskCacheRunnable::OnCacheEntryInfoRunnable&quot;)</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       , mWalker(aWalker)</span>
<span class="lineNum">     397 </span>            :     {
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     NS_IMETHOD Run() override</span>
<span class="lineNum">     401 </span>            :     {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(NS_IsMainThread());</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :       nsresult rv;
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       rv = NS_NewURI(getter_AddRefs(uri), mURISpec);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv)) {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">     410 </span>            :       }
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       rv = mWalker-&gt;mCallback-&gt;OnCacheEntryInfo(</span>
<span class="lineNum">     413 </span>            :         uri, mIdEnhance, mDataSize, mFetchCount,
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         mLastModifiedTime, mExpirationTime, mPinned, mInfo);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       if (NS_FAILED(rv)) {</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         mWalker-&gt;mCancel = true;</span>
<span class="lineNum">     417 </span>            :       }
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">     420 </span>            :     }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :     RefPtr&lt;WalkDiskCacheRunnable&gt; mWalker;
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :     nsCString mURISpec;
<span class="lineNum">     425 </span>            :     nsCString mIdEnhance;
<span class="lineNum">     426 </span>            :     int64_t mDataSize;
<span class="lineNum">     427 </span>            :     int32_t mFetchCount;
<span class="lineNum">     428 </span>            :     uint32_t mLastModifiedTime;
<span class="lineNum">     429 </span>            :     uint32_t mExpirationTime;
<span class="lineNum">     430 </span>            :     bool mPinned;
<span class="lineNum">     431 </span>            :     nsCOMPtr&lt;nsILoadContextInfo&gt; mInfo;
<a name="432"><span class="lineNum">     432 </span>            :   };</a>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   NS_IMETHOD Run() override</span>
<span class="lineNum">     435 </span>            :   {
<span class="lineNum">     436 </span>            :     // The main loop
<span class="lineNum">     437 </span>            :     nsresult rv;
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     if (CacheStorageService::IsOnManagementThread()) {</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       switch (mPass) {</span>
<span class="lineNum">     441 </span>            :       case COLLECT_STATS:
<span class="lineNum">     442 </span>            :         // Get quickly the cache stats.
<span class="lineNum">     443 </span>            :         uint32_t size;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         rv = CacheIndex::GetCacheStats(mLoadInfo, &amp;size, &amp;mCount);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :           if (mVisitEntries) {</span>
<span class="lineNum">     447 </span>            :             // both onStorageInfo and onCompleted are expected
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :             NS_DispatchToMainThread(this);</span>
<span class="lineNum">     449 </span>            :           }
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :           return NS_DispatchToMainThread(this);</span>
<span class="lineNum">     451 </span>            :         }
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         mSize = static_cast&lt;uint64_t&gt;(size) &lt;&lt; 10;</span>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            :         // Invoke onCacheStorageInfo with valid information.
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         NS_DispatchToMainThread(this);</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         if (!mVisitEntries) {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :           return NS_OK; // done</span>
<span class="lineNum">     460 </span>            :         }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         mPass = ITERATE_METADATA;</span>
<span class="lineNum">     463 </span>            :         MOZ_FALLTHROUGH;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :       case ITERATE_METADATA:
<span class="lineNum">     466 </span>            :         // Now grab the context iterator.
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         if (!mIter) {</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :           rv = CacheIndex::GetIterator(mLoadInfo, true, getter_AddRefs(mIter));</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :           if (NS_FAILED(rv)) {</span>
<span class="lineNum">     470 </span>            :             // Invoke onCacheEntryVisitCompleted now
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :             return NS_DispatchToMainThread(this);</span>
<span class="lineNum">     472 </span>            :           }
<span class="lineNum">     473 </span>            :         }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         while (!mCancel &amp;&amp; !CacheObserver::ShuttingDown()) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :           if (CacheIOThread::YieldAndRerun())</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             return NS_OK;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :           SHA1Sum::Hash hash;
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :           rv = mIter-&gt;GetNextHash(&amp;hash);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :           if (NS_FAILED(rv))</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :             break; // done (or error?)</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :           // This synchronously invokes OnEntryInfo on this class where we
<span class="lineNum">     485 </span>            :           // redispatch to the main thread for the consumer callback.
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :           CacheFileIOManager::GetEntryInfo(&amp;hash, this);</span>
<span class="lineNum">     487 </span>            :         }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :         // Invoke onCacheEntryVisitCompleted on the main thread
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :         NS_DispatchToMainThread(this);</span>
<span class="lineNum">     491 </span>            :       }
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     } else if (NS_IsMainThread()) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       if (mNotifyStorage) {</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsIFile&gt; dir;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         CacheFileIOManager::GetCacheDirectory(getter_AddRefs(dir));</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         mCallback-&gt;OnCacheStorageInfo(mCount, mSize, CacheObserver::DiskCacheCapacity(), dir);</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         mNotifyStorage = false;</span>
<span class="lineNum">     498 </span>            :       } else {
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         mCallback-&gt;OnCacheEntryVisitCompleted();</span>
<span class="lineNum">     500 </span>            :       }
<span class="lineNum">     501 </span>            :     } else {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;Bad thread&quot;);</span>
<span class="lineNum">     503 </span>            :       return NS_ERROR_FAILURE;
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<a name="507"><span class="lineNum">     507 </span>            :   }</a>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   virtual void OnEntryInfo(const nsACString &amp; aURISpec, const nsACString &amp; aIdEnhance,</span>
<span class="lineNum">     510 </span>            :                            int64_t aDataSize, int32_t aFetchCount,
<span class="lineNum">     511 </span>            :                            uint32_t aLastModifiedTime, uint32_t aExpirationTime,
<span class="lineNum">     512 </span>            :                            bool aPinned, nsILoadContextInfo* aInfo) override
<span class="lineNum">     513 </span>            :   {
<span class="lineNum">     514 </span>            :     // Called directly from CacheFileIOManager::GetEntryInfo.
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :     // Invoke onCacheEntryInfo on the main thread for this entry.
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     RefPtr&lt;OnCacheEntryInfoRunnable&gt; info = new OnCacheEntryInfoRunnable(this);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     info-&gt;mURISpec = aURISpec;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     info-&gt;mIdEnhance = aIdEnhance;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     info-&gt;mDataSize = aDataSize;</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     info-&gt;mFetchCount = aFetchCount;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     info-&gt;mLastModifiedTime = aLastModifiedTime;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     info-&gt;mExpirationTime = aExpirationTime;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     info-&gt;mPinned = aPinned;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     info-&gt;mInfo = aInfo;</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     NS_DispatchToMainThread(info);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   RefPtr&lt;nsILoadContextInfo&gt; mLoadInfo;
<span class="lineNum">     531 </span>            :   enum {
<span class="lineNum">     532 </span>            :     // First, we collect stats for the load context.
<span class="lineNum">     533 </span>            :     COLLECT_STATS,
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :     // Second, if demanded, we iterate over the entries gethered
<span class="lineNum">     536 </span>            :     // from the iterator and call CacheFileIOManager::GetEntryInfo
<span class="lineNum">     537 </span>            :     // for each found entry.
<span class="lineNum">     538 </span>            :     ITERATE_METADATA,
<span class="lineNum">     539 </span>            :   } mPass;
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :   RefPtr&lt;CacheIndexIterator&gt; mIter;
<span class="lineNum">     542 </span>            :   uint32_t mCount;
<span class="lineNum">     543 </span>            : };
<span class="lineNum">     544 </span>            : 
<a name="545"><span class="lineNum">     545 </span>            : } // namespace</a>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 : void CacheStorageService::DropPrivateBrowsingEntries()</span>
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   if (mShutdown)</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   nsTArray&lt;nsCString&gt; keys;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   for (auto iter = sGlobalEntryTables-&gt;Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     const nsACString&amp; key = iter.Key();</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsILoadContextInfo&gt; info = CacheFileUtils::ParseKey(key);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     if (info &amp;&amp; info-&gt;IsPrivate()) {</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       keys.AppendElement(key);</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            :   }
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; keys.Length(); ++i) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     DoomStorageEntries(keys[i], nullptr, true, false, nullptr);</span>
<span class="lineNum">     565 </span>            :   }
<span class="lineNum">     566 </span>            : }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : namespace {
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : class CleaupCacheDirectoriesRunnable : public Runnable
<span class="lineNum">     571 </span>            : {
<span class="lineNum">     572 </span>            : public:
<span class="lineNum">     573 </span>            :   NS_DECL_NSIRUNNABLE
<span class="lineNum">     574 </span>            :   static bool Post(uint32_t aVersion, uint32_t aActive);
<a name="575"><span class="lineNum">     575 </span>            : </a>
<span class="lineNum">     576 </span>            : private:
<span class="lineNum">     577 </span><span class="lineCov">          1 :   CleaupCacheDirectoriesRunnable(uint32_t aVersion, uint32_t aActive)</span>
<span class="lineNum">     578 </span><span class="lineCov">          1 :     : Runnable(&quot;net::CleaupCacheDirectoriesRunnable&quot;)</span>
<span class="lineNum">     579 </span>            :     , mVersion(aVersion)
<span class="lineNum">     580 </span><span class="lineCov">          1 :     , mActive(aActive)</span>
<span class="lineNum">     581 </span>            :   {
<span class="lineNum">     582 </span><span class="lineCov">          1 :     nsCacheService::GetDiskCacheDirectory(getter_AddRefs(mCache1Dir));</span>
<span class="lineNum">     583 </span><span class="lineCov">          1 :     CacheFileIOManager::GetCacheDirectory(getter_AddRefs(mCache2Dir));</span>
<span class="lineNum">     584 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">     585 </span>            :     CacheFileIOManager::GetProfilelessCacheDirectory(getter_AddRefs(mCache2Profileless));
<span class="lineNum">     586 </span>            : #endif
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">          1 :   }</span></a>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineCov">          3 :   virtual ~CleaupCacheDirectoriesRunnable() {}</span>
<span class="lineNum">     590 </span>            :   uint32_t mVersion, mActive;
<span class="lineNum">     591 </span>            :   nsCOMPtr&lt;nsIFile&gt; mCache1Dir, mCache2Dir;
<span class="lineNum">     592 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">     593 </span>            :   nsCOMPtr&lt;nsIFile&gt; mCache2Profileless;
<span class="lineNum">     594 </span>            : #endif
<span class="lineNum">     595 </span>            : };
<a name="596"><span class="lineNum">     596 </span>            : </a>
<span class="lineNum">     597 </span>            : // static
<span class="lineNum">     598 </span><span class="lineCov">          1 : bool CleaupCacheDirectoriesRunnable::Post(uint32_t aVersion, uint32_t aActive)</span>
<span class="lineNum">     599 </span>            : {
<span class="lineNum">     600 </span>            :   // CleaupCacheDirectories is called regardless what cache version is set up to use.
<span class="lineNum">     601 </span>            :   // To obtain the cache1 directory we must unfortunately instantiate the old cache
<span class="lineNum">     602 </span>            :   // service despite it may not be used at all...  This also initialize nsDeleteDir.
<span class="lineNum">     603 </span><span class="lineCov">          2 :   nsCOMPtr&lt;nsICacheService&gt; service = do_GetService(NS_CACHESERVICE_CONTRACTID);</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :   if (!service)</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">          2 :   nsCOMPtr&lt;nsIEventTarget&gt; thread;</span>
<span class="lineNum">     608 </span><span class="lineCov">          1 :   service-&gt;GetCacheIOTarget(getter_AddRefs(thread));</span>
<span class="lineNum">     609 </span><span class="lineCov">          1 :   if (!thread)</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :   RefPtr&lt;CleaupCacheDirectoriesRunnable&gt; r =
<span class="lineNum">     613 </span><span class="lineCov">          2 :     new CleaupCacheDirectoriesRunnable(aVersion, aActive);</span>
<span class="lineNum">     614 </span><span class="lineCov">          1 :   thread-&gt;Dispatch(r, NS_DISPATCH_NORMAL);</span>
<span class="lineNum">     615 </span><span class="lineCov">          1 :   return true;</span>
<a name="616"><span class="lineNum">     616 </span>            : }</a>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">          1 : NS_IMETHODIMP CleaupCacheDirectoriesRunnable::Run()</span>
<span class="lineNum">     619 </span>            : {
<span class="lineNum">     620 </span><span class="lineCov">          1 :   MOZ_ASSERT(!NS_IsMainThread());</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">          1 :   if (mCache1Dir) {</span>
<span class="lineNum">     623 </span><span class="lineCov">          1 :     nsDeleteDir::RemoveOldTrashes(mCache1Dir);</span>
<span class="lineNum">     624 </span>            :   }
<span class="lineNum">     625 </span><span class="lineCov">          1 :   if (mCache2Dir) {</span>
<span class="lineNum">     626 </span><span class="lineCov">          1 :     nsDeleteDir::RemoveOldTrashes(mCache2Dir);</span>
<span class="lineNum">     627 </span>            :   }
<span class="lineNum">     628 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">     629 </span>            :   if (mCache2Profileless) {
<span class="lineNum">     630 </span>            :     nsDeleteDir::RemoveOldTrashes(mCache2Profileless);
<span class="lineNum">     631 </span>            :     // Always delete the profileless cache on Android
<span class="lineNum">     632 </span>            :     nsDeleteDir::DeleteDir(mCache2Profileless, true, 30000);
<span class="lineNum">     633 </span>            :   }
<span class="lineNum">     634 </span>            : #endif
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :   // Delete the non-active version cache data right now
<span class="lineNum">     637 </span><span class="lineCov">          1 :   if (mVersion == mActive) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     639 </span>            :   }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineCov">          1 :   switch (mVersion) {</span>
<span class="lineNum">     642 </span>            :   case 0:
<span class="lineNum">     643 </span><span class="lineCov">          1 :     if (mCache1Dir) {</span>
<span class="lineNum">     644 </span><span class="lineCov">          1 :       nsDeleteDir::DeleteDir(mCache1Dir, true, 30000);</span>
<span class="lineNum">     645 </span>            :     }
<span class="lineNum">     646 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">     647 </span>            :   case 1:
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     if (mCache2Dir) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       nsDeleteDir::DeleteDir(mCache2Dir, true, 30000);</span>
<span class="lineNum">     650 </span>            :     }
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     652 </span>            :   }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     655 </span>            : }
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            : } // namespace
<a name="658"><span class="lineNum">     658 </span>            : </a>
<span class="lineNum">     659 </span>            : // static
<span class="lineNum">     660 </span><span class="lineCov">          1 : void CacheStorageService::CleaupCacheDirectories(uint32_t aVersion, uint32_t aActive)</span>
<span class="lineNum">     661 </span>            : {
<span class="lineNum">     662 </span>            :   // Make sure we schedule just once in case CleaupCacheDirectories gets called
<span class="lineNum">     663 </span>            :   // multiple times from some reason.
<span class="lineNum">     664 </span><span class="lineCov">          1 :   static bool runOnce = CleaupCacheDirectoriesRunnable::Post(aVersion, aActive);</span>
<span class="lineNum">     665 </span><span class="lineCov">          1 :   if (!runOnce) {</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Could not start cache trashes cleanup&quot;);</span>
<span class="lineNum">     667 </span>            :   }
<span class="lineNum">     668 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : // Helper methods
<a name="671"><span class="lineNum">     671 </span>            : </a>
<span class="lineNum">     672 </span>            : // static
<span class="lineNum">     673 </span><span class="lineCov">         72 : bool CacheStorageService::IsOnManagementThread()</span>
<span class="lineNum">     674 </span>            : {
<span class="lineNum">     675 </span><span class="lineCov">        144 :   RefPtr&lt;CacheStorageService&gt; service = Self();</span>
<span class="lineNum">     676 </span><span class="lineCov">         72 :   if (!service)</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span><span class="lineCov">        144 :   nsCOMPtr&lt;nsIEventTarget&gt; target = service-&gt;Thread();</span>
<span class="lineNum">     680 </span><span class="lineCov">         72 :   if (!target)</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :   bool currentThread;
<span class="lineNum">     684 </span><span class="lineCov">         72 :   nsresult rv = target-&gt;IsOnCurrentThread(&amp;currentThread);</span>
<span class="lineNum">     685 </span><span class="lineCov">         72 :   return NS_SUCCEEDED(rv) &amp;&amp; currentThread;</span>
<a name="686"><span class="lineNum">     686 </span>            : }</a>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineCov">         72 : already_AddRefed&lt;nsIEventTarget&gt; CacheStorageService::Thread() const</span>
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span><span class="lineCov">         72 :   return CacheFileIOManager::IOTarget();</span>
<a name="691"><span class="lineNum">     691 </span>            : }</a>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineCov">         13 : nsresult CacheStorageService::Dispatch(nsIRunnable* aEvent)</span>
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span><span class="lineCov">         26 :   RefPtr&lt;CacheIOThread&gt; cacheIOThread = CacheFileIOManager::IOThread();</span>
<span class="lineNum">     696 </span><span class="lineCov">         13 :   if (!cacheIOThread)</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">         13 :   return cacheIOThread-&gt;Dispatch(aEvent, CacheIOThread::MANAGEMENT);</span>
<span class="lineNum">     700 </span>            : }
<span class="lineNum">     701 </span>            : 
<a name="702"><span class="lineNum">     702 </span>            : // nsICacheStorageService</a>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::MemoryCacheStorage(nsILoadContextInfo *aLoadContextInfo,</span>
<span class="lineNum">     705 </span>            :                                                       nsICacheStorage * *_retval)
<span class="lineNum">     706 </span>            : {
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aLoadContextInfo);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(_retval);</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsICacheStorage&gt; storage;</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     storage = new CacheStorage(aLoadContextInfo, false, false, false, false);</span>
<span class="lineNum">     713 </span>            :   }
<span class="lineNum">     714 </span>            :   else {
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     storage = new _OldStorage(aLoadContextInfo, false, false, false, nullptr);</span>
<span class="lineNum">     716 </span>            :   }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   storage.forget(_retval);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="720"><span class="lineNum">     720 </span>            : }</a>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineCov">         10 : NS_IMETHODIMP CacheStorageService::DiskCacheStorage(nsILoadContextInfo *aLoadContextInfo,</span>
<span class="lineNum">     723 </span>            :                                                     bool aLookupAppCache,
<span class="lineNum">     724 </span>            :                                                     nsICacheStorage * *_retval)
<span class="lineNum">     725 </span>            : {
<span class="lineNum">     726 </span><span class="lineCov">         10 :   NS_ENSURE_ARG(aLoadContextInfo);</span>
<span class="lineNum">     727 </span><span class="lineCov">         10 :   NS_ENSURE_ARG(_retval);</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :   // TODO save some heap granularity - cache commonly used storages.
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   // When disk cache is disabled, still provide a storage, but just keep stuff
<span class="lineNum">     732 </span>            :   // in memory.
<span class="lineNum">     733 </span><span class="lineCov">         10 :   bool useDisk = CacheObserver::UseDiskCache();</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">         20 :   nsCOMPtr&lt;nsICacheStorage&gt; storage;</span>
<span class="lineNum">     736 </span><span class="lineCov">         10 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     737 </span><span class="lineCov">         10 :     storage = new CacheStorage(aLoadContextInfo, useDisk, aLookupAppCache, false /* size limit */, false /* don't pin */);</span>
<span class="lineNum">     738 </span>            :   }
<span class="lineNum">     739 </span>            :   else {
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     storage = new _OldStorage(aLoadContextInfo, useDisk, aLookupAppCache, false, nullptr);</span>
<span class="lineNum">     741 </span>            :   }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineCov">         10 :   storage.forget(_retval);</span>
<span class="lineNum">     744 </span><span class="lineCov">         10 :   return NS_OK;</span>
<a name="745"><span class="lineNum">     745 </span>            : }</a>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::PinningCacheStorage(nsILoadContextInfo *aLoadContextInfo,</span>
<span class="lineNum">     748 </span>            :                                                        nsICacheStorage * *_retval)
<span class="lineNum">     749 </span>            : {
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aLoadContextInfo);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(_retval);</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :   if (!CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_IMPLEMENTED;</span>
<span class="lineNum">     755 </span>            :   }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            :   // When disk cache is disabled don't pretend we cache.
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   if (!CacheObserver::UseDiskCache()) {</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">     760 </span>            :   }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :   nsCOMPtr&lt;nsICacheStorage&gt; storage = new CacheStorage(
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     aLoadContextInfo, true /* use disk */, false /* no appcache */, true /* ignore size checks */, true /* pin */);</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   storage.forget(_retval);</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="766"><span class="lineNum">     766 </span>            : }</a>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::AppCacheStorage(nsILoadContextInfo *aLoadContextInfo,</span>
<span class="lineNum">     769 </span>            :                                                    nsIApplicationCache *aApplicationCache,
<span class="lineNum">     770 </span>            :                                                    nsICacheStorage * *_retval)
<span class="lineNum">     771 </span>            : {
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aLoadContextInfo);</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(_retval);</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsICacheStorage&gt; storage;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     777 </span>            :     // Using classification since cl believes we want to instantiate this method
<span class="lineNum">     778 </span>            :     // having the same name as the desired class...
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     storage = new mozilla::net::AppCacheStorage(aLoadContextInfo, aApplicationCache);</span>
<span class="lineNum">     780 </span>            :   }
<span class="lineNum">     781 </span>            :   else {
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     storage = new _OldStorage(aLoadContextInfo, true, false, true, aApplicationCache);</span>
<span class="lineNum">     783 </span>            :   }
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   storage.forget(_retval);</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="787"><span class="lineNum">     787 </span>            : }</a>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::SynthesizedCacheStorage(nsILoadContextInfo *aLoadContextInfo,</span>
<span class="lineNum">     790 </span>            :                                                            nsICacheStorage * *_retval)
<span class="lineNum">     791 </span>            : {
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aLoadContextInfo);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(_retval);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsICacheStorage&gt; storage;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     storage = new CacheStorage(aLoadContextInfo, false, false, true /* skip size checks for synthesized cache */, false /* no pinning */);</span>
<span class="lineNum">     798 </span>            :   }
<span class="lineNum">     799 </span>            :   else {
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     storage = new _OldStorage(aLoadContextInfo, false, false, false, nullptr);</span>
<span class="lineNum">     801 </span>            :   }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   storage.forget(_retval);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="805"><span class="lineNum">     805 </span>            : }</a>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::Clear()</span>
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span>            :   nsresult rv;
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     812 </span>            :     // Tell the index to block notification to AsyncGetDiskConsumption.
<span class="lineNum">     813 </span>            :     // Will be allowed again from CacheFileContextEvictor::EvictEntries()
<span class="lineNum">     814 </span>            :     // when all the context have been removed from disk.
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     CacheIndex::OnAsyncEviction(true);</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :     {
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :       mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :       {
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         mozilla::MutexAutoLock forcedValidEntriesLock(mForcedValidEntriesLock);</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         mForcedValidEntries.Clear();</span>
<span class="lineNum">     823 </span>            :       }
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       NS_ENSURE_TRUE(!mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       nsTArray&lt;nsCString&gt; keys;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       for (auto iter = sGlobalEntryTables-&gt;Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         keys.AppendElement(iter.Key());</span>
<span class="lineNum">     830 </span>            :       }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; i &lt; keys.Length(); ++i) {</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         DoomStorageEntries(keys[i], nullptr, true, false, nullptr);</span>
<span class="lineNum">     834 </span>            :       }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :       // Passing null as a load info means to evict all contexts.
<span class="lineNum">     837 </span>            :       // EvictByContext() respects the entry pinning.  EvictAll() does not.
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       rv = CacheFileIOManager::EvictByContext(nullptr, false);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span>            :   } else {
<span class="lineNum">     842 </span>            :     nsCOMPtr&lt;nsICacheService&gt; serv =
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         do_GetService(NS_CACHESERVICE_CONTRACTID, &amp;rv);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     rv = serv-&gt;EvictEntries(nsICache::STORE_ANYWHERE);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     848 </span>            :   }
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="851"><span class="lineNum">     851 </span>            : }</a>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::PurgeFromMemory(uint32_t aWhat)</span>
<span class="lineNum">     854 </span>            : {
<span class="lineNum">     855 </span>            :   uint32_t what;
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   switch (aWhat) {</span>
<span class="lineNum">     858 </span>            :   case PURGE_DISK_DATA_ONLY:
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     what = CacheEntry::PURGE_DATA_ONLY_DISK_BACKED;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            :   case PURGE_DISK_ALL:
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     what = CacheEntry::PURGE_WHOLE_ONLY_DISK_BACKED;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :   case PURGE_EVERYTHING:
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     what = CacheEntry::PURGE_WHOLE;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :   default:
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     return NS_ERROR_INVALID_ARG;</span>
<span class="lineNum">     872 </span>            :   }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :   nsCOMPtr&lt;nsIRunnable&gt; event =
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :     new PurgeFromMemoryRunnable(this, what);</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   return Dispatch(event);</span>
<a name="878"><span class="lineNum">     878 </span>            : }</a>
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::PurgeFromMemoryRunnable::Run()</span>
<span class="lineNum">     881 </span>            : {
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   if (NS_IsMainThread()) {</span>
<span class="lineNum">     883 </span>            :     nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       mozilla::services::GetObserverService();</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     if (observerService) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       observerService-&gt;NotifyObservers(nullptr, &quot;cacheservice:purge-memory-pools&quot;, nullptr);</span>
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   if (mService) {</span>
<span class="lineNum">     893 </span>            :     // TODO not all flags apply to both pools
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     mService-&gt;Pool(true).PurgeAll(mWhat);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     mService-&gt;Pool(false).PurgeAll(mWhat);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     mService = nullptr;</span>
<span class="lineNum">     897 </span>            :   }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   NS_DispatchToMainThread(this);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="901"><span class="lineNum">     901 </span>            : }</a>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::AsyncGetDiskConsumption(</span>
<span class="lineNum">     904 </span>            :   nsICacheStorageConsumptionObserver* aObserver)
<span class="lineNum">     905 </span>            : {
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aObserver);</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :   nsresult rv;
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     rv = CacheIndex::AsyncGetDiskConsumption(aObserver);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     913 </span>            :   } else {
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     rv = _OldGetDiskConsumption::Get(aObserver);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     916 </span>            :   }
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="919"><span class="lineNum">     919 </span>            : }</a>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::GetIoTarget(nsIEventTarget** aEventTarget)</span>
<span class="lineNum">     922 </span>            : {
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aEventTarget);</span>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   if (CacheObserver::UseNewCache()) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIEventTarget&gt; ioTarget = CacheFileIOManager::IOTarget();</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     ioTarget.forget(aEventTarget);</span>
<span class="lineNum">     928 </span>            :   }
<span class="lineNum">     929 </span>            :   else {
<span class="lineNum">     930 </span>            :     nsresult rv;
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            :     nsCOMPtr&lt;nsICacheService&gt; serv =
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         do_GetService(NS_CACHESERVICE_CONTRACTID, &amp;rv);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     rv = serv-&gt;GetCacheIOTarget(aEventTarget);</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     938 </span>            :   }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="941"><span class="lineNum">     941 </span>            : }</a>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheStorageService::AsyncVisitAllStorages(</span>
<span class="lineNum">     944 </span>            :   nsICacheStorageVisitor* aVisitor,
<span class="lineNum">     945 </span>            :   bool aVisitEntries)
<span class="lineNum">     946 </span>            : {
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::AsyncVisitAllStorages [cb=%p]&quot;, aVisitor));</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   // Walking the disk cache also walks the memory cache.
<span class="lineNum">     951 </span>            :   RefPtr&lt;WalkDiskCacheRunnable&gt; event =
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     new WalkDiskCacheRunnable(nullptr, aVisitEntries, aVisitor);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   return event-&gt;Walk();</span>
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :   return NS_OK;
<span class="lineNum">     956 </span>            : }
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            : // Methods used by CacheEntry for management of in-memory structures.
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            : namespace {
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            : class FrecencyComparator
<a name="963"><span class="lineNum">     963 </span>            : {</a>
<span class="lineNum">     964 </span>            : public:
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   bool Equals(CacheEntry* a, CacheEntry* b) const {</span>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 :     return a-&gt;GetFrecency() == b-&gt;GetFrecency();</span></a>
<span class="lineNum">     967 </span>            :   }
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   bool LessThan(CacheEntry* a, CacheEntry* b) const {</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :     return a-&gt;GetFrecency() &lt; b-&gt;GetFrecency();</span>
<span class="lineNum">     970 </span>            :   }
<span class="lineNum">     971 </span>            : };
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            : class ExpirationComparator
<a name="974"><span class="lineNum">     974 </span>            : {</a>
<span class="lineNum">     975 </span>            : public:
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   bool Equals(CacheEntry* a, CacheEntry* b) const {</span>
<a name="977"><span class="lineNum">     977 </span><span class="lineNoCov">          0 :     return a-&gt;GetExpirationTime() == b-&gt;GetExpirationTime();</span></a>
<span class="lineNum">     978 </span>            :   }
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   bool LessThan(CacheEntry* a, CacheEntry* b) const {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     return a-&gt;GetExpirationTime() &lt; b-&gt;GetExpirationTime();</span>
<span class="lineNum">     981 </span>            :   }
<span class="lineNum">     982 </span>            : };
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            : } // namespace
<a name="985"><span class="lineNum">     985 </span>            : </a>
<span class="lineNum">     986 </span>            : void
<span class="lineNum">     987 </span><span class="lineCov">          5 : CacheStorageService::RegisterEntry(CacheEntry* aEntry)</span>
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span><span class="lineCov">          5 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span><span class="lineCov">          5 :   if (mShutdown || !aEntry-&gt;CanRegister())</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineCov">          5 :   TelemetryRecordEntryCreation(aEntry);</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">          5 :   LOG((&quot;CacheStorageService::RegisterEntry [entry=%p]&quot;, aEntry));</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineCov">          5 :   MemoryPool&amp; pool = Pool(aEntry-&gt;IsUsingDisk());</span>
<span class="lineNum">     999 </span><span class="lineCov">          5 :   pool.mFrecencyArray.AppendElement(aEntry);</span>
<span class="lineNum">    1000 </span><span class="lineCov">          5 :   pool.mExpirationArray.AppendElement(aEntry);</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineCov">          5 :   aEntry-&gt;SetRegistered(true);</span>
<span class="lineNum">    1003 </span>            : }
<a name="1004"><span class="lineNum">    1004 </span>            : </a>
<span class="lineNum">    1005 </span>            : void
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 : CacheStorageService::UnregisterEntry(CacheEntry* aEntry)</span>
<span class="lineNum">    1007 </span>            : {
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   if (!aEntry-&gt;IsRegistered())</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   TelemetryRecordEntryRemoval(aEntry);</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::UnregisterEntry [entry=%p]&quot;, aEntry));</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   MemoryPool&amp; pool = Pool(aEntry-&gt;IsUsingDisk());</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   mozilla::DebugOnly&lt;bool&gt; removedFrecency = pool.mFrecencyArray.RemoveElement(aEntry);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   mozilla::DebugOnly&lt;bool&gt; removedExpiration = pool.mExpirationArray.RemoveElement(aEntry);</span>
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mShutdown || (removedFrecency &amp;&amp; removedExpiration));</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   // Note: aEntry-&gt;CanRegister() since now returns false
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   aEntry-&gt;SetRegistered(false);</span>
<span class="lineNum">    1025 </span>            : }
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<span class="lineNum">    1027 </span>            : static bool
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 : AddExactEntry(CacheEntryTable* aEntries,</span>
<span class="lineNum">    1029 </span>            :               nsACString const&amp; aKey,
<span class="lineNum">    1030 </span>            :               CacheEntry* aEntry,
<span class="lineNum">    1031 </span>            :               bool aOverwrite)
<span class="lineNum">    1032 </span>            : {
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheEntry&gt; existingEntry;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   if (!aOverwrite &amp;&amp; aEntries-&gt;Get(aKey, getter_AddRefs(existingEntry))) {</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     bool equals = existingEntry == aEntry;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     LOG((&quot;AddExactEntry [entry=%p equals=%d]&quot;, aEntry, equals));</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     return equals; // Already there...</span>
<span class="lineNum">    1038 </span>            :   }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   LOG((&quot;AddExactEntry [entry=%p put]&quot;, aEntry));</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   aEntries-&gt;Put(aKey, aEntry);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1043 </span>            : }
<a name="1044"><span class="lineNum">    1044 </span>            : </a>
<span class="lineNum">    1045 </span>            : static bool
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 : RemoveExactEntry(CacheEntryTable* aEntries,</span>
<span class="lineNum">    1047 </span>            :                  nsACString const&amp; aKey,
<span class="lineNum">    1048 </span>            :                  CacheEntry* aEntry,
<span class="lineNum">    1049 </span>            :                  bool aOverwrite)
<span class="lineNum">    1050 </span>            : {
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheEntry&gt; existingEntry;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   if (!aEntries-&gt;Get(aKey, getter_AddRefs(existingEntry))) {</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     LOG((&quot;RemoveExactEntry [entry=%p already gone]&quot;, aEntry));</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     return false; // Already removed...</span>
<span class="lineNum">    1055 </span>            :   }
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   if (!aOverwrite &amp;&amp; existingEntry != aEntry) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     LOG((&quot;RemoveExactEntry [entry=%p already replaced]&quot;, aEntry));</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     return false; // Already replaced...</span>
<span class="lineNum">    1060 </span>            :   }
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   LOG((&quot;RemoveExactEntry [entry=%p removed]&quot;, aEntry));</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   aEntries-&gt;Remove(aKey);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1065 </span>            : }
<a name="1066"><span class="lineNum">    1066 </span>            : </a>
<span class="lineNum">    1067 </span>            : bool
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 : CacheStorageService::RemoveEntry(CacheEntry* aEntry, bool aOnlyUnreferenced)</span>
<span class="lineNum">    1069 </span>            : {
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::RemoveEntry [entry=%p]&quot;, aEntry));</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   nsAutoCString entryKey;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   nsresult rv = aEntry-&gt;HashingKey(entryKey);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;aEntry-&gt;HashingKey() failed?&quot;);</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1077 </span>            :   }
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :   if (mShutdown) {</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     LOG((&quot;  after shutdown&quot;));</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1084 </span>            :   }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   if (aOnlyUnreferenced) {</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     if (aEntry-&gt;IsReferenced()) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :       LOG((&quot;  still referenced, not removing&quot;));</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1090 </span>            :     }
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     if (!aEntry-&gt;IsUsingDisk() &amp;&amp; IsForcedValidEntry(aEntry-&gt;GetStorageID(), entryKey)) {</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       LOG((&quot;  forced valid, not removing&quot;));</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1095 </span>            :     }
<span class="lineNum">    1096 </span>            :   }
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            :   CacheEntryTable* entries;
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   if (sGlobalEntryTables-&gt;Get(aEntry-&gt;GetStorageID(), &amp;entries))</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     RemoveExactEntry(entries, entryKey, aEntry, false /* don't overwrite */);</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   nsAutoCString memoryStorageID(aEntry-&gt;GetStorageID());</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   AppendMemoryStorageID(memoryStorageID);</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   if (sGlobalEntryTables-&gt;Get(memoryStorageID, &amp;entries))</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     RemoveExactEntry(entries, entryKey, aEntry, false /* don't overwrite */);</span>
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1109 </span>            : }
<a name="1110"><span class="lineNum">    1110 </span>            : </a>
<span class="lineNum">    1111 </span>            : void
<span class="lineNum">    1112 </span><span class="lineCov">          5 : CacheStorageService::RecordMemoryOnlyEntry(CacheEntry* aEntry,</span>
<span class="lineNum">    1113 </span>            :                                            bool aOnlyInMemory,
<span class="lineNum">    1114 </span>            :                                            bool aOverwrite)
<span class="lineNum">    1115 </span>            : {
<span class="lineNum">    1116 </span><span class="lineCov">          5 :   LOG((&quot;CacheStorageService::RecordMemoryOnlyEntry [entry=%p, memory=%d, overwrite=%d]&quot;,</span>
<span class="lineNum">    1117 </span>            :     aEntry, aOnlyInMemory, aOverwrite));
<span class="lineNum">    1118 </span>            :   // This method is responsible to put this entry to a special record hashtable
<span class="lineNum">    1119 </span>            :   // that contains only entries that are stored in memory.
<span class="lineNum">    1120 </span>            :   // Keep in mind that every entry, regardless of whether is in-memory-only or not
<span class="lineNum">    1121 </span>            :   // is always recorded in the storage master hash table, the one identified by
<span class="lineNum">    1122 </span>            :   // CacheEntry.StorageID().
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">          5 :   mLock.AssertCurrentThreadOwns();</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span><span class="lineCov">          5 :   if (mShutdown) {</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     LOG((&quot;  after shutdown&quot;));</span>
<span class="lineNum">    1128 </span><span class="lineCov">          5 :     return;</span>
<span class="lineNum">    1129 </span>            :   }
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span>            :   nsresult rv;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineCov">          5 :   nsAutoCString entryKey;</span>
<span class="lineNum">    1134 </span><span class="lineCov">          5 :   rv = aEntry-&gt;HashingKey(entryKey);</span>
<span class="lineNum">    1135 </span><span class="lineCov">          5 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;aEntry-&gt;HashingKey() failed?&quot;);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1138 </span>            :   }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineCov">          5 :   CacheEntryTable* entries = nullptr;</span>
<span class="lineNum">    1141 </span><span class="lineCov">          5 :   nsAutoCString memoryStorageID(aEntry-&gt;GetStorageID());</span>
<span class="lineNum">    1142 </span><span class="lineCov">          5 :   AppendMemoryStorageID(memoryStorageID);</span>
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineCov">          5 :   if (!sGlobalEntryTables-&gt;Get(memoryStorageID, &amp;entries)) {</span>
<span class="lineNum">    1145 </span><span class="lineCov">          5 :     if (!aOnlyInMemory) {</span>
<span class="lineNum">    1146 </span><span class="lineCov">          5 :       LOG((&quot;  not recorded as memory only&quot;));</span>
<span class="lineNum">    1147 </span><span class="lineCov">          5 :       return;</span>
<span class="lineNum">    1148 </span>            :     }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     entries = new CacheEntryTable(CacheEntryTable::MEMORY_ONLY);</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     sGlobalEntryTables-&gt;Put(memoryStorageID, entries);</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     LOG((&quot;  new memory-only storage table for %s&quot;, memoryStorageID.get()));</span>
<span class="lineNum">    1153 </span>            :   }
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   if (aOnlyInMemory) {</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :     AddExactEntry(entries, entryKey, aEntry, aOverwrite);</span>
<span class="lineNum">    1157 </span>            :   }
<span class="lineNum">    1158 </span>            :   else {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :     RemoveExactEntry(entries, entryKey, aEntry, aOverwrite);</span>
<span class="lineNum">    1160 </span>            :   }
<span class="lineNum">    1161 </span>            : }
<span class="lineNum">    1162 </span>            : 
<a name="1163"><span class="lineNum">    1163 </span>            : // Checks if a cache entry is forced valid (will be loaded directly from cache</a>
<span class="lineNum">    1164 </span>            : // without further validation) - see nsICacheEntry.idl for further details
<span class="lineNum">    1165 </span><span class="lineCov">          4 : bool CacheStorageService::IsForcedValidEntry(nsACString const &amp;aContextKey,</span>
<span class="lineNum">    1166 </span>            :                                              nsACString const &amp;aEntryKey)
<span class="lineNum">    1167 </span>            : {
<span class="lineNum">    1168 </span><span class="lineCov">          4 :   return IsForcedValidEntry(aContextKey + aEntryKey);</span>
<a name="1169"><span class="lineNum">    1169 </span>            : }</a>
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineCov">          4 : bool CacheStorageService::IsForcedValidEntry(nsACString const &amp;aContextEntryKey)</span>
<span class="lineNum">    1172 </span>            : {
<span class="lineNum">    1173 </span><span class="lineCov">          8 :   mozilla::MutexAutoLock lock(mForcedValidEntriesLock);</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineCov">          4 :   TimeStamp validUntil;</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineCov">          4 :   if (!mForcedValidEntries.Get(aContextEntryKey, &amp;validUntil)) {</span>
<span class="lineNum">    1178 </span><span class="lineCov">          4 :     return false;</span>
<span class="lineNum">    1179 </span>            :   }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :   if (validUntil.IsNull()) {</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1183 </span>            :   }
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            :   // Entry timeout not reached yet
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   if (TimeStamp::NowLoRes() &lt;= validUntil) {</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1188 </span>            :   }
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            :   // Entry timeout has been reached
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   mForcedValidEntries.Remove(aContextEntryKey);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1193 </span>            : }
<span class="lineNum">    1194 </span>            : 
<a name="1195"><span class="lineNum">    1195 </span>            : // Allows a cache entry to be loaded directly from cache without further</a>
<span class="lineNum">    1196 </span>            : // validation - see nsICacheEntry.idl for further details
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 : void CacheStorageService::ForceEntryValidFor(nsACString const &amp;aContextKey,</span>
<span class="lineNum">    1198 </span>            :                                              nsACString const &amp;aEntryKey,
<span class="lineNum">    1199 </span>            :                                              uint32_t aSecondsToTheFuture)
<span class="lineNum">    1200 </span>            : {
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mForcedValidEntriesLock);</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   TimeStamp now = TimeStamp::NowLoRes();</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   ForcedValidEntriesPrune(now);</span>
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   // This will be the timeout
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   TimeStamp validUntil = now + TimeDuration::FromSeconds(aSecondsToTheFuture);</span>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   mForcedValidEntries.Put(aContextKey + aEntryKey, validUntil);</span>
<a name="1210"><span class="lineNum">    1210 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineCov">          1 : void CacheStorageService::RemoveEntryForceValid(nsACString const &amp;aContextKey,</span>
<span class="lineNum">    1213 </span>            :                                                 nsACString const &amp;aEntryKey)
<span class="lineNum">    1214 </span>            : {
<span class="lineNum">    1215 </span><span class="lineCov">          2 :   mozilla::MutexAutoLock lock(mForcedValidEntriesLock);</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">          1 :   LOG((&quot;CacheStorageService::RemoveEntryForceValid context='%s' entryKey=%s&quot;,</span>
<span class="lineNum">    1218 </span>            :        aContextKey.BeginReading(), aEntryKey.BeginReading()));
<span class="lineNum">    1219 </span><span class="lineCov">          1 :   mForcedValidEntries.Remove(aContextKey + aEntryKey);</span>
<span class="lineNum">    1220 </span><span class="lineCov">          1 : }</span>
<a name="1221"><span class="lineNum">    1221 </span>            : </a>
<span class="lineNum">    1222 </span>            : // Cleans out the old entries in mForcedValidEntries
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 : void CacheStorageService::ForcedValidEntriesPrune(TimeStamp &amp;now)</span>
<span class="lineNum">    1224 </span>            : {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   static TimeDuration const oneMinute = TimeDuration::FromSeconds(60);</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :   static TimeStamp dontPruneUntil = now + oneMinute;</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :   if (now &lt; dontPruneUntil)</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   for (auto iter = mForcedValidEntries.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     if (iter.Data() &lt; now) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       iter.Remove();</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span>            :   }
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :   dontPruneUntil = now + oneMinute;</span>
<span class="lineNum">    1236 </span>            : }
<a name="1237"><span class="lineNum">    1237 </span>            : </a>
<span class="lineNum">    1238 </span>            : void
<span class="lineNum">    1239 </span><span class="lineCov">         26 : CacheStorageService::OnMemoryConsumptionChange(CacheMemoryConsumer* aConsumer,</span>
<span class="lineNum">    1240 </span>            :                                                uint32_t aCurrentMemoryConsumption)
<span class="lineNum">    1241 </span>            : {
<span class="lineNum">    1242 </span><span class="lineCov">         26 :   LOG((&quot;CacheStorageService::OnMemoryConsumptionChange [consumer=%p, size=%u]&quot;,</span>
<span class="lineNum">    1243 </span>            :     aConsumer, aCurrentMemoryConsumption));
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineCov">         26 :   uint32_t savedMemorySize = aConsumer-&gt;mReportedMemoryConsumption;</span>
<span class="lineNum">    1246 </span><span class="lineCov">         26 :   if (savedMemorySize == aCurrentMemoryConsumption)</span>
<span class="lineNum">    1247 </span><span class="lineCov">         35 :     return;</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :   // Exchange saved size with current one.
<span class="lineNum">    1250 </span><span class="lineCov">         17 :   aConsumer-&gt;mReportedMemoryConsumption = aCurrentMemoryConsumption;</span>
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineCov">         17 :   bool usingDisk = !(aConsumer-&gt;mFlags &amp; CacheMemoryConsumer::MEMORY_ONLY);</span>
<span class="lineNum">    1253 </span><span class="lineCov">         17 :   bool overLimit = Pool(usingDisk).OnMemoryConsumptionChange(</span>
<span class="lineNum">    1254 </span><span class="lineCov">         17 :     savedMemorySize, aCurrentMemoryConsumption);</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">         17 :   if (!overLimit)</span>
<span class="lineNum">    1257 </span><span class="lineCov">         17 :     return;</span>
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :   // It's likely the timer has already been set when we get here,
<span class="lineNum">    1260 </span>            :   // check outside the lock to save resources.
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   if (mPurgeTimer)</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            :   // We don't know if this is called under the service lock or not,
<span class="lineNum">    1265 </span>            :   // hence rather dispatch.
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsIEventTarget&gt; cacheIOTarget = Thread();</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   if (!cacheIOTarget)</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            :   // Dispatch as a priority task, we want to set the purge timer
<span class="lineNum">    1271 </span>            :   // ASAP to prevent vain redispatch of this event.
<span class="lineNum">    1272 </span>            :   nsCOMPtr&lt;nsIRunnable&gt; event =
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :     NewRunnableMethod(&quot;net::CacheStorageService::SchedulePurgeOverMemoryLimit&quot;,</span>
<span class="lineNum">    1274 </span>            :                       this,
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                       &amp;CacheStorageService::SchedulePurgeOverMemoryLimit);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :   cacheIOTarget-&gt;Dispatch(event, nsIEventTarget::DISPATCH_NORMAL);</span>
<span class="lineNum">    1277 </span>            : }
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<span class="lineNum">    1279 </span>            : bool
<span class="lineNum">    1280 </span><span class="lineCov">         17 : CacheStorageService::MemoryPool::OnMemoryConsumptionChange(uint32_t aSavedMemorySize,</span>
<span class="lineNum">    1281 </span>            :                                                            uint32_t aCurrentMemoryConsumption)
<span class="lineNum">    1282 </span>            : {
<span class="lineNum">    1283 </span><span class="lineCov">         17 :   mMemorySize -= aSavedMemorySize;</span>
<span class="lineNum">    1284 </span><span class="lineCov">         17 :   mMemorySize += aCurrentMemoryConsumption;</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">         17 :   LOG((&quot;  mMemorySize=%u (+%u,-%u)&quot;, uint32_t(mMemorySize), aCurrentMemoryConsumption, aSavedMemorySize));</span>
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :   // Bypass purging when memory has not grew up significantly
<span class="lineNum">    1289 </span><span class="lineCov">         17 :   if (aCurrentMemoryConsumption &lt;= aSavedMemorySize)</span>
<span class="lineNum">    1290 </span><span class="lineCov">          2 :     return false;</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineCov">         15 :   return mMemorySize &gt; Limit();</span>
<span class="lineNum">    1293 </span>            : }
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<span class="lineNum">    1295 </span>            : void
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 : CacheStorageService::SchedulePurgeOverMemoryLimit()</span>
<span class="lineNum">    1297 </span>            : {
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::SchedulePurgeOverMemoryLimit&quot;));</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :   if (mShutdown) {</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     LOG((&quot;  past shutdown&quot;));</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1305 </span>            :   }
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   if (mPurgeTimer) {</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     LOG((&quot;  timer already up&quot;));</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1310 </span>            :   }
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   mPurgeTimer = do_CreateInstance(NS_TIMER_CONTRACTID);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :   if (mPurgeTimer) {</span>
<span class="lineNum">    1314 </span>            :     nsresult rv;
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :     rv = mPurgeTimer-&gt;InitWithCallback(this, 1000, nsITimer::TYPE_ONE_SHOT);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     LOG((&quot;  timer init rv=0x%08&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<span class="lineNum">    1317 </span>            :   }
<span class="lineNum">    1318 </span>            : }
<a name="1319"><span class="lineNum">    1319 </span>            : </a>
<span class="lineNum">    1320 </span>            : NS_IMETHODIMP
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 : CacheStorageService::Notify(nsITimer* aTimer)</span>
<span class="lineNum">    1322 </span>            : {
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::Notify&quot;));</span>
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   if (aTimer == mPurgeTimer) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     mPurgeTimer = nullptr;</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            :     nsCOMPtr&lt;nsIRunnable&gt; event =
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       NewRunnableMethod(&quot;net::CacheStorageService::PurgeOverMemoryLimit&quot;,</span>
<span class="lineNum">    1332 </span>            :                         this,
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                         &amp;CacheStorageService::PurgeOverMemoryLimit);</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     Dispatch(event);</span>
<span class="lineNum">    1335 </span>            :   }
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1338 </span>            : }
<a name="1339"><span class="lineNum">    1339 </span>            : </a>
<span class="lineNum">    1340 </span>            : void
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 : CacheStorageService::PurgeOverMemoryLimit()</span>
<span class="lineNum">    1342 </span>            : {
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::PurgeOverMemoryLimit&quot;));</span>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   static TimeDuration const kFourSeconds = TimeDuration::FromSeconds(4);</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   TimeStamp now = TimeStamp::NowLoRes();</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   if (!mLastPurgeTime.IsNull() &amp;&amp; now - mLastPurgeTime &lt; kFourSeconds) {</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :     LOG((&quot;  bypassed, too soon&quot;));</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1353 </span>            :   }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :   mLastPurgeTime = now;</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :   Pool(true).PurgeOverMemoryLimit();</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :   Pool(false).PurgeOverMemoryLimit();</span>
<span class="lineNum">    1359 </span>            : }
<a name="1360"><span class="lineNum">    1360 </span>            : </a>
<span class="lineNum">    1361 </span>            : void
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 : CacheStorageService::MemoryPool::PurgeOverMemoryLimit()</span>
<span class="lineNum">    1363 </span>            : {
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   TimeStamp start(TimeStamp::Now());</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :   uint32_t const memoryLimit = Limit();</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   if (mMemorySize &gt; memoryLimit) {</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     LOG((&quot;  memory data consumption over the limit, abandon expired entries&quot;));</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     PurgeExpired();</span>
<span class="lineNum">    1370 </span>            :   }
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   bool frecencyNeedsSort = true;</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   // No longer makes sense since:
<span class="lineNum">    1375 </span>            :   // Memory entries are never purged partially, only as a whole when the memory
<span class="lineNum">    1376 </span>            :   // cache limit is overreached.
<span class="lineNum">    1377 </span>            :   // Disk entries throw the data away ASAP so that only metadata are kept.
<span class="lineNum">    1378 </span>            :   // TODO when this concept of two separate pools is found working, the code should
<span class="lineNum">    1379 </span>            :   // clean up.
<span class="lineNum">    1380 </span>            : #if 0
<span class="lineNum">    1381 </span>            :   if (mMemorySize &gt; memoryLimit) {
<span class="lineNum">    1382 </span>            :     LOG((&quot;  memory data consumption over the limit, abandon disk backed data&quot;));
<span class="lineNum">    1383 </span>            :     PurgeByFrecency(frecencyNeedsSort, CacheEntry::PURGE_DATA_ONLY_DISK_BACKED);
<span class="lineNum">    1384 </span>            :   }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :   if (mMemorySize &gt; memoryLimit) {
<span class="lineNum">    1387 </span>            :     LOG((&quot;  metadata consumtion over the limit, abandon disk backed entries&quot;));
<span class="lineNum">    1388 </span>            :     PurgeByFrecency(frecencyNeedsSort, CacheEntry::PURGE_WHOLE_ONLY_DISK_BACKED);
<span class="lineNum">    1389 </span>            :   }
<span class="lineNum">    1390 </span>            : #endif
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   if (mMemorySize &gt; memoryLimit) {</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     LOG((&quot;  memory data consumption over the limit, abandon any entry&quot;));</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     PurgeByFrecency(frecencyNeedsSort, CacheEntry::PURGE_WHOLE);</span>
<span class="lineNum">    1395 </span>            :   }
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :   LOG((&quot;  purging took %1.2fms&quot;, (TimeStamp::Now() - start).ToMilliseconds()));</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 : }</span>
<a name="1399"><span class="lineNum">    1399 </span>            : </a>
<span class="lineNum">    1400 </span>            : void
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 : CacheStorageService::MemoryPool::PurgeExpired()</span>
<span class="lineNum">    1402 </span>            : {
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :   mExpirationArray.Sort(ExpirationComparator());</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :   uint32_t now = NowInSeconds();</span>
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   uint32_t const memoryLimit = Limit();</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; mMemorySize &gt; memoryLimit &amp;&amp; i &lt; mExpirationArray.Length();) {</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     if (CacheIOThread::YieldAndRerun())</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     RefPtr&lt;CacheEntry&gt; entry = mExpirationArray[i];</span>
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     uint32_t expirationTime = entry-&gt;GetExpirationTime();</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     if (expirationTime &gt; 0 &amp;&amp; expirationTime &lt;= now &amp;&amp;</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :         entry-&gt;Purge(CacheEntry::PURGE_WHOLE)) {</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       LOG((&quot;  purged expired, entry=%p, exptime=%u (now=%u)&quot;,</span>
<span class="lineNum">    1420 </span>            :         entry.get(), entry-&gt;GetExpirationTime(), now));
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1422 </span>            :     }
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span>            :     // not purged, move to the next one
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     ++i;</span>
<span class="lineNum">    1426 </span>            :   }
<span class="lineNum">    1427 </span>            : }
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<span class="lineNum">    1429 </span>            : void
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 : CacheStorageService::MemoryPool::PurgeByFrecency(bool &amp;aFrecencyNeedsSort, uint32_t aWhat)</span>
<span class="lineNum">    1431 </span>            : {
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   if (aFrecencyNeedsSort) {</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     mFrecencyArray.Sort(FrecencyComparator());</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :     aFrecencyNeedsSort = false;</span>
<span class="lineNum">    1437 </span>            :   }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   uint32_t const memoryLimit = Limit();</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; mMemorySize &gt; memoryLimit &amp;&amp; i &lt; mFrecencyArray.Length();) {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :     if (CacheIOThread::YieldAndRerun())</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     RefPtr&lt;CacheEntry&gt; entry = mFrecencyArray[i];</span>
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :     if (entry-&gt;Purge(aWhat)) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :       LOG((&quot;  abandoned (%d), entry=%p, frecency=%1.10f&quot;,</span>
<span class="lineNum">    1449 </span>            :         aWhat, entry.get(), entry-&gt;GetFrecency()));
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1451 </span>            :     }
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span>            :     // not purged, move to the next one
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     ++i;</span>
<span class="lineNum">    1455 </span>            :   }
<span class="lineNum">    1456 </span>            : }
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<span class="lineNum">    1458 </span>            : void
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 : CacheStorageService::MemoryPool::PurgeAll(uint32_t aWhat)</span>
<span class="lineNum">    1460 </span>            : {
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::MemoryPool::PurgeAll aWhat=%d&quot;, aWhat));</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(IsOnManagementThread());</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mFrecencyArray.Length();) {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     if (CacheIOThread::YieldAndRerun())</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     RefPtr&lt;CacheEntry&gt; entry = mFrecencyArray[i];</span>
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     if (entry-&gt;Purge(aWhat)) {</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :       LOG((&quot;  abandoned entry=%p&quot;, entry.get()));</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1473 </span>            :     }
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :     // not purged, move to the next one
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :     ++i;</span>
<span class="lineNum">    1477 </span>            :   }
<span class="lineNum">    1478 </span>            : }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            : // Methods exposed to and used by CacheStorage.
<a name="1481"><span class="lineNum">    1481 </span>            : </a>
<span class="lineNum">    1482 </span>            : nsresult
<span class="lineNum">    1483 </span><span class="lineCov">         13 : CacheStorageService::AddStorageEntry(CacheStorage const* aStorage,</span>
<span class="lineNum">    1484 </span>            :                                      const nsACString &amp; aURI,
<span class="lineNum">    1485 </span>            :                                      const nsACString &amp; aIdExtension,
<span class="lineNum">    1486 </span>            :                                      bool aReplace,
<span class="lineNum">    1487 </span>            :                                      CacheEntryHandle** aResult)
<span class="lineNum">    1488 </span>            : {
<span class="lineNum">    1489 </span><span class="lineCov">         13 :   NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span><span class="lineCov">         13 :   NS_ENSURE_ARG(aStorage);</span>
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineCov">         26 :   nsAutoCString contextKey;</span>
<span class="lineNum">    1494 </span><span class="lineCov">         13 :   CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span><span class="lineCov">         52 :   return AddStorageEntry(contextKey, aURI, aIdExtension,</span>
<span class="lineNum">    1497 </span><span class="lineCov">         13 :                          aStorage-&gt;WriteToDisk(),</span>
<span class="lineNum">    1498 </span><span class="lineCov">         13 :                          aStorage-&gt;SkipSizeCheck(),</span>
<span class="lineNum">    1499 </span><span class="lineCov">         13 :                          aStorage-&gt;Pinning(),</span>
<span class="lineNum">    1500 </span>            :                          aReplace,
<span class="lineNum">    1501 </span><span class="lineCov">         13 :                          aResult);</span>
<span class="lineNum">    1502 </span>            : }
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<span class="lineNum">    1504 </span>            : nsresult
<span class="lineNum">    1505 </span><span class="lineCov">         13 : CacheStorageService::AddStorageEntry(const nsACString&amp; aContextKey,</span>
<span class="lineNum">    1506 </span>            :                                      const nsACString &amp; aURI,
<span class="lineNum">    1507 </span>            :                                      const nsACString &amp; aIdExtension,
<span class="lineNum">    1508 </span>            :                                      bool aWriteToDisk,
<span class="lineNum">    1509 </span>            :                                      bool aSkipSizeCheck,
<span class="lineNum">    1510 </span>            :                                      bool aPin,
<span class="lineNum">    1511 </span>            :                                      bool aReplace,
<span class="lineNum">    1512 </span>            :                                      CacheEntryHandle** aResult)
<span class="lineNum">    1513 </span>            : {
<span class="lineNum">    1514 </span>            :   nsresult rv;
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineCov">         26 :   nsAutoCString entryKey;</span>
<span class="lineNum">    1517 </span><span class="lineCov">         13 :   rv = CacheEntry::HashingKey(EmptyCString(), aIdExtension, aURI, entryKey);</span>
<span class="lineNum">    1518 </span><span class="lineCov">         13 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">         13 :   LOG((&quot;CacheStorageService::AddStorageEntry [entryKey=%s, contextKey=%s]&quot;,</span>
<span class="lineNum">    1521 </span>            :     entryKey.get(), aContextKey.BeginReading()));
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineCov">         26 :   RefPtr&lt;CacheEntry&gt; entry;</span>
<span class="lineNum">    1524 </span><span class="lineCov">         26 :   RefPtr&lt;CacheEntryHandle&gt; handle;</span>
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :   {
<span class="lineNum">    1527 </span><span class="lineCov">         26 :     mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span><span class="lineCov">         13 :     NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            :     // Ensure storage table
<span class="lineNum">    1532 </span>            :     CacheEntryTable* entries;
<span class="lineNum">    1533 </span><span class="lineCov">         13 :     if (!sGlobalEntryTables-&gt;Get(aContextKey, &amp;entries)) {</span>
<span class="lineNum">    1534 </span><span class="lineCov">          1 :       entries = new CacheEntryTable(CacheEntryTable::ALL_ENTRIES);</span>
<span class="lineNum">    1535 </span><span class="lineCov">          1 :       sGlobalEntryTables-&gt;Put(aContextKey, entries);</span>
<span class="lineNum">    1536 </span><span class="lineCov">          1 :       LOG((&quot;  new storage entries table for context '%s'&quot;, aContextKey.BeginReading()));</span>
<span class="lineNum">    1537 </span>            :     }
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineCov">         13 :     bool entryExists = entries-&gt;Get(entryKey, getter_AddRefs(entry));</span>
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span><span class="lineCov">         13 :     if (entryExists &amp;&amp; !aReplace) {</span>
<span class="lineNum">    1542 </span>            :       // check whether we want to turn this entry to a memory-only.
<span class="lineNum">    1543 </span><span class="lineCov">          8 :       if (MOZ_UNLIKELY(!aWriteToDisk) &amp;&amp; MOZ_LIKELY(entry-&gt;IsUsingDisk())) {</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :         LOG((&quot;  entry is persistent but we want mem-only, replacing it&quot;));</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :         aReplace = true;</span>
<span class="lineNum">    1546 </span>            :       }
<span class="lineNum">    1547 </span>            :     }
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span>            :     // If truncate is demanded, delete and doom the current entry
<span class="lineNum">    1550 </span><span class="lineCov">         13 :     if (entryExists &amp;&amp; aReplace) {</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :       entries-&gt;Remove(entryKey);</span>
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :       LOG((&quot;  dooming entry %p for %s because of OPEN_TRUNCATE&quot;, entry.get(), entryKey.get()));</span>
<span class="lineNum">    1554 </span>            :       // On purpose called under the lock to prevent races of doom and open on I/O thread
<span class="lineNum">    1555 </span>            :       // No need to remove from both memory-only and all-entries tables.  The new entry
<span class="lineNum">    1556 </span>            :       // will overwrite the shadow entry in its ctor.
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :       entry-&gt;DoomAlreadyRemoved();</span>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :       entry = nullptr;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :       entryExists = false;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :       // Would only lead to deleting force-valid timestamp again.  We don't need the
<span class="lineNum">    1563 </span>            :       // replace information anymore after this point anyway.
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :       aReplace = false;</span>
<span class="lineNum">    1565 </span>            :     }
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span>            :     // Ensure entry for the particular URL
<span class="lineNum">    1568 </span><span class="lineCov">         13 :     if (!entryExists) {</span>
<span class="lineNum">    1569 </span>            :       // When replacing with a new entry, always remove the current force-valid timestamp,
<span class="lineNum">    1570 </span>            :       // this is the only place to do it.
<span class="lineNum">    1571 </span><span class="lineCov">          5 :       if (aReplace) {</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :         RemoveEntryForceValid(aContextKey, entryKey);</span>
<span class="lineNum">    1573 </span>            :       }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            :       // Entry is not in the hashtable or has just been truncated...
<span class="lineNum">    1576 </span><span class="lineCov">          5 :       entry = new CacheEntry(aContextKey, aURI, aIdExtension, aWriteToDisk, aSkipSizeCheck, aPin);</span>
<span class="lineNum">    1577 </span><span class="lineCov">          5 :       entries-&gt;Put(entryKey, entry);</span>
<span class="lineNum">    1578 </span><span class="lineCov">          5 :       LOG((&quot;  new entry %p for %s&quot;, entry.get(), entryKey.get()));</span>
<span class="lineNum">    1579 </span>            :     }
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span><span class="lineCov">         13 :     if (entry) {</span>
<span class="lineNum">    1582 </span>            :       // Here, if this entry was not for a long time referenced by any consumer,
<span class="lineNum">    1583 </span>            :       // gets again first 'handles count' reference.
<span class="lineNum">    1584 </span><span class="lineCov">         13 :       handle = entry-&gt;NewHandle();</span>
<span class="lineNum">    1585 </span>            :     }
<span class="lineNum">    1586 </span>            :   }
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineCov">         13 :   handle.forget(aResult);</span>
<span class="lineNum">    1589 </span><span class="lineCov">         13 :   return NS_OK;</span>
<span class="lineNum">    1590 </span>            : }
<a name="1591"><span class="lineNum">    1591 </span>            : </a>
<span class="lineNum">    1592 </span>            : nsresult
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 : CacheStorageService::CheckStorageEntry(CacheStorage const* aStorage,</span>
<span class="lineNum">    1594 </span>            :                                        const nsACString &amp; aURI,
<span class="lineNum">    1595 </span>            :                                        const nsACString &amp; aIdExtension,
<span class="lineNum">    1596 </span>            :                                        bool* aResult)
<span class="lineNum">    1597 </span>            : {
<span class="lineNum">    1598 </span>            :   nsresult rv;
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :   nsAutoCString contextKey;</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :   CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   if (!aStorage-&gt;WriteToDisk()) {</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :     AppendMemoryStorageID(contextKey);</span>
<span class="lineNum">    1605 </span>            :   }
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::CheckStorageEntry [uri=%s, eid=%s, contextKey=%s]&quot;,</span>
<span class="lineNum">    1608 </span>            :     aURI.BeginReading(), aIdExtension.BeginReading(), contextKey.get()));
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :   {
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :     nsAutoCString entryKey;</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     rv = CacheEntry::HashingKey(EmptyCString(), aIdExtension, aURI, entryKey);</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            :     CacheEntryTable* entries;
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :     if ((*aResult = sGlobalEntryTables-&gt;Get(contextKey, &amp;entries)) &amp;&amp;</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :         entries-&gt;GetWeak(entryKey, aResult)) {</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :       LOG((&quot;  found in hash tables&quot;));</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">    1624 </span>            :     }
<span class="lineNum">    1625 </span>            :   }
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   if (!aStorage-&gt;WriteToDisk()) {</span>
<span class="lineNum">    1628 </span>            :     // Memory entry, nothing more to do.
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     LOG((&quot;  not found in hash tables&quot;));</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1631 </span>            :   }
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :   // Disk entry, not found in the hashtable, check the index.
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :   nsAutoCString fileKey;</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   rv = CacheEntry::HashingKey(contextKey, aIdExtension, aURI, fileKey);</span>
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span>            :   CacheIndex::EntryStatus status;
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :   rv = CacheIndex::HasEntry(fileKey, &amp;status);</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv) || status == CacheIndex::DO_NOT_KNOW) {</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :     LOG((&quot;  index doesn't know, rv=0x%08&quot; PRIx32, static_cast&lt;uint32_t&gt;(rv)));</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">    1642 </span>            :   }
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   *aResult = status == CacheIndex::EXISTS;</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   LOG((&quot;  %sfound in index&quot;, *aResult ? &quot;&quot; : &quot;not &quot;));</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1647 </span>            : }
<a name="1648"><span class="lineNum">    1648 </span>            : </a>
<span class="lineNum">    1649 </span>            : nsresult
<span class="lineNum">    1650 </span><span class="lineCov">          5 : CacheStorageService::GetCacheIndexEntryAttrs(CacheStorage const* aStorage,</span>
<span class="lineNum">    1651 </span>            :                                              const nsACString &amp;aURI,
<span class="lineNum">    1652 </span>            :                                              const nsACString &amp;aIdExtension,
<span class="lineNum">    1653 </span>            :                                              bool *aHasAltData,
<span class="lineNum">    1654 </span>            :                                              uint32_t *aFileSizeKb)
<span class="lineNum">    1655 </span>            : {
<span class="lineNum">    1656 </span>            :   nsresult rv;
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineCov">         10 :   nsAutoCString contextKey;</span>
<span class="lineNum">    1659 </span><span class="lineCov">          5 :   CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineCov">          5 :   LOG((&quot;CacheStorageService::GetCacheIndexEntryAttrs [uri=%s, eid=%s, contextKey=%s]&quot;,</span>
<span class="lineNum">    1662 </span>            :     aURI.BeginReading(), aIdExtension.BeginReading(), contextKey.get()));
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span><span class="lineCov">         10 :   nsAutoCString fileKey;</span>
<span class="lineNum">    1665 </span><span class="lineCov">          5 :   rv = CacheEntry::HashingKey(contextKey, aIdExtension, aURI, fileKey);</span>
<span class="lineNum">    1666 </span><span class="lineCov">          5 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1668 </span>            :   }
<span class="lineNum">    1669 </span>            : 
<a name="1670"><span class="lineNum">    1670 </span><span class="lineCov">          5 :   *aHasAltData = false;</span></a>
<span class="lineNum">    1671 </span><span class="lineCov">          5 :   *aFileSizeKb = 0;</span>
<span class="lineNum">    1672 </span><span class="lineCov">          4 :   auto closure = [&amp;aHasAltData, &amp;aFileSizeKb](const CacheIndexEntry *entry) {</span>
<span class="lineNum">    1673 </span><span class="lineCov">          2 :     *aHasAltData = entry-&gt;GetHasAltData();</span>
<span class="lineNum">    1674 </span><span class="lineCov">          2 :     *aFileSizeKb = entry-&gt;GetFileSize();</span>
<span class="lineNum">    1675 </span><span class="lineCov">          7 :   };</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            :   CacheIndex::EntryStatus status;
<span class="lineNum">    1678 </span><span class="lineCov">          5 :   rv = CacheIndex::HasEntry(fileKey, &amp;status, closure);</span>
<span class="lineNum">    1679 </span><span class="lineCov">          5 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     return rv;</span>
<span class="lineNum">    1681 </span>            :   }
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineCov">          5 :   if (status != CacheIndex::EXISTS) {</span>
<span class="lineNum">    1684 </span><span class="lineCov">          3 :     return NS_ERROR_CACHE_KEY_NOT_FOUND;</span>
<span class="lineNum">    1685 </span>            :   }
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineCov">          2 :   return NS_OK;</span>
<span class="lineNum">    1688 </span>            : }
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            : namespace {
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            : class CacheEntryDoomByKeyCallback : public CacheFileIOListener
<span class="lineNum">    1694 </span>            :                                   , public nsIRunnable
<span class="lineNum">    1695 </span>            : {
<span class="lineNum">    1696 </span>            : public:
<span class="lineNum">    1697 </span>            :   NS_DECL_THREADSAFE_ISUPPORTS
<a name="1698"><span class="lineNum">    1698 </span>            :   NS_DECL_NSIRUNNABLE</a>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span><span class="lineCov">          1 :   explicit CacheEntryDoomByKeyCallback(nsICacheEntryDoomCallback* aCallback)</span>
<span class="lineNum">    1701 </span><span class="lineCov">          1 :     : mCallback(aCallback) { }</span>
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            : private:
<a name="1704"><span class="lineNum">    1704 </span>            :   virtual ~CacheEntryDoomByKeyCallback();</a>
<a name="1705"><span class="lineNum">    1705 </span>            : </a>
<a name="1706"><span class="lineNum">    1706 </span><span class="lineNoCov">          0 :   NS_IMETHOD OnFileOpened(CacheFileHandle *aHandle, nsresult aResult) override { return NS_OK; }</span></a>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :   NS_IMETHOD OnDataWritten(CacheFileHandle *aHandle, const char *aBuf, nsresult aResult) override { return NS_OK; }</span>
<a name="1708"><span class="lineNum">    1708 </span><span class="lineNoCov">          0 :   NS_IMETHOD OnDataRead(CacheFileHandle *aHandle, char *aBuf, nsresult aResult) override { return NS_OK; }</span></a>
<a name="1709"><span class="lineNum">    1709 </span>            :   NS_IMETHOD OnFileDoomed(CacheFileHandle *aHandle, nsresult aResult) override;</a>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :   NS_IMETHOD OnEOFSet(CacheFileHandle *aHandle, nsresult aResult) override { return NS_OK; }</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :   NS_IMETHOD OnFileRenamed(CacheFileHandle *aHandle, nsresult aResult) override { return NS_OK; }</span>
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            :   nsCOMPtr&lt;nsICacheEntryDoomCallback&gt; mCallback;
<span class="lineNum">    1714 </span>            :   nsresult mResult;
<a name="1715"><span class="lineNum">    1715 </span>            : };</a>
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span><span class="lineCov">          3 : CacheEntryDoomByKeyCallback::~CacheEntryDoomByKeyCallback()</span>
<span class="lineNum">    1718 </span>            : {
<span class="lineNum">    1719 </span><span class="lineCov">          1 :   if (mCallback)</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     ProxyReleaseMainThread(</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :       &quot;CacheEntryDoomByKeyCallback::mCallback&quot;, mCallback);</span>
<a name="1722"><span class="lineNum">    1722 </span><span class="lineCov">          3 : }</span></a>
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">          1 : NS_IMETHODIMP CacheEntryDoomByKeyCallback::OnFileDoomed(CacheFileHandle *aHandle,</span>
<span class="lineNum">    1725 </span>            :                                                         nsresult aResult)
<span class="lineNum">    1726 </span>            : {
<span class="lineNum">    1727 </span><span class="lineCov">          1 :   if (!mCallback)</span>
<span class="lineNum">    1728 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :   mResult = aResult;</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   if (NS_IsMainThread()) {</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :     Run();</span>
<span class="lineNum">    1733 </span>            :   } else {
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     NS_DispatchToMainThread(this);</span>
<span class="lineNum">    1735 </span>            :   }
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="1738"><span class="lineNum">    1738 </span>            : }</a>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 : NS_IMETHODIMP CacheEntryDoomByKeyCallback::Run()</span>
<span class="lineNum">    1741 </span>            : {
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   mCallback-&gt;OnCacheEntryDoomed(mResult);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="1744"><span class="lineNum">    1744 </span>            : }</a>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span><span class="lineCov">          7 : NS_IMPL_ISUPPORTS(CacheEntryDoomByKeyCallback, CacheFileIOListener, nsIRunnable);</span>
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span>            : } // namespace
<a name="1749"><span class="lineNum">    1749 </span>            : </a>
<span class="lineNum">    1750 </span>            : nsresult
<span class="lineNum">    1751 </span><span class="lineCov">          1 : CacheStorageService::DoomStorageEntry(CacheStorage const* aStorage,</span>
<span class="lineNum">    1752 </span>            :                                       const nsACString &amp; aURI,
<span class="lineNum">    1753 </span>            :                                       const nsACString &amp; aIdExtension,
<span class="lineNum">    1754 </span>            :                                       nsICacheEntryDoomCallback* aCallback)
<span class="lineNum">    1755 </span>            : {
<span class="lineNum">    1756 </span><span class="lineCov">          1 :   LOG((&quot;CacheStorageService::DoomStorageEntry&quot;));</span>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span><span class="lineCov">          1 :   NS_ENSURE_ARG(aStorage);</span>
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineCov">          2 :   nsAutoCString contextKey;</span>
<span class="lineNum">    1761 </span><span class="lineCov">          1 :   CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineCov">          2 :   nsAutoCString entryKey;</span>
<span class="lineNum">    1764 </span><span class="lineCov">          1 :   nsresult rv = CacheEntry::HashingKey(EmptyCString(), aIdExtension, aURI, entryKey);</span>
<span class="lineNum">    1765 </span><span class="lineCov">          1 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">          2 :   RefPtr&lt;CacheEntry&gt; entry;</span>
<span class="lineNum">    1768 </span>            :   {
<span class="lineNum">    1769 </span><span class="lineCov">          2 :     mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineCov">          1 :     NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :     CacheEntryTable* entries;
<span class="lineNum">    1774 </span><span class="lineCov">          1 :     if (sGlobalEntryTables-&gt;Get(contextKey, &amp;entries)) {</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :       if (entries-&gt;Get(entryKey, getter_AddRefs(entry))) {</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :         if (aStorage-&gt;WriteToDisk() || !entry-&gt;IsUsingDisk()) {</span>
<span class="lineNum">    1777 </span>            :           // When evicting from disk storage, purge
<span class="lineNum">    1778 </span>            :           // When evicting from memory storage and the entry is memory-only, purge
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :           LOG((&quot;  purging entry %p for %s [storage use disk=%d, entry use disk=%d]&quot;,</span>
<span class="lineNum">    1780 </span>            :             entry.get(), entryKey.get(), aStorage-&gt;WriteToDisk(), entry-&gt;IsUsingDisk()));
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :           entries-&gt;Remove(entryKey);</span>
<span class="lineNum">    1782 </span>            :         }
<span class="lineNum">    1783 </span>            :         else {
<span class="lineNum">    1784 </span>            :           // Otherwise, leave it
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :           LOG((&quot;  leaving entry %p for %s [storage use disk=%d, entry use disk=%d]&quot;,</span>
<span class="lineNum">    1786 </span>            :             entry.get(), entryKey.get(), aStorage-&gt;WriteToDisk(), entry-&gt;IsUsingDisk()));
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :           entry = nullptr;</span>
<span class="lineNum">    1788 </span>            :         }
<span class="lineNum">    1789 </span>            :       }
<span class="lineNum">    1790 </span>            :     }
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span><span class="lineCov">          1 :     if (!entry) {</span>
<span class="lineNum">    1793 </span><span class="lineCov">          1 :       RemoveEntryForceValid(contextKey, entryKey);</span>
<span class="lineNum">    1794 </span>            :     }
<span class="lineNum">    1795 </span>            :   }
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineCov">          1 :   if (entry) {</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :     LOG((&quot;  dooming entry %p for %s&quot;, entry.get(), entryKey.get()));</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     return entry-&gt;AsyncDoom(aCallback);</span>
<span class="lineNum">    1800 </span>            :   }
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span><span class="lineCov">          1 :   LOG((&quot;  no entry loaded for %s&quot;, entryKey.get()));</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span><span class="lineCov">          1 :   if (aStorage-&gt;WriteToDisk()) {</span>
<span class="lineNum">    1805 </span><span class="lineCov">          2 :     nsAutoCString contextKey;</span>
<span class="lineNum">    1806 </span><span class="lineCov">          1 :     CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span><span class="lineCov">          1 :     rv = CacheEntry::HashingKey(contextKey, aIdExtension, aURI, entryKey);</span>
<span class="lineNum">    1809 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span><span class="lineCov">          1 :     LOG((&quot;  dooming file only for %s&quot;, entryKey.get()));</span>
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :     RefPtr&lt;CacheEntryDoomByKeyCallback&gt; callback(
<span class="lineNum">    1814 </span><span class="lineCov">          2 :       new CacheEntryDoomByKeyCallback(aCallback));</span>
<span class="lineNum">    1815 </span><span class="lineCov">          1 :     rv = CacheFileIOManager::DoomFileByKey(entryKey, callback);</span>
<span class="lineNum">    1816 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span><span class="lineCov">          1 :     return NS_OK;</span>
<a name="1819"><span class="lineNum">    1819 </span>            :   }</a>
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :   class Callback : public Runnable</span>
<a name="1822"><span class="lineNum">    1822 </span>            :   {</a>
<span class="lineNum">    1823 </span>            :   public:
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :     explicit Callback(nsICacheEntryDoomCallback* aCallback)</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :       : mozilla::Runnable(&quot;Callback&quot;)</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :       , mCallback(aCallback)</span>
<a name="1827"><span class="lineNum">    1827 </span>            :     {</a>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :     NS_IMETHOD Run() override</span>
<span class="lineNum">    1830 </span>            :     {
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :       mCallback-&gt;OnCacheEntryDoomed(NS_ERROR_NOT_AVAILABLE);</span>
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">    1833 </span>            :     }
<span class="lineNum">    1834 </span>            :     nsCOMPtr&lt;nsICacheEntryDoomCallback&gt; mCallback;
<span class="lineNum">    1835 </span>            :   };
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :   if (aCallback) {</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :     RefPtr&lt;Runnable&gt; callback = new Callback(aCallback);</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :     return NS_DispatchToMainThread(callback);</span>
<span class="lineNum">    1840 </span>            :   }
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1843 </span>            : }
<a name="1844"><span class="lineNum">    1844 </span>            : </a>
<span class="lineNum">    1845 </span>            : nsresult
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 : CacheStorageService::DoomStorageEntries(CacheStorage const* aStorage,</span>
<span class="lineNum">    1847 </span>            :                                         nsICacheEntryDoomCallback* aCallback)
<span class="lineNum">    1848 </span>            : {
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::DoomStorageEntries&quot;));</span>
<span class="lineNum">    1850 </span>            : 
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aStorage);</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   nsAutoCString contextKey;</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   CacheFileUtils::AppendKeyPrefix(aStorage-&gt;LoadInfo(), contextKey);</span>
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :   return DoomStorageEntries(contextKey, aStorage-&gt;LoadInfo(),</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :                             aStorage-&gt;WriteToDisk(), aStorage-&gt;Pinning(),</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :                             aCallback);</span>
<span class="lineNum">    1862 </span>            : }
<a name="1863"><span class="lineNum">    1863 </span>            : </a>
<span class="lineNum">    1864 </span>            : nsresult
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 : CacheStorageService::DoomStorageEntries(const nsACString&amp; aContextKey,</span>
<span class="lineNum">    1866 </span>            :                                         nsILoadContextInfo* aContext,
<span class="lineNum">    1867 </span>            :                                         bool aDiskStorage,
<span class="lineNum">    1868 </span>            :                                         bool aPinned,
<span class="lineNum">    1869 </span>            :                                         nsICacheEntryDoomCallback* aCallback)
<span class="lineNum">    1870 </span>            : {
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::DoomStorageEntries [context=%s]&quot;, aContextKey.BeginReading()));</span>
<span class="lineNum">    1872 </span>            : 
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :   mLock.AssertCurrentThreadOwns();</span>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(!mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :   nsAutoCString memoryStorageID(aContextKey);</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :   AppendMemoryStorageID(memoryStorageID);</span>
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :   if (aDiskStorage) {</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     LOG((&quot;  dooming disk+memory storage of %s&quot;, aContextKey.BeginReading()));</span>
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :     // Walk one by one and remove entries according their pin status
<span class="lineNum">    1884 </span>            :     CacheEntryTable *diskEntries, *memoryEntries;
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     if (sGlobalEntryTables-&gt;Get(aContextKey, &amp;diskEntries)) {</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :       sGlobalEntryTables-&gt;Get(memoryStorageID, &amp;memoryEntries);</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :       for (auto iter = diskEntries-&gt;Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :         auto entry = iter.Data();</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :         if (entry-&gt;DeferOrBypassRemovalOnPinStatus(aPinned)) {</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    1892 </span>            :         }
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :         if (memoryEntries) {</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :           RemoveExactEntry(memoryEntries, iter.Key(), entry, false);</span>
<span class="lineNum">    1896 </span>            :         }
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :         iter.Remove();</span>
<span class="lineNum">    1898 </span>            :       }
<span class="lineNum">    1899 </span>            :     }
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     if (aContext &amp;&amp; !aContext-&gt;IsPrivate()) {</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :       LOG((&quot;  dooming disk entries&quot;));</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :       CacheFileIOManager::EvictByContext(aContext, aPinned);</span>
<span class="lineNum">    1904 </span>            :     }
<span class="lineNum">    1905 </span>            :   } else {
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :     LOG((&quot;  dooming memory-only storage of %s&quot;, aContextKey.BeginReading()));</span>
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :     // Remove the memory entries table from the global tables.
<span class="lineNum">    1909 </span>            :     // Since we store memory entries also in the disk entries table
<span class="lineNum">    1910 </span>            :     // we need to remove the memory entries from the disk table one
<span class="lineNum">    1911 </span>            :     // by one manually.
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     nsAutoPtr&lt;CacheEntryTable&gt; memoryEntries;</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     sGlobalEntryTables-&gt;Remove(memoryStorageID, &amp;memoryEntries);</span>
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            :     CacheEntryTable* diskEntries;
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     if (memoryEntries &amp;&amp; sGlobalEntryTables-&gt;Get(aContextKey, &amp;diskEntries)) {</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :       for (auto iter = memoryEntries-&gt;Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :         auto entry = iter.Data();</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         RemoveExactEntry(diskEntries, iter.Key(), entry, false);</span>
<span class="lineNum">    1920 </span>            :       }
<span class="lineNum">    1921 </span>            :     }
<span class="lineNum">    1922 </span>            :   }
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            :   {
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :     mozilla::MutexAutoLock lock(mForcedValidEntriesLock);</span>
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :     if (aContext) {</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :       for (auto iter = mForcedValidEntries.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1929 </span>            :         bool matches;
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :         DebugOnly&lt;nsresult&gt; rv = CacheFileUtils::KeyMatchesLoadContextInfo(</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :           iter.Key(), aContext, &amp;matches);</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :         if (matches) {</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :           iter.Remove();</span>
<span class="lineNum">    1936 </span>            :         }
<span class="lineNum">    1937 </span>            :       }
<span class="lineNum">    1938 </span>            :     } else {
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :       mForcedValidEntries.Clear();</span>
<span class="lineNum">    1940 </span>            :     }
<span class="lineNum">    1941 </span>            :   }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            :   // An artificial callback.  This is a candidate for removal tho.  In the new
<span class="lineNum">    1944 </span>            :   // cache any 'doom' or 'evict' function ensures that the entry or entries
<span class="lineNum">    1945 </span>            :   // being doomed is/are not accessible after the function returns.  So there is
<span class="lineNum">    1946 </span>            :   // probably no need for a callback - has no meaning.  But for compatibility
<a name="1947"><span class="lineNum">    1947 </span>            :   // with the old cache that is still in the tree we keep the API similar to be</a>
<span class="lineNum">    1948 </span>            :   // able to make tests as well as other consumers work for now.
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :   class Callback : public Runnable</span>
<a name="1950"><span class="lineNum">    1950 </span>            :   {</a>
<span class="lineNum">    1951 </span>            :   public:
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     explicit Callback(nsICacheEntryDoomCallback* aCallback)</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :       : mozilla::Runnable(&quot;Callback&quot;)</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :       , mCallback(aCallback)</span>
<a name="1955"><span class="lineNum">    1955 </span>            :     {</a>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     NS_IMETHOD Run() override</span>
<span class="lineNum">    1958 </span>            :     {
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :       mCallback-&gt;OnCacheEntryDoomed(NS_OK);</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">    1961 </span>            :     }
<span class="lineNum">    1962 </span>            :     nsCOMPtr&lt;nsICacheEntryDoomCallback&gt; mCallback;
<span class="lineNum">    1963 </span>            :   };
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :   if (aCallback) {</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :     RefPtr&lt;Runnable&gt; callback = new Callback(aCallback);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     return NS_DispatchToMainThread(callback);</span>
<span class="lineNum">    1968 </span>            :   }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1971 </span>            : }
<a name="1972"><span class="lineNum">    1972 </span>            : </a>
<span class="lineNum">    1973 </span>            : nsresult
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 : CacheStorageService::WalkStorageEntries(CacheStorage const* aStorage,</span>
<span class="lineNum">    1975 </span>            :                                         bool aVisitEntries,
<span class="lineNum">    1976 </span>            :                                         nsICacheStorageVisitor* aVisitor)
<span class="lineNum">    1977 </span>            : {
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :   LOG((&quot;CacheStorageService::WalkStorageEntries [cb=%p, visitentries=%d]&quot;, aVisitor, aVisitEntries));</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :   NS_ENSURE_FALSE(mShutdown, NS_ERROR_NOT_INITIALIZED);</span>
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aStorage);</span>
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :   if (aStorage-&gt;WriteToDisk()) {</span>
<span class="lineNum">    1984 </span>            :     RefPtr&lt;WalkDiskCacheRunnable&gt; event =
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :       new WalkDiskCacheRunnable(aStorage-&gt;LoadInfo(), aVisitEntries, aVisitor);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :     return event-&gt;Walk();</span>
<span class="lineNum">    1987 </span>            :   }
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span>            :   RefPtr&lt;WalkMemoryCacheRunnable&gt; event =
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :     new WalkMemoryCacheRunnable(aStorage-&gt;LoadInfo(), aVisitEntries, aVisitor);</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :   return event-&gt;Walk();</span>
<span class="lineNum">    1992 </span>            : }
<a name="1993"><span class="lineNum">    1993 </span>            : </a>
<span class="lineNum">    1994 </span>            : void
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 : CacheStorageService::CacheFileDoomed(nsILoadContextInfo* aLoadContextInfo,</span>
<span class="lineNum">    1996 </span>            :                                      const nsACString &amp; aIdExtension,
<span class="lineNum">    1997 </span>            :                                      const nsACString &amp; aURISpec)
<span class="lineNum">    1998 </span>            : {
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :   nsAutoCString contextKey;</span>
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :   CacheFileUtils::AppendKeyPrefix(aLoadContextInfo, contextKey);</span>
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :   nsAutoCString entryKey;</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :   CacheEntry::HashingKey(EmptyCString(), aIdExtension, aURISpec, entryKey);</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :   mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :   if (mShutdown) {</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2009 </span>            :   }
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span>            :   CacheEntryTable* entries;
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheEntry&gt; entry;</span>
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :   if (sGlobalEntryTables-&gt;Get(contextKey, &amp;entries) &amp;&amp;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :       entries-&gt;Get(entryKey, getter_AddRefs(entry))) {</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     if (entry-&gt;IsFileDoomed()) {</span>
<span class="lineNum">    2017 </span>            :       // Need to remove under the lock to avoid possible race leading
<span class="lineNum">    2018 </span>            :       // to duplication of the entry per its key.
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :       RemoveExactEntry(entries, entryKey, entry, false);</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :       entry-&gt;DoomAlreadyRemoved();</span>
<span class="lineNum">    2021 </span>            :     }
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            :     // Entry found, but it's not the entry that has been found doomed
<span class="lineNum">    2024 </span>            :     // by the lower eviction layer.  Just leave everything unchanged.
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2026 </span>            :   }
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :   RemoveEntryForceValid(contextKey, entryKey);</span>
<span class="lineNum">    2029 </span>            : }
<a name="2030"><span class="lineNum">    2030 </span>            : </a>
<span class="lineNum">    2031 </span>            : bool
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 : CacheStorageService::GetCacheEntryInfo(nsILoadContextInfo* aLoadContextInfo,</span>
<span class="lineNum">    2033 </span>            :                                        const nsACString &amp; aIdExtension,
<span class="lineNum">    2034 </span>            :                                        const nsACString &amp; aURISpec,
<span class="lineNum">    2035 </span>            :                                        EntryInfoCallback *aCallback)
<span class="lineNum">    2036 </span>            : {
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :   nsAutoCString contextKey;</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :   CacheFileUtils::AppendKeyPrefix(aLoadContextInfo, contextKey);</span>
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :   nsAutoCString entryKey;</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :   CacheEntry::HashingKey(EmptyCString(), aIdExtension, aURISpec, entryKey);</span>
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheEntry&gt; entry;</span>
<span class="lineNum">    2044 </span>            :   {
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :     mozilla::MutexAutoLock lock(mLock);</span>
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     if (mShutdown) {</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2049 </span>            :     }
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :     CacheEntryTable* entries;
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :     if (!sGlobalEntryTables-&gt;Get(contextKey, &amp;entries)) {</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2054 </span>            :     }
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :     if (!entries-&gt;Get(entryKey, getter_AddRefs(entry))) {</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2058 </span>            :     }
<span class="lineNum">    2059 </span>            :   }
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :   GetCacheEntryInfo(entry, aCallback);</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2063 </span>            : }
<span class="lineNum">    2064 </span>            : 
<a name="2065"><span class="lineNum">    2065 </span>            : // static</a>
<span class="lineNum">    2066 </span>            : void
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 : CacheStorageService::GetCacheEntryInfo(CacheEntry* aEntry,</span>
<span class="lineNum">    2068 </span>            :                                        EntryInfoCallback *aCallback)
<span class="lineNum">    2069 </span>            : {
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :   nsCString const uriSpec = aEntry-&gt;GetURI();</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :   nsCString const enhanceId = aEntry-&gt;GetEnhanceID();</span>
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :   nsAutoCString entryKey;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :   aEntry-&gt;HashingKeyWithStorage(entryKey);</span>
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span>            :   nsCOMPtr&lt;nsILoadContextInfo&gt; info =
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     CacheFileUtils::ParseKey(entryKey);</span>
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :   uint32_t dataSize;
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :   if (NS_FAILED(aEntry-&gt;GetStorageDataSize(&amp;dataSize))) {</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :     dataSize = 0;</span>
<span class="lineNum">    2082 </span>            :   }
<span class="lineNum">    2083 </span>            :   int32_t fetchCount;
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :   if (NS_FAILED(aEntry-&gt;GetFetchCount(&amp;fetchCount))) {</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     fetchCount = 0;</span>
<span class="lineNum">    2086 </span>            :   }
<span class="lineNum">    2087 </span>            :   uint32_t lastModified;
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :   if (NS_FAILED(aEntry-&gt;GetLastModified(&amp;lastModified))) {</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     lastModified = 0;</span>
<span class="lineNum">    2090 </span>            :   }
<span class="lineNum">    2091 </span>            :   uint32_t expirationTime;
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :   if (NS_FAILED(aEntry-&gt;GetExpirationTime(&amp;expirationTime))) {</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :     expirationTime = 0;</span>
<span class="lineNum">    2094 </span>            :   }
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :   aCallback-&gt;OnEntryInfo(uriSpec, enhanceId, dataSize,</span>
<span class="lineNum">    2097 </span>            :                          fetchCount, lastModified, expirationTime,
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                          aEntry-&gt;IsPinned(), info);</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 : }</span>
<a name="2100"><span class="lineNum">    2100 </span>            : </a>
<span class="lineNum">    2101 </span>            : // static
<span class="lineNum">    2102 </span><span class="lineCov">          5 : uint32_t CacheStorageService::CacheQueueSize(bool highPriority)</span>
<span class="lineNum">    2103 </span>            : {
<span class="lineNum">    2104 </span><span class="lineCov">         10 :   RefPtr&lt;CacheIOThread&gt; thread = CacheFileIOManager::IOThread();</span>
<span class="lineNum">    2105 </span><span class="lineCov">          5 :   MOZ_ASSERT(thread);</span>
<span class="lineNum">    2106 </span><span class="lineCov">         10 :   return thread-&gt;QueueSize(highPriority);</span>
<span class="lineNum">    2107 </span>            : }
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span>            : // Telemetry collection
<span class="lineNum">    2110 </span>            : 
<a name="2111"><span class="lineNum">    2111 </span>            : namespace {</a>
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">          5 : bool TelemetryEntryKey(CacheEntry const* entry, nsAutoCString&amp; key)</span>
<span class="lineNum">    2114 </span>            : {
<span class="lineNum">    2115 </span><span class="lineCov">         10 :   nsAutoCString entryKey;</span>
<span class="lineNum">    2116 </span><span class="lineCov">          5 :   nsresult rv = entry-&gt;HashingKey(entryKey);</span>
<span class="lineNum">    2117 </span><span class="lineCov">          5 :   if (NS_FAILED(rv))</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span><span class="lineCov">          5 :   if (entry-&gt;GetStorageID().IsEmpty()) {</span>
<span class="lineNum">    2121 </span>            :     // Hopefully this will be const-copied, saves some memory
<span class="lineNum">    2122 </span><span class="lineCov">          5 :     key = entryKey;</span>
<span class="lineNum">    2123 </span>            :   } else {
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :     key.Assign(entry-&gt;GetStorageID());</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     key.Append(':');</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :     key.Append(entryKey);</span>
<span class="lineNum">    2127 </span>            :   }
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span><span class="lineCov">          5 :   return true;</span>
<span class="lineNum">    2130 </span>            : }
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            : } // namespace
<a name="2133"><span class="lineNum">    2133 </span>            : </a>
<span class="lineNum">    2134 </span>            : void
<span class="lineNum">    2135 </span><span class="lineCov">          5 : CacheStorageService::TelemetryPrune(TimeStamp &amp;now)</span>
<span class="lineNum">    2136 </span>            : {
<span class="lineNum">    2137 </span><span class="lineCov">          5 :   static TimeDuration const oneMinute = TimeDuration::FromSeconds(60);</span>
<span class="lineNum">    2138 </span><span class="lineCov">          5 :   static TimeStamp dontPruneUntil = now + oneMinute;</span>
<span class="lineNum">    2139 </span><span class="lineCov">          5 :   if (now &lt; dontPruneUntil)</span>
<span class="lineNum">    2140 </span><span class="lineCov">          5 :     return;</span>
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :   static TimeDuration const fifteenMinutes = TimeDuration::FromSeconds(900);</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   for (auto iter = mPurgeTimeStamps.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :     if (now - iter.Data() &gt; fifteenMinutes) {</span>
<span class="lineNum">    2145 </span>            :       // We are not interested in resurrection of entries after 15 minutes
<span class="lineNum">    2146 </span>            :       // of time.  This is also the limit for the telemetry.
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :       iter.Remove();</span>
<span class="lineNum">    2148 </span>            :     }
<span class="lineNum">    2149 </span>            :   }
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :   dontPruneUntil = now + oneMinute;</span>
<span class="lineNum">    2151 </span>            : }
<a name="2152"><span class="lineNum">    2152 </span>            : </a>
<span class="lineNum">    2153 </span>            : void
<span class="lineNum">    2154 </span><span class="lineCov">          5 : CacheStorageService::TelemetryRecordEntryCreation(CacheEntry const* entry)</span>
<span class="lineNum">    2155 </span>            : {
<span class="lineNum">    2156 </span><span class="lineCov">          5 :   MOZ_ASSERT(CacheStorageService::IsOnManagementThread());</span>
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span><span class="lineCov">          5 :   nsAutoCString key;</span>
<span class="lineNum">    2159 </span><span class="lineCov">          5 :   if (!TelemetryEntryKey(entry, key))</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span><span class="lineCov">          5 :   TimeStamp now = TimeStamp::NowLoRes();</span>
<span class="lineNum">    2163 </span><span class="lineCov">          5 :   TelemetryPrune(now);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            :   // When an entry is craeted (registered actually) we check if there is
<span class="lineNum">    2166 </span>            :   // a timestamp marked when this very same cache entry has been removed
<span class="lineNum">    2167 </span>            :   // (deregistered) because of over-memory-limit purging.  If there is such
<span class="lineNum">    2168 </span>            :   // a timestamp found accumulate telemetry on how long the entry was away.
<span class="lineNum">    2169 </span><span class="lineCov">          5 :   TimeStamp timeStamp;</span>
<span class="lineNum">    2170 </span><span class="lineCov">          5 :   if (!mPurgeTimeStamps.Get(key, &amp;timeStamp))</span>
<span class="lineNum">    2171 </span><span class="lineCov">          5 :     return;</span>
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :   mPurgeTimeStamps.Remove(key);</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :   Telemetry::AccumulateTimeDelta(Telemetry::HTTP_CACHE_ENTRY_RELOAD_TIME,</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :                                  timeStamp, TimeStamp::NowLoRes());</span>
<span class="lineNum">    2177 </span>            : }
<a name="2178"><span class="lineNum">    2178 </span>            : </a>
<span class="lineNum">    2179 </span>            : void
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 : CacheStorageService::TelemetryRecordEntryRemoval(CacheEntry const* entry)</span>
<span class="lineNum">    2181 </span>            : {
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CacheStorageService::IsOnManagementThread());</span>
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span>            :   // Doomed entries must not be considered, we are only interested in purged
<span class="lineNum">    2185 </span>            :   // entries.  Note that the mIsDoomed flag is always set before deregistration
<span class="lineNum">    2186 </span>            :   // happens.
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   if (entry-&gt;IsDoomed())</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :   nsAutoCString key;</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :   if (!TelemetryEntryKey(entry, key))</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            :   // When an entry is removed (deregistered actually) we put a timestamp for this
<span class="lineNum">    2195 </span>            :   // entry to the hashtable so that when the entry is created (registered) again
<span class="lineNum">    2196 </span>            :   // we know how long it was away.  Also accumulate number of AsyncOpen calls on
<span class="lineNum">    2197 </span>            :   // the entry, this tells us how efficiently the pool actually works.
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :   TimeStamp now = TimeStamp::NowLoRes();</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :   TelemetryPrune(now);</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :   mPurgeTimeStamps.Put(key, now);</span>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :   Telemetry::Accumulate(Telemetry::HTTP_CACHE_ENTRY_REUSE_COUNT, entry-&gt;UseCount());</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :   Telemetry::AccumulateTimeDelta(Telemetry::HTTP_CACHE_ENTRY_ALIVE_TIME,</span>
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :                                  entry-&gt;LoadStart(), TimeStamp::NowLoRes());</span>
<span class="lineNum">    2206 </span>            : }
<span class="lineNum">    2207 </span>            : 
<span class="lineNum">    2208 </span>            : // nsIMemoryReporter
<a name="2209"><span class="lineNum">    2209 </span>            : </a>
<span class="lineNum">    2210 </span>            : size_t
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 : CacheStorageService::SizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const</span>
<span class="lineNum">    2212 </span>            : {
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :   CacheStorageService::Self()-&gt;Lock().AssertCurrentThreadOwns();</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :   size_t n = 0;</span>
<span class="lineNum">    2216 </span>            :   // The elemets are referenced by sGlobalEntryTables and are reported from there
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :   n += Pool(true).mFrecencyArray.ShallowSizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :   n += Pool(true).mExpirationArray.ShallowSizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :   n += Pool(false).mFrecencyArray.ShallowSizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :   n += Pool(false).mExpirationArray.ShallowSizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    2221 </span>            :   // Entries reported manually in CacheStorageService::CollectReports callback
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :   if (sGlobalEntryTables) {</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     n += sGlobalEntryTables-&gt;ShallowSizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    2224 </span>            :   }
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :   return n;</span>
<span class="lineNum">    2227 </span>            : }
<a name="2228"><span class="lineNum">    2228 </span>            : </a>
<span class="lineNum">    2229 </span>            : size_t
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 : CacheStorageService::SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const</span>
<span class="lineNum">    2231 </span>            : {
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   return mallocSizeOf(this) + SizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    2233 </span>            : }
<a name="2234"><span class="lineNum">    2234 </span>            : </a>
<span class="lineNum">    2235 </span>            : NS_IMETHODIMP
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 : CacheStorageService::CollectReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">    2237 </span>            :                                     nsISupports* aData, bool aAnonymize)
<span class="lineNum">    2238 </span>            : {
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :   MOZ_COLLECT_REPORT(</span>
<span class="lineNum">    2240 </span>            :     &quot;explicit/network/cache2/io&quot;, KIND_HEAP, UNITS_BYTES,
<span class="lineNum">    2241 </span>            :     CacheFileIOManager::SizeOfIncludingThis(MallocSizeOf),
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :     &quot;Memory used by the cache IO manager.&quot;);</span>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :   MOZ_COLLECT_REPORT(</span>
<span class="lineNum">    2245 </span>            :     &quot;explicit/network/cache2/index&quot;, KIND_HEAP, UNITS_BYTES,
<span class="lineNum">    2246 </span>            :     CacheIndex::SizeOfIncludingThis(MallocSizeOf),
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :     &quot;Memory used by the cache index.&quot;);</span>
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   MutexAutoLock lock(mLock);</span>
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :   // Report the service instance, this doesn't report entries, done lower
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   MOZ_COLLECT_REPORT(</span>
<span class="lineNum">    2253 </span>            :     &quot;explicit/network/cache2/service&quot;, KIND_HEAP, UNITS_BYTES,
<span class="lineNum">    2254 </span>            :     SizeOfIncludingThis(MallocSizeOf),
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :     &quot;Memory used by the cache storage service.&quot;);</span>
<span class="lineNum">    2256 </span>            : 
<span class="lineNum">    2257 </span>            :   // Report all entries, each storage separately (by the context key)
<span class="lineNum">    2258 </span>            :   //
<span class="lineNum">    2259 </span>            :   // References are:
<span class="lineNum">    2260 </span>            :   // sGlobalEntryTables to N CacheEntryTable
<span class="lineNum">    2261 </span>            :   // CacheEntryTable to N CacheEntry
<span class="lineNum">    2262 </span>            :   // CacheEntry to 1 CacheFile
<span class="lineNum">    2263 </span>            :   // CacheFile to
<span class="lineNum">    2264 </span>            :   //   N CacheFileChunk (keeping the actual data)
<span class="lineNum">    2265 </span>            :   //   1 CacheFileMetadata (keeping http headers etc.)
<span class="lineNum">    2266 </span>            :   //   1 CacheFileOutputStream
<span class="lineNum">    2267 </span>            :   //   N CacheFileInputStream
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :   if (sGlobalEntryTables) {</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :     for (auto iter1 = sGlobalEntryTables-&gt;Iter(); !iter1.Done(); iter1.Next()) {</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :       CacheStorageService::Self()-&gt;Lock().AssertCurrentThreadOwns();</span>
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :       CacheEntryTable* table = iter1.UserData();</span>
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       size_t size = 0;</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :       mozilla::MallocSizeOf mallocSizeOf = CacheStorageService::MallocSizeOf;</span>
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :       size += table-&gt;ShallowSizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :       for (auto iter2 = table-&gt;Iter(); !iter2.Done(); iter2.Next()) {</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :         size += iter2.Key().SizeOfExcludingThisIfUnshared(mallocSizeOf);</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span>            :         // Bypass memory-only entries, those will be reported when iterating the
<span class="lineNum">    2282 </span>            :         // memory only table. Memory-only entries are stored in both ALL_ENTRIES
<span class="lineNum">    2283 </span>            :         // and MEMORY_ONLY hashtables.
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :         RefPtr&lt;mozilla::net::CacheEntry&gt; const&amp; entry = iter2.Data();</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :         if (table-&gt;Type() == CacheEntryTable::MEMORY_ONLY ||</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :             entry-&gt;IsUsingDisk()) {</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :           size += entry-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    2288 </span>            :         }
<span class="lineNum">    2289 </span>            :       }
<span class="lineNum">    2290 </span>            : 
<span class="lineNum">    2291 </span>            :       // These key names are not privacy-sensitive.
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :       aHandleReport-&gt;Callback(</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         EmptyCString(),</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         nsPrintfCString(&quot;explicit/network/cache2/%s-storage(%s)&quot;,</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :           table-&gt;Type() == CacheEntryTable::MEMORY_ONLY ? &quot;memory&quot; : &quot;disk&quot;,</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :           iter1.Key().BeginReading()),</span>
<span class="lineNum">    2297 </span>            :         nsIMemoryReporter::KIND_HEAP, nsIMemoryReporter::UNITS_BYTES, size,
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :         NS_LITERAL_CSTRING(&quot;Memory used by the cache storage.&quot;),</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :         aData);</span>
<span class="lineNum">    2300 </span>            :     }
<span class="lineNum">    2301 </span>            :   }
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    2304 </span>            : }
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            : // nsICacheTesting
<a name="2307"><span class="lineNum">    2307 </span>            : </a>
<span class="lineNum">    2308 </span>            : NS_IMETHODIMP
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 : CacheStorageService::IOThreadSuspender::Run()</span>
<span class="lineNum">    2310 </span>            : {
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :   MonitorAutoLock mon(mMon);</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :   while (!mSignaled) {</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :     mon.Wait();</span>
<span class="lineNum">    2314 </span>            :   }
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    2316 </span>            : }
<a name="2317"><span class="lineNum">    2317 </span>            : </a>
<span class="lineNum">    2318 </span>            : void
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 : CacheStorageService::IOThreadSuspender::Notify()</span>
<span class="lineNum">    2320 </span>            : {
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :   MonitorAutoLock mon(mMon);</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :   mSignaled = true;</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :   mon.Notify();</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 : }</span>
<a name="2325"><span class="lineNum">    2325 </span>            : </a>
<span class="lineNum">    2326 </span>            : NS_IMETHODIMP
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 : CacheStorageService::SuspendCacheIOThread(uint32_t aLevel)</span>
<span class="lineNum">    2328 </span>            : {
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheIOThread&gt; thread = CacheFileIOManager::IOThread();</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :   if (!thread) {</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">    2332 </span>            :   }
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mActiveIOSuspender);</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :   mActiveIOSuspender = new IOThreadSuspender();</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :   return thread-&gt;Dispatch(mActiveIOSuspender, aLevel);</span>
<span class="lineNum">    2337 </span>            : }
<a name="2338"><span class="lineNum">    2338 </span>            : </a>
<span class="lineNum">    2339 </span>            : NS_IMETHODIMP
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 : CacheStorageService::ResumeCacheIOThread()</span>
<span class="lineNum">    2341 </span>            : {
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mActiveIOSuspender);</span>
<span class="lineNum">    2343 </span>            : 
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :   RefPtr&lt;IOThreadSuspender&gt; suspender;</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   suspender.swap(mActiveIOSuspender);</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :   suspender-&gt;Notify();</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    2348 </span>            : }
<a name="2349"><span class="lineNum">    2349 </span>            : </a>
<span class="lineNum">    2350 </span>            : NS_IMETHODIMP
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 : CacheStorageService::Flush(nsIObserver* aObserver)</span>
<span class="lineNum">    2352 </span>            : {
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :   RefPtr&lt;CacheIOThread&gt; thread = CacheFileIOManager::IOThread();</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :   if (!thread) {</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">    2356 </span>            :   }
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span>            :   nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :     mozilla::services::GetObserverService();</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :   if (!observerService) {</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :     return NS_ERROR_NOT_AVAILABLE;</span>
<span class="lineNum">    2362 </span>            :   }
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span>            :   // Adding as weak, the consumer is responsible to keep the reference
<span class="lineNum">    2365 </span>            :   // until notified.
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :   observerService-&gt;AddObserver(aObserver, &quot;cacheservice:purge-memory-pools&quot;, false);</span>
<span class="lineNum">    2367 </span>            : 
<span class="lineNum">    2368 </span>            :   // This runnable will do the purging and when done, notifies the above observer.
<span class="lineNum">    2369 </span>            :   // We dispatch it to the CLOSE level, so all data writes scheduled up to this time
<span class="lineNum">    2370 </span>            :   // will be done before this purging happens.
<span class="lineNum">    2371 </span>            :   RefPtr&lt;CacheStorageService::PurgeFromMemoryRunnable&gt; r =
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :     new CacheStorageService::PurgeFromMemoryRunnable(this, CacheEntry::PURGE_WHOLE);</span>
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :   return thread-&gt;Dispatch(r, CacheIOThread::WRITE);</span>
<span class="lineNum">    2375 </span>            : }
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            : } // namespace net
<span class="lineNum">    2378 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

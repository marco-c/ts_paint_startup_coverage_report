<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/bindings/DOMJSClass.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dom/bindings</a> - DOMJSClass.h<span style="font-size: 80%;"> (source / <a href="DOMJSClass.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntry">56</td>
            <td class="headerCovTableEntryHi">91.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntry">48</td>
            <td class="headerCovTableEntryHi">95.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
<span class="lineNum">       5 </span>            :  * You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef mozilla_dom_DOMJSClass_h
<span class="lineNum">       8 </span>            : #define mozilla_dom_DOMJSClass_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;jsfriendapi.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;mozilla/dom/PrototypeList.h&quot; // auto-generated
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;mozilla/dom/JSSlots.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : class nsCycleCollectionParticipant;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : // All DOM globals must have a slot at DOM_PROTOTYPE_SLOT.
<span class="lineNum">      22 </span>            : #define DOM_PROTOTYPE_SLOT JSCLASS_GLOBAL_SLOT_COUNT
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : // Keep this count up to date with any extra global slots added above.
<span class="lineNum">      25 </span>            : #define DOM_GLOBAL_SLOTS 1
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : // We use these flag bits for the new bindings.
<span class="lineNum">      28 </span>            : #define JSCLASS_DOM_GLOBAL JSCLASS_USERBIT1
<span class="lineNum">      29 </span>            : #define JSCLASS_IS_DOMIFACEANDPROTOJSCLASS JSCLASS_USERBIT2
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : namespace mozilla {
<span class="lineNum">      32 </span>            : namespace dom {
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : /**
<span class="lineNum">      35 </span>            :  * Returns true if code running in the given JSContext is allowed to access
<span class="lineNum">      36 </span>            :  * [SecureContext] API on the given JSObject.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  * [SecureContext] API exposure is restricted to use by code in a Secure
<span class="lineNum">      39 </span>            :  * Contexts:
<span class="lineNum">      40 </span>            :  *
<span class="lineNum">      41 </span>            :  *   https://w3c.github.io/webappsec-secure-contexts/
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * Since we want [SecureContext] exposure to depend on the privileges of the
<span class="lineNum">      44 </span>            :  * running code (rather than the privileges of an object's creator), this
<span class="lineNum">      45 </span>            :  * function checks to see whether the given JSContext's Compartment is flagged
<span class="lineNum">      46 </span>            :  * as a Secure Context.  That allows us to make sure that system principal code
<span class="lineNum">      47 </span>            :  * (which is marked as a Secure Context) can access Secure Context API on an
<span class="lineNum">      48 </span>            :  * object in a different compartment, regardless of whether the other
<span class="lineNum">      49 </span>            :  * compartment is a Secure Context or not.
<span class="lineNum">      50 </span>            :  *
<span class="lineNum">      51 </span>            :  * Checking the JSContext's Compartment doesn't work for expanded principal
<span class="lineNum">      52 </span>            :  * globals accessing a Secure Context web page though (e.g. those used by frame
<span class="lineNum">      53 </span>            :  * scripts).  To handle that we fall back to checking whether the JSObject came
<span class="lineNum">      54 </span>            :  * from a Secure Context.
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  * Note: We'd prefer this function to live in BindingUtils.h, but we need to
<span class="lineNum">      57 </span>            :  * call it in this header, and BindingUtils.h includes us (i.e. we'd have a
<span class="lineNum">      58 </span>            :  * circular dependency between headers if it lived there).
<a name="59"><span class="lineNum">      59 </span>            :  */</a>
<span class="lineNum">      60 </span>            : inline bool
<span class="lineNum">      61 </span><span class="lineCov">          4 : IsSecureContextOrObjectIsFromSecureContext(JSContext* aCx, JSObject* aObj)</span>
<span class="lineNum">      62 </span>            : {
<span class="lineNum">      63 </span><span class="lineCov">          4 :   return JS::CompartmentCreationOptionsRef(js::GetContextCompartment(aCx)).secureContext() ||</span>
<span class="lineNum">      64 </span><span class="lineCov">          4 :          JS::CompartmentCreationOptionsRef(js::GetObjectCompartment(aObj)).secureContext();</span>
<span class="lineNum">      65 </span>            : }
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : typedef bool
<span class="lineNum">      68 </span>            : (* ResolveOwnProperty)(JSContext* cx, JS::Handle&lt;JSObject*&gt; wrapper,
<span class="lineNum">      69 </span>            :                        JS::Handle&lt;JSObject*&gt; obj, JS::Handle&lt;jsid&gt; id,
<span class="lineNum">      70 </span>            :                        JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : typedef bool
<span class="lineNum">      73 </span>            : (* EnumerateOwnProperties)(JSContext* cx, JS::Handle&lt;JSObject*&gt; wrapper,
<span class="lineNum">      74 </span>            :                            JS::Handle&lt;JSObject*&gt; obj,
<span class="lineNum">      75 </span>            :                            JS::AutoIdVector&amp; props);
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : typedef bool
<span class="lineNum">      78 </span>            : (* DeleteNamedProperty)(JSContext* cx, JS::Handle&lt;JSObject*&gt; wrapper,
<span class="lineNum">      79 </span>            :                         JS::Handle&lt;JSObject*&gt; obj, JS::Handle&lt;jsid&gt; id,
<span class="lineNum">      80 </span>            :                         JS::ObjectOpResult&amp; opresult);
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : // Returns true if the given global is of a type whose bit is set in
<span class="lineNum">      83 </span>            : // aNonExposedGlobals.
<span class="lineNum">      84 </span>            : bool
<span class="lineNum">      85 </span>            : IsNonExposedGlobal(JSContext* aCx, JSObject* aGlobal,
<span class="lineNum">      86 </span>            :                    uint32_t aNonExposedGlobals);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : struct ConstantSpec
<span class="lineNum">      89 </span>            : {
<span class="lineNum">      90 </span>            :   const char* name;
<span class="lineNum">      91 </span>            :   JS::Value value;
<span class="lineNum">      92 </span>            : };
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : typedef bool (*PropertyEnabled)(JSContext* cx, JSObject* global);
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : namespace GlobalNames {
<span class="lineNum">      97 </span>            : // The names of our possible globals.  These are the names of the actual
<span class="lineNum">      98 </span>            : // interfaces, not of the global names used to refer to them in IDL [Exposed]
<span class="lineNum">      99 </span>            : // annotations.
<span class="lineNum">     100 </span>            : static const uint32_t Window = 1u &lt;&lt; 0;
<span class="lineNum">     101 </span>            : static const uint32_t BackstagePass = 1u &lt;&lt; 1;
<span class="lineNum">     102 </span>            : static const uint32_t DedicatedWorkerGlobalScope = 1u &lt;&lt; 2;
<span class="lineNum">     103 </span>            : static const uint32_t SharedWorkerGlobalScope = 1u &lt;&lt; 3;
<span class="lineNum">     104 </span>            : static const uint32_t ServiceWorkerGlobalScope = 1u &lt;&lt; 4;
<span class="lineNum">     105 </span>            : static const uint32_t WorkerDebuggerGlobalScope = 1u &lt;&lt; 5;
<span class="lineNum">     106 </span>            : static const uint32_t WorkletGlobalScope = 1u &lt;&lt; 6;
<span class="lineNum">     107 </span>            : } // namespace GlobalNames
<a name="108"><span class="lineNum">     108 </span>            : </a>
<span class="lineNum">     109 </span>            : struct PrefableDisablers {
<span class="lineNum">     110 </span><span class="lineCov">        629 :   inline bool isEnabled(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj) const {</span>
<span class="lineNum">     111 </span>            :     // Reading &quot;enabled&quot; on a worker thread is technically undefined behavior,
<span class="lineNum">     112 </span>            :     // because it's written only on main threads, with no barriers of any sort.
<span class="lineNum">     113 </span>            :     // So we want to avoid doing that.  But we don't particularly want to make
<span class="lineNum">     114 </span>            :     // expensive NS_IsMainThread calls here.
<span class="lineNum">     115 </span>            :     //
<span class="lineNum">     116 </span>            :     // The good news is that &quot;enabled&quot; is only written for things that have a
<span class="lineNum">     117 </span>            :     // Pref annotation, and such things can never be exposed on non-Window
<span class="lineNum">     118 </span>            :     // globals; our IDL parser enforces that.  So as long as we check our
<span class="lineNum">     119 </span>            :     // exposure set before checking &quot;enabled&quot; we will be ok.
<span class="lineNum">     120 </span><span class="lineCov">        768 :     if (nonExposedGlobals &amp;&amp;</span>
<span class="lineNum">     121 </span><span class="lineCov">        139 :         IsNonExposedGlobal(cx, js::GetGlobalForObjectCrossCompartment(obj),</span>
<span class="lineNum">     122 </span><span class="lineCov">        139 :                            nonExposedGlobals)) {</span>
<span class="lineNum">     123 </span><span class="lineCov">         14 :       return false;</span>
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span><span class="lineCov">        615 :     if (!enabled) {</span>
<span class="lineNum">     126 </span><span class="lineCov">         53 :       return false;</span>
<span class="lineNum">     127 </span>            :     }
<span class="lineNum">     128 </span><span class="lineCov">        562 :     if (secureContext &amp;&amp; !IsSecureContextOrObjectIsFromSecureContext(cx, obj)) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     130 </span>            :     }
<span class="lineNum">     131 </span><span class="lineCov">        894 :     if (enabledFunc &amp;&amp;</span>
<span class="lineNum">     132 </span><span class="lineCov">        332 :         !enabledFunc(cx, js::GetGlobalForObjectCrossCompartment(obj))) {</span>
<span class="lineNum">     133 </span><span class="lineCov">        162 :       return false;</span>
<span class="lineNum">     134 </span>            :     }
<span class="lineNum">     135 </span><span class="lineCov">        400 :     return true;</span>
<span class="lineNum">     136 </span>            :   }
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // A boolean indicating whether this set of specs is enabled. Not const
<span class="lineNum">     139 </span>            :   // because it will change at runtime if the corresponding pref is changed.
<span class="lineNum">     140 </span>            :   bool enabled;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   // A boolean indicating whether a Secure Context is required.
<span class="lineNum">     143 </span>            :   const bool secureContext;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   // Bitmask of global names that we should not be exposed in.
<span class="lineNum">     146 </span>            :   const uint16_t nonExposedGlobals;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :   // A function pointer to a function that can say the property is disabled
<span class="lineNum">     149 </span>            :   // even if &quot;enabled&quot; is set to true.  If the pointer is null the value of
<span class="lineNum">     150 </span>            :   // &quot;enabled&quot; is used as-is.
<span class="lineNum">     151 </span>            :   const PropertyEnabled enabledFunc;
<span class="lineNum">     152 </span>            : };
<span class="lineNum">     153 </span>            : 
<a name="154"><span class="lineNum">     154 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     155 </span>            : struct Prefable {
<span class="lineNum">     156 </span><span class="lineCov">       2083 :   inline bool isEnabled(JSContext* cx, JS::Handle&lt;JSObject*&gt; obj) const {</span>
<span class="lineNum">     157 </span><span class="lineCov">       2083 :     if (MOZ_LIKELY(!disablers)) {</span>
<span class="lineNum">     158 </span><span class="lineCov">       1454 :       return true;</span>
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span><span class="lineCov">        629 :     return disablers-&gt;isEnabled(cx, obj);</span>
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   // Things that can disable this set of specs. |nullptr| means &quot;cannot be
<span class="lineNum">     164 </span>            :   // disabled&quot;.
<span class="lineNum">     165 </span>            :   PrefableDisablers* const disablers;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :   // Array of specs, terminated in whatever way is customary for T.
<span class="lineNum">     168 </span>            :   // Null to indicate a end-of-array for Prefable, when such an
<span class="lineNum">     169 </span>            :   // indicator is needed.
<span class="lineNum">     170 </span>            :   const T* const specs;
<span class="lineNum">     171 </span>            : };
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : enum PropertyType {
<span class="lineNum">     174 </span>            :   eStaticMethod,
<span class="lineNum">     175 </span>            :   eStaticAttribute,
<span class="lineNum">     176 </span>            :   eMethod,
<span class="lineNum">     177 </span>            :   eAttribute,
<span class="lineNum">     178 </span>            :   eUnforgeableMethod,
<span class="lineNum">     179 </span>            :   eUnforgeableAttribute,
<span class="lineNum">     180 </span>            :   eConstant,
<span class="lineNum">     181 </span>            :   ePropertyTypeCount
<span class="lineNum">     182 </span>            : };
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : #define NUM_BITS_PROPERTY_INFO_TYPE        3
<span class="lineNum">     185 </span>            : #define NUM_BITS_PROPERTY_INFO_PREF_INDEX 13
<span class="lineNum">     186 </span>            : #define NUM_BITS_PROPERTY_INFO_SPEC_INDEX 16
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : struct PropertyInfo {
<span class="lineNum">     189 </span>            :   jsid id;
<span class="lineNum">     190 </span>            :   // One of PropertyType, will be used for accessing the corresponding Duo in
<span class="lineNum">     191 </span>            :   // NativePropertiesN.duos[].
<span class="lineNum">     192 </span>            :   uint32_t type: NUM_BITS_PROPERTY_INFO_TYPE;
<span class="lineNum">     193 </span>            :   // The index to the corresponding Preable in Duo.mPrefables[].
<span class="lineNum">     194 </span>            :   uint32_t prefIndex: NUM_BITS_PROPERTY_INFO_PREF_INDEX;
<span class="lineNum">     195 </span>            :   // The index to the corresponding spec in Duo.mPrefables[prefIndex].specs[].
<span class="lineNum">     196 </span>            :   uint32_t specIndex: NUM_BITS_PROPERTY_INFO_SPEC_INDEX;
<span class="lineNum">     197 </span>            : };
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : static_assert(ePropertyTypeCount &lt;= 1ull &lt;&lt; NUM_BITS_PROPERTY_INFO_TYPE,
<span class="lineNum">     200 </span>            :     &quot;We have property type count that is &gt; (1 &lt;&lt; NUM_BITS_PROPERTY_INFO_TYPE)&quot;);
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : // Conceptually, NativeProperties has seven (Prefable&lt;T&gt;*, PropertyInfo*) duos
<span class="lineNum">     203 </span>            : // (where T is one of JSFunctionSpec, JSPropertySpec, or ConstantSpec), one for
<span class="lineNum">     204 </span>            : // each of: static methods and attributes, methods and attributes, unforgeable
<span class="lineNum">     205 </span>            : // methods and attributes, and constants.
<span class="lineNum">     206 </span>            : //
<span class="lineNum">     207 </span>            : // That's 14 pointers, but in most instances most of the duos are all null, and
<span class="lineNum">     208 </span>            : // there are many instances. To save space we use a variable-length type,
<span class="lineNum">     209 </span>            : // NativePropertiesN&lt;N&gt;, to hold the data and getters to access it. It has N
<span class="lineNum">     210 </span>            : // actual duos (stored in duos[]), plus four bits for each of the 7 possible
<span class="lineNum">     211 </span>            : // duos: 1 bit that states if that duo is present, and 3 that state that duo's
<span class="lineNum">     212 </span>            : // offset (if present) in duos[].
<span class="lineNum">     213 </span>            : //
<span class="lineNum">     214 </span>            : // All duo accesses should be done via the getters, which contain assertions
<span class="lineNum">     215 </span>            : // that check we don't overrun the end of the struct. (The duo data members are
<span class="lineNum">     216 </span>            : // public only so they can be statically initialized.) These assertions should
<span class="lineNum">     217 </span>            : // never fail so long as (a) accesses to the variable-length part are guarded by
<span class="lineNum">     218 </span>            : // appropriate Has*() calls, and (b) all instances are well-formed, i.e. the
<span class="lineNum">     219 </span>            : // value of N matches the number of mHas* members that are true.
<span class="lineNum">     220 </span>            : //
<span class="lineNum">     221 </span>            : // We store all the property ids a NativePropertiesN owns in a single array of
<span class="lineNum">     222 </span>            : // PropertyInfo structs. Each struct contains an id and the information needed
<span class="lineNum">     223 </span>            : // to find the corresponding Prefable for the enabled check, as well as the
<span class="lineNum">     224 </span>            : // information needed to find the correct property descriptor in the
<span class="lineNum">     225 </span>            : // Prefable. We also store an array of indices into the PropertyInfo array,
<span class="lineNum">     226 </span>            : // sorted by bits of the corresponding jsid. Given a jsid, this allows us to
<span class="lineNum">     227 </span>            : // binary search for the index of the corresponding PropertyInfo, if any.
<span class="lineNum">     228 </span>            : //
<span class="lineNum">     229 </span>            : // Finally, we define a typedef of NativePropertiesN&lt;7&gt;, NativeProperties, which
<span class="lineNum">     230 </span>            : // we use as a &quot;base&quot; type used to refer to all instances of NativePropertiesN.
<span class="lineNum">     231 </span>            : // (7 is used because that's the maximum valid parameter, though any other
<span class="lineNum">     232 </span>            : // value 1..6 could also be used.) This is reasonable because of the
<span class="lineNum">     233 </span>            : // aforementioned assertions in the getters. Upcast() is used to convert
<span class="lineNum">     234 </span>            : // specific instances to this &quot;base&quot; type.
<span class="lineNum">     235 </span>            : //
<span class="lineNum">     236 </span>            : template &lt;int N&gt;
<span class="lineNum">     237 </span>            : struct NativePropertiesN {
<span class="lineNum">     238 </span>            :   // Duo structs are stored in the duos[] array, and each element in the array
<span class="lineNum">     239 </span>            :   // could require a different T. Therefore, we can't use the correct type for
<span class="lineNum">     240 </span>            :   // mPrefables. Instead we use void* and cast to the correct type in the
<span class="lineNum">     241 </span>            :   // getters.
<span class="lineNum">     242 </span>            :   struct Duo {
<span class="lineNum">     243 </span>            :     const /*Prefable&lt;const T&gt;*/ void* const mPrefables;
<span class="lineNum">     244 </span>            :     PropertyInfo* const mPropertyInfos;
<a name="245"><span class="lineNum">     245 </span>            :   };</a>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">        751 :   constexpr const NativePropertiesN&lt;7&gt;* Upcast() const {</span>
<span class="lineNum">     248 </span><span class="lineCov">        751 :     return reinterpret_cast&lt;const NativePropertiesN&lt;7&gt;*&gt;(this);</span>
<a name="249"><span class="lineNum">     249 </span>            :   }</a>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">        671 :   const PropertyInfo* PropertyInfos() const {</span>
<span class="lineNum">     252 </span><span class="lineCov">        671 :     return duos[0].mPropertyInfos;</span>
<span class="lineNum">     253 </span>            :   }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : #define DO(SpecT, FieldName) \
<span class="lineNum">     256 </span>            : public: \
<span class="lineNum">     257 </span>            :   /* The bitfields indicating the duo's presence and (if present) offset. */ \
<span class="lineNum">     258 </span>            :   const uint32_t mHas##FieldName##s:1; \
<span class="lineNum">     259 </span>            :   const uint32_t m##FieldName##sOffset:3; \
<span class="lineNum">     260 </span>            : private: \
<span class="lineNum">     261 </span>            :   const Duo* FieldName##sDuo() const { \
<span class="lineNum">     262 </span>            :     MOZ_ASSERT(Has##FieldName##s()); \
<span class="lineNum">     263 </span>            :     return &amp;duos[m##FieldName##sOffset]; \
<span class="lineNum">     264 </span>            :   } \
<span class="lineNum">     265 </span>            : public: \
<span class="lineNum">     266 </span>            :   bool Has##FieldName##s() const { \
<span class="lineNum">     267 </span>            :     return mHas##FieldName##s; \
<span class="lineNum">     268 </span>            :   } \
<span class="lineNum">     269 </span>            :   const Prefable&lt;const SpecT&gt;* FieldName##s() const { \
<span class="lineNum">     270 </span>            :     return static_cast&lt;const Prefable&lt;const SpecT&gt;*&gt; \
<span class="lineNum">     271 </span>            :                       (FieldName##sDuo()-&gt;mPrefables); \
<span class="lineNum">     272 </span>            :   } \
<span class="lineNum">     273 </span>            :   PropertyInfo* FieldName##PropertyInfos() const { \
<span class="lineNum">     274 </span>            :     return FieldName##sDuo()-&gt;mPropertyInfos; \
<a name="275"><span class="lineNum">     275 </span>            :   }</a>
<a name="276"><span class="lineNum">     276 </span>            : </a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">       1659 :   DO(JSFunctionSpec, StaticMethod)</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">       1166 :   DO(JSPropertySpec, StaticAttribute)</span></a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">       3128 :   DO(JSFunctionSpec, Method)</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineCov">       3166 :   DO(JSPropertySpec, Attribute)</span></a>
<a name="281"><span class="lineNum">     281 </span><span class="lineCov">        153 :   DO(JSFunctionSpec, UnforgeableMethod)</span></a>
<span class="lineNum">     282 </span><span class="lineCov">        367 :   DO(JSPropertySpec, UnforgeableAttribute)</span>
<span class="lineNum">     283 </span><span class="lineCov">       1696 :   DO(ConstantSpec,   Constant)</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : #undef DO
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // The index to the iterator method in MethodPropertyInfos() array.
<span class="lineNum">     288 </span>            :   const int16_t iteratorAliasMethodIndex;
<span class="lineNum">     289 </span>            :   // The number of PropertyInfo structs that the duos manage. This is the total
<span class="lineNum">     290 </span>            :   // count across all duos.
<span class="lineNum">     291 </span>            :   const uint16_t propertyInfoCount;
<span class="lineNum">     292 </span>            :   // The sorted indices array from sorting property ids, which will be used when
<span class="lineNum">     293 </span>            :   // we binary search for a property.
<span class="lineNum">     294 </span>            :   uint16_t* sortedPropertyIndices;
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   const Duo duos[N];
<span class="lineNum">     297 </span>            : };
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : // Ensure the struct has the expected size. The 8 is for the bitfields plus
<span class="lineNum">     300 </span>            : // iteratorAliasMethodIndex and idsLength; the rest is for the idsSortedIndex,
<span class="lineNum">     301 </span>            : // and duos[].
<span class="lineNum">     302 </span>            : static_assert(sizeof(NativePropertiesN&lt;1&gt;) == 8 +  3*sizeof(void*), &quot;1 size&quot;);
<span class="lineNum">     303 </span>            : static_assert(sizeof(NativePropertiesN&lt;2&gt;) == 8 +  5*sizeof(void*), &quot;2 size&quot;);
<span class="lineNum">     304 </span>            : static_assert(sizeof(NativePropertiesN&lt;3&gt;) == 8 +  7*sizeof(void*), &quot;3 size&quot;);
<span class="lineNum">     305 </span>            : static_assert(sizeof(NativePropertiesN&lt;4&gt;) == 8 +  9*sizeof(void*), &quot;4 size&quot;);
<span class="lineNum">     306 </span>            : static_assert(sizeof(NativePropertiesN&lt;5&gt;) == 8 + 11*sizeof(void*), &quot;5 size&quot;);
<span class="lineNum">     307 </span>            : static_assert(sizeof(NativePropertiesN&lt;6&gt;) == 8 + 13*sizeof(void*), &quot;6 size&quot;);
<span class="lineNum">     308 </span>            : static_assert(sizeof(NativePropertiesN&lt;7&gt;) == 8 + 15*sizeof(void*), &quot;7 size&quot;);
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : // The &quot;base&quot; type.
<span class="lineNum">     311 </span>            : typedef NativePropertiesN&lt;7&gt; NativeProperties;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : struct NativePropertiesHolder
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :   const NativeProperties* regular;
<span class="lineNum">     316 </span>            :   const NativeProperties* chromeOnly;
<span class="lineNum">     317 </span>            : };
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : // Helper structure for Xrays for DOM binding objects. The same instance is used
<span class="lineNum">     320 </span>            : // for instances, interface objects and interface prototype objects of a
<span class="lineNum">     321 </span>            : // specific interface.
<span class="lineNum">     322 </span>            : struct NativePropertyHooks
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span>            :   // The hook to call for resolving indexed or named properties. May be null if
<span class="lineNum">     325 </span>            :   // there can't be any.
<span class="lineNum">     326 </span>            :   ResolveOwnProperty mResolveOwnProperty;
<span class="lineNum">     327 </span>            :   // The hook to call for enumerating indexed or named properties. May be null
<span class="lineNum">     328 </span>            :   // if there can't be any.
<span class="lineNum">     329 </span>            :   EnumerateOwnProperties mEnumerateOwnProperties;
<span class="lineNum">     330 </span>            :   // The hook to call to delete a named property.  May be null if there are no
<span class="lineNum">     331 </span>            :   // named properties or no named property deleter.  On success (true return)
<span class="lineNum">     332 </span>            :   // the &quot;found&quot; argument will be set to true if there was in fact such a named
<span class="lineNum">     333 </span>            :   // property and false otherwise.  If it's set to false, the caller is expected
<span class="lineNum">     334 </span>            :   // to proceed with whatever deletion behavior it would have if there were no
<span class="lineNum">     335 </span>            :   // named properties involved at all (i.e. if the hook were null).  If it's set
<span class="lineNum">     336 </span>            :   // to true, it will indicate via opresult whether the delete actually
<span class="lineNum">     337 </span>            :   // succeeded.
<span class="lineNum">     338 </span>            :   DeleteNamedProperty mDeleteNamedProperty;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   // The property arrays for this interface.
<span class="lineNum">     341 </span>            :   NativePropertiesHolder mNativeProperties;
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   // This will be set to the ID of the interface prototype object for the
<span class="lineNum">     344 </span>            :   // interface, if it has one. If it doesn't have one it will be set to
<span class="lineNum">     345 </span>            :   // prototypes::id::_ID_Count.
<span class="lineNum">     346 </span>            :   prototypes::ID mPrototypeID;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            :   // This will be set to the ID of the interface object for the interface, if it
<span class="lineNum">     349 </span>            :   // has one. If it doesn't have one it will be set to
<span class="lineNum">     350 </span>            :   // constructors::id::_ID_Count.
<span class="lineNum">     351 </span>            :   constructors::ID mConstructorID;
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   // The NativePropertyHooks instance for the parent interface (for
<span class="lineNum">     354 </span>            :   // ShimInterfaceInfo).
<span class="lineNum">     355 </span>            :   const NativePropertyHooks* mProtoHooks;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :   // The JSClass to use for expandos on our Xrays.  Can be null, in which case
<span class="lineNum">     358 </span>            :   // Xrays will use a default class of their choice.
<span class="lineNum">     359 </span>            :   const JSClass* mXrayExpandoClass;
<span class="lineNum">     360 </span>            : };
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : enum DOMObjectType : uint8_t {
<span class="lineNum">     363 </span>            :   eInstance,
<span class="lineNum">     364 </span>            :   eGlobalInstance,
<span class="lineNum">     365 </span>            :   eInterface,
<span class="lineNum">     366 </span>            :   eInterfacePrototype,
<span class="lineNum">     367 </span>            :   eGlobalInterfacePrototype,
<span class="lineNum">     368 </span>            :   eNamedPropertiesObject
<span class="lineNum">     369 </span>            : };
<span class="lineNum">     370 </span>            : 
<a name="371"><span class="lineNum">     371 </span>            : inline</a>
<span class="lineNum">     372 </span>            : bool
<span class="lineNum">     373 </span><span class="lineCov">        373 : IsInstance(DOMObjectType type)</span>
<span class="lineNum">     374 </span>            : {
<span class="lineNum">     375 </span><span class="lineCov">        373 :   return type == eInstance || type == eGlobalInstance;</span>
<span class="lineNum">     376 </span>            : }
<span class="lineNum">     377 </span>            : 
<a name="378"><span class="lineNum">     378 </span>            : inline</a>
<span class="lineNum">     379 </span>            : bool
<span class="lineNum">     380 </span><span class="lineCov">        189 : IsInterfacePrototype(DOMObjectType type)</span>
<span class="lineNum">     381 </span>            : {
<span class="lineNum">     382 </span><span class="lineCov">        189 :   return type == eInterfacePrototype || type == eGlobalInterfacePrototype;</span>
<span class="lineNum">     383 </span>            : }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : typedef JSObject* (*AssociatedGlobalGetter)(JSContext* aCx,
<span class="lineNum">     386 </span>            :                                             JS::Handle&lt;JSObject*&gt; aObj);
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : typedef JSObject* (*ProtoGetter)(JSContext* aCx);
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : /**
<span class="lineNum">     391 </span>            :  * Returns a handle to the relevant WebIDL prototype object for the current
<span class="lineNum">     392 </span>            :  * compartment global (which may be a handle to null on out of memory).  Once
<span class="lineNum">     393 </span>            :  * allocated, the prototype object is guaranteed to exist as long as the global
<span class="lineNum">     394 </span>            :  * does, since the global traces its array of WebIDL prototypes and
<span class="lineNum">     395 </span>            :  * constructors.
<span class="lineNum">     396 </span>            :  */
<span class="lineNum">     397 </span>            : typedef JS::Handle&lt;JSObject*&gt; (*ProtoHandleGetter)(JSContext* aCx);
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : // Special JSClass for reflected DOM objects.
<span class="lineNum">     400 </span>            : struct DOMJSClass
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span>            :   // It would be nice to just inherit from JSClass, but that precludes pure
<span class="lineNum">     403 </span>            :   // compile-time initialization of the form |DOMJSClass = {...};|, since C++
<span class="lineNum">     404 </span>            :   // only allows brace initialization for aggregate/POD types.
<span class="lineNum">     405 </span>            :   const js::Class mBase;
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :   // A list of interfaces that this object implements, in order of decreasing
<span class="lineNum">     408 </span>            :   // derivedness.
<span class="lineNum">     409 </span>            :   const prototypes::ID mInterfaceChain[MAX_PROTOTYPE_CHAIN_LENGTH];
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   // We store the DOM object in reserved slot with index DOM_OBJECT_SLOT or in
<span class="lineNum">     412 </span>            :   // the proxy private if we use a proxy object.
<span class="lineNum">     413 </span>            :   // Sometimes it's an nsISupports and sometimes it's not; this class tells
<span class="lineNum">     414 </span>            :   // us which it is.
<span class="lineNum">     415 </span>            :   const bool mDOMObjectIsISupports;
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   const NativePropertyHooks* mNativeHooks;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   // A callback to find the associated global for our C++ object.  Note that
<span class="lineNum">     420 </span>            :   // this is used in cases when that global is _changing_, so it will not match
<span class="lineNum">     421 </span>            :   // the global of the JSObject* passed in to this function!
<span class="lineNum">     422 </span>            :   AssociatedGlobalGetter mGetAssociatedGlobal;
<span class="lineNum">     423 </span>            :   ProtoHandleGetter mGetProto;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   // This stores the CC participant for the native, null if this class does not
<span class="lineNum">     426 </span>            :   // implement cycle collection or if it inherits from nsISupports (we can get
<span class="lineNum">     427 </span>            :   // the CC participant by QI'ing in that case).
<a name="428"><span class="lineNum">     428 </span>            :   nsCycleCollectionParticipant* mParticipant;</a>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">      11220 :   static const DOMJSClass* FromJSClass(const JSClass* base) {</span>
<span class="lineNum">     431 </span><span class="lineCov">      11220 :     MOZ_ASSERT(base-&gt;flags &amp; JSCLASS_IS_DOMJSCLASS);</span>
<span class="lineNum">     432 </span><span class="lineCov">      11220 :     return reinterpret_cast&lt;const DOMJSClass*&gt;(base);</span>
<a name="433"><span class="lineNum">     433 </span>            :   }</a>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">      11220 :   static const DOMJSClass* FromJSClass(const js::Class* base) {</span>
<span class="lineNum">     436 </span><span class="lineCov">      11220 :     return FromJSClass(Jsvalify(base));</span>
<a name="437"><span class="lineNum">     437 </span>            :   }</a>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineCov">       2566 :   const JSClass* ToJSClass() const { return Jsvalify(&amp;mBase); }</span>
<span class="lineNum">     440 </span>            : };
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : // Special JSClass for DOM interface and interface prototype objects.
<span class="lineNum">     443 </span>            : struct DOMIfaceAndProtoJSClass
<span class="lineNum">     444 </span>            : {
<span class="lineNum">     445 </span>            :   // It would be nice to just inherit from js::Class, but that precludes pure
<span class="lineNum">     446 </span>            :   // compile-time initialization of the form
<span class="lineNum">     447 </span>            :   // |DOMJSInterfaceAndPrototypeClass = {...};|, since C++ only allows brace
<span class="lineNum">     448 </span>            :   // initialization for aggregate/POD types.
<span class="lineNum">     449 </span>            :   const js::Class mBase;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   // Either eInterface, eInterfacePrototype, eGlobalInterfacePrototype or
<span class="lineNum">     452 </span>            :   // eNamedPropertiesObject.
<span class="lineNum">     453 </span>            :   DOMObjectType mType; // uint8_t
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            :   // Boolean indicating whether this object wants a @@hasInstance property
<span class="lineNum">     456 </span>            :   // pointing to InterfaceHasInstance defined on it.  Only ever true for the
<span class="lineNum">     457 </span>            :   // eInterface case.
<span class="lineNum">     458 </span>            :   bool wantsInterfaceHasInstance;
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   const prototypes::ID mPrototypeID; // uint16_t
<span class="lineNum">     461 </span>            :   const uint32_t mDepth;
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :   const NativePropertyHooks* mNativeHooks;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   // The value to return for toString() on this interface or interface prototype
<span class="lineNum">     466 </span>            :   // object.
<span class="lineNum">     467 </span>            :   const char* mToString;
<span class="lineNum">     468 </span>            : 
<a name="469"><span class="lineNum">     469 </span>            :   ProtoGetter mGetParentProto;</a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">        682 :   static const DOMIfaceAndProtoJSClass* FromJSClass(const JSClass* base) {</span>
<span class="lineNum">     472 </span><span class="lineCov">        682 :     MOZ_ASSERT(base-&gt;flags &amp; JSCLASS_IS_DOMIFACEANDPROTOJSCLASS);</span>
<a name="473"><span class="lineNum">     473 </span><span class="lineCov">        682 :     return reinterpret_cast&lt;const DOMIfaceAndProtoJSClass*&gt;(base);</span></a>
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span><span class="lineCov">        682 :   static const DOMIfaceAndProtoJSClass* FromJSClass(const js::Class* base) {</span>
<span class="lineNum">     476 </span><span class="lineCov">        682 :     return FromJSClass(Jsvalify(base));</span>
<span class="lineNum">     477 </span>            :   }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :   const JSClass* ToJSClass() const { return Jsvalify(&amp;mBase); }
<span class="lineNum">     480 </span>            : };
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : class ProtoAndIfaceCache;
<a name="483"><span class="lineNum">     483 </span>            : </a>
<span class="lineNum">     484 </span>            : inline bool
<span class="lineNum">     485 </span><span class="lineCov">          1 : DOMGlobalHasProtoAndIFaceCache(JSObject* global)</span>
<span class="lineNum">     486 </span>            : {
<span class="lineNum">     487 </span><span class="lineCov">          1 :   MOZ_ASSERT(js::GetObjectClass(global)-&gt;flags &amp; JSCLASS_DOM_GLOBAL);</span>
<span class="lineNum">     488 </span>            :   // This can be undefined if we GC while creating the global
<span class="lineNum">     489 </span><span class="lineCov">          1 :   return !js::GetReservedSlot(global, DOM_PROTOTYPE_SLOT).isUndefined();</span>
<span class="lineNum">     490 </span>            : }
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : inline bool
<span class="lineNum">     493 </span><span class="lineNoCov">          0 : HasProtoAndIfaceCache(JSObject* global)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   if (!(js::GetObjectClass(global)-&gt;flags &amp; JSCLASS_DOM_GLOBAL)) {</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   return DOMGlobalHasProtoAndIFaceCache(global);</span>
<span class="lineNum">     499 </span>            : }
<a name="500"><span class="lineNum">     500 </span>            : </a>
<span class="lineNum">     501 </span>            : inline ProtoAndIfaceCache*
<span class="lineNum">     502 </span><span class="lineCov">       3965 : GetProtoAndIfaceCache(JSObject* global)</span>
<span class="lineNum">     503 </span>            : {
<span class="lineNum">     504 </span><span class="lineCov">       3965 :   MOZ_ASSERT(js::GetObjectClass(global)-&gt;flags &amp; JSCLASS_DOM_GLOBAL);</span>
<span class="lineNum">     505 </span>            :   return static_cast&lt;ProtoAndIfaceCache*&gt;(
<span class="lineNum">     506 </span><span class="lineCov">       3965 :     js::GetReservedSlot(global, DOM_PROTOTYPE_SLOT).toPrivate());</span>
<span class="lineNum">     507 </span>            : }
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : } // namespace dom
<span class="lineNum">     510 </span>            : } // namespace mozilla
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : #endif /* mozilla_dom_DOMJSClass_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

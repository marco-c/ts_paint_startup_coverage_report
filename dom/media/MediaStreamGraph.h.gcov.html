<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/media/MediaStreamGraph.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dom/media</a> - MediaStreamGraph.h<span style="font-size: 80%;"> (source / <a href="MediaStreamGraph.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">173</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">91</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/</a>
<span class="lineNum">       2 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       3 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
<span class="lineNum">       4 </span>            :  * You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : #ifndef MOZILLA_MEDIASTREAMGRAPH_H_
<span class="lineNum">       7 </span>            : #define MOZILLA_MEDIASTREAMGRAPH_H_
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;AudioStream.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;MainThreadUtils.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;MediaStreamTypes.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;StreamTracks.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;VideoSegment.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/LinkedList.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/Mutex.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/TaskQueue.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/dom/AudioChannelBinding.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsAutoPtr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsAutoRef.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsIRunnable.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      22 </span>            : #include &lt;speex/speex_resampler.h&gt;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : class nsIRunnable;
<span class="lineNum">      25 </span>            : class nsIGlobalObject;
<span class="lineNum">      26 </span>            : class nsPIDOMWindowInner;
<a name="27"><span class="lineNum">      27 </span>            : </a>
<span class="lineNum">      28 </span>            : template &lt;&gt;
<span class="lineNum">      29 </span><span class="lineNoCov">          0 : class nsAutoRefTraits&lt;SpeexResamplerState&gt; : public nsPointerRefTraits&lt;SpeexResamplerState&gt;</span>
<a name="30"><span class="lineNum">      30 </span>            : {</a>
<span class="lineNum">      31 </span>            :   public:
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :   static void Release(SpeexResamplerState* aState) { speex_resampler_destroy(aState); }</span>
<span class="lineNum">      33 </span>            : };
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : namespace mozilla {
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : extern LazyLogModule gMediaStreamGraphLog;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : namespace dom {
<span class="lineNum">      40 </span>            :   enum class AudioContextOperation;
<span class="lineNum">      41 </span>            : }
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : namespace media {
<span class="lineNum">      44 </span>            :   template&lt;typename V, typename E&gt; class Pledge;
<span class="lineNum">      45 </span>            : }
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : /*
<span class="lineNum">      48 </span>            :  * MediaStreamGraph is a framework for synchronized audio/video processing
<span class="lineNum">      49 </span>            :  * and playback. It is designed to be used by other browser components such as
<span class="lineNum">      50 </span>            :  * HTML media elements, media capture APIs, real-time media streaming APIs,
<span class="lineNum">      51 </span>            :  * multitrack media APIs, and advanced audio APIs.
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  * The MediaStreamGraph uses a dedicated thread to process media --- the media
<span class="lineNum">      54 </span>            :  * graph thread. This ensures that we can process media through the graph
<span class="lineNum">      55 </span>            :  * without blocking on main-thread activity. The media graph is only modified
<span class="lineNum">      56 </span>            :  * on the media graph thread, to ensure graph changes can be processed without
<span class="lineNum">      57 </span>            :  * interfering with media processing. All interaction with the media graph
<span class="lineNum">      58 </span>            :  * thread is done with message passing.
<span class="lineNum">      59 </span>            :  *
<span class="lineNum">      60 </span>            :  * APIs that modify the graph or its properties are described as &quot;control APIs&quot;.
<span class="lineNum">      61 </span>            :  * These APIs are asynchronous; they queue graph changes internally and
<span class="lineNum">      62 </span>            :  * those changes are processed all-at-once by the MediaStreamGraph. The
<span class="lineNum">      63 </span>            :  * MediaStreamGraph monitors the main thread event loop via nsIAppShell::RunInStableState
<span class="lineNum">      64 </span>            :  * to ensure that graph changes from a single event loop task are always
<span class="lineNum">      65 </span>            :  * processed all together. Control APIs should only be used on the main thread,
<span class="lineNum">      66 </span>            :  * currently; we may be able to relax that later.
<span class="lineNum">      67 </span>            :  *
<span class="lineNum">      68 </span>            :  * To allow precise synchronization of times in the control API, the
<span class="lineNum">      69 </span>            :  * MediaStreamGraph maintains a &quot;media timeline&quot;. Control APIs that take or
<span class="lineNum">      70 </span>            :  * return times use that timeline. Those times never advance during
<span class="lineNum">      71 </span>            :  * an event loop task. This time is returned by MediaStreamGraph::GetCurrentTime().
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * Media decoding, audio processing and media playback use thread-safe APIs to
<span class="lineNum">      74 </span>            :  * the media graph to ensure they can continue while the main thread is blocked.
<span class="lineNum">      75 </span>            :  *
<span class="lineNum">      76 </span>            :  * When the graph is changed, we may need to throw out buffered data and
<span class="lineNum">      77 </span>            :  * reprocess it. This is triggered automatically by the MediaStreamGraph.
<span class="lineNum">      78 </span>            :  */
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : class AudioNodeEngine;
<span class="lineNum">      81 </span>            : class AudioNodeExternalInputStream;
<span class="lineNum">      82 </span>            : class AudioNodeStream;
<span class="lineNum">      83 </span>            : class MediaInputPort;
<span class="lineNum">      84 </span>            : class MediaStream;
<span class="lineNum">      85 </span>            : class MediaStreamGraph;
<span class="lineNum">      86 </span>            : class MediaStreamGraphImpl;
<span class="lineNum">      87 </span>            : class ProcessedMediaStream;
<a name="88"><span class="lineNum">      88 </span>            : class SourceMediaStream;</a>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineNoCov">          0 : class AudioDataListenerInterface {</span>
<a name="91"><span class="lineNum">      91 </span>            : protected:</a>
<span class="lineNum">      92 </span>            :   // Protected destructor, to discourage deletion outside of Release():
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   virtual ~AudioDataListenerInterface() {}</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : public:
<span class="lineNum">      96 </span>            :   /* These are for cubeb audio input &amp; output streams: */
<span class="lineNum">      97 </span>            :   /**
<span class="lineNum">      98 </span>            :    * Output data to speakers, for use as the &quot;far-end&quot; data for echo
<span class="lineNum">      99 </span>            :    * cancellation.  This is not guaranteed to be in any particular size
<span class="lineNum">     100 </span>            :    * chunks.
<span class="lineNum">     101 </span>            :    */
<span class="lineNum">     102 </span>            :   virtual void NotifyOutputData(MediaStreamGraph* aGraph,
<span class="lineNum">     103 </span>            :                                 AudioDataValue* aBuffer, size_t aFrames,
<span class="lineNum">     104 </span>            :                                 TrackRate aRate, uint32_t aChannels) = 0;
<span class="lineNum">     105 </span>            :   /**
<span class="lineNum">     106 </span>            :    * Input data from a microphone (or other audio source.  This is not
<span class="lineNum">     107 </span>            :    * guaranteed to be in any particular size chunks.
<span class="lineNum">     108 </span>            :    */
<span class="lineNum">     109 </span>            :   virtual void NotifyInputData(MediaStreamGraph* aGraph,
<span class="lineNum">     110 </span>            :                                const AudioDataValue* aBuffer, size_t aFrames,
<span class="lineNum">     111 </span>            :                                TrackRate aRate, uint32_t aChannels) = 0;
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :   /**
<span class="lineNum">     114 </span>            :    * Called when the underlying audio device has changed.
<span class="lineNum">     115 </span>            :    */
<span class="lineNum">     116 </span>            :   virtual void DeviceChanged() = 0;
<a name="117"><span class="lineNum">     117 </span>            : };</a>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineNoCov">          0 : class AudioDataListener : public AudioDataListenerInterface {</span>
<a name="120"><span class="lineNum">     120 </span>            : protected:</a>
<span class="lineNum">     121 </span>            :   // Protected destructor, to discourage deletion outside of Release():
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   virtual ~AudioDataListener() {}</span>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<span class="lineNum">     124 </span>            : public:
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(AudioDataListener)</span>
<span class="lineNum">     126 </span>            : };
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : /**
<span class="lineNum">     129 </span>            :  * This is a base class for main-thread listener callbacks.
<span class="lineNum">     130 </span>            :  * This callback is invoked on the main thread when the main-thread-visible
<span class="lineNum">     131 </span>            :  * state of a stream has changed.
<span class="lineNum">     132 </span>            :  *
<span class="lineNum">     133 </span>            :  * These methods are called with the media graph monitor held, so
<span class="lineNum">     134 </span>            :  * reentry into general media graph methods is not possible.
<span class="lineNum">     135 </span>            :  * You should do something non-blocking and non-reentrant (e.g. dispatch an
<span class="lineNum">     136 </span>            :  * event) and return. DispatchFromMainThreadAfterNextStreamStateUpdate
<span class="lineNum">     137 </span>            :  * would be a good choice.
<span class="lineNum">     138 </span>            :  * The listener is allowed to synchronously remove itself from the stream, but
<a name="139"><span class="lineNum">     139 </span>            :  * not add or remove any other listeners.</a>
<span class="lineNum">     140 </span>            :  */
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : class MainThreadMediaStreamListener {</span>
<span class="lineNum">     142 </span>            : public:
<span class="lineNum">     143 </span>            :   virtual void NotifyMainThreadStreamFinished() = 0;
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /**
<span class="lineNum">     147 </span>            :  * Helper struct used to keep track of memory usage by AudioNodes.
<span class="lineNum">     148 </span>            :  */
<a name="149"><span class="lineNum">     149 </span>            : struct AudioNodeSizes</a>
<span class="lineNum">     150 </span>            : {
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   AudioNodeSizes() : mStream(0), mEngine(0), mNodeType() {}</span>
<span class="lineNum">     152 </span>            :   size_t mStream;
<span class="lineNum">     153 </span>            :   size_t mEngine;
<span class="lineNum">     154 </span>            :   const char* mNodeType;
<span class="lineNum">     155 </span>            : };
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : class AudioNodeEngine;
<span class="lineNum">     158 </span>            : class AudioNodeExternalInputStream;
<span class="lineNum">     159 </span>            : class AudioNodeStream;
<span class="lineNum">     160 </span>            : class AudioSegment;
<span class="lineNum">     161 </span>            : class DirectMediaStreamListener;
<span class="lineNum">     162 </span>            : class DirectMediaStreamTrackListener;
<span class="lineNum">     163 </span>            : class MediaInputPort;
<span class="lineNum">     164 </span>            : class MediaStreamGraphImpl;
<span class="lineNum">     165 </span>            : class MediaStreamListener;
<span class="lineNum">     166 </span>            : class MediaStreamTrackListener;
<span class="lineNum">     167 </span>            : class MediaStreamVideoSink;
<span class="lineNum">     168 </span>            : class ProcessedMediaStream;
<span class="lineNum">     169 </span>            : class SourceMediaStream;
<span class="lineNum">     170 </span>            : class TrackUnionStream;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /**
<span class="lineNum">     173 </span>            :  * Helper struct for binding a track listener to a specific TrackID.
<a name="174"><span class="lineNum">     174 </span>            :  */</a>
<span class="lineNum">     175 </span>            : template&lt;typename Listener&gt;
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : struct TrackBound</span>
<span class="lineNum">     177 </span>            : {
<span class="lineNum">     178 </span>            :   RefPtr&lt;Listener&gt; mListener;
<span class="lineNum">     179 </span>            :   TrackID mTrackID;
<span class="lineNum">     180 </span>            : };
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /**
<span class="lineNum">     183 </span>            :  * A stream of synchronized audio and video data. All (not blocked) streams
<span class="lineNum">     184 </span>            :  * progress at the same rate --- &quot;real time&quot;. Streams cannot seek. The only
<span class="lineNum">     185 </span>            :  * operation readers can perform on a stream is to read the next data.
<span class="lineNum">     186 </span>            :  *
<span class="lineNum">     187 </span>            :  * Consumers of a stream can be reading from it at different offsets, but that
<span class="lineNum">     188 </span>            :  * should only happen due to the order in which consumers are being run.
<span class="lineNum">     189 </span>            :  * Those offsets must not diverge in the long term, otherwise we would require
<span class="lineNum">     190 </span>            :  * unbounded buffering.
<span class="lineNum">     191 </span>            :  *
<span class="lineNum">     192 </span>            :  * Streams can be in a &quot;blocked&quot; state. While blocked, a stream does not
<span class="lineNum">     193 </span>            :  * produce data. A stream can be explicitly blocked via the control API,
<span class="lineNum">     194 </span>            :  * or implicitly blocked by whatever's generating it (e.g. an underrun in the
<span class="lineNum">     195 </span>            :  * source resource), or implicitly blocked because something consuming it
<span class="lineNum">     196 </span>            :  * blocks, or implicitly because it has finished.
<span class="lineNum">     197 </span>            :  *
<span class="lineNum">     198 </span>            :  * A stream can be in a &quot;finished&quot; state. &quot;Finished&quot; streams are permanently
<span class="lineNum">     199 </span>            :  * blocked.
<span class="lineNum">     200 </span>            :  *
<span class="lineNum">     201 </span>            :  * Transitions into and out of the &quot;blocked&quot; and &quot;finished&quot; states are managed
<span class="lineNum">     202 </span>            :  * by the MediaStreamGraph on the media graph thread.
<span class="lineNum">     203 </span>            :  *
<span class="lineNum">     204 </span>            :  * We buffer media data ahead of the consumers' reading offsets. It is possible
<span class="lineNum">     205 </span>            :  * to have buffered data but still be blocked.
<span class="lineNum">     206 </span>            :  *
<span class="lineNum">     207 </span>            :  * Any stream can have its audio and video playing when requested. The media
<span class="lineNum">     208 </span>            :  * stream graph plays audio by constructing audio output streams as necessary.
<span class="lineNum">     209 </span>            :  * Video is played by setting video frames into an MediaStreamVideoSink at the right
<span class="lineNum">     210 </span>            :  * time. To ensure video plays in sync with audio, make sure that the same
<span class="lineNum">     211 </span>            :  * stream is playing both the audio and video.
<span class="lineNum">     212 </span>            :  *
<span class="lineNum">     213 </span>            :  * The data in a stream is managed by StreamTracks. It consists of a set of
<span class="lineNum">     214 </span>            :  * tracks of various types that can start and end over time.
<span class="lineNum">     215 </span>            :  *
<span class="lineNum">     216 </span>            :  * Streams are explicitly managed. The client creates them via
<span class="lineNum">     217 </span>            :  * MediaStreamGraph::CreateInput/ProcessedMediaStream, and releases them by calling
<span class="lineNum">     218 </span>            :  * Destroy() when no longer needed (actual destruction will be deferred).
<span class="lineNum">     219 </span>            :  * The actual object is owned by the MediaStreamGraph. The basic idea is that
<span class="lineNum">     220 </span>            :  * main thread objects will keep Streams alive as long as necessary (using the
<span class="lineNum">     221 </span>            :  * cycle collector to clean up whenever needed).
<span class="lineNum">     222 </span>            :  *
<span class="lineNum">     223 </span>            :  * We make them refcounted only so that stream-related messages with MediaStream*
<span class="lineNum">     224 </span>            :  * pointers can be sent to the main thread safely.
<span class="lineNum">     225 </span>            :  *
<span class="lineNum">     226 </span>            :  * The lifetimes of MediaStreams are controlled from the main thread.
<span class="lineNum">     227 </span>            :  * For MediaStreams exposed to the DOM, the lifetime is controlled by the DOM
<span class="lineNum">     228 </span>            :  * wrapper; the DOM wrappers own their associated MediaStreams. When a DOM
<span class="lineNum">     229 </span>            :  * wrapper is destroyed, it sends a Destroy message for the associated
<span class="lineNum">     230 </span>            :  * MediaStream and clears its reference (the last main-thread reference to
<span class="lineNum">     231 </span>            :  * the object). When the Destroy message is processed on the graph manager
<span class="lineNum">     232 </span>            :  * thread we immediately release the affected objects (disentangling them
<span class="lineNum">     233 </span>            :  * from other objects as necessary).
<span class="lineNum">     234 </span>            :  *
<span class="lineNum">     235 </span>            :  * This could cause problems for media processing if a MediaStream is
<span class="lineNum">     236 </span>            :  * destroyed while a downstream MediaStream is still using it. Therefore
<span class="lineNum">     237 </span>            :  * the DOM wrappers must keep upstream MediaStreams alive as long as they
<span class="lineNum">     238 </span>            :  * could be being used in the media graph.
<span class="lineNum">     239 </span>            :  *
<span class="lineNum">     240 </span>            :  * At any time, however, a set of MediaStream wrappers could be
<span class="lineNum">     241 </span>            :  * collected via cycle collection. Destroy messages will be sent
<span class="lineNum">     242 </span>            :  * for those objects in arbitrary order and the MediaStreamGraph has to be able
<span class="lineNum">     243 </span>            :  * to handle this.
<span class="lineNum">     244 </span>            :  */
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : // GetCurrentTime is defined in winbase.h as zero argument macro forwarding to
<span class="lineNum">     247 </span>            : // GetTickCount() and conflicts with MediaStream::GetCurrentTime.
<span class="lineNum">     248 </span>            : #ifdef GetCurrentTime
<span class="lineNum">     249 </span>            : #undef GetCurrentTime
<span class="lineNum">     250 </span>            : #endif
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : class MediaStream : public mozilla::LinkedListElement&lt;MediaStream&gt;
<a name="253"><span class="lineNum">     253 </span>            : {</a>
<span class="lineNum">     254 </span>            : public:
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaStream)</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :   explicit MediaStream();
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : protected:
<span class="lineNum">     260 </span>            :   // Protected destructor, to discourage deletion outside of Release():
<span class="lineNum">     261 </span>            :   virtual ~MediaStream();
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : public:
<span class="lineNum">     264 </span>            :   /**
<span class="lineNum">     265 </span>            :    * Returns the graph that owns this stream.
<span class="lineNum">     266 </span>            :    */
<span class="lineNum">     267 </span>            :   MediaStreamGraphImpl* GraphImpl();
<span class="lineNum">     268 </span>            :   MediaStreamGraph* Graph();
<span class="lineNum">     269 </span>            :   /**
<span class="lineNum">     270 </span>            :    * Sets the graph that owns this stream.  Should only be called once.
<span class="lineNum">     271 </span>            :    */
<span class="lineNum">     272 </span>            :   void SetGraphImpl(MediaStreamGraphImpl* aGraph);
<span class="lineNum">     273 </span>            :   void SetGraphImpl(MediaStreamGraph* aGraph);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   /**
<a name="276"><span class="lineNum">     276 </span>            :    * Returns sample rate of the graph.</a>
<span class="lineNum">     277 </span>            :    */
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   TrackRate GraphRate() { return mTracks.GraphRate(); }</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :   // Control API.
<span class="lineNum">     281 </span>            :   // Since a stream can be played multiple ways, we need to combine independent
<span class="lineNum">     282 </span>            :   // volume settings. The aKey parameter is used to keep volume settings
<span class="lineNum">     283 </span>            :   // separate. Since the stream is always playing the same contents, only
<span class="lineNum">     284 </span>            :   // a single audio output stream is used; the volumes are combined.
<span class="lineNum">     285 </span>            :   // Currently only the first enabled audio track is played.
<span class="lineNum">     286 </span>            :   // XXX change this so all enabled audio tracks are mixed and played.
<span class="lineNum">     287 </span>            :   virtual void AddAudioOutput(void* aKey);
<span class="lineNum">     288 </span>            :   virtual void SetAudioOutputVolume(void* aKey, float aVolume);
<span class="lineNum">     289 </span>            :   virtual void RemoveAudioOutput(void* aKey);
<span class="lineNum">     290 </span>            :   // Since a stream can be played multiple ways, we need to be able to
<span class="lineNum">     291 </span>            :   // play to multiple MediaStreamVideoSinks.
<span class="lineNum">     292 </span>            :   // Only the first enabled video track is played.
<span class="lineNum">     293 </span>            :   virtual void AddVideoOutput(MediaStreamVideoSink* aSink,
<span class="lineNum">     294 </span>            :                               TrackID aID = TRACK_ANY);
<span class="lineNum">     295 </span>            :   virtual void RemoveVideoOutput(MediaStreamVideoSink* aSink,
<span class="lineNum">     296 </span>            :                                  TrackID aID = TRACK_ANY);
<span class="lineNum">     297 </span>            :   // Explicitly suspend. Useful for example if a media element is pausing
<span class="lineNum">     298 </span>            :   // and we need to stop its stream emitting its buffered data. As soon as the
<span class="lineNum">     299 </span>            :   // Suspend message reaches the graph, the stream stops processing. It
<span class="lineNum">     300 </span>            :   // ignores its inputs and produces silence/no video until Resumed. Its
<span class="lineNum">     301 </span>            :   // current time does not advance.
<span class="lineNum">     302 </span>            :   virtual void Suspend();
<span class="lineNum">     303 </span>            :   virtual void Resume();
<span class="lineNum">     304 </span>            :   // Events will be dispatched by calling methods of aListener.
<span class="lineNum">     305 </span>            :   virtual void AddListener(MediaStreamListener* aListener);
<span class="lineNum">     306 </span>            :   virtual void RemoveListener(MediaStreamListener* aListener);
<span class="lineNum">     307 </span>            :   virtual void AddTrackListener(MediaStreamTrackListener* aListener,
<span class="lineNum">     308 </span>            :                                 TrackID aTrackID);
<span class="lineNum">     309 </span>            :   virtual void RemoveTrackListener(MediaStreamTrackListener* aListener,
<span class="lineNum">     310 </span>            :                                    TrackID aTrackID);
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   /**
<span class="lineNum">     313 </span>            :    * Adds aListener to the source stream of track aTrackID in this stream.
<span class="lineNum">     314 </span>            :    * When the MediaStreamGraph processes the added listener, it will traverse
<span class="lineNum">     315 </span>            :    * the graph and add it to the track's source stream (remapping the TrackID
<span class="lineNum">     316 </span>            :    * along the way).
<span class="lineNum">     317 </span>            :    * Note that the listener will be notified on the MediaStreamGraph thread
<span class="lineNum">     318 </span>            :    * with whether the installation of it at the source was successful or not.
<span class="lineNum">     319 </span>            :    */
<span class="lineNum">     320 </span>            :   virtual void AddDirectTrackListener(DirectMediaStreamTrackListener* aListener,
<span class="lineNum">     321 </span>            :                                       TrackID aTrackID);
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   /**
<span class="lineNum">     324 </span>            :    * Removes aListener from the source stream of track aTrackID in this stream.
<span class="lineNum">     325 </span>            :    * Note that the listener has already been removed if the link between the
<span class="lineNum">     326 </span>            :    * source of track aTrackID and this stream has been broken (and made track
<span class="lineNum">     327 </span>            :    * aTrackID end). The caller doesn't have to care about this, removing when
<span class="lineNum">     328 </span>            :    * the source cannot be found, or when the listener had already been removed
<span class="lineNum">     329 </span>            :    * does nothing.
<span class="lineNum">     330 </span>            :    */
<span class="lineNum">     331 </span>            :   virtual void RemoveDirectTrackListener(DirectMediaStreamTrackListener* aListener,
<span class="lineNum">     332 </span>            :                                          TrackID aTrackID);
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   // A disabled track has video replaced by black, and audio replaced by
<span class="lineNum">     335 </span>            :   // silence.
<span class="lineNum">     336 </span>            :   void SetTrackEnabled(TrackID aTrackID, DisabledTrackMode aMode);
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   // Finish event will be notified by calling methods of aListener. It is the
<span class="lineNum">     339 </span>            :   // responsibility of the caller to remove aListener before it is destroyed.
<span class="lineNum">     340 </span>            :   void AddMainThreadListener(MainThreadMediaStreamListener* aListener);
<a name="341"><span class="lineNum">     341 </span>            :   // It's safe to call this even if aListener is not currently a listener;</a>
<span class="lineNum">     342 </span>            :   // the call will be ignored.
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   void RemoveMainThreadListener(MainThreadMediaStreamListener* aListener)</span>
<span class="lineNum">     344 </span>            :   {
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(NS_IsMainThread());</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aListener);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     mMainThreadListeners.RemoveElement(aListener);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :   /**
<span class="lineNum">     351 </span>            :    * Ensure a runnable will run on the main thread after running all pending
<span class="lineNum">     352 </span>            :    * updates that were sent from the graph thread or will be sent before the
<span class="lineNum">     353 </span>            :    * graph thread receives the next graph update.
<span class="lineNum">     354 </span>            :    *
<span class="lineNum">     355 </span>            :    * If the graph has been shut down or destroyed, then the runnable will be
<span class="lineNum">     356 </span>            :    * dispatched to the event queue immediately.  If the graph is non-realtime
<span class="lineNum">     357 </span>            :    * and has not started, then the runnable will be run
<span class="lineNum">     358 </span>            :    * synchronously/immediately.  (There are no pending updates in these
<span class="lineNum">     359 </span>            :    * situations.)
<span class="lineNum">     360 </span>            :    *
<span class="lineNum">     361 </span>            :    * Main thread only.
<span class="lineNum">     362 </span>            :    */
<span class="lineNum">     363 </span>            :   void RunAfterPendingUpdates(already_AddRefed&lt;nsIRunnable&gt; aRunnable);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :   // Signal that the client is done with this MediaStream. It will be deleted
<span class="lineNum">     366 </span>            :   // later. Do not mix usage of Destroy() with RegisterUser()/UnregisterUser().
<span class="lineNum">     367 </span>            :   // That will cause the MediaStream to be destroyed twice, which will cause
<span class="lineNum">     368 </span>            :   // some assertions to fail.
<span class="lineNum">     369 </span>            :   virtual void Destroy();
<span class="lineNum">     370 </span>            :   // Signal that a client is using this MediaStream. Useful to not have to
<span class="lineNum">     371 </span>            :   // explicitly manage ownership (responsibility to Destroy()) when there are
<span class="lineNum">     372 </span>            :   // multiple clients using a MediaStream.
<span class="lineNum">     373 </span>            :   void RegisterUser();
<span class="lineNum">     374 </span>            :   // Signal that a client no longer needs this MediaStream. When the number of
<span class="lineNum">     375 </span>            :   // clients using this MediaStream reaches 0, it will be destroyed.
<span class="lineNum">     376 </span>            :   void UnregisterUser();
<span class="lineNum">     377 </span>            : 
<a name="378"><span class="lineNum">     378 </span>            :   // Returns the main-thread's view of how much data has been processed by</a>
<span class="lineNum">     379 </span>            :   // this stream.
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   StreamTime GetCurrentTime()</span>
<span class="lineNum">     381 </span>            :   {
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     NS_ASSERTION(NS_IsMainThread(), &quot;Call only on main thread&quot;);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     return mMainThreadCurrentTime;</span>
<a name="384"><span class="lineNum">     384 </span>            :   }</a>
<span class="lineNum">     385 </span>            :   // Return the main thread's view of whether this stream has finished.
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   bool IsFinished()</span>
<span class="lineNum">     387 </span>            :   {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     NS_ASSERTION(NS_IsMainThread(), &quot;Call only on main thread&quot;);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     return mMainThreadFinished;</span>
<a name="390"><span class="lineNum">     390 </span>            :   }</a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   bool IsDestroyed()</span>
<span class="lineNum">     393 </span>            :   {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     NS_ASSERTION(NS_IsMainThread(), &quot;Call only on main thread&quot;);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     return mMainThreadDestroyed;</span>
<span class="lineNum">     396 </span>            :   }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   friend class MediaStreamGraphImpl;
<span class="lineNum">     399 </span>            :   friend class MediaInputPort;
<a name="400"><span class="lineNum">     400 </span>            :   friend class AudioNodeExternalInputStream;</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :   virtual SourceMediaStream* AsSourceStream() { return nullptr; }</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineNoCov">          0 :   virtual ProcessedMediaStream* AsProcessedStream() { return nullptr; }</span></a>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   virtual AudioNodeStream* AsAudioNodeStream() { return nullptr; }</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   virtual TrackUnionStream* AsTrackUnionStream() { return nullptr; }</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :   // These Impl methods perform the core functionality of the control methods
<span class="lineNum">     408 </span>            :   // above, on the media graph thread.
<span class="lineNum">     409 </span>            :   /**
<span class="lineNum">     410 </span>            :    * Stop all stream activity and disconnect it from all inputs and outputs.
<span class="lineNum">     411 </span>            :    * This must be idempotent.
<a name="412"><span class="lineNum">     412 </span>            :    */</a>
<span class="lineNum">     413 </span>            :   virtual void DestroyImpl();
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 :   StreamTime GetTracksEnd() { return mTracks.GetEnd(); }</span></a>
<span class="lineNum">     415 </span>            : #ifdef DEBUG
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   void DumpTrackInfo() { return mTracks.DumpTrackInfo(); }</span>
<span class="lineNum">     417 </span>            : #endif
<span class="lineNum">     418 </span>            :   void SetAudioOutputVolumeImpl(void* aKey, float aVolume);
<span class="lineNum">     419 </span>            :   void AddAudioOutputImpl(void* aKey);
<span class="lineNum">     420 </span>            :   // Returns true if this stream has an audio output.
<span class="lineNum">     421 </span>            :   bool HasAudioOutput()
<span class="lineNum">     422 </span>            :   {
<span class="lineNum">     423 </span>            :     return !mAudioOutputs.IsEmpty();
<span class="lineNum">     424 </span>            :   }
<span class="lineNum">     425 </span>            :   void RemoveAudioOutputImpl(void* aKey);
<span class="lineNum">     426 </span>            :   void AddVideoOutputImpl(already_AddRefed&lt;MediaStreamVideoSink&gt; aSink,
<span class="lineNum">     427 </span>            :                           TrackID aID);
<span class="lineNum">     428 </span>            :   void RemoveVideoOutputImpl(MediaStreamVideoSink* aSink, TrackID aID);
<span class="lineNum">     429 </span>            :   void AddListenerImpl(already_AddRefed&lt;MediaStreamListener&gt; aListener);
<span class="lineNum">     430 </span>            :   void RemoveListenerImpl(MediaStreamListener* aListener);
<span class="lineNum">     431 </span>            :   void RemoveAllListenersImpl();
<span class="lineNum">     432 </span>            :   virtual void AddTrackListenerImpl(already_AddRefed&lt;MediaStreamTrackListener&gt; aListener,
<span class="lineNum">     433 </span>            :                                     TrackID aTrackID);
<span class="lineNum">     434 </span>            :   virtual void RemoveTrackListenerImpl(MediaStreamTrackListener* aListener,
<span class="lineNum">     435 </span>            :                                        TrackID aTrackID);
<span class="lineNum">     436 </span>            :   virtual void AddDirectTrackListenerImpl(already_AddRefed&lt;DirectMediaStreamTrackListener&gt; aListener,
<span class="lineNum">     437 </span>            :                                           TrackID aTrackID);
<span class="lineNum">     438 </span>            :   virtual void RemoveDirectTrackListenerImpl(DirectMediaStreamTrackListener* aListener,
<span class="lineNum">     439 </span>            :                                              TrackID aTrackID);
<span class="lineNum">     440 </span>            :   virtual void SetTrackEnabledImpl(TrackID aTrackID, DisabledTrackMode aMode);
<a name="441"><span class="lineNum">     441 </span>            :   DisabledTrackMode GetDisabledTrackMode(TrackID aTrackID);</a>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   void AddConsumer(MediaInputPort* aPort)</span>
<span class="lineNum">     444 </span>            :   {
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :     mConsumers.AppendElement(aPort);</span></a>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   void RemoveConsumer(MediaInputPort* aPort)</span>
<span class="lineNum">     448 </span>            :   {
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     mConsumers.RemoveElement(aPort);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     451 </span>            :   uint32_t ConsumerCount()
<span class="lineNum">     452 </span>            :   {
<a name="453"><span class="lineNum">     453 </span>            :     return mConsumers.Length();</a>
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   StreamTracks&amp; GetStreamTracks() { return mTracks; }</span>
<a name="456"><span class="lineNum">     456 </span>            :   GraphTime GetStreamTracksStartTime() { return mTracksStartTime; }</a>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   double StreamTimeToSeconds(StreamTime aTime)</span>
<span class="lineNum">     459 </span>            :   {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     NS_ASSERTION(0 &lt;= aTime &amp;&amp; aTime &lt;= STREAM_TIME_MAX, &quot;Bad time&quot;);</span>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 :     return static_cast&lt;double&gt;(aTime)/mTracks.GraphRate();</span></a>
<span class="lineNum">     462 </span>            :   }
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   int64_t StreamTimeToMicroseconds(StreamTime aTime)</span>
<span class="lineNum">     464 </span>            :   {
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     NS_ASSERTION(0 &lt;= aTime &amp;&amp; aTime &lt;= STREAM_TIME_MAX, &quot;Bad time&quot;);</span>
<a name="466"><span class="lineNum">     466 </span><span class="lineNoCov">          0 :     return (aTime*1000000)/mTracks.GraphRate();</span></a>
<span class="lineNum">     467 </span>            :   }
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   StreamTime SecondsToNearestStreamTime(double aSeconds)</span>
<span class="lineNum">     469 </span>            :   {
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     NS_ASSERTION(0 &lt;= aSeconds &amp;&amp; aSeconds &lt;= TRACK_TICKS_MAX/TRACK_RATE_MAX,</span>
<span class="lineNum">     471 </span>            :                  &quot;Bad seconds&quot;);
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :     return mTracks.GraphRate() * aSeconds + 0.5;</span></a>
<span class="lineNum">     473 </span>            :   }
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   StreamTime MicrosecondsToStreamTimeRoundDown(int64_t aMicroseconds) {</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     return (aMicroseconds*mTracks.GraphRate())/1000000;</span>
<a name="476"><span class="lineNum">     476 </span>            :   }</a>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   TrackTicks TimeToTicksRoundUp(TrackRate aRate, StreamTime aTime)</span>
<span class="lineNum">     479 </span>            :   {
<a name="480"><span class="lineNum">     480 </span><span class="lineNoCov">          0 :     return RateConvertTicksRoundUp(aRate, mTracks.GraphRate(), aTime);</span></a>
<span class="lineNum">     481 </span>            :   }
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   StreamTime TicksToTimeRoundDown(TrackRate aRate, TrackTicks aTicks)</span>
<span class="lineNum">     483 </span>            :   {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     return RateConvertTicksRoundDown(mTracks.GraphRate(), aRate, aTicks);</span>
<span class="lineNum">     485 </span>            :   }
<span class="lineNum">     486 </span>            :   /**
<span class="lineNum">     487 </span>            :    * Convert graph time to stream time. aTime must be &lt;= mStateComputedTime
<span class="lineNum">     488 </span>            :    * to ensure we know exactly how much time this stream will be blocked during
<span class="lineNum">     489 </span>            :    * the interval.
<span class="lineNum">     490 </span>            :    */
<span class="lineNum">     491 </span>            :   StreamTime GraphTimeToStreamTimeWithBlocking(GraphTime aTime);
<span class="lineNum">     492 </span>            :   /**
<span class="lineNum">     493 </span>            :    * Convert graph time to stream time. This assumes there is no blocking time
<span class="lineNum">     494 </span>            :    * to take account of, which is always true except between a stream
<span class="lineNum">     495 </span>            :    * having its blocking time calculated in UpdateGraph and its blocking time
<span class="lineNum">     496 </span>            :    * taken account of in UpdateCurrentTimeForStreams.
<span class="lineNum">     497 </span>            :    */
<span class="lineNum">     498 </span>            :   StreamTime GraphTimeToStreamTime(GraphTime aTime);
<span class="lineNum">     499 </span>            :   /**
<span class="lineNum">     500 </span>            :    * Convert stream time to graph time. This assumes there is no blocking time
<span class="lineNum">     501 </span>            :    * to take account of, which is always true except between a stream
<span class="lineNum">     502 </span>            :    * having its blocking time calculated in UpdateGraph and its blocking time
<span class="lineNum">     503 </span>            :    * taken account of in UpdateCurrentTimeForStreams.
<span class="lineNum">     504 </span>            :    */
<a name="505"><span class="lineNum">     505 </span>            :   GraphTime StreamTimeToGraphTime(StreamTime aTime);</a>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   bool IsFinishedOnGraphThread() { return mFinished; }</span>
<a name="508"><span class="lineNum">     508 </span>            :   void FinishOnGraphThread();</a>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   bool HasCurrentData() { return mHasCurrentData; }</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   /**
<span class="lineNum">     513 </span>            :    * Find track by track id.
<span class="lineNum">     514 </span>            :    */
<span class="lineNum">     515 </span>            :   StreamTracks::Track* FindTrack(TrackID aID);
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :   StreamTracks::Track* EnsureTrack(TrackID aTrack);
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   virtual void ApplyTrackDisabling(TrackID aTrackID, MediaSegment* aSegment, MediaSegment* aRawSegment = nullptr);
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            :   // Return true if the main thread needs to observe updates from this stream.
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   virtual bool MainThreadNeedsUpdates() const</span>
<span class="lineNum">     523 </span>            :   {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     525 </span>            :   }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   virtual size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const;
<a name="528"><span class="lineNum">     528 </span>            :   virtual size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const;</a>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   void SetAudioChannelType(dom::AudioChannel aType) { mAudioChannelType = aType; }</span>
<a name="531"><span class="lineNum">     531 </span>            :   dom::AudioChannel AudioChannelType() const { return mAudioChannelType; }</a>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   bool IsSuspended() { return mSuspendedCount &gt; 0; }</span>
<span class="lineNum">     534 </span>            :   void IncrementSuspendCount();
<span class="lineNum">     535 </span>            :   void DecrementSuspendCount();
<span class="lineNum">     536 </span>            : 
<a name="537"><span class="lineNum">     537 </span>            : protected:</a>
<span class="lineNum">     538 </span>            :   // |AdvanceTimeVaryingValuesToCurrentTime| will be override in SourceMediaStream.
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   virtual void AdvanceTimeVaryingValuesToCurrentTime(GraphTime aCurrentTime,</span>
<span class="lineNum">     540 </span>            :                                                      GraphTime aBlockedTime)
<span class="lineNum">     541 </span>            :   {
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     mTracksStartTime += aBlockedTime;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     mTracks.ForgetUpTo(aCurrentTime - mTracksStartTime);</span>
<a name="544"><span class="lineNum">     544 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   void NotifyMainThreadListeners()</span>
<span class="lineNum">     547 </span>            :   {
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     NS_ASSERTION(NS_IsMainThread(), &quot;Call only on main thread&quot;);</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     for (int32_t i = mMainThreadListeners.Length() - 1; i &gt;= 0; --i) {</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       mMainThreadListeners[i]-&gt;NotifyMainThreadStreamFinished();</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     mMainThreadListeners.Clear();</span>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   bool ShouldNotifyStreamFinished()</span>
<span class="lineNum">     557 </span>            :   {
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     NS_ASSERTION(NS_IsMainThread(), &quot;Call only on main thread&quot;);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     if (!mMainThreadFinished || mFinishedNotificationSent) {</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     561 </span>            :     }
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     mFinishedNotificationSent = true;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     565 </span>            :   }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            :   // This state is all initialized on the main thread but
<span class="lineNum">     568 </span>            :   // otherwise modified only on the media graph thread.
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   // Buffered data. The start of the buffer corresponds to mTracksStartTime.
<span class="lineNum">     571 </span>            :   // Conceptually the buffer contains everything this stream has ever played,
<span class="lineNum">     572 </span>            :   // but we forget some prefix of the buffered data to bound the space usage.
<span class="lineNum">     573 </span>            :   StreamTracks mTracks;
<span class="lineNum">     574 </span>            :   // The time when the buffered data could be considered to have started playing.
<span class="lineNum">     575 </span>            :   // This increases over time to account for time the stream was blocked before
<span class="lineNum">     576 </span>            :   // mCurrentTime.
<span class="lineNum">     577 </span>            :   GraphTime mTracksStartTime;
<span class="lineNum">     578 </span>            : 
<a name="579"><span class="lineNum">     579 </span>            :   // Client-set volume of this stream</a>
<span class="lineNum">     580 </span>            :   struct AudioOutput {
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     explicit AudioOutput(void* aKey) : mKey(aKey), mVolume(1.0f) {}</span>
<span class="lineNum">     582 </span>            :     void* mKey;
<span class="lineNum">     583 </span>            :     float mVolume;
<span class="lineNum">     584 </span>            :   };
<span class="lineNum">     585 </span>            :   nsTArray&lt;AudioOutput&gt; mAudioOutputs;
<span class="lineNum">     586 </span>            :   nsTArray&lt;TrackBound&lt;MediaStreamVideoSink&gt;&gt; mVideoOutputs;
<span class="lineNum">     587 </span>            :   // We record the last played video frame to avoid playing the frame again
<span class="lineNum">     588 </span>            :   // with a different frame id.
<span class="lineNum">     589 </span>            :   VideoFrame mLastPlayedVideoFrame;
<span class="lineNum">     590 </span>            :   nsTArray&lt;RefPtr&lt;MediaStreamListener&gt; &gt; mListeners;
<span class="lineNum">     591 </span>            :   nsTArray&lt;TrackBound&lt;MediaStreamTrackListener&gt;&gt; mTrackListeners;
<span class="lineNum">     592 </span>            :   nsTArray&lt;MainThreadMediaStreamListener*&gt; mMainThreadListeners;
<span class="lineNum">     593 </span>            :   // List of disabled TrackIDs and their associated disabled mode.
<span class="lineNum">     594 </span>            :   // They can either by disabled by frames being replaced by black, or by
<span class="lineNum">     595 </span>            :   // retaining the previous frame.
<span class="lineNum">     596 </span>            :   nsTArray&lt;DisabledTrack&gt; mDisabledTracks;
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   // GraphTime at which this stream starts blocking.
<span class="lineNum">     599 </span>            :   // This is only valid up to mStateComputedTime. The stream is considered to
<span class="lineNum">     600 </span>            :   // have not been blocked before mCurrentTime (its mTracksStartTime is increased
<span class="lineNum">     601 </span>            :   // as necessary to account for that time instead).
<span class="lineNum">     602 </span>            :   GraphTime mStartBlocking;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   // MediaInputPorts to which this is connected
<span class="lineNum">     605 </span>            :   nsTArray&lt;MediaInputPort*&gt; mConsumers;
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :   // Where audio output is going. There is one AudioOutputStream per
<span class="lineNum">     608 </span>            :   // audio track.
<span class="lineNum">     609 </span>            :   struct AudioOutputStream
<span class="lineNum">     610 </span>            :   {
<span class="lineNum">     611 </span>            :     // When we started audio playback for this track.
<span class="lineNum">     612 </span>            :     // Add mStream-&gt;GetPosition() to find the current audio playback position.
<span class="lineNum">     613 </span>            :     GraphTime mAudioPlaybackStartTime;
<span class="lineNum">     614 </span>            :     // Amount of time that we've wanted to play silence because of the stream
<span class="lineNum">     615 </span>            :     // blocking.
<span class="lineNum">     616 </span>            :     MediaTime mBlockedAudioTime;
<span class="lineNum">     617 </span>            :     // Last tick written to the audio output.
<span class="lineNum">     618 </span>            :     StreamTime mLastTickWritten;
<span class="lineNum">     619 </span>            :     TrackID mTrackID;
<span class="lineNum">     620 </span>            :   };
<span class="lineNum">     621 </span>            :   nsTArray&lt;AudioOutputStream&gt; mAudioOutputStreams;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   /**
<span class="lineNum">     624 </span>            :    * Number of outstanding suspend operations on this stream. Stream is
<span class="lineNum">     625 </span>            :    * suspended when this is &gt; 0.
<span class="lineNum">     626 </span>            :    */
<span class="lineNum">     627 </span>            :   int32_t mSuspendedCount;
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   /**
<span class="lineNum">     630 </span>            :    * When true, this means the stream will be finished once all
<span class="lineNum">     631 </span>            :    * buffered data has been consumed.
<span class="lineNum">     632 </span>            :    */
<span class="lineNum">     633 </span>            :   bool mFinished;
<span class="lineNum">     634 </span>            :   /**
<span class="lineNum">     635 </span>            :    * When true, mFinished is true and we've played all the data in this stream
<span class="lineNum">     636 </span>            :    * and fired NotifyFinished notifications.
<span class="lineNum">     637 </span>            :    */
<span class="lineNum">     638 </span>            :   bool mNotifiedFinished;
<span class="lineNum">     639 </span>            :   /**
<span class="lineNum">     640 </span>            :    * When true, the last NotifyBlockingChanged delivered to the listeners
<span class="lineNum">     641 </span>            :    * indicated that the stream is blocked.
<span class="lineNum">     642 </span>            :    */
<span class="lineNum">     643 </span>            :   bool mNotifiedBlocked;
<span class="lineNum">     644 </span>            :   /**
<span class="lineNum">     645 </span>            :    * True if some data can be present by this stream if/when it's unblocked.
<span class="lineNum">     646 </span>            :    * Set by the stream itself on the MediaStreamGraph thread. Only changes
<span class="lineNum">     647 </span>            :    * from false to true once a stream has data, since we won't
<span class="lineNum">     648 </span>            :    * unblock it until there's more data.
<span class="lineNum">     649 </span>            :    */
<span class="lineNum">     650 </span>            :   bool mHasCurrentData;
<span class="lineNum">     651 </span>            :   /**
<span class="lineNum">     652 </span>            :    * True if mHasCurrentData is true and we've notified listeners.
<span class="lineNum">     653 </span>            :    */
<span class="lineNum">     654 </span>            :   bool mNotifiedHasCurrentData;
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   // Main-thread views of state
<span class="lineNum">     657 </span>            :   StreamTime mMainThreadCurrentTime;
<span class="lineNum">     658 </span>            :   bool mMainThreadFinished;
<span class="lineNum">     659 </span>            :   bool mFinishedNotificationSent;
<span class="lineNum">     660 </span>            :   bool mMainThreadDestroyed;
<span class="lineNum">     661 </span>            :   int mNrOfMainThreadUsers;
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :   // Our media stream graph.  null if destroyed on the graph thread.
<span class="lineNum">     664 </span>            :   MediaStreamGraphImpl* mGraph;
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :   dom::AudioChannel mAudioChannelType;
<span class="lineNum">     667 </span>            : };
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            : /**
<span class="lineNum">     670 </span>            :  * This is a stream into which a decoder can write audio and video.
<span class="lineNum">     671 </span>            :  *
<span class="lineNum">     672 </span>            :  * Audio and video can be written on any thread, but you probably want to
<span class="lineNum">     673 </span>            :  * always write from the same thread to avoid unexpected interleavings.
<span class="lineNum">     674 </span>            :  */
<span class="lineNum">     675 </span>            : class SourceMediaStream : public MediaStream
<span class="lineNum">     676 </span>            : {
<span class="lineNum">     677 </span>            : public:
<a name="678"><span class="lineNum">     678 </span>            :   explicit SourceMediaStream();</a>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :   SourceMediaStream* AsSourceStream() override { return this; }</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :   // Media graph thread only
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :   // Users of audio inputs go through the stream so it can track when the
<span class="lineNum">     685 </span>            :   // last stream referencing an input goes away, so it can close the cubeb
<span class="lineNum">     686 </span>            :   // input.  Also note: callable on any thread (though it bounces through
<span class="lineNum">     687 </span>            :   // MainThread to set the command if needed).
<span class="lineNum">     688 </span>            :   nsresult OpenAudioInput(int aID,
<span class="lineNum">     689 </span>            :                           AudioDataListener *aListener);
<span class="lineNum">     690 </span>            :   // Note: also implied when Destroy() happens
<span class="lineNum">     691 </span>            :   void CloseAudioInput();
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :   void DestroyImpl() override;
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   // Call these on any thread.
<span class="lineNum">     696 </span>            :   /**
<span class="lineNum">     697 </span>            :    * Enable or disable pulling. When pulling is enabled, NotifyPull
<span class="lineNum">     698 </span>            :    * gets called on MediaStreamListeners for this stream during the
<span class="lineNum">     699 </span>            :    * MediaStreamGraph control loop. Pulling is initially disabled.
<span class="lineNum">     700 </span>            :    * Due to unavoidable race conditions, after a call to SetPullEnabled(false)
<span class="lineNum">     701 </span>            :    * it is still possible for a NotifyPull to occur.
<span class="lineNum">     702 </span>            :    */
<span class="lineNum">     703 </span>            :   void SetPullEnabled(bool aEnabled);
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :   /**
<span class="lineNum">     706 </span>            :    * These add/remove DirectListeners, which allow bypassing the graph and any
<span class="lineNum">     707 </span>            :    * synchronization delays for e.g. PeerConnection, which wants the data ASAP
<span class="lineNum">     708 </span>            :    * and lets the far-end handle sync and playout timing.
<span class="lineNum">     709 </span>            :    */
<span class="lineNum">     710 </span>            :   void NotifyListenersEventImpl(MediaStreamGraphEvent aEvent);
<span class="lineNum">     711 </span>            :   void NotifyListenersEvent(MediaStreamGraphEvent aEvent);
<span class="lineNum">     712 </span>            :   void AddDirectListener(DirectMediaStreamListener* aListener);
<span class="lineNum">     713 </span>            :   void RemoveDirectListener(DirectMediaStreamListener* aListener);
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :   enum {
<span class="lineNum">     716 </span>            :     ADDTRACK_QUEUED    = 0x01 // Queue track add until FinishAddTracks()
<span class="lineNum">     717 </span>            :   };
<span class="lineNum">     718 </span>            :   /**
<span class="lineNum">     719 </span>            :    * Add a new track to the stream starting at the given base time (which
<span class="lineNum">     720 </span>            :    * must be greater than or equal to the last time passed to
<span class="lineNum">     721 </span>            :    * AdvanceKnownTracksTime). Takes ownership of aSegment. aSegment should
<a name="722"><span class="lineNum">     722 </span>            :    * contain data starting after aStart.</a>
<span class="lineNum">     723 </span>            :    */
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   void AddTrack(TrackID aID, StreamTime aStart, MediaSegment* aSegment,</span>
<span class="lineNum">     725 </span>            :                 uint32_t aFlags = 0)
<span class="lineNum">     726 </span>            :   {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     AddTrackInternal(aID, GraphRate(), aStart, aSegment, aFlags);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :   /**
<span class="lineNum">     731 </span>            :    * Like AddTrack, but resamples audio from aRate to the graph rate.
<span class="lineNum">     732 </span>            :    */
<span class="lineNum">     733 </span>            :   void AddAudioTrack(TrackID aID, TrackRate aRate, StreamTime aStart,
<span class="lineNum">     734 </span>            :                      AudioSegment* aSegment, uint32_t aFlags = 0);
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :   /**
<span class="lineNum">     737 </span>            :    * Call after a series of AddTrack or AddAudioTrack calls to implement
<span class="lineNum">     738 </span>            :    * any pending track adds.
<span class="lineNum">     739 </span>            :    */
<span class="lineNum">     740 </span>            :   void FinishAddTracks();
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :   /**
<span class="lineNum">     743 </span>            :    * Append media data to a track. Ownership of aSegment remains with the caller,
<span class="lineNum">     744 </span>            :    * but aSegment is emptied.
<span class="lineNum">     745 </span>            :    * Returns false if the data was not appended because no such track exists
<span class="lineNum">     746 </span>            :    * or the stream was already finished.
<span class="lineNum">     747 </span>            :    */
<span class="lineNum">     748 </span>            :   virtual bool AppendToTrack(TrackID aID, MediaSegment* aSegment, MediaSegment *aRawSegment = nullptr);
<span class="lineNum">     749 </span>            :   /**
<span class="lineNum">     750 </span>            :    * Get the stream time of the end of the data that has been appended so far.
<span class="lineNum">     751 </span>            :    * Can be called from any thread but won't be useful if it can race with
<span class="lineNum">     752 </span>            :    * an AppendToTrack call, so should probably just be called from the thread
<span class="lineNum">     753 </span>            :    * that also calls AppendToTrack.
<span class="lineNum">     754 </span>            :    */
<span class="lineNum">     755 </span>            :   StreamTime GetEndOfAppendedData(TrackID aID);
<span class="lineNum">     756 </span>            :   /**
<span class="lineNum">     757 </span>            :    * Indicate that a track has ended. Do not do any more API calls
<span class="lineNum">     758 </span>            :    * affecting this track.
<span class="lineNum">     759 </span>            :    * Ignored if the track does not exist.
<span class="lineNum">     760 </span>            :    */
<span class="lineNum">     761 </span>            :   void EndTrack(TrackID aID);
<span class="lineNum">     762 </span>            :   /**
<span class="lineNum">     763 </span>            :    * Indicate that no tracks will be added starting before time aKnownTime.
<span class="lineNum">     764 </span>            :    * aKnownTime must be &gt;= its value at the last call to AdvanceKnownTracksTime.
<span class="lineNum">     765 </span>            :    */
<span class="lineNum">     766 </span>            :   void AdvanceKnownTracksTime(StreamTime aKnownTime);
<span class="lineNum">     767 </span>            :   /**
<span class="lineNum">     768 </span>            :    * Indicate that this stream should enter the &quot;finished&quot; state. All tracks
<span class="lineNum">     769 </span>            :    * must have been ended via EndTrack. The finish time of the stream is
<span class="lineNum">     770 </span>            :    * when all tracks have ended.
<a name="771"><span class="lineNum">     771 </span>            :    */</a>
<span class="lineNum">     772 </span>            :   void FinishWithLockHeld();
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   void Finish()</span>
<span class="lineNum">     774 </span>            :   {
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     MutexAutoLock lock(mMutex);</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     FinishWithLockHeld();</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :   // Overriding allows us to hold the mMutex lock while changing the track enable status
<span class="lineNum">     780 </span>            :   void SetTrackEnabledImpl(TrackID aTrackID, DisabledTrackMode aMode) override;
<span class="lineNum">     781 </span>            : 
<a name="782"><span class="lineNum">     782 </span>            :   // Overriding allows us to ensure mMutex is locked while changing the track enable status</a>
<span class="lineNum">     783 </span>            :   void
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   ApplyTrackDisabling(TrackID aTrackID, MediaSegment* aSegment,</span>
<span class="lineNum">     785 </span>            :                       MediaSegment* aRawSegment = nullptr) override {
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     mMutex.AssertCurrentThreadOwns();</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     MediaStream::ApplyTrackDisabling(aTrackID, aSegment, aRawSegment);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :   /**
<span class="lineNum">     791 </span>            :    * End all tracks and Finish() this stream.  Used to voluntarily revoke access
<span class="lineNum">     792 </span>            :    * to a LocalMediaStream.
<span class="lineNum">     793 </span>            :    */
<span class="lineNum">     794 </span>            :   void EndAllTrackAndFinish();
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :   void RegisterForAudioMixing();
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :   /**
<span class="lineNum">     799 </span>            :    * Returns true if this SourceMediaStream contains at least one audio track
<span class="lineNum">     800 </span>            :    * that is in pending state.
<span class="lineNum">     801 </span>            :    * This is thread safe, and takes the SourceMediaStream mutex.
<span class="lineNum">     802 </span>            :    */
<a name="803"><span class="lineNum">     803 </span>            :   bool HasPendingAudioTrack();</a>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   TimeStamp GetStreamTracksStrartTimeStamp() {</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     MutexAutoLock lock(mMutex);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     return mStreamTracksStartTimeStamp;</span>
<span class="lineNum">     808 </span>            :   }
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   bool OpenNewAudioCallbackDriver(AudioDataListener *aListener);
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :   // XXX need a Reset API
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   friend class MediaStreamGraphImpl;
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            : protected:
<span class="lineNum">     817 </span>            :   enum TrackCommands : uint32_t;
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :   virtual ~SourceMediaStream();
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :   /**
<a name="822"><span class="lineNum">     822 </span>            :    * Data for each track that hasn't ended.</a>
<span class="lineNum">     823 </span>            :    */
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :   struct TrackData {</span>
<span class="lineNum">     825 </span>            :     TrackID mID;
<span class="lineNum">     826 </span>            :     // Sample rate of the input data.
<span class="lineNum">     827 </span>            :     TrackRate mInputRate;
<span class="lineNum">     828 </span>            :     // Resampler if the rate of the input track does not match the
<span class="lineNum">     829 </span>            :     // MediaStreamGraph's.
<span class="lineNum">     830 </span>            :     nsAutoRef&lt;SpeexResamplerState&gt; mResampler;
<span class="lineNum">     831 </span>            :     int mResamplerChannelCount;
<span class="lineNum">     832 </span>            :     StreamTime mStart;
<span class="lineNum">     833 </span>            :     // End-time of data already flushed to the track (excluding mData)
<span class="lineNum">     834 </span>            :     StreamTime mEndOfFlushedData;
<span class="lineNum">     835 </span>            :     // Each time the track updates are flushed to the media graph thread,
<span class="lineNum">     836 </span>            :     // the segment buffer is emptied.
<span class="lineNum">     837 </span>            :     nsAutoPtr&lt;MediaSegment&gt; mData;
<span class="lineNum">     838 </span>            :     // Each time the track updates are flushed to the media graph thread,
<span class="lineNum">     839 </span>            :     // this is cleared.
<span class="lineNum">     840 </span>            :     uint32_t mCommands;
<span class="lineNum">     841 </span>            :   };
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :   bool NeedsMixing();
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :   void ResampleAudioToGraphSampleRate(TrackData* aTrackData, MediaSegment* aSegment);
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :   void AddDirectTrackListenerImpl(already_AddRefed&lt;DirectMediaStreamTrackListener&gt; aListener,
<span class="lineNum">     848 </span>            :                                   TrackID aTrackID) override;
<span class="lineNum">     849 </span>            :   void RemoveDirectTrackListenerImpl(DirectMediaStreamTrackListener* aListener,
<span class="lineNum">     850 </span>            :                                      TrackID aTrackID) override;
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :   void AddTrackInternal(TrackID aID, TrackRate aRate,
<span class="lineNum">     853 </span>            :                         StreamTime aStart, MediaSegment* aSegment,
<a name="854"><span class="lineNum">     854 </span>            :                         uint32_t aFlags);</a>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   TrackData* FindDataForTrack(TrackID aID)</span>
<span class="lineNum">     857 </span>            :   {
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     mMutex.AssertCurrentThreadOwns();</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; mUpdateTracks.Length(); ++i) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       if (mUpdateTracks[i].mID == aID) {</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         return &amp;mUpdateTracks[i];</span>
<span class="lineNum">     862 </span>            :       }
<span class="lineNum">     863 </span>            :     }
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     865 </span>            :   }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   /**
<span class="lineNum">     868 </span>            :    * Notify direct consumers of new data to one of the stream tracks.
<span class="lineNum">     869 </span>            :    * The data doesn't have to be resampled (though it may be).  This is called
<span class="lineNum">     870 </span>            :    * from AppendToTrack on the thread providing the data, and will call
<span class="lineNum">     871 </span>            :    * the Listeners on this thread.
<span class="lineNum">     872 </span>            :    */
<span class="lineNum">     873 </span>            :   void NotifyDirectConsumers(TrackData *aTrack,
<span class="lineNum">     874 </span>            :                              MediaSegment *aSegment);
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :   virtual void
<a name="877"><span class="lineNum">     877 </span>            :   AdvanceTimeVaryingValuesToCurrentTime(GraphTime aCurrentTime,</a>
<span class="lineNum">     878 </span>            :                                         GraphTime aBlockedTime) override;
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   void SetStreamTracksStartTimeStamp(const TimeStamp&amp; aTimeStamp)</span>
<span class="lineNum">     880 </span>            :   {
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     MutexAutoLock lock(mMutex);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :     mStreamTracksStartTimeStamp = aTimeStamp;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :   // Only accessed on the MSG thread.  Used so to ask the MSGImpl to usecount
<span class="lineNum">     886 </span>            :   // users of a specific input.
<span class="lineNum">     887 </span>            :   // XXX Should really be a CubebUtils::AudioDeviceID, but they aren't
<span class="lineNum">     888 </span>            :   // copyable (opaque pointers)
<span class="lineNum">     889 </span>            :   RefPtr&lt;AudioDataListener&gt; mInputListener;
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :   // This must be acquired *before* MediaStreamGraphImpl's lock, if they are
<span class="lineNum">     892 </span>            :   // held together.
<span class="lineNum">     893 </span>            :   Mutex mMutex;
<span class="lineNum">     894 </span>            :   // protected by mMutex
<span class="lineNum">     895 </span>            :   StreamTime mUpdateKnownTracksTime;
<span class="lineNum">     896 </span>            :   // This time stamp will be updated in adding and blocked SourceMediaStream,
<span class="lineNum">     897 </span>            :   // |AddStreamGraphThread| and |AdvanceTimeVaryingValuesToCurrentTime| in
<span class="lineNum">     898 </span>            :   // particularly.
<span class="lineNum">     899 </span>            :   TimeStamp mStreamTracksStartTimeStamp;
<span class="lineNum">     900 </span>            :   nsTArray&lt;TrackData&gt; mUpdateTracks;
<span class="lineNum">     901 </span>            :   nsTArray&lt;TrackData&gt; mPendingTracks;
<span class="lineNum">     902 </span>            :   nsTArray&lt;RefPtr&lt;DirectMediaStreamListener&gt;&gt; mDirectListeners;
<span class="lineNum">     903 </span>            :   nsTArray&lt;TrackBound&lt;DirectMediaStreamTrackListener&gt;&gt; mDirectTrackListeners;
<span class="lineNum">     904 </span>            :   bool mPullEnabled;
<span class="lineNum">     905 </span>            :   bool mUpdateFinished;
<span class="lineNum">     906 </span>            :   bool mNeedsMixing;
<span class="lineNum">     907 </span>            : };
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /**
<span class="lineNum">     910 </span>            :  * The blocking mode decides how a track should be blocked in a MediaInputPort.
<span class="lineNum">     911 </span>            :  */
<span class="lineNum">     912 </span>            : enum class BlockingMode
<span class="lineNum">     913 </span>            : {
<span class="lineNum">     914 </span>            :   /**
<span class="lineNum">     915 </span>            :    * BlockingMode CREATION blocks the source track from being created
<span class="lineNum">     916 </span>            :    * in the destination. It'll end if it already exists.
<span class="lineNum">     917 </span>            :    */
<span class="lineNum">     918 </span>            :   CREATION,
<span class="lineNum">     919 </span>            :   /**
<span class="lineNum">     920 </span>            :    * BlockingMode END_EXISTING allows a track to be created in the destination
<span class="lineNum">     921 </span>            :    * but will end it before any data has been passed through.
<span class="lineNum">     922 </span>            :    */
<span class="lineNum">     923 </span>            :   END_EXISTING,
<span class="lineNum">     924 </span>            : };
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : /**
<span class="lineNum">     927 </span>            :  * Represents a connection between a ProcessedMediaStream and one of its
<span class="lineNum">     928 </span>            :  * input streams.
<span class="lineNum">     929 </span>            :  * We make these refcounted so that stream-related messages with MediaInputPort*
<span class="lineNum">     930 </span>            :  * pointers can be sent to the main thread safely.
<span class="lineNum">     931 </span>            :  *
<span class="lineNum">     932 </span>            :  * A port can be locked to a specific track in the source stream, in which case
<span class="lineNum">     933 </span>            :  * only this track will be forwarded to the destination stream. TRACK_ANY
<span class="lineNum">     934 </span>            :  * can used to signal that all tracks shall be forwarded.
<span class="lineNum">     935 </span>            :  *
<span class="lineNum">     936 </span>            :  * When a port is locked to a specific track in the source stream, it may also
<span class="lineNum">     937 </span>            :  * indicate a TrackID to map this source track to in the destination stream
<span class="lineNum">     938 </span>            :  * by setting aDestTrack to an explicit ID. When we do this, we must know
<span class="lineNum">     939 </span>            :  * that this TrackID in the destination stream is available. We assert during
<span class="lineNum">     940 </span>            :  * processing that the ID is available and that there are no generic input
<span class="lineNum">     941 </span>            :  * ports already attached to the destination stream.
<span class="lineNum">     942 </span>            :  * Note that this is currently only handled by TrackUnionStreams.
<span class="lineNum">     943 </span>            :  *
<span class="lineNum">     944 </span>            :  * When a port's source or destination stream dies, the stream's DestroyImpl
<span class="lineNum">     945 </span>            :  * calls MediaInputPort::Disconnect to disconnect the port from
<span class="lineNum">     946 </span>            :  * the source and destination streams.
<span class="lineNum">     947 </span>            :  *
<span class="lineNum">     948 </span>            :  * The lifetimes of MediaInputPort are controlled from the main thread.
<span class="lineNum">     949 </span>            :  * The media graph adds a reference to the port. When a MediaInputPort is no
<span class="lineNum">     950 </span>            :  * longer needed, main-thread code sends a Destroy message for the port and
<span class="lineNum">     951 </span>            :  * clears its reference (the last main-thread reference to the object). When
<span class="lineNum">     952 </span>            :  * the Destroy message is processed on the graph manager thread we disconnect
<span class="lineNum">     953 </span>            :  * the port and drop the graph's reference, destroying the object.
<span class="lineNum">     954 </span>            :  */
<span class="lineNum">     955 </span>            : class MediaInputPort final
<span class="lineNum">     956 </span>            : {
<a name="957"><span class="lineNum">     957 </span>            : private:</a>
<span class="lineNum">     958 </span>            :   // Do not call this constructor directly. Instead call aDest-&gt;AllocateInputPort.
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   MediaInputPort(MediaStream* aSource,</span>
<span class="lineNum">     960 </span>            :                  TrackID&amp; aSourceTrack,
<span class="lineNum">     961 </span>            :                  ProcessedMediaStream* aDest,
<span class="lineNum">     962 </span>            :                  TrackID&amp; aDestTrack,
<span class="lineNum">     963 </span>            :                  uint16_t aInputNumber,
<span class="lineNum">     964 </span>            :                  uint16_t aOutputNumber)
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     : mSource(aSource)</span>
<span class="lineNum">     966 </span>            :     , mSourceTrack(aSourceTrack)
<span class="lineNum">     967 </span>            :     , mDest(aDest)
<span class="lineNum">     968 </span>            :     , mDestTrack(aDestTrack)
<span class="lineNum">     969 </span>            :     , mInputNumber(aInputNumber)
<span class="lineNum">     970 </span>            :     , mOutputNumber(aOutputNumber)
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     , mGraph(nullptr)</span>
<span class="lineNum">     972 </span>            :   {
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     MOZ_COUNT_CTOR(MediaInputPort);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   }</span>
<a name="975"><span class="lineNum">     975 </span>            : </a>
<span class="lineNum">     976 </span>            :   // Private destructor, to discourage deletion outside of Release():
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   ~MediaInputPort()</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR(MediaInputPort);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   }</span>
<a name="981"><span class="lineNum">     981 </span>            : </a>
<span class="lineNum">     982 </span>            : public:
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(MediaInputPort)</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :   // Called on graph manager thread
<span class="lineNum">     986 </span>            :   // Do not call these from outside MediaStreamGraph.cpp!
<span class="lineNum">     987 </span>            :   void Init();
<span class="lineNum">     988 </span>            :   // Called during message processing to trigger removal of this stream.
<span class="lineNum">     989 </span>            :   void Disconnect();
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :   // Control API
<span class="lineNum">     992 </span>            :   /**
<span class="lineNum">     993 </span>            :    * Disconnects and destroys the port. The caller must not reference this
<span class="lineNum">     994 </span>            :    * object again.
<span class="lineNum">     995 </span>            :    */
<span class="lineNum">     996 </span>            :   void Destroy();
<a name="997"><span class="lineNum">     997 </span>            : </a>
<a name="998"><span class="lineNum">     998 </span>            :   // Any thread</a>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :   MediaStream* GetSource() { return mSource; }</span></a>
<a name="1000"><span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   TrackID GetSourceTrackId() { return mSourceTrack; }</span></a>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   ProcessedMediaStream* GetDestination() { return mDest; }</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   TrackID GetDestinationTrackId() { return mDestTrack; }</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :   /**
<span class="lineNum">    1005 </span>            :    * Block aTrackId in the source stream from being passed through the port.
<span class="lineNum">    1006 </span>            :    * Consumers will interpret this track as ended.
<span class="lineNum">    1007 </span>            :    * Returns a pledge that resolves on the main thread after the track block has
<span class="lineNum">    1008 </span>            :    * been applied by the MSG.
<span class="lineNum">    1009 </span>            :    */
<span class="lineNum">    1010 </span>            :   already_AddRefed&lt;media::Pledge&lt;bool, nsresult&gt;&gt; BlockSourceTrackId(TrackID aTrackId,
<span class="lineNum">    1011 </span>            :                                                                      BlockingMode aBlockingMode);
<span class="lineNum">    1012 </span>            : private:
<span class="lineNum">    1013 </span>            :   void BlockSourceTrackIdImpl(TrackID aTrackId, BlockingMode aBlockingMode);
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : public:
<a name="1016"><span class="lineNum">    1016 </span>            :   // Returns true if aTrackId has not been blocked for any reason and this port</a>
<span class="lineNum">    1017 </span>            :   // has not been locked to another track.
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   bool PassTrackThrough(TrackID aTrackId) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     bool blocked = false;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     for (auto pair : mBlockedTracks) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       if (pair.first() == aTrackId &amp;&amp;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :           (pair.second() == BlockingMode::CREATION ||</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :            pair.second() == BlockingMode::END_EXISTING)) {</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         blocked = true;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1026 </span>            :       }
<span class="lineNum">    1027 </span>            :     }
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     return !blocked &amp;&amp; (mSourceTrack == TRACK_ANY || mSourceTrack == aTrackId);</span>
<span class="lineNum">    1029 </span>            :   }
<span class="lineNum">    1030 </span>            : 
<a name="1031"><span class="lineNum">    1031 </span>            :   // Returns true if aTrackId has not been blocked for track creation and this</a>
<span class="lineNum">    1032 </span>            :   // port has not been locked to another track.
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   bool AllowCreationOf(TrackID aTrackId) {</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     bool blocked = false;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     for (auto pair : mBlockedTracks) {</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       if (pair.first() == aTrackId &amp;&amp;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :           pair.second() == BlockingMode::CREATION) {</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         blocked = true;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1040 </span>            :       }
<span class="lineNum">    1041 </span>            :     }
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     return !blocked &amp;&amp; (mSourceTrack == TRACK_ANY || mSourceTrack == aTrackId);</span>
<a name="1043"><span class="lineNum">    1043 </span>            :   }</a>
<a name="1044"><span class="lineNum">    1044 </span>            : </a>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   uint16_t InputNumber() const { return mInputNumber; }</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   uint16_t OutputNumber() const { return mOutputNumber; }</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :   // Call on graph manager thread
<span class="lineNum">    1049 </span>            :   struct InputInterval {
<span class="lineNum">    1050 </span>            :     GraphTime mStart;
<span class="lineNum">    1051 </span>            :     GraphTime mEnd;
<span class="lineNum">    1052 </span>            :     bool mInputIsBlocked;
<span class="lineNum">    1053 </span>            :   };
<span class="lineNum">    1054 </span>            :   // Find the next time interval starting at or after aTime during which
<span class="lineNum">    1055 </span>            :   // mDest is not blocked and mSource's blocking status does not change.
<span class="lineNum">    1056 </span>            :   InputInterval GetNextInputInterval(GraphTime aTime);
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :   /**
<span class="lineNum">    1059 </span>            :    * Returns the graph that owns this port.
<span class="lineNum">    1060 </span>            :    */
<span class="lineNum">    1061 </span>            :   MediaStreamGraphImpl* GraphImpl();
<span class="lineNum">    1062 </span>            :   MediaStreamGraph* Graph();
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :   /**
<span class="lineNum">    1065 </span>            :    * Sets the graph that owns this stream.  Should only be called once.
<span class="lineNum">    1066 </span>            :    */
<span class="lineNum">    1067 </span>            :   void SetGraphImpl(MediaStreamGraphImpl* aGraph);
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            :   /**
<span class="lineNum">    1070 </span>            :    * Notify the port that the source MediaStream has been suspended.
<span class="lineNum">    1071 </span>            :   */
<span class="lineNum">    1072 </span>            :   void Suspended();
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :   /**
<span class="lineNum">    1075 </span>            :    * Notify the port that the source MediaStream has been resumed.
<span class="lineNum">    1076 </span>            :   */
<a name="1077"><span class="lineNum">    1077 </span>            :   void Resumed();</a>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :   size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">    1080 </span>            :   {
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     size_t amount = 0;</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :     // Not owned:
<span class="lineNum">    1084 </span>            :     // - mSource
<span class="lineNum">    1085 </span>            :     // - mDest
<span class="lineNum">    1086 </span>            :     // - mGraph
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     return amount;</span>
<a name="1088"><span class="lineNum">    1088 </span>            :   }</a>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">    1091 </span>            :   {
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1093 </span>            :   }
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            : private:
<span class="lineNum">    1096 </span>            :   friend class MediaStreamGraphImpl;
<span class="lineNum">    1097 </span>            :   friend class MediaStream;
<span class="lineNum">    1098 </span>            :   friend class ProcessedMediaStream;
<span class="lineNum">    1099 </span>            :   // Never modified after Init()
<span class="lineNum">    1100 </span>            :   MediaStream* mSource;
<span class="lineNum">    1101 </span>            :   TrackID mSourceTrack;
<span class="lineNum">    1102 </span>            :   ProcessedMediaStream* mDest;
<span class="lineNum">    1103 </span>            :   TrackID mDestTrack;
<span class="lineNum">    1104 </span>            :   // The input and output numbers are optional, and are currently only used by
<span class="lineNum">    1105 </span>            :   // Web Audio.
<span class="lineNum">    1106 </span>            :   const uint16_t mInputNumber;
<span class="lineNum">    1107 </span>            :   const uint16_t mOutputNumber;
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :   typedef Pair&lt;TrackID, BlockingMode&gt; BlockedTrack;
<span class="lineNum">    1110 </span>            :   nsTArray&lt;BlockedTrack&gt; mBlockedTracks;
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :   // Our media stream graph
<span class="lineNum">    1113 </span>            :   MediaStreamGraphImpl* mGraph;
<span class="lineNum">    1114 </span>            : };
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            : /**
<span class="lineNum">    1117 </span>            :  * This stream processes zero or more input streams in parallel to produce
<span class="lineNum">    1118 </span>            :  * its output. The details of how the output is produced are handled by
<a name="1119"><span class="lineNum">    1119 </span>            :  * subclasses overriding the ProcessInput method.</a>
<span class="lineNum">    1120 </span>            :  */
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 : class ProcessedMediaStream : public MediaStream</span>
<a name="1122"><span class="lineNum">    1122 </span>            : {</a>
<span class="lineNum">    1123 </span>            : public:
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   explicit ProcessedMediaStream()</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     : MediaStream()</span>
<span class="lineNum">    1126 </span>            :     , mAutofinish(false)
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     , mCycleMarker(0)</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :   // Control API.
<span class="lineNum">    1131 </span>            :   /**
<span class="lineNum">    1132 </span>            :    * Allocates a new input port attached to source aStream.
<span class="lineNum">    1133 </span>            :    * This stream can be removed by calling MediaInputPort::Remove().
<span class="lineNum">    1134 </span>            :    *
<span class="lineNum">    1135 </span>            :    * The input port is tied to aTrackID in the source stream.
<span class="lineNum">    1136 </span>            :    * aTrackID can be set to TRACK_ANY to automatically forward all tracks from
<span class="lineNum">    1137 </span>            :    * aStream.
<span class="lineNum">    1138 </span>            :    *
<span class="lineNum">    1139 </span>            :    * If aTrackID is an explicit ID, aDestTrackID can also be made explicit
<span class="lineNum">    1140 </span>            :    * to ensure that the track is assigned this ID in the destination stream.
<span class="lineNum">    1141 </span>            :    * To avoid intermittent TrackID collisions the destination stream may not
<span class="lineNum">    1142 </span>            :    * have any existing generic input ports (with TRACK_ANY source track) when
<span class="lineNum">    1143 </span>            :    * you allocate an input port with a destination TrackID.
<span class="lineNum">    1144 </span>            :    *
<span class="lineNum">    1145 </span>            :    * To end a track in the destination stream forwarded with TRACK_ANY,
<span class="lineNum">    1146 </span>            :    * it can be blocked in the input port through MediaInputPort::BlockTrackId().
<span class="lineNum">    1147 </span>            :    *
<span class="lineNum">    1148 </span>            :    * Tracks in aBlockedTracks will be blocked in the input port initially. This
<span class="lineNum">    1149 </span>            :    * ensures that they don't get created by the MSG-thread before we can
<span class="lineNum">    1150 </span>            :    * BlockTrackId() on the main thread.
<span class="lineNum">    1151 </span>            :    */
<span class="lineNum">    1152 </span>            :   already_AddRefed&lt;MediaInputPort&gt;
<span class="lineNum">    1153 </span>            :   AllocateInputPort(MediaStream* aStream,
<span class="lineNum">    1154 </span>            :                     TrackID aTrackID = TRACK_ANY,
<span class="lineNum">    1155 </span>            :                     TrackID aDestTrackID = TRACK_ANY,
<span class="lineNum">    1156 </span>            :                     uint16_t aInputNumber = 0,
<span class="lineNum">    1157 </span>            :                     uint16_t aOutputNumber = 0,
<span class="lineNum">    1158 </span>            :                     nsTArray&lt;TrackID&gt;* aBlockedTracks = nullptr);
<span class="lineNum">    1159 </span>            :   /**
<span class="lineNum">    1160 </span>            :    * Force this stream into the finished state.
<span class="lineNum">    1161 </span>            :    */
<span class="lineNum">    1162 </span>            :   void Finish();
<span class="lineNum">    1163 </span>            :   /**
<span class="lineNum">    1164 </span>            :    * Set the autofinish flag on this stream (defaults to false). When this flag
<span class="lineNum">    1165 </span>            :    * is set, and all input streams are in the finished state (including if there
<span class="lineNum">    1166 </span>            :    * are no input streams), this stream automatically enters the finished state.
<span class="lineNum">    1167 </span>            :    */
<a name="1168"><span class="lineNum">    1168 </span>            :   void SetAutofinish(bool aAutofinish);</a>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   ProcessedMediaStream* AsProcessedStream() override { return this; }</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            :   friend class MediaStreamGraphImpl;
<span class="lineNum">    1173 </span>            : 
<a name="1174"><span class="lineNum">    1174 </span>            :   // Do not call these from outside MediaStreamGraph.cpp!</a>
<span class="lineNum">    1175 </span>            :   virtual void AddInput(MediaInputPort* aPort);
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :   virtual void RemoveInput(MediaInputPort* aPort)</span>
<span class="lineNum">    1177 </span>            :   {
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     mInputs.RemoveElement(aPort) || mSuspendedInputs.RemoveElement(aPort);</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1180 </span>            :   bool HasInputPort(MediaInputPort* aPort)
<span class="lineNum">    1181 </span>            :   {
<span class="lineNum">    1182 </span>            :     return mInputs.Contains(aPort) || mSuspendedInputs.Contains(aPort);
<span class="lineNum">    1183 </span>            :   }
<span class="lineNum">    1184 </span>            :   uint32_t InputPortCount()
<span class="lineNum">    1185 </span>            :   {
<span class="lineNum">    1186 </span>            :     return mInputs.Length() + mSuspendedInputs.Length();
<span class="lineNum">    1187 </span>            :   }
<a name="1188"><span class="lineNum">    1188 </span>            :   void InputSuspended(MediaInputPort* aPort);</a>
<a name="1189"><span class="lineNum">    1189 </span>            :   void InputResumed(MediaInputPort* aPort);</a>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :   virtual MediaStream* GetInputStreamFor(TrackID aTrackID) { return nullptr; }</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   virtual TrackID GetInputTrackIDFor(TrackID aTrackID) { return TRACK_NONE; }</span>
<span class="lineNum">    1192 </span>            :   void DestroyImpl() override;
<span class="lineNum">    1193 </span>            :   /**
<span class="lineNum">    1194 </span>            :    * This gets called after we've computed the blocking states for all
<span class="lineNum">    1195 </span>            :    * streams (mBlocked is up to date up to mStateComputedTime).
<span class="lineNum">    1196 </span>            :    * Also, we've produced output for all streams up to this one. If this stream
<span class="lineNum">    1197 </span>            :    * is not in a cycle, then all its source streams have produced data.
<span class="lineNum">    1198 </span>            :    * Generate output from aFrom to aTo.
<span class="lineNum">    1199 </span>            :    * This will be called on streams that have finished. Most stream types should
<span class="lineNum">    1200 </span>            :    * just return immediately if IsFinishedOnGraphThread(), but some may wish to
<span class="lineNum">    1201 </span>            :    * update internal state (see AudioNodeStream).
<span class="lineNum">    1202 </span>            :    * ProcessInput is allowed to call FinishOnGraphThread only if ALLOW_FINISH
<span class="lineNum">    1203 </span>            :    * is in aFlags. (This flag will be set when aTo &gt;= mStateComputedTime, i.e.
<span class="lineNum">    1204 </span>            :    * when we've producing the last block of data we need to produce.) Otherwise
<span class="lineNum">    1205 </span>            :    * we can get into a situation where we've determined the stream should not
<span class="lineNum">    1206 </span>            :    * block before mStateComputedTime, but the stream finishes before
<span class="lineNum">    1207 </span>            :    * mStateComputedTime, violating the invariant that finished streams are blocked.
<span class="lineNum">    1208 </span>            :    */
<span class="lineNum">    1209 </span>            :   enum {
<span class="lineNum">    1210 </span>            :     ALLOW_FINISH = 0x01
<a name="1211"><span class="lineNum">    1211 </span>            :   };</a>
<span class="lineNum">    1212 </span>            :   virtual void ProcessInput(GraphTime aFrom, GraphTime aTo, uint32_t aFlags) = 0;
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   void SetAutofinishImpl(bool aAutofinish) { mAutofinish = aAutofinish; }</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :   // Only valid after MediaStreamGraphImpl::UpdateStreamOrder() has run.
<a name="1216"><span class="lineNum">    1216 </span>            :   // A DelayNode is considered to break a cycle and so this will not return</a>
<span class="lineNum">    1217 </span>            :   // true for echo loops, only for muted cycles.
<a name="1218"><span class="lineNum">    1218 </span><span class="lineNoCov">          0 :   bool InMutedCycle() const { return mCycleMarker; }</span></a>
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   size_t SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const override</span>
<span class="lineNum">    1221 </span>            :   {
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     size_t amount = MediaStream::SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1223 </span>            :     // Not owned:
<span class="lineNum">    1224 </span>            :     // - mInputs elements
<span class="lineNum">    1225 </span>            :     // - mSuspendedInputs elements
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     amount += mInputs.ShallowSizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     amount += mSuspendedInputs.ShallowSizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     return amount;</span>
<a name="1229"><span class="lineNum">    1229 </span>            :   }</a>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   size_t SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const override</span>
<span class="lineNum">    1232 </span>            :   {
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1234 </span>            :   }
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span>            : protected:
<span class="lineNum">    1237 </span>            :   // This state is all accessed only on the media graph thread.
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :   // The list of all inputs that are not currently suspended.
<span class="lineNum">    1240 </span>            :   nsTArray&lt;MediaInputPort*&gt; mInputs;
<span class="lineNum">    1241 </span>            :   // The list of all inputs that are currently suspended.
<span class="lineNum">    1242 </span>            :   nsTArray&lt;MediaInputPort*&gt; mSuspendedInputs;
<span class="lineNum">    1243 </span>            :   bool mAutofinish;
<span class="lineNum">    1244 </span>            :   // After UpdateStreamOrder(), mCycleMarker is either 0 or 1 to indicate
<span class="lineNum">    1245 </span>            :   // whether this stream is in a muted cycle.  During ordering it can contain
<span class="lineNum">    1246 </span>            :   // other marker values - see MediaStreamGraphImpl::UpdateStreamOrder().
<span class="lineNum">    1247 </span>            :   uint32_t mCycleMarker;
<span class="lineNum">    1248 </span>            : };
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            : /**
<span class="lineNum">    1251 </span>            :  * There is a single MediaStreamGraph per window.
<span class="lineNum">    1252 </span>            :  * Additionaly, each OfflineAudioContext object creates its own MediaStreamGraph
<span class="lineNum">    1253 </span>            :  * object too..
<span class="lineNum">    1254 </span>            :  */
<span class="lineNum">    1255 </span>            : class MediaStreamGraph
<span class="lineNum">    1256 </span>            : {
<span class="lineNum">    1257 </span>            : public:
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :   // We ensure that the graph current time advances in multiples of
<span class="lineNum">    1260 </span>            :   // IdealAudioBlockSize()/AudioStream::PreferredSampleRate(). A stream that
<span class="lineNum">    1261 </span>            :   // never blocks and has a track with the ideal audio rate will produce audio
<span class="lineNum">    1262 </span>            :   // in multiples of the block size.
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            :   // Initializing an graph that outputs audio can be quite long on some
<span class="lineNum">    1265 </span>            :   // platforms. Code that want to output audio at some point can express the
<span class="lineNum">    1266 </span>            :   // fact that they will need an audio stream at some point by passing
<span class="lineNum">    1267 </span>            :   // AUDIO_THREAD_DRIVER when getting an instance of MediaStreamGraph, so that
<span class="lineNum">    1268 </span>            :   // the graph starts with the right driver.
<span class="lineNum">    1269 </span>            :   enum GraphDriverType {
<span class="lineNum">    1270 </span>            :     AUDIO_THREAD_DRIVER,
<span class="lineNum">    1271 </span>            :     SYSTEM_THREAD_DRIVER,
<span class="lineNum">    1272 </span>            :     OFFLINE_THREAD_DRIVER
<span class="lineNum">    1273 </span>            :   };
<span class="lineNum">    1274 </span>            :   static const uint32_t AUDIO_CALLBACK_DRIVER_SHUTDOWN_TIMEOUT = 20*1000;
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            :   // Main thread only
<span class="lineNum">    1277 </span>            :   static MediaStreamGraph* GetInstance(GraphDriverType aGraphDriverRequested,
<span class="lineNum">    1278 </span>            :                                        dom::AudioChannel aChannel,
<span class="lineNum">    1279 </span>            :                                        nsPIDOMWindowInner* aWindow);
<span class="lineNum">    1280 </span>            :   static MediaStreamGraph* CreateNonRealtimeInstance(
<span class="lineNum">    1281 </span>            :     TrackRate aSampleRate,
<span class="lineNum">    1282 </span>            :     nsPIDOMWindowInner* aWindowId);
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            :   // Return the correct main thread for this graph. This always returns
<span class="lineNum">    1285 </span>            :   // something that is valid. Thread safe.
<span class="lineNum">    1286 </span>            :   AbstractThread* AbstractMainThread();
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :   // Idempotent
<a name="1289"><span class="lineNum">    1289 </span>            :   static void DestroyNonRealtimeInstance(MediaStreamGraph* aGraph);</a>
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   virtual nsresult OpenAudioInput(int aID,</span>
<span class="lineNum">    1292 </span>            :                                   AudioDataListener *aListener) {
<a name="1293"><span class="lineNum">    1293 </span><span class="lineNoCov">          0 :     return NS_ERROR_FAILURE;</span></a>
<span class="lineNum">    1294 </span>            :   }
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   virtual void CloseAudioInput(AudioDataListener *aListener) {}</span>
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            :   // Control API.
<span class="lineNum">    1298 </span>            :   /**
<span class="lineNum">    1299 </span>            :    * Create a stream that a media decoder (or some other source of
<span class="lineNum">    1300 </span>            :    * media data, such as a camera) can write to.
<span class="lineNum">    1301 </span>            :    */
<span class="lineNum">    1302 </span>            :   SourceMediaStream* CreateSourceStream();
<span class="lineNum">    1303 </span>            :   /**
<span class="lineNum">    1304 </span>            :    * Create a stream that will form the union of the tracks of its input
<span class="lineNum">    1305 </span>            :    * streams.
<span class="lineNum">    1306 </span>            :    * A TrackUnionStream contains all the tracks of all its input streams.
<span class="lineNum">    1307 </span>            :    * Adding a new input stream makes that stream's tracks immediately appear as new
<span class="lineNum">    1308 </span>            :    * tracks starting at the time the input stream was added.
<span class="lineNum">    1309 </span>            :    * Removing an input stream makes the output tracks corresponding to the
<span class="lineNum">    1310 </span>            :    * removed tracks immediately end.
<span class="lineNum">    1311 </span>            :    * For each added track, the track ID of the output track is the track ID
<span class="lineNum">    1312 </span>            :    * of the input track or one plus the maximum ID of all previously added
<span class="lineNum">    1313 </span>            :    * tracks, whichever is greater.
<span class="lineNum">    1314 </span>            :    * TODO at some point we will probably need to add API to select
<span class="lineNum">    1315 </span>            :    * particular tracks of each input stream.
<span class="lineNum">    1316 </span>            :    */
<span class="lineNum">    1317 </span>            :   ProcessedMediaStream* CreateTrackUnionStream();
<span class="lineNum">    1318 </span>            :   /**
<span class="lineNum">    1319 </span>            :    * Create a stream that will mix all its audio input.
<span class="lineNum">    1320 </span>            :    */
<span class="lineNum">    1321 </span>            :   ProcessedMediaStream* CreateAudioCaptureStream(TrackID aTrackId);
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :   /**
<span class="lineNum">    1324 </span>            :    * Add a new stream to the graph.  Main thread.
<span class="lineNum">    1325 </span>            :    */
<span class="lineNum">    1326 </span>            :   void AddStream(MediaStream* aStream);
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :   /* From the main thread, ask the MSG to send back an event when the graph
<span class="lineNum">    1329 </span>            :    * thread is running, and audio is being processed. */
<span class="lineNum">    1330 </span>            :   void NotifyWhenGraphStarted(AudioNodeStream* aNodeStream);
<span class="lineNum">    1331 </span>            :   /* From the main thread, suspend, resume or close an AudioContext.
<span class="lineNum">    1332 </span>            :    * aStreams are the streams of all the AudioNodes of the AudioContext that
<span class="lineNum">    1333 </span>            :    * need to be suspended or resumed. This can be empty if this is a second
<span class="lineNum">    1334 </span>            :    * consecutive suspend call and all the nodes are already suspended.
<span class="lineNum">    1335 </span>            :    *
<span class="lineNum">    1336 </span>            :    * This can possibly pause the graph thread, releasing system resources, if
<span class="lineNum">    1337 </span>            :    * all streams have been suspended/closed.
<span class="lineNum">    1338 </span>            :    *
<span class="lineNum">    1339 </span>            :    * When the operation is complete, aPromise is resolved.
<span class="lineNum">    1340 </span>            :    */
<span class="lineNum">    1341 </span>            :   void ApplyAudioContextOperation(MediaStream* aDestinationStream,
<span class="lineNum">    1342 </span>            :                                   const nsTArray&lt;MediaStream*&gt;&amp; aStreams,
<span class="lineNum">    1343 </span>            :                                   dom::AudioContextOperation aState,
<span class="lineNum">    1344 </span>            :                                   void* aPromise);
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :   bool IsNonRealtime() const;
<span class="lineNum">    1347 </span>            :   /**
<span class="lineNum">    1348 </span>            :    * Start processing non-realtime for a specific number of ticks.
<span class="lineNum">    1349 </span>            :    */
<span class="lineNum">    1350 </span>            :   void StartNonRealtimeProcessing(uint32_t aTicksToProcess);
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :   /**
<span class="lineNum">    1353 </span>            :    * Media graph thread only.
<span class="lineNum">    1354 </span>            :    * Dispatches a runnable that will run on the main thread after all
<span class="lineNum">    1355 </span>            :    * main-thread stream state has been next updated.
<span class="lineNum">    1356 </span>            :    *
<span class="lineNum">    1357 </span>            :    * Should only be called during MediaStreamListener callbacks or during
<span class="lineNum">    1358 </span>            :    * ProcessedMediaStream::ProcessInput().
<span class="lineNum">    1359 </span>            :    */
<span class="lineNum">    1360 </span>            :   virtual void DispatchToMainThreadAfterStreamStateUpdate(
<span class="lineNum">    1361 </span>            :     already_AddRefed&lt;nsIRunnable&gt; aRunnable);
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :   /**
<a name="1364"><span class="lineNum">    1364 </span>            :    * Returns graph sample rate in Hz.</a>
<span class="lineNum">    1365 </span>            :    */
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :   TrackRate GraphRate() const { return mSampleRate; }</span>
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :   void RegisterCaptureStreamForWindow(uint64_t aWindowId,
<span class="lineNum">    1369 </span>            :                                       ProcessedMediaStream* aCaptureStream);
<span class="lineNum">    1370 </span>            :   void UnregisterCaptureStreamForWindow(uint64_t aWindowId);
<span class="lineNum">    1371 </span>            :   already_AddRefed&lt;MediaInputPort&gt; ConnectToCaptureStream(
<span class="lineNum">    1372 </span>            :     uint64_t aWindowId, MediaStream* aMediaStream);
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   /**
<span class="lineNum">    1375 </span>            :    * Data going to the speakers from the GraphDriver's DataCallback
<span class="lineNum">    1376 </span>            :    * to notify any listeners (for echo cancellation).
<span class="lineNum">    1377 </span>            :    */
<span class="lineNum">    1378 </span>            :   void NotifyOutputData(AudioDataValue* aBuffer, size_t aFrames,
<span class="lineNum">    1379 </span>            :                         TrackRate aRate, uint32_t aChannels);
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :   void AssertOnGraphThreadOrNotRunning() const;
<a name="1382"><span class="lineNum">    1382 </span>            : </a>
<span class="lineNum">    1383 </span>            : protected:
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   explicit MediaStreamGraph(TrackRate aSampleRate)</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     : mSampleRate(aSampleRate)</span>
<span class="lineNum">    1386 </span>            :   {
<a name="1387"><span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     MOZ_COUNT_CTOR(MediaStreamGraph);</span></a>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   virtual ~MediaStreamGraph()</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR(MediaStreamGraph);</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            :   // Media graph thread only
<span class="lineNum">    1395 </span>            :   nsTArray&lt;nsCOMPtr&lt;nsIRunnable&gt; &gt; mPendingUpdateRunnables;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :   /**
<span class="lineNum">    1398 </span>            :    * Sample rate at which this graph runs. For real time graphs, this is
<span class="lineNum">    1399 </span>            :    * the rate of the audio mixer. For offline graphs, this is the rate specified
<span class="lineNum">    1400 </span>            :    * at construction.
<span class="lineNum">    1401 </span>            :    */
<span class="lineNum">    1402 </span>            :   TrackRate mSampleRate;
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :   /**
<span class="lineNum">    1405 </span>            :    * CloseAudioInput is async, so hold a reference here.
<span class="lineNum">    1406 </span>            :    */
<span class="lineNum">    1407 </span>            :   nsTArray&lt;RefPtr&lt;AudioDataListener&gt;&gt; mAudioInputs;
<span class="lineNum">    1408 </span>            : };
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            : } // namespace mozilla
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            : #endif /* MOZILLA_MEDIASTREAMGRAPH_H_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/base/FragmentOrElement.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dom/base</a> - FragmentOrElement.cpp<span style="font-size: 80%;"> (source / <a href="FragmentOrElement.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">381</td>
            <td class="headerCovTableEntry">1121</td>
            <td class="headerCovTableEntryLo">34.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntry">135</td>
            <td class="headerCovTableEntryLo">51.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /*
<span class="lineNum">       8 </span>            :  * Base class for all element classes; this provides an implementation
<span class="lineNum">       9 </span>            :  * of DOM Core's nsIDOMElement, implements nsIContent, provides
<span class="lineNum">      10 </span>            :  * utility methods for subclasses, and so forth.
<span class="lineNum">      11 </span>            :  */
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;mozilla/ArrayUtils.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/StaticPtr.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;mozilla/dom/FragmentOrElement.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;mozilla/AsyncEventDispatcher.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/DeclarationBlockInlines.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/EffectSet.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/EventDispatcher.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/EventListenerManager.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/EventStates.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/ServoRestyleManager.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;mozilla/TextEditor.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;mozilla/URLExtraData.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;mozilla/dom/Attr.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsDOMAttributeMap.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsIAtom.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/dom/NodeInfo.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/dom/Event.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsIDocumentInlines.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsIDocumentEncoder.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsIDOMNodeList.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsIContentIterator.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;nsFocusManager.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;nsILinkHandler.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;nsIScriptGlobalObject.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;nsIURL.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;nsNetUtil.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;nsIFrame.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;nsIAnonymousContentCreator.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;nsIPresShell.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;nsStyleConsts.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;nsUnicharUtils.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;nsIDOMEvent.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;nsDOMCID.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;nsIDOMCSSStyleDeclaration.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;nsDOMCSSAttrDeclaration.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;nsNameSpaceManager.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;nsContentList.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;nsDOMTokenList.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;nsXBLPrototypeBinding.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;nsError.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;nsDOMString.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nsIScriptSecurityManager.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;nsIDOMMutationEvent.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;mozilla/InternalMutationEvent.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;mozilla/MouseEvents.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;nsNodeUtils.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;nsDocument.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;nsAttrValueOrString.h&quot;
<span class="lineNum">      68 </span>            : #ifdef MOZ_XUL
<span class="lineNum">      69 </span>            : #include &quot;nsXULElement.h&quot;
<span class="lineNum">      70 </span>            : #endif /* MOZ_XUL */
<span class="lineNum">      71 </span>            : #include &quot;nsFrameSelection.h&quot;
<span class="lineNum">      72 </span>            : #ifdef DEBUG
<span class="lineNum">      73 </span>            : #include &quot;nsRange.h&quot;
<span class="lineNum">      74 </span>            : #endif
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : #include &quot;nsBindingManager.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;nsXBLBinding.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;nsPIDOMWindow.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;nsPIBoxObject.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;nsSVGUtils.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      82 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      83 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      84 </span>            : #include &quot;nsTextFragment.h&quot;
<span class="lineNum">      85 </span>            : #include &quot;nsContentCID.h&quot;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : #include &quot;nsIDOMEventListener.h&quot;
<span class="lineNum">      88 </span>            : #include &quot;nsIWebNavigation.h&quot;
<span class="lineNum">      89 </span>            : #include &quot;nsIBaseWindow.h&quot;
<span class="lineNum">      90 </span>            : #include &quot;nsIWidget.h&quot;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : #include &quot;js/GCAPI.h&quot;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : #include &quot;nsNodeInfoManager.h&quot;
<span class="lineNum">      95 </span>            : #include &quot;nsICategoryManager.h&quot;
<span class="lineNum">      96 </span>            : #include &quot;nsGenericHTMLElement.h&quot;
<span class="lineNum">      97 </span>            : #include &quot;nsContentCreatorFunctions.h&quot;
<span class="lineNum">      98 </span>            : #include &quot;nsIControllers.h&quot;
<span class="lineNum">      99 </span>            : #include &quot;nsView.h&quot;
<span class="lineNum">     100 </span>            : #include &quot;nsViewManager.h&quot;
<span class="lineNum">     101 </span>            : #include &quot;nsIScrollableFrame.h&quot;
<span class="lineNum">     102 </span>            : #include &quot;ChildIterator.h&quot;
<span class="lineNum">     103 </span>            : #include &quot;mozilla/css/StyleRule.h&quot; /* For nsCSSSelectorList */
<span class="lineNum">     104 </span>            : #include &quot;nsRuleProcessorData.h&quot;
<span class="lineNum">     105 </span>            : #include &quot;nsTextNode.h&quot;
<span class="lineNum">     106 </span>            : #include &quot;mozilla/dom/NodeListBinding.h&quot;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : #ifdef MOZ_XUL
<span class="lineNum">     109 </span>            : #include &quot;nsIXULDocument.h&quot;
<span class="lineNum">     110 </span>            : #endif /* MOZ_XUL */
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : #include &quot;nsCCUncollectableMarker.h&quot;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : #include &quot;mozAutoDocUpdate.h&quot;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #include &quot;mozilla/Sprintf.h&quot;
<span class="lineNum">     117 </span>            : #include &quot;nsDOMMutationObserver.h&quot;
<span class="lineNum">     118 </span>            : #include &quot;nsWrapperCacheInlines.h&quot;
<span class="lineNum">     119 </span>            : #include &quot;nsCycleCollector.h&quot;
<span class="lineNum">     120 </span>            : #include &quot;xpcpublic.h&quot;
<span class="lineNum">     121 </span>            : #include &quot;nsIScriptError.h&quot;
<span class="lineNum">     122 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : #include &quot;mozilla/CORSMode.h&quot;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #include &quot;mozilla/dom/ShadowRoot.h&quot;
<span class="lineNum">     127 </span>            : #include &quot;mozilla/dom/HTMLTemplateElement.h&quot;
<span class="lineNum">     128 </span>            : #include &quot;mozilla/dom/SVGUseElement.h&quot;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : #include &quot;nsStyledElement.h&quot;
<span class="lineNum">     131 </span>            : #include &quot;nsIContentInlines.h&quot;
<span class="lineNum">     132 </span>            : #include &quot;nsChildContentList.h&quot;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : using namespace mozilla;
<span class="lineNum">     135 </span>            : using namespace mozilla::dom;
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : int32_t nsIContent::sTabFocusModel = eTabFocus_any;
<span class="lineNum">     138 </span>            : bool nsIContent::sTabFocusModelAppliesToXUL = false;
<span class="lineNum">     139 </span>            : uint64_t nsMutationGuard::sGeneration = 0;
<a name="140"><span class="lineNum">     140 </span>            : </a>
<span class="lineNum">     141 </span>            : nsIContent*
<span class="lineNum">     142 </span><span class="lineNoCov">          0 : nsIContent::FindFirstNonChromeOnlyAccessContent() const</span>
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span>            :   // This handles also nested native anonymous content.
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   for (const nsIContent *content = this; content;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :        content = content-&gt;GetBindingParent()) {</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     if (!content-&gt;ChromeOnlyAccess()) {</span>
<span class="lineNum">     148 </span>            :       // Oops, this function signature allows casting const to
<span class="lineNum">     149 </span>            :       // non-const.  (Then again, so does GetChildAt(0)-&gt;GetParent().)
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       return const_cast&lt;nsIContent*&gt;(content);</span>
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span>            :   }
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     154 </span>            : }
<a name="155"><span class="lineNum">     155 </span>            : </a>
<span class="lineNum">     156 </span>            : nsINode*
<span class="lineNum">     157 </span><span class="lineCov">       4363 : nsIContent::GetFlattenedTreeParentNodeInternal(FlattenedParentType aType) const</span>
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span><span class="lineCov">       4363 :   nsINode* parentNode = GetParentNode();</span>
<span class="lineNum">     160 </span><span class="lineCov">       4363 :   if (!parentNode || !parentNode-&gt;IsContent()) {</span>
<span class="lineNum">     161 </span><span class="lineCov">        448 :     MOZ_ASSERT(!parentNode || parentNode == OwnerDoc());</span>
<span class="lineNum">     162 </span><span class="lineCov">        448 :     return parentNode;</span>
<span class="lineNum">     163 </span>            :   }
<span class="lineNum">     164 </span><span class="lineCov">       3915 :   nsIContent* parent = parentNode-&gt;AsContent();</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineCov">       3915 :   if (aType == eForStyle &amp;&amp;</span>
<span class="lineNum">     167 </span><span class="lineCov">       3915 :       IsRootOfNativeAnonymousSubtree() &amp;&amp;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       OwnerDoc()-&gt;GetRootElement() == parent) {</span>
<span class="lineNum">     169 </span>            :     // First, check if this is generated ::before/::after content for the root.
<span class="lineNum">     170 </span>            :     // If it is, we know what to do.
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     if (IsGeneratedContentContainerForBefore() ||</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         IsGeneratedContentContainerForAfter()) {</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       return parent;</span>
<span class="lineNum">     174 </span>            :     }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :     // When getting the flattened tree parent for style, we return null
<span class="lineNum">     177 </span>            :     // for any &quot;document level&quot; native anonymous content subtree root.
<span class="lineNum">     178 </span>            :     // This is NAC generated by an ancestor frame of the document element's
<span class="lineNum">     179 </span>            :     // primary frame, and includes scrollbar elements created by the root
<span class="lineNum">     180 </span>            :     // scroll frame, and the &quot;custom content container&quot; and accessible caret
<span class="lineNum">     181 </span>            :     // generated by the nsCanvasFrame.  We distinguish document level NAC
<span class="lineNum">     182 </span>            :     // from NAC generated by the root element's primary frame below.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     nsIFrame* parentFrame = parent-&gt;GetPrimaryFrame();</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     if (!parentFrame) {</span>
<span class="lineNum">     185 </span>            :       // If the root element has no primary frame, it means it can't have
<span class="lineNum">     186 </span>            :       // generated any NAC itself.  Thus any NAC we have here must have
<span class="lineNum">     187 </span>            :       // been generated by an ancestor frame.
<span class="lineNum">     188 </span>            :       //
<span class="lineNum">     189 </span>            :       // If we are in here, then either the root element is display:none, or
<span class="lineNum">     190 </span>            :       // we are in the middle of constructing the root of the frame tree and
<span class="lineNum">     191 </span>            :       // we are trying to eagerly restyle document level NAC in
<span class="lineNum">     192 </span>            :       // nsCSSFrameConstructor::GetAnonymousContent before the root
<span class="lineNum">     193 </span>            :       // element's frame has been constructed.
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     nsIAnonymousContentCreator* creator = do_QueryFrame(parentFrame);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     if (!creator) {</span>
<span class="lineNum">     198 </span>            :       // If the root element does have a frame, but does not implement
<span class="lineNum">     199 </span>            :       // nsIAnonymousContentCreator, then this must be document level NAC.
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     AutoTArray&lt;nsIContent*, 8&gt; elements;</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     creator-&gt;AppendAnonymousContentTo(elements, 0);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     if (!elements.Contains(this)) {</span>
<span class="lineNum">     205 </span>            :       // If the root element does have a frame, and also does implement
<span class="lineNum">     206 </span>            :       // nsIAnonymousContentCreator, but didn't create this node, then
<span class="lineNum">     207 </span>            :       // it must be document level NAC.
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineCov">       3915 :   if (parent &amp;&amp; nsContentUtils::HasDistributedChildren(parent) &amp;&amp;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       nsContentUtils::IsInSameAnonymousTree(parent, this)) {</span>
<span class="lineNum">     214 </span>            :     // This node is distributed to insertion points, thus we
<span class="lineNum">     215 </span>            :     // need to consult the destination insertion points list to
<span class="lineNum">     216 </span>            :     // figure out where this node was inserted in the flattened tree.
<span class="lineNum">     217 </span>            :     // It may be the case that |parent| distributes its children
<span class="lineNum">     218 </span>            :     // but the child does not match any insertion points, thus
<span class="lineNum">     219 </span>            :     // the flattened tree parent is nullptr.
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     nsTArray&lt;nsIContent*&gt;* destInsertionPoints = GetExistingDestInsertionPoints();</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     parent = destInsertionPoints &amp;&amp; !destInsertionPoints-&gt;IsEmpty() ?</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       destInsertionPoints-&gt;LastElement()-&gt;GetParent() : nullptr;</span>
<span class="lineNum">     223 </span><span class="lineCov">       3915 :   } else if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {</span>
<span class="lineNum">     224 </span><span class="lineCov">       3915 :     nsIContent* insertionParent = GetXBLInsertionParent();</span>
<span class="lineNum">     225 </span><span class="lineCov">       3915 :     if (insertionParent) {</span>
<span class="lineNum">     226 </span><span class="lineCov">        989 :       parent = insertionParent;</span>
<span class="lineNum">     227 </span>            :     }
<span class="lineNum">     228 </span>            :   }
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :   // Shadow roots never shows up in the flattened tree. Return the host
<span class="lineNum">     231 </span>            :   // instead.
<span class="lineNum">     232 </span><span class="lineCov">       3915 :   if (parent &amp;&amp; parent-&gt;IsInShadowTree()) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     ShadowRoot* parentShadowRoot = ShadowRoot::FromNode(parent);</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     if (parentShadowRoot) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       return parentShadowRoot-&gt;GetHost();</span>
<span class="lineNum">     236 </span>            :     }
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineCov">       3915 :   return parent;</span>
<span class="lineNum">     240 </span>            : }
<a name="241"><span class="lineNum">     241 </span>            : </a>
<span class="lineNum">     242 </span>            : nsIContent::IMEState
<span class="lineNum">     243 </span><span class="lineNoCov">          0 : nsIContent::GetDesiredIMEState()</span>
<span class="lineNum">     244 </span>            : {
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   if (!IsEditableInternal()) {</span>
<span class="lineNum">     246 </span>            :     // Check for the special case where we're dealing with elements which don't
<span class="lineNum">     247 </span>            :     // have the editable flag set, but are readwrite (such as text controls).
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     if (!IsElement() ||</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         !AsElement()-&gt;State().HasState(NS_EVENT_STATE_MOZ_READWRITE)) {</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :       return IMEState(IMEState::DISABLED);</span>
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span>            :   // NOTE: The content for independent editors (e.g., input[type=text],
<span class="lineNum">     254 </span>            :   // textarea) must override this method, so, we don't need to worry about
<span class="lineNum">     255 </span>            :   // that here.
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   nsIContent *editableAncestor = GetEditingHost();</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :   // This is in another editable content, use the result of it.
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   if (editableAncestor &amp;&amp; editableAncestor != this) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     return editableAncestor-&gt;GetDesiredIMEState();</span>
<span class="lineNum">     261 </span>            :   }
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   nsIDocument* doc = GetComposedDoc();</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   if (!doc) {</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     return IMEState(IMEState::DISABLED);</span>
<span class="lineNum">     265 </span>            :   }
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   nsIPresShell* ps = doc-&gt;GetShell();</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   if (!ps) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     return IMEState(IMEState::DISABLED);</span>
<span class="lineNum">     269 </span>            :   }
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   nsPresContext* pc = ps-&gt;GetPresContext();</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   if (!pc) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     return IMEState(IMEState::DISABLED);</span>
<span class="lineNum">     273 </span>            :   }
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   nsIEditor* editor = nsContentUtils::GetHTMLEditor(pc);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   if (!editor) {</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     return IMEState(IMEState::DISABLED);</span>
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   IMEState state;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   editor-&gt;GetPreferredIMEState(&amp;state);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   return state;</span>
<span class="lineNum">     281 </span>            : }
<a name="282"><span class="lineNum">     282 </span>            : </a>
<span class="lineNum">     283 </span>            : bool
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : nsIContent::HasIndependentSelection()</span>
<span class="lineNum">     285 </span>            : {
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   nsIFrame* frame = GetPrimaryFrame();</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   return (frame &amp;&amp; frame-&gt;GetStateBits() &amp; NS_FRAME_INDEPENDENT_SELECTION);</span>
<span class="lineNum">     288 </span>            : }
<a name="289"><span class="lineNum">     289 </span>            : </a>
<span class="lineNum">     290 </span>            : dom::Element*
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : nsIContent::GetEditingHost()</span>
<span class="lineNum">     292 </span>            : {
<span class="lineNum">     293 </span>            :   // If this isn't editable, return nullptr.
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   if (!IsEditableInternal()) {</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     296 </span>            :   }
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   nsIDocument* doc = GetComposedDoc();</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   if (!doc) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     301 </span>            :   }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   // If this is in designMode, we should return &lt;body&gt;
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   if (doc-&gt;HasFlag(NODE_IS_EDITABLE) &amp;&amp; !IsInShadowTree()) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     return doc-&gt;GetBodyElement();</span>
<span class="lineNum">     306 </span>            :   }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   nsIContent* content = this;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   for (dom::Element* parent = GetParentElement();</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :        parent &amp;&amp; parent-&gt;HasFlag(NODE_IS_EDITABLE);</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :        parent = content-&gt;GetParentElement()) {</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     content = parent;</span>
<span class="lineNum">     313 </span>            :   }
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   return content-&gt;AsElement();</span>
<span class="lineNum">     315 </span>            : }
<a name="316"><span class="lineNum">     316 </span>            : </a>
<span class="lineNum">     317 </span>            : nsresult
<span class="lineNum">     318 </span><span class="lineCov">          2 : nsIContent::LookupNamespaceURIInternal(const nsAString&amp; aNamespacePrefix,</span>
<span class="lineNum">     319 </span>            :                                        nsAString&amp; aNamespaceURI) const
<span class="lineNum">     320 </span>            : {
<span class="lineNum">     321 </span><span class="lineCov">          2 :   if (aNamespacePrefix.EqualsLiteral(&quot;xml&quot;)) {</span>
<span class="lineNum">     322 </span>            :     // Special-case for xml prefix
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     aNamespaceURI.AssignLiteral(&quot;http://www.w3.org/XML/1998/namespace&quot;);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     325 </span>            :   }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineCov">          2 :   if (aNamespacePrefix.EqualsLiteral(&quot;xmlns&quot;)) {</span>
<span class="lineNum">     328 </span>            :     // Special-case for xmlns prefix
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     aNamespaceURI.AssignLiteral(&quot;http://www.w3.org/2000/xmlns/&quot;);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     331 </span>            :   }
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineCov">          4 :   nsCOMPtr&lt;nsIAtom&gt; name;</span>
<span class="lineNum">     334 </span><span class="lineCov">          2 :   if (!aNamespacePrefix.IsEmpty()) {</span>
<span class="lineNum">     335 </span><span class="lineCov">          2 :     name = NS_Atomize(aNamespacePrefix);</span>
<span class="lineNum">     336 </span><span class="lineCov">          2 :     NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     337 </span>            :   }
<span class="lineNum">     338 </span>            :   else {
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     name = nsGkAtoms::xmlns;</span>
<span class="lineNum">     340 </span>            :   }
<span class="lineNum">     341 </span>            :   // Trace up the content parent chain looking for the namespace
<span class="lineNum">     342 </span>            :   // declaration that declares aNamespacePrefix.
<span class="lineNum">     343 </span><span class="lineCov">          2 :   const nsIContent* content = this;</span>
<span class="lineNum">     344 </span><span class="lineCov">          3 :   do {</span>
<span class="lineNum">     345 </span><span class="lineCov">          4 :     if (content-&gt;GetAttr(kNameSpaceID_XMLNS, name, aNamespaceURI))</span>
<span class="lineNum">     346 </span><span class="lineCov">          1 :       return NS_OK;</span>
<span class="lineNum">     347 </span><span class="lineCov">          3 :   } while ((content = content-&gt;GetParent()));</span>
<span class="lineNum">     348 </span><span class="lineCov">          1 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">     349 </span>            : }
<a name="350"><span class="lineNum">     350 </span>            : </a>
<span class="lineNum">     351 </span>            : nsIAtom*
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : nsIContent::GetLang() const</span>
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   for (const auto* content = this; content; content = content-&gt;GetParent()) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (!content-&gt;GetAttrCount() || !content-&gt;IsElement()) {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">     357 </span>            :     }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     auto* element = content-&gt;AsElement();</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :     // xml:lang has precedence over lang on HTML elements (see
<span class="lineNum">     362 </span>            :     // XHTML1 section C.7).
<span class="lineNum">     363 </span>            :     const nsAttrValue* attr =
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :       element-&gt;GetParsedAttr(nsGkAtoms::lang, kNameSpaceID_XML);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     if (!attr &amp;&amp; element-&gt;SupportsLangAttr()) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :       attr = element-&gt;GetParsedAttr(nsGkAtoms::lang);</span>
<span class="lineNum">     367 </span>            :     }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (attr) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(attr-&gt;Type() == nsAttrValue::eAtom);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(attr-&gt;GetAtomValue());</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       return attr-&gt;GetAtomValue();</span>
<span class="lineNum">     372 </span>            :     }
<span class="lineNum">     373 </span>            :   }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     376 </span>            : }
<a name="377"><span class="lineNum">     377 </span>            : </a>
<span class="lineNum">     378 </span>            : already_AddRefed&lt;nsIURI&gt;
<span class="lineNum">     379 </span><span class="lineCov">        301 : nsIContent::GetBaseURI(bool aTryUseXHRDocBaseURI) const</span>
<span class="lineNum">     380 </span>            : {
<span class="lineNum">     381 </span><span class="lineCov">        301 :   if (IsInAnonymousSubtree() &amp;&amp; IsAnonymousContentInSVGUseSubtree()) {</span>
<span class="lineNum">     382 </span><span class="lineCov">         46 :     nsIContent* bindingParent = GetBindingParent();</span>
<span class="lineNum">     383 </span><span class="lineCov">         46 :     MOZ_ASSERT(bindingParent);</span>
<span class="lineNum">     384 </span><span class="lineCov">         46 :     SVGUseElement* useElement = static_cast&lt;SVGUseElement*&gt;(bindingParent);</span>
<span class="lineNum">     385 </span>            :     // XXX Ignore xml:base as we are removing it.
<span class="lineNum">     386 </span><span class="lineCov">         46 :     return do_AddRef(useElement-&gt;GetContentURLData()-&gt;BaseURI());</span>
<span class="lineNum">     387 </span>            :   }
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">        255 :   nsIDocument* doc = OwnerDoc();</span>
<span class="lineNum">     390 </span>            :   // Start with document base
<span class="lineNum">     391 </span><span class="lineCov">        510 :   nsCOMPtr&lt;nsIURI&gt; base = doc-&gt;GetBaseURI(aTryUseXHRDocBaseURI);</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :   // Collect array of xml:base attribute values up the parent chain. This
<span class="lineNum">     394 </span>            :   // is slightly slower for the case when there are xml:base attributes, but
<span class="lineNum">     395 </span>            :   // faster for the far more common case of there not being any such
<span class="lineNum">     396 </span>            :   // attributes.
<span class="lineNum">     397 </span>            :   // Also check for SVG elements which require special handling
<span class="lineNum">     398 </span><span class="lineCov">        510 :   AutoTArray&lt;nsString, 5&gt; baseAttrs;</span>
<span class="lineNum">     399 </span><span class="lineCov">        510 :   nsString attr;</span>
<span class="lineNum">     400 </span><span class="lineCov">        255 :   const nsIContent *elem = this;</span>
<span class="lineNum">     401 </span><span class="lineCov">        631 :   do {</span>
<span class="lineNum">     402 </span>            :     // First check for SVG specialness (why is this SVG specific?)
<span class="lineNum">     403 </span><span class="lineCov">        886 :     if (elem-&gt;IsSVGElement()) {</span>
<span class="lineNum">     404 </span><span class="lineCov">        603 :       nsIContent* bindingParent = elem-&gt;GetBindingParent();</span>
<span class="lineNum">     405 </span><span class="lineCov">        603 :       if (bindingParent) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         nsXBLBinding* binding = bindingParent-&gt;GetXBLBinding();</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         if (binding) {</span>
<span class="lineNum">     408 </span>            :           // XXX sXBL/XBL2 issue
<span class="lineNum">     409 </span>            :           // If this is an anonymous XBL element use the binding
<span class="lineNum">     410 </span>            :           // document for the base URI.
<span class="lineNum">     411 </span>            :           // XXX Will fail with xml:base
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :           base = binding-&gt;PrototypeBinding()-&gt;DocURI();</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     414 </span>            :         }
<span class="lineNum">     415 </span>            :       }
<span class="lineNum">     416 </span>            :     }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :     // Otherwise check for xml:base attribute
<span class="lineNum">     419 </span><span class="lineCov">        886 :     elem-&gt;GetAttr(kNameSpaceID_XML, nsGkAtoms::base, attr);</span>
<span class="lineNum">     420 </span><span class="lineCov">        886 :     if (!attr.IsEmpty()) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :       baseAttrs.AppendElement(attr);</span>
<span class="lineNum">     422 </span>            :     }
<span class="lineNum">     423 </span><span class="lineCov">        886 :     elem = elem-&gt;GetParent();</span>
<span class="lineNum">     424 </span><span class="lineCov">        886 :   } while(elem);</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">        255 :   if (!baseAttrs.IsEmpty()) {</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     doc-&gt;WarnOnceAbout(nsIDocument::eXMLBaseAttribute);</span>
<span class="lineNum">     428 </span>            :     // Now resolve against all xml:base attrs
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     for (uint32_t i = baseAttrs.Length() - 1; i != uint32_t(-1); --i) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       nsCOMPtr&lt;nsIURI&gt; newBase;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       nsresult rv = NS_NewURI(getter_AddRefs(newBase), baseAttrs[i],</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                               doc-&gt;GetDocumentCharacterSet(), base);</span>
<span class="lineNum">     433 </span>            :       // Do a security check, almost the same as nsDocument::SetBaseURL()
<span class="lineNum">     434 </span>            :       // Only need to do this on the final uri
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       if (NS_SUCCEEDED(rv) &amp;&amp; i == 0) {</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         rv = nsContentUtils::GetSecurityManager()-&gt;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :           CheckLoadURIWithPrincipal(NodePrincipal(), newBase,</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                                     nsIScriptSecurityManager::STANDARD);</span>
<span class="lineNum">     439 </span>            :       }
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         base.swap(newBase);</span>
<span class="lineNum">     442 </span>            :       }
<span class="lineNum">     443 </span>            :     }
<span class="lineNum">     444 </span>            :   }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineCov">        255 :   return base.forget();</span>
<span class="lineNum">     447 </span>            : }
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : nsIURI*
<span class="lineNum">     450 </span><span class="lineCov">          8 : nsIContent::GetBaseURIWithoutXMLBase() const</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span><span class="lineCov">          8 :   if (IsInAnonymousSubtree() &amp;&amp; IsAnonymousContentInSVGUseSubtree()) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     nsIContent* bindingParent = GetBindingParent();</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(bindingParent);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     SVGUseElement* useElement = static_cast&lt;SVGUseElement*&gt;(bindingParent);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     return useElement-&gt;GetContentURLData()-&gt;BaseURI();</span>
<span class="lineNum">     457 </span>            :   }
<span class="lineNum">     458 </span>            :   // This also ignores the case that SVG inside XBL binding.
<span class="lineNum">     459 </span>            :   // But it is probably fine.
<span class="lineNum">     460 </span><span class="lineCov">          8 :   return OwnerDoc()-&gt;GetDocBaseURI();</span>
<span class="lineNum">     461 </span>            : }
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : already_AddRefed&lt;nsIURI&gt;
<span class="lineNum">     464 </span><span class="lineCov">          8 : nsIContent::GetBaseURIForStyleAttr() const</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineCov">          8 :   nsIDocument* doc = OwnerDoc();</span>
<span class="lineNum">     467 </span><span class="lineCov">          8 :   nsIURI* baseWithoutXMLBase = GetBaseURIWithoutXMLBase();</span>
<span class="lineNum">     468 </span><span class="lineCov">         16 :   nsCOMPtr&lt;nsIURI&gt; base = GetBaseURI();</span>
<span class="lineNum">     469 </span>            :   // If eXMLBaseAttribute is not triggered in GetBaseURI() call above,
<span class="lineNum">     470 </span>            :   // we don't need to count eXMLBaseAttributeForStyleAttr either.
<span class="lineNum">     471 </span><span class="lineCov">          8 :   if (doc-&gt;HasWarnedAbout(nsIDocument::eXMLBaseAttribute) &amp;&amp;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       !doc-&gt;HasWarnedAbout(nsIDocument::eXMLBaseAttributeForStyleAttr)) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     bool isEqual = false;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     base-&gt;Equals(baseWithoutXMLBase, &amp;isEqual);</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     if (!isEqual) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       doc-&gt;WarnOnceAbout(nsIDocument::eXMLBaseAttributeForStyleAttr);</span>
<span class="lineNum">     477 </span>            :     }
<span class="lineNum">     478 </span>            :   }
<span class="lineNum">     479 </span><span class="lineCov">          8 :   return nsLayoutUtils::StyleAttrWithXMLBaseDisabled()</span>
<span class="lineNum">     480 </span><span class="lineCov">         16 :     ? do_AddRef(baseWithoutXMLBase) : base.forget();</span>
<span class="lineNum">     481 </span>            : }
<a name="482"><span class="lineNum">     482 </span>            : </a>
<span class="lineNum">     483 </span>            : URLExtraData*
<span class="lineNum">     484 </span><span class="lineNoCov">          0 : nsIContent::GetURLDataForStyleAttr() const</span>
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   if (IsInAnonymousSubtree() &amp;&amp; IsAnonymousContentInSVGUseSubtree()) {</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     nsIContent* bindingParent = GetBindingParent();</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(bindingParent);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     SVGUseElement* useElement = static_cast&lt;SVGUseElement*&gt;(bindingParent);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     return useElement-&gt;GetContentURLData();</span>
<span class="lineNum">     491 </span>            :   }
<span class="lineNum">     492 </span>            :   // We are not going to support xml:base for stylo, but we want to
<span class="lineNum">     493 </span>            :   // ensure we unship that support before we enabling stylo.
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(nsLayoutUtils::StyleAttrWithXMLBaseDisabled());</span>
<span class="lineNum">     495 </span>            :   // This also ignores the case that SVG inside XBL binding.
<span class="lineNum">     496 </span>            :   // But it is probably fine.
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   return OwnerDoc()-&gt;DefaultStyleAttrURLData();</span>
<span class="lineNum">     498 </span>            : }
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : //----------------------------------------------------------------------
<a name="501"><span class="lineNum">     501 </span>            : </a>
<span class="lineNum">     502 </span>            : static inline JSObject*
<span class="lineNum">     503 </span><span class="lineNoCov">          0 : GetJSObjectChild(nsWrapperCache* aCache)</span>
<span class="lineNum">     504 </span>            : {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   return aCache-&gt;PreservingWrapper() ? aCache-&gt;GetWrapperPreserveColor() : nullptr;</span>
<span class="lineNum">     506 </span>            : }
<a name="507"><span class="lineNum">     507 </span>            : </a>
<span class="lineNum">     508 </span>            : static bool
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : NeedsScriptTraverse(nsINode* aNode)</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   return aNode-&gt;PreservingWrapper() &amp;&amp; aNode-&gt;GetWrapperPreserveColor() &amp;&amp;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :          !aNode-&gt;HasKnownLiveWrapperAndDoesNotNeedTracing(aNode);</span>
<span class="lineNum">     513 </span>            : }
<span class="lineNum">     514 </span>            : 
<a name="515"><span class="lineNum">     515 </span>            : //----------------------------------------------------------------------</a>
<a name="516"><span class="lineNum">     516 </span>            : </a>
<span class="lineNum">     517 </span><span class="lineCov">         30 : NS_IMPL_CYCLE_COLLECTING_ADDREF(nsChildContentList)</span>
<span class="lineNum">     518 </span><span class="lineCov">         12 : NS_IMPL_CYCLE_COLLECTING_RELEASE(nsChildContentList)</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : // If nsChildContentList is changed so that any additional fields are
<a name="521"><span class="lineNum">     521 </span>            : // traversed by the cycle collector, then CAN_SKIP must be updated to</a>
<span class="lineNum">     522 </span>            : // check that the additional fields are null.
<span class="lineNum">     523 </span><span class="lineCov">         24 : NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(nsChildContentList)</span>
<span class="lineNum">     524 </span>            : 
<a name="525"><span class="lineNum">     525 </span>            : // nsChildContentList only ever has a single child, its wrapper, so if</a>
<span class="lineNum">     526 </span>            : // the wrapper is known-live, the list can't be part of a garbage cycle.
<span class="lineNum">     527 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsChildContentList)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   return tmp-&gt;HasKnownLiveWrapper();</span>
<a name="529"><span class="lineNum">     529 </span>            : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END</a>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsChildContentList)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   return tmp-&gt;HasKnownLiveWrapperAndDoesNotNeedTracing(tmp);</span>
<span class="lineNum">     533 </span>            : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
<a name="534"><span class="lineNum">     534 </span>            : </a>
<span class="lineNum">     535 </span>            : // CanSkipThis returns false to avoid problems with incomplete unlinking.
<span class="lineNum">     536 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsChildContentList)</span>
<a name="537"><span class="lineNum">     537 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END</span></a>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">         88 : NS_INTERFACE_TABLE_HEAD(nsChildContentList)</span>
<span class="lineNum">     540 </span><span class="lineCov">         88 :   NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY</span>
<span class="lineNum">     541 </span><span class="lineCov">         80 :   NS_INTERFACE_TABLE(nsChildContentList, nsINodeList, nsIDOMNodeList)</span>
<span class="lineNum">     542 </span><span class="lineCov">         80 :   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsChildContentList)</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 : NS_INTERFACE_MAP_END</span>
<a name="544"><span class="lineNum">     544 </span>            : </a>
<span class="lineNum">     545 </span>            : JSObject*
<span class="lineNum">     546 </span><span class="lineCov">          8 : nsChildContentList::WrapObject(JSContext *cx, JS::Handle&lt;JSObject*&gt; aGivenProto)</span>
<span class="lineNum">     547 </span>            : {
<span class="lineNum">     548 </span><span class="lineCov">          8 :   return NodeListBinding::Wrap(cx, this, aGivenProto);</span>
<span class="lineNum">     549 </span>            : }
<a name="550"><span class="lineNum">     550 </span>            : </a>
<span class="lineNum">     551 </span>            : NS_IMETHODIMP
<span class="lineNum">     552 </span><span class="lineCov">         38 : nsChildContentList::GetLength(uint32_t* aLength)</span>
<span class="lineNum">     553 </span>            : {
<span class="lineNum">     554 </span><span class="lineCov">         38 :   *aLength = mNode ? mNode-&gt;GetChildCount() : 0;</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineCov">         38 :   return NS_OK;</span>
<span class="lineNum">     557 </span>            : }
<a name="558"><span class="lineNum">     558 </span>            : </a>
<span class="lineNum">     559 </span>            : NS_IMETHODIMP
<span class="lineNum">     560 </span><span class="lineCov">          6 : nsChildContentList::Item(uint32_t aIndex, nsIDOMNode** aReturn)</span>
<span class="lineNum">     561 </span>            : {
<span class="lineNum">     562 </span><span class="lineCov">          6 :   nsINode* node = Item(aIndex);</span>
<span class="lineNum">     563 </span><span class="lineCov">          6 :   if (!node) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     *aReturn = nullptr;</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineCov">          6 :   return CallQueryInterface(node, aReturn);</span>
<span class="lineNum">     570 </span>            : }
<a name="571"><span class="lineNum">     571 </span>            : </a>
<span class="lineNum">     572 </span>            : nsIContent*
<span class="lineNum">     573 </span><span class="lineCov">         39 : nsChildContentList::Item(uint32_t aIndex)</span>
<span class="lineNum">     574 </span>            : {
<span class="lineNum">     575 </span><span class="lineCov">         39 :   if (mNode) {</span>
<span class="lineNum">     576 </span><span class="lineCov">         39 :     return mNode-&gt;GetChildAt(aIndex);</span>
<span class="lineNum">     577 </span>            :   }
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">     580 </span>            : }
<a name="581"><span class="lineNum">     581 </span>            : </a>
<span class="lineNum">     582 </span>            : int32_t
<span class="lineNum">     583 </span><span class="lineNoCov">          0 : nsChildContentList::IndexOf(nsIContent* aContent)</span>
<span class="lineNum">     584 </span>            : {
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   if (mNode) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     return mNode-&gt;IndexOf(aContent);</span>
<span class="lineNum">     587 </span>            :   }
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">     590 </span>            : }
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            : //----------------------------------------------------------------------
<a name="593"><span class="lineNum">     593 </span>            : </a>
<span class="lineNum">     594 </span>            : nsIHTMLCollection*
<span class="lineNum">     595 </span><span class="lineCov">          5 : FragmentOrElement::Children()</span>
<span class="lineNum">     596 </span>            : {
<span class="lineNum">     597 </span><span class="lineCov">          5 :   FragmentOrElement::nsDOMSlots *slots = DOMSlots();</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineCov">          5 :   if (!slots-&gt;mChildrenList) {</span>
<span class="lineNum">     600 </span>            :     slots-&gt;mChildrenList = new nsContentList(this, kNameSpaceID_Wildcard,
<span class="lineNum">     601 </span>            :                                              nsGkAtoms::_asterisk, nsGkAtoms::_asterisk,
<span class="lineNum">     602 </span><span class="lineCov">          5 :                                              false);</span>
<span class="lineNum">     603 </span>            :   }
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineCov">          5 :   return slots-&gt;mChildrenList;</span>
<span class="lineNum">     606 </span>            : }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : //----------------------------------------------------------------------
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineCov">        581 : NS_IMPL_ISUPPORTS(nsNodeWeakReference,</span>
<a name="613"><span class="lineNum">     613 </span>            :                   nsIWeakReference)</a>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">         26 : nsNodeWeakReference::~nsNodeWeakReference()</span>
<span class="lineNum">     616 </span>            : {
<span class="lineNum">     617 </span><span class="lineCov">         13 :   if (mNode) {</span>
<span class="lineNum">     618 </span><span class="lineCov">         13 :     NS_ASSERTION(mNode-&gt;Slots()-&gt;mWeakReference == this,</span>
<span class="lineNum">     619 </span>            :                  &quot;Weak reference has wrong value&quot;);
<span class="lineNum">     620 </span><span class="lineCov">         13 :     mNode-&gt;Slots()-&gt;mWeakReference = nullptr;</span>
<span class="lineNum">     621 </span>            :   }
<span class="lineNum">     622 </span><span class="lineCov">         13 : }</span>
<a name="623"><span class="lineNum">     623 </span>            : </a>
<span class="lineNum">     624 </span>            : NS_IMETHODIMP
<span class="lineNum">     625 </span><span class="lineCov">        258 : nsNodeWeakReference::QueryReferent(const nsIID&amp; aIID, void** aInstancePtr)</span>
<span class="lineNum">     626 </span>            : {
<span class="lineNum">     627 </span><span class="lineCov">        258 :   return mNode ? mNode-&gt;QueryInterface(aIID, aInstancePtr) :</span>
<span class="lineNum">     628 </span><span class="lineCov">        258 :                  NS_ERROR_NULL_POINTER;</span>
<span class="lineNum">     629 </span>            : }
<a name="630"><span class="lineNum">     630 </span>            : </a>
<span class="lineNum">     631 </span>            : size_t
<span class="lineNum">     632 </span><span class="lineNoCov">          0 : nsNodeWeakReference::SizeOfOnlyThis(mozilla::MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   return aMallocSizeOf(this);</span>
<span class="lineNum">     635 </span>            : }
<a name="636"><span class="lineNum">     636 </span>            : </a>
<span class="lineNum">     637 </span>            : 
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff, mNode)</span></a>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineCov">        675 : NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff)</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)</span>
<a name="642"><span class="lineNum">     642 </span><span class="lineNoCov">          0 : NS_INTERFACE_MAP_END_AGGREGATED(mNode)</span></a>
<a name="643"><span class="lineNum">     643 </span>            : </a>
<span class="lineNum">     644 </span><span class="lineCov">        135 : NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSupportsWeakRefTearoff)</span>
<span class="lineNum">     645 </span><span class="lineCov">        405 : NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSupportsWeakRefTearoff)</span>
<a name="646"><span class="lineNum">     646 </span>            : </a>
<span class="lineNum">     647 </span>            : NS_IMETHODIMP
<span class="lineNum">     648 </span><span class="lineCov">        135 : nsNodeSupportsWeakRefTearoff::GetWeakReference(nsIWeakReference** aInstancePtr)</span>
<span class="lineNum">     649 </span>            : {
<span class="lineNum">     650 </span><span class="lineCov">        135 :   nsINode::nsSlots* slots = mNode-&gt;Slots();</span>
<span class="lineNum">     651 </span><span class="lineCov">        135 :   if (!slots-&gt;mWeakReference) {</span>
<span class="lineNum">     652 </span><span class="lineCov">        222 :     slots-&gt;mWeakReference = new nsNodeWeakReference(mNode);</span>
<span class="lineNum">     653 </span>            :   }
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineCov">        135 :   NS_ADDREF(*aInstancePtr = slots-&gt;mWeakReference);</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineCov">        135 :   return NS_OK;</span>
<span class="lineNum">     658 </span>            : }
<a name="659"><span class="lineNum">     659 </span>            : </a>
<span class="lineNum">     660 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     661 </span><span class="lineCov">        981 : FragmentOrElement::nsDOMSlots::nsDOMSlots()</span>
<span class="lineNum">     662 </span>            :   : nsINode::nsSlots(),
<span class="lineNum">     663 </span>            :     mDataset(nullptr),
<span class="lineNum">     664 </span><span class="lineCov">        981 :     mBindingParent(nullptr)</span>
<span class="lineNum">     665 </span>            : {
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">        981 : }</span></a>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineCov">          3 : FragmentOrElement::nsDOMSlots::~nsDOMSlots()</span>
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span><span class="lineCov">          1 :   if (mAttributeMap) {</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     mAttributeMap-&gt;DropReference();</span>
<span class="lineNum">     672 </span>            :   }
<span class="lineNum">     673 </span><span class="lineCov">          3 : }</span>
<a name="674"><span class="lineNum">     674 </span>            : </a>
<span class="lineNum">     675 </span>            : void
<span class="lineNum">     676 </span><span class="lineCov">        290 : FragmentOrElement::nsDOMSlots::Traverse(nsCycleCollectionTraversalCallback &amp;cb, bool aIsXUL)</span>
<span class="lineNum">     677 </span>            : {
<span class="lineNum">     678 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mStyle&quot;);</span>
<span class="lineNum">     679 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(mStyle.get());</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mSMILOverrideStyle&quot;);</span>
<span class="lineNum">     682 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(mSMILOverrideStyle.get());</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mAttributeMap&quot;);</span>
<span class="lineNum">     685 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(mAttributeMap.get());</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineCov">        290 :   if (aIsXUL) {</span>
<span class="lineNum">     688 </span><span class="lineCov">        287 :     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mControllers&quot;);</span>
<span class="lineNum">     689 </span><span class="lineCov">        287 :     cb.NoteXPCOMChild(mControllers);</span>
<span class="lineNum">     690 </span>            :   }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mXBLBinding&quot;);</span>
<span class="lineNum">     693 </span><span class="lineCov">        290 :   cb.NoteNativeChild(mXBLBinding, NS_CYCLE_COLLECTION_PARTICIPANT(nsXBLBinding));</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mXBLInsertionParent&quot;);</span>
<span class="lineNum">     696 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(mXBLInsertionParent.get());</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mShadowRoot&quot;);</span>
<span class="lineNum">     699 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIContent*, mShadowRoot));</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mContainingShadow&quot;);</span>
<span class="lineNum">     702 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIContent*, mContainingShadow));</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mChildrenList&quot;);</span>
<span class="lineNum">     705 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIDOMNodeList*, mChildrenList));</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mLabelsList&quot;);</span>
<span class="lineNum">     708 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIDOMNodeList*, mLabelsList));</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineCov">        290 :   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mClassList&quot;);</span>
<span class="lineNum">     711 </span><span class="lineCov">        290 :   cb.NoteXPCOMChild(mClassList.get());</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">        290 :   if (mCustomElementData) {</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; mCustomElementData-&gt;mCallbackQueue.Length(); i++) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       mCustomElementData-&gt;mCallbackQueue[i]-&gt;Traverse(cb);</span>
<span class="lineNum">     716 </span>            :     }
<span class="lineNum">     717 </span>            :   }
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineCov">        290 :   for (auto iter = mRegisteredIntersectionObservers.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     DOMIntersectionObserver* observer = iter.Key();</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mSlots-&gt;mRegisteredIntersectionObservers[i]&quot;);</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     cb.NoteXPCOMChild(observer);</span>
<span class="lineNum">     723 </span>            :   }
<span class="lineNum">     724 </span><span class="lineCov">        290 : }</span>
<a name="725"><span class="lineNum">     725 </span>            : </a>
<span class="lineNum">     726 </span>            : void
<span class="lineNum">     727 </span><span class="lineNoCov">          0 : FragmentOrElement::nsDOMSlots::Unlink(bool aIsXUL)</span>
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   mStyle = nullptr;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   mSMILOverrideStyle = nullptr;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   if (mAttributeMap) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     mAttributeMap-&gt;DropReference();</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     mAttributeMap = nullptr;</span>
<span class="lineNum">     734 </span>            :   }
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   if (aIsXUL)</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     NS_IF_RELEASE(mControllers);</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mXBLBinding);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   mXBLInsertionParent = nullptr;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   mShadowRoot = nullptr;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   mContainingShadow = nullptr;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   mChildrenList = nullptr;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   mLabelsList = nullptr;</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   mCustomElementData = nullptr;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   mClassList = nullptr;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   mRegisteredIntersectionObservers.Clear();</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 : }</span>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            : size_t
<span class="lineNum">     751 </span><span class="lineCov">          5 : FragmentOrElement::nsDOMSlots::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">     752 </span>            : {
<span class="lineNum">     753 </span><span class="lineCov">          5 :   size_t n = aMallocSizeOf(this);</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">          5 :   if (mAttributeMap) {</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     n += mAttributeMap-&gt;SizeOfIncludingThis(aMallocSizeOf);</span>
<span class="lineNum">     757 </span>            :   }
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   // Measurement of the following members may be added later if DMD finds it is
<span class="lineNum">     760 </span>            :   // worthwhile:
<span class="lineNum">     761 </span>            :   // - Superclass members (nsINode::nsSlots)
<span class="lineNum">     762 </span>            :   // - mStyle
<span class="lineNum">     763 </span>            :   // - mDataSet
<span class="lineNum">     764 </span>            :   // - mSMILOverrideStyle
<span class="lineNum">     765 </span>            :   // - mSMILOverrideStyleDeclaration
<span class="lineNum">     766 </span>            :   // - mChildrenList
<span class="lineNum">     767 </span>            :   // - mClassList
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :   // The following members are not measured:
<span class="lineNum">     770 </span>            :   // - mBindingParent / mControllers: because they're   non-owning
<span class="lineNum">     771 </span><span class="lineCov">          5 :   return n;</span>
<a name="772"><span class="lineNum">     772 </span>            : }</a>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">       3168 : FragmentOrElement::FragmentOrElement(already_AddRefed&lt;mozilla::dom::NodeInfo&gt;&amp; aNodeInfo)</span>
<span class="lineNum">     775 </span><span class="lineCov">       3168 :   : nsIContent(aNodeInfo)</span>
<span class="lineNum">     776 </span>            : {
<a name="777"><span class="lineNum">     777 </span><span class="lineCov">       3168 : }</span></a>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineCov">          4 : FragmentOrElement::FragmentOrElement(already_AddRefed&lt;mozilla::dom::NodeInfo&gt;&amp;&amp; aNodeInfo)</span>
<span class="lineNum">     780 </span><span class="lineCov">          4 :   : nsIContent(aNodeInfo)</span>
<span class="lineNum">     781 </span>            : {
<a name="782"><span class="lineNum">     782 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">         64 : FragmentOrElement::~FragmentOrElement()</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span><span class="lineCov">         32 :   NS_PRECONDITION(!IsInUncomposedDoc(),</span>
<span class="lineNum">     787 </span>            :                   &quot;Please remove this from the document properly&quot;);
<span class="lineNum">     788 </span><span class="lineCov">         32 :   if (GetParent()) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     NS_RELEASE(mParent);</span>
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span><span class="lineCov">         32 : }</span>
<a name="792"><span class="lineNum">     792 </span>            : </a>
<span class="lineNum">     793 </span>            : already_AddRefed&lt;nsINodeList&gt;
<span class="lineNum">     794 </span><span class="lineNoCov">          0 : FragmentOrElement::GetChildren(uint32_t aFilter)</span>
<span class="lineNum">     795 </span>            : {
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsSimpleContentList&gt; list = new nsSimpleContentList(this);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :   AllChildrenIterator iter(this, aFilter);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   while (nsIContent* kid = iter.GetNextChild()) {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     list-&gt;AppendElement(kid);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   return list.forget();</span>
<span class="lineNum">     803 </span>            : }
<a name="804"><span class="lineNum">     804 </span>            : </a>
<span class="lineNum">     805 </span>            : static nsIContent*
<span class="lineNum">     806 </span><span class="lineNoCov">          0 : FindChromeAccessOnlySubtreeOwner(nsIContent* aContent)</span>
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   if (aContent-&gt;ChromeOnlyAccess()) {</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     bool chromeAccessOnly = false;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     while (aContent &amp;&amp; !chromeAccessOnly) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :       chromeAccessOnly = aContent-&gt;IsRootOfChromeAccessOnlySubtree();</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       aContent = aContent-&gt;GetParent();</span>
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span>            :   }
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   return aContent;</span>
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : nsresult
<span class="lineNum">     819 </span><span class="lineCov">       1404 : nsIContent::GetEventTargetParent(EventChainPreVisitor&amp; aVisitor)</span>
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span>            :   //FIXME! Document how this event retargeting works, Bug 329124.
<span class="lineNum">     822 </span><span class="lineCov">       1404 :   aVisitor.mCanHandle = true;</span>
<span class="lineNum">     823 </span><span class="lineCov">       1404 :   aVisitor.mMayHaveListenerManager = HasListenerManager();</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :   // Don't propagate mouseover and mouseout events when mouse is moving
<span class="lineNum">     826 </span>            :   // inside chrome access only content.
<span class="lineNum">     827 </span><span class="lineCov">       1404 :   bool isAnonForEvents = IsRootOfChromeAccessOnlySubtree();</span>
<span class="lineNum">     828 </span><span class="lineCov">       4198 :   if ((aVisitor.mEvent-&gt;mMessage == eMouseOver ||</span>
<span class="lineNum">     829 </span><span class="lineCov">       2766 :        aVisitor.mEvent-&gt;mMessage == eMouseOut ||</span>
<span class="lineNum">     830 </span><span class="lineCov">       2738 :        aVisitor.mEvent-&gt;mMessage == ePointerOver ||</span>
<span class="lineNum">     831 </span><span class="lineCov">       2826 :        aVisitor.mEvent-&gt;mMessage == ePointerOut) &amp;&amp;</span>
<span class="lineNum">     832 </span>            :       // Check if we should stop event propagation when event has just been
<span class="lineNum">     833 </span>            :       // dispatched or when we're about to propagate from
<span class="lineNum">     834 </span>            :       // chrome access only subtree or if we are about to propagate out of
<span class="lineNum">     835 </span>            :       // a shadow root to a shadow root host.
<span class="lineNum">     836 </span><span class="lineCov">         60 :       ((this == aVisitor.mEvent-&gt;mOriginalTarget &amp;&amp;</span>
<span class="lineNum">     837 </span><span class="lineCov">         56 :         !ChromeOnlyAccess()) || isAnonForEvents || GetShadowRoot())) {</span>
<span class="lineNum">     838 </span>            :      nsCOMPtr&lt;nsIContent&gt; relatedTarget =
<span class="lineNum">     839 </span><span class="lineCov">          8 :        do_QueryInterface(aVisitor.mEvent-&gt;AsMouseEvent()-&gt;relatedTarget);</span>
<span class="lineNum">     840 </span><span class="lineCov">          4 :     if (relatedTarget &amp;&amp;</span>
<span class="lineNum">     841 </span><span class="lineCov">          4 :         relatedTarget-&gt;OwnerDoc() == OwnerDoc()) {</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :       // In the web components case, we may need to stop propagation of events
<span class="lineNum">     844 </span>            :       // at shadow root host.
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :       if (GetShadowRoot()) {</span>
<span class="lineNum">     846 </span>            :         nsIContent* adjustedTarget =
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :           Event::GetShadowRelatedTarget(this, relatedTarget);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         if (this == adjustedTarget) {</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :           aVisitor.mParentTarget = nullptr;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :           aVisitor.mCanHandle = false;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :           return NS_OK;</span>
<span class="lineNum">     852 </span>            :         }
<span class="lineNum">     853 </span>            :       }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :       // If current target is anonymous for events or we know that related
<span class="lineNum">     856 </span>            :       // target is descendant of an element which is anonymous for events,
<span class="lineNum">     857 </span>            :       // we may want to stop event propagation.
<span class="lineNum">     858 </span>            :       // If this is the original target, aVisitor.mRelatedTargetIsInAnon
<span class="lineNum">     859 </span>            :       // must be updated.
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       if (isAnonForEvents || aVisitor.mRelatedTargetIsInAnon ||</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :           (aVisitor.mEvent-&gt;mOriginalTarget == this &amp;&amp;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :            (aVisitor.mRelatedTargetIsInAnon =</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :             relatedTarget-&gt;ChromeOnlyAccess()))) {</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         nsIContent* anonOwner = FindChromeAccessOnlySubtreeOwner(this);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :         if (anonOwner) {</span>
<span class="lineNum">     866 </span>            :           nsIContent* anonOwnerRelated =
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :             FindChromeAccessOnlySubtreeOwner(relatedTarget);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :           if (anonOwnerRelated) {</span>
<span class="lineNum">     869 </span>            :             // Note, anonOwnerRelated may still be inside some other
<span class="lineNum">     870 </span>            :             // native anonymous subtree. The case where anonOwner is still
<span class="lineNum">     871 </span>            :             // inside native anonymous subtree will be handled when event
<span class="lineNum">     872 </span>            :             // propagates up in the DOM tree.
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :             while (anonOwner != anonOwnerRelated &amp;&amp;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                    anonOwnerRelated-&gt;ChromeOnlyAccess()) {</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :               anonOwnerRelated = FindChromeAccessOnlySubtreeOwner(anonOwnerRelated);</span>
<span class="lineNum">     876 </span>            :             }
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :             if (anonOwner == anonOwnerRelated) {</span>
<span class="lineNum">     878 </span>            : #ifdef DEBUG_smaug
<span class="lineNum">     879 </span>            :               nsCOMPtr&lt;nsIContent&gt; originalTarget =
<span class="lineNum">     880 </span>            :                 do_QueryInterface(aVisitor.mEvent-&gt;mOriginalTarget);
<span class="lineNum">     881 </span>            :               nsAutoString ot, ct, rt;
<span class="lineNum">     882 </span>            :               if (originalTarget) {
<span class="lineNum">     883 </span>            :                 originalTarget-&gt;NodeInfo()-&gt;NameAtom()-&gt;ToString(ot);
<span class="lineNum">     884 </span>            :               }
<span class="lineNum">     885 </span>            :               NodeInfo()-&gt;NameAtom()-&gt;ToString(ct);
<span class="lineNum">     886 </span>            :               relatedTarget-&gt;NodeInfo()-&gt;NameAtom()-&gt;ToString(rt);
<span class="lineNum">     887 </span>            :               printf(&quot;Stopping %s propagation:&quot;
<span class="lineNum">     888 </span>            :                      &quot;\n\toriginalTarget=%s \n\tcurrentTarget=%s %s&quot;
<span class="lineNum">     889 </span>            :                      &quot;\n\trelatedTarget=%s %s \n%s&quot;,
<span class="lineNum">     890 </span>            :                      (aVisitor.mEvent-&gt;mMessage == eMouseOver)
<span class="lineNum">     891 </span>            :                        ? &quot;mouseover&quot; : &quot;mouseout&quot;,
<span class="lineNum">     892 </span>            :                      NS_ConvertUTF16toUTF8(ot).get(),
<span class="lineNum">     893 </span>            :                      NS_ConvertUTF16toUTF8(ct).get(),
<span class="lineNum">     894 </span>            :                      isAnonForEvents
<span class="lineNum">     895 </span>            :                        ? &quot;(is native anonymous)&quot;
<span class="lineNum">     896 </span>            :                        : (ChromeOnlyAccess()
<span class="lineNum">     897 </span>            :                            ? &quot;(is in native anonymous subtree)&quot; : &quot;&quot;),
<span class="lineNum">     898 </span>            :                      NS_ConvertUTF16toUTF8(rt).get(),
<span class="lineNum">     899 </span>            :                      relatedTarget-&gt;ChromeOnlyAccess()
<span class="lineNum">     900 </span>            :                        ? &quot;(is in native anonymous subtree)&quot; : &quot;&quot;,
<span class="lineNum">     901 </span>            :                      (originalTarget &amp;&amp;
<span class="lineNum">     902 </span>            :                       relatedTarget-&gt;FindFirstNonChromeOnlyAccessContent() ==
<span class="lineNum">     903 </span>            :                         originalTarget-&gt;FindFirstNonChromeOnlyAccessContent())
<span class="lineNum">     904 </span>            :                        ? &quot;&quot; : &quot;Wrong event propagation!?!\n&quot;);
<span class="lineNum">     905 </span>            : #endif
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :               aVisitor.mParentTarget = nullptr;</span>
<span class="lineNum">     907 </span>            :               // Event should not propagate to non-anon content.
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :               aVisitor.mCanHandle = isAnonForEvents;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :               return NS_OK;</span>
<span class="lineNum">     910 </span>            :             }
<span class="lineNum">     911 </span>            :           }
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span>            :       }
<span class="lineNum">     914 </span>            :     }
<span class="lineNum">     915 </span>            :   }
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineCov">       1404 :   nsIContent* parent = GetParent();</span>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            :   // Web components have a special event chain that need to account
<span class="lineNum">     920 </span>            :   // for destination insertion points where nodes have been distributed.
<span class="lineNum">     921 </span><span class="lineCov">       1404 :   nsTArray&lt;nsIContent*&gt;* destPoints = GetExistingDestInsertionPoints();</span>
<span class="lineNum">     922 </span><span class="lineCov">       1404 :   if (destPoints &amp;&amp; !destPoints-&gt;IsEmpty()) {</span>
<span class="lineNum">     923 </span>            :     // Push destination insertion points to aVisitor.mDestInsertionPoints
<span class="lineNum">     924 </span>            :     // excluding shadow insertion points.
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     bool didPushNonShadowInsertionPoint = false;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; destPoints-&gt;Length(); i++) {</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       nsIContent* point = destPoints-&gt;ElementAt(i);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :       if (!ShadowRoot::IsShadowInsertionPoint(point)) {</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :         aVisitor.mDestInsertionPoints.AppendElement(point);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         didPushNonShadowInsertionPoint = true;</span>
<span class="lineNum">     931 </span>            :       }
<span class="lineNum">     932 </span>            :     }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     // Next node in the event path is the final destination
<span class="lineNum">     935 </span>            :     // (non-shadow) insertion point that was pushed.
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     if (didPushNonShadowInsertionPoint) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       parent = aVisitor.mDestInsertionPoints.LastElement();</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :       aVisitor.mDestInsertionPoints.SetLength(</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         aVisitor.mDestInsertionPoints.Length() - 1);</span>
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span>            :   }
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineCov">       1404 :   ShadowRoot* thisShadowRoot = ShadowRoot::FromNode(this);</span>
<span class="lineNum">     944 </span><span class="lineCov">       1404 :   if (thisShadowRoot) {</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     if (!aVisitor.mEvent-&gt;mFlags.mComposed) {</span>
<span class="lineNum">     946 </span>            :       // If we do stop propagation, we still want to propagate
<span class="lineNum">     947 </span>            :       // the event to chrome (nsPIDOMWindow::GetParentTarget()).
<span class="lineNum">     948 </span>            :       // The load event is special in that we don't ever propagate it
<span class="lineNum">     949 </span>            :       // to chrome.
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :       nsCOMPtr&lt;nsPIDOMWindowOuter&gt; win = OwnerDoc()-&gt;GetWindow();</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       EventTarget* parentTarget = win &amp;&amp; aVisitor.mEvent-&gt;mMessage != eLoad</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         ? win-&gt;GetParentTarget() : nullptr;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :       aVisitor.mParentTarget = parentTarget;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     if (!aVisitor.mDestInsertionPoints.IsEmpty()) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       parent = aVisitor.mDestInsertionPoints.LastElement();</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       aVisitor.mDestInsertionPoints.SetLength(</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         aVisitor.mDestInsertionPoints.Length() - 1);</span>
<span class="lineNum">     962 </span>            :     } else {
<span class="lineNum">     963 </span>            :       // The pool host for the youngest shadow root is shadow DOM host,
<span class="lineNum">     964 </span>            :       // for older shadow roots, it is the shadow insertion point
<span class="lineNum">     965 </span>            :       // where the shadow root is projected, nullptr if none exists.
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :       parent = thisShadowRoot-&gt;GetPoolHost();</span>
<span class="lineNum">     967 </span>            :     }
<span class="lineNum">     968 </span>            :   }
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :   // Event may need to be retargeted if this is the root of a native
<span class="lineNum">     971 </span>            :   // anonymous content subtree or event is dispatched somewhere inside XBL.
<span class="lineNum">     972 </span><span class="lineCov">       1404 :   if (isAnonForEvents) {</span>
<span class="lineNum">     973 </span>            : #ifdef DEBUG
<span class="lineNum">     974 </span>            :     // If a DOM event is explicitly dispatched using node.dispatchEvent(), then
<span class="lineNum">     975 </span>            :     // all the events are allowed even in the native anonymous content..
<span class="lineNum">     976 </span>            :     nsCOMPtr&lt;nsIContent&gt; t =
<span class="lineNum">     977 </span><span class="lineCov">          2 :       do_QueryInterface(aVisitor.mEvent-&gt;mOriginalTarget);</span>
<span class="lineNum">     978 </span><span class="lineCov">          1 :     NS_ASSERTION(!t || !t-&gt;ChromeOnlyAccess() ||</span>
<span class="lineNum">     979 </span>            :                  aVisitor.mEvent-&gt;mClass != eMutationEventClass ||
<span class="lineNum">     980 </span>            :                  aVisitor.mDOMEvent,
<span class="lineNum">     981 </span>            :                  &quot;Mutation event dispatched in native anonymous content!?!&quot;);
<span class="lineNum">     982 </span>            : #endif
<span class="lineNum">     983 </span><span class="lineCov">          1 :     aVisitor.mEventTargetAtParent = parent;</span>
<span class="lineNum">     984 </span><span class="lineCov">       1403 :   } else if (parent &amp;&amp; aVisitor.mOriginalTargetIsInAnon) {</span>
<span class="lineNum">     985 </span><span class="lineCov">       1470 :     nsCOMPtr&lt;nsIContent&gt; content(do_QueryInterface(aVisitor.mEvent-&gt;mTarget));</span>
<span class="lineNum">     986 </span><span class="lineCov">        735 :     if (content &amp;&amp; content-&gt;GetBindingParent() == parent) {</span>
<span class="lineNum">     987 </span><span class="lineCov">         90 :       aVisitor.mEventTargetAtParent = parent;</span>
<span class="lineNum">     988 </span>            :     }
<span class="lineNum">     989 </span>            :   }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :   // check for an anonymous parent
<span class="lineNum">     992 </span>            :   // XXX XBL2/sXBL issue
<span class="lineNum">     993 </span><span class="lineCov">       1404 :   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {</span>
<span class="lineNum">     994 </span><span class="lineCov">        780 :     nsIContent* insertionParent = GetXBLInsertionParent();</span>
<span class="lineNum">     995 </span><span class="lineCov">        780 :     NS_ASSERTION(!(aVisitor.mEventTargetAtParent &amp;&amp; insertionParent &amp;&amp;</span>
<span class="lineNum">     996 </span>            :                    aVisitor.mEventTargetAtParent != insertionParent),
<span class="lineNum">     997 </span>            :                  &quot;Retargeting and having insertion parent!&quot;);
<span class="lineNum">     998 </span><span class="lineCov">        780 :     if (insertionParent) {</span>
<span class="lineNum">     999 </span><span class="lineCov">         68 :       parent = insertionParent;</span>
<span class="lineNum">    1000 </span>            :     }
<span class="lineNum">    1001 </span>            :   }
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">       3476 :   if (!aVisitor.mEvent-&gt;mFlags.mComposedInNativeAnonymousContent &amp;&amp;</span>
<span class="lineNum">    1004 </span><span class="lineCov">       1404 :       IsRootOfNativeAnonymousSubtree() &amp;&amp; OwnerDoc() &amp;&amp;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :       OwnerDoc()-&gt;GetWindow()) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     aVisitor.mParentTarget = OwnerDoc()-&gt;GetWindow()-&gt;GetParentTarget();</span>
<span class="lineNum">    1007 </span><span class="lineCov">       1404 :   } else if (parent) {</span>
<span class="lineNum">    1008 </span><span class="lineCov">       1225 :     aVisitor.mParentTarget = parent;</span>
<span class="lineNum">    1009 </span>            :   } else {
<span class="lineNum">    1010 </span><span class="lineCov">        179 :     aVisitor.mParentTarget = GetComposedDoc();</span>
<span class="lineNum">    1011 </span>            :   }
<span class="lineNum">    1012 </span><span class="lineCov">       1404 :   return NS_OK;</span>
<span class="lineNum">    1013 </span>            : }
<a name="1014"><span class="lineNum">    1014 </span>            : </a>
<span class="lineNum">    1015 </span>            : bool
<span class="lineNum">    1016 </span><span class="lineCov">      12142 : nsIContent::GetAttr(int32_t aNameSpaceID, nsIAtom* aName,</span>
<span class="lineNum">    1017 </span>            :                     nsAString&amp; aResult) const
<span class="lineNum">    1018 </span>            : {
<span class="lineNum">    1019 </span><span class="lineCov">      12142 :   if (IsElement()) {</span>
<span class="lineNum">    1020 </span><span class="lineCov">      12136 :     return AsElement()-&gt;GetAttr(aNameSpaceID, aName, aResult);</span>
<span class="lineNum">    1021 </span>            :   }
<span class="lineNum">    1022 </span><span class="lineCov">          6 :   aResult.Truncate();</span>
<span class="lineNum">    1023 </span><span class="lineCov">          6 :   return false;</span>
<span class="lineNum">    1024 </span>            : }
<a name="1025"><span class="lineNum">    1025 </span>            : </a>
<span class="lineNum">    1026 </span>            : bool
<span class="lineNum">    1027 </span><span class="lineCov">       5473 : nsIContent::HasAttr(int32_t aNameSpaceID, nsIAtom* aName) const</span>
<span class="lineNum">    1028 </span>            : {
<span class="lineNum">    1029 </span><span class="lineCov">       5473 :   return IsElement() &amp;&amp; AsElement()-&gt;HasAttr(aNameSpaceID, aName);</span>
<span class="lineNum">    1030 </span>            : }
<a name="1031"><span class="lineNum">    1031 </span>            : </a>
<span class="lineNum">    1032 </span>            : bool
<span class="lineNum">    1033 </span><span class="lineCov">        231 : nsIContent::AttrValueIs(int32_t aNameSpaceID,</span>
<span class="lineNum">    1034 </span>            :                         nsIAtom* aName,
<span class="lineNum">    1035 </span>            :                         const nsAString&amp; aValue,
<span class="lineNum">    1036 </span>            :                         nsCaseTreatment aCaseSensitive) const
<span class="lineNum">    1037 </span>            : {
<span class="lineNum">    1038 </span><span class="lineCov">        453 :   return IsElement() &amp;&amp;</span>
<span class="lineNum">    1039 </span><span class="lineCov">        453 :     AsElement()-&gt;AttrValueIs(aNameSpaceID, aName, aValue, aCaseSensitive);</span>
<span class="lineNum">    1040 </span>            : }
<a name="1041"><span class="lineNum">    1041 </span>            : </a>
<span class="lineNum">    1042 </span>            : bool
<span class="lineNum">    1043 </span><span class="lineCov">       1188 : nsIContent::AttrValueIs(int32_t aNameSpaceID,</span>
<span class="lineNum">    1044 </span>            :                         nsIAtom* aName,
<span class="lineNum">    1045 </span>            :                         nsIAtom* aValue,
<span class="lineNum">    1046 </span>            :                         nsCaseTreatment aCaseSensitive) const
<span class="lineNum">    1047 </span>            : {
<span class="lineNum">    1048 </span><span class="lineCov">       2376 :   return IsElement() &amp;&amp;</span>
<span class="lineNum">    1049 </span><span class="lineCov">       2376 :     AsElement()-&gt;AttrValueIs(aNameSpaceID, aName, aValue, aCaseSensitive);</span>
<span class="lineNum">    1050 </span>            : }
<a name="1051"><span class="lineNum">    1051 </span>            : </a>
<span class="lineNum">    1052 </span>            : bool
<span class="lineNum">    1053 </span><span class="lineCov">          3 : nsIContent::IsFocusable(int32_t* aTabIndex, bool aWithMouse)</span>
<span class="lineNum">    1054 </span>            : {
<span class="lineNum">    1055 </span><span class="lineCov">          3 :   bool focusable = IsFocusableInternal(aTabIndex, aWithMouse);</span>
<span class="lineNum">    1056 </span>            :   // Ensure that the return value and aTabIndex are consistent in the case
<span class="lineNum">    1057 </span>            :   // we're in userfocusignored context.
<span class="lineNum">    1058 </span><span class="lineCov">          3 :   if (focusable || (aTabIndex &amp;&amp; *aTabIndex != -1)) {</span>
<span class="lineNum">    1059 </span><span class="lineCov">          3 :     if (nsContentUtils::IsUserFocusIgnored(this)) {</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :       if (aTabIndex) {</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         *aTabIndex = -1;</span>
<span class="lineNum">    1062 </span>            :       }
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1064 </span>            :     }
<span class="lineNum">    1065 </span><span class="lineCov">          3 :     return focusable;</span>
<span class="lineNum">    1066 </span>            :   }
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1068 </span>            : }
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<span class="lineNum">    1070 </span>            : bool
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 : nsIContent::IsFocusableInternal(int32_t* aTabIndex, bool aWithMouse)</span>
<span class="lineNum">    1072 </span>            : {
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   if (aTabIndex) {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     *aTabIndex = -1; // Default, not tabbable</span>
<span class="lineNum">    1075 </span>            :   }
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1077 </span>            : }
<a name="1078"><span class="lineNum">    1078 </span>            : </a>
<span class="lineNum">    1079 </span>            : NS_IMETHODIMP
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 : FragmentOrElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)</span>
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1083 </span>            : }
<a name="1084"><span class="lineNum">    1084 </span>            : </a>
<span class="lineNum">    1085 </span>            : bool
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 : FragmentOrElement::IsLink(nsIURI** aURI) const</span>
<span class="lineNum">    1087 </span>            : {
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   *aURI = nullptr;</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1090 </span>            : }
<a name="1091"><span class="lineNum">    1091 </span>            : </a>
<span class="lineNum">    1092 </span>            : nsIContent*
<span class="lineNum">    1093 </span><span class="lineCov">      15726 : FragmentOrElement::GetBindingParent() const</span>
<span class="lineNum">    1094 </span>            : {
<span class="lineNum">    1095 </span><span class="lineCov">      15726 :   nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineCov">      15726 :   if (slots) {</span>
<span class="lineNum">    1098 </span><span class="lineCov">       3090 :     return slots-&gt;mBindingParent;</span>
<span class="lineNum">    1099 </span>            :   }
<span class="lineNum">    1100 </span><span class="lineCov">      12636 :   return nullptr;</span>
<span class="lineNum">    1101 </span>            : }
<a name="1102"><span class="lineNum">    1102 </span>            : </a>
<span class="lineNum">    1103 </span>            : nsXBLBinding*
<span class="lineNum">    1104 </span><span class="lineCov">      11149 : FragmentOrElement::GetXBLBinding() const</span>
<span class="lineNum">    1105 </span>            : {
<span class="lineNum">    1106 </span><span class="lineCov">      11149 :   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {</span>
<span class="lineNum">    1107 </span><span class="lineCov">       6580 :     nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1108 </span><span class="lineCov">       6580 :     if (slots) {</span>
<span class="lineNum">    1109 </span><span class="lineCov">       6580 :       return slots-&gt;mXBLBinding;</span>
<span class="lineNum">    1110 </span>            :     }
<span class="lineNum">    1111 </span>            :   }
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">       4569 :   return nullptr;</span>
<span class="lineNum">    1114 </span>            : }
<a name="1115"><span class="lineNum">    1115 </span>            : </a>
<span class="lineNum">    1116 </span>            : void
<span class="lineNum">    1117 </span><span class="lineCov">        284 : FragmentOrElement::SetXBLBinding(nsXBLBinding* aBinding,</span>
<span class="lineNum">    1118 </span>            :                                  nsBindingManager* aOldBindingManager)
<span class="lineNum">    1119 </span>            : {
<span class="lineNum">    1120 </span>            :   nsBindingManager* bindingManager;
<span class="lineNum">    1121 </span><span class="lineCov">        284 :   if (aOldBindingManager) {</span>
<span class="lineNum">    1122 </span><span class="lineCov">          7 :     MOZ_ASSERT(!aBinding, &quot;aOldBindingManager should only be provided &quot;</span>
<span class="lineNum">    1123 </span>            :                           &quot;when removing a binding.&quot;);
<span class="lineNum">    1124 </span><span class="lineCov">          7 :     bindingManager = aOldBindingManager;</span>
<span class="lineNum">    1125 </span>            :   } else {
<span class="lineNum">    1126 </span><span class="lineCov">        277 :     bindingManager = OwnerDoc()-&gt;BindingManager();</span>
<span class="lineNum">    1127 </span>            :   }
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span>            :   // After this point, aBinding will be the most-derived binding for aContent.
<span class="lineNum">    1130 </span>            :   // If we already have a binding for aContent, make sure to
<span class="lineNum">    1131 </span>            :   // remove it from the attached stack.  Otherwise we might end up firing its
<span class="lineNum">    1132 </span>            :   // constructor twice (if aBinding inherits from it) or firing its constructor
<span class="lineNum">    1133 </span>            :   // after aContent has been deleted (if aBinding is null and the content node
<span class="lineNum">    1134 </span>            :   // dies before we process mAttachedStack).
<span class="lineNum">    1135 </span><span class="lineCov">        568 :   RefPtr&lt;nsXBLBinding&gt; oldBinding = GetXBLBinding();</span>
<span class="lineNum">    1136 </span><span class="lineCov">        284 :   if (oldBinding) {</span>
<span class="lineNum">    1137 </span><span class="lineCov">         12 :     bindingManager-&gt;RemoveFromAttachedQueue(oldBinding);</span>
<span class="lineNum">    1138 </span>            :   }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineCov">        284 :   if (aBinding) {</span>
<span class="lineNum">    1141 </span><span class="lineCov">        272 :     SetFlags(NODE_MAY_BE_IN_BINDING_MNGR);</span>
<span class="lineNum">    1142 </span><span class="lineCov">        272 :     nsDOMSlots *slots = DOMSlots();</span>
<span class="lineNum">    1143 </span><span class="lineCov">        272 :     slots-&gt;mXBLBinding = aBinding;</span>
<span class="lineNum">    1144 </span><span class="lineCov">        272 :     bindingManager-&gt;AddBoundContent(this);</span>
<span class="lineNum">    1145 </span>            :   } else {
<span class="lineNum">    1146 </span><span class="lineCov">         12 :     nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1147 </span><span class="lineCov">         12 :     if (slots) {</span>
<span class="lineNum">    1148 </span><span class="lineCov">         12 :       slots-&gt;mXBLBinding = nullptr;</span>
<span class="lineNum">    1149 </span>            :     }
<span class="lineNum">    1150 </span><span class="lineCov">         12 :     bindingManager-&gt;RemoveBoundContent(this);</span>
<span class="lineNum">    1151 </span><span class="lineCov">         12 :     if (oldBinding) {</span>
<span class="lineNum">    1152 </span><span class="lineCov">         12 :       oldBinding-&gt;SetBoundElement(nullptr);</span>
<span class="lineNum">    1153 </span>            :     }
<span class="lineNum">    1154 </span>            :   }
<span class="lineNum">    1155 </span><span class="lineCov">        284 : }</span>
<a name="1156"><span class="lineNum">    1156 </span>            : </a>
<span class="lineNum">    1157 </span>            : nsIContent*
<span class="lineNum">    1158 </span><span class="lineCov">       4786 : FragmentOrElement::GetXBLInsertionParent() const</span>
<span class="lineNum">    1159 </span>            : {
<span class="lineNum">    1160 </span><span class="lineCov">       4786 :   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {</span>
<span class="lineNum">    1161 </span><span class="lineCov">       4693 :     nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1162 </span><span class="lineCov">       4693 :     if (slots) {</span>
<span class="lineNum">    1163 </span><span class="lineCov">       4693 :       return slots-&gt;mXBLInsertionParent;</span>
<span class="lineNum">    1164 </span>            :     }
<span class="lineNum">    1165 </span>            :   }
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineCov">         93 :   return nullptr;</span>
<span class="lineNum">    1168 </span>            : }
<a name="1169"><span class="lineNum">    1169 </span>            : </a>
<span class="lineNum">    1170 </span>            : ShadowRoot*
<span class="lineNum">    1171 </span><span class="lineCov">       7177 : FragmentOrElement::GetContainingShadow() const</span>
<span class="lineNum">    1172 </span>            : {
<span class="lineNum">    1173 </span><span class="lineCov">       7177 :   nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1174 </span><span class="lineCov">       7177 :   if (slots) {</span>
<span class="lineNum">    1175 </span><span class="lineCov">        553 :     return slots-&gt;mContainingShadow;</span>
<span class="lineNum">    1176 </span>            :   }
<span class="lineNum">    1177 </span><span class="lineCov">       6624 :   return nullptr;</span>
<span class="lineNum">    1178 </span>            : }
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<span class="lineNum">    1180 </span>            : void
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : FragmentOrElement::SetShadowRoot(ShadowRoot* aShadowRoot)</span>
<span class="lineNum">    1182 </span>            : {
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :   nsDOMSlots *slots = DOMSlots();</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   slots-&gt;mShadowRoot = aShadowRoot;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 : }</span>
<a name="1186"><span class="lineNum">    1186 </span>            : </a>
<span class="lineNum">    1187 </span>            : nsTArray&lt;nsIContent*&gt;&amp;
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 : FragmentOrElement::DestInsertionPoints()</span>
<span class="lineNum">    1189 </span>            : {
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :   nsDOMSlots *slots = DOMSlots();</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :   return slots-&gt;mDestInsertionPoints;</span>
<span class="lineNum">    1192 </span>            : }
<a name="1193"><span class="lineNum">    1193 </span>            : </a>
<span class="lineNum">    1194 </span>            : nsTArray&lt;nsIContent*&gt;*
<span class="lineNum">    1195 </span><span class="lineCov">       1398 : FragmentOrElement::GetExistingDestInsertionPoints() const</span>
<span class="lineNum">    1196 </span>            : {
<span class="lineNum">    1197 </span><span class="lineCov">       1398 :   nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1198 </span><span class="lineCov">       1398 :   if (slots) {</span>
<span class="lineNum">    1199 </span><span class="lineCov">        852 :     return &amp;slots-&gt;mDestInsertionPoints;</span>
<span class="lineNum">    1200 </span>            :   }
<span class="lineNum">    1201 </span><span class="lineCov">        546 :   return nullptr;</span>
<span class="lineNum">    1202 </span>            : }
<a name="1203"><span class="lineNum">    1203 </span>            : </a>
<span class="lineNum">    1204 </span>            : void
<span class="lineNum">    1205 </span><span class="lineCov">        496 : FragmentOrElement::SetXBLInsertionParent(nsIContent* aContent)</span>
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span><span class="lineCov">        496 :   if (aContent) {</span>
<span class="lineNum">    1208 </span><span class="lineCov">        429 :     nsDOMSlots *slots = DOMSlots();</span>
<span class="lineNum">    1209 </span><span class="lineCov">        429 :     SetFlags(NODE_MAY_BE_IN_BINDING_MNGR);</span>
<span class="lineNum">    1210 </span><span class="lineCov">        429 :     slots-&gt;mXBLInsertionParent = aContent;</span>
<span class="lineNum">    1211 </span>            :   } else {
<span class="lineNum">    1212 </span><span class="lineCov">         67 :     nsDOMSlots *slots = GetExistingDOMSlots();</span>
<span class="lineNum">    1213 </span><span class="lineCov">         67 :     if (slots) {</span>
<span class="lineNum">    1214 </span><span class="lineCov">         30 :       slots-&gt;mXBLInsertionParent = nullptr;</span>
<span class="lineNum">    1215 </span>            :     }
<span class="lineNum">    1216 </span>            :   }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :   // We just changed the flattened tree, so any Servo style data is now invalid.
<span class="lineNum">    1219 </span>            :   // We rely on nsXBLService::LoadBindings to re-traverse the subtree afterwards.
<span class="lineNum">    1220 </span><span class="lineCov">        496 :   if (IsStyledByServo() &amp;&amp; IsElement() &amp;&amp; AsElement()-&gt;HasServoData()) {</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     ServoRestyleManager::ClearServoDataFromSubtree(AsElement());</span>
<span class="lineNum">    1222 </span>            :   }
<span class="lineNum">    1223 </span><span class="lineCov">        496 : }</span>
<a name="1224"><span class="lineNum">    1224 </span>            : </a>
<span class="lineNum">    1225 </span>            : nsresult
<span class="lineNum">    1226 </span><span class="lineCov">       3330 : FragmentOrElement::InsertChildAt(nsIContent* aKid,</span>
<span class="lineNum">    1227 </span>            :                                 uint32_t aIndex,
<span class="lineNum">    1228 </span>            :                                 bool aNotify)
<span class="lineNum">    1229 </span>            : {
<span class="lineNum">    1230 </span><span class="lineCov">       3330 :   NS_PRECONDITION(aKid, &quot;null ptr&quot;);</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineCov">       3330 :   return doInsertChildAt(aKid, aIndex, aNotify, mAttrsAndChildren);</span>
<span class="lineNum">    1233 </span>            : }
<a name="1234"><span class="lineNum">    1234 </span>            : </a>
<span class="lineNum">    1235 </span>            : void
<span class="lineNum">    1236 </span><span class="lineCov">        109 : FragmentOrElement::RemoveChildAt(uint32_t aIndex, bool aNotify)</span>
<span class="lineNum">    1237 </span>            : {
<span class="lineNum">    1238 </span><span class="lineCov">        218 :   nsCOMPtr&lt;nsIContent&gt; oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);</span>
<span class="lineNum">    1239 </span><span class="lineCov">        109 :   NS_ASSERTION(oldKid == GetChildAt(aIndex), &quot;Unexpected child in RemoveChildAt&quot;);</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineCov">        109 :   if (oldKid) {</span>
<span class="lineNum">    1242 </span><span class="lineCov">        109 :     doRemoveChildAt(aIndex, aNotify, oldKid, mAttrsAndChildren);</span>
<span class="lineNum">    1243 </span>            :   }
<span class="lineNum">    1244 </span><span class="lineCov">        109 : }</span>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<span class="lineNum">    1246 </span>            : void
<span class="lineNum">    1247 </span><span class="lineCov">          2 : FragmentOrElement::GetTextContentInternal(nsAString&amp; aTextContent,</span>
<span class="lineNum">    1248 </span>            :                                           OOMReporter&amp; aError)
<span class="lineNum">    1249 </span>            : {
<span class="lineNum">    1250 </span><span class="lineCov">          2 :   if (!nsContentUtils::GetNodeTextContent(this, true, aTextContent, fallible)) {</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     aError.ReportOOM();</span>
<span class="lineNum">    1252 </span>            :   }
<span class="lineNum">    1253 </span><span class="lineCov">          2 : }</span>
<a name="1254"><span class="lineNum">    1254 </span>            : </a>
<span class="lineNum">    1255 </span>            : void
<span class="lineNum">    1256 </span><span class="lineCov">          2 : FragmentOrElement::SetTextContentInternal(const nsAString&amp; aTextContent,</span>
<span class="lineNum">    1257 </span>            :                                           ErrorResult&amp; aError)
<span class="lineNum">    1258 </span>            : {
<span class="lineNum">    1259 </span><span class="lineCov">          2 :   aError = nsContentUtils::SetNodeTextContent(this, aTextContent, false);</span>
<span class="lineNum">    1260 </span><span class="lineCov">          2 : }</span>
<a name="1261"><span class="lineNum">    1261 </span>            : </a>
<span class="lineNum">    1262 </span>            : void
<span class="lineNum">    1263 </span><span class="lineCov">         12 : FragmentOrElement::DestroyContent()</span>
<span class="lineNum">    1264 </span>            : {
<span class="lineNum">    1265 </span>            :   // Drop any servo data. We do this before the RemovedFromDocument call below
<span class="lineNum">    1266 </span>            :   // so that it doesn't need to try to keep the style state sane when shuffling
<span class="lineNum">    1267 </span>            :   // around the flattened tree.
<span class="lineNum">    1268 </span><span class="lineCov">         12 :   if (IsElement() &amp;&amp; AsElement()-&gt;HasServoData()) {</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     AsElement()-&gt;ClearServoData();</span>
<span class="lineNum">    1270 </span>            :   }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineCov">         12 :   nsIDocument *document = OwnerDoc();</span>
<span class="lineNum">    1273 </span><span class="lineCov">         12 :   document-&gt;BindingManager()-&gt;RemovedFromDocument(this, document,</span>
<span class="lineNum">    1274 </span><span class="lineCov">         12 :                                                   nsBindingManager::eRunDtor);</span>
<span class="lineNum">    1275 </span><span class="lineCov">         12 :   document-&gt;ClearBoxObjectFor(this);</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineCov">         12 :   uint32_t i, count = mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    1278 </span><span class="lineCov">         20 :   for (i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1279 </span>            :     // The child can remove itself from the parent in BindToTree.
<span class="lineNum">    1280 </span><span class="lineCov">          8 :     mAttrsAndChildren.ChildAt(i)-&gt;DestroyContent();</span>
<span class="lineNum">    1281 </span>            :   }
<span class="lineNum">    1282 </span><span class="lineCov">         12 :   ShadowRoot* shadowRoot = GetShadowRoot();</span>
<span class="lineNum">    1283 </span><span class="lineCov">         12 :   if (shadowRoot) {</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     shadowRoot-&gt;DestroyContent();</span>
<span class="lineNum">    1285 </span>            :   }
<span class="lineNum">    1286 </span><span class="lineCov">         12 : }</span>
<a name="1287"><span class="lineNum">    1287 </span>            : </a>
<span class="lineNum">    1288 </span>            : void
<span class="lineNum">    1289 </span><span class="lineCov">         12 : FragmentOrElement::SaveSubtreeState()</span>
<span class="lineNum">    1290 </span>            : {
<span class="lineNum">    1291 </span><span class="lineCov">         12 :   uint32_t i, count = mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    1292 </span><span class="lineCov">         20 :   for (i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1293 </span><span class="lineCov">          8 :     mAttrsAndChildren.ChildAt(i)-&gt;SaveSubtreeState();</span>
<span class="lineNum">    1294 </span>            :   }
<span class="lineNum">    1295 </span><span class="lineCov">         12 : }</span>
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : // Generic DOMNode implementations
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<span class="lineNum">    1301 </span>            : void
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 : FragmentOrElement::FireNodeInserted(nsIDocument* aDoc,</span>
<span class="lineNum">    1303 </span>            :                                    nsINode* aParent,
<span class="lineNum">    1304 </span>            :                                    nsTArray&lt;nsCOMPtr&lt;nsIContent&gt; &gt;&amp; aNodes)
<span class="lineNum">    1305 </span>            : {
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   uint32_t count = aNodes.Length();</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :     nsIContent* childContent = aNodes[i];</span>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :     if (nsContentUtils::HasMutationListeners(childContent,</span>
<span class="lineNum">    1311 </span>            :           NS_EVENT_BITS_MUTATION_NODEINSERTED, aParent)) {
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       InternalMutationEvent mutation(true, eLegacyNodeInserted);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       mutation.mRelatedNode = do_QueryInterface(aParent);</span>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       mozAutoSubtreeModified subtree(aDoc, aParent);</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :       (new AsyncEventDispatcher(childContent, mutation))-&gt;RunDOMEventWhenSafe();</span>
<span class="lineNum">    1317 </span>            :     }
<span class="lineNum">    1318 </span>            :   }
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : //----------------------------------------------------------------------
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            : // nsISupports implementation
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : #define SUBTREE_UNBINDINGS_PER_RUNNABLE 500
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            : class ContentUnbinder : public Runnable
<a name="1328"><span class="lineNum">    1328 </span>            : {</a>
<span class="lineNum">    1329 </span>            : public:
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   ContentUnbinder()</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :     : Runnable(&quot;ContentUnbinder&quot;)</span>
<span class="lineNum">    1332 </span>            :   {
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     mLast = this;</span>
<a name="1334"><span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   ~ContentUnbinder()</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     Run();</span>
<a name="1339"><span class="lineNum">    1339 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   void UnbindSubtree(nsIContent* aNode)</span>
<span class="lineNum">    1342 </span>            :   {
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :     if (aNode-&gt;NodeType() != nsIDOMNode::ELEMENT_NODE &amp;&amp;</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :         aNode-&gt;NodeType() != nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1346 </span>            :     }
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :     FragmentOrElement* container = static_cast&lt;FragmentOrElement*&gt;(aNode);</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     uint32_t childCount = container-&gt;mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     if (childCount) {</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :       while (childCount-- &gt; 0) {</span>
<span class="lineNum">    1351 </span>            :         // Hold a strong ref to the node when we remove it, because we may be
<span class="lineNum">    1352 </span>            :         // the last reference to it.  We need to call TakeChildAt() and
<span class="lineNum">    1353 </span>            :         // update mFirstChild before calling UnbindFromTree, since this last
<span class="lineNum">    1354 </span>            :         // can notify various observers and they should really see consistent
<span class="lineNum">    1355 </span>            :         // tree state.
<span class="lineNum">    1356 </span>            :         // If this code changes, change the corresponding code in
<span class="lineNum">    1357 </span>            :         // FragmentOrElement's and nsDocument's unlink impls.
<span class="lineNum">    1358 </span>            :         nsCOMPtr&lt;nsIContent&gt; child =
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :           container-&gt;mAttrsAndChildren.TakeChildAt(childCount);</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         if (childCount == 0) {</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :           container-&gt;mFirstChild = nullptr;</span>
<span class="lineNum">    1362 </span>            :         }
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :         UnbindSubtree(child);</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :         child-&gt;UnbindFromTree();</span>
<span class="lineNum">    1365 </span>            :       }
<span class="lineNum">    1366 </span>            :     }
<a name="1367"><span class="lineNum">    1367 </span>            :   }</a>
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   NS_IMETHOD Run() override</span>
<span class="lineNum">    1370 </span>            :   {
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     nsAutoScriptBlocker scriptBlocker;</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     uint32_t len = mSubtreeRoots.Length();</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     if (len) {</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :         UnbindSubtree(mSubtreeRoots[i]);</span>
<span class="lineNum">    1376 </span>            :       }
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       mSubtreeRoots.Clear();</span>
<span class="lineNum">    1378 </span>            :     }
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :     nsCycleCollector_dispatchDeferredDeletion();</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :     if (this == sContentUnbinder) {</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :       sContentUnbinder = nullptr;</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :       if (mNext) {</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :         RefPtr&lt;ContentUnbinder&gt; next;</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :         next.swap(mNext);</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :         sContentUnbinder = next;</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :         next-&gt;mLast = mLast;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :         mLast = nullptr;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :         NS_IdleDispatchToCurrentThread(next.forget());</span>
<span class="lineNum">    1389 </span>            :       }
<span class="lineNum">    1390 </span>            :     }
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<a name="1392"><span class="lineNum">    1392 </span>            :   }</a>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   static void UnbindAll()</span>
<span class="lineNum">    1395 </span>            :   {
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :     RefPtr&lt;ContentUnbinder&gt; ub = sContentUnbinder;</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     sContentUnbinder = nullptr;</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :     while (ub) {</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :       ub-&gt;Run();</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :       ub = ub-&gt;mNext;</span>
<span class="lineNum">    1401 </span>            :     }
<a name="1402"><span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :   static void Append(nsIContent* aSubtreeRoot)</span>
<span class="lineNum">    1405 </span>            :   {
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :     if (!sContentUnbinder) {</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :       sContentUnbinder = new ContentUnbinder();</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :       nsCOMPtr&lt;nsIRunnable&gt; e = sContentUnbinder;</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :       NS_IdleDispatchToCurrentThread(e.forget());</span>
<span class="lineNum">    1410 </span>            :     }
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     if (sContentUnbinder-&gt;mLast-&gt;mSubtreeRoots.Length() &gt;=</span>
<span class="lineNum">    1413 </span>            :         SUBTREE_UNBINDINGS_PER_RUNNABLE) {
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :       sContentUnbinder-&gt;mLast-&gt;mNext = new ContentUnbinder();</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :       sContentUnbinder-&gt;mLast = sContentUnbinder-&gt;mLast-&gt;mNext;</span>
<span class="lineNum">    1416 </span>            :     }
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     sContentUnbinder-&gt;mLast-&gt;mSubtreeRoots.AppendElement(aSubtreeRoot);</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            : private:
<span class="lineNum">    1421 </span>            :   AutoTArray&lt;nsCOMPtr&lt;nsIContent&gt;,
<span class="lineNum">    1422 </span>            :                SUBTREE_UNBINDINGS_PER_RUNNABLE&gt; mSubtreeRoots;
<span class="lineNum">    1423 </span>            :   RefPtr&lt;ContentUnbinder&gt;                     mNext;
<span class="lineNum">    1424 </span>            :   ContentUnbinder*                              mLast;
<span class="lineNum">    1425 </span>            :   static ContentUnbinder*                       sContentUnbinder;
<span class="lineNum">    1426 </span>            : };
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : ContentUnbinder* ContentUnbinder::sContentUnbinder = nullptr;
<a name="1429"><span class="lineNum">    1429 </span>            : </a>
<span class="lineNum">    1430 </span>            : void
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 : FragmentOrElement::ClearContentUnbinder()</span>
<span class="lineNum">    1432 </span>            : {
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   ContentUnbinder::UnbindAll();</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1435 </span>            : 
<a name="1436"><span class="lineNum">    1436 </span>            : NS_IMPL_CYCLE_COLLECTION_CLASS(FragmentOrElement)</a>
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(FragmentOrElement)</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   nsINode::Unlink(tmp);</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   // The XBL binding is removed by RemoveFromBindingManagerRunnable
<span class="lineNum">    1442 </span>            :   // which is dispatched in UnbindFromTree.
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   if (tmp-&gt;HasProperties()) {</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :     if (tmp-&gt;IsHTMLElement() || tmp-&gt;IsSVGElement()) {</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :       nsIAtom*** props = Element::HTMLSVGPropertiesToTraverseAndUnlink();</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; props[i]; ++i) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :         tmp-&gt;DeleteProperty(*props[i]);</span>
<span class="lineNum">    1449 </span>            :       }
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       if (tmp-&gt;MayHaveAnimations()) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         nsIAtom** effectProps = EffectSet::GetEffectSetPropertyAtoms();</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; effectProps[i]; ++i) {</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :           tmp-&gt;DeleteProperty(effectProps[i]);</span>
<span class="lineNum">    1454 </span>            :         }
<span class="lineNum">    1455 </span>            :       }
<span class="lineNum">    1456 </span>            :     }
<span class="lineNum">    1457 </span>            :   }
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :   // Unlink child content (and unbind our subtree).
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   if (tmp-&gt;UnoptimizableCCNode() || !nsCCUncollectableMarker::sGeneration) {</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :     uint32_t childCount = tmp-&gt;mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :     if (childCount) {</span>
<span class="lineNum">    1463 </span>            :       // Don't allow script to run while we're unbinding everything.
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       nsAutoScriptBlocker scriptBlocker;</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :       while (childCount-- &gt; 0) {</span>
<span class="lineNum">    1466 </span>            :         // Hold a strong ref to the node when we remove it, because we may be
<span class="lineNum">    1467 </span>            :         // the last reference to it.  We need to call TakeChildAt() and
<span class="lineNum">    1468 </span>            :         // update mFirstChild before calling UnbindFromTree, since this last
<span class="lineNum">    1469 </span>            :         // can notify various observers and they should really see consistent
<span class="lineNum">    1470 </span>            :         // tree state.
<span class="lineNum">    1471 </span>            :         // If this code changes, change the corresponding code in nsDocument's
<span class="lineNum">    1472 </span>            :         // unlink impl and ContentUnbinder::UnbindSubtree.
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsIContent&gt; child = tmp-&gt;mAttrsAndChildren.TakeChildAt(childCount);</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         if (childCount == 0) {</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :           tmp-&gt;mFirstChild = nullptr;</span>
<span class="lineNum">    1476 </span>            :         }
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         child-&gt;UnbindFromTree();</span>
<span class="lineNum">    1478 </span>            :       }
<span class="lineNum">    1479 </span>            :     }
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   } else if (!tmp-&gt;GetParent() &amp;&amp; tmp-&gt;mAttrsAndChildren.ChildCount()) {</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :     ContentUnbinder::Append(tmp);</span>
<span class="lineNum">    1482 </span>            :   } /* else {
<span class="lineNum">    1483 </span>            :     The subtree root will end up to a ContentUnbinder, and that will
<span class="lineNum">    1484 </span>            :     unbind the child nodes.
<span class="lineNum">    1485 </span>            :   } */
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            :   // Clear flag here because unlinking slots will clear the
<span class="lineNum">    1488 </span>            :   // containing shadow root pointer.
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :   tmp-&gt;UnsetFlags(NODE_IS_IN_SHADOW_TREE);</span>
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :   nsIDocument* doc = tmp-&gt;OwnerDoc();</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :   doc-&gt;BindingManager()-&gt;RemovedFromDocument(tmp, doc,</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :                                              nsBindingManager::eDoNotRunDtor);</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            :   // Unlink any DOM slots of interest.
<span class="lineNum">    1496 </span>            :   {
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :     nsDOMSlots *slots = tmp-&gt;GetExistingDOMSlots();</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     if (slots) {</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :       if (tmp-&gt;IsElement()) {</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         Element* elem = tmp-&gt;AsElement();</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         for (auto iter = slots-&gt;mRegisteredIntersectionObservers.Iter(); !iter.Done(); iter.Next()) {</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :           DOMIntersectionObserver* observer = iter.Key();</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :           observer-&gt;UnlinkTarget(*elem);</span>
<span class="lineNum">    1504 </span>            :         }
<span class="lineNum">    1505 </span>            :       }
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :       slots-&gt;Unlink(tmp-&gt;IsXULElement());</span>
<span class="lineNum">    1507 </span>            :     }
<span class="lineNum">    1508 </span>            :   }
<span class="lineNum">    1509 </span>            : 
<a name="1510"><span class="lineNum">    1510 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_UNLINK_END</span></a>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineCov">       1140 : NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(FragmentOrElement)</span>
<a name="1513"><span class="lineNum">    1513 </span>            : </a>
<span class="lineNum">    1514 </span>            : void
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 : FragmentOrElement::MarkUserData(void* aObject, nsIAtom* aKey, void* aChild,</span>
<span class="lineNum">    1516 </span>            :                                void* aData)
<span class="lineNum">    1517 </span>            : {
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   uint32_t* gen = static_cast&lt;uint32_t*&gt;(aData);</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   xpc_MarkInCCGeneration(static_cast&lt;nsISupports*&gt;(aChild), *gen);</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 : }</span>
<a name="1521"><span class="lineNum">    1521 </span>            : </a>
<span class="lineNum">    1522 </span>            : void
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 : FragmentOrElement::MarkNodeChildren(nsINode* aNode)</span>
<span class="lineNum">    1524 </span>            : {
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   JSObject* o = GetJSObjectChild(aNode);</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   if (o) {</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     JS::ExposeObjectToActiveJS(o);</span>
<span class="lineNum">    1528 </span>            :   }
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   EventListenerManager* elm = aNode-&gt;GetExistingListenerManager();</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   if (elm) {</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     elm-&gt;MarkForCC();</span>
<span class="lineNum">    1533 </span>            :   }
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :   if (aNode-&gt;HasProperties()) {</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     nsIDocument* ownerDoc = aNode-&gt;OwnerDoc();</span>
<span class="lineNum">    1537 </span>            :     ownerDoc-&gt;PropertyTable(DOM_USER_DATA)-&gt;
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :       Enumerate(aNode, FragmentOrElement::MarkUserData,</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :                 &amp;nsCCUncollectableMarker::sGeneration);</span>
<span class="lineNum">    1540 </span>            :   }
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 : }</span>
<a name="1542"><span class="lineNum">    1542 </span>            : </a>
<span class="lineNum">    1543 </span>            : nsINode*
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 : FindOptimizableSubtreeRoot(nsINode* aNode)</span>
<span class="lineNum">    1545 </span>            : {
<span class="lineNum">    1546 </span>            :   nsINode* p;
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :   while ((p = aNode-&gt;GetParentNode())) {</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :     if (aNode-&gt;UnoptimizableCCNode()) {</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :       return nullptr;</span>
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :     aNode = p;</span>
<span class="lineNum">    1552 </span>            :   }
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :   if (aNode-&gt;UnoptimizableCCNode()) {</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1556 </span>            :   }
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   return aNode;</span>
<span class="lineNum">    1558 </span>            : }
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span><span class="lineCov">          3 : StaticAutoPtr&lt;nsTHashtable&lt;nsPtrHashKey&lt;nsINode&gt;&gt;&gt; gCCBlackMarkedNodes;</span>
<a name="1561"><span class="lineNum">    1561 </span>            : </a>
<span class="lineNum">    1562 </span>            : static void
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 : ClearBlackMarkedNodes()</span>
<span class="lineNum">    1564 </span>            : {
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   if (!gCCBlackMarkedNodes) {</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1567 </span>            :   }
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :   for (auto iter = gCCBlackMarkedNodes-&gt;ConstIter(); !iter.Done();</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :        iter.Next()) {</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     nsINode* n = iter.Get()-&gt;GetKey();</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     n-&gt;SetCCMarkedRoot(false);</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     n-&gt;SetInCCBlackTree(false);</span>
<span class="lineNum">    1573 </span>            :   }
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :   gCCBlackMarkedNodes = nullptr;</span>
<span class="lineNum">    1575 </span>            : }
<span class="lineNum">    1576 </span>            : 
<a name="1577"><span class="lineNum">    1577 </span>            : // static</a>
<span class="lineNum">    1578 </span>            : void
<span class="lineNum">    1579 </span><span class="lineCov">         47 : FragmentOrElement::RemoveBlackMarkedNode(nsINode* aNode)</span>
<span class="lineNum">    1580 </span>            : {
<span class="lineNum">    1581 </span><span class="lineCov">         47 :   if (!gCCBlackMarkedNodes) {</span>
<span class="lineNum">    1582 </span><span class="lineCov">         47 :     return;</span>
<span class="lineNum">    1583 </span>            :   }
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   gCCBlackMarkedNodes-&gt;RemoveEntry(aNode);</span>
<span class="lineNum">    1585 </span>            : }
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<span class="lineNum">    1587 </span>            : static bool
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 : IsCertainlyAliveNode(nsINode* aNode, nsIDocument* aDoc)</span>
<span class="lineNum">    1589 </span>            : {
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aNode-&gt;GetUncomposedDoc() == aDoc);</span>
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            :   // Marked to be in-CC-generation or if the document is an svg image that's
<span class="lineNum">    1593 </span>            :   // being kept alive by the image cache. (Note that an svg image's internal
<span class="lineNum">    1594 </span>            :   // SVG document will receive an OnPageHide() call when it gets purged from
<span class="lineNum">    1595 </span>            :   // the image cache; hence, we use IsVisible() as a hint that the document is
<span class="lineNum">    1596 </span>            :   // actively being kept alive by the cache.)
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   return nsCCUncollectableMarker::InGeneration(aDoc-&gt;GetMarkedCCGeneration()) ||</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :          (nsCCUncollectableMarker::sGeneration &amp;&amp;</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :           aDoc-&gt;IsBeingUsedAsImage() &amp;&amp;</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :           aDoc-&gt;IsVisible());</span>
<span class="lineNum">    1601 </span>            : }
<span class="lineNum">    1602 </span>            : 
<a name="1603"><span class="lineNum">    1603 </span>            : // static</a>
<span class="lineNum">    1604 </span>            : bool
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 : FragmentOrElement::CanSkipInCC(nsINode* aNode)</span>
<span class="lineNum">    1606 </span>            : {
<span class="lineNum">    1607 </span>            :   // Don't try to optimize anything during shutdown.
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   if (nsCCUncollectableMarker::sGeneration == 0) {</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1610 </span>            :   }
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            :   //XXXsmaug Need to figure out in which cases Shadow DOM can be optimized out
<span class="lineNum">    1613 </span>            :   //         from the CC graph.
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :   nsIDocument* currentDoc = aNode-&gt;GetUncomposedDoc();</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   if (currentDoc &amp;&amp; IsCertainlyAliveNode(aNode, currentDoc)) {</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     return !NeedsScriptTraverse(aNode);</span>
<span class="lineNum">    1617 </span>            :   }
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span>            :   // Bail out early if aNode is somewhere in anonymous content,
<span class="lineNum">    1620 </span>            :   // or otherwise unusual.
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :   if (aNode-&gt;UnoptimizableCCNode()) {</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1623 </span>            :   }
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span>            :   nsINode* root =
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     currentDoc ? static_cast&lt;nsINode*&gt;(currentDoc) :</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :                  FindOptimizableSubtreeRoot(aNode);</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :   if (!root) {</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1630 </span>            :   }
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            :   // Subtree has been traversed already.
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   if (root-&gt;CCMarkedRoot()) {</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     return root-&gt;InCCBlackTree() &amp;&amp; !NeedsScriptTraverse(aNode);</span>
<span class="lineNum">    1635 </span>            :   }
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :   if (!gCCBlackMarkedNodes) {</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     gCCBlackMarkedNodes = new nsTHashtable&lt;nsPtrHashKey&lt;nsINode&gt; &gt;(1020);</span>
<span class="lineNum">    1639 </span>            :   }
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span>            :   // nodesToUnpurple contains nodes which will be removed
<span class="lineNum">    1642 </span>            :   // from the purple buffer if the DOM tree is known-live.
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :   AutoTArray&lt;nsIContent*, 1020&gt; nodesToUnpurple;</span>
<span class="lineNum">    1644 </span>            :   // grayNodes need script traverse, so they aren't removed from
<span class="lineNum">    1645 </span>            :   // the purple buffer, but are marked to be in known-live subtree so that
<span class="lineNum">    1646 </span>            :   // traverse is faster.
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   AutoTArray&lt;nsINode*, 1020&gt; grayNodes;</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   bool foundLiveWrapper = root-&gt;HasKnownLiveWrapper();</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   if (root != currentDoc) {</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :     currentDoc = nullptr;</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :     if (NeedsScriptTraverse(root)) {</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :       grayNodes.AppendElement(root);</span>
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :     } else if (static_cast&lt;nsIContent*&gt;(root)-&gt;IsPurple()) {</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :       nodesToUnpurple.AppendElement(static_cast&lt;nsIContent*&gt;(root));</span>
<span class="lineNum">    1656 </span>            :     }
<span class="lineNum">    1657 </span>            :   }
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :   // Traverse the subtree and check if we could know without CC
<span class="lineNum">    1660 </span>            :   // that it is known-live.
<span class="lineNum">    1661 </span>            :   // Note, this traverse is non-virtual and inline, so it should be a lot faster
<span class="lineNum">    1662 </span>            :   // than CC's generic traverse.
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   for (nsIContent* node = root-&gt;GetFirstChild(); node;</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :        node = node-&gt;GetNextNode(root)) {</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     foundLiveWrapper = foundLiveWrapper || node-&gt;HasKnownLiveWrapper();</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :     if (foundLiveWrapper &amp;&amp; currentDoc) {</span>
<span class="lineNum">    1667 </span>            :       // If we can mark the whole document known-live, no need to optimize
<span class="lineNum">    1668 </span>            :       // so much, since when the next purple node in the document will be
<span class="lineNum">    1669 </span>            :       // handled, it is fast to check that currentDoc is in CCGeneration.
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     if (NeedsScriptTraverse(node)) {</span>
<span class="lineNum">    1673 </span>            :       // Gray nodes need real CC traverse.
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :       grayNodes.AppendElement(node);</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :     } else if (node-&gt;IsPurple()) {</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :       nodesToUnpurple.AppendElement(node);</span>
<span class="lineNum">    1677 </span>            :     }
<span class="lineNum">    1678 </span>            :   }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :   root-&gt;SetCCMarkedRoot(true);</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   root-&gt;SetInCCBlackTree(foundLiveWrapper);</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :   gCCBlackMarkedNodes-&gt;PutEntry(root);</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :   if (!foundLiveWrapper) {</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1686 </span>            :   }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :   if (currentDoc) {</span>
<span class="lineNum">    1689 </span>            :     // Special case documents. If we know the document is known-live,
<span class="lineNum">    1690 </span>            :     // we can mark the document to be in CCGeneration.
<span class="lineNum">    1691 </span>            :     currentDoc-&gt;
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :       MarkUncollectableForCCGeneration(nsCCUncollectableMarker::sGeneration);</span>
<span class="lineNum">    1693 </span>            :   } else {
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; grayNodes.Length(); ++i) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       nsINode* node = grayNodes[i];</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :       node-&gt;SetInCCBlackTree(true);</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       gCCBlackMarkedNodes-&gt;PutEntry(node);</span>
<span class="lineNum">    1698 </span>            :     }
<span class="lineNum">    1699 </span>            :   }
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            :   // Subtree is known-live, we can remove non-gray purple nodes from
<span class="lineNum">    1702 </span>            :   // purple buffer.
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; nodesToUnpurple.Length(); ++i) {</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :     nsIContent* purple = nodesToUnpurple[i];</span>
<span class="lineNum">    1705 </span>            :     // Can't remove currently handled purple node.
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :     if (purple != aNode) {</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :       purple-&gt;RemovePurple();</span>
<span class="lineNum">    1708 </span>            :     }
<span class="lineNum">    1709 </span>            :   }
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :   return !NeedsScriptTraverse(aNode);</span>
<span class="lineNum">    1711 </span>            : }
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            : AutoTArray&lt;nsINode*, 1020&gt;* gPurpleRoots = nullptr;
<a name="1714"><span class="lineNum">    1714 </span>            : AutoTArray&lt;nsIContent*, 1020&gt;* gNodesToUnbind = nullptr;</a>
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 : void ClearCycleCollectorCleanupData()</span>
<span class="lineNum">    1717 </span>            : {
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :   if (gPurpleRoots) {</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :     uint32_t len = gPurpleRoots-&gt;Length();</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :       nsINode* n = gPurpleRoots-&gt;ElementAt(i);</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :       n-&gt;SetIsPurpleRoot(false);</span>
<span class="lineNum">    1723 </span>            :     }
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :     delete gPurpleRoots;</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :     gPurpleRoots = nullptr;</span>
<span class="lineNum">    1726 </span>            :   }
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   if (gNodesToUnbind) {</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     uint32_t len = gNodesToUnbind-&gt;Length();</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :       nsIContent* c = gNodesToUnbind-&gt;ElementAt(i);</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :       c-&gt;SetIsPurpleRoot(false);</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :       ContentUnbinder::Append(c);</span>
<span class="lineNum">    1733 </span>            :     }
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     delete gNodesToUnbind;</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     gNodesToUnbind = nullptr;</span>
<span class="lineNum">    1736 </span>            :   }
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 : }</span>
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<span class="lineNum">    1739 </span>            : static bool
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 : ShouldClearPurple(nsIContent* aContent)</span>
<span class="lineNum">    1741 </span>            : {
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aContent);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :   if (aContent-&gt;IsPurple()) {</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1745 </span>            :   }
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :   JSObject* o = GetJSObjectChild(aContent);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :   if (o &amp;&amp; JS::ObjectIsMarkedGray(o)) {</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1750 </span>            :   }
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   if (aContent-&gt;HasListenerManager()) {</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1754 </span>            :   }
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :   return aContent-&gt;HasProperties();</span>
<span class="lineNum">    1757 </span>            : }
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span>            : // If aNode is not optimizable, but is an element
<span class="lineNum">    1760 </span>            : // with a frame in a document which has currently active presshell,
<span class="lineNum">    1761 </span>            : // we can act as if it was optimizable. When the primary frame dies, aNode
<a name="1762"><span class="lineNum">    1762 </span>            : // will end up to the purple buffer because of the refcount change.</a>
<span class="lineNum">    1763 </span>            : bool
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 : NodeHasActiveFrame(nsIDocument* aCurrentDoc, nsINode* aNode)</span>
<span class="lineNum">    1765 </span>            : {
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :   return aCurrentDoc-&gt;GetShell() &amp;&amp; aNode-&gt;IsElement() &amp;&amp;</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :          aNode-&gt;AsElement()-&gt;GetPrimaryFrame();</span>
<span class="lineNum">    1768 </span>            : }
<a name="1769"><span class="lineNum">    1769 </span>            : </a>
<span class="lineNum">    1770 </span>            : bool
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 : OwnedByBindingManager(nsIDocument* aCurrentDoc, nsINode* aNode)</span>
<span class="lineNum">    1772 </span>            : {
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :   return aNode-&gt;IsElement() &amp;&amp; aNode-&gt;AsElement()-&gt;GetXBLBinding();</span>
<span class="lineNum">    1774 </span>            : }
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            : // CanSkip checks if aNode is known-live, and if it is, returns true. If aNode
<span class="lineNum">    1777 </span>            : // is in a known-live DOM tree, CanSkip may also remove other objects from
<span class="lineNum">    1778 </span>            : // purple buffer and unmark event listeners and user data.  If the root of the
<span class="lineNum">    1779 </span>            : // DOM tree is a document, less optimizations are done since checking the
<span class="lineNum">    1780 </span>            : // liveness of the current document is usually fast and we don't want slow down
<a name="1781"><span class="lineNum">    1781 </span>            : // such common cases.</a>
<span class="lineNum">    1782 </span>            : bool
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 : FragmentOrElement::CanSkip(nsINode* aNode, bool aRemovingAllowed)</span>
<span class="lineNum">    1784 </span>            : {
<span class="lineNum">    1785 </span>            :   // Don't try to optimize anything during shutdown.
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :   if (nsCCUncollectableMarker::sGeneration == 0) {</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1788 </span>            :   }
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :   bool unoptimizable = aNode-&gt;UnoptimizableCCNode();</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :   nsIDocument* currentDoc = aNode-&gt;GetUncomposedDoc();</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :   if (currentDoc &amp;&amp; IsCertainlyAliveNode(aNode, currentDoc) &amp;&amp;</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :       (!unoptimizable || NodeHasActiveFrame(currentDoc, aNode) ||</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :        OwnedByBindingManager(currentDoc, aNode))) {</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :     MarkNodeChildren(aNode);</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1797 </span>            :   }
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :   if (unoptimizable) {</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1801 </span>            :   }
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :   nsINode* root = currentDoc ? static_cast&lt;nsINode*&gt;(currentDoc) :</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :                                FindOptimizableSubtreeRoot(aNode);</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :   if (!root) {</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1807 </span>            :   }
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span>            :   // Subtree has been traversed already, and aNode has
<span class="lineNum">    1810 </span>            :   // been handled in a way that doesn't require revisiting it.
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :   if (root-&gt;IsPurpleRoot()) {</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1813 </span>            :   }
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :   // nodesToClear contains nodes which are either purple or
<span class="lineNum">    1816 </span>            :   // gray.
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :   AutoTArray&lt;nsIContent*, 1020&gt; nodesToClear;</span>
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :   bool foundLiveWrapper = root-&gt;HasKnownLiveWrapper();</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :   bool domOnlyCycle = false;</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :   if (root != currentDoc) {</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     currentDoc = nullptr;</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :     if (!foundLiveWrapper) {</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :       domOnlyCycle = static_cast&lt;nsIContent*&gt;(root)-&gt;OwnedOnlyByTheDOMTree();</span>
<span class="lineNum">    1825 </span>            :     }
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :     if (ShouldClearPurple(static_cast&lt;nsIContent*&gt;(root))) {</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :       nodesToClear.AppendElement(static_cast&lt;nsIContent*&gt;(root));</span>
<span class="lineNum">    1828 </span>            :     }
<span class="lineNum">    1829 </span>            :   }
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :   // Traverse the subtree and check if we could know without CC
<span class="lineNum">    1832 </span>            :   // that it is known-live.
<span class="lineNum">    1833 </span>            :   // Note, this traverse is non-virtual and inline, so it should be a lot faster
<span class="lineNum">    1834 </span>            :   // than CC's generic traverse.
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :   for (nsIContent* node = root-&gt;GetFirstChild(); node;</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :        node = node-&gt;GetNextNode(root)) {</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     foundLiveWrapper = foundLiveWrapper || node-&gt;HasKnownLiveWrapper();</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :     if (foundLiveWrapper) {</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :       domOnlyCycle = false;</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :       if (currentDoc) {</span>
<span class="lineNum">    1841 </span>            :         // If we can mark the whole document live, no need to optimize
<span class="lineNum">    1842 </span>            :         // so much, since when the next purple node in the document will be
<span class="lineNum">    1843 </span>            :         // handled, it is fast to check that the currentDoc is in CCGeneration.
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1845 </span>            :       }
<span class="lineNum">    1846 </span>            :       // No need to put stuff to the nodesToClear array, if we can clear it
<span class="lineNum">    1847 </span>            :       // already here.
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :       if (node-&gt;IsPurple() &amp;&amp; (node != aNode || aRemovingAllowed)) {</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :         node-&gt;RemovePurple();</span>
<span class="lineNum">    1850 </span>            :       }
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :       MarkNodeChildren(node);</span>
<span class="lineNum">    1852 </span>            :     } else {
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :       domOnlyCycle = domOnlyCycle &amp;&amp; node-&gt;OwnedOnlyByTheDOMTree();</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :       if (ShouldClearPurple(node)) {</span>
<span class="lineNum">    1855 </span>            :         // Collect interesting nodes which we can clear if we find that
<span class="lineNum">    1856 </span>            :         // they are kept alive in a known-live tree or are in a DOM-only cycle.
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :         nodesToClear.AppendElement(node);</span>
<span class="lineNum">    1858 </span>            :       }
<span class="lineNum">    1859 </span>            :     }
<span class="lineNum">    1860 </span>            :   }
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :   if (!currentDoc || !foundLiveWrapper) {</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     root-&gt;SetIsPurpleRoot(true);</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     if (domOnlyCycle) {</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :       if (!gNodesToUnbind) {</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :         gNodesToUnbind = new AutoTArray&lt;nsIContent*, 1020&gt;();</span>
<span class="lineNum">    1867 </span>            :       }
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :       gNodesToUnbind-&gt;AppendElement(static_cast&lt;nsIContent*&gt;(root));</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; i &lt; nodesToClear.Length(); ++i) {</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :         nsIContent* n = nodesToClear[i];</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :         if ((n != aNode || aRemovingAllowed) &amp;&amp; n-&gt;IsPurple()) {</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :           n-&gt;RemovePurple();</span>
<span class="lineNum">    1873 </span>            :         }
<span class="lineNum">    1874 </span>            :       }
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1876 </span>            :     } else {
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :       if (!gPurpleRoots) {</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :         gPurpleRoots = new AutoTArray&lt;nsINode*, 1020&gt;();</span>
<span class="lineNum">    1879 </span>            :       }
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :       gPurpleRoots-&gt;AppendElement(root);</span>
<span class="lineNum">    1881 </span>            :     }
<span class="lineNum">    1882 </span>            :   }
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :   if (!foundLiveWrapper) {</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1886 </span>            :   }
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   if (currentDoc) {</span>
<span class="lineNum">    1889 </span>            :     // Special case documents. If we know the document is known-live,
<span class="lineNum">    1890 </span>            :     // we can mark the document to be in CCGeneration.
<span class="lineNum">    1891 </span>            :     currentDoc-&gt;
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :       MarkUncollectableForCCGeneration(nsCCUncollectableMarker::sGeneration);</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     MarkNodeChildren(currentDoc);</span>
<span class="lineNum">    1894 </span>            :   }
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span>            :   // Subtree is known-live, so we can remove purple nodes from
<span class="lineNum">    1897 </span>            :   // purple buffer and mark stuff that to be certainly alive.
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; nodesToClear.Length(); ++i) {</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :     nsIContent* n = nodesToClear[i];</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     MarkNodeChildren(n);</span>
<span class="lineNum">    1901 </span>            :     // Can't remove currently handled purple node,
<span class="lineNum">    1902 </span>            :     // unless aRemovingAllowed is true.
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     if ((n != aNode || aRemovingAllowed) &amp;&amp; n-&gt;IsPurple()) {</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :       n-&gt;RemovePurple();</span>
<span class="lineNum">    1905 </span>            :     }
<span class="lineNum">    1906 </span>            :   }
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1908 </span>            : }
<a name="1909"><span class="lineNum">    1909 </span>            : </a>
<span class="lineNum">    1910 </span>            : bool
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 : FragmentOrElement::CanSkipThis(nsINode* aNode)</span>
<span class="lineNum">    1912 </span>            : {
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :   if (nsCCUncollectableMarker::sGeneration == 0) {</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1915 </span>            :   }
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :   if (aNode-&gt;HasKnownLiveWrapper()) {</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1918 </span>            :   }
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :   nsIDocument* c = aNode-&gt;GetUncomposedDoc();</span>
<span class="lineNum">    1920 </span>            :   return
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :     ((c &amp;&amp; IsCertainlyAliveNode(aNode, c)) || aNode-&gt;InCCBlackTree()) &amp;&amp;</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     !NeedsScriptTraverse(aNode);</span>
<span class="lineNum">    1923 </span>            : }
<a name="1924"><span class="lineNum">    1924 </span>            : </a>
<span class="lineNum">    1925 </span>            : void
<span class="lineNum">    1926 </span><span class="lineCov">          3 : FragmentOrElement::InitCCCallbacks()</span>
<span class="lineNum">    1927 </span>            : {
<span class="lineNum">    1928 </span><span class="lineCov">          3 :   nsCycleCollector_setForgetSkippableCallback(ClearCycleCollectorCleanupData);</span>
<span class="lineNum">    1929 </span><span class="lineCov">          3 :   nsCycleCollector_setBeforeUnlinkCallback(ClearBlackMarkedNodes);</span>
<a name="1930"><span class="lineNum">    1930 </span><span class="lineCov">          3 : }</span></a>
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(FragmentOrElement)</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :   return FragmentOrElement::CanSkip(tmp, aRemovingAllowed);</span>
<a name="1934"><span class="lineNum">    1934 </span>            : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END</a>
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(FragmentOrElement)</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :   return FragmentOrElement::CanSkipInCC(tmp);</span>
<a name="1938"><span class="lineNum">    1938 </span>            : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END</a>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(FragmentOrElement)</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :   return FragmentOrElement::CanSkipThis(tmp);</span>
<span class="lineNum">    1942 </span>            : NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span>            : static const char* kNSURIs[] = {
<span class="lineNum">    1945 </span>            :   &quot; ([none])&quot;,
<span class="lineNum">    1946 </span>            :   &quot; (xmlns)&quot;,
<span class="lineNum">    1947 </span>            :   &quot; (xml)&quot;,
<span class="lineNum">    1948 </span>            :   &quot; (xhtml)&quot;,
<span class="lineNum">    1949 </span>            :   &quot; (XLink)&quot;,
<span class="lineNum">    1950 </span>            :   &quot; (XSLT)&quot;,
<span class="lineNum">    1951 </span>            :   &quot; (XBL)&quot;,
<span class="lineNum">    1952 </span>            :   &quot; (MathML)&quot;,
<span class="lineNum">    1953 </span>            :   &quot; (RDF)&quot;,
<span class="lineNum">    1954 </span>            :   &quot; (XUL)&quot;,
<span class="lineNum">    1955 </span>            :   &quot; (SVG)&quot;,
<span class="lineNum">    1956 </span>            :   &quot; (XML Events)&quot;
<a name="1957"><span class="lineNum">    1957 </span>            : };</a>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineCov">        432 : NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(FragmentOrElement)</span>
<span class="lineNum">    1960 </span><span class="lineCov">        432 :   if (MOZ_UNLIKELY(cb.WantDebugInfo())) {</span>
<span class="lineNum">    1961 </span>            :     char name[512];
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :     uint32_t nsid = tmp-&gt;GetNameSpaceID();</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :     nsAtomCString localName(tmp-&gt;NodeInfo()-&gt;NameAtom());</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     nsAutoCString uri;</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :     if (tmp-&gt;OwnerDoc()-&gt;GetDocumentURI()) {</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :       uri = tmp-&gt;OwnerDoc()-&gt;GetDocumentURI()-&gt;GetSpecOrDefault();</span>
<span class="lineNum">    1967 </span>            :     }
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     nsAutoString id;</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :     nsIAtom* idAtom = tmp-&gt;GetID();</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     if (idAtom) {</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :       id.AppendLiteral(&quot; id='&quot;);</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :       id.Append(nsDependentAtomString(idAtom));</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :       id.Append('\'');</span>
<span class="lineNum">    1975 </span>            :     }
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :     nsAutoString classes;</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :     const nsAttrValue* classAttrValue = tmp-&gt;IsElement() ?</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :       tmp-&gt;AsElement()-&gt;GetClasses() : nullptr;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     if (classAttrValue) {</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :       classes.AppendLiteral(&quot; class='&quot;);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :       nsAutoString classString;</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :       classAttrValue-&gt;ToString(classString);</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :       classString.ReplaceChar(char16_t('\n'), char16_t(' '));</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :       classes.Append(classString);</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :       classes.Append('\'');</span>
<span class="lineNum">    1987 </span>            :     }
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     nsAutoCString orphan;</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :     if (!tmp-&gt;IsInUncomposedDoc() &amp;&amp;</span>
<span class="lineNum">    1991 </span>            :         // Ignore xbl:content, which is never in the document and hence always
<span class="lineNum">    1992 </span>            :         // appears to be orphaned.
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :         !tmp-&gt;NodeInfo()-&gt;Equals(nsGkAtoms::content, kNameSpaceID_XBL)) {</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :       orphan.AppendLiteral(&quot; (orphan)&quot;);</span>
<span class="lineNum">    1995 </span>            :     }
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     const char* nsuri = nsid &lt; ArrayLength(kNSURIs) ? kNSURIs[nsid] : &quot;&quot;;</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :     SprintfLiteral(name, &quot;FragmentOrElement%s %s%s%s%s %s&quot;,</span>
<span class="lineNum">    1999 </span>            :                    nsuri,
<span class="lineNum">    2000 </span>            :                    localName.get(),
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :                    NS_ConvertUTF16toUTF8(id).get(),</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :                    NS_ConvertUTF16toUTF8(classes).get(),</span>
<span class="lineNum">    2003 </span>            :                    orphan.get(),
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                    uri.get());</span>
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :     cb.DescribeRefCountedNode(tmp-&gt;mRefCnt.get(), name);</span>
<span class="lineNum">    2006 </span>            :   }
<span class="lineNum">    2007 </span>            :   else {
<span class="lineNum">    2008 </span><span class="lineCov">        432 :     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(FragmentOrElement, tmp-&gt;mRefCnt.get())</span>
<span class="lineNum">    2009 </span>            :   }
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span><span class="lineCov">        432 :   if (!nsINode::Traverse(tmp, cb)) {</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :     return NS_SUCCESS_INTERRUPTED_TRAVERSE;</span>
<span class="lineNum">    2013 </span>            :   }
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span><span class="lineCov">        432 :   tmp-&gt;OwnerDoc()-&gt;BindingManager()-&gt;Traverse(tmp, cb);</span>
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            :   // Check that whenever we have effect properties, MayHaveAnimations is set.
<span class="lineNum">    2018 </span>            : #ifdef DEBUG
<span class="lineNum">    2019 </span><span class="lineCov">        432 :   nsIAtom** effectProps = EffectSet::GetEffectSetPropertyAtoms();</span>
<span class="lineNum">    2020 </span><span class="lineCov">       1728 :   for (uint32_t i = 0; effectProps[i]; ++i) {</span>
<span class="lineNum">    2021 </span><span class="lineCov">       1296 :     MOZ_ASSERT_IF(tmp-&gt;GetProperty(effectProps[i]), tmp-&gt;MayHaveAnimations());</span>
<span class="lineNum">    2022 </span>            :   }
<span class="lineNum">    2023 </span>            : #endif
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineCov">        432 :   if (tmp-&gt;HasProperties()) {</span>
<span class="lineNum">    2026 </span><span class="lineCov">          1 :     if (tmp-&gt;IsHTMLElement() || tmp-&gt;IsSVGElement()) {</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :       nsIAtom*** props = Element::HTMLSVGPropertiesToTraverseAndUnlink();</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :       for (uint32_t i = 0; props[i]; ++i) {</span>
<span class="lineNum">    2029 </span>            :         nsISupports* property =
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :           static_cast&lt;nsISupports*&gt;(tmp-&gt;GetProperty(*props[i]));</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :         cb.NoteXPCOMChild(property);</span>
<span class="lineNum">    2032 </span>            :       }
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       if (tmp-&gt;MayHaveAnimations()) {</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :         nsIAtom** effectProps = EffectSet::GetEffectSetPropertyAtoms();</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; effectProps[i]; ++i) {</span>
<span class="lineNum">    2036 </span>            :           EffectSet* effectSet =
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :             static_cast&lt;EffectSet*&gt;(tmp-&gt;GetProperty(effectProps[i]));</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :           if (effectSet) {</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :             effectSet-&gt;Traverse(cb);</span>
<span class="lineNum">    2040 </span>            :           }
<span class="lineNum">    2041 </span>            :         }
<span class="lineNum">    2042 </span>            :       }
<span class="lineNum">    2043 </span>            :     }
<span class="lineNum">    2044 </span>            :   }
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span>            :   // Traverse attribute names and child content.
<span class="lineNum">    2047 </span>            :   {
<span class="lineNum">    2048 </span>            :     uint32_t i;
<span class="lineNum">    2049 </span><span class="lineCov">        432 :     uint32_t attrs = tmp-&gt;mAttrsAndChildren.AttrCount();</span>
<span class="lineNum">    2050 </span><span class="lineCov">       1990 :     for (i = 0; i &lt; attrs; i++) {</span>
<span class="lineNum">    2051 </span><span class="lineCov">       1558 :       const nsAttrName* name = tmp-&gt;mAttrsAndChildren.AttrNameAt(i);</span>
<span class="lineNum">    2052 </span><span class="lineCov">       1558 :       if (!name-&gt;IsAtom()) {</span>
<span class="lineNum">    2053 </span>            :         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
<span class="lineNum">    2054 </span><span class="lineCov">         63 :                                            &quot;mAttrsAndChildren[i]-&gt;NodeInfo()&quot;);</span>
<span class="lineNum">    2055 </span><span class="lineCov">         63 :         cb.NoteNativeChild(name-&gt;NodeInfo(),</span>
<span class="lineNum">    2056 </span><span class="lineCov">        126 :                            NS_CYCLE_COLLECTION_PARTICIPANT(NodeInfo));</span>
<span class="lineNum">    2057 </span>            :       }
<span class="lineNum">    2058 </span>            :     }
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span><span class="lineCov">        432 :     uint32_t kids = tmp-&gt;mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    2061 </span><span class="lineCov">       1235 :     for (i = 0; i &lt; kids; i++) {</span>
<span class="lineNum">    2062 </span><span class="lineCov">        803 :       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;mAttrsAndChildren[i]&quot;);</span>
<span class="lineNum">    2063 </span><span class="lineCov">        803 :       cb.NoteXPCOMChild(tmp-&gt;mAttrsAndChildren.GetSafeChildAt(i));</span>
<span class="lineNum">    2064 </span>            :     }
<span class="lineNum">    2065 </span>            :   }
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span>            :   // Traverse any DOM slots of interest.
<span class="lineNum">    2068 </span>            :   {
<span class="lineNum">    2069 </span><span class="lineCov">        432 :     nsDOMSlots *slots = tmp-&gt;GetExistingDOMSlots();</span>
<span class="lineNum">    2070 </span><span class="lineCov">        432 :     if (slots) {</span>
<span class="lineNum">    2071 </span><span class="lineCov">        290 :       slots-&gt;Traverse(cb, tmp-&gt;IsXULElement());</span>
<span class="lineNum">    2072 </span>            :     }
<span class="lineNum">    2073 </span>            :   }
<span class="lineNum">    2074 </span><span class="lineCov">        432 : NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END</span>
<a name="2075"><span class="lineNum">    2075 </span>            : </a>
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span><span class="lineCov">      20883 : NS_INTERFACE_MAP_BEGIN(FragmentOrElement)</span>
<span class="lineNum">    2078 </span><span class="lineCov">      20883 :   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY</span>
<span class="lineNum">    2079 </span><span class="lineCov">      20099 :   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(FragmentOrElement)</span>
<span class="lineNum">    2080 </span><span class="lineCov">      16785 :   NS_INTERFACE_MAP_ENTRY(Element)</span>
<span class="lineNum">    2081 </span><span class="lineCov">      14994 :   NS_INTERFACE_MAP_ENTRY(nsIContent)</span>
<span class="lineNum">    2082 </span><span class="lineCov">       7380 :   NS_INTERFACE_MAP_ENTRY(nsINode)</span>
<span class="lineNum">    2083 </span><span class="lineCov">       4259 :   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)</span>
<span class="lineNum">    2084 </span><span class="lineCov">       4244 :   NS_INTERFACE_MAP_ENTRY(mozilla::dom::EventTarget)</span>
<span class="lineNum">    2085 </span><span class="lineCov">       1613 :   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,</span>
<span class="lineNum">    2086 </span>            :                                  new nsNodeSupportsWeakRefTearoff(this))
<span class="lineNum">    2087 </span>            :   // DOM bindings depend on the identity pointer being the
<span class="lineNum">    2088 </span>            :   // same as nsINode (which nsIContent inherits).
<span class="lineNum">    2089 </span><span class="lineCov">       1359 :   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)</span>
<a name="2090"><span class="lineNum">    2090 </span><span class="lineCov">        514 : NS_INTERFACE_MAP_END</span></a>
<a name="2091"><span class="lineNum">    2091 </span>            : </a>
<span class="lineNum">    2092 </span><span class="lineCov">      40755 : NS_IMPL_CYCLE_COLLECTING_ADDREF(FragmentOrElement)</span>
<span class="lineNum">    2093 </span><span class="lineCov">      31949 : NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE(FragmentOrElement,</span>
<span class="lineNum">    2094 </span>            :                                                    nsNodeUtils::LastRelease(this))
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span>            : //----------------------------------------------------------------------
<a name="2097"><span class="lineNum">    2097 </span>            : </a>
<span class="lineNum">    2098 </span>            : nsresult
<span class="lineNum">    2099 </span><span class="lineCov">        337 : FragmentOrElement::CopyInnerTo(FragmentOrElement* aDst,</span>
<span class="lineNum">    2100 </span>            :                                bool aPreallocateChildren)
<span class="lineNum">    2101 </span>            : {
<span class="lineNum">    2102 </span><span class="lineCov">        337 :   nsresult rv = aDst-&gt;mAttrsAndChildren.EnsureCapacityToClone(mAttrsAndChildren,</span>
<span class="lineNum">    2103 </span><span class="lineCov">        337 :                                                               aPreallocateChildren);</span>
<span class="lineNum">    2104 </span><span class="lineCov">        337 :   NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span><span class="lineCov">        337 :   uint32_t i, count = mAttrsAndChildren.AttrCount();</span>
<span class="lineNum">    2107 </span><span class="lineCov">        568 :   for (i = 0; i &lt; count; ++i) {</span>
<span class="lineNum">    2108 </span><span class="lineCov">        231 :     const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);</span>
<span class="lineNum">    2109 </span><span class="lineCov">        231 :     const nsAttrValue* value = mAttrsAndChildren.AttrAt(i);</span>
<span class="lineNum">    2110 </span><span class="lineCov">        462 :     nsAutoString valStr;</span>
<span class="lineNum">    2111 </span><span class="lineCov">        231 :     value-&gt;ToString(valStr);</span>
<span class="lineNum">    2112 </span><span class="lineCov">        462 :     rv = aDst-&gt;SetAttr(name-&gt;NamespaceID(), name-&gt;LocalName(),</span>
<span class="lineNum">    2113 </span><span class="lineCov">        462 :                                 name-&gt;GetPrefix(), valStr, false);</span>
<span class="lineNum">    2114 </span><span class="lineCov">        231 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2115 </span>            :   }
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span><span class="lineCov">        337 :   return NS_OK;</span>
<span class="lineNum">    2118 </span>            : }
<a name="2119"><span class="lineNum">    2119 </span>            : </a>
<span class="lineNum">    2120 </span>            : const nsTextFragment*
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 : FragmentOrElement::GetText()</span>
<span class="lineNum">    2122 </span>            : {
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">    2124 </span>            : }
<a name="2125"><span class="lineNum">    2125 </span>            : </a>
<span class="lineNum">    2126 </span>            : uint32_t
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 : FragmentOrElement::TextLength() const</span>
<span class="lineNum">    2128 </span>            : {
<span class="lineNum">    2129 </span>            :   // We can remove this assertion if it turns out to be useful to be able
<span class="lineNum">    2130 </span>            :   // to depend on this returning 0
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :   NS_NOTREACHED(&quot;called FragmentOrElement::TextLength&quot;);</span>
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    2134 </span>            : }
<a name="2135"><span class="lineNum">    2135 </span>            : </a>
<span class="lineNum">    2136 </span>            : nsresult
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 : FragmentOrElement::SetText(const char16_t* aBuffer, uint32_t aLength,</span>
<span class="lineNum">    2138 </span>            :                           bool aNotify)
<span class="lineNum">    2139 </span>            : {
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :   NS_ERROR(&quot;called FragmentOrElement::SetText&quot;);</span>
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">    2143 </span>            : }
<a name="2144"><span class="lineNum">    2144 </span>            : </a>
<span class="lineNum">    2145 </span>            : nsresult
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 : FragmentOrElement::AppendText(const char16_t* aBuffer, uint32_t aLength,</span>
<span class="lineNum">    2147 </span>            :                              bool aNotify)
<span class="lineNum">    2148 </span>            : {
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :   NS_ERROR(&quot;called FragmentOrElement::AppendText&quot;);</span>
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">    2152 </span>            : }
<a name="2153"><span class="lineNum">    2153 </span>            : </a>
<span class="lineNum">    2154 </span>            : bool
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 : FragmentOrElement::TextIsOnlyWhitespace()</span>
<span class="lineNum">    2156 </span>            : {
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2158 </span>            : }
<a name="2159"><span class="lineNum">    2159 </span>            : </a>
<span class="lineNum">    2160 </span>            : bool
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 : FragmentOrElement::ThreadSafeTextIsOnlyWhitespace() const</span>
<span class="lineNum">    2162 </span>            : {
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2164 </span>            : }
<a name="2165"><span class="lineNum">    2165 </span>            : </a>
<span class="lineNum">    2166 </span>            : bool
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 : FragmentOrElement::HasTextForTranslation()</span>
<span class="lineNum">    2168 </span>            : {
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2170 </span>            : }
<a name="2171"><span class="lineNum">    2171 </span>            : </a>
<span class="lineNum">    2172 </span>            : void
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 : FragmentOrElement::AppendTextTo(nsAString&amp; aResult)</span>
<span class="lineNum">    2174 </span>            : {
<span class="lineNum">    2175 </span>            :   // We can remove this assertion if it turns out to be useful to be able
<span class="lineNum">    2176 </span>            :   // to depend on this appending nothing.
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :   NS_NOTREACHED(&quot;called FragmentOrElement::TextLength&quot;);</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 : }</span>
<a name="2179"><span class="lineNum">    2179 </span>            : </a>
<span class="lineNum">    2180 </span>            : bool
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 : FragmentOrElement::AppendTextTo(nsAString&amp; aResult, const mozilla::fallible_t&amp;)</span>
<span class="lineNum">    2182 </span>            : {
<span class="lineNum">    2183 </span>            :   // We can remove this assertion if it turns out to be useful to be able
<span class="lineNum">    2184 </span>            :   // to depend on this appending nothing.
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :   NS_NOTREACHED(&quot;called FragmentOrElement::TextLength&quot;);</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2188 </span>            : }
<a name="2189"><span class="lineNum">    2189 </span>            : </a>
<span class="lineNum">    2190 </span>            : uint32_t
<span class="lineNum">    2191 </span><span class="lineCov">       3780 : FragmentOrElement::GetChildCount() const</span>
<span class="lineNum">    2192 </span>            : {
<span class="lineNum">    2193 </span><span class="lineCov">       3780 :   return mAttrsAndChildren.ChildCount();</span>
<span class="lineNum">    2194 </span>            : }
<a name="2195"><span class="lineNum">    2195 </span>            : </a>
<span class="lineNum">    2196 </span>            : nsIContent *
<span class="lineNum">    2197 </span><span class="lineCov">       1087 : FragmentOrElement::GetChildAt(uint32_t aIndex) const</span>
<span class="lineNum">    2198 </span>            : {
<span class="lineNum">    2199 </span><span class="lineCov">       1087 :   return mAttrsAndChildren.GetSafeChildAt(aIndex);</span>
<span class="lineNum">    2200 </span>            : }
<a name="2201"><span class="lineNum">    2201 </span>            : </a>
<span class="lineNum">    2202 </span>            : nsIContent * const *
<span class="lineNum">    2203 </span><span class="lineCov">       1023 : FragmentOrElement::GetChildArray(uint32_t* aChildCount) const</span>
<span class="lineNum">    2204 </span>            : {
<span class="lineNum">    2205 </span><span class="lineCov">       1023 :   return mAttrsAndChildren.GetChildArray(aChildCount);</span>
<span class="lineNum">    2206 </span>            : }
<a name="2207"><span class="lineNum">    2207 </span>            : </a>
<span class="lineNum">    2208 </span>            : int32_t
<span class="lineNum">    2209 </span><span class="lineCov">        729 : FragmentOrElement::IndexOf(const nsINode* aPossibleChild) const</span>
<span class="lineNum">    2210 </span>            : {
<span class="lineNum">    2211 </span><span class="lineCov">        729 :   return mAttrsAndChildren.IndexOfChild(aPossibleChild);</span>
<span class="lineNum">    2212 </span>            : }
<a name="2213"><span class="lineNum">    2213 </span>            : </a>
<span class="lineNum">    2214 </span>            : static inline bool
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 : IsVoidTag(nsIAtom* aTag)</span>
<span class="lineNum">    2216 </span>            : {
<span class="lineNum">    2217 </span>            :   static const nsIAtom* voidElements[] = {
<span class="lineNum">    2218 </span>            :     nsGkAtoms::area, nsGkAtoms::base, nsGkAtoms::basefont,
<span class="lineNum">    2219 </span>            :     nsGkAtoms::bgsound, nsGkAtoms::br, nsGkAtoms::col,
<span class="lineNum">    2220 </span>            :     nsGkAtoms::embed, nsGkAtoms::frame,
<span class="lineNum">    2221 </span>            :     nsGkAtoms::hr, nsGkAtoms::img, nsGkAtoms::input,
<span class="lineNum">    2222 </span>            :     nsGkAtoms::keygen, nsGkAtoms::link, nsGkAtoms::meta,
<span class="lineNum">    2223 </span>            :     nsGkAtoms::param, nsGkAtoms::source, nsGkAtoms::track,
<span class="lineNum">    2224 </span>            :     nsGkAtoms::wbr
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :   };</span>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :   static mozilla::BloomFilter&lt;12, nsIAtom&gt; sFilter;</span>
<span class="lineNum">    2228 </span>            :   static bool sInitialized = false;
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :   if (!sInitialized) {</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :     sInitialized = true;</span>
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; ArrayLength(voidElements); ++i) {</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :       sFilter.add(voidElements[i]);</span>
<span class="lineNum">    2233 </span>            :     }
<span class="lineNum">    2234 </span>            :   }
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :   if (sFilter.mightContain(aTag)) {</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; ArrayLength(voidElements); ++i) {</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :       if (aTag == voidElements[i]) {</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    2240 </span>            :       }
<span class="lineNum">    2241 </span>            :     }
<span class="lineNum">    2242 </span>            :   }
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2244 </span>            : }
<span class="lineNum">    2245 </span>            : 
<a name="2246"><span class="lineNum">    2246 </span>            : /* static */</a>
<span class="lineNum">    2247 </span>            : bool
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 : FragmentOrElement::IsHTMLVoid(nsIAtom* aLocalName)</span>
<span class="lineNum">    2249 </span>            : {
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :   return aLocalName &amp;&amp; IsVoidTag(aLocalName);</span>
<span class="lineNum">    2251 </span>            : }
<a name="2252"><span class="lineNum">    2252 </span>            : </a>
<span class="lineNum">    2253 </span>            : void
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 : FragmentOrElement::GetMarkup(bool aIncludeSelf, nsAString&amp; aMarkup)</span>
<span class="lineNum">    2255 </span>            : {
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :   aMarkup.Truncate();</span>
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :   nsIDocument* doc = OwnerDoc();</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :   if (IsInHTMLDocument()) {</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :     nsContentUtils::SerializeNodeToMarkup(this, !aIncludeSelf, aMarkup);</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2262 </span>            :   }
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :   nsAutoString contentType;</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :   doc-&gt;GetContentType(contentType);</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :   bool tryToCacheEncoder = !aIncludeSelf;</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIDocumentEncoder&gt; docEncoder = doc-&gt;GetCachedEncoder();</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :   if (!docEncoder) {</span>
<span class="lineNum">    2270 </span>            :     docEncoder =
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :       do_CreateInstance(PromiseFlatCString(</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         nsDependentCString(NS_DOC_ENCODER_CONTRACTID_BASE) +</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         NS_ConvertUTF16toUTF8(contentType)</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       ).get());</span>
<span class="lineNum">    2275 </span>            :   }
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :   if (!docEncoder) {</span>
<span class="lineNum">    2277 </span>            :     // This could be some type for which we create a synthetic document.  Try
<span class="lineNum">    2278 </span>            :     // again as XML
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :     contentType.AssignLiteral(&quot;application/xml&quot;);</span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :     docEncoder = do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE &quot;application/xml&quot;);</span>
<span class="lineNum">    2281 </span>            :     // Don't try to cache the encoder since it would point to a different
<span class="lineNum">    2282 </span>            :     // contentType once it has been reinitialized.
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :     tryToCacheEncoder = false;</span>
<span class="lineNum">    2284 </span>            :   }
<span class="lineNum">    2285 </span>            : 
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE_VOID(docEncoder);</span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span>            :   uint32_t flags = nsIDocumentEncoder::OutputEncodeBasicEntities |
<span class="lineNum">    2289 </span>            :                    // Output DOM-standard newlines
<span class="lineNum">    2290 </span>            :                    nsIDocumentEncoder::OutputLFLineBreak |
<span class="lineNum">    2291 </span>            :                    // Don't do linebreaking that's not present in
<span class="lineNum">    2292 </span>            :                    // the source
<span class="lineNum">    2293 </span>            :                    nsIDocumentEncoder::OutputRaw |
<span class="lineNum">    2294 </span>            :                    // Only check for mozdirty when necessary (bug 599983)
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :                    nsIDocumentEncoder::OutputIgnoreMozDirty;</span>
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :   if (IsEditable()) {</span>
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;Element&gt; elem = do_QueryInterface(this);</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :     TextEditor* textEditor = elem ? elem-&gt;GetTextEditorInternal() : nullptr;</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :     if (textEditor &amp;&amp; textEditor-&gt;OutputsMozDirty()) {</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :       flags &amp;= ~nsIDocumentEncoder::OutputIgnoreMozDirty;</span>
<span class="lineNum">    2302 </span>            :     }
<span class="lineNum">    2303 </span>            :   }
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :   DebugOnly&lt;nsresult&gt; rv = docEncoder-&gt;NativeInit(doc, contentType, flags);</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    2307 </span>            : 
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :   if (aIncludeSelf) {</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :     docEncoder-&gt;SetNativeNode(this);</span>
<span class="lineNum">    2310 </span>            :   } else {
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :     docEncoder-&gt;SetNativeContainerNode(this);</span>
<span class="lineNum">    2312 </span>            :   }
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :   rv = docEncoder-&gt;EncodeToString(aMarkup);</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :   if (tryToCacheEncoder) {</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :     doc-&gt;SetCachedEncoder(docEncoder.forget());</span>
<span class="lineNum">    2317 </span>            :   }
<span class="lineNum">    2318 </span>            : }
<a name="2319"><span class="lineNum">    2319 </span>            : </a>
<span class="lineNum">    2320 </span>            : static bool
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 : ContainsMarkup(const nsAString&amp; aStr)</span>
<span class="lineNum">    2322 </span>            : {
<span class="lineNum">    2323 </span>            :   // Note: we can't use FindCharInSet because null is one of the characters we
<span class="lineNum">    2324 </span>            :   // want to search for.
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :   const char16_t* start = aStr.BeginReading();</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :   const char16_t* end = aStr.EndReading();</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   while (start != end) {</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :     char16_t c = *start;</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     if (c == char16_t('&lt;') ||</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :         c == char16_t('&amp;') ||</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         c == char16_t('\r') ||</span>
<span class="lineNum">    2333 </span>            :         c == char16_t('\0')) {
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    2335 </span>            :     }
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :     ++start;</span>
<span class="lineNum">    2337 </span>            :   }
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2340 </span>            : }
<a name="2341"><span class="lineNum">    2341 </span>            : </a>
<span class="lineNum">    2342 </span>            : void
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 : FragmentOrElement::SetInnerHTMLInternal(const nsAString&amp; aInnerHTML, ErrorResult&amp; aError)</span>
<span class="lineNum">    2344 </span>            : {
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   FragmentOrElement* target = this;</span>
<span class="lineNum">    2346 </span>            :   // Handle template case.
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   if (nsNodeUtils::IsTemplateElement(target)) {</span>
<span class="lineNum">    2348 </span>            :     DocumentFragment* frag =
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :       static_cast&lt;HTMLTemplateElement*&gt;(target)-&gt;Content();</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(frag);</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :     target = frag;</span>
<span class="lineNum">    2352 </span>            :   }
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :   // Fast-path for strings with no markup. Limit this to short strings, to
<span class="lineNum">    2355 </span>            :   // avoid ContainsMarkup taking too long. The choice for 100 is based on
<span class="lineNum">    2356 </span>            :   // gut feeling.
<span class="lineNum">    2357 </span>            :   //
<span class="lineNum">    2358 </span>            :   // Don't do this for elements with a weird parser insertion mode, for
<span class="lineNum">    2359 </span>            :   // instance setting innerHTML = &quot;&quot; on a &lt;html&gt; element should add the
<span class="lineNum">    2360 </span>            :   // optional &lt;head&gt; and &lt;body&gt; elements.
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :   if (!target-&gt;HasWeirdParserInsertionMode() &amp;&amp;</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :       aInnerHTML.Length() &lt; 100 &amp;&amp; !ContainsMarkup(aInnerHTML)) {</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     aError = nsContentUtils::SetNodeTextContent(target, aInnerHTML, false);</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2365 </span>            :   }
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :   nsIDocument* doc = target-&gt;OwnerDoc();</span>
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span>            :   // Batch possible DOMSubtreeModified events.
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   mozAutoSubtreeModified subtree(doc, nullptr);</span>
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :   target-&gt;FireNodeRemovedForChildren();</span>
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span>            :   // Needed when innerHTML is used in combination with contenteditable
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, true);</span>
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            :   // Remove childnodes.
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :   uint32_t childCount = target-&gt;GetChildCount();</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :   nsAutoMutationBatch mb(target, true, false);</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; childCount; ++i) {</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :     target-&gt;RemoveChildAt(0, true);</span>
<span class="lineNum">    2382 </span>            :   }
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :   mb.RemovalDone();</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :   nsAutoScriptLoaderDisabler sld(doc);</span>
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :   nsIAtom* contextLocalName = NodeInfo()-&gt;NameAtom();</span>
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :   int32_t contextNameSpaceID = GetNameSpaceID();</span>
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :   ShadowRoot* shadowRoot = ShadowRoot::FromNode(this);</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :   if (shadowRoot) {</span>
<span class="lineNum">    2392 </span>            :     // Fix up the context to be the host of the ShadowRoot.
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :     contextLocalName = shadowRoot-&gt;GetHost()-&gt;NodeInfo()-&gt;NameAtom();</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :     contextNameSpaceID = shadowRoot-&gt;GetHost()-&gt;GetNameSpaceID();</span>
<span class="lineNum">    2395 </span>            :   }
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :   if (doc-&gt;IsHTMLDocument()) {</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     int32_t oldChildCount = target-&gt;GetChildCount();</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     aError = nsContentUtils::ParseFragmentHTML(aInnerHTML,</span>
<span class="lineNum">    2400 </span>            :                                                target,
<span class="lineNum">    2401 </span>            :                                                contextLocalName,
<span class="lineNum">    2402 </span>            :                                                contextNameSpaceID,
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :                                                doc-&gt;GetCompatibilityMode() ==</span>
<span class="lineNum">    2404 </span>            :                                                  eCompatibility_NavQuirks,
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                                                true);</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :     mb.NodesAdded();</span>
<span class="lineNum">    2407 </span>            :     // HTML5 parser has notified, but not fired mutation events.
<span class="lineNum">    2408 </span>            :     nsContentUtils::FireMutationEventsForDirectParsing(doc, target,
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :                                                        oldChildCount);</span>
<span class="lineNum">    2410 </span>            :   } else {
<span class="lineNum">    2411 </span>            :     RefPtr&lt;DocumentFragment&gt; df =
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :       nsContentUtils::CreateContextualFragment(target, aInnerHTML, true, aError);</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :     if (!aError.Failed()) {</span>
<span class="lineNum">    2414 </span>            :       // Suppress assertion about node removal mutation events that can't have
<span class="lineNum">    2415 </span>            :       // listeners anyway, because no one has had the chance to register mutation
<span class="lineNum">    2416 </span>            :       // listeners on the fragment that comes from the parser.
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :       nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;</span>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :       static_cast&lt;nsINode*&gt;(target)-&gt;AppendChild(*df, aError);</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :       mb.NodesAdded();</span>
<span class="lineNum">    2421 </span>            :     }
<span class="lineNum">    2422 </span>            :   }
<span class="lineNum">    2423 </span>            : }
<a name="2424"><span class="lineNum">    2424 </span>            : </a>
<span class="lineNum">    2425 </span>            : nsINode::nsSlots*
<span class="lineNum">    2426 </span><span class="lineCov">        275 : FragmentOrElement::CreateSlots()</span>
<span class="lineNum">    2427 </span>            : {
<span class="lineNum">    2428 </span><span class="lineCov">        275 :   return new nsDOMSlots();</span>
<span class="lineNum">    2429 </span>            : }
<a name="2430"><span class="lineNum">    2430 </span>            : </a>
<span class="lineNum">    2431 </span>            : void
<span class="lineNum">    2432 </span><span class="lineCov">          4 : FragmentOrElement::FireNodeRemovedForChildren()</span>
<span class="lineNum">    2433 </span>            : {
<span class="lineNum">    2434 </span><span class="lineCov">          4 :   nsIDocument* doc = OwnerDoc();</span>
<span class="lineNum">    2435 </span>            :   // Optimize the common case
<span class="lineNum">    2436 </span><span class="lineCov">          4 :   if (!nsContentUtils::</span>
<span class="lineNum">    2437 </span><span class="lineCov">          4 :         HasMutationListeners(doc, NS_EVENT_BITS_MUTATION_NODEREMOVED)) {</span>
<span class="lineNum">    2438 </span><span class="lineCov">          4 :     return;</span>
<span class="lineNum">    2439 </span>            :   }
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIDocument&gt; owningDoc = doc;</span>
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsINode&gt; child;</span>
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :   for (child = GetFirstChild();</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :        child &amp;&amp; child-&gt;GetParentNode() == this;</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :        child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     nsContentUtils::MaybeFireNodeRemoved(child, this, doc);</span>
<span class="lineNum">    2448 </span>            :   }
<span class="lineNum">    2449 </span>            : }
<a name="2450"><span class="lineNum">    2450 </span>            : </a>
<span class="lineNum">    2451 </span>            : size_t
<span class="lineNum">    2452 </span><span class="lineCov">        130 : FragmentOrElement::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">    2453 </span>            : {
<span class="lineNum">    2454 </span><span class="lineCov">        130 :   size_t n = 0;</span>
<span class="lineNum">    2455 </span><span class="lineCov">        130 :   n += nsIContent::SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    2456 </span><span class="lineCov">        130 :   n += mAttrsAndChildren.SizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    2457 </span>            : 
<span class="lineNum">    2458 </span><span class="lineCov">        130 :   nsDOMSlots* slots = GetExistingDOMSlots();</span>
<span class="lineNum">    2459 </span><span class="lineCov">        130 :   if (slots) {</span>
<span class="lineNum">    2460 </span><span class="lineCov">          5 :     n += slots-&gt;SizeOfIncludingThis(aMallocSizeOf);</span>
<span class="lineNum">    2461 </span>            :   }
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineCov">        130 :   return n;</span>
<span class="lineNum">    2464 </span>            : }
<a name="2465"><span class="lineNum">    2465 </span>            : </a>
<span class="lineNum">    2466 </span>            : void
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 : FragmentOrElement::SetIsElementInStyleScopeFlagOnSubtree(bool aInStyleScope)</span>
<span class="lineNum">    2468 </span>            : {
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :   if (aInStyleScope &amp;&amp; IsElementInStyleScope()) {</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2471 </span>            :   }
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :   if (IsElement()) {</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     SetIsElementInStyleScope(aInStyleScope);</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :     SetIsElementInStyleScopeFlagOnShadowTree(aInStyleScope);</span>
<span class="lineNum">    2476 </span>            :   }
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :   nsIContent* n = GetNextNode(this);</span>
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :   while (n) {</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :     if (n-&gt;IsElementInStyleScope()) {</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :       n = n-&gt;GetNextNonChildNode(this);</span>
<span class="lineNum">    2482 </span>            :     } else {
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :       if (n-&gt;IsElement()) {</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :         n-&gt;SetIsElementInStyleScope(aInStyleScope);</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :         n-&gt;AsElement()-&gt;SetIsElementInStyleScopeFlagOnShadowTree(aInStyleScope);</span>
<span class="lineNum">    2486 </span>            :       }
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :       n = n-&gt;GetNextNode(this);</span>
<span class="lineNum">    2488 </span>            :     }
<span class="lineNum">    2489 </span>            :   }
<span class="lineNum">    2490 </span>            : }
<a name="2491"><span class="lineNum">    2491 </span>            : </a>
<span class="lineNum">    2492 </span>            : void
<span class="lineNum">    2493 </span><span class="lineCov">       4709 : FragmentOrElement::SetIsElementInStyleScopeFlagOnShadowTree(bool aInStyleScope)</span>
<span class="lineNum">    2494 </span>            : {
<span class="lineNum">    2495 </span><span class="lineCov">       4709 :   NS_ASSERTION(IsElement(), &quot;calling SetIsElementInStyleScopeFlagOnShadowTree &quot;</span>
<span class="lineNum">    2496 </span>            :                             &quot;on a non-Element is useless&quot;);
<span class="lineNum">    2497 </span><span class="lineCov">       4709 :   ShadowRoot* shadowRoot = GetShadowRoot();</span>
<span class="lineNum">    2498 </span><span class="lineCov">       4709 :   while (shadowRoot) {</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :     shadowRoot-&gt;SetIsElementInStyleScopeFlagOnSubtree(aInStyleScope);</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     shadowRoot = shadowRoot-&gt;GetOlderShadowRoot();</span>
<span class="lineNum">    2501 </span>            :   }
<span class="lineNum">    2502 </span><span class="lineCov">       4709 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - dom/base/nsObjectLoadingContent.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">dom/base</a> - nsObjectLoadingContent.h<span style="font-size: 80%;"> (source / <a href="nsObjectLoadingContent.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /*
<span class="lineNum">       8 </span>            :  * A base class implementing nsIObjectLoadingContent for use by
<span class="lineNum">       9 </span>            :  * various content nodes that want to provide plugin/document/image
<span class="lineNum">      10 </span>            :  * loading functionality (eg &lt;embed&gt;, &lt;object&gt;, &lt;applet&gt;, etc).
<span class="lineNum">      11 </span>            :  */
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #ifndef NSOBJECTLOADINGCONTENT_H_
<span class="lineNum">      14 </span>            : #define NSOBJECTLOADINGCONTENT_H_
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/dom/BindingDeclarations.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsImageLoadingContent.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsIStreamListener.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsIChannelEventSink.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsIContentPolicy.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIObjectLoadingContent.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIRunnable.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIThreadInternal.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIFrame.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsIFrameLoader.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : class nsAsyncInstantiateEvent;
<span class="lineNum">      29 </span>            : class nsStopPluginRunnable;
<span class="lineNum">      30 </span>            : class AutoSetInstantiatingToFalse;
<span class="lineNum">      31 </span>            : class nsIPrincipal;
<span class="lineNum">      32 </span>            : class nsFrameLoader;
<span class="lineNum">      33 </span>            : class nsPluginFrame;
<span class="lineNum">      34 </span>            : class nsXULElement;
<span class="lineNum">      35 </span>            : class nsPluginInstanceOwner;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : namespace mozilla {
<span class="lineNum">      38 </span>            : namespace dom {
<span class="lineNum">      39 </span>            : template&lt;typename T&gt; class Sequence;
<span class="lineNum">      40 </span>            : struct MozPluginParameter;
<span class="lineNum">      41 </span>            : class HTMLIFrameElement;
<span class="lineNum">      42 </span>            : } // namespace dom
<span class="lineNum">      43 </span>            : } // namespace mozilla
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : class nsObjectLoadingContent : public nsImageLoadingContent
<span class="lineNum">      46 </span>            :                              , public nsIStreamListener
<span class="lineNum">      47 </span>            :                              , public nsIFrameLoaderOwner
<span class="lineNum">      48 </span>            :                              , public nsIObjectLoadingContent
<span class="lineNum">      49 </span>            :                              , public nsIChannelEventSink
<span class="lineNum">      50 </span>            : {
<span class="lineNum">      51 </span>            :   friend class AutoSetInstantiatingToFalse;
<span class="lineNum">      52 </span>            :   friend class AutoSetLoadingToFalse;
<span class="lineNum">      53 </span>            :   friend class CheckPluginStopEvent;
<span class="lineNum">      54 </span>            :   friend class nsStopPluginRunnable;
<span class="lineNum">      55 </span>            :   friend class nsAsyncInstantiateEvent;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :   public:
<span class="lineNum">      58 </span>            :     // This enum's values must be the same as the constants on
<span class="lineNum">      59 </span>            :     // nsIObjectLoadingContent
<span class="lineNum">      60 </span>            :     enum ObjectType {
<span class="lineNum">      61 </span>            :       // Loading, type not yet known. We may be waiting for a channel to open.
<span class="lineNum">      62 </span>            :       eType_Loading        = TYPE_LOADING,
<span class="lineNum">      63 </span>            :       // Content is a *non-svg* image
<span class="lineNum">      64 </span>            :       eType_Image          = TYPE_IMAGE,
<span class="lineNum">      65 </span>            :       // Content is a plugin
<span class="lineNum">      66 </span>            :       eType_Plugin         = TYPE_PLUGIN,
<span class="lineNum">      67 </span>            :       // Content is a fake plugin, which loads as a document but behaves as a
<span class="lineNum">      68 </span>            :       // plugin (see nsPluginHost::CreateFakePlugin)
<span class="lineNum">      69 </span>            :       eType_FakePlugin     = TYPE_FAKE_PLUGIN,
<span class="lineNum">      70 </span>            :       // Content is a subdocument, possibly SVG
<span class="lineNum">      71 </span>            :       eType_Document       = TYPE_DOCUMENT,
<span class="lineNum">      72 </span>            :       // No content loaded (fallback). May be showing alternate content or
<span class="lineNum">      73 </span>            :       // a custom error handler - *including* click-to-play dialogs
<span class="lineNum">      74 </span>            :       eType_Null           = TYPE_NULL
<span class="lineNum">      75 </span>            :     };
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :     enum FallbackType {
<span class="lineNum">      78 </span>            :       // The content type is not supported (e.g. plugin not installed)
<span class="lineNum">      79 </span>            :       eFallbackUnsupported = nsIObjectLoadingContent::PLUGIN_UNSUPPORTED,
<span class="lineNum">      80 </span>            :       // Showing alternate content
<span class="lineNum">      81 </span>            :       eFallbackAlternate = nsIObjectLoadingContent::PLUGIN_ALTERNATE,
<span class="lineNum">      82 </span>            :       // The plugin exists, but is disabled
<span class="lineNum">      83 </span>            :       eFallbackDisabled = nsIObjectLoadingContent::PLUGIN_DISABLED,
<span class="lineNum">      84 </span>            :       // The plugin is blocklisted and disabled
<span class="lineNum">      85 </span>            :       eFallbackBlocklisted = nsIObjectLoadingContent::PLUGIN_BLOCKLISTED,
<span class="lineNum">      86 </span>            :       // The plugin is considered outdated, but not disabled
<span class="lineNum">      87 </span>            :       eFallbackOutdated = nsIObjectLoadingContent::PLUGIN_OUTDATED,
<span class="lineNum">      88 </span>            :       // The plugin has crashed
<span class="lineNum">      89 </span>            :       eFallbackCrashed = nsIObjectLoadingContent::PLUGIN_CRASHED,
<span class="lineNum">      90 </span>            :       // Suppressed by security policy
<span class="lineNum">      91 </span>            :       eFallbackSuppressed = nsIObjectLoadingContent::PLUGIN_SUPPRESSED,
<span class="lineNum">      92 </span>            :       // Blocked by content policy
<span class="lineNum">      93 </span>            :       eFallbackUserDisabled = nsIObjectLoadingContent::PLUGIN_USER_DISABLED,
<span class="lineNum">      94 </span>            :       /// ** All values &gt;= eFallbackClickToPlay are plugin placeholder types
<span class="lineNum">      95 </span>            :       ///    that would be replaced by a real plugin if activated (PlayPlugin())
<span class="lineNum">      96 </span>            :       /// ** Furthermore, values &gt;= eFallbackClickToPlay and
<span class="lineNum">      97 </span>            :       ///    &lt;= eFallbackVulnerableNoUpdate are click-to-play types.
<span class="lineNum">      98 </span>            :       // The plugin is disabled until the user clicks on it
<span class="lineNum">      99 </span>            :       eFallbackClickToPlay = nsIObjectLoadingContent::PLUGIN_CLICK_TO_PLAY,
<span class="lineNum">     100 </span>            :       // The plugin is vulnerable (update available)
<span class="lineNum">     101 </span>            :       eFallbackVulnerableUpdatable = nsIObjectLoadingContent::PLUGIN_VULNERABLE_UPDATABLE,
<span class="lineNum">     102 </span>            :       // The plugin is vulnerable (no update available)
<span class="lineNum">     103 </span>            :       eFallbackVulnerableNoUpdate = nsIObjectLoadingContent::PLUGIN_VULNERABLE_NO_UPDATE,
<span class="lineNum">     104 </span>            :     };
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     nsObjectLoadingContent();
<span class="lineNum">     107 </span>            :     virtual ~nsObjectLoadingContent();
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     NS_DECL_NSIREQUESTOBSERVER
<span class="lineNum">     110 </span>            :     NS_DECL_NSISTREAMLISTENER
<span class="lineNum">     111 </span>            :     NS_DECL_NSIFRAMELOADEROWNER
<span class="lineNum">     112 </span>            :     NS_DECL_NSIOBJECTLOADINGCONTENT
<span class="lineNum">     113 </span>            :     NS_DECL_NSICHANNELEVENTSINK
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :     /**
<span class="lineNum">     116 </span>            :      * Object state. This is a bitmask of NS_EVENT_STATEs epresenting the
<span class="lineNum">     117 </span>            :      * current state of the object.
<span class="lineNum">     118 </span>            :      */
<a name="119"><span class="lineNum">     119 </span>            :     mozilla::EventStates ObjectState() const;</a>
<span class="lineNum">     120 </span>            : 
<a name="121"><span class="lineNum">     121 </span><span class="lineNoCov">          0 :     ObjectType Type() const { return mType; }</span></a>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     void SetIsNetworkCreated(bool aNetworkCreated)</span>
<span class="lineNum">     124 </span>            :     {
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :       mNetworkCreated = aNetworkCreated;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     /**
<span class="lineNum">     129 </span>            :      * When the object is loaded, the attributes and all nested &lt;param&gt;
<span class="lineNum">     130 </span>            :      * elements are cached as name:value string pairs to be passed as
<span class="lineNum">     131 </span>            :      * parameters when instantiating the plugin.
<span class="lineNum">     132 </span>            :      *
<span class="lineNum">     133 </span>            :      * Note: these cached values can be overriden for different quirk cases.
<span class="lineNum">     134 </span>            :      */
<span class="lineNum">     135 </span>            :     // Returns the cached attributes array.
<span class="lineNum">     136 </span>            :     void GetPluginAttributes(nsTArray&lt;mozilla::dom::MozPluginParameter&gt;&amp; aAttributes);
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     // Returns the cached &lt;param&gt; array.
<span class="lineNum">     139 </span>            :     void GetPluginParameters(nsTArray&lt;mozilla::dom::MozPluginParameter&gt;&amp; aParameters);
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :     /**
<span class="lineNum">     142 </span>            :      * Immediately instantiate a plugin instance. This is a no-op if mType !=
<span class="lineNum">     143 </span>            :      * eType_Plugin or a plugin is already running.
<span class="lineNum">     144 </span>            :      *
<span class="lineNum">     145 </span>            :      * aIsLoading indicates that we are in the loading code, and we can bypass
<span class="lineNum">     146 </span>            :      * the mIsLoading check.
<span class="lineNum">     147 </span>            :      */
<span class="lineNum">     148 </span>            :     nsresult InstantiatePluginInstance(bool aIsLoading = false);
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :     /**
<span class="lineNum">     151 </span>            :      * Notify this class the document state has changed
<span class="lineNum">     152 </span>            :      * Called by nsDocument so we may suspend plugins in inactive documents)
<span class="lineNum">     153 </span>            :      */
<span class="lineNum">     154 </span>            :     void NotifyOwnerDocumentActivityChanged();
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :     /**
<span class="lineNum">     157 </span>            :      * When a plug-in is instantiated, it can create a scriptable
<span class="lineNum">     158 </span>            :      * object that the page wants to interact with.  We expose this
<span class="lineNum">     159 </span>            :      * object by placing it on the prototype chain of our element,
<span class="lineNum">     160 </span>            :      * between the element itself and its most-derived DOM prototype.
<span class="lineNum">     161 </span>            :      *
<span class="lineNum">     162 </span>            :      * SetupProtoChain handles actually inserting the plug-in
<span class="lineNum">     163 </span>            :      * scriptable object into the proto chain if needed.
<span class="lineNum">     164 </span>            :      *
<span class="lineNum">     165 </span>            :      * DoResolve is a hook that allows us to find out when the web
<span class="lineNum">     166 </span>            :      * page is looking up a property name on our object and make sure
<span class="lineNum">     167 </span>            :      * that our plug-in, if any, is instantiated.
<span class="lineNum">     168 </span>            :      */
<span class="lineNum">     169 </span>            :     // Helper for WebIDL node wrapping
<span class="lineNum">     170 </span>            :     void SetupProtoChain(JSContext* aCx, JS::Handle&lt;JSObject*&gt; aObject);
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     // Remove plugin from protochain
<span class="lineNum">     173 </span>            :     void TeardownProtoChain();
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :     // Helper for WebIDL NeedResolve
<span class="lineNum">     176 </span>            :     bool DoResolve(JSContext* aCx, JS::Handle&lt;JSObject*&gt; aObject,
<span class="lineNum">     177 </span>            :                    JS::Handle&lt;jsid&gt; aId,
<span class="lineNum">     178 </span>            :                    JS::MutableHandle&lt;JS::PropertyDescriptor&gt; aDesc);
<span class="lineNum">     179 </span>            :     // The return value is whether DoResolve might end up resolving the given
<span class="lineNum">     180 </span>            :     // id.  If in doubt, return true.
<span class="lineNum">     181 </span>            :     static bool MayResolve(jsid aId);
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     // Helper for WebIDL enumeration
<span class="lineNum">     184 </span>            :     void GetOwnPropertyNames(JSContext* aCx, JS::AutoIdVector&amp; /* unused */,
<span class="lineNum">     185 </span>            :                              bool /* unused */, mozilla::ErrorResult&amp; aRv);
<span class="lineNum">     186 </span>            : 
<a name="187"><span class="lineNum">     187 </span>            :     // WebIDL API</a>
<span class="lineNum">     188 </span>            :     nsIDocument* GetContentDocument(nsIPrincipal&amp; aSubjectPrincipal);
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     void GetActualType(nsAString&amp; aType) const</span>
<span class="lineNum">     190 </span>            :     {
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :       CopyUTF8toUTF16(mContentType, aType);</span></a>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     uint32_t DisplayedType() const</span>
<span class="lineNum">     194 </span>            :     {
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 :       return mType;</span></a>
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     uint32_t GetContentTypeForMIMEType(const nsAString&amp; aMIMEType)</span>
<span class="lineNum">     198 </span>            :     {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :       return GetTypeOfContent(NS_ConvertUTF16toUTF8(aMIMEType), false);</span>
<span class="lineNum">     200 </span>            :     }
<a name="201"><span class="lineNum">     201 </span>            :     void PlayPlugin(mozilla::dom::SystemCallerGuarantee,</a>
<span class="lineNum">     202 </span>            :                     mozilla::ErrorResult&amp; aRv);
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     void Reload(bool aClearActivation, mozilla::ErrorResult&amp; aRv)</span>
<span class="lineNum">     204 </span>            :     {
<a name="205"><span class="lineNum">     205 </span><span class="lineNoCov">          0 :       aRv = Reload(aClearActivation);</span></a>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     bool Activated() const</span>
<span class="lineNum">     208 </span>            :     {
<a name="209"><span class="lineNum">     209 </span><span class="lineNoCov">          0 :       return mActivated;</span></a>
<span class="lineNum">     210 </span>            :     }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     nsIURI* GetSrcURI() const</span>
<span class="lineNum">     212 </span>            :     {
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       return mURI;</span>
<span class="lineNum">     214 </span>            :     }
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     /**
<span class="lineNum">     217 </span>            :      * The default state that this plugin would be without manual activation.
<span class="lineNum">     218 </span>            :      * @returns PLUGIN_ACTIVE if the default state would be active.
<span class="lineNum">     219 </span>            :      */
<a name="220"><span class="lineNum">     220 </span>            :     uint32_t DefaultFallbackType();</a>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     uint32_t PluginFallbackType() const</span>
<span class="lineNum">     223 </span>            :     {
<a name="224"><span class="lineNum">     224 </span><span class="lineNoCov">          0 :       return mFallbackType;</span></a>
<span class="lineNum">     225 </span>            :     }
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     bool HasRunningPlugin() const</span>
<span class="lineNum">     227 </span>            :     {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       return !!mInstanceOwner;</span>
<a name="229"><span class="lineNum">     229 </span>            :     }</a>
<span class="lineNum">     230 </span>            :     // FIXME rename this
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     void SkipFakePlugins(mozilla::ErrorResult&amp; aRv)</span>
<span class="lineNum">     232 </span>            :     {
<a name="233"><span class="lineNum">     233 </span><span class="lineNoCov">          0 :       aRv = SkipFakePlugins();</span></a>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     void SwapFrameLoaders(mozilla::dom::HTMLIFrameElement&amp; aOtherLoaderOwner,</span>
<span class="lineNum">     236 </span>            :                           mozilla::ErrorResult&amp; aRv)
<span class="lineNum">     237 </span>            :     {
<a name="238"><span class="lineNum">     238 </span><span class="lineNoCov">          0 :       aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);</span></a>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     void SwapFrameLoaders(nsXULElement&amp; aOtherLoaderOwner,</span>
<span class="lineNum">     241 </span>            :                           mozilla::ErrorResult&amp; aRv)
<span class="lineNum">     242 </span>            :     {
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     245 </span>            :     void LegacyCall(JSContext* aCx, JS::Handle&lt;JS::Value&gt; aThisVal,
<span class="lineNum">     246 </span>            :                     const mozilla::dom::Sequence&lt;JS::Value&gt;&amp; aArguments,
<span class="lineNum">     247 </span>            :                     JS::MutableHandle&lt;JS::Value&gt; aRetval,
<span class="lineNum">     248 </span>            :                     mozilla::ErrorResult&amp; aRv);
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :     uint32_t GetRunID(mozilla::dom::SystemCallerGuarantee,
<a name="251"><span class="lineNum">     251 </span>            :                       mozilla::ErrorResult&amp; aRv);</a>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     bool IsRewrittenYoutubeEmbed() const</span>
<span class="lineNum">     254 </span>            :     {
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       return mRewrittenYoutubeEmbed;</span>
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :     void PresetOpenerWindow(mozIDOMWindowProxy* aOpenerWindow, mozilla::ErrorResult&amp; aRv);
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :   protected:
<span class="lineNum">     261 </span>            :     /**
<span class="lineNum">     262 </span>            :      * Begins loading the object when called
<span class="lineNum">     263 </span>            :      *
<span class="lineNum">     264 </span>            :      * Attributes of |this| QI'd to nsIContent will be inspected, depending on
<span class="lineNum">     265 </span>            :      * the node type. This function currently assumes it is a &lt;applet&gt;,
<span class="lineNum">     266 </span>            :      * &lt;object&gt;, or &lt;embed&gt; tag.
<span class="lineNum">     267 </span>            :      *
<span class="lineNum">     268 </span>            :      * The instantiated plugin depends on:
<span class="lineNum">     269 </span>            :      * - The URI (&lt;embed src&gt;, &lt;object data&gt;)
<span class="lineNum">     270 </span>            :      * - The type 'hint' (type attribute)
<span class="lineNum">     271 </span>            :      * - The mime type returned by opening the URI
<span class="lineNum">     272 </span>            :      * - Enabled plugins claiming the ultimate mime type
<span class="lineNum">     273 </span>            :      * - The capabilities returned by GetCapabilities
<span class="lineNum">     274 </span>            :      * - The classid attribute, if eSupportClassID is among the capabilities
<span class="lineNum">     275 </span>            :      *
<span class="lineNum">     276 </span>            :      * If eAllowPluginSkipChannel is true, we may skip opening the URI if our
<span class="lineNum">     277 </span>            :      * type hint points to a valid plugin, deferring that responsibility to the
<span class="lineNum">     278 </span>            :      * plugin.
<span class="lineNum">     279 </span>            :      * Similarly, if no URI is provided, but a type hint for a valid plugin is
<span class="lineNum">     280 </span>            :      * present, that plugin will be instantiated
<span class="lineNum">     281 </span>            :      *
<span class="lineNum">     282 </span>            :      * Otherwise a request to that URI is made and the type sent by the server
<span class="lineNum">     283 </span>            :      * is used to find a suitable handler, EXCEPT when:
<span class="lineNum">     284 </span>            :      *  - The type hint refers to a *supported* plugin, in which case that
<span class="lineNum">     285 </span>            :      *    plugin will be instantiated regardless of the server provided type
<span class="lineNum">     286 </span>            :      *  - The server returns a binary-stream type, and our type hint refers to
<span class="lineNum">     287 </span>            :      *    a valid non-document type, we will use the type hint
<span class="lineNum">     288 </span>            :      *
<span class="lineNum">     289 </span>            :      * @param aNotify    If we should send notifications. If false, content
<span class="lineNum">     290 </span>            :      *                   loading may be deferred while appropriate frames are
<span class="lineNum">     291 </span>            :      *                   created
<span class="lineNum">     292 </span>            :      * @param aForceLoad If we should reload this content (and re-attempt the
<span class="lineNum">     293 </span>            :      *                   channel open) even if our parameters did not change
<span class="lineNum">     294 </span>            :      */
<span class="lineNum">     295 </span>            :     nsresult LoadObject(bool aNotify,
<span class="lineNum">     296 </span>            :                         bool aForceLoad = false);
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :     enum Capabilities {
<span class="lineNum">     299 </span>            :       eSupportImages       = 1u &lt;&lt; 0, // Images are supported (imgILoader)
<span class="lineNum">     300 </span>            :       eSupportPlugins      = 1u &lt;&lt; 1, // Plugins are supported (nsIPluginHost)
<span class="lineNum">     301 </span>            :       eSupportDocuments    = 1u &lt;&lt; 2, // Documents are supported
<span class="lineNum">     302 </span>            :                                         // (nsIDocumentLoaderFactory)
<span class="lineNum">     303 </span>            :                                         // This flag always includes SVG
<span class="lineNum">     304 </span>            :       eSupportClassID      = 1u &lt;&lt; 3, // The classid attribute is supported
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :       // If possible to get a *plugin* type from the type attribute *or* file
<span class="lineNum">     307 </span>            :       // extension, we can use that type and begin loading the plugin before
<span class="lineNum">     308 </span>            :       // opening a channel.
<span class="lineNum">     309 </span>            :       // A side effect of this is if the channel fails, the plugin is still
<span class="lineNum">     310 </span>            :       // running.
<span class="lineNum">     311 </span>            :       eAllowPluginSkipChannel  = 1u &lt;&lt; 4
<span class="lineNum">     312 </span>            :     };
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     /**
<span class="lineNum">     315 </span>            :      * Returns the list of capabilities this content node supports. This is a
<span class="lineNum">     316 </span>            :      * bitmask consisting of flags from the Capabilities enum.
<span class="lineNum">     317 </span>            :      *
<span class="lineNum">     318 </span>            :      * The default implementation supports all types but not
<span class="lineNum">     319 </span>            :      * eSupportClassID or eAllowPluginSkipChannel
<span class="lineNum">     320 </span>            :      */
<span class="lineNum">     321 </span>            :     virtual uint32_t GetCapabilities() const;
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     /**
<span class="lineNum">     324 </span>            :      * Destroys all loaded documents/plugins and releases references
<span class="lineNum">     325 </span>            :      */
<span class="lineNum">     326 </span>            :     void DestroyContent();
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     static void Traverse(nsObjectLoadingContent *tmp,
<span class="lineNum">     329 </span>            :                          nsCycleCollectionTraversalCallback &amp;cb);
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     void CreateStaticClone(nsObjectLoadingContent* aDest) const;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :     void DoStopPlugin(nsPluginInstanceOwner* aInstanceOwner);
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :     nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
<span class="lineNum">     336 </span>            :                         nsIContent* aBindingParent,
<span class="lineNum">     337 </span>            :                         bool aCompileEventHandler);
<span class="lineNum">     338 </span>            :     void UnbindFromTree(bool aDeep = true,
<span class="lineNum">     339 </span>            :                         bool aNullParent = true);
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :     /**
<span class="lineNum">     342 </span>            :      * Return the content policy type used for loading the element.
<span class="lineNum">     343 </span>            :      */
<span class="lineNum">     344 </span>            :     virtual nsContentPolicyType GetContentPolicyType() const = 0;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :     /**
<span class="lineNum">     347 </span>            :      * Decides whether we should load &lt;embed&gt;/&lt;object&gt; node content.
<span class="lineNum">     348 </span>            :      *
<span class="lineNum">     349 </span>            :      * If this is an &lt;embed&gt; or &lt;object&gt; node there are cases in which we should
<span class="lineNum">     350 </span>            :      * not try to load the content:
<span class="lineNum">     351 </span>            :      *
<span class="lineNum">     352 </span>            :      * - If the node is the child of a media element
<span class="lineNum">     353 </span>            :      * - If the node is the child of an &lt;object&gt; node that already has
<span class="lineNum">     354 </span>            :      *   content being loaded.
<span class="lineNum">     355 </span>            :      *
<span class="lineNum">     356 </span>            :      * In these cases, this function will return false, which will cause
<span class="lineNum">     357 </span>            :      * us to skip calling LoadObject.
<span class="lineNum">     358 </span>            :      */
<span class="lineNum">     359 </span>            :     bool BlockEmbedOrObjectContentLoading();
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   private:
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :     // Object parameter changes returned by UpdateObjectParameters
<span class="lineNum">     364 </span>            :     enum ParameterUpdateFlags {
<span class="lineNum">     365 </span>            :       eParamNoChange           = 0,
<span class="lineNum">     366 </span>            :       // Parameters that potentially affect the channel changed
<span class="lineNum">     367 </span>            :       // - mOriginalURI, mOriginalContentType
<span class="lineNum">     368 </span>            :       eParamChannelChanged     = 1u &lt;&lt; 0,
<span class="lineNum">     369 </span>            :       // Parameters that affect displayed content changed
<span class="lineNum">     370 </span>            :       // - mURI, mContentType, mType, mBaseURI
<span class="lineNum">     371 </span>            :       eParamStateChanged       = 1u &lt;&lt; 1,
<span class="lineNum">     372 </span>            :       // The effective content type changed, independant of object type. This
<span class="lineNum">     373 </span>            :       // can happen when changing from Loading -&gt; Final type, but doesn't
<span class="lineNum">     374 </span>            :       // necessarily happen when changing between object types. E.g., if a PDF
<span class="lineNum">     375 </span>            :       // handler was installed between the last load of this object and now, we
<span class="lineNum">     376 </span>            :       // might change from eType_Document -&gt; eType_Plugin without changing
<span class="lineNum">     377 </span>            :       // ContentType
<span class="lineNum">     378 </span>            :       eParamContentTypeChanged = 1u &lt;&lt; 2
<span class="lineNum">     379 </span>            :     };
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     /**
<span class="lineNum">     382 </span>            :      * Getter for child &lt;param&gt; elements that are not nested in another plugin
<span class="lineNum">     383 </span>            :      * dom element.
<span class="lineNum">     384 </span>            :      * This is an internal helper function and should not be used directly for
<span class="lineNum">     385 </span>            :      * passing parameters to the plugin instance.
<span class="lineNum">     386 </span>            :      *
<span class="lineNum">     387 </span>            :      * See GetPluginParameters and GetPluginAttributes, which also handle
<span class="lineNum">     388 </span>            :      * quirk-overrides.
<span class="lineNum">     389 </span>            :      *
<span class="lineNum">     390 </span>            :      * @param aParameters     The array containing pairs of name/value strings
<span class="lineNum">     391 </span>            :      *                        from nested &lt;param&gt; objects.
<span class="lineNum">     392 </span>            :      * @param aIgnoreCodebase Flag for ignoring the &quot;codebase&quot; param when
<span class="lineNum">     393 </span>            :      *                        building the array. This is useful when loading
<span class="lineNum">     394 </span>            :      *                        java.
<span class="lineNum">     395 </span>            :      */
<span class="lineNum">     396 </span>            :     void GetNestedParams(nsTArray&lt;mozilla::dom::MozPluginParameter&gt;&amp; aParameters,
<span class="lineNum">     397 </span>            :                          bool aIgnoreCodebase);
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :     MOZ_MUST_USE nsresult BuildParametersArray();
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :     /**
<span class="lineNum">     402 </span>            :      * Loads fallback content with the specified FallbackType
<span class="lineNum">     403 </span>            :      *
<span class="lineNum">     404 </span>            :      * @param aType   FallbackType value for type of fallback we're loading
<span class="lineNum">     405 </span>            :      * @param aNotify Send notifications and events. If false, caller is
<span class="lineNum">     406 </span>            :      *                responsible for doing so
<span class="lineNum">     407 </span>            :      */
<span class="lineNum">     408 </span>            :     void LoadFallback(FallbackType aType, bool aNotify);
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :     /**
<span class="lineNum">     411 </span>            :      * Internal version of LoadObject that should only be used by this class
<span class="lineNum">     412 </span>            :      * aLoadingChannel is passed by the LoadObject call from OnStartRequest,
<span class="lineNum">     413 </span>            :      * primarily for sanity-preservation
<span class="lineNum">     414 </span>            :      */
<span class="lineNum">     415 </span>            :     nsresult LoadObject(bool aNotify,
<span class="lineNum">     416 </span>            :                         bool aForceLoad,
<span class="lineNum">     417 </span>            :                         nsIRequest *aLoadingChannel);
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :     /**
<span class="lineNum">     420 </span>            :      * Introspects the object and sets the following member variables:
<span class="lineNum">     421 </span>            :      * - mOriginalContentType : This is the type attribute on the element
<span class="lineNum">     422 </span>            :      * - mOriginalURI         : The src or data attribute on the element
<span class="lineNum">     423 </span>            :      * - mURI                 : The final URI, considering mChannel if
<span class="lineNum">     424 </span>            :      *                          mChannelLoaded is set
<span class="lineNum">     425 </span>            :      * - mContentType         : The final content type, considering mChannel if
<span class="lineNum">     426 </span>            :      *                          mChannelLoaded is set
<span class="lineNum">     427 </span>            :      * - mBaseURI             : The object's base URI, which may be set by the
<span class="lineNum">     428 </span>            :      *                          object (codebase attribute)
<span class="lineNum">     429 </span>            :      * - mType                : The type the object is determined to be based
<span class="lineNum">     430 </span>            :      *                          on the above
<span class="lineNum">     431 </span>            :      *
<span class="lineNum">     432 </span>            :      * NOTE The class assumes that mType is the currently loaded type at various
<span class="lineNum">     433 </span>            :      *      points, so the caller of this function must take the appropriate
<span class="lineNum">     434 </span>            :      *      actions to ensure this
<span class="lineNum">     435 </span>            :      *
<span class="lineNum">     436 </span>            :      * NOTE This function does not perform security checks, only determining the
<span class="lineNum">     437 </span>            :      *      requested type and parameters of the object.
<span class="lineNum">     438 </span>            :      *
<span class="lineNum">     439 </span>            :      * @param aJavaURI Specify that the URI will be consumed by java, which
<span class="lineNum">     440 </span>            :      *                 changes codebase parsing and URI construction. Used
<span class="lineNum">     441 </span>            :      *                 internally.
<span class="lineNum">     442 </span>            :      *
<span class="lineNum">     443 </span>            :      * @return Returns a bitmask of ParameterUpdateFlags values
<span class="lineNum">     444 </span>            :      */
<span class="lineNum">     445 </span>            :     ParameterUpdateFlags UpdateObjectParameters(bool aJavaURI = false);
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :     /**
<span class="lineNum">     448 </span>            :      * Queue a CheckPluginStopEvent and track it in mPendingCheckPluginStopEvent
<span class="lineNum">     449 </span>            :      */
<span class="lineNum">     450 </span>            :     void QueueCheckPluginStopEvent();
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :     void NotifyContentObjectWrapper();
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :     /**
<span class="lineNum">     455 </span>            :      * Opens the channel pointed to by mURI into mChannel.
<span class="lineNum">     456 </span>            :      */
<span class="lineNum">     457 </span>            :     nsresult OpenChannel();
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     /**
<span class="lineNum">     460 </span>            :      * Closes and releases references to mChannel and, if opened, mFinalListener
<span class="lineNum">     461 </span>            :      */
<span class="lineNum">     462 </span>            :     nsresult CloseChannel();
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :     /**
<span class="lineNum">     465 </span>            :      * If this object should be tested against blocking list.
<span class="lineNum">     466 </span>            :      */
<span class="lineNum">     467 </span>            :     bool ShouldBlockContent();
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :     /**
<span class="lineNum">     470 </span>            :      * If this object is allowed to play plugin content, or if it would display
<span class="lineNum">     471 </span>            :      * click-to-play instead.
<span class="lineNum">     472 </span>            :      * NOTE that this does not actually check if the object is a loadable plugin
<span class="lineNum">     473 </span>            :      * NOTE This ignores the current activated state. The caller should check
<span class="lineNum">     474 </span>            :      *      this if appropriate.
<span class="lineNum">     475 </span>            :      */
<span class="lineNum">     476 </span>            :     bool ShouldPlay(FallbackType &amp;aReason);
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :     /**
<span class="lineNum">     479 </span>            :      * This method tells if the fallback content should be attempted to be used
<span class="lineNum">     480 </span>            :      * over the original object content.
<span class="lineNum">     481 </span>            :      * It will look at prefs and this plugin's CTP state to make a decision.
<span class="lineNum">     482 </span>            :      *
<span class="lineNum">     483 </span>            :      * NOTE that this doesn't say whether the fallback _will_ be used, only whether
<span class="lineNum">     484 </span>            :      * we should look into it to possibly use it. The final answer will be
<span class="lineNum">     485 </span>            :      * given by the PreferFallback method.
<span class="lineNum">     486 </span>            :      *
<span class="lineNum">     487 </span>            :      * @param aIsPluginClickToPlay Whether this object instance is CTP.
<span class="lineNum">     488 </span>            :      */
<span class="lineNum">     489 </span>            :     bool FavorFallbackMode(bool aIsPluginClickToPlay);
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     /**
<span class="lineNum">     492 </span>            :      * Whether the page has provided good fallback content to this object.
<span class="lineNum">     493 </span>            :      */
<span class="lineNum">     494 </span>            :     bool HasGoodFallback();
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :     /**
<span class="lineNum">     497 </span>            :      * This method tells the final answer on whether this object's fallback
<span class="lineNum">     498 </span>            :      * content should be used instead of the original plugin content.
<span class="lineNum">     499 </span>            :      *
<span class="lineNum">     500 </span>            :      * @param aIsPluginClickToPlay Whether this object instance is CTP.
<span class="lineNum">     501 </span>            :      */
<span class="lineNum">     502 </span>            :     bool PreferFallback(bool aIsPluginClickToPlay);
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :     /*
<span class="lineNum">     505 </span>            :      * Helper to check if mBaseURI can be used by java as a codebase
<span class="lineNum">     506 </span>            :      */
<span class="lineNum">     507 </span>            :     bool CheckJavaCodebase();
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :     /**
<span class="lineNum">     510 </span>            :      * Helper to check if our current URI passes policy
<span class="lineNum">     511 </span>            :      *
<span class="lineNum">     512 </span>            :      * @param aContentPolicy [out] The result of the content policy decision
<span class="lineNum">     513 </span>            :      *
<span class="lineNum">     514 </span>            :      * @return true if call succeeded and NS_CP_ACCEPTED(*aContentPolicy)
<span class="lineNum">     515 </span>            :      */
<span class="lineNum">     516 </span>            :     bool CheckLoadPolicy(int16_t *aContentPolicy);
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     /**
<span class="lineNum">     519 </span>            :      * Helper to check if the object passes process policy. Assumes we have a
<span class="lineNum">     520 </span>            :      * final determined type.
<span class="lineNum">     521 </span>            :      *
<span class="lineNum">     522 </span>            :      * @param aContentPolicy [out] The result of the content policy decision
<span class="lineNum">     523 </span>            :      *
<span class="lineNum">     524 </span>            :      * @return true if call succeeded and NS_CP_ACCEPTED(*aContentPolicy)
<span class="lineNum">     525 </span>            :      */
<span class="lineNum">     526 </span>            :     bool CheckProcessPolicy(int16_t *aContentPolicy);
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :     /**
<span class="lineNum">     529 </span>            :      * Gets the plugin instance and creates a plugin stream listener, assigning
<span class="lineNum">     530 </span>            :      * it to mFinalListener
<span class="lineNum">     531 </span>            :      */
<span class="lineNum">     532 </span>            :     bool MakePluginListener();
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :     void SetupFrameLoader(int32_t aJSPluginId);
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :     /**
<span class="lineNum">     537 </span>            :      * Helper to spawn mFrameLoader and return a pointer to its docshell
<span class="lineNum">     538 </span>            :      *
<span class="lineNum">     539 </span>            :      * @param aURI URI we intend to load for the recursive load check (does not
<span class="lineNum">     540 </span>            :      *             actually load anything)
<span class="lineNum">     541 </span>            :      */
<span class="lineNum">     542 </span>            :     already_AddRefed&lt;nsIDocShell&gt; SetupDocShell(nsIURI* aRecursionCheckURI);
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :     /**
<span class="lineNum">     545 </span>            :      * Unloads all content and resets the object to a completely unloaded state
<span class="lineNum">     546 </span>            :      *
<span class="lineNum">     547 </span>            :      * NOTE Calls StopPluginInstance() and may spin the event loop
<span class="lineNum">     548 </span>            :      *
<span class="lineNum">     549 </span>            :      * @param aResetState Reset the object type to 'loading' and destroy channel
<span class="lineNum">     550 </span>            :      *                    as well
<span class="lineNum">     551 </span>            :      */
<span class="lineNum">     552 </span>            :     void UnloadObject(bool aResetState = true);
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :     /**
<span class="lineNum">     555 </span>            :      * Notifies document observes about a new type/state of this object.
<span class="lineNum">     556 </span>            :      * Triggers frame construction as needed. mType must be set correctly when
<span class="lineNum">     557 </span>            :      * this method is called. This method is cheap if the type and state didn't
<span class="lineNum">     558 </span>            :      * actually change.
<span class="lineNum">     559 </span>            :      *
<span class="lineNum">     560 </span>            :      * @param aSync If a synchronous frame construction is required. If false,
<span class="lineNum">     561 </span>            :      *              the construction may either be sync or async.
<span class="lineNum">     562 </span>            :      * @param aNotify if false, only need to update the state of our element.
<span class="lineNum">     563 </span>            :      */
<span class="lineNum">     564 </span>            :     void NotifyStateChanged(ObjectType aOldType,
<span class="lineNum">     565 </span>            :                             mozilla::EventStates aOldState,
<span class="lineNum">     566 </span>            :                             bool aSync, bool aNotify);
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     /**
<span class="lineNum">     569 </span>            :      * Returns a ObjectType value corresponding to the type of content we would
<span class="lineNum">     570 </span>            :      * support the given MIME type as, taking capabilities and plugin state
<span class="lineNum">     571 </span>            :      * into account
<span class="lineNum">     572 </span>            :      *
<span class="lineNum">     573 </span>            :      * @param aNoFakePlugin Don't select a fake plugin handler as a valid type,
<span class="lineNum">     574 </span>            :      *                      as when SkipFakePlugins() is called.
<span class="lineNum">     575 </span>            :      * @return The ObjectType enum value that we would attempt to load
<span class="lineNum">     576 </span>            :      *
<span class="lineNum">     577 </span>            :      * NOTE this does not consider whether the content would be suppressed by
<span class="lineNum">     578 </span>            :      *      click-to-play or other content policy checks
<span class="lineNum">     579 </span>            :      */
<span class="lineNum">     580 </span>            :     ObjectType GetTypeOfContent(const nsCString&amp; aMIMEType, bool aNoFakePlugin);
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :     /**
<span class="lineNum">     583 </span>            :      * Gets the frame that's associated with this content node.
<span class="lineNum">     584 </span>            :      * Does not flush.
<span class="lineNum">     585 </span>            :      */
<span class="lineNum">     586 </span>            :     nsPluginFrame* GetExistingFrame();
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :     /**
<span class="lineNum">     589 </span>            :      * Used for identifying whether we can rewrite a youtube flash embed to
<span class="lineNum">     590 </span>            :      * possibly use HTML5 instead.
<span class="lineNum">     591 </span>            :      *
<span class="lineNum">     592 </span>            :      * Returns true if plugin.rewrite_youtube_embeds pref is true and the
<span class="lineNum">     593 </span>            :      * element this nsObjectLoadingContent instance represents:
<span class="lineNum">     594 </span>            :      *
<span class="lineNum">     595 </span>            :      * - is an embed or object node
<span class="lineNum">     596 </span>            :      * - has a URL pointing at the youtube.com domain, using &quot;/v/&quot; style video
<span class="lineNum">     597 </span>            :      *   path reference, and without enablejsapi=1 in the path
<span class="lineNum">     598 </span>            :      *
<span class="lineNum">     599 </span>            :      * Having the enablejsapi flag means the document that contains the element
<span class="lineNum">     600 </span>            :      * could possibly be manipulating the youtube video elsewhere on the page
<span class="lineNum">     601 </span>            :      * via javascript. We can't rewrite these kinds of elements without possibly
<span class="lineNum">     602 </span>            :      * breaking content, which we want to avoid.
<span class="lineNum">     603 </span>            :      *
<span class="lineNum">     604 </span>            :      * If we can rewrite the URL, we change the &quot;/v/&quot; to &quot;/embed/&quot;, and change
<span class="lineNum">     605 </span>            :      * our type to eType_Document so that we render similarly to an iframe
<span class="lineNum">     606 </span>            :      * embed.
<span class="lineNum">     607 </span>            :      */
<span class="lineNum">     608 </span>            :     void MaybeRewriteYoutubeEmbed(nsIURI* aURI,
<span class="lineNum">     609 </span>            :                                   nsIURI* aBaseURI,
<span class="lineNum">     610 </span>            :                                   nsIURI** aRewrittenURI);
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :     // Helper class for SetupProtoChain
<a name="613"><span class="lineNum">     613 </span>            :     class SetupProtoChainRunner final : public nsIRunnable</a>
<span class="lineNum">     614 </span>            :     {
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       ~SetupProtoChainRunner() = default;</span>
<span class="lineNum">     616 </span>            :     public:
<span class="lineNum">     617 </span>            :       NS_DECL_ISUPPORTS
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :       explicit SetupProtoChainRunner(nsObjectLoadingContent* aContent);
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :       NS_IMETHOD Run() override;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :     private:
<span class="lineNum">     624 </span>            :       // We store an nsIObjectLoadingContent because we can
<span class="lineNum">     625 </span>            :       // unambiguously refcount that.
<span class="lineNum">     626 </span>            :       RefPtr&lt;nsIObjectLoadingContent&gt; mContent;
<span class="lineNum">     627 </span>            :     };
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     // Utility getter for getting our nsNPAPIPluginInstance in a safe way.
<span class="lineNum">     630 </span>            :     nsresult ScriptRequestPluginInstance(JSContext* aCx,
<span class="lineNum">     631 </span>            :                                          nsNPAPIPluginInstance** aResult);
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :     // Utility method for getting our plugin JSObject
<span class="lineNum">     634 </span>            :     static nsresult GetPluginJSObject(JSContext *cx,
<span class="lineNum">     635 </span>            :                                       JS::Handle&lt;JSObject*&gt; obj,
<span class="lineNum">     636 </span>            :                                       nsNPAPIPluginInstance *plugin_inst,
<span class="lineNum">     637 </span>            :                                       JS::MutableHandle&lt;JSObject*&gt; plugin_obj,
<span class="lineNum">     638 </span>            :                                       JS::MutableHandle&lt;JSObject*&gt; plugin_proto);
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     // Utility for firing an error event, if we're an &lt;object&gt;.
<span class="lineNum">     641 </span>            :     void MaybeFireErrorEvent();
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :     // The final listener for mChannel (uriloader, pluginstreamlistener, etc.)
<span class="lineNum">     644 </span>            :     nsCOMPtr&lt;nsIStreamListener&gt; mFinalListener;
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :     // Frame loader, for content documents we load.
<span class="lineNum">     647 </span>            :     RefPtr&lt;nsFrameLoader&gt;     mFrameLoader;
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :     // Track if we have a pending AsyncInstantiateEvent
<span class="lineNum">     650 </span>            :     nsCOMPtr&lt;nsIRunnable&gt;       mPendingInstantiateEvent;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :     // Tracks if we have a pending CheckPluginStopEvent
<span class="lineNum">     653 </span>            :     nsCOMPtr&lt;nsIRunnable&gt;       mPendingCheckPluginStopEvent;
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :     // The content type of our current load target, updated by
<span class="lineNum">     656 </span>            :     // UpdateObjectParameters(). Takes the channel's type into account once
<span class="lineNum">     657 </span>            :     // opened.
<span class="lineNum">     658 </span>            :     //
<span class="lineNum">     659 </span>            :     // May change if a channel is opened, does not imply a loaded state
<span class="lineNum">     660 </span>            :     nsCString                   mContentType;
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :     // The content type 'hint' provided by the element's type attribute. May
<span class="lineNum">     663 </span>            :     // or may not be used as a final type
<span class="lineNum">     664 </span>            :     nsCString                   mOriginalContentType;
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :     // The channel that's currently being loaded. If set, but mChannelLoaded is
<span class="lineNum">     667 </span>            :     // false, has not yet reached OnStartRequest
<span class="lineNum">     668 </span>            :     nsCOMPtr&lt;nsIChannel&gt;        mChannel;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :     // The URI of the current content.
<span class="lineNum">     671 </span>            :     // May change as we open channels and encounter redirects - does not imply
<span class="lineNum">     672 </span>            :     // a loaded type
<span class="lineNum">     673 </span>            :     nsCOMPtr&lt;nsIURI&gt;            mURI;
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :     // The original URI obtained from inspecting the element (codebase, and
<span class="lineNum">     676 </span>            :     // src/data). May differ from mURI due to redirects
<span class="lineNum">     677 </span>            :     nsCOMPtr&lt;nsIURI&gt;            mOriginalURI;
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :     // The baseURI used for constructing mURI, and used by some plugins (java)
<span class="lineNum">     680 </span>            :     // as a root for other resource requests.
<span class="lineNum">     681 </span>            :     nsCOMPtr&lt;nsIURI&gt;            mBaseURI;
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :     // Type of the currently-loaded content.
<span class="lineNum">     686 </span>            :     ObjectType                  mType           : 8;
<span class="lineNum">     687 </span>            :     // The type of fallback content we're showing (see ObjectState())
<span class="lineNum">     688 </span>            :     FallbackType                mFallbackType : 8;
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :     uint32_t                    mRunID;
<span class="lineNum">     691 </span>            :     bool                        mHasRunID : 1;
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :     // If true, we have opened a channel as the listener and it has reached
<span class="lineNum">     694 </span>            :     // OnStartRequest. Does not get set for channels that are passed directly to
<span class="lineNum">     695 </span>            :     // the plugin listener.
<span class="lineNum">     696 </span>            :     bool                        mChannelLoaded    : 1;
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :     // Whether we are about to call instantiate on our frame. If we aren't,
<span class="lineNum">     699 </span>            :     // SetFrame needs to asynchronously call Instantiate.
<span class="lineNum">     700 </span>            :     bool                        mInstantiating : 1;
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :     // True when the object is created for an element which the parser has
<span class="lineNum">     703 </span>            :     // created using NS_FROM_PARSER_NETWORK flag. If the element is modified,
<span class="lineNum">     704 </span>            :     // it may lose the flag.
<span class="lineNum">     705 </span>            :     bool                        mNetworkCreated : 1;
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :     // Used to keep track of whether or not a plugin has been explicitly
<span class="lineNum">     708 </span>            :     // activated by PlayPlugin(). (see ShouldPlay())
<span class="lineNum">     709 </span>            :     bool                        mActivated : 1;
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :     // Whether content blocking is enabled or not for this object.
<span class="lineNum">     712 </span>            :     bool                        mContentBlockingEnabled : 1;
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :     // If we should not use fake plugins until the next type change
<span class="lineNum">     715 </span>            :     bool                        mSkipFakePlugins : 1;
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :     // Protects DoStopPlugin from reentry (bug 724781).
<span class="lineNum">     718 </span>            :     bool                        mIsStopping : 1;
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     // Protects LoadObject from re-entry
<span class="lineNum">     721 </span>            :     bool                        mIsLoading : 1;
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :     // For plugin stand-in types (click-to-play) tracks whether content js has
<span class="lineNum">     724 </span>            :     // tried to access the plugin script object.
<span class="lineNum">     725 </span>            :     bool                        mScriptRequested : 1;
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     // True if object represents an object/embed tag pointing to a flash embed
<span class="lineNum">     728 </span>            :     // for a youtube video. When possible (see IsRewritableYoutubeEmbed function
<span class="lineNum">     729 </span>            :     // comments for details), we change these to try to load HTML5 versions of
<span class="lineNum">     730 </span>            :     // videos.
<span class="lineNum">     731 </span>            :     bool                        mRewrittenYoutubeEmbed : 1;
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :     // Cache the answer of PreferFallback() because ShouldPlay is called several
<span class="lineNum">     734 </span>            :     // times during the load process.
<span class="lineNum">     735 </span>            :     bool                        mPreferFallback : 1;
<span class="lineNum">     736 </span>            :     bool                        mPreferFallbackKnown : 1;
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     WeakFrame                   mPrintFrame;
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :     RefPtr&lt;nsPluginInstanceOwner&gt; mInstanceOwner;
<span class="lineNum">     741 </span>            :     nsTArray&lt;mozilla::dom::MozPluginParameter&gt; mCachedAttributes;
<span class="lineNum">     742 </span>            :     nsTArray&lt;mozilla::dom::MozPluginParameter&gt; mCachedParameters;
<span class="lineNum">     743 </span>            : };
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

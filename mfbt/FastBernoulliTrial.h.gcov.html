<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - mfbt/FastBernoulliTrial.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">mfbt</a> - FastBernoulliTrial.h<span style="font-size: 80%;"> (source / <a href="FastBernoulliTrial.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">41.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">60.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef mozilla_FastBernoulliTrial_h
<span class="lineNum">       8 </span>            : #define mozilla_FastBernoulliTrial_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/XorShift128PlusRNG.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      14 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : namespace mozilla {
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : /**
<span class="lineNum">      19 </span>            :  * class FastBernoulliTrial: Efficient sampling with uniform probability
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * When gathering statistics about a program's behavior, we may be observing
<span class="lineNum">      22 </span>            :  * events that occur very frequently (e.g., function calls or memory
<span class="lineNum">      23 </span>            :  * allocations) and we may be gathering information that is somewhat expensive
<span class="lineNum">      24 </span>            :  * to produce (e.g., call stacks). Sampling all the events could have a
<span class="lineNum">      25 </span>            :  * significant impact on the program's performance.
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Why not just sample every N'th event? This technique is called &quot;systematic
<span class="lineNum">      28 </span>            :  * sampling&quot;; it's simple and efficient, and it's fine if we imagine a
<span class="lineNum">      29 </span>            :  * patternless stream of events. But what if we're sampling allocations, and the
<span class="lineNum">      30 </span>            :  * program happens to have a loop where each iteration does exactly N
<span class="lineNum">      31 </span>            :  * allocations? You would end up sampling the same allocation every time through
<span class="lineNum">      32 </span>            :  * the loop; the entire rest of the loop becomes invisible to your measurements!
<span class="lineNum">      33 </span>            :  * More generally, if each iteration does M allocations, and M and N have any
<span class="lineNum">      34 </span>            :  * common divisor at all, most allocation sites will never be sampled. If
<span class="lineNum">      35 </span>            :  * they're both even, say, the odd-numbered allocations disappear from your
<span class="lineNum">      36 </span>            :  * results.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  * Ideally, we'd like each event to have some probability P of being sampled,
<span class="lineNum">      39 </span>            :  * independent of its neighbors and of its position in the sequence. This is
<span class="lineNum">      40 </span>            :  * called &quot;Bernoulli sampling&quot;, and it doesn't suffer from any of the problems
<span class="lineNum">      41 </span>            :  * mentioned above.
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * One disadvantage of Bernoulli sampling is that you can't be sure exactly how
<span class="lineNum">      44 </span>            :  * many samples you'll get: technically, it's possible that you might sample
<span class="lineNum">      45 </span>            :  * none of them, or all of them. But if the number of events N is large, these
<span class="lineNum">      46 </span>            :  * aren't likely outcomes; you can generally expect somewhere around P * N
<span class="lineNum">      47 </span>            :  * events to be sampled.
<span class="lineNum">      48 </span>            :  *
<span class="lineNum">      49 </span>            :  * The other disadvantage of Bernoulli sampling is that you have to generate a
<span class="lineNum">      50 </span>            :  * random number for every event, which can be slow.
<span class="lineNum">      51 </span>            :  *
<span class="lineNum">      52 </span>            :  * [significant pause]
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * BUT NOT WITH THIS CLASS! FastBernoulliTrial lets you do true Bernoulli
<span class="lineNum">      55 </span>            :  * sampling, while generating a fresh random number only when we do decide to
<span class="lineNum">      56 </span>            :  * sample an event, not on every trial. When it decides not to sample, a call to
<span class="lineNum">      57 </span>            :  * |FastBernoulliTrial::trial| is nothing but decrementing a counter and
<span class="lineNum">      58 </span>            :  * comparing it to zero. So the lower your sampling probability is, the less
<span class="lineNum">      59 </span>            :  * overhead FastBernoulliTrial imposes.
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  * Probabilities of 0 and 1 are handled efficiently. (In neither case need we
<span class="lineNum">      62 </span>            :  * ever generate a random number at all.)
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  * The essential API:
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  * - FastBernoulliTrial(double P)
<span class="lineNum">      67 </span>            :  *   Construct an instance that selects events with probability P.
<span class="lineNum">      68 </span>            :  *
<span class="lineNum">      69 </span>            :  * - FastBernoulliTrial::trial()
<span class="lineNum">      70 </span>            :  *   Return true with probability P. Call this each time an event occurs, to
<span class="lineNum">      71 </span>            :  *   decide whether to sample it or not.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * - FastBernoulliTrial::trial(size_t n)
<span class="lineNum">      74 </span>            :  *   Equivalent to calling trial() |n| times, and returning true if any of those
<span class="lineNum">      75 </span>            :  *   calls do. However, like trial, this runs in fast constant time.
<span class="lineNum">      76 </span>            :  *
<span class="lineNum">      77 </span>            :  *   What is this good for? In some applications, some events are &quot;bigger&quot; than
<span class="lineNum">      78 </span>            :  *   others. For example, large allocations are more significant than small
<span class="lineNum">      79 </span>            :  *   allocations. Perhaps we'd like to imagine that we're drawing allocations
<span class="lineNum">      80 </span>            :  *   from a stream of bytes, and performing a separate Bernoulli trial on every
<span class="lineNum">      81 </span>            :  *   byte from the stream. We can accomplish this by calling |t.trial(S)| for
<span class="lineNum">      82 </span>            :  *   the number of bytes S, and sampling the event if that returns true.
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  *   Of course, this style of sampling needs to be paired with analysis and
<span class="lineNum">      85 </span>            :  *   presentation that makes the size of the event apparent, lest trials with
<span class="lineNum">      86 </span>            :  *   large values for |n| appear to be indistinguishable from those with small
<span class="lineNum">      87 </span>            :  *   values for |n|.
<span class="lineNum">      88 </span>            :  */
<span class="lineNum">      89 </span>            : class FastBernoulliTrial {
<span class="lineNum">      90 </span>            :   /*
<span class="lineNum">      91 </span>            :    * This comment should just read, &quot;Generate skip counts with a geometric
<span class="lineNum">      92 </span>            :    * distribution&quot;, and leave everyone to go look that up and see why it's the
<span class="lineNum">      93 </span>            :    * right thing to do, if they don't know already.
<span class="lineNum">      94 </span>            :    *
<span class="lineNum">      95 </span>            :    * BUT IF YOU'RE CURIOUS, COMMENTS ARE FREE...
<span class="lineNum">      96 </span>            :    *
<span class="lineNum">      97 </span>            :    * Instead of generating a fresh random number for every trial, we can
<span class="lineNum">      98 </span>            :    * randomly generate a count of how many times we should return false before
<span class="lineNum">      99 </span>            :    * the next time we return true. We call this a &quot;skip count&quot;. Once we've
<span class="lineNum">     100 </span>            :    * returned true, we generate a fresh skip count, and begin counting down
<span class="lineNum">     101 </span>            :    * again.
<span class="lineNum">     102 </span>            :    *
<span class="lineNum">     103 </span>            :    * Here's an awesome fact: by exercising a little care in the way we generate
<span class="lineNum">     104 </span>            :    * skip counts, we can produce results indistinguishable from those we would
<span class="lineNum">     105 </span>            :    * get &quot;rolling the dice&quot; afresh for every trial.
<span class="lineNum">     106 </span>            :    *
<span class="lineNum">     107 </span>            :    * In short, skip counts in Bernoulli trials of probability P obey a geometric
<span class="lineNum">     108 </span>            :    * distribution. If a random variable X is uniformly distributed from [0..1),
<span class="lineNum">     109 </span>            :    * then std::floor(std::log(X) / std::log(1-P)) has the appropriate geometric
<span class="lineNum">     110 </span>            :    * distribution for the skip counts.
<span class="lineNum">     111 </span>            :    *
<span class="lineNum">     112 </span>            :    * Why that formula?
<span class="lineNum">     113 </span>            :    *
<span class="lineNum">     114 </span>            :    * Suppose we're to return |true| with some probability P, say, 0.3. Spread
<span class="lineNum">     115 </span>            :    * all possible futures along a line segment of length 1. In portion P of
<span class="lineNum">     116 </span>            :    * those cases, we'll return true on the next call to |trial|; the skip count
<span class="lineNum">     117 </span>            :    * is 0. For the remaining portion 1-P of cases, the skip count is 1 or more.
<span class="lineNum">     118 </span>            :    *
<span class="lineNum">     119 </span>            :    * skip:                0                         1 or more
<span class="lineNum">     120 </span>            :    *             |------------------^-----------------------------------------|
<span class="lineNum">     121 </span>            :    * portion:            0.3                            0.7
<span class="lineNum">     122 </span>            :    *                      P                             1-P
<span class="lineNum">     123 </span>            :    *
<span class="lineNum">     124 </span>            :    * But the &quot;1 or more&quot; section of the line is subdivided the same way: *within
<span class="lineNum">     125 </span>            :    * that section*, in portion P the second call to |trial()| returns true, and in
<span class="lineNum">     126 </span>            :    * portion 1-P it returns false a second time; the skip count is two or more.
<span class="lineNum">     127 </span>            :    * So we return true on the second call in proportion 0.7 * 0.3, and skip at
<span class="lineNum">     128 </span>            :    * least the first two in proportion 0.7 * 0.7.
<span class="lineNum">     129 </span>            :    *
<span class="lineNum">     130 </span>            :    * skip:                0                1              2 or more
<span class="lineNum">     131 </span>            :    *             |------------------^------------^----------------------------|
<span class="lineNum">     132 </span>            :    * portion:            0.3           0.7 * 0.3          0.7 * 0.7
<span class="lineNum">     133 </span>            :    *                      P             (1-P)*P            (1-P)^2
<span class="lineNum">     134 </span>            :    *
<span class="lineNum">     135 </span>            :    * We can continue to subdivide:
<span class="lineNum">     136 </span>            :    *
<span class="lineNum">     137 </span>            :    * skip &gt;= 0:  |------------------------------------------------- (1-P)^0 --|
<span class="lineNum">     138 </span>            :    * skip &gt;= 1:  |                  ------------------------------- (1-P)^1 --|
<span class="lineNum">     139 </span>            :    * skip &gt;= 2:  |                               ------------------ (1-P)^2 --|
<span class="lineNum">     140 </span>            :    * skip &gt;= 3:  |                                 ^     ---------- (1-P)^3 --|
<span class="lineNum">     141 </span>            :    * skip &gt;= 4:  |                                 .            --- (1-P)^4 --|
<span class="lineNum">     142 </span>            :    *                                               .
<span class="lineNum">     143 </span>            :    *                                               ^X, see below
<span class="lineNum">     144 </span>            :    *
<span class="lineNum">     145 </span>            :    * In other words, the likelihood of the next n calls to |trial| returning
<span class="lineNum">     146 </span>            :    * false is (1-P)^n. The longer a run we require, the more the likelihood
<span class="lineNum">     147 </span>            :    * drops. Further calls may return false too, but this is the probability
<span class="lineNum">     148 </span>            :    * we'll skip at least n.
<span class="lineNum">     149 </span>            :    *
<span class="lineNum">     150 </span>            :    * This is interesting, because we can pick a point along this line segment
<span class="lineNum">     151 </span>            :    * and see which skip count's range it falls within; the point X above, for
<span class="lineNum">     152 </span>            :    * example, is within the &quot;&gt;= 2&quot; range, but not within the &quot;&gt;= 3&quot; range, so it
<span class="lineNum">     153 </span>            :    * designates a skip count of 2. So if we pick points on the line at random
<span class="lineNum">     154 </span>            :    * and use the skip counts they fall under, that will be indistinguishable
<span class="lineNum">     155 </span>            :    * from generating a fresh random number between 0 and 1 for each trial and
<span class="lineNum">     156 </span>            :    * comparing it to P.
<span class="lineNum">     157 </span>            :    *
<span class="lineNum">     158 </span>            :    * So to find the skip count for a point X, we must ask: To what whole power
<span class="lineNum">     159 </span>            :    * must we raise 1-P such that we include X, but the next power would exclude
<span class="lineNum">     160 </span>            :    * it? This is exactly std::floor(std::log(X) / std::log(1-P)).
<span class="lineNum">     161 </span>            :    *
<span class="lineNum">     162 </span>            :    * Our algorithm is then, simply: When constructed, compute an initial skip
<span class="lineNum">     163 </span>            :    * count. Return false from |trial| that many times, and then compute a new skip
<span class="lineNum">     164 </span>            :    * count.
<span class="lineNum">     165 </span>            :    *
<span class="lineNum">     166 </span>            :    * For a call to |trial(n)|, if the skip count is greater than n, return false
<span class="lineNum">     167 </span>            :    * and subtract n from the skip count. If the skip count is less than n,
<span class="lineNum">     168 </span>            :    * return true and compute a new skip count. Since each trial is independent,
<span class="lineNum">     169 </span>            :    * it doesn't matter by how much n overshoots the skip count; we can actually
<span class="lineNum">     170 </span>            :    * compute a new skip count at *any* time without affecting the distribution.
<span class="lineNum">     171 </span>            :    * This is really beautiful.
<span class="lineNum">     172 </span>            :    */
<span class="lineNum">     173 </span>            :  public:
<span class="lineNum">     174 </span>            :   /**
<span class="lineNum">     175 </span>            :    * Construct a fast Bernoulli trial generator. Calls to |trial()| return true
<span class="lineNum">     176 </span>            :    * with probability |aProbability|. Use |aState0| and |aState1| to seed the
<a name="177"><span class="lineNum">     177 </span>            :    * random number generator; both may not be zero.</a>
<span class="lineNum">     178 </span>            :    */
<span class="lineNum">     179 </span><span class="lineCov">        315 :   FastBernoulliTrial(double aProbability, uint64_t aState0, uint64_t aState1)</span>
<span class="lineNum">     180 </span><span class="lineCov">        315 :    : mProbability(0)</span>
<span class="lineNum">     181 </span>            :    , mInvLogNotProbability(0)
<span class="lineNum">     182 </span>            :    , mGenerator(aState0, aState1)
<span class="lineNum">     183 </span><span class="lineCov">        315 :    , mSkipCount(0)</span>
<span class="lineNum">     184 </span>            :   {
<span class="lineNum">     185 </span><span class="lineCov">        315 :     setProbability(aProbability);</span>
<span class="lineNum">     186 </span><span class="lineCov">        315 :   }</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :   /**
<span class="lineNum">     189 </span>            :    * Return true with probability |mProbability|. Call this each time an event
<span class="lineNum">     190 </span>            :    * occurs, to decide whether to sample it or not. The lower |mProbability| is,
<a name="191"><span class="lineNum">     191 </span>            :    * the faster this function runs.</a>
<span class="lineNum">     192 </span>            :    */
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   bool trial() {</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     if (mSkipCount) {</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :       mSkipCount--;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     197 </span>            :     }
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     return chooseSkipCount();</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :   /**
<span class="lineNum">     203 </span>            :    * Equivalent to calling trial() |n| times, and returning true if any of those
<span class="lineNum">     204 </span>            :    * calls do. However, like trial, this runs in fast constant time.
<span class="lineNum">     205 </span>            :    *
<span class="lineNum">     206 </span>            :    * What is this good for? In some applications, some events are &quot;bigger&quot; than
<span class="lineNum">     207 </span>            :    * others. For example, large allocations are more significant than small
<span class="lineNum">     208 </span>            :    * allocations. Perhaps we'd like to imagine that we're drawing allocations
<span class="lineNum">     209 </span>            :    * from a stream of bytes, and performing a separate Bernoulli trial on every
<span class="lineNum">     210 </span>            :    * byte from the stream. We can accomplish this by calling |t.trial(S)| for
<span class="lineNum">     211 </span>            :    * the number of bytes S, and sampling the event if that returns true.
<span class="lineNum">     212 </span>            :    *
<span class="lineNum">     213 </span>            :    * Of course, this style of sampling needs to be paired with analysis and
<span class="lineNum">     214 </span>            :    * presentation that makes the &quot;size&quot; of the event apparent, lest trials with
<span class="lineNum">     215 </span>            :    * large values for |n| appear to be indistinguishable from those with small
<span class="lineNum">     216 </span>            :    * values for |n|, despite being potentially much more likely to be sampled.
<span class="lineNum">     217 </span>            :    */
<span class="lineNum">     218 </span>            :   bool trial(size_t aCount) {
<span class="lineNum">     219 </span>            :     if (mSkipCount &gt; aCount) {
<span class="lineNum">     220 </span>            :       mSkipCount -= aCount;
<span class="lineNum">     221 </span>            :       return false;
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :     return chooseSkipCount();
<a name="225"><span class="lineNum">     225 </span>            :   }</a>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   void setRandomState(uint64_t aState0, uint64_t aState1) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     mGenerator.setState(aState0, aState1);</span>
<a name="229"><span class="lineNum">     229 </span><span class="lineNoCov">          0 :   }</span></a>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">        315 :   void setProbability(double aProbability) {</span>
<span class="lineNum">     232 </span><span class="lineCov">        315 :     MOZ_ASSERT(0 &lt;= aProbability &amp;&amp; aProbability &lt;= 1);</span>
<span class="lineNum">     233 </span><span class="lineCov">        315 :     mProbability = aProbability;</span>
<span class="lineNum">     234 </span><span class="lineCov">        315 :     if (0 &lt; mProbability &amp;&amp; mProbability &lt; 1) {</span>
<span class="lineNum">     235 </span>            :       /*
<span class="lineNum">     236 </span>            :        * Let's look carefully at how this calculation plays out in floating-
<span class="lineNum">     237 </span>            :        * point arithmetic. We'll assume IEEE, but the final C++ code we arrive
<span class="lineNum">     238 </span>            :        * at would still be fine if our numbers were mathematically perfect. So,
<span class="lineNum">     239 </span>            :        * while we've considered IEEE's edge cases, we haven't done anything that
<span class="lineNum">     240 </span>            :        * should be actively bad when using other representations.
<span class="lineNum">     241 </span>            :        *
<span class="lineNum">     242 </span>            :        * (In the below, read comparisons as exact mathematical comparisons: when
<span class="lineNum">     243 </span>            :        * we say something &quot;equals 1&quot;, that means it's exactly equal to 1. We
<span class="lineNum">     244 </span>            :        * treat approximation using intervals with open boundaries: saying a
<span class="lineNum">     245 </span>            :        * value is in (0,1) doesn't specify how close to 0 or 1 the value gets.
<span class="lineNum">     246 </span>            :        * When we use closed boundaries like [2**-53, 1], we're careful to ensure
<span class="lineNum">     247 </span>            :        * the boundary values are actually representable.)
<span class="lineNum">     248 </span>            :        *
<span class="lineNum">     249 </span>            :        * - After the comparison above, we know mProbability is in (0,1).
<span class="lineNum">     250 </span>            :        *
<span class="lineNum">     251 </span>            :        * - The gaps below 1 are 2**-53, so that interval is (0, 1-2**-53].
<span class="lineNum">     252 </span>            :        *
<span class="lineNum">     253 </span>            :        * - Because the floating-point gaps near 1 are wider than those near
<span class="lineNum">     254 </span>            :        *   zero, there are many small positive doubles ε such that 1-ε rounds to
<span class="lineNum">     255 </span>            :        *   exactly 1. However, 2**-53 can be represented exactly. So
<span class="lineNum">     256 </span>            :        *   1-mProbability is in [2**-53, 1].
<span class="lineNum">     257 </span>            :        *
<span class="lineNum">     258 </span>            :        * - log(1 - mProbability) is thus in (-37, 0].
<span class="lineNum">     259 </span>            :        *
<span class="lineNum">     260 </span>            :        *   That range includes zero, but when we use mInvLogNotProbability, it
<span class="lineNum">     261 </span>            :        *   would be helpful if we could trust that it's negative. So when log(1
<span class="lineNum">     262 </span>            :        *   - mProbability) is 0, we'll just set mProbability to 0, so that
<span class="lineNum">     263 </span>            :        *   mInvLogNotProbability is not used in chooseSkipCount.
<span class="lineNum">     264 </span>            :        *
<span class="lineNum">     265 </span>            :        * - How much of the range of mProbability does this cause us to ignore?
<span class="lineNum">     266 </span>            :        *   The only value for which log returns 0 is exactly 1; the slope of log
<span class="lineNum">     267 </span>            :        *   at 1 is 1, so for small ε such that 1 - ε != 1, log(1 - ε) is -ε,
<span class="lineNum">     268 </span>            :        *   never 0. The gaps near one are larger than the gaps near zero, so if
<span class="lineNum">     269 </span>            :        *   1 - ε wasn't 1, then -ε is representable. So if log(1 - mProbability)
<span class="lineNum">     270 </span>            :        *   isn't 0, then 1 - mProbability isn't 1, which means that mProbability
<span class="lineNum">     271 </span>            :        *   is at least 2**-53, as discussed earlier. This is a sampling
<span class="lineNum">     272 </span>            :        *   likelihood of roughly one in ten trillion, which is unlikely to be
<span class="lineNum">     273 </span>            :        *   distinguishable from zero in practice.
<span class="lineNum">     274 </span>            :        *
<span class="lineNum">     275 </span>            :        *   So by forbidding zero, we've tightened our range to (-37, -2**-53].
<span class="lineNum">     276 </span>            :        *
<span class="lineNum">     277 </span>            :        * - Finally, 1 / log(1 - mProbability) is in [-2**53, -1/37). This all
<span class="lineNum">     278 </span>            :        *   falls readily within the range of an IEEE double.
<span class="lineNum">     279 </span>            :        *
<span class="lineNum">     280 </span>            :        * ALL THAT HAVING BEEN SAID: here are the five lines of actual code:
<span class="lineNum">     281 </span>            :        */
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :       double logNotProbability = std::log(1 - mProbability);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :       if (logNotProbability == 0.0)</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         mProbability = 0.0;</span>
<span class="lineNum">     285 </span>            :       else
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         mInvLogNotProbability = 1 / logNotProbability;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineCov">        315 :     chooseSkipCount();</span>
<span class="lineNum">     290 </span><span class="lineCov">        315 :   }</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :  private:
<span class="lineNum">     293 </span>            :   /* The likelihood that any given call to |trial| should return true. */
<span class="lineNum">     294 </span>            :   double mProbability;
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   /*
<span class="lineNum">     297 </span>            :    * The value of 1/std::log(1 - mProbability), cached for repeated use.
<span class="lineNum">     298 </span>            :    *
<span class="lineNum">     299 </span>            :    * If mProbability is exactly 0 or exactly 1, we don't use this value.
<span class="lineNum">     300 </span>            :    * Otherwise, we guarantee this value is in the range [-2**53, -1/37), i.e.
<span class="lineNum">     301 </span>            :    * definitely negative, as required by chooseSkipCount. See setProbability for
<span class="lineNum">     302 </span>            :    * the details.
<span class="lineNum">     303 </span>            :    */
<span class="lineNum">     304 </span>            :   double mInvLogNotProbability;
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   /* Our random number generator. */
<span class="lineNum">     307 </span>            :   non_crypto::XorShift128PlusRNG mGenerator;
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :   /* The number of times |trial| should return false before next returning true. */
<span class="lineNum">     310 </span>            :   size_t mSkipCount;
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   /*
<span class="lineNum">     313 </span>            :    * Choose the next skip count. This also returns the value that |trial| should
<span class="lineNum">     314 </span>            :    * return, since we have to check for the extreme values for mProbability
<a name="315"><span class="lineNum">     315 </span>            :    * anyway, and |trial| should never return true at all when mProbability is 0.</a>
<span class="lineNum">     316 </span>            :    */
<span class="lineNum">     317 </span><span class="lineCov">        315 :   bool chooseSkipCount() {</span>
<span class="lineNum">     318 </span>            :     /*
<span class="lineNum">     319 </span>            :      * If the probability is 1.0, every call to |trial| returns true. Make sure
<span class="lineNum">     320 </span>            :      * mSkipCount is 0.
<span class="lineNum">     321 </span>            :      */
<span class="lineNum">     322 </span><span class="lineCov">        315 :     if (mProbability == 1.0) {</span>
<span class="lineNum">     323 </span><span class="lineCov">        315 :       mSkipCount = 0;</span>
<span class="lineNum">     324 </span><span class="lineCov">        315 :       return true;</span>
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :     /*
<span class="lineNum">     328 </span>            :      * If the probabilility is zero, |trial| never returns true. Don't bother us
<span class="lineNum">     329 </span>            :      * for a while.
<span class="lineNum">     330 </span>            :      */
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     if (mProbability == 0.0) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :       mSkipCount = SIZE_MAX;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     334 </span>            :     }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :     /*
<span class="lineNum">     337 </span>            :      * What sorts of values can this call to std::floor produce?
<span class="lineNum">     338 </span>            :      *
<span class="lineNum">     339 </span>            :      * Since mGenerator.nextDouble returns a value in [0, 1-2**-53], std::log
<span class="lineNum">     340 </span>            :      * returns a value in the range [-infinity, -2**-53], all negative. Since
<span class="lineNum">     341 </span>            :      * mInvLogNotProbability is negative (see its comments), the product is
<span class="lineNum">     342 </span>            :      * positive and possibly infinite. std::floor returns +infinity unchanged.
<span class="lineNum">     343 </span>            :      * So the result will always be positive.
<span class="lineNum">     344 </span>            :      *
<span class="lineNum">     345 </span>            :      * Converting a double to an integer that is out of range for that integer
<span class="lineNum">     346 </span>            :      * is undefined behavior, so we must clamp our result to SIZE_MAX, to ensure
<span class="lineNum">     347 </span>            :      * we get an acceptable value for mSkipCount.
<span class="lineNum">     348 </span>            :      *
<span class="lineNum">     349 </span>            :      * The clamp is written carefully. Note that if we had said:
<span class="lineNum">     350 </span>            :      *
<span class="lineNum">     351 </span>            :      *    if (skipCount &gt; SIZE_MAX)
<span class="lineNum">     352 </span>            :      *       skipCount = SIZE_MAX;
<span class="lineNum">     353 </span>            :      *
<span class="lineNum">     354 </span>            :      * that leads to undefined behavior 64-bit machines: SIZE_MAX coerced to
<span class="lineNum">     355 </span>            :      * double is 2^64, not 2^64-1, so this doesn't actually set skipCount to a
<span class="lineNum">     356 </span>            :      * value that can be safely assigned to mSkipCount.
<span class="lineNum">     357 </span>            :      *
<span class="lineNum">     358 </span>            :      * Jakub Oleson cleverly suggested flipping the sense of the comparison: if
<span class="lineNum">     359 </span>            :      * we require that skipCount &lt; SIZE_MAX, then because of the gaps (2048)
<span class="lineNum">     360 </span>            :      * between doubles at that magnitude, the highest double less than 2^64 is
<span class="lineNum">     361 </span>            :      * 2^64 - 2048, which is fine to store in a size_t.
<span class="lineNum">     362 </span>            :      *
<span class="lineNum">     363 </span>            :      * (On 32-bit machines, all size_t values can be represented exactly in
<span class="lineNum">     364 </span>            :      * double, so all is well.)
<span class="lineNum">     365 </span>            :      */
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     double skipCount = std::floor(std::log(mGenerator.nextDouble())</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :                                   * mInvLogNotProbability);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (skipCount &lt; SIZE_MAX)</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       mSkipCount = skipCount;</span>
<span class="lineNum">     370 </span>            :     else
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       mSkipCount = SIZE_MAX;</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span>            : };
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : }  /* namespace mozilla */
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : #endif /* mozilla_FastBernoulliTrial_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

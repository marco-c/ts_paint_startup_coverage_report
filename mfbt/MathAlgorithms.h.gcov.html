<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - mfbt/MathAlgorithms.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">mfbt</a> - MathAlgorithms.h<span style="font-size: 80%;"> (source / <a href="MathAlgorithms.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntry">79</td>
            <td class="headerCovTableEntryLo">64.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntry">42</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* mfbt maths algorithms. */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #ifndef mozilla_MathAlgorithms_h
<span class="lineNum">      10 </span>            : #define mozilla_MathAlgorithms_h
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/TypeTraits.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      16 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">      17 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : namespace mozilla {
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : // Greatest Common Divisor
<a name="22"><span class="lineNum">      22 </span>            : template&lt;typename IntegerType&gt;</a>
<span class="lineNum">      23 </span>            : MOZ_ALWAYS_INLINE IntegerType
<span class="lineNum">      24 </span><span class="lineNoCov">          0 : EuclidGCD(IntegerType aA, IntegerType aB)</span>
<span class="lineNum">      25 </span>            : {
<span class="lineNum">      26 </span>            :   // Euclid's algorithm; O(N) in the worst case.  (There are better
<span class="lineNum">      27 </span>            :   // ways, but we don't need them for the current use of this algo.)
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aA &gt; IntegerType(0));</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aB &gt; IntegerType(0));</span>
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :   while (aA != aB) {</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :     if (aA &gt; aB) {</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :       aA = aA - aB;</span>
<span class="lineNum">      34 </span>            :     } else {
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :       aB = aB - aA;</span>
<span class="lineNum">      36 </span>            :     }
<span class="lineNum">      37 </span>            :   }
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   return aA;</span>
<span class="lineNum">      40 </span>            : }
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // Least Common Multiple
<a name="43"><span class="lineNum">      43 </span>            : template&lt;typename IntegerType&gt;</a>
<span class="lineNum">      44 </span>            : MOZ_ALWAYS_INLINE IntegerType
<span class="lineNum">      45 </span><span class="lineNoCov">          0 : EuclidLCM(IntegerType aA, IntegerType aB)</span>
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :   // Divide first to reduce overflow risk.
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   return (aA / EuclidGCD(aA, aB)) * aB;</span>
<span class="lineNum">      49 </span>            : }
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : namespace detail {
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : template&lt;typename T&gt;
<span class="lineNum">      54 </span>            : struct AllowDeprecatedAbsFixed : FalseType {};
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : template&lt;&gt; struct AllowDeprecatedAbsFixed&lt;int32_t&gt; : TrueType {};
<span class="lineNum">      57 </span>            : template&lt;&gt; struct AllowDeprecatedAbsFixed&lt;int64_t&gt; : TrueType {};
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : template&lt;typename T&gt;
<span class="lineNum">      60 </span>            : struct AllowDeprecatedAbs : AllowDeprecatedAbsFixed&lt;T&gt; {};
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : template&lt;&gt; struct AllowDeprecatedAbs&lt;int&gt; : TrueType {};
<span class="lineNum">      63 </span>            : template&lt;&gt; struct AllowDeprecatedAbs&lt;long&gt; : TrueType {};
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : } // namespace detail
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : // DO NOT USE DeprecatedAbs.  It exists only until its callers can be converted
<span class="lineNum">      68 </span>            : // to Abs below, and it will be removed when all callers have been changed.
<a name="69"><span class="lineNum">      69 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">      70 </span>            : inline typename mozilla::EnableIf&lt;detail::AllowDeprecatedAbs&lt;T&gt;::value, T&gt;::Type
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : DeprecatedAbs(const T aValue)</span>
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span>            :   // The absolute value of the smallest possible value of a signed-integer type
<span class="lineNum">      74 </span>            :   // won't fit in that type (on twos-complement systems -- and we're blithely
<span class="lineNum">      75 </span>            :   // assuming we're on such systems, for the non-&lt;stdint.h&gt; types listed above),
<span class="lineNum">      76 </span>            :   // so assert that the input isn't that value.
<span class="lineNum">      77 </span>            :   //
<span class="lineNum">      78 </span>            :   // This is the case if: the value is non-negative; or if adding one (giving a
<span class="lineNum">      79 </span>            :   // value in the range [-maxvalue, 0]), then negating (giving a value in the
<span class="lineNum">      80 </span>            :   // range [0, maxvalue]), doesn't produce maxvalue (because in twos-complement,
<span class="lineNum">      81 </span>            :   // (minvalue + 1) == -maxvalue).
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aValue &gt;= 0 ||</span>
<span class="lineNum">      83 </span>            :              -(aValue + 1) != T((1ULL &lt;&lt; (CHAR_BIT * sizeof(T) - 1)) - 1),
<span class="lineNum">      84 </span>            :              &quot;You can't negate the smallest possible negative integer!&quot;);
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   return aValue &gt;= 0 ? aValue : -aValue;</span>
<span class="lineNum">      86 </span>            : }
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : namespace detail {
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : // For now mozilla::Abs only takes intN_T, the signed natural types, and
<span class="lineNum">      91 </span>            : // float/double/long double.  Feel free to add overloads for other standard,
<span class="lineNum">      92 </span>            : // signed types if you need them.
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : template&lt;typename T&gt;
<span class="lineNum">      95 </span>            : struct AbsReturnTypeFixed;
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : template&lt;&gt; struct AbsReturnTypeFixed&lt;int8_t&gt; { typedef uint8_t Type; };
<span class="lineNum">      98 </span>            : template&lt;&gt; struct AbsReturnTypeFixed&lt;int16_t&gt; { typedef uint16_t Type; };
<span class="lineNum">      99 </span>            : template&lt;&gt; struct AbsReturnTypeFixed&lt;int32_t&gt; { typedef uint32_t Type; };
<span class="lineNum">     100 </span>            : template&lt;&gt; struct AbsReturnTypeFixed&lt;int64_t&gt; { typedef uint64_t Type; };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : template&lt;typename T&gt;
<span class="lineNum">     103 </span>            : struct AbsReturnType : AbsReturnTypeFixed&lt;T&gt; {};
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : template&lt;&gt; struct AbsReturnType&lt;char&gt; :
<span class="lineNum">     106 </span>            :   EnableIf&lt;char(-1) &lt; char(0), unsigned char&gt; {};
<span class="lineNum">     107 </span>            : template&lt;&gt; struct AbsReturnType&lt;signed char&gt; { typedef unsigned char Type; };
<span class="lineNum">     108 </span>            : template&lt;&gt; struct AbsReturnType&lt;short&gt; { typedef unsigned short Type; };
<span class="lineNum">     109 </span>            : template&lt;&gt; struct AbsReturnType&lt;int&gt; { typedef unsigned int Type; };
<span class="lineNum">     110 </span>            : template&lt;&gt; struct AbsReturnType&lt;long&gt; { typedef unsigned long Type; };
<span class="lineNum">     111 </span>            : template&lt;&gt; struct AbsReturnType&lt;long long&gt; { typedef unsigned long long Type; };
<span class="lineNum">     112 </span>            : template&lt;&gt; struct AbsReturnType&lt;float&gt; { typedef float Type; };
<span class="lineNum">     113 </span>            : template&lt;&gt; struct AbsReturnType&lt;double&gt; { typedef double Type; };
<span class="lineNum">     114 </span>            : template&lt;&gt; struct AbsReturnType&lt;long double&gt; { typedef long double Type; };
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : } // namespace detail
<span class="lineNum">     117 </span>            : 
<a name="118"><span class="lineNum">     118 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     119 </span>            : inline typename detail::AbsReturnType&lt;T&gt;::Type
<span class="lineNum">     120 </span><span class="lineCov">       3222 : Abs(const T aValue)</span>
<span class="lineNum">     121 </span>            : {
<span class="lineNum">     122 </span>            :   typedef typename detail::AbsReturnType&lt;T&gt;::Type ReturnType;
<span class="lineNum">     123 </span><span class="lineCov">       3222 :   return aValue &gt;= 0 ? ReturnType(aValue) : ~ReturnType(aValue) + 1;</span>
<span class="lineNum">     124 </span>            : }
<span class="lineNum">     125 </span>            : 
<a name="126"><span class="lineNum">     126 </span>            : template&lt;&gt;</a>
<span class="lineNum">     127 </span>            : inline float
<span class="lineNum">     128 </span><span class="lineCov">        578 : Abs&lt;float&gt;(const float aFloat)</span>
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span><span class="lineCov">        578 :   return std::fabs(aFloat);</span>
<span class="lineNum">     131 </span>            : }
<span class="lineNum">     132 </span>            : 
<a name="133"><span class="lineNum">     133 </span>            : template&lt;&gt;</a>
<span class="lineNum">     134 </span>            : inline double
<span class="lineNum">     135 </span><span class="lineCov">        120 : Abs&lt;double&gt;(const double aDouble)</span>
<span class="lineNum">     136 </span>            : {
<span class="lineNum">     137 </span><span class="lineCov">        120 :   return std::fabs(aDouble);</span>
<span class="lineNum">     138 </span>            : }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : template&lt;&gt;
<span class="lineNum">     141 </span>            : inline long double
<span class="lineNum">     142 </span>            : Abs&lt;long double&gt;(const long double aLongDouble)
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span>            :   return std::fabs(aLongDouble);
<span class="lineNum">     145 </span>            : }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : } // namespace mozilla
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : #if defined(_MSC_VER) &amp;&amp; \
<span class="lineNum">     150 </span>            :     (defined(_M_IX86) || defined(_M_AMD64) || defined(_M_X64))
<span class="lineNum">     151 </span>            : #  define MOZ_BITSCAN_WINDOWS
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : #  include &lt;intrin.h&gt;
<span class="lineNum">     154 </span>            : #  pragma intrinsic(_BitScanForward, _BitScanReverse)
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : #  if defined(_M_AMD64) || defined(_M_X64)
<span class="lineNum">     157 </span>            : #    define MOZ_BITSCAN_WINDOWS64
<span class="lineNum">     158 </span>            : #   pragma intrinsic(_BitScanForward64, _BitScanReverse64)
<span class="lineNum">     159 </span>            : #  endif
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : #endif
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : namespace mozilla {
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : namespace detail {
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : #if defined(MOZ_BITSCAN_WINDOWS)
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : inline uint_fast8_t
<span class="lineNum">     170 </span>            : CountLeadingZeroes32(uint32_t aValue)
<span class="lineNum">     171 </span>            : {
<span class="lineNum">     172 </span>            :   unsigned long index;
<span class="lineNum">     173 </span>            :   if (!_BitScanReverse(&amp;index, static_cast&lt;unsigned long&gt;(aValue)))
<span class="lineNum">     174 </span>            :       return 32;
<span class="lineNum">     175 </span>            :   return uint_fast8_t(31 - index);
<span class="lineNum">     176 </span>            : }
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : inline uint_fast8_t
<span class="lineNum">     180 </span>            : CountTrailingZeroes32(uint32_t aValue)
<span class="lineNum">     181 </span>            : {
<span class="lineNum">     182 </span>            :   unsigned long index;
<span class="lineNum">     183 </span>            :   if (!_BitScanForward(&amp;index, static_cast&lt;unsigned long&gt;(aValue)))
<span class="lineNum">     184 </span>            :       return 32;
<span class="lineNum">     185 </span>            :   return uint_fast8_t(index);
<span class="lineNum">     186 </span>            : }
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : inline uint_fast8_t
<span class="lineNum">     189 </span>            : CountPopulation32(uint32_t aValue)
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span>            :   uint32_t x = aValue - ((aValue &gt;&gt; 1) &amp; 0x55555555);
<span class="lineNum">     192 </span>            :   x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);
<span class="lineNum">     193 </span>            :   return (((x + (x &gt;&gt; 4)) &amp; 0xf0f0f0f) * 0x1010101) &gt;&gt; 24;
<span class="lineNum">     194 </span>            : }
<span class="lineNum">     195 </span>            : inline uint_fast8_t
<span class="lineNum">     196 </span>            : CountPopulation64(uint64_t aValue)
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span>            :   return uint_fast8_t(CountPopulation32(aValue &amp; 0xffffffff) +
<span class="lineNum">     199 </span>            :                       CountPopulation32(aValue &gt;&gt; 32));
<span class="lineNum">     200 </span>            : }
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : inline uint_fast8_t
<span class="lineNum">     203 </span>            : CountLeadingZeroes64(uint64_t aValue)
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span>            : #if defined(MOZ_BITSCAN_WINDOWS64)
<span class="lineNum">     206 </span>            :   unsigned long index;
<span class="lineNum">     207 </span>            :   if (!_BitScanReverse64(&amp;index, static_cast&lt;unsigned __int64&gt;(aValue)))
<span class="lineNum">     208 </span>            :       return 64;
<span class="lineNum">     209 </span>            :   return uint_fast8_t(63 - index);
<span class="lineNum">     210 </span>            : #else
<span class="lineNum">     211 </span>            :   uint32_t hi = uint32_t(aValue &gt;&gt; 32);
<span class="lineNum">     212 </span>            :   if (hi != 0) {
<span class="lineNum">     213 </span>            :     return CountLeadingZeroes32(hi);
<span class="lineNum">     214 </span>            :   }
<span class="lineNum">     215 </span>            :   return 32u + CountLeadingZeroes32(uint32_t(aValue));
<span class="lineNum">     216 </span>            : #endif
<span class="lineNum">     217 </span>            : }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : inline uint_fast8_t
<span class="lineNum">     220 </span>            : CountTrailingZeroes64(uint64_t aValue)
<span class="lineNum">     221 </span>            : {
<span class="lineNum">     222 </span>            : #if defined(MOZ_BITSCAN_WINDOWS64)
<span class="lineNum">     223 </span>            :   unsigned long index;
<span class="lineNum">     224 </span>            :   if (!_BitScanForward64(&amp;index, static_cast&lt;unsigned __int64&gt;(aValue)))
<span class="lineNum">     225 </span>            :       return 64;
<span class="lineNum">     226 </span>            :   return uint_fast8_t(index);
<span class="lineNum">     227 </span>            : #else
<span class="lineNum">     228 </span>            :   uint32_t lo = uint32_t(aValue);
<span class="lineNum">     229 </span>            :   if (lo != 0) {
<span class="lineNum">     230 </span>            :     return CountTrailingZeroes32(lo);
<span class="lineNum">     231 </span>            :   }
<span class="lineNum">     232 </span>            :   return 32u + CountTrailingZeroes32(uint32_t(aValue &gt;&gt; 32));
<span class="lineNum">     233 </span>            : #endif
<span class="lineNum">     234 </span>            : }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : #  ifdef MOZ_HAVE_BITSCAN64
<span class="lineNum">     237 </span>            : #    undef MOZ_HAVE_BITSCAN64
<span class="lineNum">     238 </span>            : #  endif
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : #elif defined(__clang__) || defined(__GNUC__)
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : #  if defined(__clang__)
<span class="lineNum">     243 </span>            : #    if !__has_builtin(__builtin_ctz) || !__has_builtin(__builtin_clz)
<span class="lineNum">     244 </span>            : #      error &quot;A clang providing __builtin_c[lt]z is required to build&quot;
<span class="lineNum">     245 </span>            : #    endif
<span class="lineNum">     246 </span>            : #  else
<span class="lineNum">     247 </span>            :      // gcc has had __builtin_clz and friends since 3.4: no need to check.
<span class="lineNum">     248 </span>            : #  endif
<a name="249"><span class="lineNum">     249 </span>            : </a>
<span class="lineNum">     250 </span>            : inline uint_fast8_t
<span class="lineNum">     251 </span><span class="lineCov">     234682 : CountLeadingZeroes32(uint32_t aValue)</span>
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span><span class="lineCov">     234682 :   return __builtin_clz(aValue);</span>
<span class="lineNum">     254 </span>            : }
<a name="255"><span class="lineNum">     255 </span>            : </a>
<span class="lineNum">     256 </span>            : inline uint_fast8_t
<span class="lineNum">     257 </span><span class="lineCov">     209264 : CountTrailingZeroes32(uint32_t aValue)</span>
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineCov">     209264 :   return __builtin_ctz(aValue);</span>
<span class="lineNum">     260 </span>            : }
<a name="261"><span class="lineNum">     261 </span>            : </a>
<span class="lineNum">     262 </span>            : inline uint_fast8_t
<span class="lineNum">     263 </span><span class="lineCov">     113737 : CountPopulation32(uint32_t aValue)</span>
<span class="lineNum">     264 </span>            : {
<span class="lineNum">     265 </span><span class="lineCov">     113737 :   return __builtin_popcount(aValue);</span>
<span class="lineNum">     266 </span>            : }
<a name="267"><span class="lineNum">     267 </span>            : </a>
<span class="lineNum">     268 </span>            : inline uint_fast8_t
<span class="lineNum">     269 </span><span class="lineNoCov">          0 : CountPopulation64(uint64_t aValue)</span>
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   return __builtin_popcountll(aValue);</span>
<span class="lineNum">     272 </span>            : }
<a name="273"><span class="lineNum">     273 </span>            : </a>
<span class="lineNum">     274 </span>            : inline uint_fast8_t
<span class="lineNum">     275 </span><span class="lineCov">    2475534 : CountLeadingZeroes64(uint64_t aValue)</span>
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span><span class="lineCov">    2475534 :   return __builtin_clzll(aValue);</span>
<span class="lineNum">     278 </span>            : }
<a name="279"><span class="lineNum">     279 </span>            : </a>
<span class="lineNum">     280 </span>            : inline uint_fast8_t
<span class="lineNum">     281 </span><span class="lineCov">       7155 : CountTrailingZeroes64(uint64_t aValue)</span>
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineCov">       7155 :   return __builtin_ctzll(aValue);</span>
<span class="lineNum">     284 </span>            : }
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : #else
<span class="lineNum">     287 </span>            : #  error &quot;Implement these!&quot;
<span class="lineNum">     288 </span>            : inline uint_fast8_t CountLeadingZeroes32(uint32_t aValue) = delete;
<span class="lineNum">     289 </span>            : inline uint_fast8_t CountTrailingZeroes32(uint32_t aValue) = delete;
<span class="lineNum">     290 </span>            : inline uint_fast8_t CountPopulation32(uint32_t aValue) = delete;
<span class="lineNum">     291 </span>            : inline uint_fast8_t CountPopulation64(uint64_t aValue) = delete;
<span class="lineNum">     292 </span>            : inline uint_fast8_t CountLeadingZeroes64(uint64_t aValue) = delete;
<span class="lineNum">     293 </span>            : inline uint_fast8_t CountTrailingZeroes64(uint64_t aValue) = delete;
<span class="lineNum">     294 </span>            : #endif
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : } // namespace detail
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : /**
<span class="lineNum">     299 </span>            :  * Compute the number of high-order zero bits in the NON-ZERO number |aValue|.
<span class="lineNum">     300 </span>            :  * That is, looking at the bitwise representation of the number, with the
<span class="lineNum">     301 </span>            :  * highest- valued bits at the start, return the number of zeroes before the
<span class="lineNum">     302 </span>            :  * first one is observed.
<span class="lineNum">     303 </span>            :  *
<span class="lineNum">     304 </span>            :  * CountLeadingZeroes32(0xF0FF1000) is 0;
<span class="lineNum">     305 </span>            :  * CountLeadingZeroes32(0x7F8F0001) is 1;
<span class="lineNum">     306 </span>            :  * CountLeadingZeroes32(0x3FFF0100) is 2;
<span class="lineNum">     307 </span>            :  * CountLeadingZeroes32(0x1FF50010) is 3; and so on.
<a name="308"><span class="lineNum">     308 </span>            :  */</a>
<span class="lineNum">     309 </span>            : inline uint_fast8_t
<span class="lineNum">     310 </span><span class="lineCov">     182879 : CountLeadingZeroes32(uint32_t aValue)</span>
<span class="lineNum">     311 </span>            : {
<span class="lineNum">     312 </span><span class="lineCov">     182879 :   MOZ_ASSERT(aValue != 0);</span>
<span class="lineNum">     313 </span><span class="lineCov">     182879 :   return detail::CountLeadingZeroes32(aValue);</span>
<span class="lineNum">     314 </span>            : }
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : /**
<span class="lineNum">     317 </span>            :  * Compute the number of low-order zero bits in the NON-ZERO number |aValue|.
<span class="lineNum">     318 </span>            :  * That is, looking at the bitwise representation of the number, with the
<span class="lineNum">     319 </span>            :  * lowest- valued bits at the start, return the number of zeroes before the
<span class="lineNum">     320 </span>            :  * first one is observed.
<span class="lineNum">     321 </span>            :  *
<span class="lineNum">     322 </span>            :  * CountTrailingZeroes32(0x0100FFFF) is 0;
<span class="lineNum">     323 </span>            :  * CountTrailingZeroes32(0x7000FFFE) is 1;
<span class="lineNum">     324 </span>            :  * CountTrailingZeroes32(0x0080FFFC) is 2;
<span class="lineNum">     325 </span>            :  * CountTrailingZeroes32(0x0080FFF8) is 3; and so on.
<a name="326"><span class="lineNum">     326 </span>            :  */</a>
<span class="lineNum">     327 </span>            : inline uint_fast8_t
<span class="lineNum">     328 </span><span class="lineCov">     209264 : CountTrailingZeroes32(uint32_t aValue)</span>
<span class="lineNum">     329 </span>            : {
<span class="lineNum">     330 </span><span class="lineCov">     209264 :   MOZ_ASSERT(aValue != 0);</span>
<span class="lineNum">     331 </span><span class="lineCov">     209264 :   return detail::CountTrailingZeroes32(aValue);</span>
<span class="lineNum">     332 </span>            : }
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : /**
<span class="lineNum">     335 </span>            :  * Compute the number of one bits in the number |aValue|,
<a name="336"><span class="lineNum">     336 </span>            :  */</a>
<span class="lineNum">     337 </span>            : inline uint_fast8_t
<span class="lineNum">     338 </span><span class="lineCov">     113737 : CountPopulation32(uint32_t aValue)</span>
<span class="lineNum">     339 </span>            : {
<span class="lineNum">     340 </span><span class="lineCov">     113737 :   return detail::CountPopulation32(aValue);</span>
<span class="lineNum">     341 </span>            : }
<span class="lineNum">     342 </span>            : 
<a name="343"><span class="lineNum">     343 </span>            : /** Analogous to CountPopulation32, but for 64-bit numbers */</a>
<span class="lineNum">     344 </span>            : inline uint_fast8_t
<span class="lineNum">     345 </span><span class="lineNoCov">          0 : CountPopulation64(uint64_t aValue)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   return detail::CountPopulation64(aValue);</span>
<span class="lineNum">     348 </span>            : }
<span class="lineNum">     349 </span>            : 
<a name="350"><span class="lineNum">     350 </span>            : /** Analogous to CountLeadingZeroes32, but for 64-bit numbers. */</a>
<span class="lineNum">     351 </span>            : inline uint_fast8_t
<span class="lineNum">     352 </span><span class="lineCov">     662344 : CountLeadingZeroes64(uint64_t aValue)</span>
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span><span class="lineCov">     662344 :   MOZ_ASSERT(aValue != 0);</span>
<span class="lineNum">     355 </span><span class="lineCov">     662344 :   return detail::CountLeadingZeroes64(aValue);</span>
<span class="lineNum">     356 </span>            : }
<span class="lineNum">     357 </span>            : 
<a name="358"><span class="lineNum">     358 </span>            : /** Analogous to CountTrailingZeroes32, but for 64-bit numbers. */</a>
<span class="lineNum">     359 </span>            : inline uint_fast8_t
<span class="lineNum">     360 </span><span class="lineCov">       7155 : CountTrailingZeroes64(uint64_t aValue)</span>
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span><span class="lineCov">       7155 :   MOZ_ASSERT(aValue != 0);</span>
<span class="lineNum">     363 </span><span class="lineCov">       7155 :   return detail::CountTrailingZeroes64(aValue);</span>
<span class="lineNum">     364 </span>            : }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : namespace detail {
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : template&lt;typename T, size_t Size = sizeof(T)&gt;
<span class="lineNum">     369 </span>            : class CeilingLog2;
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : template&lt;typename T&gt;
<span class="lineNum">     372 </span>            : class CeilingLog2&lt;T, 4&gt;
<a name="373"><span class="lineNum">     373 </span>            : {</a>
<span class="lineNum">     374 </span>            : public:
<span class="lineNum">     375 </span><span class="lineCov">      13622 :   static uint_fast8_t compute(const T aValue)</span>
<span class="lineNum">     376 </span>            :   {
<span class="lineNum">     377 </span>            :     // Check for &lt;= 1 to avoid the == 0 undefined case.
<span class="lineNum">     378 </span><span class="lineCov">      13622 :     return aValue &lt;= 1 ? 0u : 32u - CountLeadingZeroes32(aValue - 1);</span>
<span class="lineNum">     379 </span>            :   }
<span class="lineNum">     380 </span>            : };
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : template&lt;typename T&gt;
<span class="lineNum">     383 </span>            : class CeilingLog2&lt;T, 8&gt;
<a name="384"><span class="lineNum">     384 </span>            : {</a>
<span class="lineNum">     385 </span>            : public:
<span class="lineNum">     386 </span><span class="lineCov">    1813610 :   static uint_fast8_t compute(const T aValue)</span>
<span class="lineNum">     387 </span>            :   {
<span class="lineNum">     388 </span>            :     // Check for &lt;= 1 to avoid the == 0 undefined case.
<span class="lineNum">     389 </span><span class="lineCov">    1813610 :     return aValue &lt;= 1 ? 0u : 64u - CountLeadingZeroes64(aValue - 1);</span>
<span class="lineNum">     390 </span>            :   }
<span class="lineNum">     391 </span>            : };
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : } // namespace detail
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : /**
<span class="lineNum">     396 </span>            :  * Compute the log of the least power of 2 greater than or equal to |aValue|.
<span class="lineNum">     397 </span>            :  *
<span class="lineNum">     398 </span>            :  * CeilingLog2(0..1) is 0;
<span class="lineNum">     399 </span>            :  * CeilingLog2(2) is 1;
<span class="lineNum">     400 </span>            :  * CeilingLog2(3..4) is 2;
<span class="lineNum">     401 </span>            :  * CeilingLog2(5..8) is 3;
<span class="lineNum">     402 </span>            :  * CeilingLog2(9..16) is 4; and so on.
<span class="lineNum">     403 </span>            :  */
<a name="404"><span class="lineNum">     404 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     405 </span>            : inline uint_fast8_t
<span class="lineNum">     406 </span><span class="lineCov">    1827231 : CeilingLog2(const T aValue)</span>
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span><span class="lineCov">    1827231 :   return detail::CeilingLog2&lt;T&gt;::compute(aValue);</span>
<span class="lineNum">     409 </span>            : }
<span class="lineNum">     410 </span>            : 
<a name="411"><span class="lineNum">     411 </span>            : /** A CeilingLog2 variant that accepts only size_t. */</a>
<span class="lineNum">     412 </span>            : inline uint_fast8_t
<span class="lineNum">     413 </span><span class="lineCov">       2717 : CeilingLog2Size(size_t aValue)</span>
<span class="lineNum">     414 </span>            : {
<span class="lineNum">     415 </span><span class="lineCov">       2717 :   return CeilingLog2(aValue);</span>
<span class="lineNum">     416 </span>            : }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : namespace detail {
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : template&lt;typename T, size_t Size = sizeof(T)&gt;
<span class="lineNum">     421 </span>            : class FloorLog2;
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : template&lt;typename T&gt;
<span class="lineNum">     424 </span>            : class FloorLog2&lt;T, 4&gt;
<a name="425"><span class="lineNum">     425 </span>            : {</a>
<span class="lineNum">     426 </span>            : public:
<span class="lineNum">     427 </span><span class="lineCov">      37601 :   static uint_fast8_t compute(const T aValue)</span>
<span class="lineNum">     428 </span>            :   {
<span class="lineNum">     429 </span><span class="lineCov">      37601 :     return 31u - CountLeadingZeroes32(aValue | 1);</span>
<span class="lineNum">     430 </span>            :   }
<span class="lineNum">     431 </span>            : };
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : template&lt;typename T&gt;
<span class="lineNum">     434 </span>            : class FloorLog2&lt;T, 8&gt;
<a name="435"><span class="lineNum">     435 </span>            : {</a>
<span class="lineNum">     436 </span>            : public:
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   static uint_fast8_t compute(const T aValue)</span>
<span class="lineNum">     438 </span>            :   {
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     return 63u - CountLeadingZeroes64(aValue | 1);</span>
<span class="lineNum">     440 </span>            :   }
<span class="lineNum">     441 </span>            : };
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            : } // namespace detail
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : /**
<span class="lineNum">     446 </span>            :  * Compute the log of the greatest power of 2 less than or equal to |aValue|.
<span class="lineNum">     447 </span>            :  *
<span class="lineNum">     448 </span>            :  * FloorLog2(0..1) is 0;
<span class="lineNum">     449 </span>            :  * FloorLog2(2..3) is 1;
<span class="lineNum">     450 </span>            :  * FloorLog2(4..7) is 2;
<span class="lineNum">     451 </span>            :  * FloorLog2(8..15) is 3; and so on.
<span class="lineNum">     452 </span>            :  */
<a name="453"><span class="lineNum">     453 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     454 </span>            : inline uint_fast8_t
<span class="lineNum">     455 </span><span class="lineCov">      37601 : FloorLog2(const T aValue)</span>
<span class="lineNum">     456 </span>            : {
<span class="lineNum">     457 </span><span class="lineCov">      37601 :   return detail::FloorLog2&lt;T&gt;::compute(aValue);</span>
<span class="lineNum">     458 </span>            : }
<span class="lineNum">     459 </span>            : 
<a name="460"><span class="lineNum">     460 </span>            : /** A FloorLog2 variant that accepts only size_t. */</a>
<span class="lineNum">     461 </span>            : inline uint_fast8_t
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : FloorLog2Size(size_t aValue)</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   return FloorLog2(aValue);</span>
<span class="lineNum">     465 </span>            : }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : /*
<span class="lineNum">     468 </span>            :  * Compute the smallest power of 2 greater than or equal to |x|.  |x| must not
<span class="lineNum">     469 </span>            :  * be so great that the computed value would overflow |size_t|.
<a name="470"><span class="lineNum">     470 </span>            :  */</a>
<span class="lineNum">     471 </span>            : inline size_t
<span class="lineNum">     472 </span><span class="lineCov">    1810856 : RoundUpPow2(size_t aValue)</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineCov">    1810856 :   MOZ_ASSERT(aValue &lt;= (size_t(1) &lt;&lt; (sizeof(size_t) * CHAR_BIT - 1)),</span>
<span class="lineNum">     475 </span>            :              &quot;can't round up -- will overflow!&quot;);
<span class="lineNum">     476 </span><span class="lineCov">    1810856 :   return size_t(1) &lt;&lt; CeilingLog2(aValue);</span>
<span class="lineNum">     477 </span>            : }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            : /**
<span class="lineNum">     480 </span>            :  * Rotates the bits of the given value left by the amount of the shift width.
<span class="lineNum">     481 </span>            :  */
<a name="482"><span class="lineNum">     482 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     483 </span>            : inline T
<span class="lineNum">     484 </span><span class="lineCov">     702700 : RotateLeft(const T aValue, uint_fast8_t aShift)</span>
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span><span class="lineCov">     702700 :   MOZ_ASSERT(aShift &lt; sizeof(T) * CHAR_BIT, &quot;Shift value is too large!&quot;);</span>
<span class="lineNum">     487 </span><span class="lineCov">     702700 :   MOZ_ASSERT(aShift &gt; 0,</span>
<span class="lineNum">     488 </span>            :              &quot;Rotation by value length is undefined behavior, but compilers &quot;
<span class="lineNum">     489 </span>            :              &quot;do not currently fold a test into the rotate instruction. &quot;
<span class="lineNum">     490 </span>            :              &quot;Please remove this restriction when compilers optimize the &quot;
<span class="lineNum">     491 </span>            :              &quot;zero case (http://blog.regehr.org/archives/1063).&quot;);
<span class="lineNum">     492 </span>            :   static_assert(IsUnsigned&lt;T&gt;::value, &quot;Rotates require unsigned values&quot;);
<span class="lineNum">     493 </span><span class="lineCov">     702700 :   return (aValue &lt;&lt; aShift) | (aValue &gt;&gt; (sizeof(T) * CHAR_BIT - aShift));</span>
<span class="lineNum">     494 </span>            : }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : /**
<span class="lineNum">     497 </span>            :  * Rotates the bits of the given value right by the amount of the shift width.
<span class="lineNum">     498 </span>            :  */
<span class="lineNum">     499 </span>            : template&lt;typename T&gt;
<span class="lineNum">     500 </span>            : inline T
<span class="lineNum">     501 </span>            : RotateRight(const T aValue, uint_fast8_t aShift)
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span>            :   MOZ_ASSERT(aShift &lt; sizeof(T) * CHAR_BIT, &quot;Shift value is too large!&quot;);
<span class="lineNum">     504 </span>            :   MOZ_ASSERT(aShift &gt; 0,
<span class="lineNum">     505 </span>            :              &quot;Rotation by value length is undefined behavior, but compilers &quot;
<span class="lineNum">     506 </span>            :              &quot;do not currently fold a test into the rotate instruction. &quot;
<span class="lineNum">     507 </span>            :              &quot;Please remove this restriction when compilers optimize the &quot;
<span class="lineNum">     508 </span>            :              &quot;zero case (http://blog.regehr.org/archives/1063).&quot;);
<span class="lineNum">     509 </span>            :   static_assert(IsUnsigned&lt;T&gt;::value, &quot;Rotates require unsigned values&quot;);
<span class="lineNum">     510 </span>            :   return (aValue &gt;&gt; aShift) | (aValue &lt;&lt; (sizeof(T) * CHAR_BIT - aShift));
<span class="lineNum">     511 </span>            : }
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : /**
<span class="lineNum">     514 </span>            :  * Returns true if |x| is a power of two.
<span class="lineNum">     515 </span>            :  * Zero is not an integer power of two. (-Inf is not an integer)
<span class="lineNum">     516 </span>            :  */
<a name="517"><span class="lineNum">     517 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     518 </span>            : constexpr bool
<span class="lineNum">     519 </span><span class="lineCov">      39906 : IsPowerOfTwo(T x)</span>
<span class="lineNum">     520 </span>            : {
<span class="lineNum">     521 </span>            :     static_assert(IsUnsigned&lt;T&gt;::value,
<span class="lineNum">     522 </span>            :                   &quot;IsPowerOfTwo requires unsigned values&quot;);
<span class="lineNum">     523 </span><span class="lineCov">      39906 :     return x &amp;&amp; (x &amp; (x - 1)) == 0;</span>
<span class="lineNum">     524 </span>            : }
<span class="lineNum">     525 </span>            : 
<a name="526"><span class="lineNum">     526 </span>            : template&lt;typename T&gt;</a>
<span class="lineNum">     527 </span>            : inline T
<span class="lineNum">     528 </span><span class="lineNoCov">          0 : Clamp(const T aValue, const T aMin, const T aMax)</span>
<span class="lineNum">     529 </span>            : {
<span class="lineNum">     530 </span>            :     static_assert(IsIntegral&lt;T&gt;::value,
<span class="lineNum">     531 </span>            :                   &quot;Clamp accepts only integral types, so that it doesn't have&quot;
<span class="lineNum">     532 </span>            :                   &quot; to distinguish differently-signed zeroes (which users may&quot;
<span class="lineNum">     533 </span>            :                   &quot; or may not care to distinguish, likely at a perf cost) or&quot;
<span class="lineNum">     534 </span>            :                   &quot; to decide how to clamp NaN or a range with a NaN&quot;
<span class="lineNum">     535 </span>            :                   &quot; endpoint.&quot;);
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aMin &lt;= aMax);</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     if (aValue &lt;= aMin)</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         return aMin;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     if (aValue &gt;= aMax)</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         return aMax;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     return aValue;</span>
<span class="lineNum">     543 </span>            : }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : } /* namespace mozilla */
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : #endif /* mozilla_MathAlgorithms_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

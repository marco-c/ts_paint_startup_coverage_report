<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libvorbis/lib/vorbis_psy.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/libvorbis/lib</a> - vorbis_psy.c<span style="font-size: 80%;"> (source / <a href="vorbis_psy.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">573</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /********************************************************************</a>
<span class="lineNum">       2 </span>            :  *                                                                  *
<span class="lineNum">       3 </span>            :  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
<span class="lineNum">       4 </span>            :  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
<span class="lineNum">       5 </span>            :  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
<span class="lineNum">       6 </span>            :  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
<span class="lineNum">       7 </span>            :  *                                                                  *
<span class="lineNum">       8 </span>            :  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
<span class="lineNum">       9 </span>            :  * by the Xiph.Org Foundation http://www.xiph.org/                  *
<span class="lineNum">      10 </span>            :  *                                                                  *
<span class="lineNum">      11 </span>            :  ********************************************************************
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  function: psychoacoustics not including preecho
<span class="lineNum">      14 </span>            :  last mod: $Id$
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  ********************************************************************/
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      21 </span>            : #include &quot;vorbis/codec.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;codec_internal.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;masking.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;psy.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;os.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;lpc.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;smallft.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;scales.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;misc.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #define NEGINF -9999.f
<span class="lineNum">      33 </span>            : static const double stereo_threshholds[]={0.0, .5, 1.0, 1.5, 2.5, 4.5, 8.5, 16.5, 9e10};
<a name="34"><span class="lineNum">      34 </span>            : static const double stereo_threshholds_limited[]={0.0, .5, 1.0, 1.5, 2.0, 2.5, 4.5, 8.5, 9e10};</a>
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span><span class="lineNoCov">          0 : vorbis_look_psy_global *_vp_global_look(vorbis_info *vi){</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   codec_setup_info *ci=vi-&gt;codec_setup;</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   vorbis_info_psy_global *gi=&amp;ci-&gt;psy_g_param;</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   vorbis_look_psy_global *look=_ogg_calloc(1,sizeof(*look));</span>
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   look-&gt;channels=vi-&gt;channels;</span>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   look-&gt;ampmax=-9999.;</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   look-&gt;gi=gi;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   return(look);</span>
<a name="46"><span class="lineNum">      46 </span>            : }</a>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineNoCov">          0 : void _vp_global_free(vorbis_look_psy_global *look){</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   if(look){</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     memset(look,0,sizeof(*look));</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :     _ogg_free(look);</span>
<span class="lineNum">      52 </span>            :   }
<a name="53"><span class="lineNum">      53 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 : void _vi_gpsy_free(vorbis_info_psy_global *i){</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   if(i){</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     memset(i,0,sizeof(*i));</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     _ogg_free(i);</span>
<span class="lineNum">      59 </span>            :   }
<a name="60"><span class="lineNum">      60 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span><span class="lineNoCov">          0 : void _vi_psy_free(vorbis_info_psy *i){</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   if(i){</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     memset(i,0,sizeof(*i));</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     _ogg_free(i);</span>
<span class="lineNum">      66 </span>            :   }
<a name="67"><span class="lineNum">      67 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span><span class="lineNoCov">          0 : static void min_curve(float *c,</span>
<span class="lineNum">      70 </span>            :                        float *c2){
<span class="lineNum">      71 </span>            :   int i;
<a name="72"><span class="lineNum">      72 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;EHMER_MAX;i++)if(c2[i]&lt;c[i])c[i]=c2[i];</span></a>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 : static void max_curve(float *c,</span>
<span class="lineNum">      75 </span>            :                        float *c2){
<span class="lineNum">      76 </span>            :   int i;
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;EHMER_MAX;i++)if(c2[i]&gt;c[i])c[i]=c2[i];</span>
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span><span class="lineNoCov">          0 : static void attenuate_curve(float *c,float att){</span>
<span class="lineNum">      81 </span>            :   int i;
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;EHMER_MAX;i++)</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     c[i]+=att;</span>
<a name="84"><span class="lineNum">      84 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : static float ***setup_tone_curves(float curveatt_dB[P_BANDS],float binHz,int n,</span>
<span class="lineNum">      87 </span>            :                                   float center_boost, float center_decay_rate){
<span class="lineNum">      88 </span>            :   int i,j,k,m;
<span class="lineNum">      89 </span>            :   float ath[EHMER_MAX];
<span class="lineNum">      90 </span>            :   float workc[P_BANDS][P_LEVELS][EHMER_MAX];
<span class="lineNum">      91 </span>            :   float athc[P_LEVELS][EHMER_MAX];
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   float *brute_buffer=alloca(n*sizeof(*brute_buffer));</span>
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   float ***ret=_ogg_malloc(sizeof(*ret)*P_BANDS);</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   memset(workc,0,sizeof(workc));</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;P_BANDS;i++){</span>
<span class="lineNum">      99 </span>            :     /* we add back in the ATH to avoid low level curves falling off to
<span class="lineNum">     100 </span>            :        -infinity and unnecessarily cutting off high level curves in the
<span class="lineNum">     101 </span>            :        curve limiting (last step). */
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :     /* A half-band's settings must be valid over the whole band, and
<span class="lineNum">     104 </span>            :        it's better to mask too little than too much */
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     int ath_offset=i*4;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;EHMER_MAX;j++){</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :       float min=999.;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :       for(k=0;k&lt;4;k++)</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :         if(j+k+ath_offset&lt;MAX_ATH){</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :           if(min&gt;ATH[j+k+ath_offset])min=ATH[j+k+ath_offset];</span>
<span class="lineNum">     111 </span>            :         }else{
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :           if(min&gt;ATH[MAX_ATH-1])min=ATH[MAX_ATH-1];</span>
<span class="lineNum">     113 </span>            :         }
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :       ath[j]=min;</span>
<span class="lineNum">     115 </span>            :     }
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :     /* copy curves into working space, replicate the 50dB curve to 30
<span class="lineNum">     118 </span>            :        and 40, replicate the 100dB curve to 110 */
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;6;j++)</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :       memcpy(workc[i][j+2],tonemasks[i][j],EHMER_MAX*sizeof(*tonemasks[i][j]));</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     memcpy(workc[i][0],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     memcpy(workc[i][1],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     /* apply centered curve boost/decay */
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;P_LEVELS;j++){</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :       for(k=0;k&lt;EHMER_MAX;k++){</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :         float adj=center_boost+abs(EHMER_OFFSET-k)*center_decay_rate;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         if(adj&lt;0. &amp;&amp; center_boost&gt;0)adj=0.;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         if(adj&gt;0. &amp;&amp; center_boost&lt;0)adj=0.;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :         workc[i][j][k]+=adj;</span>
<span class="lineNum">     131 </span>            :       }
<span class="lineNum">     132 </span>            :     }
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :     /* normalize curves so the driving amplitude is 0dB */
<span class="lineNum">     135 </span>            :     /* make temp curves with the ATH overlayed */
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;P_LEVELS;j++){</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :       attenuate_curve(workc[i][j],curveatt_dB[i]+100.-(j&lt;2?2:j)*10.-P_LEVEL_0);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :       memcpy(athc[j],ath,EHMER_MAX*sizeof(**athc));</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :       attenuate_curve(athc[j],+100.-j*10.f-P_LEVEL_0);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       max_curve(athc[j],workc[i][j]);</span>
<span class="lineNum">     141 </span>            :     }
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :     /* Now limit the louder curves.
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :        the idea is this: We don't know what the playback attenuation
<span class="lineNum">     146 </span>            :        will be; 0dB SL moves every time the user twiddles the volume
<span class="lineNum">     147 </span>            :        knob. So that means we have to use a single 'most pessimal' curve
<span class="lineNum">     148 </span>            :        for all masking amplitudes, right?  Wrong.  The *loudest* sound
<span class="lineNum">     149 </span>            :        can be in (we assume) a range of ...+100dB] SL.  However, sounds
<span class="lineNum">     150 </span>            :        20dB down will be in a range ...+80], 40dB down is from ...+60],
<span class="lineNum">     151 </span>            :        etc... */
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     for(j=1;j&lt;P_LEVELS;j++){</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :       min_curve(athc[j],athc[j-1]);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :       min_curve(workc[i][j],athc[j]);</span>
<span class="lineNum">     156 </span>            :     }
<span class="lineNum">     157 </span>            :   }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;P_BANDS;i++){</span>
<span class="lineNum">     160 </span>            :     int hi_curve,lo_curve,bin;
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     ret[i]=_ogg_malloc(sizeof(**ret)*P_LEVELS);</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :     /* low frequency curves are measured with greater resolution than
<span class="lineNum">     164 </span>            :        the MDCT/FFT will actually give us; we want the curve applied
<span class="lineNum">     165 </span>            :        to the tone data to be pessimistic and thus apply the minimum
<span class="lineNum">     166 </span>            :        masking possible for a given bin.  That means that a single bin
<span class="lineNum">     167 </span>            :        could span more than one octave and that the curve will be a
<span class="lineNum">     168 </span>            :        composite of multiple octaves.  It also may mean that a single
<span class="lineNum">     169 </span>            :        bin may span &gt; an eighth of an octave and that the eighth
<span class="lineNum">     170 </span>            :        octave values may also be composited. */
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     /* which octave curves will we be compositing? */
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     bin=floor(fromOC(i*.5)/binHz);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :     lo_curve=  ceil(toOC(bin*binHz+1)*2);</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     hi_curve=  floor(toOC((bin+1)*binHz)*2);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :     if(lo_curve&gt;i)lo_curve=i;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     if(lo_curve&lt;0)lo_curve=0;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     if(hi_curve&gt;=P_BANDS)hi_curve=P_BANDS-1;</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     for(m=0;m&lt;P_LEVELS;m++){</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       ret[i][m]=_ogg_malloc(sizeof(***ret)*(EHMER_MAX+2));</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       for(j=0;j&lt;n;j++)brute_buffer[j]=999.;</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :       /* render the curve into bins, then pull values back into curve.
<span class="lineNum">     186 </span>            :          The point is that any inherent subsampling aliasing results in
<span class="lineNum">     187 </span>            :          a safe minimum */
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :       for(k=lo_curve;k&lt;=hi_curve;k++){</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         int l=0;</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;EHMER_MAX;j++){</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :           int lo_bin= fromOC(j*.125+k*.5-2.0625)/binHz;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :           int hi_bin= fromOC(j*.125+k*.5-1.9375)/binHz+1;</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :           if(lo_bin&lt;0)lo_bin=0;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :           if(lo_bin&gt;n)lo_bin=n;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :           if(lo_bin&lt;l)l=lo_bin;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :           if(hi_bin&lt;0)hi_bin=0;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :           if(hi_bin&gt;n)hi_bin=n;</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :           for(;l&lt;hi_bin &amp;&amp; l&lt;n;l++)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :             if(brute_buffer[l]&gt;workc[k][m][j])</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :               brute_buffer[l]=workc[k][m][j];</span>
<span class="lineNum">     204 </span>            :         }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         for(;l&lt;n;l++)</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :           if(brute_buffer[l]&gt;workc[k][m][EHMER_MAX-1])</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :             brute_buffer[l]=workc[k][m][EHMER_MAX-1];</span>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :       }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :       /* be equally paranoid about being valid up to next half ocatve */
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       if(i+1&lt;P_BANDS){</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         int l=0;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         k=i+1;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;EHMER_MAX;j++){</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :           int lo_bin= fromOC(j*.125+i*.5-2.0625)/binHz;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :           int hi_bin= fromOC(j*.125+i*.5-1.9375)/binHz+1;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :           if(lo_bin&lt;0)lo_bin=0;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :           if(lo_bin&gt;n)lo_bin=n;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :           if(lo_bin&lt;l)l=lo_bin;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :           if(hi_bin&lt;0)hi_bin=0;</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :           if(hi_bin&gt;n)hi_bin=n;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :           for(;l&lt;hi_bin &amp;&amp; l&lt;n;l++)</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :             if(brute_buffer[l]&gt;workc[k][m][j])</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :               brute_buffer[l]=workc[k][m][j];</span>
<span class="lineNum">     229 </span>            :         }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         for(;l&lt;n;l++)</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :           if(brute_buffer[l]&gt;workc[k][m][EHMER_MAX-1])</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :             brute_buffer[l]=workc[k][m][EHMER_MAX-1];</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :       }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       for(j=0;j&lt;EHMER_MAX;j++){</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         int bin=fromOC(j*.125+i*.5-2.)/binHz;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         if(bin&lt;0){</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :           ret[i][m][j+2]=-999.;</span>
<span class="lineNum">     242 </span>            :         }else{
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :           if(bin&gt;=n){</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             ret[i][m][j+2]=-999.;</span>
<span class="lineNum">     245 </span>            :           }else{
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             ret[i][m][j+2]=brute_buffer[bin];</span>
<span class="lineNum">     247 </span>            :           }
<span class="lineNum">     248 </span>            :         }
<span class="lineNum">     249 </span>            :       }
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :       /* add fenceposts */
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       for(j=0;j&lt;EHMER_OFFSET;j++)</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         if(ret[i][m][j+2]&gt;-200.f)break;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       ret[i][m][0]=j;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       for(j=EHMER_MAX-1;j&gt;EHMER_OFFSET+1;j--)</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         if(ret[i][m][j+2]&gt;-200.f)</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       ret[i][m][1]=j;</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :     }
<span class="lineNum">     262 </span>            :   }
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   return(ret);</span>
<a name="265"><span class="lineNum">     265 </span>            : }</a>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : void _vp_psy_init(vorbis_look_psy *p,vorbis_info_psy *vi,</span>
<span class="lineNum">     268 </span>            :                   vorbis_info_psy_global *gi,int n,long rate){
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   long i,j,lo=-99,hi=1;</span>
<span class="lineNum">     270 </span>            :   long maxoc;
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   memset(p,0,sizeof(*p));</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   p-&gt;eighth_octave_lines=gi-&gt;eighth_octave_lines;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   p-&gt;shiftoc=rint(log(gi-&gt;eighth_octave_lines*8.f)/log(2.f))-1;</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   p-&gt;firstoc=toOC(.25f*rate*.5/n)*(1&lt;&lt;(p-&gt;shiftoc+1))-gi-&gt;eighth_octave_lines;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   maxoc=toOC((n+.25f)*rate*.5/n)*(1&lt;&lt;(p-&gt;shiftoc+1))+.5f;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   p-&gt;total_octave_lines=maxoc-p-&gt;firstoc+1;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   p-&gt;ath=_ogg_malloc(n*sizeof(*p-&gt;ath));</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   p-&gt;octave=_ogg_malloc(n*sizeof(*p-&gt;octave));</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   p-&gt;bark=_ogg_malloc(n*sizeof(*p-&gt;bark));</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   p-&gt;vi=vi;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   p-&gt;n=n;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   p-&gt;rate=rate;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   /* AoTuV HF weighting */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   p-&gt;m_val = 1.;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   if(rate &lt; 26000) p-&gt;m_val = 0;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   else if(rate &lt; 38000) p-&gt;m_val = .94;   /* 32kHz */</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   else if(rate &gt; 46000) p-&gt;m_val = 1.275; /* 48kHz */</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   /* set up the lookups for a given blocksize and sample rate */
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   for(i=0,j=0;i&lt;MAX_ATH-1;i++){</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     int endpos=rint(fromOC((i+1)*.125-2.)*2*n/rate);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     float base=ATH[i];</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if(j&lt;endpos){</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       float delta=(ATH[i+1]-base)/(endpos-j);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       for(;j&lt;endpos &amp;&amp; j&lt;n;j++){</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         p-&gt;ath[j]=base+100.;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         base+=delta;</span>
<span class="lineNum">     303 </span>            :       }
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            :   }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   for(;j&lt;n;j++){</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     p-&gt;ath[j]=p-&gt;ath[j-1];</span>
<span class="lineNum">     309 </span>            :   }
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     float bark=toBARK(rate/(2*n)*i);</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     for(;lo+vi-&gt;noisewindowlomin&lt;i &amp;&amp;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :           toBARK(rate/(2*n)*lo)&lt;(bark-vi-&gt;noisewindowlo);lo++);</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     for(;hi&lt;=n &amp;&amp; (hi&lt;i+vi-&gt;noisewindowhimin ||</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :           toBARK(rate/(2*n)*hi)&lt;(bark+vi-&gt;noisewindowhi));hi++);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     p-&gt;bark[i]=((lo-1)&lt;&lt;16)+(hi-1);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   }
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++)</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     p-&gt;octave[i]=toOC((i+.25f)*.5*rate/n)*(1&lt;&lt;(p-&gt;shiftoc+1))+.5f;</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   p-&gt;tonecurves=setup_tone_curves(vi-&gt;toneatt,rate*.5/n,n,</span>
<span class="lineNum">     328 </span>            :                                   vi-&gt;tone_centerboost,vi-&gt;tone_decay);
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   /* set up rolling noise median */
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   p-&gt;noiseoffset=_ogg_malloc(P_NOISECURVES*sizeof(*p-&gt;noiseoffset));</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;P_NOISECURVES;i++)</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     p-&gt;noiseoffset[i]=_ogg_malloc(n*sizeof(**p-&gt;noiseoffset));</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     float halfoc=toOC((i+.5)*rate/(2.*n))*2.;</span>
<span class="lineNum">     337 </span>            :     int inthalfoc;
<span class="lineNum">     338 </span>            :     float del;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     if(halfoc&lt;0)halfoc=0;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     if(halfoc&gt;=P_BANDS-1)halfoc=P_BANDS-1;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     inthalfoc=(int)halfoc;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     del=halfoc-inthalfoc;</span>
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;P_NOISECURVES;j++)</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :       p-&gt;noiseoffset[j][i]=</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         p-&gt;vi-&gt;noiseoff[j][inthalfoc]*(1.-del) +</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         p-&gt;vi-&gt;noiseoff[j][inthalfoc+1]*del;</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :   }
<span class="lineNum">     351 </span>            : #if 0
<span class="lineNum">     352 </span>            :   {
<span class="lineNum">     353 </span>            :     static int ls=0;
<span class="lineNum">     354 </span>            :     _analysis_output_always(&quot;noiseoff0&quot;,ls,p-&gt;noiseoffset[0],n,1,0,0);
<span class="lineNum">     355 </span>            :     _analysis_output_always(&quot;noiseoff1&quot;,ls,p-&gt;noiseoffset[1],n,1,0,0);
<span class="lineNum">     356 </span>            :     _analysis_output_always(&quot;noiseoff2&quot;,ls++,p-&gt;noiseoffset[2],n,1,0,0);
<span class="lineNum">     357 </span>            :   }
<span class="lineNum">     358 </span>            : #endif
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 : void _vp_psy_clear(vorbis_look_psy *p){</span>
<span class="lineNum">     362 </span>            :   int i,j;
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   if(p){</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     if(p-&gt;ath)_ogg_free(p-&gt;ath);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     if(p-&gt;octave)_ogg_free(p-&gt;octave);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     if(p-&gt;bark)_ogg_free(p-&gt;bark);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     if(p-&gt;tonecurves){</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;P_BANDS;i++){</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;P_LEVELS;j++){</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :           _ogg_free(p-&gt;tonecurves[i][j]);</span>
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         _ogg_free(p-&gt;tonecurves[i]);</span>
<span class="lineNum">     373 </span>            :       }
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :       _ogg_free(p-&gt;tonecurves);</span>
<span class="lineNum">     375 </span>            :     }
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if(p-&gt;noiseoffset){</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;P_NOISECURVES;i++){</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         _ogg_free(p-&gt;noiseoffset[i]);</span>
<span class="lineNum">     379 </span>            :       }
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       _ogg_free(p-&gt;noiseoffset);</span>
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     memset(p,0,sizeof(*p));</span>
<span class="lineNum">     383 </span>            :   }
<span class="lineNum">     384 </span><span class="lineNoCov">          0 : }</span>
<a name="385"><span class="lineNum">     385 </span>            : </a>
<span class="lineNum">     386 </span>            : /* octave/(8*eighth_octave_lines) x scale and dB y scale */
<span class="lineNum">     387 </span><span class="lineNoCov">          0 : static void seed_curve(float *seed,</span>
<span class="lineNum">     388 </span>            :                        const float **curves,
<span class="lineNum">     389 </span>            :                        float amp,
<span class="lineNum">     390 </span>            :                        int oc, int n,
<span class="lineNum">     391 </span>            :                        int linesper,float dBoffset){
<span class="lineNum">     392 </span>            :   int i,post1;
<span class="lineNum">     393 </span>            :   int seedptr;
<span class="lineNum">     394 </span>            :   const float *posts,*curve;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   int choice=(int)((amp+dBoffset-P_LEVEL_0)*.1f);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   choice=max(choice,0);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   choice=min(choice,P_LEVELS-1);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   posts=curves[choice];</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   curve=posts+2;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   post1=(int)posts[1];</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   seedptr=oc+(posts[0]-EHMER_OFFSET)*linesper-(linesper&gt;&gt;1);</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   for(i=posts[0];i&lt;post1;i++){</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     if(seedptr&gt;0){</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       float lin=amp+curve[i];</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       if(seed[seedptr]&lt;lin)seed[seedptr]=lin;</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     seedptr+=linesper;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     if(seedptr&gt;=n)break;</span>
<span class="lineNum">     411 </span>            :   }
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : static void seed_loop(vorbis_look_psy *p,</span>
<span class="lineNum">     415 </span>            :                       const float ***curves,
<span class="lineNum">     416 </span>            :                       const float *f,
<span class="lineNum">     417 </span>            :                       const float *flr,
<span class="lineNum">     418 </span>            :                       float *seed,
<span class="lineNum">     419 </span>            :                       float specmax){
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   vorbis_info_psy *vi=p-&gt;vi;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   long n=p-&gt;n,i;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   float dBoffset=vi-&gt;max_curve_dB-specmax;</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   /* prime the working vector with peak values */
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     float max=f[i];</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     long oc=p-&gt;octave[i];</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     while(i+1&lt;n &amp;&amp; p-&gt;octave[i+1]==oc){</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       i++;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       if(f[i]&gt;max)max=f[i];</span>
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     if(max+6.f&gt;flr[i]){</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       oc=oc&gt;&gt;p-&gt;shiftoc;</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       if(oc&gt;=P_BANDS)oc=P_BANDS-1;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       if(oc&lt;0)oc=0;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       seed_curve(seed,</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                  curves[oc],</span>
<span class="lineNum">     442 </span>            :                  max,
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                  p-&gt;octave[i]-p-&gt;firstoc,</span>
<span class="lineNum">     444 </span>            :                  p-&gt;total_octave_lines,
<span class="lineNum">     445 </span>            :                  p-&gt;eighth_octave_lines,
<span class="lineNum">     446 </span>            :                  dBoffset);
<span class="lineNum">     447 </span>            :     }
<span class="lineNum">     448 </span>            :   }
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineNoCov">          0 : static void seed_chase(float *seeds, int linesper, long n){</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   long  *posstack=alloca(n*sizeof(*posstack));</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   float *ampstack=alloca(n*sizeof(*ampstack));</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   long   stack=0;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   long   pos=0;</span>
<span class="lineNum">     456 </span>            :   long   i;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     if(stack&lt;2){</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       posstack[stack]=i;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       ampstack[stack++]=seeds[i];</span>
<span class="lineNum">     462 </span>            :     }else{
<span class="lineNum">     463 </span>            :       while(1){
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         if(seeds[i]&lt;ampstack[stack-1]){</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :           posstack[stack]=i;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :           ampstack[stack++]=seeds[i];</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     468 </span>            :         }else{
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :           if(i&lt;posstack[stack-1]+linesper){</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :             if(stack&gt;1 &amp;&amp; ampstack[stack-1]&lt;=ampstack[stack-2] &amp;&amp;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                i&lt;posstack[stack-2]+linesper){</span>
<span class="lineNum">     472 </span>            :               /* we completely overlap, making stack-1 irrelevant.  pop it */
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :               stack--;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">     475 </span>            :             }
<span class="lineNum">     476 </span>            :           }
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :           posstack[stack]=i;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :           ampstack[stack++]=seeds[i];</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            :       }
<span class="lineNum">     483 </span>            :     }
<span class="lineNum">     484 </span>            :   }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   /* the stack now contains only the positions that are relevant. Scan
<span class="lineNum">     487 </span>            :      'em straight through */
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;stack;i++){</span>
<span class="lineNum">     490 </span>            :     long endpos;
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     if(i&lt;stack-1 &amp;&amp; ampstack[i+1]&gt;ampstack[i]){</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       endpos=posstack[i+1];</span>
<span class="lineNum">     493 </span>            :     }else{
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       endpos=posstack[i]+linesper+1; /* +1 is important, else bin 0 is</span>
<span class="lineNum">     495 </span>            :                                         discarded in short frames */
<span class="lineNum">     496 </span>            :     }
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     if(endpos&gt;n)endpos=n;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     for(;pos&lt;endpos;pos++)</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       seeds[pos]=ampstack[i];</span>
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :   /* there.  Linear time.  I now remember this was on a problem set I
<span class="lineNum">     503 </span>            :      had in Grad Skool... I didn't solve it at the time ;-) */
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     506 </span>            : 
<a name="507"><span class="lineNum">     507 </span>            : /* bleaugh, this is more complicated than it needs to be */</a>
<span class="lineNum">     508 </span>            : #include&lt;stdio.h&gt;
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : static void max_seeds(vorbis_look_psy *p,</span>
<span class="lineNum">     510 </span>            :                       float *seed,
<span class="lineNum">     511 </span>            :                       float *flr){
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :   long   n=p-&gt;total_octave_lines;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   int    linesper=p-&gt;eighth_octave_lines;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   long   linpos=0;</span>
<span class="lineNum">     515 </span>            :   long   pos;
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   seed_chase(seed,linesper,n); /* for masking */</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   pos=p-&gt;octave[0]-p-&gt;firstoc-(linesper&gt;&gt;1);</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   while(linpos+1&lt;p-&gt;n){</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     float minV=seed[pos];</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     long end=((p-&gt;octave[linpos]+p-&gt;octave[linpos+1])&gt;&gt;1)-p-&gt;firstoc;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     if(minV&gt;p-&gt;vi-&gt;tone_abs_limit)minV=p-&gt;vi-&gt;tone_abs_limit;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     while(pos+1&lt;=end){</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       pos++;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       if((seed[pos]&gt;NEGINF &amp;&amp; seed[pos]&lt;minV) || minV==NEGINF)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         minV=seed[pos];</span>
<span class="lineNum">     529 </span>            :     }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     end=pos+p-&gt;firstoc;</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     for(;linpos&lt;p-&gt;n &amp;&amp; p-&gt;octave[linpos]&lt;=end;linpos++)</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :       if(flr[linpos]&lt;minV)flr[linpos]=minV;</span>
<span class="lineNum">     534 </span>            :   }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :   {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     float minV=seed[p-&gt;total_octave_lines-1];</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     for(;linpos&lt;p-&gt;n;linpos++)</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :       if(flr[linpos]&lt;minV)flr[linpos]=minV;</span>
<span class="lineNum">     540 </span>            :   }
<span class="lineNum">     541 </span>            : 
<a name="542"><span class="lineNum">     542 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineNoCov">          0 : static void bark_noise_hybridmp(int n,const long *b,</span>
<span class="lineNum">     545 </span>            :                                 const float *f,
<span class="lineNum">     546 </span>            :                                 float *noise,
<span class="lineNum">     547 </span>            :                                 const float offset,
<span class="lineNum">     548 </span>            :                                 const int fixed){
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   float *N=alloca(n*sizeof(*N));</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   float *X=alloca(n*sizeof(*N));</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   float *XX=alloca(n*sizeof(*N));</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   float *Y=alloca(n*sizeof(*N));</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   float *XY=alloca(n*sizeof(*N));</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :   float tN, tX, tXX, tY, tXY;
<span class="lineNum">     557 </span>            :   int i;
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :   int lo, hi;
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   float R=0.f;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   float A=0.f;</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   float B=0.f;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   float D=1.f;</span>
<span class="lineNum">     564 </span>            :   float w, x, y;
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   tN = tX = tXX = tY = tXY = 0.f;</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   y = f[0] + offset;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   if (y &lt; 1.f) y = 1.f;</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   w = y * y * .5;</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   tN += w;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   tX += w;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   tY += w * y;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   N[0] = tN;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   X[0] = tX;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   XX[0] = tXX;</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   Y[0] = tY;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :   XY[0] = tXY;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   for (i = 1, x = 1.f; i &lt; n; i++, x += 1.f) {</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     y = f[i] + offset;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     if (y &lt; 1.f) y = 1.f;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     w = y * y;</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     tN += w;</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     tX += w * x;</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     tXX += w * x * x;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     tY += w * y;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     tXY += w * x * y;</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     N[i] = tN;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     X[i] = tX;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     XX[i] = tXX;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     Y[i] = tY;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     XY[i] = tXY;</span>
<span class="lineNum">     601 </span>            :   }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   for (i = 0, x = 0.f;; i++, x += 1.f) {</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     lo = b[i] &gt;&gt; 16;</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     if( lo&gt;=0 ) break;</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     hi = b[i] &amp; 0xffff;</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     tN = N[hi] + N[-lo];</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     tX = X[hi] - X[-lo];</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     tXX = XX[hi] + XX[-lo];</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     tY = Y[hi] + Y[-lo];</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     tXY = XY[hi] - XY[-lo];</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     A = tY * tXX - tX * tXY;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     B = tN * tXY - tX * tY;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     D = tN * tXX - tX * tX;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     if (R &lt; 0.f)</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :       R = 0.f;</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     noise[i] = R - offset;</span>
<span class="lineNum">     623 </span>            :   }
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   for ( ;; i++, x += 1.f) {</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     lo = b[i] &gt;&gt; 16;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     hi = b[i] &amp; 0xffff;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     if(hi&gt;=n)break;</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     tN = N[hi] - N[lo];</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     tX = X[hi] - X[lo];</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     tXX = XX[hi] - XX[lo];</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     tY = Y[hi] - Y[lo];</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     tXY = XY[hi] - XY[lo];</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     A = tY * tXX - tX * tXY;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     B = tN * tXY - tX * tY;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     D = tN * tXX - tX * tX;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     if (R &lt; 0.f) R = 0.f;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     noise[i] = R - offset;</span>
<span class="lineNum">     644 </span>            :   }
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   for ( ; i &lt; n; i++, x += 1.f) {</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     if (R &lt; 0.f) R = 0.f;</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     noise[i] = R - offset;</span>
<span class="lineNum">     651 </span>            :   }
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   if (fixed &lt;= 0) return;</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   for (i = 0, x = 0.f;; i++, x += 1.f) {</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     hi = i + fixed / 2;</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     lo = hi - fixed;</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     if(lo&gt;=0)break;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     tN = N[hi] + N[-lo];</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     tX = X[hi] - X[-lo];</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     tXX = XX[hi] + XX[-lo];</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     tY = Y[hi] + Y[-lo];</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     tXY = XY[hi] - XY[-lo];</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     A = tY * tXX - tX * tXY;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     B = tN * tXY - tX * tY;</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     D = tN * tXX - tX * tX;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     if (R - offset &lt; noise[i]) noise[i] = R - offset;</span>
<span class="lineNum">     673 </span>            :   }
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   for ( ;; i++, x += 1.f) {</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     hi = i + fixed / 2;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     lo = hi - fixed;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     if(hi&gt;=n)break;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     tN = N[hi] - N[lo];</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     tX = X[hi] - X[lo];</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     tXX = XX[hi] - XX[lo];</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     tY = Y[hi] - Y[lo];</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     tXY = XY[hi] - XY[lo];</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     A = tY * tXX - tX * tXY;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     B = tN * tXY - tX * tY;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     D = tN * tXX - tX * tX;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     if (R - offset &lt; noise[i]) noise[i] = R - offset;</span>
<span class="lineNum">     692 </span>            :   }
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   for ( ; i &lt; n; i++, x += 1.f) {</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     R = (A + x * B) / D;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     if (R - offset &lt; noise[i]) noise[i] = R - offset;</span>
<span class="lineNum">     696 </span>            :   }
<a name="697"><span class="lineNum">     697 </span>            : }</a>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 : void _vp_noisemask(vorbis_look_psy *p,</span>
<span class="lineNum">     700 </span>            :                    float *logmdct,
<span class="lineNum">     701 </span>            :                    float *logmask){
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   int i,n=p-&gt;n;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   float *work=alloca(n*sizeof(*work));</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   bark_noise_hybridmp(n,p-&gt;bark,logmdct,logmask,</span>
<span class="lineNum">     707 </span>            :                       140.,-1);
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++)work[i]=logmdct[i]-logmask[i];</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   bark_noise_hybridmp(n,p-&gt;bark,work,logmask,0.,</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :                       p-&gt;vi-&gt;noisewindowfixed);</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++)work[i]=logmdct[i]-work[i];</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : #if 0
<span class="lineNum">     717 </span>            :   {
<span class="lineNum">     718 </span>            :     static int seq=0;
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     float work2[n];
<span class="lineNum">     721 </span>            :     for(i=0;i&lt;n;i++){
<span class="lineNum">     722 </span>            :       work2[i]=logmask[i]+work[i];
<span class="lineNum">     723 </span>            :     }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :     if(seq&amp;1)
<span class="lineNum">     726 </span>            :       _analysis_output(&quot;median2R&quot;,seq/2,work,n,1,0,0);
<span class="lineNum">     727 </span>            :     else
<span class="lineNum">     728 </span>            :       _analysis_output(&quot;median2L&quot;,seq/2,work,n,1,0,0);
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     if(seq&amp;1)
<span class="lineNum">     731 </span>            :       _analysis_output(&quot;envelope2R&quot;,seq/2,work2,n,1,0,0);
<span class="lineNum">     732 </span>            :     else
<span class="lineNum">     733 </span>            :       _analysis_output(&quot;envelope2L&quot;,seq/2,work2,n,1,0,0);
<span class="lineNum">     734 </span>            :     seq++;
<span class="lineNum">     735 </span>            :   }
<span class="lineNum">     736 </span>            : #endif
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     int dB=logmask[i]+.5;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     if(dB&gt;=NOISE_COMPAND_LEVELS)dB=NOISE_COMPAND_LEVELS-1;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     if(dB&lt;0)dB=0;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     logmask[i]= work[i]+p-&gt;vi-&gt;noisecompand[dB];</span>
<span class="lineNum">     743 </span>            :   }
<span class="lineNum">     744 </span>            : 
<a name="745"><span class="lineNum">     745 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 : void _vp_tonemask(vorbis_look_psy *p,</span>
<span class="lineNum">     748 </span>            :                   float *logfft,
<span class="lineNum">     749 </span>            :                   float *logmask,
<span class="lineNum">     750 </span>            :                   float global_specmax,
<span class="lineNum">     751 </span>            :                   float local_specmax){
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :   int i,n=p-&gt;n;</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :   float *seed=alloca(sizeof(*seed)*p-&gt;total_octave_lines);</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   float att=local_specmax+p-&gt;vi-&gt;ath_adjatt;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;p-&gt;total_octave_lines;i++)seed[i]=NEGINF;</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   /* set the ATH (floating below localmax, not global max by a
<span class="lineNum">     760 </span>            :      specified att) */
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   if(att&lt;p-&gt;vi-&gt;ath_maxatt)att=p-&gt;vi-&gt;ath_maxatt;</span>
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     logmask[i]=p-&gt;ath[i]+att;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   /* tone masking */
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   seed_loop(p,(const float ***)p-&gt;tonecurves,logfft,logmask,seed,global_specmax);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   max_seeds(p,seed,logmask);</span>
<span class="lineNum">     769 </span>            : 
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 : void _vp_offset_and_mix(vorbis_look_psy *p,</span>
<span class="lineNum">     773 </span>            :                         float *noise,
<span class="lineNum">     774 </span>            :                         float *tone,
<span class="lineNum">     775 </span>            :                         int offset_select,
<span class="lineNum">     776 </span>            :                         float *logmask,
<span class="lineNum">     777 </span>            :                         float *mdct,
<span class="lineNum">     778 </span>            :                         float *logmdct){
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   int i,n=p-&gt;n;</span>
<span class="lineNum">     780 </span>            :   float de, coeffi, cx;/* AoTuV */
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   float toneatt=p-&gt;vi-&gt;tone_masteratt[offset_select];</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   cx = p-&gt;m_val;</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++){</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     float val= noise[i]+p-&gt;noiseoffset[offset_select][i];</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     if(val&gt;p-&gt;vi-&gt;noisemaxsupp)val=p-&gt;vi-&gt;noisemaxsupp;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     logmask[i]=max(val,tone[i]+toneatt);</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :     /* AoTuV */
<span class="lineNum">     792 </span>            :     /** @ M1 **
<span class="lineNum">     793 </span>            :         The following codes improve a noise problem.
<span class="lineNum">     794 </span>            :         A fundamental idea uses the value of masking and carries out
<span class="lineNum">     795 </span>            :         the relative compensation of the MDCT.
<span class="lineNum">     796 </span>            :         However, this code is not perfect and all noise problems cannot be solved.
<span class="lineNum">     797 </span>            :         by Aoyumi @ 2004/04/18
<span class="lineNum">     798 </span>            :     */
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     if(offset_select == 1) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       coeffi = -17.2;       /* coeffi is a -17.2dB threshold */</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       val = val - logmdct[i];  /* val == mdct line value relative to floor in dB */</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :       if(val &gt; coeffi){</span>
<span class="lineNum">     805 </span>            :         /* mdct value is &gt; -17.2 dB below floor */
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         de = 1.0-((val-coeffi)*0.005*cx);</span>
<span class="lineNum">     808 </span>            :         /* pro-rated attenuation:
<span class="lineNum">     809 </span>            :            -0.00 dB boost if mdct value is -17.2dB (relative to floor)
<span class="lineNum">     810 </span>            :            -0.77 dB boost if mdct value is 0dB (relative to floor)
<span class="lineNum">     811 </span>            :            -1.64 dB boost if mdct value is +17.2dB (relative to floor)
<span class="lineNum">     812 </span>            :            etc... */
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         if(de &lt; 0) de = 0.0001;</span>
<span class="lineNum">     815 </span>            :       }else
<span class="lineNum">     816 </span>            :         /* mdct value is &lt;= -17.2 dB below floor */
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         de = 1.0-((val-coeffi)*0.0003*cx);</span>
<span class="lineNum">     819 </span>            :       /* pro-rated attenuation:
<span class="lineNum">     820 </span>            :          +0.00 dB atten if mdct value is -17.2dB (relative to floor)
<span class="lineNum">     821 </span>            :          +0.45 dB atten if mdct value is -34.4dB (relative to floor)
<span class="lineNum">     822 </span>            :          etc... */
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       mdct[i] *= de;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :     }
<span class="lineNum">     827 </span>            :   }
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 : float _vp_ampmax_decay(float amp,vorbis_dsp_state *vd){</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   vorbis_info *vi=vd-&gt;vi;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   codec_setup_info *ci=vi-&gt;codec_setup;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   vorbis_info_psy_global *gi=&amp;ci-&gt;psy_g_param;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   int n=ci-&gt;blocksizes[vd-&gt;W]/2;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   float secs=(float)n/vi-&gt;rate;</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   amp+=secs*gi-&gt;ampmax_att_per_sec;</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :   if(amp&lt;-9999)amp=-9999;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   return(amp);</span>
<span class="lineNum">     841 </span>            : }
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : static float FLOOR1_fromdB_LOOKUP[256]={
<span class="lineNum">     844 </span>            :   1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
<span class="lineNum">     845 </span>            :   1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
<span class="lineNum">     846 </span>            :   1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
<span class="lineNum">     847 </span>            :   2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
<span class="lineNum">     848 </span>            :   2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
<span class="lineNum">     849 </span>            :   3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
<span class="lineNum">     850 </span>            :   4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
<span class="lineNum">     851 </span>            :   6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
<span class="lineNum">     852 </span>            :   7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
<span class="lineNum">     853 </span>            :   1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
<span class="lineNum">     854 </span>            :   1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
<span class="lineNum">     855 </span>            :   1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
<span class="lineNum">     856 </span>            :   2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
<span class="lineNum">     857 </span>            :   2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
<span class="lineNum">     858 </span>            :   3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
<span class="lineNum">     859 </span>            :   4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
<span class="lineNum">     860 </span>            :   5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
<span class="lineNum">     861 </span>            :   7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
<span class="lineNum">     862 </span>            :   9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
<span class="lineNum">     863 </span>            :   1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
<span class="lineNum">     864 </span>            :   1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
<span class="lineNum">     865 </span>            :   2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
<span class="lineNum">     866 </span>            :   2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
<span class="lineNum">     867 </span>            :   3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
<span class="lineNum">     868 </span>            :   4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
<span class="lineNum">     869 </span>            :   5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
<span class="lineNum">     870 </span>            :   7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
<span class="lineNum">     871 </span>            :   9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
<span class="lineNum">     872 </span>            :   0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
<span class="lineNum">     873 </span>            :   0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
<span class="lineNum">     874 </span>            :   0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
<span class="lineNum">     875 </span>            :   0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
<span class="lineNum">     876 </span>            :   0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
<span class="lineNum">     877 </span>            :   0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
<span class="lineNum">     878 </span>            :   0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
<span class="lineNum">     879 </span>            :   0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
<span class="lineNum">     880 </span>            :   0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
<span class="lineNum">     881 </span>            :   0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
<span class="lineNum">     882 </span>            :   0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
<span class="lineNum">     883 </span>            :   0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
<span class="lineNum">     884 </span>            :   0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
<span class="lineNum">     885 </span>            :   0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
<span class="lineNum">     886 </span>            :   0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
<span class="lineNum">     887 </span>            :   0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
<span class="lineNum">     888 </span>            :   0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
<span class="lineNum">     889 </span>            :   0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
<span class="lineNum">     890 </span>            :   0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
<span class="lineNum">     891 </span>            :   0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
<span class="lineNum">     892 </span>            :   0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
<span class="lineNum">     893 </span>            :   0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
<span class="lineNum">     894 </span>            :   0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
<span class="lineNum">     895 </span>            :   0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
<span class="lineNum">     896 </span>            :   0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
<span class="lineNum">     897 </span>            :   0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
<span class="lineNum">     898 </span>            :   0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
<span class="lineNum">     899 </span>            :   0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
<span class="lineNum">     900 </span>            :   0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
<span class="lineNum">     901 </span>            :   0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
<span class="lineNum">     902 </span>            :   0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
<span class="lineNum">     903 </span>            :   0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
<span class="lineNum">     904 </span>            :   0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
<span class="lineNum">     905 </span>            :   0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
<span class="lineNum">     906 </span>            :   0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
<span class="lineNum">     907 </span>            :   0.82788260F, 0.88168307F, 0.9389798F, 1.F,
<span class="lineNum">     908 </span>            : };
<a name="909"><span class="lineNum">     909 </span>            : </a>
<span class="lineNum">     910 </span>            : /* this is for per-channel noise normalization */
<span class="lineNum">     911 </span><span class="lineNoCov">          0 : static int apsort(const void *a, const void *b){</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   float f1=**(float**)a;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :   float f2=**(float**)b;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :   return (f1&lt;f2)-(f1&gt;f2);</span>
<a name="915"><span class="lineNum">     915 </span>            : }</a>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineNoCov">          0 : static void flag_lossless(int limit, float prepoint, float postpoint, float *mdct,</span>
<span class="lineNum">     918 </span>            :                          float *floor, int *flag, int i, int jn){
<span class="lineNum">     919 </span>            :   int j;
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   for(j=0;j&lt;jn;j++){</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     float point = j&gt;=limit-i ? postpoint : prepoint;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     float r = fabs(mdct[j])/floor[j];</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     if(r&lt;point)</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       flag[j]=0;</span>
<span class="lineNum">     925 </span>            :     else
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       flag[j]=1;</span>
<span class="lineNum">     927 </span>            :   }
<span class="lineNum">     928 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            : /* Overload/Side effect: On input, the *q vector holds either the
<span class="lineNum">     931 </span>            :    quantized energy (for elements with the flag set) or the absolute
<a name="932"><span class="lineNum">     932 </span>            :    values of the *r vector (for elements with flag unset).  On output,</a>
<span class="lineNum">     933 </span>            :    *q holds the quantized energy for all elements */
<span class="lineNum">     934 </span><span class="lineNoCov">          0 : static float noise_normalize(vorbis_look_psy *p, int limit, float *r, float *q, float *f, int *flags, float acc, int i, int n, int *out){</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   vorbis_info_psy *vi=p-&gt;vi;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   float **sort = alloca(n*sizeof(*sort));</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   int j,count=0;</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   int start = (vi-&gt;normal_p ? vi-&gt;normal_start-i : n);</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   if(start&gt;n)start=n;</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   /* force classic behavior where only energy in the current band is considered */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   acc=0.f;</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :   /* still responsible for populating *out where noise norm not in
<span class="lineNum">     946 </span>            :      effect.  There's no need to [re]populate *q in these areas */
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   for(j=0;j&lt;start;j++){</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     if(!flags || !flags[j]){ /* lossless coupling already quantized.</span>
<span class="lineNum">     949 </span>            :                                 Don't touch; requantizing based on
<span class="lineNum">     950 </span>            :                                 energy would be incorrect. */
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       float ve = q[j]/f[j];</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :       if(r[j]&lt;0)</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         out[j] = -rint(sqrt(ve));</span>
<span class="lineNum">     954 </span>            :       else
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         out[j] = rint(sqrt(ve));</span>
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span>            :   }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :   /* sort magnitudes for noise norm portion of partition */
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   for(;j&lt;n;j++){</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     if(!flags || !flags[j]){ /* can't noise norm elements that have</span>
<span class="lineNum">     962 </span>            :                                 already been loslessly coupled; we can
<span class="lineNum">     963 </span>            :                                 only account for their energy error */
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       float ve = q[j]/f[j];</span>
<span class="lineNum">     965 </span>            :       /* Despite all the new, more capable coupling code, for now we
<span class="lineNum">     966 </span>            :          implement noise norm as it has been up to this point. Only
<span class="lineNum">     967 </span>            :          consider promotions to unit magnitude from 0.  In addition
<span class="lineNum">     968 </span>            :          the only energy error counted is quantizations to zero. */
<span class="lineNum">     969 </span>            :       /* also-- the original point code only applied noise norm at &gt; pointlimit */
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :       if(ve&lt;.25f &amp;&amp; (!flags || j&gt;=limit-i)){</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         acc += ve;</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         sort[count++]=q+j; /* q is fabs(r) for unflagged element */</span>
<span class="lineNum">     973 </span>            :       }else{
<span class="lineNum">     974 </span>            :         /* For now: no acc adjustment for nonzero quantization.  populate *out and q as this value is final. */
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         if(r[j]&lt;0)</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :           out[j] = -rint(sqrt(ve));</span>
<span class="lineNum">     977 </span>            :         else
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :           out[j] = rint(sqrt(ve));</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         q[j] = out[j]*out[j]*f[j];</span>
<span class="lineNum">     980 </span>            :       }
<span class="lineNum">     981 </span>            :     }/* else{
<span class="lineNum">     982 </span>            :         again, no energy adjustment for error in nonzero quant-- for now
<span class="lineNum">     983 </span>            :         }*/
<span class="lineNum">     984 </span>            :   }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   if(count){</span>
<span class="lineNum">     987 </span>            :     /* noise norm to do */
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     qsort(sort,count,sizeof(*sort),apsort);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;count;j++){</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :       int k=sort[j]-q;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :       if(acc&gt;=vi-&gt;normal_thresh){</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         out[k]=unitnorm(r[k]);</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :         acc-=1.f;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :         q[k]=f[k];</span>
<span class="lineNum">     995 </span>            :       }else{
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         out[k]=0;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :         q[k]=0.f;</span>
<span class="lineNum">     998 </span>            :       }
<span class="lineNum">     999 </span>            :     }
<span class="lineNum">    1000 </span>            :   }
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   return acc;</span>
<span class="lineNum">    1003 </span>            : }
<span class="lineNum">    1004 </span>            : 
<a name="1005"><span class="lineNum">    1005 </span>            : /* Noise normalization, quantization and coupling are not wholly</a>
<span class="lineNum">    1006 </span>            :    seperable processes in depth&gt;1 coupling. */
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 : void _vp_couple_quantize_normalize(int blobno,</span>
<span class="lineNum">    1008 </span>            :                                    vorbis_info_psy_global *g,
<span class="lineNum">    1009 </span>            :                                    vorbis_look_psy *p,
<span class="lineNum">    1010 </span>            :                                    vorbis_info_mapping0 *vi,
<span class="lineNum">    1011 </span>            :                                    float **mdct,
<span class="lineNum">    1012 </span>            :                                    int   **iwork,
<span class="lineNum">    1013 </span>            :                                    int    *nonzero,
<span class="lineNum">    1014 </span>            :                                    int     sliding_lowpass,
<span class="lineNum">    1015 </span>            :                                    int     ch){
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :   int i;
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   int n = p-&gt;n;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   int partition=(p-&gt;vi-&gt;normal_p ? p-&gt;vi-&gt;normal_partition : 16);</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :   int limit = g-&gt;coupling_pointlimit[p-&gt;vi-&gt;blockflag][blobno];</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   float prepoint=stereo_threshholds[g-&gt;coupling_prepointamp[blobno]];</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   float postpoint=stereo_threshholds[g-&gt;coupling_postpointamp[blobno]];</span>
<span class="lineNum">    1023 </span>            : #if 0
<span class="lineNum">    1024 </span>            :   float de=0.1*p-&gt;m_val; /* a blend of the AoTuV M2 and M3 code here and below */
<span class="lineNum">    1025 </span>            : #endif
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :   /* mdct is our raw mdct output, floor not removed. */
<span class="lineNum">    1028 </span>            :   /* inout passes in the ifloor, passes back quantized result */
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :   /* unquantized energy (negative indicates amplitude has negative sign) */
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   float **raw = alloca(ch*sizeof(*raw));</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   /* dual pupose; quantized energy (if flag set), othersize fabs(raw) */
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   float **quant = alloca(ch*sizeof(*quant));</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :   /* floor energy */
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   float **floor = alloca(ch*sizeof(*floor));</span>
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :   /* flags indicating raw/quantized status of elements in raw vector */
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   int   **flag  = alloca(ch*sizeof(*flag));</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            :   /* non-zero flag working vector */
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   int    *nz    = alloca(ch*sizeof(*nz));</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   /* energy surplus/defecit tracking */
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   float  *acc   = alloca((ch+vi-&gt;coupling_steps)*sizeof(*acc));</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :   /* The threshold of a stereo is changed with the size of n */
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if(n &gt; 1000)</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     postpoint=stereo_threshholds_limited[g-&gt;coupling_postpointamp[blobno]];</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   raw[0]   = alloca(ch*partition*sizeof(**raw));</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   quant[0] = alloca(ch*partition*sizeof(**quant));</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   floor[0] = alloca(ch*partition*sizeof(**floor));</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   flag[0]  = alloca(ch*partition*sizeof(**flag));</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   for(i=1;i&lt;ch;i++){</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     raw[i]   = &amp;raw[0][partition*i];</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     quant[i] = &amp;quant[0][partition*i];</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     floor[i] = &amp;floor[0][partition*i];</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     flag[i]  = &amp;flag[0][partition*i];</span>
<span class="lineNum">    1062 </span>            :   }
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;ch+vi-&gt;coupling_steps;i++)</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     acc[i]=0.f;</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i+=partition){</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     int k,j,jn = partition &gt; n-i ? n-i : partition;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     int step,track = 0;</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     memcpy(nz,nonzero,sizeof(*nz)*ch);</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span>            :     /* prefill */
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     memset(flag[0],0,ch*partition*sizeof(**flag));</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     for(k=0;k&lt;ch;k++){</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :       int *iout = &amp;iwork[k][i];</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :       if(nz[k]){</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;jn;j++)</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :           floor[k][j] = FLOOR1_fromdB_LOOKUP[iout[j]];</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         flag_lossless(limit,prepoint,postpoint,&amp;mdct[k][i],floor[k],flag[k],i,jn);</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;jn;j++){</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :           quant[k][j] = raw[k][j] = mdct[k][i+j]*mdct[k][i+j];</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :           if(mdct[k][i+j]&lt;0.f) raw[k][j]*=-1.f;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :           floor[k][j]*=floor[k][j];</span>
<span class="lineNum">    1087 </span>            :         }
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         acc[track]=noise_normalize(p,limit,raw[k],quant[k],floor[k],NULL,acc[track],i,jn,iout);</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :       }else{
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;jn;j++){</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :           floor[k][j] = 1e-10f;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :           raw[k][j] = 0.f;</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :           quant[k][j] = 0.f;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :           flag[k][j] = 0;</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :           iout[j]=0;</span>
<span class="lineNum">    1098 </span>            :         }
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         acc[track]=0.f;</span>
<span class="lineNum">    1100 </span>            :       }
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       track++;</span>
<span class="lineNum">    1102 </span>            :     }
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :     /* coupling */
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     for(step=0;step&lt;vi-&gt;coupling_steps;step++){</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :       int Mi = vi-&gt;coupling_mag[step];</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :       int Ai = vi-&gt;coupling_ang[step];</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :       int *iM = &amp;iwork[Mi][i];</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :       int *iA = &amp;iwork[Ai][i];</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       float *reM = raw[Mi];</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       float *reA = raw[Ai];</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       float *qeM = quant[Mi];</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       float *qeA = quant[Ai];</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       float *floorM = floor[Mi];</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       float *floorA = floor[Ai];</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       int *fM = flag[Mi];</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :       int *fA = flag[Ai];</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       if(nz[Mi] || nz[Ai]){</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         nz[Mi] = nz[Ai] = 1;</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;jn;j++){</span>
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :           if(j&lt;sliding_lowpass-i){</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :             if(fM[j] || fA[j]){</span>
<span class="lineNum">    1126 </span>            :               /* lossless coupling */
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :               reM[j] = fabs(reM[j])+fabs(reA[j]);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :               qeM[j] = qeM[j]+qeA[j];</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :               fM[j]=fA[j]=1;</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :               /* couple iM/iA */
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :               {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                 int A = iM[j];</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :                 int B = iA[j];</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 if(abs(A)&gt;abs(B)){</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                   iA[j]=(A&gt;0?A-B:B-A);</span>
<span class="lineNum">    1139 </span>            :                 }else{
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                   iA[j]=(B&gt;0?A-B:B-A);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                   iM[j]=B;</span>
<span class="lineNum">    1142 </span>            :                 }
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            :                 /* collapse two equivalent tuples to one */
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                 if(iA[j]&gt;=abs(iM[j])*2){</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                   iA[j]= -iA[j];</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                   iM[j]= -iM[j];</span>
<span class="lineNum">    1148 </span>            :                 }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            :               }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :             }else{
<span class="lineNum">    1153 </span>            :               /* lossy (point) coupling */
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :               if(j&lt;limit-i){</span>
<span class="lineNum">    1155 </span>            :                 /* dipole */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                 reM[j] += reA[j];</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :                 qeM[j] = fabs(reM[j]);</span>
<span class="lineNum">    1158 </span>            :               }else{
<span class="lineNum">    1159 </span>            : #if 0
<span class="lineNum">    1160 </span>            :                 /* AoTuV */
<span class="lineNum">    1161 </span>            :                 /** @ M2 **
<span class="lineNum">    1162 </span>            :                     The boost problem by the combination of noise normalization and point stereo is eased.
<span class="lineNum">    1163 </span>            :                     However, this is a temporary patch.
<span class="lineNum">    1164 </span>            :                     by Aoyumi @ 2004/04/18
<span class="lineNum">    1165 </span>            :                 */
<span class="lineNum">    1166 </span>            :                 float derate = (1.0 - de*((float)(j-limit+i) / (float)(n-limit)));
<span class="lineNum">    1167 </span>            :                 /* elliptical */
<span class="lineNum">    1168 </span>            :                 if(reM[j]+reA[j]&lt;0){
<span class="lineNum">    1169 </span>            :                   reM[j] = - (qeM[j] = (fabs(reM[j])+fabs(reA[j]))*derate*derate);
<span class="lineNum">    1170 </span>            :                 }else{
<span class="lineNum">    1171 </span>            :                   reM[j] =   (qeM[j] = (fabs(reM[j])+fabs(reA[j]))*derate*derate);
<span class="lineNum">    1172 </span>            :                 }
<span class="lineNum">    1173 </span>            : #else
<span class="lineNum">    1174 </span>            :                 /* elliptical */
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                 if(reM[j]+reA[j]&lt;0){</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :                   reM[j] = - (qeM[j] = fabs(reM[j])+fabs(reA[j]));</span>
<span class="lineNum">    1177 </span>            :                 }else{
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :                   reM[j] =   (qeM[j] = fabs(reM[j])+fabs(reA[j]));</span>
<span class="lineNum">    1179 </span>            :                 }
<span class="lineNum">    1180 </span>            : #endif
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :               }
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :               reA[j]=qeA[j]=0.f;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :               fA[j]=1;</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :               iA[j]=0;</span>
<span class="lineNum">    1186 </span>            :             }
<span class="lineNum">    1187 </span>            :           }
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :           floorM[j]=floorA[j]=floorM[j]+floorA[j];</span>
<span class="lineNum">    1189 </span>            :         }
<span class="lineNum">    1190 </span>            :         /* normalize the resulting mag vector */
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         acc[track]=noise_normalize(p,limit,raw[Mi],quant[Mi],floor[Mi],flag[Mi],acc[track],i,jn,iM);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         track++;</span>
<span class="lineNum">    1193 </span>            :       }
<span class="lineNum">    1194 </span>            :     }
<span class="lineNum">    1195 </span>            :   }
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;vi-&gt;coupling_steps;i++){</span>
<span class="lineNum">    1198 </span>            :     /* make sure coupling a zero and a nonzero channel results in two
<span class="lineNum">    1199 </span>            :        nonzero channels. */
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     if(nonzero[vi-&gt;coupling_mag[i]] ||</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :        nonzero[vi-&gt;coupling_ang[i]]){</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       nonzero[vi-&gt;coupling_mag[i]]=1;</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :       nonzero[vi-&gt;coupling_ang[i]]=1;</span>
<span class="lineNum">    1204 </span>            :     }
<span class="lineNum">    1205 </span>            :   }
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

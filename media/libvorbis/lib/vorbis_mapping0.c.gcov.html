<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libvorbis/lib/vorbis_mapping0.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/libvorbis/lib</a> - vorbis_mapping0.c<span style="font-size: 80%;"> (source / <a href="vorbis_mapping0.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">240</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /********************************************************************</a>
<span class="lineNum">       2 </span>            :  *                                                                  *
<span class="lineNum">       3 </span>            :  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
<span class="lineNum">       4 </span>            :  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
<span class="lineNum">       5 </span>            :  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
<span class="lineNum">       6 </span>            :  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
<span class="lineNum">       7 </span>            :  *                                                                  *
<span class="lineNum">       8 </span>            :  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
<span class="lineNum">       9 </span>            :  * by the Xiph.Org Foundation http://www.xiph.org/                  *
<span class="lineNum">      10 </span>            :  *                                                                  *
<span class="lineNum">      11 </span>            :  ********************************************************************
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  function: channel mapping 0 implementation
<span class="lineNum">      14 </span>            :  last mod: $Id$
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  ********************************************************************/
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;ogg/ogg.h&gt;
<span class="lineNum">      23 </span>            : #include &quot;vorbis/codec.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;codec_internal.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;codebook.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;window.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;registry.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;psy.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;misc.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : /* simplistic, wasteful way of doing this (unique lookup for each
<span class="lineNum">      32 </span>            :    mode/submapping); there should be a central repository for
<span class="lineNum">      33 </span>            :    identical lookups.  That will require minor work, so I'm putting it
<span class="lineNum">      34 </span>            :    off as low priority.
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :    Why a lookup for each backend in a given mode?  Because the
<span class="lineNum">      37 </span>            :    blocksize is set by the mode, and low backend lookups may require
<a name="38"><span class="lineNum">      38 </span>            :    parameters from other areas of the mode/mapping */</a>
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span><span class="lineNoCov">          0 : static void mapping0_free_info(vorbis_info_mapping *i){</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)i;</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   if(info){</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     memset(info,0,sizeof(*info));</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :     _ogg_free(info);</span>
<span class="lineNum">      45 </span>            :   }
<a name="46"><span class="lineNum">      46 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineNoCov">          0 : static void mapping0_pack(vorbis_info *vi,vorbis_info_mapping *vm,</span>
<span class="lineNum">      49 </span>            :                           oggpack_buffer *opb){
<span class="lineNum">      50 </span>            :   int i;
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)vm;</span>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :   /* another 'we meant to do it this way' hack...  up to beta 4, we
<span class="lineNum">      54 </span>            :      packed 4 binary zeros here to signify one submapping in use.  We
<span class="lineNum">      55 </span>            :      now redefine that to mean four bitflags that indicate use of
<span class="lineNum">      56 </span>            :      deeper features; bit0:submappings, bit1:coupling,
<span class="lineNum">      57 </span>            :      bit2,3:reserved. This is backward compatable with all actual uses
<span class="lineNum">      58 </span>            :      of the beta code. */
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   if(info-&gt;submaps&gt;1){</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     oggpack_write(opb,1,1);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :     oggpack_write(opb,info-&gt;submaps-1,4);</span>
<span class="lineNum">      63 </span>            :   }else
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     oggpack_write(opb,0,1);</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   if(info-&gt;coupling_steps&gt;0){</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     oggpack_write(opb,1,1);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     oggpack_write(opb,info-&gt;coupling_steps-1,8);</span>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;info-&gt;coupling_steps;i++){</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :       oggpack_write(opb,info-&gt;coupling_mag[i],ov_ilog(vi-&gt;channels-1));</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :       oggpack_write(opb,info-&gt;coupling_ang[i],ov_ilog(vi-&gt;channels-1));</span>
<span class="lineNum">      73 </span>            :     }
<span class="lineNum">      74 </span>            :   }else
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     oggpack_write(opb,0,1);</span>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   oggpack_write(opb,0,2); /* 2,3:reserved */</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :   /* we don't write the channel submappings if we only have one... */
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   if(info-&gt;submaps&gt;1){</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;vi-&gt;channels;i++)</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :       oggpack_write(opb,info-&gt;chmuxlist[i],4);</span>
<span class="lineNum">      83 </span>            :   }
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;info-&gt;submaps;i++){</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     oggpack_write(opb,0,8); /* time submap unused */</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     oggpack_write(opb,info-&gt;floorsubmap[i],8);</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     oggpack_write(opb,info-&gt;residuesubmap[i],8);</span>
<span class="lineNum">      88 </span>            :   }
<span class="lineNum">      89 </span><span class="lineNoCov">          0 : }</span>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<span class="lineNum">      91 </span>            : /* also responsible for range checking */
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : static vorbis_info_mapping *mapping0_unpack(vorbis_info *vi,oggpack_buffer *opb){</span>
<span class="lineNum">      93 </span>            :   int i,b;
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   vorbis_info_mapping0 *info=_ogg_calloc(1,sizeof(*info));</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   codec_setup_info     *ci=vi-&gt;codec_setup;</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   memset(info,0,sizeof(*info));</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   if(vi-&gt;channels&lt;=0)goto err_out;</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   b=oggpack_read(opb,1);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   if(b&lt;0)goto err_out;</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   if(b){</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     info-&gt;submaps=oggpack_read(opb,4)+1;</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     if(info-&gt;submaps&lt;=0)goto err_out;</span>
<span class="lineNum">     104 </span>            :   }else
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :     info-&gt;submaps=1;</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   b=oggpack_read(opb,1);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if(b&lt;0)goto err_out;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   if(b){</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     info-&gt;coupling_steps=oggpack_read(opb,8)+1;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     if(info-&gt;coupling_steps&lt;=0)goto err_out;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;info-&gt;coupling_steps;i++){</span>
<span class="lineNum">     113 </span>            :       /* vi-&gt;channels &gt; 0 is enforced in the caller */
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :       int testM=info-&gt;coupling_mag[i]=</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :         oggpack_read(opb,ov_ilog(vi-&gt;channels-1));</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :       int testA=info-&gt;coupling_ang[i]=</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :         oggpack_read(opb,ov_ilog(vi-&gt;channels-1));</span>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       if(testM&lt;0 ||</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :          testA&lt;0 ||</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :          testM==testA ||</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :          testM&gt;=vi-&gt;channels ||</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :          testA&gt;=vi-&gt;channels) goto err_out;</span>
<span class="lineNum">     124 </span>            :     }
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   if(oggpack_read(opb,2)!=0)goto err_out; /* 2,3:reserved */</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   if(info-&gt;submaps&gt;1){</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :       info-&gt;chmuxlist[i]=oggpack_read(opb,4);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       if(info-&gt;chmuxlist[i]&gt;=info-&gt;submaps || info-&gt;chmuxlist[i]&lt;0)goto err_out;</span>
<span class="lineNum">     134 </span>            :     }
<span class="lineNum">     135 </span>            :   }
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;info-&gt;submaps;i++){</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     oggpack_read(opb,8); /* time submap unused */</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     info-&gt;floorsubmap[i]=oggpack_read(opb,8);</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     if(info-&gt;floorsubmap[i]&gt;=ci-&gt;floors || info-&gt;floorsubmap[i]&lt;0)goto err_out;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     info-&gt;residuesubmap[i]=oggpack_read(opb,8);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     if(info-&gt;residuesubmap[i]&gt;=ci-&gt;residues || info-&gt;residuesubmap[i]&lt;0)goto err_out;</span>
<span class="lineNum">     142 </span>            :   }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   return info;</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :  err_out:
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   mapping0_free_info(info);</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   return(NULL);</span>
<span class="lineNum">     149 </span>            : }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : #include &quot;os.h&quot;
<span class="lineNum">     152 </span>            : #include &quot;lpc.h&quot;
<span class="lineNum">     153 </span>            : #include &quot;lsp.h&quot;
<span class="lineNum">     154 </span>            : #include &quot;envelope.h&quot;
<span class="lineNum">     155 </span>            : #include &quot;mdct.h&quot;
<span class="lineNum">     156 </span>            : #include &quot;psy.h&quot;
<span class="lineNum">     157 </span>            : #include &quot;scales.h&quot;
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            : #if 0
<span class="lineNum">     160 </span>            : static long seq=0;
<span class="lineNum">     161 </span>            : static ogg_int64_t total=0;
<span class="lineNum">     162 </span>            : static float FLOOR1_fromdB_LOOKUP[256]={
<span class="lineNum">     163 </span>            :   1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
<span class="lineNum">     164 </span>            :   1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
<span class="lineNum">     165 </span>            :   1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
<span class="lineNum">     166 </span>            :   2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
<span class="lineNum">     167 </span>            :   2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
<span class="lineNum">     168 </span>            :   3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
<span class="lineNum">     169 </span>            :   4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
<span class="lineNum">     170 </span>            :   6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
<span class="lineNum">     171 </span>            :   7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
<span class="lineNum">     172 </span>            :   1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
<span class="lineNum">     173 </span>            :   1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
<span class="lineNum">     174 </span>            :   1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
<span class="lineNum">     175 </span>            :   2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
<span class="lineNum">     176 </span>            :   2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
<span class="lineNum">     177 </span>            :   3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
<span class="lineNum">     178 </span>            :   4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
<span class="lineNum">     179 </span>            :   5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
<span class="lineNum">     180 </span>            :   7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
<span class="lineNum">     181 </span>            :   9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
<span class="lineNum">     182 </span>            :   1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
<span class="lineNum">     183 </span>            :   1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
<span class="lineNum">     184 </span>            :   2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
<span class="lineNum">     185 </span>            :   2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
<span class="lineNum">     186 </span>            :   3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
<span class="lineNum">     187 </span>            :   4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
<span class="lineNum">     188 </span>            :   5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
<span class="lineNum">     189 </span>            :   7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
<span class="lineNum">     190 </span>            :   9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
<span class="lineNum">     191 </span>            :   0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
<span class="lineNum">     192 </span>            :   0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
<span class="lineNum">     193 </span>            :   0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
<span class="lineNum">     194 </span>            :   0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
<span class="lineNum">     195 </span>            :   0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
<span class="lineNum">     196 </span>            :   0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
<span class="lineNum">     197 </span>            :   0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
<span class="lineNum">     198 </span>            :   0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
<span class="lineNum">     199 </span>            :   0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
<span class="lineNum">     200 </span>            :   0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
<span class="lineNum">     201 </span>            :   0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
<span class="lineNum">     202 </span>            :   0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
<span class="lineNum">     203 </span>            :   0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
<span class="lineNum">     204 </span>            :   0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
<span class="lineNum">     205 </span>            :   0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
<span class="lineNum">     206 </span>            :   0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
<span class="lineNum">     207 </span>            :   0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
<span class="lineNum">     208 </span>            :   0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
<span class="lineNum">     209 </span>            :   0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
<span class="lineNum">     210 </span>            :   0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
<span class="lineNum">     211 </span>            :   0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
<span class="lineNum">     212 </span>            :   0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
<span class="lineNum">     213 </span>            :   0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
<span class="lineNum">     214 </span>            :   0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
<span class="lineNum">     215 </span>            :   0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
<span class="lineNum">     216 </span>            :   0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
<span class="lineNum">     217 </span>            :   0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
<span class="lineNum">     218 </span>            :   0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
<span class="lineNum">     219 </span>            :   0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
<span class="lineNum">     220 </span>            :   0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
<span class="lineNum">     221 </span>            :   0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
<span class="lineNum">     222 </span>            :   0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
<span class="lineNum">     223 </span>            :   0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
<span class="lineNum">     224 </span>            :   0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
<span class="lineNum">     225 </span>            :   0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
<span class="lineNum">     226 </span>            :   0.82788260F, 0.88168307F, 0.9389798F, 1.F,
<span class="lineNum">     227 </span>            : };
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            : #endif
<a name="230"><span class="lineNum">     230 </span>            : </a>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : static int mapping0_forward(vorbis_block *vb){</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   vorbis_dsp_state      *vd=vb-&gt;vd;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   vorbis_info           *vi=vd-&gt;vi;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   codec_setup_info      *ci=vi-&gt;codec_setup;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   private_state         *b=vb-&gt;vd-&gt;backend_state;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   vorbis_block_internal *vbi=(vorbis_block_internal *)vb-&gt;internal;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   int                    n=vb-&gt;pcmend;</span>
<span class="lineNum">     239 </span>            :   int i,j,k;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   int    *nonzero    = alloca(sizeof(*nonzero)*vi-&gt;channels);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   float  **gmdct     = _vorbis_block_alloc(vb,vi-&gt;channels*sizeof(*gmdct));</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   int    **iwork      = _vorbis_block_alloc(vb,vi-&gt;channels*sizeof(*iwork));</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   int ***floor_posts = _vorbis_block_alloc(vb,vi-&gt;channels*sizeof(*floor_posts));</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   float global_ampmax=vbi-&gt;ampmax;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   float *local_ampmax=alloca(sizeof(*local_ampmax)*vi-&gt;channels);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   int blocktype=vbi-&gt;blocktype;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   int modenumber=vb-&gt;W;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   vorbis_info_mapping0 *info=ci-&gt;map_param[modenumber];</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   vorbis_look_psy *psy_look=b-&gt;psy+blocktype+(vb-&gt;W?2:0);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   vb-&gt;mode=modenumber;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     float scale=4.f/n;</span>
<span class="lineNum">     258 </span>            :     float scale_dB;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     float *pcm     =vb-&gt;pcm[i];</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     float *logfft  =pcm;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     iwork[i]=_vorbis_block_alloc(vb,n/2*sizeof(**iwork));</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     gmdct[i]=_vorbis_block_alloc(vb,n/2*sizeof(**gmdct));</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     scale_dB=todB(&amp;scale) + .345; /* + .345 is a hack; the original</span>
<span class="lineNum">     267 </span>            :                                      todB estimation used on IEEE 754
<span class="lineNum">     268 </span>            :                                      compliant machines had a bug that
<span class="lineNum">     269 </span>            :                                      returned dB values about a third
<span class="lineNum">     270 </span>            :                                      of a decibel too high.  The bug
<span class="lineNum">     271 </span>            :                                      was harmless because tunings
<span class="lineNum">     272 </span>            :                                      implicitly took that into
<span class="lineNum">     273 </span>            :                                      account.  However, fixing the bug
<span class="lineNum">     274 </span>            :                                      in the estimator requires
<span class="lineNum">     275 </span>            :                                      changing all the tunings as well.
<span class="lineNum">     276 </span>            :                                      For now, it's easier to sync
<span class="lineNum">     277 </span>            :                                      things back up here, and
<span class="lineNum">     278 </span>            :                                      recalibrate the tunings in the
<span class="lineNum">     279 </span>            :                                      next major model upgrade. */
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : #if 0
<span class="lineNum">     282 </span>            :     if(vi-&gt;channels==2){
<span class="lineNum">     283 </span>            :       if(i==0)
<span class="lineNum">     284 </span>            :         _analysis_output(&quot;pcmL&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     285 </span>            :       else
<span class="lineNum">     286 </span>            :         _analysis_output(&quot;pcmR&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     287 </span>            :     }else{
<span class="lineNum">     288 </span>            :       _analysis_output(&quot;pcm&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span>            : #endif
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     /* window the PCM data */
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     _vorbis_apply_window(pcm,b-&gt;window,ci-&gt;blocksizes,vb-&gt;lW,vb-&gt;W,vb-&gt;nW);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : #if 0
<span class="lineNum">     296 </span>            :     if(vi-&gt;channels==2){
<span class="lineNum">     297 </span>            :       if(i==0)
<span class="lineNum">     298 </span>            :         _analysis_output(&quot;windowedL&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     299 </span>            :       else
<span class="lineNum">     300 </span>            :         _analysis_output(&quot;windowedR&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     301 </span>            :     }else{
<span class="lineNum">     302 </span>            :       _analysis_output(&quot;windowed&quot;,seq,pcm,n,0,0,total-n/2);
<span class="lineNum">     303 </span>            :     }
<span class="lineNum">     304 </span>            : #endif
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :     /* transform the PCM data */
<span class="lineNum">     307 </span>            :     /* only MDCT right now.... */
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     mdct_forward(b-&gt;transform[vb-&gt;W][0],pcm,gmdct[i]);</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :     /* FFT yields more accurate tonal estimation (not phase sensitive) */
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     drft_forward(&amp;b-&gt;fft_look[vb-&gt;W],pcm);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     logfft[0]=scale_dB+todB(pcm)  + .345; /* + .345 is a hack; the</span>
<span class="lineNum">     313 </span>            :                                      original todB estimation used on
<span class="lineNum">     314 </span>            :                                      IEEE 754 compliant machines had a
<span class="lineNum">     315 </span>            :                                      bug that returned dB values about
<span class="lineNum">     316 </span>            :                                      a third of a decibel too high.
<span class="lineNum">     317 </span>            :                                      The bug was harmless because
<span class="lineNum">     318 </span>            :                                      tunings implicitly took that into
<span class="lineNum">     319 </span>            :                                      account.  However, fixing the bug
<span class="lineNum">     320 </span>            :                                      in the estimator requires
<span class="lineNum">     321 </span>            :                                      changing all the tunings as well.
<span class="lineNum">     322 </span>            :                                      For now, it's easier to sync
<span class="lineNum">     323 </span>            :                                      things back up here, and
<span class="lineNum">     324 </span>            :                                      recalibrate the tunings in the
<span class="lineNum">     325 </span>            :                                      next major model upgrade. */
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     local_ampmax[i]=logfft[0];</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     for(j=1;j&lt;n-1;j+=2){</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       float temp=pcm[j]*pcm[j]+pcm[j+1]*pcm[j+1];</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       temp=logfft[(j+1)&gt;&gt;1]=scale_dB+.5f*todB(&amp;temp)  + .345; /* +</span>
<span class="lineNum">     330 </span>            :                                      .345 is a hack; the original todB
<span class="lineNum">     331 </span>            :                                      estimation used on IEEE 754
<span class="lineNum">     332 </span>            :                                      compliant machines had a bug that
<span class="lineNum">     333 </span>            :                                      returned dB values about a third
<span class="lineNum">     334 </span>            :                                      of a decibel too high.  The bug
<span class="lineNum">     335 </span>            :                                      was harmless because tunings
<span class="lineNum">     336 </span>            :                                      implicitly took that into
<span class="lineNum">     337 </span>            :                                      account.  However, fixing the bug
<span class="lineNum">     338 </span>            :                                      in the estimator requires
<span class="lineNum">     339 </span>            :                                      changing all the tunings as well.
<span class="lineNum">     340 </span>            :                                      For now, it's easier to sync
<span class="lineNum">     341 </span>            :                                      things back up here, and
<span class="lineNum">     342 </span>            :                                      recalibrate the tunings in the
<span class="lineNum">     343 </span>            :                                      next major model upgrade. */
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :       if(temp&gt;local_ampmax[i])local_ampmax[i]=temp;</span>
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     if(local_ampmax[i]&gt;0.f)local_ampmax[i]=0.f;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     if(local_ampmax[i]&gt;global_ampmax)global_ampmax=local_ampmax[i];</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : #if 0
<span class="lineNum">     351 </span>            :     if(vi-&gt;channels==2){
<span class="lineNum">     352 </span>            :       if(i==0){
<span class="lineNum">     353 </span>            :         _analysis_output(&quot;fftL&quot;,seq,logfft,n/2,1,0,0);
<span class="lineNum">     354 </span>            :       }else{
<span class="lineNum">     355 </span>            :         _analysis_output(&quot;fftR&quot;,seq,logfft,n/2,1,0,0);
<span class="lineNum">     356 </span>            :       }
<span class="lineNum">     357 </span>            :     }else{
<span class="lineNum">     358 </span>            :       _analysis_output(&quot;fft&quot;,seq,logfft,n/2,1,0,0);
<span class="lineNum">     359 </span>            :     }
<span class="lineNum">     360 </span>            : #endif
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :   }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   {
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     float   *noise        = _vorbis_block_alloc(vb,n/2*sizeof(*noise));</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     float   *tone         = _vorbis_block_alloc(vb,n/2*sizeof(*tone));</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     369 </span>            :       /* the encoder setup assumes that all the modes used by any
<span class="lineNum">     370 </span>            :          specific bitrate tweaking use the same floor */
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       int submap=info-&gt;chmuxlist[i];</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :       /* the following makes things clearer to *me* anyway */
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       float *mdct    =gmdct[i];</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :       float *logfft  =vb-&gt;pcm[i];</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       float *logmdct =logfft+n/2;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :       float *logmask =logfft;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       vb-&gt;mode=modenumber;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       floor_posts[i]=_vorbis_block_alloc(vb,PACKETBLOBS*sizeof(**floor_posts));</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       memset(floor_posts[i],0,sizeof(**floor_posts)*PACKETBLOBS);</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       for(j=0;j&lt;n/2;j++)</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         logmdct[j]=todB(mdct+j)  + .345; /* + .345 is a hack; the original</span>
<span class="lineNum">     388 </span>            :                                      todB estimation used on IEEE 754
<span class="lineNum">     389 </span>            :                                      compliant machines had a bug that
<span class="lineNum">     390 </span>            :                                      returned dB values about a third
<span class="lineNum">     391 </span>            :                                      of a decibel too high.  The bug
<span class="lineNum">     392 </span>            :                                      was harmless because tunings
<span class="lineNum">     393 </span>            :                                      implicitly took that into
<span class="lineNum">     394 </span>            :                                      account.  However, fixing the bug
<span class="lineNum">     395 </span>            :                                      in the estimator requires
<span class="lineNum">     396 </span>            :                                      changing all the tunings as well.
<span class="lineNum">     397 </span>            :                                      For now, it's easier to sync
<span class="lineNum">     398 </span>            :                                      things back up here, and
<span class="lineNum">     399 </span>            :                                      recalibrate the tunings in the
<span class="lineNum">     400 </span>            :                                      next major model upgrade. */
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : #if 0
<span class="lineNum">     403 </span>            :       if(vi-&gt;channels==2){
<span class="lineNum">     404 </span>            :         if(i==0)
<span class="lineNum">     405 </span>            :           _analysis_output(&quot;mdctL&quot;,seq,logmdct,n/2,1,0,0);
<span class="lineNum">     406 </span>            :         else
<span class="lineNum">     407 </span>            :           _analysis_output(&quot;mdctR&quot;,seq,logmdct,n/2,1,0,0);
<span class="lineNum">     408 </span>            :       }else{
<span class="lineNum">     409 </span>            :         _analysis_output(&quot;mdct&quot;,seq,logmdct,n/2,1,0,0);
<span class="lineNum">     410 </span>            :       }
<span class="lineNum">     411 </span>            : #endif
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :       /* first step; noise masking.  Not only does 'noise masking'
<span class="lineNum">     414 </span>            :          give us curves from which we can decide how much resolution
<span class="lineNum">     415 </span>            :          to give noise parts of the spectrum, it also implicitly hands
<span class="lineNum">     416 </span>            :          us a tonality estimate (the larger the value in the
<span class="lineNum">     417 </span>            :          'noise_depth' vector, the more tonal that area is) */
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       _vp_noisemask(psy_look,</span>
<span class="lineNum">     420 </span>            :                     logmdct,
<span class="lineNum">     421 </span>            :                     noise); /* noise does not have by-frequency offset
<span class="lineNum">     422 </span>            :                                bias applied yet */
<span class="lineNum">     423 </span>            : #if 0
<span class="lineNum">     424 </span>            :       if(vi-&gt;channels==2){
<span class="lineNum">     425 </span>            :         if(i==0)
<span class="lineNum">     426 </span>            :           _analysis_output(&quot;noiseL&quot;,seq,noise,n/2,1,0,0);
<span class="lineNum">     427 </span>            :         else
<span class="lineNum">     428 </span>            :           _analysis_output(&quot;noiseR&quot;,seq,noise,n/2,1,0,0);
<span class="lineNum">     429 </span>            :       }else{
<span class="lineNum">     430 </span>            :         _analysis_output(&quot;noise&quot;,seq,noise,n/2,1,0,0);
<span class="lineNum">     431 </span>            :       }
<span class="lineNum">     432 </span>            : #endif
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :       /* second step: 'all the other crap'; all the stuff that isn't
<span class="lineNum">     435 </span>            :          computed/fit for bitrate management goes in the second psy
<span class="lineNum">     436 </span>            :          vector.  This includes tone masking, peak limiting and ATH */
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       _vp_tonemask(psy_look,</span>
<span class="lineNum">     439 </span>            :                    logfft,
<span class="lineNum">     440 </span>            :                    tone,
<span class="lineNum">     441 </span>            :                    global_ampmax,
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                    local_ampmax[i]);</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : #if 0
<span class="lineNum">     445 </span>            :       if(vi-&gt;channels==2){
<span class="lineNum">     446 </span>            :         if(i==0)
<span class="lineNum">     447 </span>            :           _analysis_output(&quot;toneL&quot;,seq,tone,n/2,1,0,0);
<span class="lineNum">     448 </span>            :         else
<span class="lineNum">     449 </span>            :           _analysis_output(&quot;toneR&quot;,seq,tone,n/2,1,0,0);
<span class="lineNum">     450 </span>            :       }else{
<span class="lineNum">     451 </span>            :         _analysis_output(&quot;tone&quot;,seq,tone,n/2,1,0,0);
<span class="lineNum">     452 </span>            :       }
<span class="lineNum">     453 </span>            : #endif
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            :       /* third step; we offset the noise vectors, overlay tone
<span class="lineNum">     456 </span>            :          masking.  We then do a floor1-specific line fit.  If we're
<span class="lineNum">     457 </span>            :          performing bitrate management, the line fit is performed
<span class="lineNum">     458 </span>            :          multiple times for up/down tweakage on demand. */
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : #if 0
<span class="lineNum">     461 </span>            :       {
<span class="lineNum">     462 </span>            :       float aotuv[psy_look-&gt;n];
<span class="lineNum">     463 </span>            : #endif
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         _vp_offset_and_mix(psy_look,</span>
<span class="lineNum">     466 </span>            :                            noise,
<span class="lineNum">     467 </span>            :                            tone,
<span class="lineNum">     468 </span>            :                            1,
<span class="lineNum">     469 </span>            :                            logmask,
<span class="lineNum">     470 </span>            :                            mdct,
<span class="lineNum">     471 </span>            :                            logmdct);
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : #if 0
<span class="lineNum">     474 </span>            :         if(vi-&gt;channels==2){
<span class="lineNum">     475 </span>            :           if(i==0)
<span class="lineNum">     476 </span>            :             _analysis_output(&quot;aotuvM1_L&quot;,seq,aotuv,psy_look-&gt;n,1,1,0);
<span class="lineNum">     477 </span>            :           else
<span class="lineNum">     478 </span>            :             _analysis_output(&quot;aotuvM1_R&quot;,seq,aotuv,psy_look-&gt;n,1,1,0);
<span class="lineNum">     479 </span>            :         }else{
<span class="lineNum">     480 </span>            :           _analysis_output(&quot;aotuvM1&quot;,seq,aotuv,psy_look-&gt;n,1,1,0);
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            :       }
<span class="lineNum">     483 </span>            : #endif
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : #if 0
<span class="lineNum">     487 </span>            :       if(vi-&gt;channels==2){
<span class="lineNum">     488 </span>            :         if(i==0)
<span class="lineNum">     489 </span>            :           _analysis_output(&quot;mask1L&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     490 </span>            :         else
<span class="lineNum">     491 </span>            :           _analysis_output(&quot;mask1R&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     492 </span>            :       }else{
<span class="lineNum">     493 </span>            :         _analysis_output(&quot;mask1&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     494 </span>            :       }
<span class="lineNum">     495 </span>            : #endif
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :       /* this algorithm is hardwired to floor 1 for now; abort out if
<span class="lineNum">     498 </span>            :          we're *not* floor1.  This won't happen unless someone has
<span class="lineNum">     499 </span>            :          broken the encode setup lib.  Guard it anyway. */
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       if(ci-&gt;floor_type[info-&gt;floorsubmap[submap]]!=1)return(-1);</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       floor_posts[i][PACKETBLOBS/2]=</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     504 </span>            :                    logmdct,
<span class="lineNum">     505 </span>            :                    logmask);
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :       /* are we managing bitrate?  If so, perform two more fits for
<span class="lineNum">     508 </span>            :          later rate tweaking (fits represent hi/lo) */
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       if(vorbis_bitrate_managed(vb) &amp;&amp; floor_posts[i][PACKETBLOBS/2]){</span>
<span class="lineNum">     510 </span>            :         /* higher rate by way of lower noise curve */
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         _vp_offset_and_mix(psy_look,</span>
<span class="lineNum">     513 </span>            :                            noise,
<span class="lineNum">     514 </span>            :                            tone,
<span class="lineNum">     515 </span>            :                            2,
<span class="lineNum">     516 </span>            :                            logmask,
<span class="lineNum">     517 </span>            :                            mdct,
<span class="lineNum">     518 </span>            :                            logmdct);
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            : #if 0
<span class="lineNum">     521 </span>            :         if(vi-&gt;channels==2){
<span class="lineNum">     522 </span>            :           if(i==0)
<span class="lineNum">     523 </span>            :             _analysis_output(&quot;mask2L&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     524 </span>            :           else
<span class="lineNum">     525 </span>            :             _analysis_output(&quot;mask2R&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     526 </span>            :         }else{
<span class="lineNum">     527 </span>            :           _analysis_output(&quot;mask2&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     528 </span>            :         }
<span class="lineNum">     529 </span>            : #endif
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         floor_posts[i][PACKETBLOBS-1]=</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :           floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     533 </span>            :                      logmdct,
<span class="lineNum">     534 </span>            :                      logmask);
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :         /* lower rate by way of higher noise curve */
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         _vp_offset_and_mix(psy_look,</span>
<span class="lineNum">     538 </span>            :                            noise,
<span class="lineNum">     539 </span>            :                            tone,
<span class="lineNum">     540 </span>            :                            0,
<span class="lineNum">     541 </span>            :                            logmask,
<span class="lineNum">     542 </span>            :                            mdct,
<span class="lineNum">     543 </span>            :                            logmdct);
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : #if 0
<span class="lineNum">     546 </span>            :         if(vi-&gt;channels==2){
<span class="lineNum">     547 </span>            :           if(i==0)
<span class="lineNum">     548 </span>            :             _analysis_output(&quot;mask0L&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     549 </span>            :           else
<span class="lineNum">     550 </span>            :             _analysis_output(&quot;mask0R&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     551 </span>            :         }else{
<span class="lineNum">     552 </span>            :           _analysis_output(&quot;mask0&quot;,seq,logmask,n/2,1,0,0);
<span class="lineNum">     553 </span>            :         }
<span class="lineNum">     554 </span>            : #endif
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         floor_posts[i][0]=</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :           floor1_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     558 </span>            :                      logmdct,
<span class="lineNum">     559 </span>            :                      logmask);
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :         /* we also interpolate a range of intermediate curves for
<span class="lineNum">     562 </span>            :            intermediate rates */
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         for(k=1;k&lt;PACKETBLOBS/2;k++)</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :           floor_posts[i][k]=</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :             floor1_interpolate_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                                    floor_posts[i][0],</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                                    floor_posts[i][PACKETBLOBS/2],</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :                                    k*65536/(PACKETBLOBS/2));</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         for(k=PACKETBLOBS/2+1;k&lt;PACKETBLOBS-1;k++)</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :           floor_posts[i][k]=</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :             floor1_interpolate_fit(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :                                    floor_posts[i][PACKETBLOBS/2],</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                                    floor_posts[i][PACKETBLOBS-1],</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                                    (k-PACKETBLOBS/2)*65536/(PACKETBLOBS/2));</span>
<span class="lineNum">     575 </span>            :       }
<span class="lineNum">     576 </span>            :     }
<span class="lineNum">     577 </span>            :   }
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   vbi-&gt;ampmax=global_ampmax;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   /*
<span class="lineNum">     581 </span>            :     the next phases are performed once for vbr-only and PACKETBLOB
<span class="lineNum">     582 </span>            :     times for bitrate managed modes.
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :     1) encode actual mode being used
<span class="lineNum">     585 </span>            :     2) encode the floor for each channel, compute coded mask curve/res
<span class="lineNum">     586 </span>            :     3) normalize and couple.
<span class="lineNum">     587 </span>            :     4) encode residue
<span class="lineNum">     588 </span>            :     5) save packet bytes to the packetblob vector
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   */
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :   /* iterate over the many masking curve fits we've created */
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :   {
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     int **couple_bundle=alloca(sizeof(*couple_bundle)*vi-&gt;channels);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     int *zerobundle=alloca(sizeof(*zerobundle)*vi-&gt;channels);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     for(k=(vorbis_bitrate_managed(vb)?0:PACKETBLOBS/2);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :         k&lt;=(vorbis_bitrate_managed(vb)?PACKETBLOBS-1:PACKETBLOBS/2);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         k++){</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       oggpack_buffer *opb=vbi-&gt;packetblob[k];</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :       /* start out our new packet blob with packet type and mode */
<span class="lineNum">     604 </span>            :       /* Encode the packet type */
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       oggpack_write(opb,0,1);</span>
<span class="lineNum">     606 </span>            :       /* Encode the modenumber */
<span class="lineNum">     607 </span>            :       /* Encode frame mode, pre,post windowsize, then dispatch */
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       oggpack_write(opb,modenumber,b-&gt;modebits);</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       if(vb-&gt;W){</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         oggpack_write(opb,vb-&gt;lW,1);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         oggpack_write(opb,vb-&gt;nW,1);</span>
<span class="lineNum">     612 </span>            :       }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :       /* encode floor, compute masking curve, sep out residue */
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         int submap=info-&gt;chmuxlist[i];</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         int *ilogmask=iwork[i];</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         nonzero[i]=floor1_encode(opb,vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                                  floor_posts[i][k],</span>
<span class="lineNum">     621 </span>            :                                  ilogmask);
<span class="lineNum">     622 </span>            : #if 0
<span class="lineNum">     623 </span>            :         {
<span class="lineNum">     624 </span>            :           char buf[80];
<span class="lineNum">     625 </span>            :           sprintf(buf,&quot;maskI%c%d&quot;,i?'R':'L',k);
<span class="lineNum">     626 </span>            :           float work[n/2];
<span class="lineNum">     627 </span>            :           for(j=0;j&lt;n/2;j++)
<span class="lineNum">     628 </span>            :             work[j]=FLOOR1_fromdB_LOOKUP[iwork[i][j]];
<span class="lineNum">     629 </span>            :           _analysis_output(buf,seq,work,n/2,1,1,0);
<span class="lineNum">     630 </span>            :         }
<span class="lineNum">     631 </span>            : #endif
<span class="lineNum">     632 </span>            :       }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :       /* our iteration is now based on masking curve, not prequant and
<span class="lineNum">     635 </span>            :          coupling.  Only one prequant/coupling step */
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :       /* quantize/couple */
<span class="lineNum">     638 </span>            :       /* incomplete implementation that assumes the tree is all depth
<span class="lineNum">     639 </span>            :          one, or no tree at all */
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       _vp_couple_quantize_normalize(k,</span>
<span class="lineNum">     641 </span>            :                                     &amp;ci-&gt;psy_g_param,
<span class="lineNum">     642 </span>            :                                     psy_look,
<span class="lineNum">     643 </span>            :                                     info,
<span class="lineNum">     644 </span>            :                                     gmdct,
<span class="lineNum">     645 </span>            :                                     iwork,
<span class="lineNum">     646 </span>            :                                     nonzero,
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :                                     ci-&gt;psy_g_param.sliding_lowpass[vb-&gt;W][k],</span>
<span class="lineNum">     648 </span>            :                                     vi-&gt;channels);
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : #if 0
<span class="lineNum">     651 </span>            :       for(i=0;i&lt;vi-&gt;channels;i++){
<span class="lineNum">     652 </span>            :         char buf[80];
<span class="lineNum">     653 </span>            :         sprintf(buf,&quot;res%c%d&quot;,i?'R':'L',k);
<span class="lineNum">     654 </span>            :         float work[n/2];
<span class="lineNum">     655 </span>            :         for(j=0;j&lt;n/2;j++)
<span class="lineNum">     656 </span>            :           work[j]=iwork[i][j];
<span class="lineNum">     657 </span>            :         _analysis_output(buf,seq,work,n/2,1,0,0);
<span class="lineNum">     658 </span>            :       }
<span class="lineNum">     659 </span>            : #endif
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :       /* classify and encode by submap */
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;info-&gt;submaps;i++){</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         int ch_in_bundle=0;</span>
<span class="lineNum">     664 </span>            :         long **classifications;
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         int resnum=info-&gt;residuesubmap[i];</span>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;vi-&gt;channels;j++){</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :           if(info-&gt;chmuxlist[j]==i){</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :             zerobundle[ch_in_bundle]=0;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :             if(nonzero[j])zerobundle[ch_in_bundle]=1;</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :             couple_bundle[ch_in_bundle++]=iwork[j];</span>
<span class="lineNum">     672 </span>            :           }
<span class="lineNum">     673 </span>            :         }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         classifications=_residue_P[ci-&gt;residue_type[resnum]]-&gt;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :           class(vb,b-&gt;residue[resnum],couple_bundle,zerobundle,ch_in_bundle);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         ch_in_bundle=0;</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;vi-&gt;channels;j++)</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :           if(info-&gt;chmuxlist[j]==i)</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :             couple_bundle[ch_in_bundle++]=iwork[j];</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         _residue_P[ci-&gt;residue_type[resnum]]-&gt;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :           forward(opb,vb,b-&gt;residue[resnum],</span>
<span class="lineNum">     685 </span>            :                   couple_bundle,zerobundle,ch_in_bundle,classifications,i);
<span class="lineNum">     686 </span>            :       }
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :       /* ok, done encoding.  Next protopacket. */
<span class="lineNum">     689 </span>            :     }
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :   }
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : #if 0
<span class="lineNum">     694 </span>            :   seq++;
<span class="lineNum">     695 </span>            :   total+=ci-&gt;blocksizes[vb-&gt;W]/4+ci-&gt;blocksizes[vb-&gt;nW]/4;
<span class="lineNum">     696 </span>            : #endif
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :   return(0);</span>
<a name="698"><span class="lineNum">     698 </span>            : }</a>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 : static int mapping0_inverse(vorbis_block *vb,vorbis_info_mapping *l){</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :   vorbis_dsp_state     *vd=vb-&gt;vd;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   vorbis_info          *vi=vd-&gt;vi;</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   codec_setup_info     *ci=vi-&gt;codec_setup;</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   private_state        *b=vd-&gt;backend_state;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)l;</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   int                   i,j;
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   long                  n=vb-&gt;pcmend=ci-&gt;blocksizes[vb-&gt;W];</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   float **pcmbundle=alloca(sizeof(*pcmbundle)*vi-&gt;channels);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   int    *zerobundle=alloca(sizeof(*zerobundle)*vi-&gt;channels);</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   int   *nonzero  =alloca(sizeof(*nonzero)*vi-&gt;channels);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   void **floormemo=alloca(sizeof(*floormemo)*vi-&gt;channels);</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   /* recover the spectral envelope; store it in the PCM vector for now */
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     int submap=info-&gt;chmuxlist[i];</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     floormemo[i]=_floor_P[ci-&gt;floor_type[info-&gt;floorsubmap[submap]]]-&gt;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       inverse1(vb,b-&gt;flr[info-&gt;floorsubmap[submap]]);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     if(floormemo[i])</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :       nonzero[i]=1;</span>
<span class="lineNum">     723 </span>            :     else
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       nonzero[i]=0;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     memset(vb-&gt;pcm[i],0,sizeof(*vb-&gt;pcm[i])*n/2);</span>
<span class="lineNum">     726 </span>            :   }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   /* channel coupling can 'dirty' the nonzero listing */
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;info-&gt;coupling_steps;i++){</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     if(nonzero[info-&gt;coupling_mag[i]] ||</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :        nonzero[info-&gt;coupling_ang[i]]){</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       nonzero[info-&gt;coupling_mag[i]]=1;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       nonzero[info-&gt;coupling_ang[i]]=1;</span>
<span class="lineNum">     734 </span>            :     }
<span class="lineNum">     735 </span>            :   }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   /* recover the residue into our working vectors */
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;info-&gt;submaps;i++){</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     int ch_in_bundle=0;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;vi-&gt;channels;j++){</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :       if(info-&gt;chmuxlist[j]==i){</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         if(nonzero[j])</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :           zerobundle[ch_in_bundle]=1;</span>
<span class="lineNum">     744 </span>            :         else
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :           zerobundle[ch_in_bundle]=0;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         pcmbundle[ch_in_bundle++]=vb-&gt;pcm[j];</span>
<span class="lineNum">     747 </span>            :       }
<span class="lineNum">     748 </span>            :     }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     _residue_P[ci-&gt;residue_type[info-&gt;residuesubmap[i]]]-&gt;</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       inverse(vb,b-&gt;residue[info-&gt;residuesubmap[i]],</span>
<span class="lineNum">     752 </span>            :               pcmbundle,zerobundle,ch_in_bundle);
<span class="lineNum">     753 </span>            :   }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            :   /* channel coupling */
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   for(i=info-&gt;coupling_steps-1;i&gt;=0;i--){</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     float *pcmM=vb-&gt;pcm[info-&gt;coupling_mag[i]];</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     float *pcmA=vb-&gt;pcm[info-&gt;coupling_ang[i]];</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     for(j=0;j&lt;n/2;j++){</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :       float mag=pcmM[j];</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       float ang=pcmA[j];</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :       if(mag&gt;0)</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         if(ang&gt;0){</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :           pcmM[j]=mag;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :           pcmA[j]=mag-ang;</span>
<span class="lineNum">     768 </span>            :         }else{
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           pcmA[j]=mag;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :           pcmM[j]=mag+ang;</span>
<span class="lineNum">     771 </span>            :         }
<span class="lineNum">     772 </span>            :       else
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         if(ang&gt;0){</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :           pcmM[j]=mag;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :           pcmA[j]=mag+ang;</span>
<span class="lineNum">     776 </span>            :         }else{
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :           pcmA[j]=mag;</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :           pcmM[j]=mag-ang;</span>
<span class="lineNum">     779 </span>            :         }
<span class="lineNum">     780 </span>            :     }
<span class="lineNum">     781 </span>            :   }
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :   /* compute and apply spectral envelope */
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     float *pcm=vb-&gt;pcm[i];</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     int submap=info-&gt;chmuxlist[i];</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     _floor_P[ci-&gt;floor_type[info-&gt;floorsubmap[submap]]]-&gt;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :       inverse2(vb,b-&gt;flr[info-&gt;floorsubmap[submap]],</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :                floormemo[i],pcm);</span>
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   /* transform the PCM data; takes PCM vector, vb; modifies PCM vector */
<span class="lineNum">     793 </span>            :   /* only MDCT right now.... */
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;vi-&gt;channels;i++){</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     float *pcm=vb-&gt;pcm[i];</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     mdct_backward(b-&gt;transform[vb-&gt;W][0],pcm,pcm);</span>
<span class="lineNum">     797 </span>            :   }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :   /* all done! */
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   return(0);</span>
<span class="lineNum">     801 </span>            : }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : /* export hooks */
<span class="lineNum">     804 </span>            : const vorbis_func_mapping mapping0_exportbundle={
<span class="lineNum">     805 </span>            :   &amp;mapping0_pack,
<span class="lineNum">     806 </span>            :   &amp;mapping0_unpack,
<span class="lineNum">     807 </span>            :   &amp;mapping0_free_info,
<span class="lineNum">     808 </span>            :   &amp;mapping0_forward,
<span class="lineNum">     809 </span>            :   &amp;mapping0_inverse
<span class="lineNum">     810 </span>            : };
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

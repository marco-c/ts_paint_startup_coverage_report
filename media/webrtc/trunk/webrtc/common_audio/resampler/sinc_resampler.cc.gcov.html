<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/common_audio/resampler/sinc_resampler.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/common_audio/resampler</a> - sinc_resampler.cc<span style="font-size: 80%;"> (source / <a href="sinc_resampler.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">116</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2013 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : // Modified from the Chromium original:
<span class="lineNum">      12 </span>            : // src/media/base/sinc_resampler.cc
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : // Initial input buffer layout, dividing into regions r0_ to r4_ (note: r0_, r3_
<span class="lineNum">      15 </span>            : // and r4_ will move after the first load):
<span class="lineNum">      16 </span>            : //
<span class="lineNum">      17 </span>            : // |----------------|-----------------------------------------|----------------|
<span class="lineNum">      18 </span>            : //
<span class="lineNum">      19 </span>            : //                                        request_frames_
<span class="lineNum">      20 </span>            : //                   &lt;---------------------------------------------------------&gt;
<span class="lineNum">      21 </span>            : //                                    r0_ (during first load)
<span class="lineNum">      22 </span>            : //
<span class="lineNum">      23 </span>            : //  kKernelSize / 2   kKernelSize / 2         kKernelSize / 2   kKernelSize / 2
<span class="lineNum">      24 </span>            : // &lt;---------------&gt; &lt;---------------&gt;       &lt;---------------&gt; &lt;---------------&gt;
<span class="lineNum">      25 </span>            : //        r1_               r2_                     r3_               r4_
<span class="lineNum">      26 </span>            : //
<span class="lineNum">      27 </span>            : //                             block_size_ == r4_ - r2_
<span class="lineNum">      28 </span>            : //                   &lt;---------------------------------------&gt;
<span class="lineNum">      29 </span>            : //
<span class="lineNum">      30 </span>            : //                                                  request_frames_
<span class="lineNum">      31 </span>            : //                                    &lt;------------------ ... -----------------&gt;
<span class="lineNum">      32 </span>            : //                                               r0_ (during second load)
<span class="lineNum">      33 </span>            : //
<span class="lineNum">      34 </span>            : // On the second request r0_ slides to the right by kKernelSize / 2 and r3_, r4_
<span class="lineNum">      35 </span>            : // and block_size_ are reinitialized via step (3) in the algorithm below.
<span class="lineNum">      36 </span>            : //
<span class="lineNum">      37 </span>            : // These new regions remain constant until a Flush() occurs.  While complicated,
<span class="lineNum">      38 </span>            : // this allows us to reduce jitter by always requesting the same amount from the
<span class="lineNum">      39 </span>            : // provided callback.
<span class="lineNum">      40 </span>            : //
<span class="lineNum">      41 </span>            : // The algorithm:
<span class="lineNum">      42 </span>            : //
<span class="lineNum">      43 </span>            : // 1) Allocate input_buffer of size: request_frames_ + kKernelSize; this ensures
<span class="lineNum">      44 </span>            : //    there's enough room to read request_frames_ from the callback into region
<span class="lineNum">      45 </span>            : //    r0_ (which will move between the first and subsequent passes).
<span class="lineNum">      46 </span>            : //
<span class="lineNum">      47 </span>            : // 2) Let r1_, r2_ each represent half the kernel centered around r0_:
<span class="lineNum">      48 </span>            : //
<span class="lineNum">      49 </span>            : //        r0_ = input_buffer_ + kKernelSize / 2
<span class="lineNum">      50 </span>            : //        r1_ = input_buffer_
<span class="lineNum">      51 </span>            : //        r2_ = r0_
<span class="lineNum">      52 </span>            : //
<span class="lineNum">      53 </span>            : //    r0_ is always request_frames_ in size.  r1_, r2_ are kKernelSize / 2 in
<span class="lineNum">      54 </span>            : //    size.  r1_ must be zero initialized to avoid convolution with garbage (see
<span class="lineNum">      55 </span>            : //    step (5) for why).
<span class="lineNum">      56 </span>            : //
<span class="lineNum">      57 </span>            : // 3) Let r3_, r4_ each represent half the kernel right aligned with the end of
<span class="lineNum">      58 </span>            : //    r0_ and choose block_size_ as the distance in frames between r4_ and r2_:
<span class="lineNum">      59 </span>            : //
<span class="lineNum">      60 </span>            : //        r3_ = r0_ + request_frames_ - kKernelSize
<span class="lineNum">      61 </span>            : //        r4_ = r0_ + request_frames_ - kKernelSize / 2
<span class="lineNum">      62 </span>            : //        block_size_ = r4_ - r2_ = request_frames_ - kKernelSize / 2
<span class="lineNum">      63 </span>            : //
<span class="lineNum">      64 </span>            : // 4) Consume request_frames_ frames into r0_.
<span class="lineNum">      65 </span>            : //
<span class="lineNum">      66 </span>            : // 5) Position kernel centered at start of r2_ and generate output frames until
<span class="lineNum">      67 </span>            : //    the kernel is centered at the start of r4_ or we've finished generating
<span class="lineNum">      68 </span>            : //    all the output frames.
<span class="lineNum">      69 </span>            : //
<span class="lineNum">      70 </span>            : // 6) Wrap left over data from the r3_ to r1_ and r4_ to r2_.
<span class="lineNum">      71 </span>            : //
<span class="lineNum">      72 </span>            : // 7) If we're on the second load, in order to avoid overwriting the frames we
<span class="lineNum">      73 </span>            : //    just wrapped from r4_ we need to slide r0_ to the right by the size of
<span class="lineNum">      74 </span>            : //    r4_, which is kKernelSize / 2:
<span class="lineNum">      75 </span>            : //
<span class="lineNum">      76 </span>            : //        r0_ = r0_ + kKernelSize / 2 = input_buffer_ + kKernelSize
<span class="lineNum">      77 </span>            : //
<span class="lineNum">      78 </span>            : //    r3_, r4_, and block_size_ then need to be reinitialized, so goto (3).
<span class="lineNum">      79 </span>            : //
<span class="lineNum">      80 </span>            : // 8) Else, if we're not on the second load, goto (4).
<span class="lineNum">      81 </span>            : //
<span class="lineNum">      82 </span>            : // Note: we're glossing over how the sub-sample handling works with
<span class="lineNum">      83 </span>            : // |virtual_source_idx_|, etc.
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : // MSVC++ requires this to be set before any other includes to get M_PI.
<span class="lineNum">      86 </span>            : #ifndef _USE_MATH_DEFINES
<span class="lineNum">      87 </span>            : #define _USE_MATH_DEFINES
<span class="lineNum">      88 </span>            : #endif
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      91 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : #include &lt;limits&gt;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : #include &quot;webrtc/base/checks.h&quot;
<span class="lineNum">      96 </span>            : #include &quot;webrtc/common_audio/resampler/sinc_resampler.h&quot;
<span class="lineNum">      97 </span>            : #include &quot;webrtc/system_wrappers/include/cpu_features_wrapper.h&quot;
<span class="lineNum">      98 </span>            : #include &quot;webrtc/typedefs.h&quot;
<span class="lineNum">      99 </span>            : 
<a name="100"><span class="lineNum">     100 </span>            : namespace {</a>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : double SincScaleFactor(double io_ratio) {</span>
<span class="lineNum">     103 </span>            :   // |sinc_scale_factor| is basically the normalized cutoff frequency of the
<span class="lineNum">     104 </span>            :   // low-pass filter.
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   double sinc_scale_factor = io_ratio &gt; 1.0 ? 1.0 / io_ratio : 1.0;</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   // The sinc function is an idealized brick-wall filter, but since we're
<span class="lineNum">     108 </span>            :   // windowing it the transition from pass to stop does not happen right away.
<span class="lineNum">     109 </span>            :   // So we should adjust the low pass filter cutoff slightly downward to avoid
<span class="lineNum">     110 </span>            :   // some aliasing at the very high-end.
<span class="lineNum">     111 </span>            :   // TODO(crogers): this value is empirical and to be more exact should vary
<span class="lineNum">     112 </span>            :   // depending on kKernelSize.
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   sinc_scale_factor *= 0.9;</span>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   return sinc_scale_factor;</span>
<span class="lineNum">     116 </span>            : }
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : }  // namespace
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : namespace webrtc {
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : const size_t SincResampler::kKernelSize;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : // If we know the minimum architecture at compile time, avoid CPU detection.
<span class="lineNum">     125 </span>            : #if defined(WEBRTC_ARCH_X86_FAMILY)
<a name="126"><span class="lineNum">     126 </span>            : #if defined(__SSE2__)</a>
<span class="lineNum">     127 </span>            : #define CONVOLVE_FUNC Convolve_SSE
<span class="lineNum">     128 </span><span class="lineNoCov">          0 : void SincResampler::InitializeCPUSpecificFeatures() {}</span>
<span class="lineNum">     129 </span>            : #else
<span class="lineNum">     130 </span>            : // x86 CPU detection required.  Function will be set by
<span class="lineNum">     131 </span>            : // InitializeCPUSpecificFeatures().
<span class="lineNum">     132 </span>            : // TODO(dalecurtis): Once Chrome moves to an SSE baseline this can be removed.
<span class="lineNum">     133 </span>            : #define CONVOLVE_FUNC convolve_proc_
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : void SincResampler::InitializeCPUSpecificFeatures() {
<span class="lineNum">     136 </span>            :   convolve_proc_ = WebRtc_GetCPUInfo(kSSE2) ? Convolve_SSE : Convolve_C;
<span class="lineNum">     137 </span>            : }
<span class="lineNum">     138 </span>            : #endif
<span class="lineNum">     139 </span>            : #elif defined(WEBRTC_HAS_NEON)
<span class="lineNum">     140 </span>            : #define CONVOLVE_FUNC Convolve_NEON
<span class="lineNum">     141 </span>            : void SincResampler::InitializeCPUSpecificFeatures() {}
<span class="lineNum">     142 </span>            : #else
<span class="lineNum">     143 </span>            : // Unknown architecture.
<span class="lineNum">     144 </span>            : #define CONVOLVE_FUNC Convolve_C
<span class="lineNum">     145 </span>            : void SincResampler::InitializeCPUSpecificFeatures() {}
<a name="146"><span class="lineNum">     146 </span>            : #endif</a>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : SincResampler::SincResampler(double io_sample_rate_ratio,</span>
<span class="lineNum">     149 </span>            :                              size_t request_frames,
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                              SincResamplerCallback* read_cb)</span>
<span class="lineNum">     151 </span>            :     : io_sample_rate_ratio_(io_sample_rate_ratio),
<span class="lineNum">     152 </span>            :       read_cb_(read_cb),
<span class="lineNum">     153 </span>            :       request_frames_(request_frames),
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :       input_buffer_size_(request_frames_ + kKernelSize),</span>
<span class="lineNum">     155 </span>            :       // Create input buffers with a 16-byte alignment for SSE optimizations.
<span class="lineNum">     156 </span>            :       kernel_storage_(static_cast&lt;float*&gt;(
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :           AlignedMalloc(sizeof(float) * kKernelStorageSize, 16))),</span>
<span class="lineNum">     158 </span>            :       kernel_pre_sinc_storage_(static_cast&lt;float*&gt;(
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :           AlignedMalloc(sizeof(float) * kKernelStorageSize, 16))),</span>
<span class="lineNum">     160 </span>            :       kernel_window_storage_(static_cast&lt;float*&gt;(
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :           AlignedMalloc(sizeof(float) * kKernelStorageSize, 16))),</span>
<span class="lineNum">     162 </span>            :       input_buffer_(static_cast&lt;float*&gt;(
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :           AlignedMalloc(sizeof(float) * input_buffer_size_, 16))),</span>
<span class="lineNum">     164 </span>            : #if defined(WEBRTC_CPU_DETECTION)
<span class="lineNum">     165 </span>            :       convolve_proc_(NULL),
<span class="lineNum">     166 </span>            : #endif
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       r1_(input_buffer_.get()),</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       r2_(input_buffer_.get() + kKernelSize / 2) {</span>
<span class="lineNum">     169 </span>            : #if defined(WEBRTC_CPU_DETECTION)
<span class="lineNum">     170 </span>            :   InitializeCPUSpecificFeatures();
<span class="lineNum">     171 </span>            :   RTC_DCHECK(convolve_proc_);
<span class="lineNum">     172 </span>            : #endif
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   RTC_DCHECK_GT(request_frames_, 0);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   Flush();</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   RTC_DCHECK_GT(block_size_, kKernelSize);</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   memset(kernel_storage_.get(), 0,</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :          sizeof(*kernel_storage_.get()) * kKernelStorageSize);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   memset(kernel_pre_sinc_storage_.get(), 0,</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :          sizeof(*kernel_pre_sinc_storage_.get()) * kKernelStorageSize);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   memset(kernel_window_storage_.get(), 0,</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :          sizeof(*kernel_window_storage_.get()) * kKernelStorageSize);</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   InitializeKernel();</span>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     186 </span>            : 
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 : SincResampler::~SincResampler() {}</span></a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : void SincResampler::UpdateRegions(bool second_load) {</span>
<span class="lineNum">     190 </span>            :   // Setup various region pointers in the buffer (see diagram above).  If we're
<span class="lineNum">     191 </span>            :   // on the second load we need to slide r0_ to the right by kKernelSize / 2.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   r0_ = input_buffer_.get() + (second_load ? kKernelSize : kKernelSize / 2);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   r3_ = r0_ + request_frames_ - kKernelSize;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   r4_ = r0_ + request_frames_ - kKernelSize / 2;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   block_size_ = r4_ - r2_;</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   // r1_ at the beginning of the buffer.
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(r1_, input_buffer_.get());</span>
<span class="lineNum">     199 </span>            :   // r1_ left of r2_, r4_ left of r3_ and size correct.
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(r2_ - r1_, r4_ - r3_);</span>
<span class="lineNum">     201 </span>            :   // r2_ left of r3.
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   RTC_DCHECK_LT(r2_, r3_);</span>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 : void SincResampler::InitializeKernel() {</span>
<span class="lineNum">     206 </span>            :   // Blackman window parameters.
<span class="lineNum">     207 </span>            :   static const double kAlpha = 0.16;
<span class="lineNum">     208 </span>            :   static const double kA0 = 0.5 * (1.0 - kAlpha);
<span class="lineNum">     209 </span>            :   static const double kA1 = 0.5;
<span class="lineNum">     210 </span>            :   static const double kA2 = 0.5 * kAlpha;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :   // Generates a set of windowed sinc() kernels.
<span class="lineNum">     213 </span>            :   // We generate a range of sub-sample offsets from 0.0 to 1.0.
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   const double sinc_scale_factor = SincScaleFactor(io_sample_rate_ratio_);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   for (size_t offset_idx = 0; offset_idx &lt;= kKernelOffsetCount; ++offset_idx) {</span>
<span class="lineNum">     216 </span>            :     const float subsample_offset =
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         static_cast&lt;float&gt;(offset_idx) / kKernelOffsetCount;</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; kKernelSize; ++i) {</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       const size_t idx = i + offset_idx * kKernelSize;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       const float pre_sinc = static_cast&lt;float&gt;(M_PI *</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :           (static_cast&lt;int&gt;(i) - static_cast&lt;int&gt;(kKernelSize / 2) -</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :            subsample_offset));</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       kernel_pre_sinc_storage_[idx] = pre_sinc;</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :       // Compute Blackman window, matching the offset of the sinc().
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       const float x = (i - subsample_offset) / kKernelSize;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       const float window = static_cast&lt;float&gt;(kA0 - kA1 * cos(2.0 * M_PI * x) +</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :           kA2 * cos(4.0 * M_PI * x));</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :       kernel_window_storage_[idx] = window;</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :       // Compute the sinc with offset, then window the sinc() function and store
<span class="lineNum">     233 </span>            :       // at the correct offset.
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       kernel_storage_[idx] = static_cast&lt;float&gt;(window *</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :           ((pre_sinc == 0) ?</span>
<span class="lineNum">     236 </span>            :               sinc_scale_factor :
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :               (sin(sinc_scale_factor * pre_sinc) / pre_sinc)));</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span>            :   }
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 : void SincResampler::SetRatio(double io_sample_rate_ratio) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   if (fabs(io_sample_rate_ratio_ - io_sample_rate_ratio) &lt;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       std::numeric_limits&lt;double&gt;::epsilon()) {</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     246 </span>            :   }
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   io_sample_rate_ratio_ = io_sample_rate_ratio;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :   // Optimize reinitialization by reusing values which are independent of
<span class="lineNum">     251 </span>            :   // |sinc_scale_factor|.  Provides a 3x speedup.
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   const double sinc_scale_factor = SincScaleFactor(io_sample_rate_ratio_);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   for (size_t offset_idx = 0; offset_idx &lt;= kKernelOffsetCount; ++offset_idx) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; kKernelSize; ++i) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       const size_t idx = i + offset_idx * kKernelSize;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       const float window = kernel_window_storage_[idx];</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       const float pre_sinc = kernel_pre_sinc_storage_[idx];</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       kernel_storage_[idx] = static_cast&lt;float&gt;(window *</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :           ((pre_sinc == 0) ?</span>
<span class="lineNum">     261 </span>            :               sinc_scale_factor :
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :               (sin(sinc_scale_factor * pre_sinc) / pre_sinc)));</span>
<span class="lineNum">     263 </span>            :     }
<span class="lineNum">     264 </span>            :   }
<a name="265"><span class="lineNum">     265 </span>            : }</a>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : void SincResampler::Resample(size_t frames, float* destination) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   size_t remaining_frames = frames;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // Step (1) -- Prime the input buffer at the start of the input stream.
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   if (!buffer_primed_ &amp;&amp; remaining_frames) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     read_cb_-&gt;Run(request_frames_, r0_);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     buffer_primed_ = true;</span>
<span class="lineNum">     274 </span>            :   }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :   // Step (2) -- Resample!  const what we can outside of the loop for speed.  It
<span class="lineNum">     277 </span>            :   // actually has an impact on ARM performance.  See inner loop comment below.
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   const double current_io_ratio = io_sample_rate_ratio_;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   const float* const kernel_ptr = kernel_storage_.get();</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   while (remaining_frames) {</span>
<span class="lineNum">     281 </span>            :     // |i| may be negative if the last Resample() call ended on an iteration
<span class="lineNum">     282 </span>            :     // that put |virtual_source_idx_| over the limit.
<span class="lineNum">     283 </span>            :     //
<span class="lineNum">     284 </span>            :     // Note: The loop construct here can severely impact performance on ARM
<span class="lineNum">     285 </span>            :     // or when built with clang.  See https://codereview.chromium.org/18566009/
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     for (int i = static_cast&lt;int&gt;(</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :              ceil((block_size_ - virtual_source_idx_) / current_io_ratio));</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :          i &gt; 0; --i) {</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       RTC_DCHECK_LT(virtual_source_idx_, block_size_);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :       // |virtual_source_idx_| lies in between two kernel offsets so figure out
<span class="lineNum">     292 </span>            :       // what they are.
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       const int source_idx = static_cast&lt;int&gt;(virtual_source_idx_);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       const double subsample_remainder = virtual_source_idx_ - source_idx;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :       const double virtual_offset_idx =
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :           subsample_remainder * kKernelOffsetCount;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :       const int offset_idx = static_cast&lt;int&gt;(virtual_offset_idx);</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :       // We'll compute &quot;convolutions&quot; for the two kernels which straddle
<span class="lineNum">     301 </span>            :       // |virtual_source_idx_|.
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       const float* const k1 = kernel_ptr + offset_idx * kKernelSize;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       const float* const k2 = k1 + kKernelSize;</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :       // Ensure |k1|, |k2| are 16-byte aligned for SIMD usage.  Should always be
<span class="lineNum">     306 </span>            :       // true so long as kKernelSize is a multiple of 16.
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       RTC_DCHECK_EQ(0, reinterpret_cast&lt;uintptr_t&gt;(k1) % 16);</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       RTC_DCHECK_EQ(0, reinterpret_cast&lt;uintptr_t&gt;(k2) % 16);</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :       // Initialize input pointer based on quantized |virtual_source_idx_|.
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       const float* const input_ptr = r1_ + source_idx;</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :       // Figure out how much to weight each kernel's &quot;convolution&quot;.
<span class="lineNum">     314 </span>            :       const double kernel_interpolation_factor =
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :           virtual_offset_idx - offset_idx;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :       *destination++ = CONVOLVE_FUNC(</span>
<span class="lineNum">     317 </span>            :           input_ptr, k1, k2, kernel_interpolation_factor);
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :       // Advance the virtual index.
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       virtual_source_idx_ += current_io_ratio;</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :       if (!--remaining_frames)</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :     // Wrap back around to the start.
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     virtual_source_idx_ -= block_size_;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     // Step (3) -- Copy r3_, r4_ to r1_, r2_.
<span class="lineNum">     330 </span>            :     // This wraps the last input frames back to the start of the buffer.
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     memcpy(r1_, r3_, sizeof(*input_buffer_.get()) * kKernelSize);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :     // Step (4) -- Reinitialize regions if necessary.
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     if (r0_ == r2_)</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       UpdateRegions(true);</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :     // Step (5) -- Refresh the buffer with more input.
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     read_cb_-&gt;Run(request_frames_, r0_);</span>
<span class="lineNum">     339 </span>            :   }
<span class="lineNum">     340 </span>            : }
<span class="lineNum">     341 </span>            : 
<a name="342"><span class="lineNum">     342 </span>            : #undef CONVOLVE_FUNC</a>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : size_t SincResampler::ChunkSize() const {</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   return static_cast&lt;size_t&gt;(block_size_ / io_sample_rate_ratio_);</span>
<a name="346"><span class="lineNum">     346 </span>            : }</a>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : void SincResampler::Flush() {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   virtual_source_idx_ = 0;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   buffer_primed_ = false;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   memset(input_buffer_.get(), 0,</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :          sizeof(*input_buffer_.get()) * input_buffer_size_);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   UpdateRegions(false);</span>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : float SincResampler::Convolve_C(const float* input_ptr, const float* k1,</span>
<span class="lineNum">     357 </span>            :                                 const float* k2,
<span class="lineNum">     358 </span>            :                                 double kernel_interpolation_factor) {
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   float sum1 = 0;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   float sum2 = 0;</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :   // Generate a single output sample.  Unrolling this loop hurt performance in
<span class="lineNum">     363 </span>            :   // local testing.
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   size_t n = kKernelSize;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   while (n--) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     sum1 += *input_ptr * *k1++;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     sum2 += *input_ptr++ * *k2++;</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // Linearly interpolate the two &quot;convolutions&quot;.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   return static_cast&lt;float&gt;((1.0 - kernel_interpolation_factor) * sum1 +</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       kernel_interpolation_factor * sum2);</span>
<span class="lineNum">     373 </span>            : }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

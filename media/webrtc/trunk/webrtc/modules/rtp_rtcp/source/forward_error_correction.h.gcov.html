<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/rtp_rtcp/source</a> - forward_error_correction.h<span style="font-size: 80%;"> (source / <a href="forward_error_correction.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #ifndef WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
<span class="lineNum">      12 </span>            : #define WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;list&gt;
<span class="lineNum">      17 </span>            : #include &lt;memory&gt;
<span class="lineNum">      18 </span>            : #include &lt;vector&gt;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;webrtc/base/basictypes.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;webrtc/base/constructormagic.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;webrtc/base/refcount.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;webrtc/base/scoped_ref_ptr.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;webrtc/modules/rtp_rtcp/include/rtp_rtcp_defines.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;webrtc/modules/rtp_rtcp/source/forward_error_correction_internal.h&quot;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : namespace webrtc {
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : class FecHeaderReader;
<span class="lineNum">      30 </span>            : class FecHeaderWriter;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : // Performs codec-independent forward error correction (FEC), based on RFC 5109.
<span class="lineNum">      33 </span>            : // Option exists to enable unequal protection (UEP) across packets.
<a name="34"><span class="lineNum">      34 </span>            : // This is not to be confused with protection within packets</a>
<span class="lineNum">      35 </span>            : // (referred to as uneven level protection (ULP) in RFC 5109).
<span class="lineNum">      36 </span><span class="lineNoCov">          0 : class ForwardErrorCorrection {</span>
<span class="lineNum">      37 </span>            :  public:
<span class="lineNum">      38 </span>            :   // TODO(holmer): As a next step all these struct-like packet classes should be
<span class="lineNum">      39 </span>            :   // refactored into proper classes, and their members should be made private.
<a name="40"><span class="lineNum">      40 </span>            :   // This will require parts of the functionality in forward_error_correction.cc</a>
<span class="lineNum">      41 </span>            :   // and receiver_fec.cc to be refactored into the packet classes.
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   class Packet {</span>
<span class="lineNum">      43 </span>            :    public:
<span class="lineNum">      44 </span>            :     Packet();
<span class="lineNum">      45 </span>            :     virtual ~Packet();
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :     // Add a reference.
<span class="lineNum">      48 </span>            :     virtual int32_t AddRef();
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :     // Release a reference. Will delete the object if the reference count
<span class="lineNum">      51 </span>            :     // reaches zero.
<span class="lineNum">      52 </span>            :     virtual int32_t Release();
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :     size_t length;                 // Length of packet in bytes.
<span class="lineNum">      55 </span>            :     uint8_t data[IP_PACKET_SIZE];  // Packet data.
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :    private:
<span class="lineNum">      58 </span>            :     int32_t ref_count_;  // Counts the number of references to a packet.
<span class="lineNum">      59 </span>            :   };
<a name="60"><span class="lineNum">      60 </span>            : </a>
<span class="lineNum">      61 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   class SortablePacket {</span>
<span class="lineNum">      63 </span>            :    public:
<span class="lineNum">      64 </span>            :     // Functor which returns true if the sequence number of |first|
<span class="lineNum">      65 </span>            :     // is &lt; the sequence number of |second|.
<span class="lineNum">      66 </span>            :     struct LessThan {
<span class="lineNum">      67 </span>            :       template &lt;typename S, typename T&gt;
<span class="lineNum">      68 </span>            :       bool operator() (const S&amp; first, const T&amp; second);
<span class="lineNum">      69 </span>            :     };
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            :     uint16_t seq_num;
<span class="lineNum">      72 </span>            :   };
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   // The received list parameter of DecodeFec() references structs of this type.
<span class="lineNum">      75 </span>            :   //
<span class="lineNum">      76 </span>            :   // The ssrc member is needed to ensure that we can restore the SSRC field of
<span class="lineNum">      77 </span>            :   // recovered packets. In most situations this could be retrieved from other
<span class="lineNum">      78 </span>            :   // media packets, but in the case of an FEC packet protecting a single
<a name="79"><span class="lineNum">      79 </span>            :   // missing media packet, we have no other means of obtaining it.</a>
<span class="lineNum">      80 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   class ReceivedPacket : public SortablePacket {</span>
<span class="lineNum">      82 </span>            :    public:
<span class="lineNum">      83 </span>            :     ReceivedPacket();
<span class="lineNum">      84 </span>            :     ~ReceivedPacket();
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :     uint32_t ssrc;  // SSRC of the current frame. Must be set for FEC
<span class="lineNum">      87 </span>            :                     // packets, but not required for media packets.
<span class="lineNum">      88 </span>            :     bool is_fec;    // Set to true if this is an FEC packet and false
<span class="lineNum">      89 </span>            :                     // otherwise.
<span class="lineNum">      90 </span>            :     rtc::scoped_refptr&lt;Packet&gt; pkt;  // Pointer to the packet storage.
<span class="lineNum">      91 </span>            :   };
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :   // The recovered list parameter of DecodeFec() references structs of
<a name="94"><span class="lineNum">      94 </span>            :   // this type.</a>
<span class="lineNum">      95 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   class RecoveredPacket : public SortablePacket {</span>
<span class="lineNum">      97 </span>            :    public:
<span class="lineNum">      98 </span>            :     RecoveredPacket();
<span class="lineNum">      99 </span>            :     ~RecoveredPacket();
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :     bool was_recovered;  // Will be true if this packet was recovered by
<span class="lineNum">     102 </span>            :                          // the FEC. Otherwise it was a media packet passed in
<span class="lineNum">     103 </span>            :                          // through the received packet list.
<span class="lineNum">     104 </span>            :     bool returned;  // True when the packet already has been returned to the
<span class="lineNum">     105 </span>            :                     // caller through the callback.
<span class="lineNum">     106 </span>            :     rtc::scoped_refptr&lt;Packet&gt; pkt;  // Pointer to the packet storage.
<span class="lineNum">     107 </span>            :   };
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :   // Used to link media packets to their protecting FEC packets.
<a name="110"><span class="lineNum">     110 </span>            :   //</a>
<span class="lineNum">     111 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   class ProtectedPacket : public ForwardErrorCorrection::SortablePacket {</span>
<span class="lineNum">     113 </span>            :    public:
<span class="lineNum">     114 </span>            :     ProtectedPacket();
<span class="lineNum">     115 </span>            :     ~ProtectedPacket();
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :     rtc::scoped_refptr&lt;ForwardErrorCorrection::Packet&gt; pkt;
<span class="lineNum">     118 </span>            :   };
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   using ProtectedPacketList = std::list&lt;std::unique_ptr&lt;ProtectedPacket&gt;&gt;;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   // Used for internal storage of received FEC packets in a list.
<a name="123"><span class="lineNum">     123 </span>            :   //</a>
<span class="lineNum">     124 </span>            :   // TODO(holmer): Refactor into a proper class.
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   class ReceivedFecPacket : public ForwardErrorCorrection::SortablePacket {</span>
<span class="lineNum">     126 </span>            :    public:
<span class="lineNum">     127 </span>            :     ReceivedFecPacket();
<span class="lineNum">     128 </span>            :     ~ReceivedFecPacket();
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :     // List of media packets that this FEC packet protects.
<span class="lineNum">     131 </span>            :     ProtectedPacketList protected_packets;
<span class="lineNum">     132 </span>            :     // RTP header fields.
<span class="lineNum">     133 </span>            :     uint32_t ssrc;
<span class="lineNum">     134 </span>            :     // FEC header fields.
<span class="lineNum">     135 </span>            :     size_t fec_header_size;
<span class="lineNum">     136 </span>            :     uint32_t protected_ssrc;
<span class="lineNum">     137 </span>            :     uint16_t seq_num_base;
<span class="lineNum">     138 </span>            :     size_t packet_mask_offset;  // Relative start of FEC header.
<span class="lineNum">     139 </span>            :     size_t packet_mask_size;
<span class="lineNum">     140 </span>            :     size_t protection_length;
<span class="lineNum">     141 </span>            :     // Raw data.
<span class="lineNum">     142 </span>            :     rtc::scoped_refptr&lt;ForwardErrorCorrection::Packet&gt; pkt;
<span class="lineNum">     143 </span>            :   };
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   using PacketList = std::list&lt;std::unique_ptr&lt;Packet&gt;&gt;;
<span class="lineNum">     146 </span>            :   using ReceivedPacketList = std::list&lt;std::unique_ptr&lt;ReceivedPacket&gt;&gt;;
<span class="lineNum">     147 </span>            :   using RecoveredPacketList = std::list&lt;std::unique_ptr&lt;RecoveredPacket&gt;&gt;;
<span class="lineNum">     148 </span>            :   using ReceivedFecPacketList = std::list&lt;std::unique_ptr&lt;ReceivedFecPacket&gt;&gt;;
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :   ~ForwardErrorCorrection();
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   // Creates a ForwardErrorCorrection tailored for a specific FEC scheme.
<span class="lineNum">     153 </span>            :   static std::unique_ptr&lt;ForwardErrorCorrection&gt; CreateUlpfec();
<span class="lineNum">     154 </span>            :   static std::unique_ptr&lt;ForwardErrorCorrection&gt; CreateFlexfec();
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   // Generates a list of FEC packets from supplied media packets.
<span class="lineNum">     157 </span>            :   //
<span class="lineNum">     158 </span>            :   // Input:  media_packets          List of media packets to protect, of type
<span class="lineNum">     159 </span>            :   //                                Packet. All packets must belong to the
<span class="lineNum">     160 </span>            :   //                                same frame and the list must not be empty.
<span class="lineNum">     161 </span>            :   // Input:  protection_factor      FEC protection overhead in the [0, 255]
<span class="lineNum">     162 </span>            :   //                                domain. To obtain 100% overhead, or an
<span class="lineNum">     163 </span>            :   //                                equal number of FEC packets as
<span class="lineNum">     164 </span>            :   //                                media packets, use 255.
<span class="lineNum">     165 </span>            :   // Input:  num_important_packets  The number of &quot;important&quot; packets in the
<span class="lineNum">     166 </span>            :   //                                frame. These packets may receive greater
<span class="lineNum">     167 </span>            :   //                                protection than the remaining packets.
<span class="lineNum">     168 </span>            :   //                                The important packets must be located at the
<span class="lineNum">     169 </span>            :   //                                start of the media packet list. For codecs
<span class="lineNum">     170 </span>            :   //                                with data partitioning, the important
<span class="lineNum">     171 </span>            :   //                                packets may correspond to first partition
<span class="lineNum">     172 </span>            :   //                                packets.
<span class="lineNum">     173 </span>            :   // Input:  use_unequal_protection Parameter to enable/disable unequal
<span class="lineNum">     174 </span>            :   //                                protection (UEP) across packets. Enabling
<span class="lineNum">     175 </span>            :   //                                UEP will allocate more protection to the
<span class="lineNum">     176 </span>            :   //                                num_important_packets from the start of the
<span class="lineNum">     177 </span>            :   //                                media_packets.
<span class="lineNum">     178 </span>            :   // Input:  fec_mask_type          The type of packet mask used in the FEC.
<span class="lineNum">     179 </span>            :   //                                Random or bursty type may be selected. The
<span class="lineNum">     180 </span>            :   //                                bursty type is only defined up to 12 media
<span class="lineNum">     181 </span>            :   //                                packets. If the number of media packets is
<span class="lineNum">     182 </span>            :   //                                above 12, the packet masks from the random
<span class="lineNum">     183 </span>            :   //                                table will be selected.
<span class="lineNum">     184 </span>            :   // Output: fec_packets            List of pointers to generated FEC packets,
<span class="lineNum">     185 </span>            :   //                                of type Packet. Must be empty on entry.
<span class="lineNum">     186 </span>            :   //                                The memory available through the list will
<span class="lineNum">     187 </span>            :   //                                be valid until the next call to
<span class="lineNum">     188 </span>            :   //                                EncodeFec().
<span class="lineNum">     189 </span>            :   //
<span class="lineNum">     190 </span>            :   // Returns 0 on success, -1 on failure.
<span class="lineNum">     191 </span>            :   //
<span class="lineNum">     192 </span>            :   int EncodeFec(const PacketList&amp; media_packets,
<span class="lineNum">     193 </span>            :                 uint8_t protection_factor,
<span class="lineNum">     194 </span>            :                 int num_important_packets,
<span class="lineNum">     195 </span>            :                 bool use_unequal_protection,
<span class="lineNum">     196 </span>            :                 FecMaskType fec_mask_type,
<span class="lineNum">     197 </span>            :                 std::list&lt;Packet*&gt;* fec_packets);
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   // Decodes a list of received media and FEC packets. It will parse the
<span class="lineNum">     200 </span>            :   // |received_packets|, storing FEC packets internally, and move
<span class="lineNum">     201 </span>            :   // media packets to |recovered_packets|. The recovered list will be
<span class="lineNum">     202 </span>            :   // sorted by ascending sequence number and have duplicates removed.
<span class="lineNum">     203 </span>            :   // The function should be called as new packets arrive, and
<span class="lineNum">     204 </span>            :   // |recovered_packets| will be progressively assembled with each call.
<span class="lineNum">     205 </span>            :   // When the function returns, |received_packets| will be empty.
<span class="lineNum">     206 </span>            :   //
<span class="lineNum">     207 </span>            :   // The caller will allocate packets submitted through |received_packets|.
<span class="lineNum">     208 </span>            :   // The function will handle allocation of recovered packets.
<span class="lineNum">     209 </span>            :   //
<span class="lineNum">     210 </span>            :   // Input:  received_packets   List of new received packets, of type
<span class="lineNum">     211 </span>            :   //                            ReceivedPacket, belonging to a single
<span class="lineNum">     212 </span>            :   //                            frame. At output the list will be empty,
<span class="lineNum">     213 </span>            :   //                            with packets either stored internally,
<span class="lineNum">     214 </span>            :   //                            or accessible through the recovered list.
<span class="lineNum">     215 </span>            :   // Output: recovered_packets  List of recovered media packets, of type
<span class="lineNum">     216 </span>            :   //                            RecoveredPacket, belonging to a single
<span class="lineNum">     217 </span>            :   //                            frame. The memory available through the
<span class="lineNum">     218 </span>            :   //                            list will be valid until the next call to
<span class="lineNum">     219 </span>            :   //                            DecodeFec().
<span class="lineNum">     220 </span>            :   //
<span class="lineNum">     221 </span>            :   // Returns 0 on success, -1 on failure.
<span class="lineNum">     222 </span>            :   //
<span class="lineNum">     223 </span>            :   int DecodeFec(ReceivedPacketList* received_packets,
<span class="lineNum">     224 </span>            :                 RecoveredPacketList* recovered_packets);
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // Get the number of generated FEC packets, given the number of media packets
<span class="lineNum">     227 </span>            :   // and the protection factor.
<span class="lineNum">     228 </span>            :   static int NumFecPackets(int num_media_packets, int protection_factor);
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :   // Gets the maximum size of the FEC headers in bytes, which must be
<span class="lineNum">     231 </span>            :   // accounted for as packet overhead.
<span class="lineNum">     232 </span>            :   size_t MaxPacketOverhead() const;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :   // Reset internal states from last frame and clear |recovered_packets|.
<span class="lineNum">     235 </span>            :   // Frees all memory allocated by this class.
<span class="lineNum">     236 </span>            :   void ResetState(RecoveredPacketList* recovered_packets);
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   // TODO(brandtr): Remove these functions when the Packet classes
<span class="lineNum">     239 </span>            :   // have been refactored.
<span class="lineNum">     240 </span>            :   static uint16_t ParseSequenceNumber(uint8_t* packet);
<span class="lineNum">     241 </span>            :   static uint32_t ParseSsrc(uint8_t* packet);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :  protected:
<span class="lineNum">     244 </span>            :   ForwardErrorCorrection(std::unique_ptr&lt;FecHeaderReader&gt; fec_header_reader,
<span class="lineNum">     245 </span>            :                          std::unique_ptr&lt;FecHeaderWriter&gt; fec_header_writer);
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :  private:
<span class="lineNum">     248 </span>            :   // Analyzes |media_packets| for holes in the sequence and inserts zero columns
<span class="lineNum">     249 </span>            :   // into the |packet_mask| where those holes are found. Zero columns means that
<span class="lineNum">     250 </span>            :   // those packets will have no protection.
<span class="lineNum">     251 </span>            :   // Returns the number of bits used for one row of the new packet mask.
<span class="lineNum">     252 </span>            :   // Requires that |packet_mask| has at least 6 * |num_fec_packets| bytes
<span class="lineNum">     253 </span>            :   // allocated.
<span class="lineNum">     254 </span>            :   int InsertZerosInPacketMasks(const PacketList&amp; media_packets,
<span class="lineNum">     255 </span>            :                                size_t num_fec_packets);
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :   // Writes FEC payloads and some recovery fields in the FEC headers.
<span class="lineNum">     258 </span>            :   void GenerateFecPayloads(const PacketList&amp; media_packets,
<span class="lineNum">     259 </span>            :                            size_t num_fec_packets);
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // Writes the FEC header fields that are not written by GenerateFecPayloads.
<span class="lineNum">     262 </span>            :   // This includes writing the packet masks.
<span class="lineNum">     263 </span>            :   void FinalizeFecHeaders(size_t num_fec_packets,
<span class="lineNum">     264 </span>            :                           uint32_t media_ssrc,
<span class="lineNum">     265 </span>            :                           uint16_t seq_num_base);
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   // Inserts the |received_packets| into the internal received FEC packet list
<span class="lineNum">     268 </span>            :   // or into |recovered_packets|.
<span class="lineNum">     269 </span>            :   void InsertPackets(ReceivedPacketList* received_packets,
<span class="lineNum">     270 </span>            :                      RecoveredPacketList* recovered_packets);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :   // Inserts the |received_packet| into |recovered_packets|. Deletes duplicates.
<span class="lineNum">     273 </span>            :   void InsertMediaPacket(RecoveredPacketList* recovered_packets,
<span class="lineNum">     274 </span>            :                          ReceivedPacket* received_packet);
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :   // Assigns pointers to the recovered packet from all FEC packets which cover
<span class="lineNum">     277 </span>            :   // it.
<span class="lineNum">     278 </span>            :   // Note: This reduces the complexity when we want to try to recover a packet
<span class="lineNum">     279 </span>            :   // since we don't have to find the intersection between recovered packets and
<span class="lineNum">     280 </span>            :   // packets covered by the FEC packet.
<span class="lineNum">     281 </span>            :   void UpdateCoveringFecPackets(const RecoveredPacket&amp; packet);
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   // Insert |received_packet| into internal FEC list. Deletes duplicates.
<span class="lineNum">     284 </span>            :   void InsertFecPacket(const RecoveredPacketList&amp; recovered_packets,
<span class="lineNum">     285 </span>            :                        ReceivedPacket* received_packet);
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // Assigns pointers to already recovered packets covered by |fec_packet|.
<span class="lineNum">     288 </span>            :   static void AssignRecoveredPackets(
<span class="lineNum">     289 </span>            :       const RecoveredPacketList&amp; recovered_packets,
<span class="lineNum">     290 </span>            :       ReceivedFecPacket* fec_packet);
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   // Attempt to recover missing packets, using the internally stored
<span class="lineNum">     293 </span>            :   // received FEC packets.
<span class="lineNum">     294 </span>            :   void AttemptRecovery(RecoveredPacketList* recovered_packets);
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   // Initializes headers and payload before the XOR operation
<span class="lineNum">     297 </span>            :   // that recovers a packet.
<span class="lineNum">     298 </span>            :   static bool StartPacketRecovery(const ReceivedFecPacket&amp; fec_packet,
<span class="lineNum">     299 </span>            :                                   RecoveredPacket* recovered_packet);
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   // Performs XOR between the first 8 bytes of |src| and |dst| and stores
<span class="lineNum">     302 </span>            :   // the result in |dst|. The 3rd and 4th bytes are used for storing
<span class="lineNum">     303 </span>            :   // the length recovery field.
<span class="lineNum">     304 </span>            :   static void XorHeaders(const Packet&amp; src, Packet* dst);
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   // Performs XOR between the payloads of |src| and |dst| and stores the result
<span class="lineNum">     307 </span>            :   // in |dst|. The parameter |dst_offset| determines at  what byte the
<span class="lineNum">     308 </span>            :   // XOR operation starts in |dst|. In total, |payload_length| bytes are XORed.
<span class="lineNum">     309 </span>            :   static void XorPayloads(const Packet&amp; src,
<span class="lineNum">     310 </span>            :                           size_t payload_length,
<span class="lineNum">     311 </span>            :                           size_t dst_offset,
<span class="lineNum">     312 </span>            :                           Packet* dst);
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :   // Finalizes recovery of packet by setting RTP header fields.
<span class="lineNum">     315 </span>            :   // This is not specific to the FEC scheme used.
<span class="lineNum">     316 </span>            :   static bool FinishPacketRecovery(const ReceivedFecPacket&amp; fec_packet,
<span class="lineNum">     317 </span>            :                                    RecoveredPacket* recovered_packet);
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :   // Recover a missing packet.
<span class="lineNum">     320 </span>            :   static bool RecoverPacket(const ReceivedFecPacket&amp; fec_packet,
<span class="lineNum">     321 </span>            :                             RecoveredPacket* recovered_packet);
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   // Get the number of missing media packets which are covered by |fec_packet|.
<span class="lineNum">     324 </span>            :   // An FEC packet can recover at most one packet, and if zero packets are
<span class="lineNum">     325 </span>            :   // missing the FEC packet can be discarded. This function returns 2 when two
<span class="lineNum">     326 </span>            :   // or more packets are missing.
<span class="lineNum">     327 </span>            :   static int NumCoveredPacketsMissing(const ReceivedFecPacket&amp; fec_packet);
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // Discards old packets in |recovered_packets|, which are no longer relevant
<span class="lineNum">     330 </span>            :   // for recovering lost packets.
<span class="lineNum">     331 </span>            :   void DiscardOldRecoveredPackets(RecoveredPacketList* recovered_packets);
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :   std::unique_ptr&lt;FecHeaderReader&gt; fec_header_reader_;
<span class="lineNum">     334 </span>            :   std::unique_ptr&lt;FecHeaderWriter&gt; fec_header_writer_;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   std::vector&lt;Packet&gt; generated_fec_packets_;
<span class="lineNum">     337 </span>            :   ReceivedFecPacketList received_fec_packets_;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   // Arrays used to avoid dynamically allocating memory when generating
<span class="lineNum">     340 </span>            :   // the packet masks.
<span class="lineNum">     341 </span>            :   // (There are never more than |kUlpfecMaxMediaPackets| FEC packets generated.)
<span class="lineNum">     342 </span>            :   uint8_t packet_masks_[kUlpfecMaxMediaPackets * kUlpfecMaxPacketMaskSize];
<span class="lineNum">     343 </span>            :   uint8_t tmp_packet_masks_[kUlpfecMaxMediaPackets * kUlpfecMaxPacketMaskSize];
<span class="lineNum">     344 </span>            :   size_t packet_mask_size_;
<span class="lineNum">     345 </span>            : };
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : // Classes derived from FecHeader{Reader,Writer} encapsulate the
<a name="348"><span class="lineNum">     348 </span>            : // specifics of reading and writing FEC header for, e.g., ULPFEC</a>
<span class="lineNum">     349 </span>            : // and FlexFEC.
<span class="lineNum">     350 </span><span class="lineNoCov">          0 : class FecHeaderReader {</span>
<span class="lineNum">     351 </span>            :  public:
<span class="lineNum">     352 </span>            :   virtual ~FecHeaderReader();
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   // The maximum number of media packets that can be covered by one FEC packet.
<span class="lineNum">     355 </span>            :   size_t MaxMediaPackets() const;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :   // The maximum number of FEC packets that is supported, per call
<span class="lineNum">     358 </span>            :   // to ForwardErrorCorrection::EncodeFec().
<span class="lineNum">     359 </span>            :   size_t MaxFecPackets() const;
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   // Parses FEC header and stores information in ReceivedFecPacket members.
<span class="lineNum">     362 </span>            :   virtual bool ReadFecHeader(
<span class="lineNum">     363 </span>            :       ForwardErrorCorrection::ReceivedFecPacket* fec_packet) const = 0;
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :  protected:
<span class="lineNum">     366 </span>            :   FecHeaderReader(size_t max_media_packets, size_t max_fec_packets);
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :   const size_t max_media_packets_;
<span class="lineNum">     369 </span>            :   const size_t max_fec_packets_;
<a name="370"><span class="lineNum">     370 </span>            : };</a>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : class FecHeaderWriter {</span>
<span class="lineNum">     373 </span>            :  public:
<span class="lineNum">     374 </span>            :   virtual ~FecHeaderWriter();
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   // The maximum number of media packets that can be covered by one FEC packet.
<span class="lineNum">     377 </span>            :   size_t MaxMediaPackets() const;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   // The maximum number of FEC packets that is supported, per call
<span class="lineNum">     380 </span>            :   // to ForwardErrorCorrection::EncodeFec().
<span class="lineNum">     381 </span>            :   size_t MaxFecPackets() const;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   // The maximum overhead (in bytes) per packet, due to FEC headers.
<span class="lineNum">     384 </span>            :   size_t MaxPacketOverhead() const;
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   // Calculates the minimum packet mask size needed (in bytes),
<span class="lineNum">     387 </span>            :   // given the discrete options of the ULPFEC masks and the bits
<span class="lineNum">     388 </span>            :   // set in the current packet mask.
<span class="lineNum">     389 </span>            :   virtual size_t MinPacketMaskSize(const uint8_t* packet_mask,
<span class="lineNum">     390 </span>            :                                    size_t packet_mask_size) const = 0;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   // The header size (in bytes), given the packet mask size.
<span class="lineNum">     393 </span>            :   virtual size_t FecHeaderSize(size_t packet_mask_size) const = 0;
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   // Writes FEC header.
<span class="lineNum">     396 </span>            :   virtual void FinalizeFecHeader(
<span class="lineNum">     397 </span>            :       uint32_t media_ssrc,
<span class="lineNum">     398 </span>            :       uint16_t seq_num_base,
<span class="lineNum">     399 </span>            :       const uint8_t* packet_mask,
<span class="lineNum">     400 </span>            :       size_t packet_mask_size,
<span class="lineNum">     401 </span>            :       ForwardErrorCorrection::Packet* fec_packet) const = 0;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :  protected:
<span class="lineNum">     404 </span>            :   FecHeaderWriter(size_t max_media_packets,
<span class="lineNum">     405 </span>            :                   size_t max_fec_packets,
<span class="lineNum">     406 </span>            :                   size_t max_packet_overhead);
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :   const size_t max_media_packets_;
<span class="lineNum">     409 </span>            :   const size_t max_fec_packets_;
<span class="lineNum">     410 </span>            :   const size_t max_packet_overhead_;
<span class="lineNum">     411 </span>            : };
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : }  // namespace webrtc
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : #endif  // WEBRTC_MODULES_RTP_RTCP_SOURCE_FORWARD_ERROR_CORRECTION_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

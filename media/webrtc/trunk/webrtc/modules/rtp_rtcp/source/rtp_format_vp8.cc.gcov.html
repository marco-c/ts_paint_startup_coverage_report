<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/rtp_format_vp8.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/rtp_rtcp/source</a> - rtp_format_vp8.cc<span style="font-size: 80%;"> (source / <a href="rtp_format_vp8.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">414</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">32</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2011 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;webrtc/modules/rtp_rtcp/source/rtp_format_vp8.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;assert.h&gt;  // assert
<span class="lineNum">      14 </span>            : #include &lt;string.h&gt;  // memcpy
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;vector&gt;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;webrtc/base/logging.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;webrtc/modules/rtp_rtcp/source/vp8_partition_aggregator.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;webrtc/modules/rtp_rtcp/source/rtp_packet_to_send.h&quot;
<span class="lineNum">      21 </span>            : 
<a name="22"><span class="lineNum">      22 </span>            : namespace webrtc {</a>
<span class="lineNum">      23 </span>            : namespace {
<span class="lineNum">      24 </span><span class="lineNoCov">          0 : int ParseVP8PictureID(RTPVideoHeaderVP8* vp8,</span>
<span class="lineNum">      25 </span>            :                       const uint8_t** data,
<span class="lineNum">      26 </span>            :                       size_t* data_length,
<span class="lineNum">      27 </span>            :                       size_t* parsed_bytes) {
<span class="lineNum">      28 </span><span class="lineNoCov">          0 :   assert(vp8 != NULL);</span>
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   if (*data_length == 0)</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :   vp8-&gt;pictureId = (**data &amp; 0x7F);</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   if (**data &amp; 0x80) {</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :     (*data)++;</span>
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :     (*parsed_bytes)++;</span>
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :     if (--(*data_length) == 0)</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">      38 </span>            :     // PictureId is 15 bits
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :     vp8-&gt;pictureId = (vp8-&gt;pictureId &lt;&lt; 8) + **data;</span>
<span class="lineNum">      40 </span>            :   }
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   (*data)++;</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   (*parsed_bytes)++;</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :   (*data_length)--;</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="45"><span class="lineNum">      45 </span>            : }</a>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : int ParseVP8Tl0PicIdx(RTPVideoHeaderVP8* vp8,</span>
<span class="lineNum">      48 </span>            :                       const uint8_t** data,
<span class="lineNum">      49 </span>            :                       size_t* data_length,
<span class="lineNum">      50 </span>            :                       size_t* parsed_bytes) {
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   assert(vp8 != NULL);</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   if (*data_length == 0)</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   vp8-&gt;tl0PicIdx = **data;</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   (*data)++;</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   (*parsed_bytes)++;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   (*data_length)--;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="60"><span class="lineNum">      60 </span>            : }</a>
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span><span class="lineNoCov">          0 : int ParseVP8TIDAndKeyIdx(RTPVideoHeaderVP8* vp8,</span>
<span class="lineNum">      63 </span>            :                          const uint8_t** data,
<span class="lineNum">      64 </span>            :                          size_t* data_length,
<span class="lineNum">      65 </span>            :                          size_t* parsed_bytes,
<span class="lineNum">      66 </span>            :                          bool has_tid,
<span class="lineNum">      67 </span>            :                          bool has_key_idx) {
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   assert(vp8 != NULL);</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   if (*data_length == 0)</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   if (has_tid) {</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     vp8-&gt;temporalIdx = ((**data &gt;&gt; 6) &amp; 0x03);</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     vp8-&gt;layerSync = (**data &amp; 0x20) ? true : false;  // Y bit</span>
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   if (has_key_idx) {</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     vp8-&gt;keyIdx = (**data &amp; 0x1F);</span>
<span class="lineNum">      78 </span>            :   }
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   (*data)++;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   (*parsed_bytes)++;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   (*data_length)--;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="83"><span class="lineNum">      83 </span>            : }</a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 : int ParseVP8Extension(RTPVideoHeaderVP8* vp8,</span>
<span class="lineNum">      86 </span>            :                       const uint8_t* data,
<span class="lineNum">      87 </span>            :                       size_t data_length) {
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   assert(vp8 != NULL);</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   assert(data_length &gt; 0);</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   size_t parsed_bytes = 0;</span>
<span class="lineNum">      91 </span>            :   // Optional X field is present.
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   bool has_picture_id = (*data &amp; 0x80) ? true : false;   // I bit</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   bool has_tl0_pic_idx = (*data &amp; 0x40) ? true : false;  // L bit</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   bool has_tid = (*data &amp; 0x20) ? true : false;          // T bit</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   bool has_key_idx = (*data &amp; 0x10) ? true : false;      // K bit</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // Advance data and decrease remaining payload size.
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   data++;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   parsed_bytes++;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   data_length--;</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   if (has_picture_id) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     if (ParseVP8PictureID(vp8, &amp;data, &amp;data_length, &amp;parsed_bytes) != 0) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     105 </span>            :     }
<span class="lineNum">     106 </span>            :   }
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if (has_tl0_pic_idx) {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     if (ParseVP8Tl0PicIdx(vp8, &amp;data, &amp;data_length, &amp;parsed_bytes) != 0) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     111 </span>            :     }
<span class="lineNum">     112 </span>            :   }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   if (has_tid || has_key_idx) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     if (ParseVP8TIDAndKeyIdx(</span>
<span class="lineNum">     116 </span>            :             vp8, &amp;data, &amp;data_length, &amp;parsed_bytes, has_tid, has_key_idx) !=
<span class="lineNum">     117 </span>            :         0) {
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     119 </span>            :     }
<span class="lineNum">     120 </span>            :   }
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   return static_cast&lt;int&gt;(parsed_bytes);</span>
<a name="122"><span class="lineNum">     122 </span>            : }</a>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : int ParseVP8FrameSize(RtpDepacketizer::ParsedPayload* parsed_payload,</span>
<span class="lineNum">     125 </span>            :                       const uint8_t* data,
<span class="lineNum">     126 </span>            :                       size_t data_length) {
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   assert(parsed_payload != NULL);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   if (parsed_payload-&gt;frame_type != kVideoFrameKey) {</span>
<span class="lineNum">     129 </span>            :     // Included in payload header for I-frames.
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   if (data_length &lt; 10) {</span>
<span class="lineNum">     133 </span>            :     // For an I-frame we should always have the uncompressed VP8 header
<span class="lineNum">     134 </span>            :     // in the beginning of the partition.
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     136 </span>            :   }
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.width = ((data[7] &lt;&lt; 8) + data[6]) &amp; 0x3FFF;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.height = ((data[9] &lt;&lt; 8) + data[8]) &amp; 0x3FFF;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     140 </span>            : }
<span class="lineNum">     141 </span>            : }  // namespace
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : // Define how the VP8PacketizerModes are implemented.
<span class="lineNum">     144 </span>            : // Modes are: kStrict, kAggregate, kEqualSize.
<span class="lineNum">     145 </span>            : const RtpPacketizerVp8::AggregationMode RtpPacketizerVp8::aggr_modes_
<span class="lineNum">     146 </span>            :     [kNumModes] = {kAggrNone, kAggrPartitions, kAggrFragments};
<span class="lineNum">     147 </span>            : const bool RtpPacketizerVp8::balance_modes_[kNumModes] = {true, true, true};
<span class="lineNum">     148 </span>            : const bool RtpPacketizerVp8::separate_first_modes_[kNumModes] = {true, false,
<a name="149"><span class="lineNum">     149 </span>            :                                                                  false};</a>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 : RtpPacketizerVp8::RtpPacketizerVp8(const RTPVideoHeaderVP8&amp; hdr_info,</span>
<span class="lineNum">     152 </span>            :                                    size_t max_payload_len,
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                                    VP8PacketizerMode mode)</span>
<span class="lineNum">     154 </span>            :     : payload_data_(NULL),
<span class="lineNum">     155 </span>            :       payload_size_(0),
<span class="lineNum">     156 </span>            :       vp8_fixed_payload_descriptor_bytes_(1),
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :       aggr_mode_(aggr_modes_[mode]),</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       balance_(balance_modes_[mode]),</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       separate_first_(separate_first_modes_[mode]),</span>
<span class="lineNum">     160 </span>            :       hdr_info_(hdr_info),
<span class="lineNum">     161 </span>            :       num_partitions_(0),
<span class="lineNum">     162 </span>            :       max_payload_len_(max_payload_len),
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       packets_calculated_(false) {</span>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineNoCov">          0 : RtpPacketizerVp8::RtpPacketizerVp8(const RTPVideoHeaderVP8&amp; hdr_info,</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                                    size_t max_payload_len)</span>
<span class="lineNum">     168 </span>            :     : payload_data_(NULL),
<span class="lineNum">     169 </span>            :       payload_size_(0),
<span class="lineNum">     170 </span>            :       part_info_(),
<span class="lineNum">     171 </span>            :       vp8_fixed_payload_descriptor_bytes_(1),
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       aggr_mode_(aggr_modes_[kEqualSize]),</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       balance_(balance_modes_[kEqualSize]),</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       separate_first_(separate_first_modes_[kEqualSize]),</span>
<span class="lineNum">     175 </span>            :       hdr_info_(hdr_info),
<span class="lineNum">     176 </span>            :       num_partitions_(0),
<span class="lineNum">     177 </span>            :       max_payload_len_(max_payload_len),
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :       packets_calculated_(false) {</span>
<a name="179"><span class="lineNum">     179 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : RtpPacketizerVp8::~RtpPacketizerVp8() {</span>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : void RtpPacketizerVp8::SetPayloadData(</span>
<span class="lineNum">     185 </span>            :     const uint8_t* payload_data,
<span class="lineNum">     186 </span>            :     size_t payload_size,
<span class="lineNum">     187 </span>            :     const RTPFragmentationHeader* fragmentation) {
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   payload_data_ = payload_data;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   payload_size_ = payload_size;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   if (fragmentation) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     part_info_.CopyFrom(*fragmentation);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     num_partitions_ = fragmentation-&gt;fragmentationVectorSize;</span>
<span class="lineNum">     193 </span>            :   } else {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     part_info_.VerifyAndAllocateFragmentationHeader(1);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     part_info_.fragmentationLength[0] = payload_size;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     part_info_.fragmentationOffset[0] = 0;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     num_partitions_ = part_info_.fragmentationVectorSize;</span>
<span class="lineNum">     198 </span>            :   }
<a name="199"><span class="lineNum">     199 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : bool RtpPacketizerVp8::NextPacket(RtpPacketToSend* packet, bool* last_packet) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   RTC_DCHECK(packet);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   RTC_DCHECK(last_packet);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   if (!packets_calculated_) {</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     int ret = 0;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     if (aggr_mode_ == kAggrPartitions &amp;&amp; balance_) {</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :       ret = GeneratePacketsBalancedAggregates();</span>
<span class="lineNum">     208 </span>            :     } else {
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       ret = GeneratePackets();</span>
<span class="lineNum">     210 </span>            :     }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (ret &lt; 0) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     213 </span>            :     }
<span class="lineNum">     214 </span>            :   }
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   if (packets_.empty()) {</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     217 </span>            :   }
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   InfoStruct packet_info = packets_.front();</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   packets_.pop();</span>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   uint8_t* buffer = packet-&gt;AllocatePayload(max_payload_len_);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   int bytes = WriteHeaderAndPayload(packet_info, buffer, max_payload_len_);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   if (bytes &lt; 0) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     225 </span>            :   }
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   packet-&gt;SetPayloadSize(bytes);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   *last_packet = packets_.empty();</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   packet-&gt;SetMarker(*last_packet);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="230"><span class="lineNum">     230 </span>            : }</a>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : ProtectionType RtpPacketizerVp8::GetProtectionType() {</span>
<span class="lineNum">     233 </span>            :   bool protect =
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       hdr_info_.temporalIdx == 0 || hdr_info_.temporalIdx == kNoTemporalIdx;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   return protect ? kProtectedPacket : kUnprotectedPacket;</span>
<a name="236"><span class="lineNum">     236 </span>            : }</a>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : StorageType RtpPacketizerVp8::GetStorageType(uint32_t retransmission_settings) {</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   if (hdr_info_.temporalIdx == 0 &amp;&amp;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :       !(retransmission_settings &amp; kRetransmitBaseLayer)) {</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     return kDontRetransmit;</span>
<span class="lineNum">     242 </span>            :   }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   if (hdr_info_.temporalIdx != kNoTemporalIdx &amp;&amp;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :              hdr_info_.temporalIdx &gt; 0 &amp;&amp;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :              !(retransmission_settings &amp; kRetransmitHigherLayers)) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     return kDontRetransmit;</span>
<span class="lineNum">     247 </span>            :   }
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   return kAllowRetransmission;</span>
<a name="249"><span class="lineNum">     249 </span>            : }</a>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : std::string RtpPacketizerVp8::ToString() {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   return &quot;RtpPacketizerVp8&quot;;</span>
<a name="253"><span class="lineNum">     253 </span>            : }</a>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 : size_t RtpPacketizerVp8::CalcNextSize(size_t max_payload_len,</span>
<span class="lineNum">     256 </span>            :                                       size_t remaining_bytes,
<span class="lineNum">     257 </span>            :                                       bool split_payload) const {
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   if (max_payload_len == 0 || remaining_bytes == 0) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     260 </span>            :   }
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   if (!split_payload) {</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     return max_payload_len &gt;= remaining_bytes ? remaining_bytes : 0;</span>
<span class="lineNum">     263 </span>            :   }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   if (balance_) {</span>
<span class="lineNum">     266 </span>            :     // Balance payload sizes to produce (almost) equal size
<span class="lineNum">     267 </span>            :     // fragments.
<span class="lineNum">     268 </span>            :     // Number of fragments for remaining_bytes:
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     size_t num_frags = remaining_bytes / max_payload_len + 1;</span>
<span class="lineNum">     270 </span>            :     // Number of bytes in this fragment:
<span class="lineNum">     271 </span>            :     return static_cast&lt;size_t&gt;(
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         static_cast&lt;double&gt;(remaining_bytes) / num_frags + 0.5);</span>
<span class="lineNum">     273 </span>            :   } else {
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     return max_payload_len &gt;= remaining_bytes ? remaining_bytes</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                                               : max_payload_len;</span>
<span class="lineNum">     276 </span>            :   }
<a name="277"><span class="lineNum">     277 </span>            : }</a>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::GeneratePackets() {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   if (max_payload_len_ &lt; vp8_fixed_payload_descriptor_bytes_ +</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                              PayloadDescriptorExtraLength() + 1) {</span>
<span class="lineNum">     282 </span>            :     // The provided payload length is not long enough for the payload
<span class="lineNum">     283 </span>            :     // descriptor and one payload byte. Return an error.
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     285 </span>            :   }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   size_t total_bytes_processed = 0;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   bool start_on_new_fragment = true;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   bool beginning = true;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   size_t part_ix = 0;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   while (total_bytes_processed &lt; payload_size_) {</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     size_t packet_bytes = 0;    // How much data to send in this packet.</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     bool split_payload = true;  // Splitting of partitions is initially allowed.</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     size_t remaining_in_partition = part_info_.fragmentationOffset[part_ix] -</span>
<span class="lineNum">     294 </span>            :                                  total_bytes_processed +
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :                                  part_info_.fragmentationLength[part_ix];</span>
<span class="lineNum">     296 </span>            :     size_t rem_payload_len =
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         max_payload_len_ -</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         (vp8_fixed_payload_descriptor_bytes_ + PayloadDescriptorExtraLength());</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     size_t first_partition_in_packet = part_ix;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     while (size_t next_size = CalcNextSize(</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :                rem_payload_len, remaining_in_partition, split_payload)) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       packet_bytes += next_size;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       rem_payload_len -= next_size;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       remaining_in_partition -= next_size;</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       if (remaining_in_partition == 0 &amp;&amp; !(beginning &amp;&amp; separate_first_)) {</span>
<span class="lineNum">     308 </span>            :         // Advance to next partition?
<span class="lineNum">     309 </span>            :         // Check that there are more partitions; verify that we are either
<span class="lineNum">     310 </span>            :         // allowed to aggregate fragments, or that we are allowed to
<span class="lineNum">     311 </span>            :         // aggregate intact partitions and that we started this packet
<span class="lineNum">     312 </span>            :         // with an intact partition (indicated by first_fragment_ == true).
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         if (part_ix + 1 &lt; num_partitions_ &amp;&amp;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             ((aggr_mode_ == kAggrFragments) ||</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :              (aggr_mode_ == kAggrPartitions &amp;&amp; start_on_new_fragment))) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :           assert(part_ix &lt; num_partitions_);</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :           remaining_in_partition = part_info_.fragmentationLength[++part_ix];</span>
<span class="lineNum">     318 </span>            :           // Disallow splitting unless kAggrFragments. In kAggrPartitions,
<span class="lineNum">     319 </span>            :           // we can only aggregate intact partitions.
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :           split_payload = (aggr_mode_ == kAggrFragments);</span>
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :       } else if (balance_ &amp;&amp; remaining_in_partition &gt; 0) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     324 </span>            :       }
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     if (remaining_in_partition == 0) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       ++part_ix;  // Advance to next partition.</span>
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     assert(packet_bytes &gt; 0);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     QueuePacket(total_bytes_processed,</span>
<span class="lineNum">     332 </span>            :                 packet_bytes,
<span class="lineNum">     333 </span>            :                 first_partition_in_packet,
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :                 start_on_new_fragment);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     total_bytes_processed += packet_bytes;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     start_on_new_fragment = (remaining_in_partition == 0);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     beginning = false;  // Next packet cannot be first packet in frame.</span>
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   packets_calculated_ = true;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   assert(total_bytes_processed == payload_size_);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="342"><span class="lineNum">     342 </span>            : }</a>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::GeneratePacketsBalancedAggregates() {</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   if (max_payload_len_ &lt; vp8_fixed_payload_descriptor_bytes_ +</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                              PayloadDescriptorExtraLength() + 1) {</span>
<span class="lineNum">     347 </span>            :     // The provided payload length is not long enough for the payload
<span class="lineNum">     348 </span>            :     // descriptor and one payload byte. Return an error.
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     350 </span>            :   }
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   std::vector&lt;int&gt; partition_decision;</span>
<span class="lineNum">     352 </span>            :   const size_t overhead =
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       vp8_fixed_payload_descriptor_bytes_ + PayloadDescriptorExtraLength();</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   const size_t max_payload_len = max_payload_len_ - overhead;</span>
<span class="lineNum">     355 </span>            :   int min_size, max_size;
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   AggregateSmallPartitions(&amp;partition_decision, &amp;min_size, &amp;max_size);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   size_t total_bytes_processed = 0;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   size_t part_ix = 0;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   while (part_ix &lt; num_partitions_) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     if (partition_decision[part_ix] == -1) {</span>
<span class="lineNum">     362 </span>            :       // Split large partitions.
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :       size_t remaining_partition = part_info_.fragmentationLength[part_ix];</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :       size_t num_fragments = Vp8PartitionAggregator::CalcNumberOfFragments(</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :           remaining_partition, max_payload_len, overhead, min_size, max_size);</span>
<span class="lineNum">     366 </span>            :       const size_t packet_bytes =
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :           (remaining_partition + num_fragments - 1) / num_fragments;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       for (size_t n = 0; n &lt; num_fragments; ++n) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         const size_t this_packet_bytes = packet_bytes &lt; remaining_partition</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                                              ? packet_bytes</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                                              : remaining_partition;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         QueuePacket(</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :             total_bytes_processed, this_packet_bytes, part_ix, (n == 0));</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         remaining_partition -= this_packet_bytes;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         total_bytes_processed += this_packet_bytes;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         if (static_cast&lt;int&gt;(this_packet_bytes) &lt; min_size) {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :           min_size = this_packet_bytes;</span>
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         if (static_cast&lt;int&gt;(this_packet_bytes) &gt; max_size) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :           max_size = this_packet_bytes;</span>
<span class="lineNum">     381 </span>            :         }
<span class="lineNum">     382 </span>            :       }
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       assert(remaining_partition == 0);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       ++part_ix;</span>
<span class="lineNum">     385 </span>            :     } else {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       size_t this_packet_bytes = 0;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       const size_t first_partition_in_packet = part_ix;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       const int aggregation_index = partition_decision[part_ix];</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       while (part_ix &lt; partition_decision.size() &amp;&amp;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :              partition_decision[part_ix] == aggregation_index) {</span>
<span class="lineNum">     391 </span>            :         // Collect all partitions that were aggregated into the same packet.
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         this_packet_bytes += part_info_.fragmentationLength[part_ix];</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         ++part_ix;</span>
<span class="lineNum">     394 </span>            :       }
<span class="lineNum">     395 </span>            :       QueuePacket(total_bytes_processed,
<span class="lineNum">     396 </span>            :                   this_packet_bytes,
<span class="lineNum">     397 </span>            :                   first_partition_in_packet,
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                   true);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       total_bytes_processed += this_packet_bytes;</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span>            :   }
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   packets_calculated_ = true;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="404"><span class="lineNum">     404 </span>            : }</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 : void RtpPacketizerVp8::AggregateSmallPartitions(std::vector&lt;int&gt;* partition_vec,</span>
<span class="lineNum">     407 </span>            :                                                 int* min_size,
<span class="lineNum">     408 </span>            :                                                 int* max_size) {
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   assert(min_size &amp;&amp; max_size);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   *min_size = -1;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   *max_size = -1;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   assert(partition_vec);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   partition_vec-&gt;assign(num_partitions_, -1);</span>
<span class="lineNum">     414 </span>            :   const size_t overhead =
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       vp8_fixed_payload_descriptor_bytes_ + PayloadDescriptorExtraLength();</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   const size_t max_payload_len = max_payload_len_ - overhead;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   size_t first_in_set = 0;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   size_t last_in_set = 0;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   int num_aggregate_packets = 0;</span>
<span class="lineNum">     420 </span>            :   // Find sets of partitions smaller than max_payload_len_.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   while (first_in_set &lt; num_partitions_) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     if (part_info_.fragmentationLength[first_in_set] &lt; max_payload_len) {</span>
<span class="lineNum">     423 </span>            :       // Found start of a set.
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :       last_in_set = first_in_set;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       while (last_in_set + 1 &lt; num_partitions_ &amp;&amp;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :              part_info_.fragmentationLength[last_in_set + 1] &lt;</span>
<span class="lineNum">     427 </span>            :                  max_payload_len) {
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         ++last_in_set;</span>
<span class="lineNum">     429 </span>            :       }
<span class="lineNum">     430 </span>            :       // Found end of a set. Run optimized aggregator. It is ok if start == end.
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       Vp8PartitionAggregator aggregator(part_info_, first_in_set, last_in_set);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       if (*min_size &gt;= 0 &amp;&amp; *max_size &gt;= 0) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         aggregator.SetPriorMinMax(*min_size, *max_size);</span>
<span class="lineNum">     434 </span>            :       }
<span class="lineNum">     435 </span>            :       Vp8PartitionAggregator::ConfigVec optimal_config =
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :           aggregator.FindOptimalConfiguration(max_payload_len, overhead);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       aggregator.CalcMinMax(optimal_config, min_size, max_size);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       for (size_t i = first_in_set, j = 0; i &lt;= last_in_set; ++i, ++j) {</span>
<span class="lineNum">     439 </span>            :         // Transfer configuration for this set of partitions to the joint
<span class="lineNum">     440 </span>            :         // partition vector representing all partitions in the frame.
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         (*partition_vec)[i] = num_aggregate_packets + optimal_config[j];</span>
<span class="lineNum">     442 </span>            :       }
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       num_aggregate_packets += optimal_config.back() + 1;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :       first_in_set = last_in_set;</span>
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     ++first_in_set;</span>
<span class="lineNum">     447 </span>            :   }
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : void RtpPacketizerVp8::QueuePacket(size_t start_pos,</span>
<span class="lineNum">     451 </span>            :                                    size_t packet_size,
<span class="lineNum">     452 </span>            :                                    size_t first_partition_in_packet,
<span class="lineNum">     453 </span>            :                                    bool start_on_new_fragment) {
<span class="lineNum">     454 </span>            :   // Write info to packet info struct and store in packet info queue.
<span class="lineNum">     455 </span>            :   InfoStruct packet_info;
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   packet_info.payload_start_pos = start_pos;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   packet_info.size = packet_size;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   packet_info.first_partition_ix = first_partition_in_packet;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   packet_info.first_fragment = start_on_new_fragment;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   packets_.push(packet_info);</span>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WriteHeaderAndPayload(const InfoStruct&amp; packet_info,</span>
<span class="lineNum">     464 </span>            :                                             uint8_t* buffer,
<span class="lineNum">     465 </span>            :                                             size_t buffer_length) const {
<span class="lineNum">     466 </span>            :   // Write the VP8 payload descriptor.
<span class="lineNum">     467 </span>            :   //       0
<span class="lineNum">     468 </span>            :   //       0 1 2 3 4 5 6 7 8
<span class="lineNum">     469 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     470 </span>            :   //      |X| |N|S| PART_ID |
<span class="lineNum">     471 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     472 </span>            :   // X:   |I|L|T|K|         | (mandatory if any of the below are used)
<span class="lineNum">     473 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     474 </span>            :   // I:   |PictureID (8/16b)| (optional)
<span class="lineNum">     475 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     476 </span>            :   // L:   |   TL0PIC_IDX    | (optional)
<span class="lineNum">     477 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     478 </span>            :   // T/K: |TID:Y|  KEYIDX   | (optional)
<span class="lineNum">     479 </span>            :   //      +-+-+-+-+-+-+-+-+-+
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   assert(packet_info.size &gt; 0);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   buffer[0] = 0;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   if (XFieldPresent())</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     buffer[0] |= kXBit;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   if (hdr_info_.nonReference)</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     buffer[0] |= kNBit;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   if (packet_info.first_fragment)</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     buffer[0] |= kSBit;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   buffer[0] |= (packet_info.first_partition_ix &amp; kPartIdField);</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   const int extension_length = WriteExtensionFields(buffer, buffer_length);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   if (extension_length &lt; 0)</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   memcpy(&amp;buffer[vp8_fixed_payload_descriptor_bytes_ + extension_length],</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :          &amp;payload_data_[packet_info.payload_start_pos],</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :          packet_info.size);</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   // Return total length of written data.
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   return packet_info.size + vp8_fixed_payload_descriptor_bytes_ +</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :          extension_length;</span>
<a name="502"><span class="lineNum">     502 </span>            : }</a>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WriteExtensionFields(uint8_t* buffer,</span>
<span class="lineNum">     505 </span>            :                                            size_t buffer_length) const {
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   size_t extension_length = 0;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   if (XFieldPresent()) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     uint8_t* x_field = buffer + vp8_fixed_payload_descriptor_bytes_;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     *x_field = 0;</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     extension_length = 1;  // One octet for the X field.</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     if (PictureIdPresent()) {</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :       if (WritePictureIDFields(</span>
<span class="lineNum">     513 </span>            :               x_field, buffer, buffer_length, &amp;extension_length) &lt; 0) {
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     515 </span>            :       }
<span class="lineNum">     516 </span>            :     }
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     if (TL0PicIdxFieldPresent()) {</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       if (WriteTl0PicIdxFields(</span>
<span class="lineNum">     519 </span>            :               x_field, buffer, buffer_length, &amp;extension_length) &lt; 0) {
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     521 </span>            :       }
<span class="lineNum">     522 </span>            :     }
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     if (TIDFieldPresent() || KeyIdxFieldPresent()) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (WriteTIDAndKeyIdxFields(</span>
<span class="lineNum">     525 </span>            :               x_field, buffer, buffer_length, &amp;extension_length) &lt; 0) {
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     527 </span>            :       }
<span class="lineNum">     528 </span>            :     }
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     assert(extension_length == PayloadDescriptorExtraLength());</span>
<span class="lineNum">     530 </span>            :   }
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   return static_cast&lt;int&gt;(extension_length);</span>
<a name="532"><span class="lineNum">     532 </span>            : }</a>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WritePictureIDFields(uint8_t* x_field,</span>
<span class="lineNum">     535 </span>            :                                            uint8_t* buffer,
<span class="lineNum">     536 </span>            :                                            size_t buffer_length,
<span class="lineNum">     537 </span>            :                                            size_t* extension_length) const {
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :   *x_field |= kIBit;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   assert(buffer_length &gt;=</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       vp8_fixed_payload_descriptor_bytes_ + *extension_length);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   const int pic_id_length = WritePictureID(</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       buffer + vp8_fixed_payload_descriptor_bytes_ + *extension_length,</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       buffer_length - vp8_fixed_payload_descriptor_bytes_ - *extension_length);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   if (pic_id_length &lt; 0)</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   *extension_length += pic_id_length;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="548"><span class="lineNum">     548 </span>            : }</a>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WritePictureID(uint8_t* buffer,</span>
<span class="lineNum">     551 </span>            :                                      size_t buffer_length) const {
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   const uint16_t pic_id = static_cast&lt;uint16_t&gt;(hdr_info_.pictureId);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   size_t picture_id_len = PictureIdLength();</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   if (picture_id_len &gt; buffer_length)</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (picture_id_len == 2) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     buffer[0] = 0x80 | ((pic_id &gt;&gt; 8) &amp; 0x7F);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     buffer[1] = pic_id &amp; 0xFF;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   } else if (picture_id_len == 1) {</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     buffer[0] = pic_id &amp; 0x7F;</span>
<span class="lineNum">     561 </span>            :   }
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   return static_cast&lt;int&gt;(picture_id_len);</span>
<a name="563"><span class="lineNum">     563 </span>            : }</a>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WriteTl0PicIdxFields(uint8_t* x_field,</span>
<span class="lineNum">     566 </span>            :                                            uint8_t* buffer,
<span class="lineNum">     567 </span>            :                                            size_t buffer_length,
<span class="lineNum">     568 </span>            :                                            size_t* extension_length) const {
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   if (buffer_length &lt;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       vp8_fixed_payload_descriptor_bytes_ + *extension_length + 1) {</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     572 </span>            :   }
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   *x_field |= kLBit;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   buffer[vp8_fixed_payload_descriptor_bytes_ + *extension_length] =</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       hdr_info_.tl0PicIdx;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   ++*extension_length;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="578"><span class="lineNum">     578 </span>            : }</a>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 : int RtpPacketizerVp8::WriteTIDAndKeyIdxFields(uint8_t* x_field,</span>
<span class="lineNum">     581 </span>            :                                               uint8_t* buffer,
<span class="lineNum">     582 </span>            :                                               size_t buffer_length,
<span class="lineNum">     583 </span>            :                                               size_t* extension_length) const {
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   if (buffer_length &lt;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       vp8_fixed_payload_descriptor_bytes_ + *extension_length + 1) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     587 </span>            :   }
<span class="lineNum">     588 </span>            :   uint8_t* data_field =
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       &amp;buffer[vp8_fixed_payload_descriptor_bytes_ + *extension_length];</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   *data_field = 0;</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   if (TIDFieldPresent()) {</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     *x_field |= kTBit;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     assert(hdr_info_.temporalIdx &lt;= 3);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     *data_field |= hdr_info_.temporalIdx &lt;&lt; 6;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     *data_field |= hdr_info_.layerSync ? kYBit : 0;</span>
<span class="lineNum">     596 </span>            :   }
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   if (KeyIdxFieldPresent()) {</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     *x_field |= kKBit;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     *data_field |= (hdr_info_.keyIdx &amp; kKeyIdxField);</span>
<span class="lineNum">     600 </span>            :   }
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   ++*extension_length;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="603"><span class="lineNum">     603 </span>            : }</a>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 : size_t RtpPacketizerVp8::PayloadDescriptorExtraLength() const {</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   size_t length_bytes = PictureIdLength();</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   if (TL0PicIdxFieldPresent())</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     ++length_bytes;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   if (TIDFieldPresent() || KeyIdxFieldPresent())</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     ++length_bytes;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   if (length_bytes &gt; 0)</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     ++length_bytes;  // Include the extension field.</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   return length_bytes;</span>
<a name="614"><span class="lineNum">     614 </span>            : }</a>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineNoCov">          0 : size_t RtpPacketizerVp8::PictureIdLength() const {</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   if (hdr_info_.pictureId == kNoPictureId) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     619 </span>            :   }
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if (hdr_info_.pictureId &lt;= 0x7F) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     622 </span>            :   }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   return 2;</span>
<a name="624"><span class="lineNum">     624 </span>            : }</a>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 : bool RtpPacketizerVp8::XFieldPresent() const {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   return (TIDFieldPresent() || TL0PicIdxFieldPresent() || PictureIdPresent() ||</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :           KeyIdxFieldPresent());</span>
<a name="629"><span class="lineNum">     629 </span>            : }</a>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 : bool RtpPacketizerVp8::TIDFieldPresent() const {</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   assert((hdr_info_.layerSync == false) ||</span>
<span class="lineNum">     633 </span>            :          (hdr_info_.temporalIdx != kNoTemporalIdx));
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   return (hdr_info_.temporalIdx != kNoTemporalIdx);</span>
<a name="635"><span class="lineNum">     635 </span>            : }</a>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineNoCov">          0 : bool RtpPacketizerVp8::KeyIdxFieldPresent() const {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :   return (hdr_info_.keyIdx != kNoKeyIdx);</span>
<a name="639"><span class="lineNum">     639 </span>            : }</a>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : bool RtpPacketizerVp8::TL0PicIdxFieldPresent() const {</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   return (hdr_info_.tl0PicIdx != kNoTl0PicIdx);</span>
<span class="lineNum">     643 </span>            : }
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : //
<span class="lineNum">     646 </span>            : // VP8 format:
<span class="lineNum">     647 </span>            : //
<span class="lineNum">     648 </span>            : // Payload descriptor
<span class="lineNum">     649 </span>            : //       0 1 2 3 4 5 6 7
<span class="lineNum">     650 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     651 </span>            : //      |X|R|N|S|PartID | (REQUIRED)
<span class="lineNum">     652 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     653 </span>            : // X:   |I|L|T|K|  RSV  | (OPTIONAL)
<span class="lineNum">     654 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     655 </span>            : // I:   |   PictureID   | (OPTIONAL)
<span class="lineNum">     656 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     657 </span>            : // L:   |   TL0PICIDX   | (OPTIONAL)
<span class="lineNum">     658 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     659 </span>            : // T/K: |TID:Y| KEYIDX  | (OPTIONAL)
<span class="lineNum">     660 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     661 </span>            : //
<span class="lineNum">     662 </span>            : // Payload header (considered part of the actual payload, sent to decoder)
<span class="lineNum">     663 </span>            : //       0 1 2 3 4 5 6 7
<span class="lineNum">     664 </span>            : //      +-+-+-+-+-+-+-+-+
<span class="lineNum">     665 </span>            : //      |Size0|H| VER |P|
<span class="lineNum">     666 </span>            : //      +-+-+-+-+-+-+-+-+
<a name="667"><span class="lineNum">     667 </span>            : //      |      ...      |</a>
<span class="lineNum">     668 </span>            : //      +               +
<span class="lineNum">     669 </span><span class="lineNoCov">          0 : bool RtpDepacketizerVp8::Parse(ParsedPayload* parsed_payload,</span>
<span class="lineNum">     670 </span>            :                                const uint8_t* payload_data,
<span class="lineNum">     671 </span>            :                                size_t payload_data_length) {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   assert(parsed_payload != NULL);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   if (payload_data_length == 0) {</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     LOG(LS_ERROR) &lt;&lt; &quot;Empty payload.&quot;;</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     676 </span>            :   }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :   // Parse mandatory first byte of payload descriptor.
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :   bool extension = (*payload_data &amp; 0x80) ? true : false;               // X bit</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :   bool beginning_of_partition = (*payload_data &amp; 0x10) ? true : false;  // S bit</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   int partition_id = (*payload_data &amp; 0x0F);  // PartID field</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.width = 0;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.height = 0;</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.is_first_packet_in_frame =</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       beginning_of_partition &amp;&amp; (partition_id == 0);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.simulcastIdx = 0;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codec = kRtpVideoVp8;</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.nonReference =</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :       (*payload_data &amp; 0x20) ? true : false;  // N bit</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.partitionId = partition_id;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.beginningOfPartition =</span>
<span class="lineNum">     693 </span>            :       beginning_of_partition;
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.pictureId = kNoPictureId;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.tl0PicIdx = kNoTl0PicIdx;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.temporalIdx = kNoTemporalIdx;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.layerSync = false;</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;type.Video.codecHeader.VP8.keyIdx = kNoKeyIdx;</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   if (partition_id &gt; 8) {</span>
<span class="lineNum">     701 </span>            :     // Weak check for corrupt payload_data: PartID MUST NOT be larger than 8.
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     703 </span>            :   }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :   // Advance payload_data and decrease remaining payload size.
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   payload_data++;</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   if (payload_data_length &lt;= 1) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     LOG(LS_ERROR) &lt;&lt; &quot;Error parsing VP8 payload descriptor!&quot;;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     710 </span>            :   }
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :   payload_data_length--;</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   if (extension) {</span>
<span class="lineNum">     714 </span>            :     const int parsed_bytes =
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         ParseVP8Extension(&amp;parsed_payload-&gt;type.Video.codecHeader.VP8,</span>
<span class="lineNum">     716 </span>            :                           payload_data,
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                           payload_data_length);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     if (parsed_bytes &lt; 0)</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     payload_data += parsed_bytes;</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     payload_data_length -= parsed_bytes;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     if (payload_data_length == 0) {</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       LOG(LS_ERROR) &lt;&lt; &quot;Error parsing VP8 payload descriptor!&quot;;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     725 </span>            :     }
<span class="lineNum">     726 </span>            :   }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   // Read P bit from payload header (only at beginning of first partition).
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   if (beginning_of_partition &amp;&amp; partition_id == 0) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     parsed_payload-&gt;frame_type =</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :         (*payload_data &amp; 0x01) ? kVideoFrameDelta : kVideoFrameKey;</span>
<span class="lineNum">     732 </span>            :   } else {
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :     parsed_payload-&gt;frame_type = kVideoFrameDelta;</span>
<span class="lineNum">     734 </span>            :   }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   if (ParseVP8FrameSize(parsed_payload, payload_data, payload_data_length) !=</span>
<span class="lineNum">     737 </span>            :       0) {
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     739 </span>            :   }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;payload = payload_data;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   parsed_payload-&gt;payload_length = payload_data_length;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     744 </span>            : }
<span class="lineNum">     745 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

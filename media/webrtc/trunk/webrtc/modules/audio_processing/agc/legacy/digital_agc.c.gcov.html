<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/audio_processing/agc/legacy/digital_agc.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/audio_processing/agc/legacy</a> - digital_agc.c<span style="font-size: 80%;"> (source / <a href="digital_agc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">308</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2011 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : /* digital_agc.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;webrtc/modules/audio_processing/agc/legacy/digital_agc.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      18 </span>            : #ifdef WEBRTC_AGC_DEBUG_DUMP
<span class="lineNum">      19 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      20 </span>            : #endif
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;webrtc/base/checks.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;webrtc/modules/audio_processing/agc/legacy/gain_control.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : // To generate the gaintable, copy&amp;paste the following lines to a Matlab window:
<span class="lineNum">      26 </span>            : // MaxGain = 6; MinGain = 0; CompRatio = 3; Knee = 1;
<span class="lineNum">      27 </span>            : // zeros = 0:31; lvl = 2.^(1-zeros);
<span class="lineNum">      28 </span>            : // A = -10*log10(lvl) * (CompRatio - 1) / CompRatio;
<span class="lineNum">      29 </span>            : // B = MaxGain - MinGain;
<span class="lineNum">      30 </span>            : // gains = round(2^16*10.^(0.05 * (MinGain + B * (
<span class="lineNum">      31 </span>            : // log(exp(-Knee*A)+exp(-Knee*B)) - log(1+exp(-Knee*B)) ) /
<span class="lineNum">      32 </span>            : // log(1/(1+exp(Knee*B))))));
<span class="lineNum">      33 </span>            : // fprintf(1, '\t%i, %i, %i, %i,\n', gains);
<span class="lineNum">      34 </span>            : // % Matlab code for plotting the gain and input/output level characteristic
<span class="lineNum">      35 </span>            : // (copy/paste the following 3 lines):
<span class="lineNum">      36 </span>            : // in = 10*log10(lvl); out = 20*log10(gains/65536);
<span class="lineNum">      37 </span>            : // subplot(121); plot(in, out); axis([-30, 0, -5, 20]); grid on; xlabel('Input
<span class="lineNum">      38 </span>            : // (dB)'); ylabel('Gain (dB)');
<span class="lineNum">      39 </span>            : // subplot(122); plot(in, in+out); axis([-30, 0, -30, 5]); grid on;
<span class="lineNum">      40 </span>            : // xlabel('Input (dB)'); ylabel('Output (dB)');
<span class="lineNum">      41 </span>            : // zoom on;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : // Generator table for y=log2(1+e^x) in Q8.
<span class="lineNum">      44 </span>            : enum { kGenFuncTableSize = 128 };
<span class="lineNum">      45 </span>            : static const uint16_t kGenFuncTable[kGenFuncTableSize] = {
<span class="lineNum">      46 </span>            :     256,   485,   786,   1126,  1484,  1849,  2217,  2586,  2955,  3324,  3693,
<span class="lineNum">      47 </span>            :     4063,  4432,  4801,  5171,  5540,  5909,  6279,  6648,  7017,  7387,  7756,
<span class="lineNum">      48 </span>            :     8125,  8495,  8864,  9233,  9603,  9972,  10341, 10711, 11080, 11449, 11819,
<span class="lineNum">      49 </span>            :     12188, 12557, 12927, 13296, 13665, 14035, 14404, 14773, 15143, 15512, 15881,
<span class="lineNum">      50 </span>            :     16251, 16620, 16989, 17359, 17728, 18097, 18466, 18836, 19205, 19574, 19944,
<span class="lineNum">      51 </span>            :     20313, 20682, 21052, 21421, 21790, 22160, 22529, 22898, 23268, 23637, 24006,
<span class="lineNum">      52 </span>            :     24376, 24745, 25114, 25484, 25853, 26222, 26592, 26961, 27330, 27700, 28069,
<span class="lineNum">      53 </span>            :     28438, 28808, 29177, 29546, 29916, 30285, 30654, 31024, 31393, 31762, 32132,
<span class="lineNum">      54 </span>            :     32501, 32870, 33240, 33609, 33978, 34348, 34717, 35086, 35456, 35825, 36194,
<span class="lineNum">      55 </span>            :     36564, 36933, 37302, 37672, 38041, 38410, 38780, 39149, 39518, 39888, 40257,
<span class="lineNum">      56 </span>            :     40626, 40996, 41365, 41734, 42104, 42473, 42842, 43212, 43581, 43950, 44320,
<span class="lineNum">      57 </span>            :     44689, 45058, 45428, 45797, 46166, 46536, 46905};
<span class="lineNum">      58 </span>            : 
<a name="59"><span class="lineNum">      59 </span>            : static const int16_t kAvgDecayTime = 250;  // frames; &lt; 3000</a>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : int32_t WebRtcAgc_CalculateGainTable(int32_t* gainTable,       // Q16</span>
<span class="lineNum">      62 </span>            :                                      int16_t digCompGaindB,    // Q0
<span class="lineNum">      63 </span>            :                                      int16_t targetLevelDbfs,  // Q0
<span class="lineNum">      64 </span>            :                                      uint8_t limiterEnable,
<span class="lineNum">      65 </span>            :                                      int16_t analogTarget)  // Q0
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :   // This function generates the compressor gain table used in the fixed digital
<span class="lineNum">      68 </span>            :   // part.
<span class="lineNum">      69 </span>            :   uint32_t tmpU32no1, tmpU32no2, absInLevel, logApprox;
<span class="lineNum">      70 </span>            :   int32_t inLevel, limiterLvl;
<span class="lineNum">      71 </span>            :   int32_t tmp32, tmp32no1, tmp32no2, numFIX, den, y32;
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   const uint16_t kLog10 = 54426;    // log2(10)     in Q14</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :   const uint16_t kLog10_2 = 49321;  // 10*log10(2)  in Q14</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   const uint16_t kLogE_1 = 23637;   // log2(e)      in Q14</span>
<span class="lineNum">      75 </span>            :   uint16_t constMaxGain;
<span class="lineNum">      76 </span>            :   uint16_t tmpU16, intPart, fracPart;
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   const int16_t kCompRatio = 3;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   const int16_t kSoftLimiterLeft = 1;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   int16_t limiterOffset = 0;  // Limiter offset</span>
<span class="lineNum">      80 </span>            :   int16_t limiterIdx, limiterLvlX;
<span class="lineNum">      81 </span>            :   int16_t constLinApprox, zeroGainLvl, maxGain, diffGain;
<span class="lineNum">      82 </span>            :   int16_t i, tmp16, tmp16no1;
<span class="lineNum">      83 </span>            :   int zeros, zerosScale;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :   // Constants
<span class="lineNum">      86 </span>            :   //    kLogE_1 = 23637; // log2(e)      in Q14
<span class="lineNum">      87 </span>            :   //    kLog10 = 54426; // log2(10)     in Q14
<span class="lineNum">      88 </span>            :   //    kLog10_2 = 49321; // 10*log10(2)  in Q14
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :   // Calculate maximum digital gain and zero gain level
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   tmp32no1 = (digCompGaindB - analogTarget) * (kCompRatio - 1);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   tmp16no1 = analogTarget - targetLevelDbfs;</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   tmp16no1 +=</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :       WebRtcSpl_DivW32W16ResW16(tmp32no1 + (kCompRatio &gt;&gt; 1), kCompRatio);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   maxGain = WEBRTC_SPL_MAX(tmp16no1, (analogTarget - targetLevelDbfs));</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   tmp32no1 = maxGain * kCompRatio;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   zeroGainLvl = digCompGaindB;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   zeroGainLvl -= WebRtcSpl_DivW32W16ResW16(tmp32no1 + ((kCompRatio - 1) &gt;&gt; 1),</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                                            kCompRatio - 1);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   if ((digCompGaindB &lt;= analogTarget) &amp;&amp; (limiterEnable)) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     zeroGainLvl += (analogTarget - digCompGaindB + kSoftLimiterLeft);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     limiterOffset = 0;</span>
<span class="lineNum">     103 </span>            :   }
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   // Calculate the difference between maximum gain and gain at 0dB0v:
<span class="lineNum">     106 </span>            :   //  diffGain = maxGain + (compRatio-1)*zeroGainLvl/compRatio
<span class="lineNum">     107 </span>            :   //           = (compRatio-1)*digCompGaindB/compRatio
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   tmp32no1 = digCompGaindB * (kCompRatio - 1);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   diffGain =</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       WebRtcSpl_DivW32W16ResW16(tmp32no1 + (kCompRatio &gt;&gt; 1), kCompRatio);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   if (diffGain &lt; 0 || diffGain &gt;= kGenFuncTableSize) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     RTC_DCHECK(0);</span>
<span class="lineNum">     113 </span>            :     return -1;
<span class="lineNum">     114 </span>            :   }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   // Calculate the limiter level and index:
<span class="lineNum">     117 </span>            :   //  limiterLvlX = analogTarget - limiterOffset
<span class="lineNum">     118 </span>            :   //  limiterLvl  = targetLevelDbfs + limiterOffset/compRatio
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   limiterLvlX = analogTarget - limiterOffset;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   limiterIdx = 2 + WebRtcSpl_DivW32W16ResW16((int32_t)limiterLvlX * (1 &lt;&lt; 13),</span>
<span class="lineNum">     121 </span>            :                                              kLog10_2 / 2);
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   tmp16no1 =</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :       WebRtcSpl_DivW32W16ResW16(limiterOffset + (kCompRatio &gt;&gt; 1), kCompRatio);</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   limiterLvl = targetLevelDbfs + tmp16no1;</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   // Calculate (through table lookup):
<span class="lineNum">     127 </span>            :   //  constMaxGain = log2(1+2^(log2(e)*diffGain)); (in Q8)
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   constMaxGain = kGenFuncTable[diffGain];  // in Q8</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :   // Calculate a parameter used to approximate the fractional part of 2^x with a
<span class="lineNum">     131 </span>            :   // piecewise linear function in Q14:
<span class="lineNum">     132 </span>            :   //  constLinApprox = round(3/2*(4*(3-2*sqrt(2))/(log(2)^2)-0.5)*2^14);
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   constLinApprox = 22817;  // in Q14</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :   // Calculate a denominator used in the exponential part to convert from dB to
<span class="lineNum">     136 </span>            :   // linear scale:
<span class="lineNum">     137 </span>            :   //  den = 20*constMaxGain (in Q8)
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   den = WEBRTC_SPL_MUL_16_U16(20, constMaxGain);  // in Q8</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 32; i++) {</span>
<span class="lineNum">     141 </span>            :     // Calculate scaled input level (compressor):
<span class="lineNum">     142 </span>            :     //  inLevel =
<span class="lineNum">     143 </span>            :     //  fix((-constLog10_2*(compRatio-1)*(1-i)+fix(compRatio/2))/compRatio)
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     tmp16 = (int16_t)((kCompRatio - 1) * (i - 1));       // Q0</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     tmp32 = WEBRTC_SPL_MUL_16_U16(tmp16, kLog10_2) + 1;  // Q14</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     inLevel = WebRtcSpl_DivW32W16(tmp32, kCompRatio);    // Q14</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     // Calculate diffGain-inLevel, to map using the genFuncTable
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     inLevel = (int32_t)diffGain * (1 &lt;&lt; 14) - inLevel;  // Q14</span>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :     // Make calculations on abs(inLevel) and compensate for the sign afterwards.
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     absInLevel = (uint32_t)WEBRTC_SPL_ABS_W32(inLevel);  // Q14</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :     // LUT with interpolation
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     intPart = (uint16_t)(absInLevel &gt;&gt; 14);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     fracPart =</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         (uint16_t)(absInLevel &amp; 0x00003FFF);  // extract the fractional part</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     tmpU16 = kGenFuncTable[intPart + 1] - kGenFuncTable[intPart];  // Q8</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     tmpU32no1 = tmpU16 * fracPart;                                 // Q22</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     tmpU32no1 += (uint32_t)kGenFuncTable[intPart] &lt;&lt; 14;           // Q22</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     logApprox = tmpU32no1 &gt;&gt; 8;                                    // Q14</span>
<span class="lineNum">     162 </span>            :     // Compensate for negative exponent using the relation:
<span class="lineNum">     163 </span>            :     //  log2(1 + 2^-x) = log2(1 + 2^x) - x
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     if (inLevel &lt; 0) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       zeros = WebRtcSpl_NormU32(absInLevel);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       zerosScale = 0;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       if (zeros &lt; 15) {</span>
<span class="lineNum">     168 </span>            :         // Not enough space for multiplication
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         tmpU32no2 = absInLevel &gt;&gt; (15 - zeros);                 // Q(zeros-1)</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         tmpU32no2 = WEBRTC_SPL_UMUL_32_16(tmpU32no2, kLogE_1);  // Q(zeros+13)</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :         if (zeros &lt; 9) {</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :           zerosScale = 9 - zeros;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :           tmpU32no1 &gt;&gt;= zerosScale;  // Q(zeros+13)</span>
<span class="lineNum">     174 </span>            :         } else {
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :           tmpU32no2 &gt;&gt;= zeros - 9;  // Q22</span>
<span class="lineNum">     176 </span>            :         }
<span class="lineNum">     177 </span>            :       } else {
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         tmpU32no2 = WEBRTC_SPL_UMUL_32_16(absInLevel, kLogE_1);  // Q28</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         tmpU32no2 &gt;&gt;= 6;                                         // Q22</span>
<span class="lineNum">     180 </span>            :       }
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       logApprox = 0;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       if (tmpU32no2 &lt; tmpU32no1) {</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         logApprox = (tmpU32no1 - tmpU32no2) &gt;&gt; (8 - zerosScale);  // Q14</span>
<span class="lineNum">     184 </span>            :       }
<span class="lineNum">     185 </span>            :     }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     numFIX = (maxGain * constMaxGain) * (1 &lt;&lt; 6);  // Q14</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     numFIX -= (int32_t)logApprox * diffGain;       // Q14</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :     // Calculate ratio
<span class="lineNum">     190 </span>            :     // Shift |numFIX| as much as possible.
<span class="lineNum">     191 </span>            :     // Ensure we avoid wrap-around in |den| as well.
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     if (numFIX &gt; (den &gt;&gt; 8) || -numFIX &gt; (den &gt;&gt; 8))  // |den| is Q8.</span>
<span class="lineNum">     193 </span>            :     {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       zeros = WebRtcSpl_NormW32(numFIX);</span>
<span class="lineNum">     195 </span>            :     } else {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       zeros = WebRtcSpl_NormW32(den) + 8;</span>
<span class="lineNum">     197 </span>            :     }
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     numFIX *= 1 &lt;&lt; zeros;  // Q(14+zeros)</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :     // Shift den so we end up in Qy1
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     tmp32no1 = WEBRTC_SPL_SHIFT_W32(den, zeros - 9);  // Q(zeros - 1)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     y32 = numFIX / tmp32no1;  // in Q15</span>
<span class="lineNum">     203 </span>            :     // This is to do rounding in Q14.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     y32 = y32 &gt;= 0 ? (y32 + 1) &gt;&gt; 1 : -((-y32 + 1) &gt;&gt; 1);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     if (limiterEnable &amp;&amp; (i &lt; limiterIdx)) {</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :       tmp32 = WEBRTC_SPL_MUL_16_U16(i - 1, kLog10_2);  // Q14</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :       tmp32 -= limiterLvl * (1 &lt;&lt; 14);                 // Q14</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       y32 = WebRtcSpl_DivW32W16(tmp32 + 10, 20);</span>
<span class="lineNum">     210 </span>            :     }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (y32 &gt; 39000) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       tmp32 = (y32 &gt;&gt; 1) * kLog10 + 4096;  // in Q27</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       tmp32 &gt;&gt;= 13;                        // In Q14.</span>
<span class="lineNum">     214 </span>            :     } else {
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :       tmp32 = y32 * kLog10 + 8192;  // in Q28</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :       tmp32 &gt;&gt;= 14;                 // In Q14.</span>
<span class="lineNum">     217 </span>            :     }
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     tmp32 += 16 &lt;&lt; 14;  // in Q14 (Make sure final output is in Q16)</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     // Calculate power
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (tmp32 &gt; 0) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       intPart = (int16_t)(tmp32 &gt;&gt; 14);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       fracPart = (uint16_t)(tmp32 &amp; 0x00003FFF);  // in Q14</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       if ((fracPart &gt;&gt; 13) != 0) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         tmp16 = (2 &lt;&lt; 14) - constLinApprox;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         tmp32no2 = (1 &lt;&lt; 14) - fracPart;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         tmp32no2 *= tmp16;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         tmp32no2 &gt;&gt;= 13;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :         tmp32no2 = (1 &lt;&lt; 14) - tmp32no2;</span>
<span class="lineNum">     230 </span>            :       } else {
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         tmp16 = constLinApprox - (1 &lt;&lt; 14);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         tmp32no2 = (fracPart * tmp16) &gt;&gt; 13;</span>
<span class="lineNum">     233 </span>            :       }
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :       fracPart = (uint16_t)tmp32no2;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       gainTable[i] =</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :           (1 &lt;&lt; intPart) + WEBRTC_SPL_SHIFT_W32(fracPart, intPart - 14);</span>
<span class="lineNum">     237 </span>            :     } else {
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       gainTable[i] = 0;</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            :   }
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="243"><span class="lineNum">     243 </span>            : }</a>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 : int32_t WebRtcAgc_InitDigital(DigitalAgc* stt, int16_t agcMode) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   if (agcMode == kAgcModeFixedDigital) {</span>
<span class="lineNum">     247 </span>            :     // start at minimum to find correct gain faster
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     stt-&gt;capacitorSlow = 0;</span>
<span class="lineNum">     249 </span>            :   } else {
<span class="lineNum">     250 </span>            :     // start out with 0 dB gain
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     stt-&gt;capacitorSlow = 134217728;  // (int32_t)(0.125f * 32768.0f * 32768.0f);</span>
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   stt-&gt;capacitorFast = 0;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :   stt-&gt;gain = 65536;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   stt-&gt;gatePrevious = 0;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   stt-&gt;agcMode = agcMode;</span>
<span class="lineNum">     257 </span>            : #ifdef WEBRTC_AGC_DEBUG_DUMP
<span class="lineNum">     258 </span>            :   stt-&gt;frameCounter = 0;
<span class="lineNum">     259 </span>            : #endif
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   // initialize VADs
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   WebRtcAgc_InitVad(&amp;stt-&gt;vadNearend);</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   WebRtcAgc_InitVad(&amp;stt-&gt;vadFarend);</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="266"><span class="lineNum">     266 </span>            : }</a>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 : int32_t WebRtcAgc_AddFarendToDigital(DigitalAgc* stt,</span>
<span class="lineNum">     269 </span>            :                                      const int16_t* in_far,
<span class="lineNum">     270 </span>            :                                      size_t nrSamples) {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   RTC_DCHECK(stt);</span>
<span class="lineNum">     272 </span>            :   // VAD for far end
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   WebRtcAgc_ProcessVad(&amp;stt-&gt;vadFarend, in_far, nrSamples);</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="276"><span class="lineNum">     276 </span>            : }</a>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineNoCov">          0 : int32_t WebRtcAgc_ProcessDigital(DigitalAgc* stt,</span>
<span class="lineNum">     279 </span>            :                                  const int16_t* const* in_near,
<span class="lineNum">     280 </span>            :                                  size_t num_bands,
<span class="lineNum">     281 </span>            :                                  int16_t* const* out,
<span class="lineNum">     282 </span>            :                                  uint32_t FS,
<span class="lineNum">     283 </span>            :                                  int16_t lowlevelSignal) {
<span class="lineNum">     284 </span>            :   // array for gains (one value per ms, incl start &amp; end)
<span class="lineNum">     285 </span>            :   int32_t gains[11];
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   int32_t out_tmp, tmp32;
<span class="lineNum">     288 </span>            :   int32_t env[10];
<span class="lineNum">     289 </span>            :   int32_t max_nrg;
<span class="lineNum">     290 </span>            :   int32_t cur_level;
<span class="lineNum">     291 </span>            :   int32_t gain32, delta;
<span class="lineNum">     292 </span>            :   int16_t logratio;
<span class="lineNum">     293 </span>            :   int16_t lower_thr, upper_thr;
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   int16_t zeros = 0, zeros_fast, frac = 0;</span>
<span class="lineNum">     295 </span>            :   int16_t decay;
<span class="lineNum">     296 </span>            :   int16_t gate, gain_adj;
<span class="lineNum">     297 </span>            :   int16_t k;
<span class="lineNum">     298 </span>            :   size_t n, i, L;
<span class="lineNum">     299 </span>            :   int16_t L2;  // samples/subframe
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   // determine number of samples per ms
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (FS == 8000) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     L = 8;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     L2 = 3;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   } else if (FS == 16000 || FS == 32000 || FS == 48000) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     L = 16;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     L2 = 4;</span>
<span class="lineNum">     308 </span>            :   } else {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     310 </span>            :   }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; num_bands; ++i) {</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     if (in_near[i] != out[i]) {</span>
<span class="lineNum">     314 </span>            :       // Only needed if they don't already point to the same place.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       memcpy(out[i], in_near[i], 10 * L * sizeof(in_near[i][0]));</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            :   // VAD for near end
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   logratio = WebRtcAgc_ProcessVad(&amp;stt-&gt;vadNearend, out[0], L * 10);</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   // Account for far end VAD
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   if (stt-&gt;vadFarend.counter &gt; 10) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     tmp32 = 3 * logratio;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     logratio = (int16_t)((tmp32 - stt-&gt;vadFarend.logRatio) &gt;&gt; 2);</span>
<span class="lineNum">     325 </span>            :   }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   // Determine decay factor depending on VAD
<span class="lineNum">     328 </span>            :   //  upper_thr = 1.0f;
<span class="lineNum">     329 </span>            :   //  lower_thr = 0.25f;
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   upper_thr = 1024;  // Q10</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   lower_thr = 0;     // Q10</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   if (logratio &gt; upper_thr) {</span>
<span class="lineNum">     333 </span>            :     // decay = -2^17 / DecayTime;  -&gt;  -65
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     decay = -65;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   } else if (logratio &lt; lower_thr) {</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     decay = 0;</span>
<span class="lineNum">     337 </span>            :   } else {
<span class="lineNum">     338 </span>            :     // decay = (int16_t)(((lower_thr - logratio)
<span class="lineNum">     339 </span>            :     //       * (2^27/(DecayTime*(upper_thr-lower_thr)))) &gt;&gt; 10);
<span class="lineNum">     340 </span>            :     // SUBSTITUTED: 2^27/(DecayTime*(upper_thr-lower_thr))  -&gt;  65
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     tmp32 = (lower_thr - logratio) * 65;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     decay = (int16_t)(tmp32 &gt;&gt; 10);</span>
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   // adjust decay factor for long silence (detected as low standard deviation)
<span class="lineNum">     346 </span>            :   // This is only done in the adaptive modes
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   if (stt-&gt;agcMode != kAgcModeFixedDigital) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     if (stt-&gt;vadNearend.stdLongTerm &lt; 4000) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       decay = 0;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     } else if (stt-&gt;vadNearend.stdLongTerm &lt; 8096) {</span>
<span class="lineNum">     351 </span>            :       // decay = (int16_t)(((stt-&gt;vadNearend.stdLongTerm - 4000) * decay) &gt;&gt;
<span class="lineNum">     352 </span>            :       // 12);
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       tmp32 = (stt-&gt;vadNearend.stdLongTerm - 4000) * decay;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       decay = (int16_t)(tmp32 &gt;&gt; 12);</span>
<span class="lineNum">     355 </span>            :     }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     if (lowlevelSignal != 0) {</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :       decay = 0;</span>
<span class="lineNum">     359 </span>            :     }
<span class="lineNum">     360 </span>            :   }
<span class="lineNum">     361 </span>            : #ifdef WEBRTC_AGC_DEBUG_DUMP
<span class="lineNum">     362 </span>            :   stt-&gt;frameCounter++;
<span class="lineNum">     363 </span>            :   fprintf(stt-&gt;logFile, &quot;%5.2f\t%d\t%d\t%d\t&quot;, (float)(stt-&gt;frameCounter) / 100,
<span class="lineNum">     364 </span>            :           logratio, decay, stt-&gt;vadNearend.stdLongTerm);
<span class="lineNum">     365 </span>            : #endif
<span class="lineNum">     366 </span>            :   // Find max amplitude per sub frame
<span class="lineNum">     367 </span>            :   // iterate over sub frames
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 10; k++) {</span>
<span class="lineNum">     369 </span>            :     // iterate over samples
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     max_nrg = 0;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; L; n++) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       int32_t nrg = out[0][k * L + n] * out[0][k * L + n];</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :       if (nrg &gt; max_nrg) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         max_nrg = nrg;</span>
<span class="lineNum">     375 </span>            :       }
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     env[k] = max_nrg;</span>
<span class="lineNum">     378 </span>            :   }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :   // Calculate gain per sub frame
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   gains[0] = stt-&gt;gain;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 10; k++) {</span>
<span class="lineNum">     383 </span>            :     // Fast envelope follower
<span class="lineNum">     384 </span>            :     //  decay time = -131000 / -1000 = 131 (ms)
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     stt-&gt;capacitorFast =</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         AGC_SCALEDIFF32(-1000, stt-&gt;capacitorFast, stt-&gt;capacitorFast);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     if (env[k] &gt; stt-&gt;capacitorFast) {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       stt-&gt;capacitorFast = env[k];</span>
<span class="lineNum">     389 </span>            :     }
<span class="lineNum">     390 </span>            :     // Slow envelope follower
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     if (env[k] &gt; stt-&gt;capacitorSlow) {</span>
<span class="lineNum">     392 </span>            :       // increase capacitorSlow
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       stt-&gt;capacitorSlow = AGC_SCALEDIFF32(500, (env[k] - stt-&gt;capacitorSlow),</span>
<span class="lineNum">     394 </span>            :                                            stt-&gt;capacitorSlow);
<span class="lineNum">     395 </span>            :     } else {
<span class="lineNum">     396 </span>            :       // decrease capacitorSlow
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :       stt-&gt;capacitorSlow =</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :           AGC_SCALEDIFF32(decay, stt-&gt;capacitorSlow, stt-&gt;capacitorSlow);</span>
<span class="lineNum">     399 </span>            :     }
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :     // use maximum of both capacitors as current level
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (stt-&gt;capacitorFast &gt; stt-&gt;capacitorSlow) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :       cur_level = stt-&gt;capacitorFast;</span>
<span class="lineNum">     404 </span>            :     } else {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :       cur_level = stt-&gt;capacitorSlow;</span>
<span class="lineNum">     406 </span>            :     }
<span class="lineNum">     407 </span>            :     // Translate signal level into gain, using a piecewise linear approximation
<span class="lineNum">     408 </span>            :     // find number of leading zeros
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     zeros = WebRtcSpl_NormU32((uint32_t)cur_level);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :     if (cur_level == 0) {</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :       zeros = 31;</span>
<span class="lineNum">     412 </span>            :     }
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     tmp32 = (cur_level &lt;&lt; zeros) &amp; 0x7FFFFFFF;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     frac = (int16_t)(tmp32 &gt;&gt; 19);  // Q12.</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     tmp32 = (stt-&gt;gainTable[zeros - 1] - stt-&gt;gainTable[zeros]) * frac;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     gains[k + 1] = stt-&gt;gainTable[zeros] + (tmp32 &gt;&gt; 12);</span>
<span class="lineNum">     417 </span>            : #ifdef WEBRTC_AGC_DEBUG_DUMP
<span class="lineNum">     418 </span>            :     if (k == 0) {
<span class="lineNum">     419 </span>            :       fprintf(stt-&gt;logFile, &quot;%d\t%d\t%d\t%d\t%d\n&quot;, env[0], cur_level,
<span class="lineNum">     420 </span>            :               stt-&gt;capacitorFast, stt-&gt;capacitorSlow, zeros);
<span class="lineNum">     421 </span>            :     }
<span class="lineNum">     422 </span>            : #endif
<span class="lineNum">     423 </span>            :   }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   // Gate processing (lower gain during absence of speech)
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   zeros = (zeros &lt;&lt; 9) - (frac &gt;&gt; 3);</span>
<span class="lineNum">     427 </span>            :   // find number of leading zeros
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   zeros_fast = WebRtcSpl_NormU32((uint32_t)stt-&gt;capacitorFast);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   if (stt-&gt;capacitorFast == 0) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     zeros_fast = 31;</span>
<span class="lineNum">     431 </span>            :   }
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   tmp32 = (stt-&gt;capacitorFast &lt;&lt; zeros_fast) &amp; 0x7FFFFFFF;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   zeros_fast &lt;&lt;= 9;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   zeros_fast -= (int16_t)(tmp32 &gt;&gt; 22);</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   gate = 1000 + zeros_fast - zeros - stt-&gt;vadNearend.stdShortTerm;</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (gate &lt; 0) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     stt-&gt;gatePrevious = 0;</span>
<span class="lineNum">     440 </span>            :   } else {
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     tmp32 = stt-&gt;gatePrevious * 7;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     gate = (int16_t)((gate + tmp32) &gt;&gt; 3);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     stt-&gt;gatePrevious = gate;</span>
<span class="lineNum">     444 </span>            :   }
<span class="lineNum">     445 </span>            :   // gate &lt; 0     -&gt; no gate
<span class="lineNum">     446 </span>            :   // gate &gt; 2500  -&gt; max gate
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   if (gate &gt; 0) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     if (gate &lt; 2500) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       gain_adj = (2500 - gate) &gt;&gt; 5;</span>
<span class="lineNum">     450 </span>            :     } else {
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       gain_adj = 0;</span>
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; 10; k++) {</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :       if ((gains[k + 1] - stt-&gt;gainTable[0]) &gt; 8388608) {</span>
<span class="lineNum">     455 </span>            :         // To prevent wraparound
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         tmp32 = (gains[k + 1] - stt-&gt;gainTable[0]) &gt;&gt; 8;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         tmp32 *= 178 + gain_adj;</span>
<span class="lineNum">     458 </span>            :       } else {
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         tmp32 = (gains[k + 1] - stt-&gt;gainTable[0]) * (178 + gain_adj);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         tmp32 &gt;&gt;= 8;</span>
<span class="lineNum">     461 </span>            :       }
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       gains[k + 1] = stt-&gt;gainTable[0] + tmp32;</span>
<span class="lineNum">     463 </span>            :     }
<span class="lineNum">     464 </span>            :   }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   // Limit gain to avoid overload distortion
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 10; k++) {</span>
<span class="lineNum">     468 </span>            :     // To prevent wrap around
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     zeros = 10;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     if (gains[k + 1] &gt; 47453132) {</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       zeros = 16 - WebRtcSpl_NormW32(gains[k + 1]);</span>
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     gain32 = (gains[k + 1] &gt;&gt; zeros) + 1;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     gain32 *= gain32;</span>
<span class="lineNum">     475 </span>            :     // check for overflow
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     while (AGC_MUL32((env[k] &gt;&gt; 12) + 1, gain32) &gt;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :            WEBRTC_SPL_SHIFT_W32((int32_t)32767, 2 * (1 - zeros + 10))) {</span>
<span class="lineNum">     478 </span>            :       // multiply by 253/256 ==&gt; -0.1 dB
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       if (gains[k + 1] &gt; 8388607) {</span>
<span class="lineNum">     480 </span>            :         // Prevent wrap around
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         gains[k + 1] = (gains[k + 1] / 256) * 253;</span>
<span class="lineNum">     482 </span>            :       } else {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         gains[k + 1] = (gains[k + 1] * 253) / 256;</span>
<span class="lineNum">     484 </span>            :       }
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       gain32 = (gains[k + 1] &gt;&gt; zeros) + 1;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       gain32 *= gain32;</span>
<span class="lineNum">     487 </span>            :     }
<span class="lineNum">     488 </span>            :   }
<span class="lineNum">     489 </span>            :   // gain reductions should be done 1 ms earlier than gain increases
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt; 10; k++) {</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     if (gains[k] &gt; gains[k + 1]) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       gains[k] = gains[k + 1];</span>
<span class="lineNum">     493 </span>            :     }
<span class="lineNum">     494 </span>            :   }
<span class="lineNum">     495 </span>            :   // save start gain for next frame
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   stt-&gt;gain = gains[10];</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   // Apply gain
<span class="lineNum">     499 </span>            :   // handle first sub frame separately
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   delta = (gains[1] - gains[0]) * (1 &lt;&lt; (4 - L2));</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   gain32 = gains[0] * (1 &lt;&lt; 4);</span>
<span class="lineNum">     502 </span>            :   // iterate over samples
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   for (n = 0; n &lt; L; n++) {</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; num_bands; ++i) {</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :       tmp32 = out[i][n] * ((gain32 + 127) &gt;&gt; 7);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :       out_tmp = tmp32 &gt;&gt; 16;</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :       if (out_tmp &gt; 4095) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         out[i][n] = (int16_t)32767;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       } else if (out_tmp &lt; -4096) {</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         out[i][n] = (int16_t)-32768;</span>
<span class="lineNum">     511 </span>            :       } else {
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         tmp32 = out[i][n] * (gain32 &gt;&gt; 4);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         out[i][n] = (int16_t)(tmp32 &gt;&gt; 16);</span>
<span class="lineNum">     514 </span>            :       }
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            :     //
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     gain32 += delta;</span>
<span class="lineNum">     519 </span>            :   }
<span class="lineNum">     520 </span>            :   // iterate over subframes
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt; 10; k++) {</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     delta = (gains[k + 1] - gains[k]) * (1 &lt;&lt; (4 - L2));</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     gain32 = gains[k] * (1 &lt;&lt; 4);</span>
<span class="lineNum">     524 </span>            :     // iterate over samples
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; L; n++) {</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; num_bands; ++i) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         tmp32 = out[i][k * L + n] * (gain32 &gt;&gt; 4);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         out[i][k * L + n] = (int16_t)(tmp32 &gt;&gt; 16);</span>
<span class="lineNum">     529 </span>            :       }
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       gain32 += delta;</span>
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            :   }
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="535"><span class="lineNum">     535 </span>            : }</a>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : void WebRtcAgc_InitVad(AgcVad* state) {</span>
<span class="lineNum">     538 </span>            :   int16_t k;
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   state-&gt;HPstate = 0;   // state of high pass filter</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   state-&gt;logRatio = 0;  // log( P(active) / P(inactive) )</span>
<span class="lineNum">     542 </span>            :   // average input level (Q10)
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   state-&gt;meanLongTerm = 15 &lt;&lt; 10;</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   // variance of input level (Q8)
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   state-&gt;varianceLongTerm = 500 &lt;&lt; 8;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   state-&gt;stdLongTerm = 0;  // standard deviation of input level in dB</span>
<span class="lineNum">     549 </span>            :   // short-term average input level (Q10)
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   state-&gt;meanShortTerm = 15 &lt;&lt; 10;</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :   // short-term variance of input level (Q8)
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   state-&gt;varianceShortTerm = 500 &lt;&lt; 8;</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   state-&gt;stdShortTerm =</span>
<span class="lineNum">     556 </span>            :       0;               // short-term standard deviation of input level in dB
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   state-&gt;counter = 3;  // counts updates</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 8; k++) {</span>
<span class="lineNum">     559 </span>            :     // downsampling filter
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     state-&gt;downState[k] = 0;</span>
<span class="lineNum">     561 </span>            :   }
<a name="562"><span class="lineNum">     562 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineNoCov">          0 : int16_t WebRtcAgc_ProcessVad(AgcVad* state,      // (i) VAD state</span>
<span class="lineNum">     565 </span>            :                              const int16_t* in,  // (i) Speech signal
<span class="lineNum">     566 </span>            :                              size_t nrSamples)   // (i) number of samples
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span>            :   int32_t out, nrg, tmp32, tmp32b;
<span class="lineNum">     569 </span>            :   uint16_t tmpU16;
<span class="lineNum">     570 </span>            :   int16_t k, subfr, tmp16;
<span class="lineNum">     571 </span>            :   int16_t buf1[8];
<span class="lineNum">     572 </span>            :   int16_t buf2[4];
<span class="lineNum">     573 </span>            :   int16_t HPstate;
<span class="lineNum">     574 </span>            :   int16_t zeros, dB;
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :   // process in 10 sub frames of 1 ms (to save on memory)
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   nrg = 0;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   HPstate = state-&gt;HPstate;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   for (subfr = 0; subfr &lt; 10; subfr++) {</span>
<span class="lineNum">     580 </span>            :     // downsample to 4 kHz
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     if (nrSamples == 160) {</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; 8; k++) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         tmp32 = (int32_t)in[2 * k] + (int32_t)in[2 * k + 1];</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         tmp32 &gt;&gt;= 1;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :         buf1[k] = (int16_t)tmp32;</span>
<span class="lineNum">     586 </span>            :       }
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       in += 16;</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       WebRtcSpl_DownsampleBy2(buf1, 8, buf2, state-&gt;downState);</span>
<span class="lineNum">     590 </span>            :     } else {
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       WebRtcSpl_DownsampleBy2(in, 8, buf2, state-&gt;downState);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       in += 8;</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :     // high pass filter and compute energy
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; 4; k++) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       out = buf2[k] + HPstate;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       tmp32 = 600 * out;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       HPstate = (int16_t)((tmp32 &gt;&gt; 10) - buf2[k]);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       nrg += (out * out) &gt;&gt; 6;</span>
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            :   }
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   state-&gt;HPstate = HPstate;</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   // find number of leading zeros
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   if (!(0xFFFF0000 &amp; nrg)) {</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     zeros = 16;</span>
<span class="lineNum">     608 </span>            :   } else {
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     zeros = 0;</span>
<span class="lineNum">     610 </span>            :   }
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :   if (!(0xFF000000 &amp; (nrg &lt;&lt; zeros))) {</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     zeros += 8;</span>
<span class="lineNum">     613 </span>            :   }
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   if (!(0xF0000000 &amp; (nrg &lt;&lt; zeros))) {</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     zeros += 4;</span>
<span class="lineNum">     616 </span>            :   }
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   if (!(0xC0000000 &amp; (nrg &lt;&lt; zeros))) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     zeros += 2;</span>
<span class="lineNum">     619 </span>            :   }
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if (!(0x80000000 &amp; (nrg &lt;&lt; zeros))) {</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     zeros += 1;</span>
<span class="lineNum">     622 </span>            :   }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :   // energy level (range {-32..30}) (Q10)
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   dB = (15 - zeros) &lt;&lt; 11;</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :   // Update statistics
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :   if (state-&gt;counter &lt; kAvgDecayTime) {</span>
<span class="lineNum">     630 </span>            :     // decay time = AvgDecTime * 10 ms
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     state-&gt;counter++;</span>
<span class="lineNum">     632 </span>            :   }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   // update short-term estimate of mean energy level (Q10)
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   tmp32 = state-&gt;meanShortTerm * 15 + dB;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   state-&gt;meanShortTerm = (int16_t)(tmp32 &gt;&gt; 4);</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :   // update short-term estimate of variance in energy level (Q8)
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   tmp32 = (dB * dB) &gt;&gt; 12;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   tmp32 += state-&gt;varianceShortTerm * 15;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   state-&gt;varianceShortTerm = tmp32 / 16;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   // update short-term estimate of standard deviation in energy level (Q10)
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   tmp32 = state-&gt;meanShortTerm * state-&gt;meanShortTerm;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   tmp32 = (state-&gt;varianceShortTerm &lt;&lt; 12) - tmp32;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   state-&gt;stdShortTerm = (int16_t)WebRtcSpl_Sqrt(tmp32);</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :   // update long-term estimate of mean energy level (Q10)
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   tmp32 = state-&gt;meanLongTerm * state-&gt;counter + dB;</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :   state-&gt;meanLongTerm =</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       WebRtcSpl_DivW32W16ResW16(tmp32, WebRtcSpl_AddSatW16(state-&gt;counter, 1));</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :   // update long-term estimate of variance in energy level (Q8)
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   tmp32 = (dB * dB) &gt;&gt; 12;</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   tmp32 += state-&gt;varianceLongTerm * state-&gt;counter;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   state-&gt;varianceLongTerm =</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :       WebRtcSpl_DivW32W16(tmp32, WebRtcSpl_AddSatW16(state-&gt;counter, 1));</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   // update long-term estimate of standard deviation in energy level (Q10)
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   tmp32 = state-&gt;meanLongTerm * state-&gt;meanLongTerm;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   tmp32 = (state-&gt;varianceLongTerm &lt;&lt; 12) - tmp32;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   state-&gt;stdLongTerm = (int16_t)WebRtcSpl_Sqrt(tmp32);</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :   // update voice activity measure (Q10)
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   tmp16 = 3 &lt;&lt; 12;</span>
<span class="lineNum">     666 </span>            :   // TODO(bjornv): (dB - state-&gt;meanLongTerm) can overflow, e.g., in
<span class="lineNum">     667 </span>            :   // ApmTest.Process unit test. Previously the macro WEBRTC_SPL_MUL_16_16()
<span class="lineNum">     668 </span>            :   // was used, which did an intermediate cast to (int16_t), hence losing
<span class="lineNum">     669 </span>            :   // significant bits. This cause logRatio to max out positive, rather than
<span class="lineNum">     670 </span>            :   // negative. This is a bug, but has very little significance.
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :   tmp32 = tmp16 * (int16_t)(dB - state-&gt;meanLongTerm);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   tmp32 = WebRtcSpl_DivW32W16(tmp32, state-&gt;stdLongTerm);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   tmpU16 = (13 &lt;&lt; 12);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   tmp32b = WEBRTC_SPL_MUL_16_U16(state-&gt;logRatio, tmpU16);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   tmp32 += tmp32b &gt;&gt; 10;</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   state-&gt;logRatio = (int16_t)(tmp32 &gt;&gt; 6);</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :   // limit
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :   if (state-&gt;logRatio &gt; 2048) {</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     state-&gt;logRatio = 2048;</span>
<span class="lineNum">     682 </span>            :   }
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   if (state-&gt;logRatio &lt; -2048) {</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     state-&gt;logRatio = -2048;</span>
<span class="lineNum">     685 </span>            :   }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   return state-&gt;logRatio;  // Q10</span>
<span class="lineNum">     688 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

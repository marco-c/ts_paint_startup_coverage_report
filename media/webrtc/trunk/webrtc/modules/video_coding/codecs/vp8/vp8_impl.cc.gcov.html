<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/video_coding/codecs/vp8/vp8_impl.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/video_coding/codecs/vp8</a> - vp8_impl.cc<span style="font-size: 80%;"> (source / <a href="vp8_impl.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">697</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;webrtc/modules/video_coding/codecs/vp8/vp8_impl.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      15 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : // NOTE(ajm): Path provided by gyp.
<span class="lineNum">      19 </span>            : #include &quot;libyuv/scale.h&quot;    // NOLINT
<span class="lineNum">      20 </span>            : #include &quot;libyuv/convert.h&quot;  // NOLINT
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;webrtc/base/checks.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;webrtc/base/timeutils.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;webrtc/base/trace_event.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;webrtc/common_types.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;webrtc/common_video/libyuv/include/webrtc_libyuv.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;webrtc/modules/include/module_common_types.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;webrtc/modules/video_coding/include/video_codec_interface.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;webrtc/modules/video_coding/codecs/vp8/include/vp8_common_types.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;webrtc/modules/video_coding/codecs/vp8/screenshare_layers.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;webrtc/modules/video_coding/codecs/vp8/temporal_layers.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;webrtc/modules/video_coding/utility/simulcast_rate_allocator.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;webrtc/system_wrappers/include/clock.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;webrtc/system_wrappers/include/metrics.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : namespace webrtc {
<span class="lineNum">      37 </span>            : namespace {
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : enum { kVp8ErrorPropagationTh = 30 };
<span class="lineNum">      40 </span>            : enum { kVp832ByteAlign = 32 };
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : // VP8 denoiser states.
<span class="lineNum">      43 </span>            : enum denoiserState {
<span class="lineNum">      44 </span>            :   kDenoiserOff,
<span class="lineNum">      45 </span>            :   kDenoiserOnYOnly,
<span class="lineNum">      46 </span>            :   kDenoiserOnYUV,
<span class="lineNum">      47 </span>            :   kDenoiserOnYUVAggressive,
<span class="lineNum">      48 </span>            :   // Adaptive mode defaults to kDenoiserOnYUV on key frame, but may switch
<span class="lineNum">      49 </span>            :   // to kDenoiserOnYUVAggressive based on a computed noise metric.
<span class="lineNum">      50 </span>            :   kDenoiserOnAdaptive
<span class="lineNum">      51 </span>            : };
<a name="52"><span class="lineNum">      52 </span>            : </a>
<span class="lineNum">      53 </span>            : // Greatest common divisior
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : int GCD(int a, int b) {</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   int c = a % b;</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   while (c != 0) {</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     a = b;</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     b = c;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :     c = a % b;</span>
<span class="lineNum">      60 </span>            :   }
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   return b;</span>
<a name="62"><span class="lineNum">      62 </span>            : }</a>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span><span class="lineNoCov">          0 : uint32_t SumStreamMaxBitrate(int streams, const VideoCodec&amp; codec) {</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   uint32_t bitrate_sum = 0;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; streams; ++i) {</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     bitrate_sum += codec.simulcastStream[i].maxBitrate;</span>
<span class="lineNum">      68 </span>            :   }
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   return bitrate_sum;</span>
<a name="70"><span class="lineNum">      70 </span>            : }</a>
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span><span class="lineNoCov">          0 : int NumberOfStreams(const VideoCodec&amp; codec) {</span>
<span class="lineNum">      73 </span>            :   int streams =
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :       codec.numberOfSimulcastStreams &lt; 1 ? 1 : codec.numberOfSimulcastStreams;</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   uint32_t simulcast_max_bitrate = SumStreamMaxBitrate(streams, codec);</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   if (simulcast_max_bitrate == 0) {</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     streams = 1;</span>
<span class="lineNum">      78 </span>            :   }
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   return streams;</span>
<a name="80"><span class="lineNum">      80 </span>            : }</a>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : bool ValidSimulcastResolutions(const VideoCodec&amp; codec, int num_streams) {</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   if (codec.width != codec.simulcastStream[num_streams - 1].width ||</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :       codec.height != codec.simulcastStream[num_streams - 1].height) {</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">      86 </span>            :   }
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; num_streams; ++i) {</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     if (codec.width * codec.simulcastStream[i].height !=</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         codec.height * codec.simulcastStream[i].width) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">      91 </span>            :     }
<span class="lineNum">      92 </span>            :   }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="94"><span class="lineNum">      94 </span>            : }</a>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineNoCov">          0 : int NumStreamsDisabled(const std::vector&lt;bool&gt;&amp; streams) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   int num_disabled = 0;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   for (bool stream : streams) {</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     if (!stream)</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :       ++num_disabled;</span>
<span class="lineNum">     101 </span>            :   }
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   return num_disabled;</span>
<span class="lineNum">     103 </span>            : }
<a name="104"><span class="lineNum">     104 </span>            : }  // namespace</a>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineNoCov">          0 : VP8Encoder* VP8Encoder::Create() {</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   return new VP8EncoderImpl();</span>
<a name="108"><span class="lineNum">     108 </span>            : }</a>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineNoCov">          0 : VP8Decoder* VP8Decoder::Create() {</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   return new VP8DecoderImpl();</span>
<a name="112"><span class="lineNum">     112 </span>            : }</a>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 : VP8EncoderImpl::VP8EncoderImpl()</span>
<span class="lineNum">     115 </span>            :     : encoded_complete_callback_(nullptr),
<span class="lineNum">     116 </span>            :       inited_(false),
<span class="lineNum">     117 </span>            :       timestamp_(0),
<span class="lineNum">     118 </span>            :       feedback_mode_(false),
<span class="lineNum">     119 </span>            :       qp_max_(56),  // Setting for max quantizer.
<span class="lineNum">     120 </span>            :       cpu_speed_default_(-6),
<span class="lineNum">     121 </span>            :       number_of_cores_(0),
<span class="lineNum">     122 </span>            :       rc_max_intra_target_(0),
<span class="lineNum">     123 </span>            :       token_partitions_(VP8_ONE_TOKENPARTITION),
<span class="lineNum">     124 </span>            :       down_scale_requested_(false),
<span class="lineNum">     125 </span>            :       down_scale_bitrate_(0),
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :       key_frame_request_(kMaxSimulcastStreams, false) {</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   uint32_t seed = rtc::Time32();</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   srand(seed);</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   picture_id_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   last_key_frame_picture_id_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   temporal_layers_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   raw_images_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   encoded_images_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   send_stream_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   cpu_speed_.assign(kMaxSimulcastStreams, -6);  // Set default to -6.</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   encoders_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   configurations_.reserve(kMaxSimulcastStreams);</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   downsampling_factors_.reserve(kMaxSimulcastStreams);</span>
<a name="140"><span class="lineNum">     140 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 : VP8EncoderImpl::~VP8EncoderImpl() {</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   Release();</span>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::Release() {</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   int ret_val = WEBRTC_VIDEO_CODEC_OK;</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   while (!encoded_images_.empty()) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     EncodedImage&amp; image = encoded_images_.back();</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     delete[] image._buffer;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     encoded_images_.pop_back();</span>
<span class="lineNum">     153 </span>            :   }
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   while (!encoders_.empty()) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     vpx_codec_ctx_t&amp; encoder = encoders_.back();</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     if (vpx_codec_destroy(&amp;encoder)) {</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :       ret_val = WEBRTC_VIDEO_CODEC_MEMORY;</span>
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     encoders_.pop_back();</span>
<span class="lineNum">     160 </span>            :   }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   configurations_.clear();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   send_stream_.clear();</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   cpu_speed_.clear();</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   while (!raw_images_.empty()) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     vpx_img_free(&amp;raw_images_.back());</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     raw_images_.pop_back();</span>
<span class="lineNum">     167 </span>            :   }
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   while (!temporal_layers_.empty()) {</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     delete temporal_layers_.back();</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     temporal_layers_.pop_back();</span>
<span class="lineNum">     171 </span>            :   }
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   inited_ = false;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   return ret_val;</span>
<a name="174"><span class="lineNum">     174 </span>            : }</a>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::SetRateAllocation(const BitrateAllocation&amp; bitrate,</span>
<span class="lineNum">     177 </span>            :                                       uint32_t new_framerate) {
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   if (!inited_)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   if (encoders_[0].err)</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   if (new_framerate &lt; 1)</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   if (bitrate.get_sum_bps() == 0) {</span>
<span class="lineNum">     188 </span>            :     // Encoder paused, turn off all encoding.
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     const int num_streams = static_cast&lt;size_t&gt;(encoders_.size());</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; num_streams; ++i)</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :       SetStreamState(false, i);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_OK;</span>
<span class="lineNum">     193 </span>            :   }
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   // At this point, bitrate allocation should already match codec settings.
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   if (codec_.maxBitrate &gt; 0)</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     RTC_DCHECK_LE(bitrate.get_sum_kbps(), codec_.maxBitrate);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   RTC_DCHECK_GE(bitrate.get_sum_kbps(), codec_.minBitrate);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   if (codec_.numberOfSimulcastStreams &gt; 0)</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     RTC_DCHECK_GE(bitrate.get_sum_kbps(), codec_.simulcastStream[0].minBitrate);</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   codec_.maxFramerate = new_framerate;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   if (encoders_.size() == 1) {</span>
<span class="lineNum">     205 </span>            :     // 1:1.
<span class="lineNum">     206 </span>            :     // Calculate a rough limit for when to trigger a potental down scale.
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     uint32_t k_pixels_per_frame = codec_.width * codec_.height / 1000;</span>
<span class="lineNum">     208 </span>            :     // TODO(pwestin): we currently lack CAMA, this is a temporary fix to work
<span class="lineNum">     209 </span>            :     // around the current limitations.
<span class="lineNum">     210 </span>            :     // Only trigger keyframes if we are allowed to scale down.
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     if (configurations_[0].rc_resize_allowed) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       if (!down_scale_requested_) {</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         if (k_pixels_per_frame &gt; bitrate.get_sum_kbps()) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :           down_scale_requested_ = true;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :           down_scale_bitrate_ = bitrate.get_sum_kbps();</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :           key_frame_request_[0] = true;</span>
<span class="lineNum">     217 </span>            :         }
<span class="lineNum">     218 </span>            :       } else {
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         if (bitrate.get_sum_kbps() &gt; (2 * down_scale_bitrate_) ||</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :             bitrate.get_sum_kbps() &lt; (down_scale_bitrate_ / 2)) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :           down_scale_requested_ = false;</span>
<span class="lineNum">     222 </span>            :         }
<span class="lineNum">     223 </span>            :       }
<span class="lineNum">     224 </span>            :     }
<span class="lineNum">     225 </span>            :   } else {
<span class="lineNum">     226 </span>            :     // If we have more than 1 stream, reduce the qp_max for the low resolution
<span class="lineNum">     227 </span>            :     // stream if frame rate is not too low. The trade-off with lower qp_max is
<span class="lineNum">     228 </span>            :     // possibly more dropped frames, so we only do this if the frame rate is
<span class="lineNum">     229 </span>            :     // above some threshold (base temporal layer is down to 1/4 for 3 layers).
<span class="lineNum">     230 </span>            :     // We may want to condition this on bitrate later.
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     if (new_framerate &gt; 20) {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       configurations_[encoders_.size() - 1].rc_max_quantizer = 45;</span>
<span class="lineNum">     233 </span>            :     } else {
<span class="lineNum">     234 </span>            :       // Go back to default value set in InitEncode.
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       configurations_[encoders_.size() - 1].rc_max_quantizer = qp_max_;</span>
<span class="lineNum">     236 </span>            :     }
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   size_t stream_idx = encoders_.size() - 1;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; encoders_.size(); ++i, --stream_idx) {</span>
<span class="lineNum">     241 </span>            :     unsigned int target_bitrate_kbps =
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         bitrate.GetSpatialLayerSum(stream_idx) / 1000;</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     bool send_stream = target_bitrate_kbps &gt; 0;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (send_stream || encoders_.size() &gt; 1)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       SetStreamState(send_stream, stream_idx);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     configurations_[i].rc_target_bitrate = target_bitrate_kbps;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     temporal_layers_[stream_idx]-&gt;UpdateConfiguration(&amp;configurations_[i]);</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     if (vpx_codec_enc_config_set(&amp;encoders_[i], &amp;configurations_[i])) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span>            :   }
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="256"><span class="lineNum">     256 </span>            : }</a>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : const char* VP8EncoderImpl::ImplementationName() const {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   return &quot;libvpx&quot;;</span>
<a name="260"><span class="lineNum">     260 </span>            : }</a>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : void VP8EncoderImpl::SetStreamState(bool send_stream,</span>
<span class="lineNum">     263 </span>            :                                             int stream_idx) {
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   if (send_stream &amp;&amp; !send_stream_[stream_idx]) {</span>
<span class="lineNum">     265 </span>            :     // Need a key frame if we have not sent this stream before.
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     key_frame_request_[stream_idx] = true;</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   send_stream_[stream_idx] = send_stream;</span>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 : void VP8EncoderImpl::SetupTemporalLayers(int num_streams,</span>
<span class="lineNum">     272 </span>            :                                          int num_temporal_layers,
<span class="lineNum">     273 </span>            :                                          const VideoCodec&amp; codec) {
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   RTC_DCHECK(codec.VP8().tl_factory != nullptr);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   const TemporalLayersFactory* tl_factory = codec.VP8().tl_factory;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :   if (num_streams == 1) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     temporal_layers_.push_back(</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         tl_factory-&gt;Create(0, num_temporal_layers, rand()));</span>
<span class="lineNum">     279 </span>            :   } else {
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; num_streams; ++i) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       RTC_CHECK_GT(num_temporal_layers, 0);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :       int layers = std::max(static_cast&lt;uint8_t&gt;(1),</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                             codec.simulcastStream[i].numberOfTemporalLayers);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       temporal_layers_.push_back(tl_factory-&gt;Create(i, layers, rand()));</span>
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span>            :   }
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::InitEncode(const VideoCodec* inst,</span>
<span class="lineNum">     290 </span>            :                                int number_of_cores,
<span class="lineNum">     291 </span>            :                                size_t /*maxPayloadSize */) {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   if (inst == NULL) {</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     294 </span>            :   }
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   if (inst-&gt;maxFramerate &lt; 1) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     297 </span>            :   }
<span class="lineNum">     298 </span>            :   // allow zero to represent an unspecified maxBitRate
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   if (inst-&gt;maxBitrate &gt; 0 &amp;&amp; inst-&gt;startBitrate &gt; inst-&gt;maxBitrate) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     301 </span>            :   }
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (inst-&gt;width &lt;= 1 || inst-&gt;height &lt;= 1) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     304 </span>            :   }
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   if (number_of_cores &lt; 1) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     307 </span>            :   }
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   if (inst-&gt;VP8().feedbackModeOn &amp;&amp; inst-&gt;numberOfSimulcastStreams &gt; 1) {</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     310 </span>            :   }
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   if (inst-&gt;VP8().automaticResizeOn &amp;&amp; inst-&gt;numberOfSimulcastStreams &gt; 1) {</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     313 </span>            :   }
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   int retVal = Release();</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   if (retVal &lt; 0) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     return retVal;</span>
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   int number_of_streams = NumberOfStreams(*inst);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   bool doing_simulcast = (number_of_streams &gt; 1);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   if (doing_simulcast &amp;&amp; !ValidSimulcastResolutions(*inst, number_of_streams)) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">     324 </span>            :   }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   int num_temporal_layers =
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :       doing_simulcast ? inst-&gt;simulcastStream[0].numberOfTemporalLayers</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                       : inst-&gt;VP8().numberOfTemporalLayers;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   RTC_DCHECK_GT(num_temporal_layers, 0);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   SetupTemporalLayers(number_of_streams, num_temporal_layers, *inst);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   feedback_mode_ = inst-&gt;VP8().feedbackModeOn;</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   number_of_cores_ = number_of_cores;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   timestamp_ = 0;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   codec_ = *inst;</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   // Code expects simulcastStream resolutions to be correct, make sure they are
<span class="lineNum">     340 </span>            :   // filled even when there are no simulcast layers.
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   if (codec_.numberOfSimulcastStreams == 0) {</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     codec_.simulcastStream[0].width = codec_.width;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     codec_.simulcastStream[0].height = codec_.height;</span>
<span class="lineNum">     344 </span>            :   }
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   picture_id_.resize(number_of_streams);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   last_key_frame_picture_id_.resize(number_of_streams);</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   encoded_images_.resize(number_of_streams);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   encoders_.resize(number_of_streams);</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   configurations_.resize(number_of_streams);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   downsampling_factors_.resize(number_of_streams);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   raw_images_.resize(number_of_streams);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   send_stream_.resize(number_of_streams);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   send_stream_[0] = true;  // For non-simulcast case.</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   cpu_speed_.resize(number_of_streams);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   std::fill(key_frame_request_.begin(), key_frame_request_.end(), false);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   int idx = number_of_streams - 1;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; (number_of_streams - 1); ++i, --idx) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     int gcd = GCD(inst-&gt;simulcastStream[idx].width,</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :                   inst-&gt;simulcastStream[idx - 1].width);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     downsampling_factors_[i].num = inst-&gt;simulcastStream[idx].width / gcd;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     downsampling_factors_[i].den = inst-&gt;simulcastStream[idx - 1].width / gcd;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     send_stream_[i] = false;</span>
<span class="lineNum">     365 </span>            :   }
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   if (number_of_streams &gt; 1) {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     send_stream_[number_of_streams - 1] = false;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     downsampling_factors_[number_of_streams - 1].num = 1;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     downsampling_factors_[number_of_streams - 1].den = 1;</span>
<span class="lineNum">     370 </span>            :   }
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; number_of_streams; ++i) {</span>
<span class="lineNum">     372 </span>            :     // Random start, 16 bits is enough.
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     picture_id_[i] = static_cast&lt;uint16_t&gt;(rand()) &amp; 0x7FFF;  // NOLINT</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     last_key_frame_picture_id_[i] = -1;</span>
<span class="lineNum">     375 </span>            :     // allocate memory for encoded image
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if (encoded_images_[i]._buffer != NULL) {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       delete[] encoded_images_[i]._buffer;</span>
<span class="lineNum">     378 </span>            :     }
<span class="lineNum">     379 </span>            :     // Reserve 100 extra bytes for overhead at small resolutions.
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     encoded_images_[i]._size = CalcBufferSize(kI420, codec_.width, codec_.height)</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                                + 100;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     encoded_images_[i]._buffer = new uint8_t[encoded_images_[i]._size];</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     encoded_images_[i]._completeFrame = true;</span>
<span class="lineNum">     384 </span>            :   }
<span class="lineNum">     385 </span>            :   // populate encoder configuration with default values
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   if (vpx_codec_enc_config_default(vpx_codec_vp8_cx(), &amp;configurations_[0],</span>
<span class="lineNum">     387 </span>            :                                    0)) {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     389 </span>            :   }
<span class="lineNum">     390 </span>            :   // setting the time base of the codec
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   configurations_[0].g_timebase.num = 1;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   configurations_[0].g_timebase.den = 90000;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   configurations_[0].g_lag_in_frames = 0;  // 0- no frame lagging</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   // Set the error resilience mode according to user settings.
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   switch (inst-&gt;VP8().resilience) {</span>
<span class="lineNum">     397 </span>            :     case kResilienceOff:
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :       configurations_[0].g_error_resilient = 0;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     400 </span>            :     case kResilientStream:
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :       configurations_[0].g_error_resilient = 1;  // TODO(holmer): Replace with</span>
<span class="lineNum">     402 </span>            :       // VPX_ERROR_RESILIENT_DEFAULT when we
<span class="lineNum">     403 </span>            :       // drop support for libvpx 9.6.0.
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     405 </span>            :     case kResilientFrames:
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;  // Not supported</span>
<span class="lineNum">     407 </span>            :   }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :   // rate control settings
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   configurations_[0].rc_dropframe_thresh = inst-&gt;VP8().frameDroppingOn ? 30 : 0;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   configurations_[0].rc_end_usage = VPX_CBR;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   configurations_[0].g_pass = VPX_RC_ONE_PASS;</span>
<span class="lineNum">     413 </span>            :   // TODO(hellner): investigate why the following two lines produce
<span class="lineNum">     414 </span>            :   // automaticResizeOn value of 3 when running
<span class="lineNum">     415 </span>            :   // WebRtcVideoMediaChannelTest.GetStatsMultipleSendStreams inside the talk
<span class="lineNum">     416 </span>            :   // framework.
<span class="lineNum">     417 </span>            :   // configurations_[0].rc_resize_allowed =
<span class="lineNum">     418 </span>            :   //    inst-&gt;codecSpecific.VP8.automaticResizeOn ? 1 : 0;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   configurations_[0].rc_resize_allowed = 0;</span>
<span class="lineNum">     420 </span>            :   // Handle resizing outside of libvpx when doing single-stream.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   if (inst-&gt;VP8().automaticResizeOn &amp;&amp; number_of_streams &gt; 1) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     configurations_[0].rc_resize_allowed = 1;</span>
<span class="lineNum">     423 </span>            :   }
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   configurations_[0].rc_min_quantizer = 2;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   if (inst-&gt;qpMax &gt;= configurations_[0].rc_min_quantizer) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     qp_max_ = inst-&gt;qpMax;</span>
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   configurations_[0].rc_max_quantizer = qp_max_;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   configurations_[0].rc_undershoot_pct = 100;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   configurations_[0].rc_overshoot_pct = 15;</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   configurations_[0].rc_buf_initial_sz = 500;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   configurations_[0].rc_buf_optimal_sz = 600;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   configurations_[0].rc_buf_sz = 1000;</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :   // Set the maximum target size of any key-frame.
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   rc_max_intra_target_ = MaxIntraTarget(configurations_[0].rc_buf_optimal_sz);</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (feedback_mode_) {</span>
<span class="lineNum">     439 </span>            :     // Disable periodic key frames if we get feedback from the decoder
<span class="lineNum">     440 </span>            :     // through SLI and RPSI.
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     configurations_[0].kf_mode = VPX_KF_DISABLED;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   } else if (inst-&gt;VP8().keyFrameInterval &gt; 0) {</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     configurations_[0].kf_mode = VPX_KF_AUTO;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     configurations_[0].kf_max_dist = inst-&gt;VP8().keyFrameInterval;</span>
<span class="lineNum">     445 </span>            :   } else {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     configurations_[0].kf_mode = VPX_KF_DISABLED;</span>
<span class="lineNum">     447 </span>            :   }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // Allow the user to set the complexity for the base stream.
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   switch (inst-&gt;VP8().complexity) {</span>
<span class="lineNum">     451 </span>            :     case kComplexityHigh:
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       cpu_speed_[0] = -5;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     454 </span>            :     case kComplexityHigher:
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       cpu_speed_[0] = -4;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     457 </span>            :     case kComplexityMax:
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       cpu_speed_[0] = -3;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     460 </span>            :     default:
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       cpu_speed_[0] = -6;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     463 </span>            :   }
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   cpu_speed_default_ = cpu_speed_[0];</span>
<span class="lineNum">     465 </span>            :   // Set encoding complexity (cpu_speed) based on resolution and/or platform.
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   cpu_speed_[0] = SetCpuSpeed(inst-&gt;width, inst-&gt;height);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   for (int i = 1; i &lt; number_of_streams; ++i) {</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     cpu_speed_[i] =</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         SetCpuSpeed(inst-&gt;simulcastStream[number_of_streams - 1 - i].width,</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                     inst-&gt;simulcastStream[number_of_streams - 1 - i].height);</span>
<span class="lineNum">     471 </span>            :   }
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   configurations_[0].g_w = inst-&gt;width;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   configurations_[0].g_h = inst-&gt;height;</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   // Determine number of threads based on the image size and #cores.
<span class="lineNum">     476 </span>            :   // TODO(fbarchard): Consider number of Simulcast layers.
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   configurations_[0].g_threads = NumberOfThreads(</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       configurations_[0].g_w, configurations_[0].g_h, number_of_cores);</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   // Creating a wrapper to the image - setting image data to NULL.
<span class="lineNum">     481 </span>            :   // Actual pointer will be set in encode. Setting align to 1, as it
<span class="lineNum">     482 </span>            :   // is meaningless (no memory allocation is done here).
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   vpx_img_wrap(&amp;raw_images_[0], VPX_IMG_FMT_I420, inst-&gt;width, inst-&gt;height, 1,</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                NULL);</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   // Note the order we use is different from webm, we have lowest resolution
<span class="lineNum">     487 </span>            :   // at position 0 and they have highest resolution at position 0.
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   int stream_idx = encoders_.size() - 1;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   SimulcastRateAllocator init_allocator(codec_, nullptr);</span>
<span class="lineNum">     490 </span>            :   BitrateAllocation allocation = init_allocator.GetAllocation(
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       inst-&gt;startBitrate * 1000, inst-&gt;maxFramerate);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   std::vector&lt;uint32_t&gt; stream_bitrates;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   for (int i = 0; i == 0 || i &lt; inst-&gt;numberOfSimulcastStreams; ++i) {</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     uint32_t bitrate = allocation.GetSpatialLayerSum(i) / 1000;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     stream_bitrates.push_back(bitrate);</span>
<span class="lineNum">     496 </span>            :   }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   configurations_[0].rc_target_bitrate = stream_bitrates[stream_idx];</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   temporal_layers_[stream_idx]-&gt;OnRatesUpdated(</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       stream_bitrates[stream_idx], inst-&gt;maxBitrate, inst-&gt;maxFramerate);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   temporal_layers_[stream_idx]-&gt;UpdateConfiguration(&amp;configurations_[0]);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   --stream_idx;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   for (size_t i = 1; i &lt; encoders_.size(); ++i, --stream_idx) {</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     memcpy(&amp;configurations_[i], &amp;configurations_[0],</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :            sizeof(configurations_[0]));</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     configurations_[i].g_w = inst-&gt;simulcastStream[stream_idx].width;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     configurations_[i].g_h = inst-&gt;simulcastStream[stream_idx].height;</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :     // Use 1 thread for lower resolutions.
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     configurations_[i].g_threads = 1;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :     // Setting alignment to 32 - as that ensures at least 16 for all
<span class="lineNum">     514 </span>            :     // planes (32 for Y, 16 for U,V). Libvpx sets the requested stride for
<span class="lineNum">     515 </span>            :     // the y plane, but only half of it to the u and v planes.
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     vpx_img_alloc(&amp;raw_images_[i], VPX_IMG_FMT_I420,</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                   inst-&gt;simulcastStream[stream_idx].width,</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                   inst-&gt;simulcastStream[stream_idx].height, kVp832ByteAlign);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     SetStreamState(stream_bitrates[stream_idx] &gt; 0, stream_idx);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     configurations_[i].rc_target_bitrate = stream_bitrates[stream_idx];</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     temporal_layers_[stream_idx]-&gt;OnRatesUpdated(</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :         stream_bitrates[stream_idx], inst-&gt;maxBitrate, inst-&gt;maxFramerate);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     temporal_layers_[stream_idx]-&gt;UpdateConfiguration(&amp;configurations_[i]);</span>
<span class="lineNum">     524 </span>            :   }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   rps_.Init();</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   return InitAndSetControlSettings();</span>
<a name="528"><span class="lineNum">     528 </span>            : }</a>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::SetCpuSpeed(int width, int height) {</span>
<span class="lineNum">     531 </span>            : #if defined(WEBRTC_ARCH_ARM) || defined(WEBRTC_ARCH_ARM64) || defined(ANDROID)
<span class="lineNum">     532 </span>            :   // On mobile platform, use a lower speed setting for lower resolutions for
<span class="lineNum">     533 </span>            :   // CPUs with 4 or more cores.
<span class="lineNum">     534 </span>            :   RTC_DCHECK_GT(number_of_cores_, 0);
<span class="lineNum">     535 </span>            :   if (number_of_cores_ &lt;= 3)
<span class="lineNum">     536 </span>            :     return -12;
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :   if (width * height &lt;= 352 * 288)
<span class="lineNum">     539 </span>            :     return -8;
<span class="lineNum">     540 </span>            :   else if (width * height &lt;= 640 * 480)
<span class="lineNum">     541 </span>            :     return -10;
<span class="lineNum">     542 </span>            :   else
<span class="lineNum">     543 </span>            :     return -12;
<span class="lineNum">     544 </span>            : #else
<span class="lineNum">     545 </span>            :   // For non-ARM, increase encoding complexity (i.e., use lower speed setting)
<span class="lineNum">     546 </span>            :   // if resolution is below CIF. Otherwise, keep the default/user setting
<span class="lineNum">     547 </span>            :   // (|cpu_speed_default_|) set on InitEncode via VP8().complexity.
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   if (width * height &lt; 352 * 288)</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     return (cpu_speed_default_ &lt; -4) ? -4 : cpu_speed_default_;</span>
<span class="lineNum">     550 </span>            :   else
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     return cpu_speed_default_;</span>
<span class="lineNum">     552 </span>            : #endif
<a name="553"><span class="lineNum">     553 </span>            : }</a>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::NumberOfThreads(int width, int height, int cpus) {</span>
<span class="lineNum">     556 </span>            : #if defined(ANDROID)
<span class="lineNum">     557 </span>            :   if (width * height &gt;= 320 * 180) {
<span class="lineNum">     558 </span>            :     if (cpus &gt;= 4) {
<span class="lineNum">     559 </span>            :       // 3 threads for CPUs with 4 and more cores since most of times only 4
<span class="lineNum">     560 </span>            :       // cores will be active.
<span class="lineNum">     561 </span>            :       return 3;
<span class="lineNum">     562 </span>            :     } else if (cpus == 3 || cpus == 2) {
<span class="lineNum">     563 </span>            :       return 2;
<span class="lineNum">     564 </span>            :     } else {
<span class="lineNum">     565 </span>            :       return 1;
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span>            :   return 1;
<span class="lineNum">     569 </span>            : #else
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   if (width * height &gt;= 1920 * 1080 &amp;&amp; cpus &gt; 8) {</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     return 8;  // 8 threads for 1080p on high perf machines.</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   } else if (width * height &gt; 1280 * 960 &amp;&amp; cpus &gt;= 6) {</span>
<span class="lineNum">     573 </span>            :     // 3 threads for 1080p.
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     return 3;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   } else if (width * height &gt; 640 * 480 &amp;&amp; cpus &gt;= 3) {</span>
<span class="lineNum">     576 </span>            :     // 2 threads for qHD/HD.
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     return 2;</span>
<span class="lineNum">     578 </span>            :   } else {
<span class="lineNum">     579 </span>            :     // 1 thread for VGA or less.
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     581 </span>            :   }
<span class="lineNum">     582 </span>            : #endif
<a name="583"><span class="lineNum">     583 </span>            : }</a>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::InitAndSetControlSettings() {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   vpx_codec_flags_t flags = 0;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   flags |= VPX_CODEC_USE_OUTPUT_PARTITION;</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   if (encoders_.size() &gt; 1) {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     int error = vpx_codec_enc_init_multi(&amp;encoders_[0], vpx_codec_vp8_cx(),</span>
<span class="lineNum">     591 </span>            :                                          &amp;configurations_[0], encoders_.size(),
<span class="lineNum">     592 </span>            :                                          flags, &amp;downsampling_factors_[0]);
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     if (error) {</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">     595 </span>            :     }
<span class="lineNum">     596 </span>            :   } else {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     if (vpx_codec_enc_init(&amp;encoders_[0], vpx_codec_vp8_cx(),</span>
<span class="lineNum">     598 </span>            :                            &amp;configurations_[0], flags)) {
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">     600 </span>            :     }
<span class="lineNum">     601 </span>            :   }
<span class="lineNum">     602 </span>            :   // Enable denoising for the highest resolution stream, and for
<span class="lineNum">     603 </span>            :   // the second highest resolution if we are doing more than 2
<span class="lineNum">     604 </span>            :   // spatial layers/streams.
<span class="lineNum">     605 </span>            :   // TODO(holmer): Investigate possibility of adding a libvpx API
<span class="lineNum">     606 </span>            :   // for getting the denoised frame from the encoder and using that
<span class="lineNum">     607 </span>            :   // when encoding lower resolution streams. Would it work with the
<span class="lineNum">     608 </span>            :   // multi-res encoding feature?
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   denoiserState denoiser_state = kDenoiserOnYOnly;</span>
<span class="lineNum">     610 </span>            : #if defined(WEBRTC_ARCH_ARM) || defined(WEBRTC_ARCH_ARM64) || defined(ANDROID)
<span class="lineNum">     611 </span>            :   denoiser_state = kDenoiserOnYOnly;
<span class="lineNum">     612 </span>            : #else
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   denoiser_state = kDenoiserOnAdaptive;</span>
<span class="lineNum">     614 </span>            : #endif
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   vpx_codec_control(&amp;encoders_[0], VP8E_SET_NOISE_SENSITIVITY,</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                     codec_.VP8()-&gt;denoisingOn ? denoiser_state : kDenoiserOff);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   if (encoders_.size() &gt; 2) {</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     vpx_codec_control(</span>
<span class="lineNum">     619 </span>            :         &amp;encoders_[1], VP8E_SET_NOISE_SENSITIVITY,
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         codec_.VP8()-&gt;denoisingOn ? denoiser_state : kDenoiserOff);</span>
<span class="lineNum">     621 </span>            :   }
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     623 </span>            :     // Allow more screen content to be detected as static.
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[i]), VP8E_SET_STATIC_THRESHOLD,</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                       codec_.mode == kScreensharing ? 300 : 1);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[i]), VP8E_SET_CPUUSED, cpu_speed_[i]);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[i]), VP8E_SET_TOKEN_PARTITIONS,</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                       static_cast&lt;vp8e_token_partitions&gt;(token_partitions_));</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[i]), VP8E_SET_MAX_INTRA_BITRATE_PCT,</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                       rc_max_intra_target_);</span>
<span class="lineNum">     631 </span>            :     // VP8E_SET_SCREEN_CONTENT_MODE 2 = screen content with more aggressive
<span class="lineNum">     632 </span>            :     // rate control (drop frames on large target bitrate overshoot)
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[i]), VP8E_SET_SCREEN_CONTENT_MODE,</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                       codec_.mode == kScreensharing ? 2 : 0);</span>
<span class="lineNum">     635 </span>            :   }
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   inited_ = true;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="638"><span class="lineNum">     638 </span>            : }</a>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineNoCov">          0 : uint32_t VP8EncoderImpl::MaxIntraTarget(uint32_t optimalBuffersize) {</span>
<span class="lineNum">     641 </span>            :   // Set max to the optimal buffer level (normalized by target BR),
<span class="lineNum">     642 </span>            :   // and scaled by a scalePar.
<span class="lineNum">     643 </span>            :   // Max target size = scalePar * optimalBufferSize * targetBR[Kbps].
<span class="lineNum">     644 </span>            :   // This values is presented in percentage of perFrameBw:
<span class="lineNum">     645 </span>            :   // perFrameBw = targetBR[Kbps] * 1000 / frameRate.
<span class="lineNum">     646 </span>            :   // The target in % is as follows:
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   float scalePar = 0.5;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   uint32_t targetPct = optimalBuffersize * scalePar * codec_.maxFramerate / 10;</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :   // Don't go below 3 times the per frame bandwidth.
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   const uint32_t minIntraTh = 300;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   return (targetPct &lt; minIntraTh) ? minIntraTh : targetPct;</span>
<a name="654"><span class="lineNum">     654 </span>            : }</a>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::Encode(const VideoFrame&amp; frame,</span>
<span class="lineNum">     657 </span>            :                            const CodecSpecificInfo* codec_specific_info,
<span class="lineNum">     658 </span>            :                            const std::vector&lt;FrameType&gt;* frame_types) {
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(frame.width(), codec_.width);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(frame.height(), codec_.height);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   if (!inited_)</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   if (encoded_complete_callback_ == NULL)</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   rtc::scoped_refptr&lt;VideoFrameBuffer&gt; input_image = frame.video_frame_buffer();</span>
<span class="lineNum">     668 </span>            :   // Since we are extracting raw pointers from |input_image| to
<span class="lineNum">     669 </span>            :   // |raw_images_[0]|, the resolution of these frames must match. Note that
<span class="lineNum">     670 </span>            :   // |input_image| might be scaled from |frame|. In that case, the resolution of
<span class="lineNum">     671 </span>            :   // |raw_images_[0]| should have been updated in UpdateCodecFrameSize.
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(input_image-&gt;width(), raw_images_[0].d_w);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :   RTC_DCHECK_EQ(input_image-&gt;height(), raw_images_[0].d_h);</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   // Image in vpx_image_t format.
<span class="lineNum">     676 </span>            :   // Input image is const. VP8's raw image is not defined as const.
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   raw_images_[0].planes[VPX_PLANE_Y] =</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       const_cast&lt;uint8_t*&gt;(input_image-&gt;DataY());</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :   raw_images_[0].planes[VPX_PLANE_U] =</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       const_cast&lt;uint8_t*&gt;(input_image-&gt;DataU());</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   raw_images_[0].planes[VPX_PLANE_V] =</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :       const_cast&lt;uint8_t*&gt;(input_image-&gt;DataV());</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   raw_images_[0].stride[VPX_PLANE_Y] = input_image-&gt;StrideY();</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   raw_images_[0].stride[VPX_PLANE_U] = input_image-&gt;StrideU();</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   raw_images_[0].stride[VPX_PLANE_V] = input_image-&gt;StrideV();</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   for (size_t i = 1; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     689 </span>            :     // Scale the image down a number of times by downsampling factor
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     libyuv::I420Scale(</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].planes[VPX_PLANE_Y],</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].stride[VPX_PLANE_Y],</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].planes[VPX_PLANE_U],</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].stride[VPX_PLANE_U],</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].planes[VPX_PLANE_V],</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].stride[VPX_PLANE_V], raw_images_[i - 1].d_w,</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         raw_images_[i - 1].d_h, raw_images_[i].planes[VPX_PLANE_Y],</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         raw_images_[i].stride[VPX_PLANE_Y], raw_images_[i].planes[VPX_PLANE_U],</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         raw_images_[i].stride[VPX_PLANE_U], raw_images_[i].planes[VPX_PLANE_V],</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         raw_images_[i].stride[VPX_PLANE_V], raw_images_[i].d_w,</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         raw_images_[i].d_h, libyuv::kFilterBilinear);</span>
<span class="lineNum">     702 </span>            :   }
<span class="lineNum">     703 </span>            :   vpx_enc_frame_flags_t flags[kMaxSimulcastStreams];
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     int ret = temporal_layers_[i]-&gt;EncodeFlags(frame.timestamp());</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     if (ret &lt; 0) {</span>
<span class="lineNum">     707 </span>            :       // Drop this frame.
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_OK;</span>
<span class="lineNum">     709 </span>            :     }
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     flags[i] = ret;</span>
<span class="lineNum">     711 </span>            :   }
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   bool send_key_frame = false;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; key_frame_request_.size() &amp;&amp; i &lt; send_stream_.size();</span>
<span class="lineNum">     714 </span>            :        ++i) {
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     if (key_frame_request_[i] &amp;&amp; send_stream_[i]) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       send_key_frame = true;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span>            :   }
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   if (!send_key_frame &amp;&amp; frame_types) {</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; frame_types-&gt;size() &amp;&amp; i &lt; send_stream_.size();</span>
<span class="lineNum">     722 </span>            :          ++i) {
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       if ((*frame_types)[i] == kVideoFrameKey &amp;&amp; send_stream_[i]) {</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         send_key_frame = true;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     726 </span>            :       }
<span class="lineNum">     727 </span>            :     }
<span class="lineNum">     728 </span>            :   }
<span class="lineNum">     729 </span>            :   // The flag modification below (due to forced key frame, RPS, etc.,) for now
<span class="lineNum">     730 </span>            :   // will be the same for all encoders/spatial layers.
<span class="lineNum">     731 </span>            :   // TODO(marpan/holmer): Allow for key frame request to be set per encoder.
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   bool only_predict_from_key_frame = false;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   if (send_key_frame) {</span>
<span class="lineNum">     734 </span>            :     // Adapt the size of the key frame when in screenshare with 1 temporal
<span class="lineNum">     735 </span>            :     // layer.
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     if (encoders_.size() == 1 &amp;&amp; codec_.mode == kScreensharing &amp;&amp;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         codec_.VP8()-&gt;numberOfTemporalLayers &lt;= 1) {</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       const uint32_t forceKeyFrameIntraTh = 100;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :       vpx_codec_control(&amp;(encoders_[0]), VP8E_SET_MAX_INTRA_BITRATE_PCT,</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                         forceKeyFrameIntraTh);</span>
<span class="lineNum">     741 </span>            :     }
<span class="lineNum">     742 </span>            :     // Key frame request from caller.
<span class="lineNum">     743 </span>            :     // Will update both golden and alt-ref.
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       flags[i] = VPX_EFLAG_FORCE_KF;</span>
<span class="lineNum">     746 </span>            :     }
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     std::fill(key_frame_request_.begin(), key_frame_request_.end(), false);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   } else if (codec_specific_info &amp;&amp;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :              codec_specific_info-&gt;codecType == kVideoCodecVP8) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     if (feedback_mode_) {</span>
<span class="lineNum">     751 </span>            :       // Handle RPSI and SLI messages and set up the appropriate encode flags.
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       bool sendRefresh = false;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       if (codec_specific_info-&gt;codecSpecific.VP8.hasReceivedRPSI) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         rps_.ReceivedRPSI(codec_specific_info-&gt;codecSpecific.VP8.pictureIdRPSI);</span>
<span class="lineNum">     755 </span>            :       }
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :       if (codec_specific_info-&gt;codecSpecific.VP8.hasReceivedSLI) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         sendRefresh = rps_.ReceivedSLI(frame.timestamp());</span>
<span class="lineNum">     758 </span>            :       }
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         flags[i] = rps_.EncodeFlags(picture_id_[i], sendRefresh,</span>
<span class="lineNum">     761 </span>            :                                     frame.timestamp());
<span class="lineNum">     762 </span>            :       }
<span class="lineNum">     763 </span>            :     } else {
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :       if (codec_specific_info-&gt;codecSpecific.VP8.hasReceivedRPSI) {</span>
<span class="lineNum">     765 </span>            :         // Is this our last key frame? If not ignore.
<span class="lineNum">     766 </span>            :         // |picture_id_| is defined per spatial stream/layer, so check that
<span class="lineNum">     767 </span>            :         // |RPSI| matches the last key frame from any of the spatial streams.
<span class="lineNum">     768 </span>            :         // If so, then all spatial streams for this encoding will predict from
<span class="lineNum">     769 </span>            :         // its long-term reference (last key frame).
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         int RPSI = codec_specific_info-&gt;codecSpecific.VP8.pictureIdRPSI;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; encoders_.size(); ++i) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           if (last_key_frame_picture_id_[i] == RPSI) {</span>
<span class="lineNum">     773 </span>            :             // Request for a long term reference frame.
<span class="lineNum">     774 </span>            :             // Note 1: overwrites any temporal settings.
<span class="lineNum">     775 </span>            :             // Note 2: VP8_EFLAG_NO_UPD_ENTROPY is not needed as that flag is
<span class="lineNum">     776 </span>            :             //         set by error_resilient mode.
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :             for (size_t j = 0; j &lt; encoders_.size(); ++j) {</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :               flags[j] = VP8_EFLAG_NO_UPD_ARF;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :               flags[j] |= VP8_EFLAG_NO_REF_GF;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :               flags[j] |= VP8_EFLAG_NO_REF_LAST;</span>
<span class="lineNum">     781 </span>            :             }
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :             only_predict_from_key_frame = true;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     784 </span>            :           }
<span class="lineNum">     785 </span>            :         }
<span class="lineNum">     786 </span>            :       }
<span class="lineNum">     787 </span>            :     }
<span class="lineNum">     788 </span>            :   }
<span class="lineNum">     789 </span>            :   // Set the encoder frame flags and temporal layer_id for each spatial stream.
<span class="lineNum">     790 </span>            :   // Note that |temporal_layers_| are defined starting from lowest resolution at
<span class="lineNum">     791 </span>            :   // position 0 to highest resolution at position |encoders_.size() - 1|,
<span class="lineNum">     792 </span>            :   // whereas |encoder_| is from highest to lowest resolution.
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   size_t stream_idx = encoders_.size() - 1;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; encoders_.size(); ++i, --stream_idx) {</span>
<span class="lineNum">     795 </span>            :     // Allow the layers adapter to temporarily modify the configuration. This
<span class="lineNum">     796 </span>            :     // change isn't stored in configurations_ so change will be discarded at
<span class="lineNum">     797 </span>            :     // the next update.
<span class="lineNum">     798 </span>            :     vpx_codec_enc_cfg_t temp_config;
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     memcpy(&amp;temp_config, &amp;configurations_[i], sizeof(vpx_codec_enc_cfg_t));</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     if (temporal_layers_[stream_idx]-&gt;UpdateConfiguration(&amp;temp_config)) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       if (vpx_codec_enc_config_set(&amp;encoders_[i], &amp;temp_config))</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;encoders_[i], VP8E_SET_FRAME_FLAGS, flags[stream_idx]);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;encoders_[i], VP8E_SET_TEMPORAL_LAYER_ID,</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :                       temporal_layers_[stream_idx]-&gt;CurrentLayerId());</span>
<span class="lineNum">     808 </span>            :   }
<span class="lineNum">     809 </span>            :   // TODO(holmer): Ideally the duration should be the timestamp diff of this
<span class="lineNum">     810 </span>            :   // frame and the next frame to be encoded, which we don't have. Instead we
<span class="lineNum">     811 </span>            :   // would like to use the duration of the previous frame. Unfortunately the
<span class="lineNum">     812 </span>            :   // rate control seems to be off with that setup. Using the average input
<span class="lineNum">     813 </span>            :   // frame rate to calculate an average duration for now.
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   assert(codec_.maxFramerate &gt; 0);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   uint32_t duration = 90000 / codec_.maxFramerate;</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   // Note we must pass 0 for |flags| field in encode call below since they are
<span class="lineNum">     818 </span>            :   // set above in |vpx_codec_control| function for each encoder/spatial layer.
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   int error = vpx_codec_encode(&amp;encoders_[0], &amp;raw_images_[0], timestamp_,</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                                duration, 0, VPX_DL_REALTIME);</span>
<span class="lineNum">     821 </span>            :   // Reset specific intra frame thresholds, following the key frame.
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   if (send_key_frame) {</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;(encoders_[0]), VP8E_SET_MAX_INTRA_BITRATE_PCT,</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                       rc_max_intra_target_);</span>
<span class="lineNum">     825 </span>            :   }
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   if (error)</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   timestamp_ += duration;</span>
<span class="lineNum">     829 </span>            :   // Examines frame timestamps only.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   return GetEncodedPartitions(frame, only_predict_from_key_frame);</span>
<span class="lineNum">     831 </span>            : }
<a name="832"><span class="lineNum">     832 </span>            : </a>
<span class="lineNum">     833 </span>            : // TODO(pbos): Make sure this works for properly for &gt;1 encoders.
<span class="lineNum">     834 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::UpdateCodecFrameSize(int width, int height) {</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   codec_.width = width;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   codec_.height = height;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   if (codec_.numberOfSimulcastStreams &lt;= 1) {</span>
<span class="lineNum">     838 </span>            :     // For now scaling is only used for single-layer streams.
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     codec_.simulcastStream[0].width = width;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     codec_.simulcastStream[0].height = height;</span>
<span class="lineNum">     841 </span>            :   }
<span class="lineNum">     842 </span>            :   // Update the cpu_speed setting for resolution change.
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   vpx_codec_control(&amp;(encoders_[0]), VP8E_SET_CPUUSED,</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :                     SetCpuSpeed(codec_.width, codec_.height));</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   raw_images_[0].w = codec_.width;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :   raw_images_[0].h = codec_.height;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   raw_images_[0].d_w = codec_.width;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   raw_images_[0].d_h = codec_.height;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   vpx_img_set_rect(&amp;raw_images_[0], 0, 0, codec_.width, codec_.height);</span>
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   // Update encoder context for new frame size.
<span class="lineNum">     852 </span>            :   // Change of frame size will automatically trigger a key frame.
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   configurations_[0].g_w = codec_.width;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   configurations_[0].g_h = codec_.height;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   if (vpx_codec_enc_config_set(&amp;encoders_[0], &amp;configurations_[0])) {</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">     857 </span>            :   }
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="859"><span class="lineNum">     859 </span>            : }</a>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 : void VP8EncoderImpl::PopulateCodecSpecific(</span>
<span class="lineNum">     862 </span>            :     CodecSpecificInfo* codec_specific,
<span class="lineNum">     863 </span>            :     const vpx_codec_cx_pkt_t&amp; pkt,
<span class="lineNum">     864 </span>            :     int stream_idx,
<span class="lineNum">     865 </span>            :     uint32_t timestamp,
<span class="lineNum">     866 </span>            :     bool only_predicting_from_key_frame) {
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   assert(codec_specific != NULL);</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   codec_specific-&gt;codecType = kVideoCodecVP8;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   codec_specific-&gt;codec_name = ImplementationName();</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   CodecSpecificInfoVP8* vp8Info = &amp;(codec_specific-&gt;codecSpecific.VP8);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   vp8Info-&gt;pictureId = picture_id_[stream_idx];</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   if (pkt.data.frame.flags &amp; VPX_FRAME_IS_KEY) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     last_key_frame_picture_id_[stream_idx] = picture_id_[stream_idx];</span>
<span class="lineNum">     874 </span>            :   }
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :   vp8Info-&gt;simulcastIdx = stream_idx;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   vp8Info-&gt;keyIdx = kNoKeyIdx;  // TODO(hlundin) populate this</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :   vp8Info-&gt;nonReference =</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       (pkt.data.frame.flags &amp; VPX_FRAME_IS_DROPPABLE) ? true : false;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   bool base_layer_sync_point = (pkt.data.frame.flags &amp; VPX_FRAME_IS_KEY) ||</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :                                only_predicting_from_key_frame;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   temporal_layers_[stream_idx]-&gt;PopulateCodecSpecific(base_layer_sync_point,</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :                                                       vp8Info, timestamp);</span>
<span class="lineNum">     883 </span>            :   // Prepare next.
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   picture_id_[stream_idx] = (picture_id_[stream_idx] + 1) &amp; 0x7FFF;</span>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::GetEncodedPartitions(const VideoFrame&amp; input_image,</span>
<span class="lineNum">     888 </span>            :                                          bool only_predicting_from_key_frame) {
<span class="lineNum">     889 </span>            :   int bw_resolutions_disabled =
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       (encoders_.size() &gt; 1) ? NumStreamsDisabled(send_stream_) : -1;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   int stream_idx = static_cast&lt;int&gt;(encoders_.size()) - 1;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   int result = WEBRTC_VIDEO_CODEC_OK;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   for (size_t encoder_idx = 0; encoder_idx &lt; encoders_.size();</span>
<span class="lineNum">     895 </span>            :        ++encoder_idx, --stream_idx) {
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     vpx_codec_iter_t iter = NULL;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     int part_idx = 0;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     encoded_images_[encoder_idx]._length = 0;</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     encoded_images_[encoder_idx]._frameType = kVideoFrameDelta;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     RTPFragmentationHeader frag_info;</span>
<span class="lineNum">     901 </span>            :     // token_partitions_ is number of bits used.
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     frag_info.VerifyAndAllocateFragmentationHeader((1 &lt;&lt; token_partitions_) +</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                                                    1);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     CodecSpecificInfo codec_specific;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     const vpx_codec_cx_pkt_t* pkt = NULL;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     while ((pkt = vpx_codec_get_cx_data(&amp;encoders_[encoder_idx], &amp;iter)) !=</span>
<span class="lineNum">     907 </span>            :            NULL) {
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :       switch (pkt-&gt;kind) {</span>
<span class="lineNum">     909 </span>            :         case VPX_CODEC_CX_FRAME_PKT: {
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :           size_t length = encoded_images_[encoder_idx]._length;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :           if (pkt-&gt;data.frame.sz + length &gt;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :               encoded_images_[encoder_idx]._size) {</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :             uint8_t* buffer = new uint8_t[pkt-&gt;data.frame.sz + length];</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :             memcpy(buffer, encoded_images_[encoder_idx]._buffer, length);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :             delete[] encoded_images_[encoder_idx]._buffer;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :             encoded_images_[encoder_idx]._buffer = buffer;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :             encoded_images_[encoder_idx]._size = pkt-&gt;data.frame.sz + length;</span>
<span class="lineNum">     918 </span>            :           }
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :           memcpy(&amp;encoded_images_[encoder_idx]._buffer[length],</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                  pkt-&gt;data.frame.buf, pkt-&gt;data.frame.sz);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :           frag_info.fragmentationOffset[part_idx] = length;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :           frag_info.fragmentationLength[part_idx] = pkt-&gt;data.frame.sz;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :           frag_info.fragmentationPlType[part_idx] = 0;  // not known here</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :           frag_info.fragmentationTimeDiff[part_idx] = 0;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :           encoded_images_[encoder_idx]._length += pkt-&gt;data.frame.sz;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :           assert(length &lt;= encoded_images_[encoder_idx]._size);</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :           ++part_idx;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span>            :         default:
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     932 </span>            :       }
<span class="lineNum">     933 </span>            :       // End of frame
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :       if ((pkt-&gt;data.frame.flags &amp; VPX_FRAME_IS_FRAGMENT) == 0) {</span>
<span class="lineNum">     935 </span>            :         // check if encoded frame is a key frame
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         if (pkt-&gt;data.frame.flags &amp; VPX_FRAME_IS_KEY) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :           encoded_images_[encoder_idx]._frameType = kVideoFrameKey;</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :           rps_.EncodedKeyFrame(picture_id_[stream_idx]);</span>
<span class="lineNum">     939 </span>            :         }
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         PopulateCodecSpecific(&amp;codec_specific, *pkt, stream_idx,</span>
<span class="lineNum">     941 </span>            :                               input_image.timestamp(),
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :                               only_predicting_from_key_frame);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     944 </span>            :       }
<span class="lineNum">     945 </span>            :     }
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     encoded_images_[encoder_idx]._timeStamp = input_image.timestamp();</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     encoded_images_[encoder_idx].capture_time_ms_ =</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         input_image.render_time_ms();</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     encoded_images_[encoder_idx].rotation_ = input_image.rotation();</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     int qp = -1;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     vpx_codec_control(&amp;encoders_[encoder_idx], VP8E_GET_LAST_QUANTIZER_64, &amp;qp);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     temporal_layers_[stream_idx]-&gt;FrameEncoded(</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx]._length,</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx]._timeStamp, qp);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     if (send_stream_[stream_idx]) {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :       if (encoded_images_[encoder_idx]._length &gt; 0) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         TRACE_COUNTER_ID1(&quot;webrtc&quot;, &quot;EncodedFrameSize&quot;, encoder_idx,</span>
<span class="lineNum">     959 </span>            :                           encoded_images_[encoder_idx]._length);
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx]._encodedHeight =</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :             codec_.simulcastStream[stream_idx].height;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx]._encodedWidth =</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             codec_.simulcastStream[stream_idx].width;</span>
<span class="lineNum">     964 </span>            :         // Report once per frame (lowest stream always sent).
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx].adapt_reason_.bw_resolutions_disabled =</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :             (stream_idx == 0) ? bw_resolutions_disabled : -1;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         int qp_128 = -1;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         vpx_codec_control(&amp;encoders_[encoder_idx], VP8E_GET_LAST_QUANTIZER,</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :                           &amp;qp_128);</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         encoded_images_[encoder_idx].qp_ = qp_128;</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         encoded_complete_callback_-&gt;OnEncodedImage(encoded_images_[encoder_idx],</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                                                    &amp;codec_specific, &amp;frag_info);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :       } else if (codec_.mode == kScreensharing) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         result = WEBRTC_VIDEO_CODEC_TARGET_BITRATE_OVERSHOOT;</span>
<span class="lineNum">     975 </span>            :       }
<span class="lineNum">     976 </span>            :     }
<span class="lineNum">     977 </span>            :   }
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   return result;</span>
<a name="979"><span class="lineNum">     979 </span>            : }</a>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 : VideoEncoder::ScalingSettings VP8EncoderImpl::GetScalingSettings() const {</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   const bool enable_scaling = encoders_.size() == 1 &amp;&amp;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :                               configurations_[0].rc_dropframe_thresh &gt; 0 &amp;&amp;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                               codec_.VP8().automaticResizeOn;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :   return VideoEncoder::ScalingSettings(enable_scaling);</span>
<a name="986"><span class="lineNum">     986 </span>            : }</a>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::SetChannelParameters(uint32_t packetLoss, int64_t rtt) {</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   rps_.SetRtt(rtt);</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="991"><span class="lineNum">     991 </span>            : }</a>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : int VP8EncoderImpl::RegisterEncodeCompleteCallback(</span>
<span class="lineNum">     994 </span>            :     EncodedImageCallback* callback) {
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   encoded_complete_callback_ = callback;</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="997"><span class="lineNum">     997 </span>            : }</a>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineNoCov">          0 : VP8DecoderImpl::VP8DecoderImpl()</span>
<span class="lineNum">    1000 </span>            :     : buffer_pool_(false, 300 /* max_number_of_buffers*/),
<span class="lineNum">    1001 </span>            :       decode_complete_callback_(NULL),
<span class="lineNum">    1002 </span>            :       inited_(false),
<span class="lineNum">    1003 </span>            :       feedback_mode_(false),
<span class="lineNum">    1004 </span>            :       decoder_(NULL),
<span class="lineNum">    1005 </span>            :       image_format_(VPX_IMG_FMT_NONE),
<span class="lineNum">    1006 </span>            :       ref_frame_(NULL),
<span class="lineNum">    1007 </span>            :       propagation_cnt_(-1),
<span class="lineNum">    1008 </span>            :       last_frame_width_(0),
<span class="lineNum">    1009 </span>            :       last_frame_height_(0),
<a name="1010"><span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       key_frame_required_(true) {}</span></a>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 : VP8DecoderImpl::~VP8DecoderImpl() {</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   inited_ = true;  // in order to do the actual release</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   Release();</span>
<a name="1015"><span class="lineNum">    1015 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::InitDecode(const VideoCodec* inst, int number_of_cores) {</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   int ret_val = Release();</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   if (ret_val &lt; 0) {</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     return ret_val;</span>
<span class="lineNum">    1021 </span>            :   }
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   if (decoder_ == NULL) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :     decoder_ = new vpx_codec_ctx_t;</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     memset(decoder_, 0, sizeof(*decoder_));</span>
<span class="lineNum">    1025 </span>            :   }
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   if (inst &amp;&amp; inst-&gt;codecType == kVideoCodecVP8) {</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     feedback_mode_ = inst-&gt;VP8().feedbackModeOn;</span>
<span class="lineNum">    1028 </span>            :   }
<span class="lineNum">    1029 </span>            :   vpx_codec_dec_cfg_t cfg;
<span class="lineNum">    1030 </span>            :   // Setting number of threads to a constant value (1)
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   cfg.threads = 1;</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   cfg.h = cfg.w = 0;  // set after decode</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   vpx_codec_flags_t flags = 0;</span>
<span class="lineNum">    1035 </span>            : #if !defined(WEBRTC_ARCH_ARM) &amp;&amp; !defined(WEBRTC_ARCH_ARM64) &amp;&amp; \
<span class="lineNum">    1036 </span>            :   !defined(ANDROID)
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   flags = VPX_CODEC_USE_POSTPROC;</span>
<span class="lineNum">    1038 </span>            : #endif
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   if (vpx_codec_dec_init(decoder_, vpx_codec_vp8_dx(), &amp;cfg, flags)) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     delete decoder_;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     decoder_ = nullptr;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_MEMORY;</span>
<span class="lineNum">    1044 </span>            :   }
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            :   // Save VideoCodec instance for later; mainly for duplicating the decoder.
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   if (&amp;codec_ != inst)</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :     codec_ = *inst;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   propagation_cnt_ = -1;</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   inited_ = true;</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   // Always start with a complete key frame.
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   key_frame_required_ = true;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="1056"><span class="lineNum">    1056 </span>            : }</a>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::Decode(const EncodedImage&amp; input_image,</span>
<span class="lineNum">    1059 </span>            :                            bool missing_frames,
<span class="lineNum">    1060 </span>            :                            const RTPFragmentationHeader* fragmentation,
<span class="lineNum">    1061 </span>            :                            const CodecSpecificInfo* codec_specific_info,
<span class="lineNum">    1062 </span>            :                            int64_t /*render_time_ms*/) {
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   if (!inited_) {</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">    1065 </span>            :   }
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   if (decode_complete_callback_ == NULL) {</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_UNINITIALIZED;</span>
<span class="lineNum">    1068 </span>            :   }
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   if (input_image._buffer == NULL &amp;&amp; input_image._length &gt; 0) {</span>
<span class="lineNum">    1070 </span>            :     // Reset to avoid requesting key frames too often.
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     if (propagation_cnt_ &gt; 0)</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :       propagation_cnt_ = 0;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;</span>
<span class="lineNum">    1074 </span>            :   }
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : #if !defined(WEBRTC_ARCH_ARM) &amp;&amp; !defined(WEBRTC_ARCH_ARM64) &amp;&amp; \
<span class="lineNum">    1077 </span>            :   !defined(ANDROID)
<span class="lineNum">    1078 </span>            :   vp8_postproc_cfg_t ppcfg;
<span class="lineNum">    1079 </span>            :   // MFQE enabled to reduce key frame popping.
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   ppcfg.post_proc_flag = VP8_MFQE | VP8_DEBLOCK;</span>
<span class="lineNum">    1081 </span>            :   // For VGA resolutions and lower, enable the demacroblocker postproc.
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   if (last_frame_width_ * last_frame_height_ &lt;= 640 * 360) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     ppcfg.post_proc_flag |= VP8_DEMACROBLOCK;</span>
<span class="lineNum">    1084 </span>            :   }
<span class="lineNum">    1085 </span>            :   // Strength of deblocking filter. Valid range:[0,16]
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   ppcfg.deblocking_level = 3;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   vpx_codec_control(decoder_, VP8_SET_POSTPROC, &amp;ppcfg);</span>
<span class="lineNum">    1088 </span>            : #endif
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :   // Always start with a complete key frame.
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   if (key_frame_required_) {</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     if (input_image._frameType != kVideoFrameKey)</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1094 </span>            :     // We have a key frame - is it complete?
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     if (input_image._completeFrame) {</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       key_frame_required_ = false;</span>
<span class="lineNum">    1097 </span>            :     } else {
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1099 </span>            :     }
<span class="lineNum">    1100 </span>            :   }
<span class="lineNum">    1101 </span>            :   // Restrict error propagation using key frame requests. Disabled when
<span class="lineNum">    1102 </span>            :   // the feedback mode is enabled (RPS).
<span class="lineNum">    1103 </span>            :   // Reset on a key frame refresh.
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   if (!feedback_mode_) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     if (input_image._frameType == kVideoFrameKey &amp;&amp;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         input_image._completeFrame) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :       propagation_cnt_ = -1;</span>
<span class="lineNum">    1108 </span>            :       // Start count on first loss.
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     } else if ((!input_image._completeFrame || missing_frames) &amp;&amp;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                propagation_cnt_ == -1) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       propagation_cnt_ = 0;</span>
<span class="lineNum">    1112 </span>            :     }
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     if (propagation_cnt_ &gt;= 0) {</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       propagation_cnt_++;</span>
<span class="lineNum">    1115 </span>            :     }
<span class="lineNum">    1116 </span>            :   }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   vpx_codec_iter_t iter = NULL;</span>
<span class="lineNum">    1119 </span>            :   vpx_image_t* img;
<span class="lineNum">    1120 </span>            :   int ret;
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   // Check for missing frames.
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   if (missing_frames) {</span>
<span class="lineNum">    1124 </span>            :     // Call decoder with zero data length to signal missing frames.
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     if (vpx_codec_decode(decoder_, NULL, 0, 0, VPX_DL_REALTIME)) {</span>
<span class="lineNum">    1126 </span>            :       // Reset to avoid requesting key frames too often.
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       if (propagation_cnt_ &gt; 0)</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :         propagation_cnt_ = 0;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1130 </span>            :     }
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     img = vpx_codec_get_frame(decoder_, &amp;iter);</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     iter = NULL;</span>
<span class="lineNum">    1133 </span>            :   }
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   uint8_t* buffer = input_image._buffer;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :   if (input_image._length == 0) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     buffer = NULL;  // Triggers full frame concealment.</span>
<span class="lineNum">    1138 </span>            :   }
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   if (vpx_codec_decode(decoder_, buffer, input_image._length, 0,</span>
<span class="lineNum">    1140 </span>            :                        VPX_DL_REALTIME)) {
<span class="lineNum">    1141 </span>            :     // Reset to avoid requesting key frames too often.
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     if (propagation_cnt_ &gt; 0) {</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :       propagation_cnt_ = 0;</span>
<span class="lineNum">    1144 </span>            :     }
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1146 </span>            :   }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   img = vpx_codec_get_frame(decoder_, &amp;iter);</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   ret = ReturnFrame(img, input_image._timeStamp, input_image.ntp_time_ms_);</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   if (ret != 0) {</span>
<span class="lineNum">    1151 </span>            :     // Reset to avoid requesting key frames too often.
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     if (ret &lt; 0 &amp;&amp; propagation_cnt_ &gt; 0)</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :       propagation_cnt_ = 0;</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">    1155 </span>            :   }
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   if (feedback_mode_) {</span>
<span class="lineNum">    1157 </span>            :     // Whenever we receive an incomplete key frame all reference buffers will
<span class="lineNum">    1158 </span>            :     // be corrupt. If that happens we must request new key frames until we
<span class="lineNum">    1159 </span>            :     // decode a complete key frame.
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :     if (input_image._frameType == kVideoFrameKey &amp;&amp; !input_image._completeFrame)</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1162 </span>            :     // Check for reference updates and last reference buffer corruption and
<span class="lineNum">    1163 </span>            :     // signal successful reference propagation or frame corruption to the
<span class="lineNum">    1164 </span>            :     // encoder.
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :     int reference_updates = 0;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     if (vpx_codec_control(decoder_, VP8D_GET_LAST_REF_UPDATES,</span>
<span class="lineNum">    1167 </span>            :                           &amp;reference_updates)) {
<span class="lineNum">    1168 </span>            :       // Reset to avoid requesting key frames too often.
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :       if (propagation_cnt_ &gt; 0) {</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         propagation_cnt_ = 0;</span>
<span class="lineNum">    1171 </span>            :       }
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1173 </span>            :     }
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     int corrupted = 0;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     if (vpx_codec_control(decoder_, VP8D_GET_FRAME_CORRUPTED, &amp;corrupted)) {</span>
<span class="lineNum">    1176 </span>            :       // Reset to avoid requesting key frames too often.
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :       if (propagation_cnt_ &gt; 0)</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         propagation_cnt_ = 0;</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1180 </span>            :     }
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     int16_t picture_id = -1;</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :     if (codec_specific_info) {</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :       picture_id = codec_specific_info-&gt;codecSpecific.VP8.pictureId;</span>
<span class="lineNum">    1184 </span>            :     }
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     if (picture_id &gt; -1) {</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :       if (((reference_updates &amp; VP8_GOLD_FRAME) ||</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :            (reference_updates &amp; VP8_ALTR_FRAME)) &amp;&amp;</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :           !corrupted) {</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :         decode_complete_callback_-&gt;ReceivedDecodedReferenceFrame(picture_id);</span>
<span class="lineNum">    1190 </span>            :       }
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :       decode_complete_callback_-&gt;ReceivedDecodedFrame(picture_id);</span>
<span class="lineNum">    1192 </span>            :     }
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     if (corrupted) {</span>
<span class="lineNum">    1194 </span>            :       // we can decode but with artifacts
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_REQUEST_SLI;</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            :   }
<span class="lineNum">    1198 </span>            :   // Check Vs. threshold
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   if (propagation_cnt_ &gt; kVp8ErrorPropagationTh) {</span>
<span class="lineNum">    1200 </span>            :     // Reset to avoid requesting key frames too often.
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     propagation_cnt_ = 0;</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_ERROR;</span>
<span class="lineNum">    1203 </span>            :   }
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="1205"><span class="lineNum">    1205 </span>            : }</a>
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::ReturnFrame(const vpx_image_t* img,</span>
<span class="lineNum">    1208 </span>            :                                 uint32_t timestamp,
<span class="lineNum">    1209 </span>            :                                 int64_t ntp_time_ms) {
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   if (img == NULL) {</span>
<span class="lineNum">    1211 </span>            :     // Decoder OK and NULL image =&gt; No show frame
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_NO_OUTPUT;</span>
<span class="lineNum">    1213 </span>            :   }
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   last_frame_width_ = img-&gt;d_w;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :   last_frame_height_ = img-&gt;d_h;</span>
<span class="lineNum">    1216 </span>            :   // Allocate memory for decoded image.
<span class="lineNum">    1217 </span>            :   rtc::scoped_refptr&lt;I420Buffer&gt; buffer =
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :       buffer_pool_.CreateBuffer(img-&gt;d_w, img-&gt;d_h);</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   if (!buffer.get()) {</span>
<span class="lineNum">    1220 </span>            :     // Pool has too many pending frames.
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     RTC_HISTOGRAM_BOOLEAN(&quot;WebRTC.Video.VP8DecoderImpl.TooManyPendingFrames&quot;,</span>
<span class="lineNum">    1222 </span>            :                           1);
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     return WEBRTC_VIDEO_CODEC_NO_OUTPUT;</span>
<span class="lineNum">    1224 </span>            :   }
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :   libyuv::I420Copy(img-&gt;planes[VPX_PLANE_Y], img-&gt;stride[VPX_PLANE_Y],</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                    img-&gt;planes[VPX_PLANE_U], img-&gt;stride[VPX_PLANE_U],</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                    img-&gt;planes[VPX_PLANE_V], img-&gt;stride[VPX_PLANE_V],</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                    buffer-&gt;MutableDataY(), buffer-&gt;StrideY(),</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :                    buffer-&gt;MutableDataU(), buffer-&gt;StrideU(),</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                    buffer-&gt;MutableDataV(), buffer-&gt;StrideV(),</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                    img-&gt;d_w, img-&gt;d_h);</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :   VideoFrame decoded_image(buffer, timestamp, 0, kVideoRotation_0);</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :   decoded_image.set_ntp_time_ms(ntp_time_ms);</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   int ret = decode_complete_callback_-&gt;Decoded(decoded_image);</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   if (ret != 0)</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :   // Remember image format for later
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   image_format_ = img-&gt;fmt;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="1243"><span class="lineNum">    1243 </span>            : }</a>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::RegisterDecodeCompleteCallback(</span>
<span class="lineNum">    1246 </span>            :     DecodedImageCallback* callback) {
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :   decode_complete_callback_ = callback;</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="1249"><span class="lineNum">    1249 </span>            : }</a>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::Release() {</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   if (decoder_ != NULL) {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     if (vpx_codec_destroy(decoder_)) {</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :       return WEBRTC_VIDEO_CODEC_MEMORY;</span>
<span class="lineNum">    1255 </span>            :     }
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     delete decoder_;</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     decoder_ = NULL;</span>
<span class="lineNum">    1258 </span>            :   }
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   if (ref_frame_ != NULL) {</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     vpx_img_free(&amp;ref_frame_-&gt;img);</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     delete ref_frame_;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     ref_frame_ = NULL;</span>
<span class="lineNum">    1263 </span>            :   }
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :   buffer_pool_.Release();</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :   inited_ = false;</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   return WEBRTC_VIDEO_CODEC_OK;</span>
<a name="1267"><span class="lineNum">    1267 </span>            : }</a>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 : const char* VP8DecoderImpl::ImplementationName() const {</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   return &quot;libvpx&quot;;</span>
<a name="1271"><span class="lineNum">    1271 </span>            : }</a>
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 : int VP8DecoderImpl::CopyReference(VP8DecoderImpl* copy) {</span>
<span class="lineNum">    1274 </span>            :   // The type of frame to copy should be set in ref_frame_-&gt;frame_type
<span class="lineNum">    1275 </span>            :   // before the call to this function.
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :   if (vpx_codec_control(decoder_, VP8_COPY_REFERENCE, ref_frame_) !=</span>
<span class="lineNum">    1277 </span>            :       VPX_CODEC_OK) {
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1279 </span>            :   }
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :   if (vpx_codec_control(copy-&gt;decoder_, VP8_SET_REFERENCE, ref_frame_) !=</span>
<span class="lineNum">    1281 </span>            :       VPX_CODEC_OK) {
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1283 </span>            :   }
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1285 </span>            : }
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/audio_coding/neteq/expand.cc</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/audio_coding/neteq</a> - expand.cc<span style="font-size: 80%;"> (source / <a href="expand.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">498</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/expand.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;string.h&gt;  // memset
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;algorithm&gt;  // min, max
<span class="lineNum">      17 </span>            : #include &lt;limits&gt;  // numeric_limits&lt;T&gt;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;webrtc/base/safe_conversions.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;webrtc/common_audio/signal_processing/include/signal_processing_library.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/background_noise.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/cross_correlation.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/dsp_helper.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/random_vector.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/statistics_calculator.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;webrtc/modules/audio_coding/neteq/sync_buffer.h&quot;
<span class="lineNum">      27 </span>            : 
<a name="28"><span class="lineNum">      28 </span>            : namespace webrtc {</a>
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span><span class="lineNoCov">          0 : Expand::Expand(BackgroundNoise* background_noise,</span>
<span class="lineNum">      31 </span>            :                SyncBuffer* sync_buffer,
<span class="lineNum">      32 </span>            :                RandomVector* random_vector,
<span class="lineNum">      33 </span>            :                StatisticsCalculator* statistics,
<span class="lineNum">      34 </span>            :                int fs,
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :                size_t num_channels)</span>
<span class="lineNum">      36 </span>            :     : random_vector_(random_vector),
<span class="lineNum">      37 </span>            :       sync_buffer_(sync_buffer),
<span class="lineNum">      38 </span>            :       first_expand_(true),
<span class="lineNum">      39 </span>            :       fs_hz_(fs),
<span class="lineNum">      40 </span>            :       num_channels_(num_channels),
<span class="lineNum">      41 </span>            :       consecutive_expands_(0),
<span class="lineNum">      42 </span>            :       background_noise_(background_noise),
<span class="lineNum">      43 </span>            :       statistics_(statistics),
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :       overlap_length_(5 * fs / 8000),</span>
<span class="lineNum">      45 </span>            :       lag_index_direction_(0),
<span class="lineNum">      46 </span>            :       current_lag_index_(0),
<span class="lineNum">      47 </span>            :       stop_muting_(false),
<span class="lineNum">      48 </span>            :       expand_duration_samples_(0),
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :       channel_parameters_(new ChannelParameters[num_channels_]) {</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   assert(fs == 8000 || fs == 16000 || fs == 32000 || fs == 48000);</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   assert(fs &lt;= static_cast&lt;int&gt;(kMaxSampleRate));  // Should not be possible.</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   assert(num_channels_ &gt; 0);</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   memset(expand_lags_, 0, sizeof(expand_lags_));</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   Reset();</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      56 </span>            : 
<a name="57"><span class="lineNum">      57 </span>            : Expand::~Expand() = default;</a>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span><span class="lineNoCov">          0 : void Expand::Reset() {</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   first_expand_ = true;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   consecutive_expands_ = 0;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   max_lag_ = 0;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   for (size_t ix = 0; ix &lt; num_channels_; ++ix) {</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     channel_parameters_[ix].expand_vector0.Clear();</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     channel_parameters_[ix].expand_vector1.Clear();</span>
<span class="lineNum">      66 </span>            :   }
<a name="67"><span class="lineNum">      67 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span><span class="lineNoCov">          0 : int Expand::Process(AudioMultiVector* output) {</span>
<span class="lineNum">      70 </span>            :   int16_t random_vector[kMaxSampleRate / 8000 * 120 + 30];
<span class="lineNum">      71 </span>            :   int16_t scaled_random_vector[kMaxSampleRate / 8000 * 125];
<span class="lineNum">      72 </span>            :   static const int kTempDataSize = 3600;
<span class="lineNum">      73 </span>            :   int16_t temp_data[kTempDataSize];  // TODO(hlundin) Remove this.
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   int16_t* voiced_vector_storage = temp_data;</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   int16_t* voiced_vector = &amp;voiced_vector_storage[overlap_length_];</span>
<span class="lineNum">      76 </span>            :   static const size_t kNoiseLpcOrder = BackgroundNoise::kMaxLpcOrder;
<span class="lineNum">      77 </span>            :   int16_t unvoiced_array_memory[kNoiseLpcOrder + kMaxSampleRate / 8000 * 125];
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   int16_t* unvoiced_vector = unvoiced_array_memory + kUnvoicedLpcOrder;</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   int16_t* noise_vector = unvoiced_array_memory + kNoiseLpcOrder;</span>
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   int fs_mult = fs_hz_ / 8000;</span>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   if (first_expand_) {</span>
<span class="lineNum">      84 </span>            :     // Perform initial setup if this is the first expansion since last reset.
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     AnalyzeSignal(random_vector);</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     first_expand_ = false;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     expand_duration_samples_ = 0;</span>
<span class="lineNum">      88 </span>            :   } else {
<span class="lineNum">      89 </span>            :     // This is not the first expansion, parameters are already estimated.
<span class="lineNum">      90 </span>            :     // Extract a noise segment.
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     size_t rand_length = max_lag_;</span>
<span class="lineNum">      92 </span>            :     // This only applies to SWB where length could be larger than 256.
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     assert(rand_length &lt;= kMaxSampleRate / 8000 * 120 + 30);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     GenerateRandomVector(2, rand_length, random_vector);</span>
<span class="lineNum">      95 </span>            :   }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   // Generate signal.
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   UpdateLagIndex();</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :   // Voiced part.
<span class="lineNum">     102 </span>            :   // Generate a weighted vector with the current lag.
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   size_t expansion_vector_length = max_lag_ + overlap_length_;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   size_t current_lag = expand_lags_[current_lag_index_];</span>
<span class="lineNum">     105 </span>            :   // Copy lag+overlap data.
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   size_t expansion_vector_position = expansion_vector_length - current_lag -</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :       overlap_length_;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   size_t temp_length = current_lag + overlap_length_;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   for (size_t channel_ix = 0; channel_ix &lt; num_channels_; ++channel_ix) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     ChannelParameters&amp; parameters = channel_parameters_[channel_ix];</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     if (current_lag_index_ == 0) {</span>
<span class="lineNum">     112 </span>            :       // Use only expand_vector0.
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :       assert(expansion_vector_position + temp_length &lt;=</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :              parameters.expand_vector0.Size());</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.CopyTo(temp_length, expansion_vector_position,</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                                        voiced_vector_storage);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     } else if (current_lag_index_ == 1) {</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       std::unique_ptr&lt;int16_t[]&gt; temp_0(new int16_t[temp_length]);</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.CopyTo(temp_length, expansion_vector_position,</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                                        temp_0.get());</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :       std::unique_ptr&lt;int16_t[]&gt; temp_1(new int16_t[temp_length]);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       parameters.expand_vector1.CopyTo(temp_length, expansion_vector_position,</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :                                        temp_1.get());</span>
<span class="lineNum">     124 </span>            :       // Mix 3/4 of expand_vector0 with 1/4 of expand_vector1.
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :       WebRtcSpl_ScaleAndAddVectorsWithRound(temp_0.get(), 3, temp_1.get(), 1, 2,</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :                                             voiced_vector_storage, temp_length);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     } else if (current_lag_index_ == 2) {</span>
<span class="lineNum">     128 </span>            :       // Mix 1/2 of expand_vector0 with 1/2 of expand_vector1.
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       assert(expansion_vector_position + temp_length &lt;=</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :              parameters.expand_vector0.Size());</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :       assert(expansion_vector_position + temp_length &lt;=</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :              parameters.expand_vector1.Size());</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       std::unique_ptr&lt;int16_t[]&gt; temp_0(new int16_t[temp_length]);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.CopyTo(temp_length, expansion_vector_position,</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :                                        temp_0.get());</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :       std::unique_ptr&lt;int16_t[]&gt; temp_1(new int16_t[temp_length]);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :       parameters.expand_vector1.CopyTo(temp_length, expansion_vector_position,</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :                                        temp_1.get());</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       WebRtcSpl_ScaleAndAddVectorsWithRound(temp_0.get(), 1, temp_1.get(), 1, 1,</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :                                             voiced_vector_storage, temp_length);</span>
<span class="lineNum">     142 </span>            :     }
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     // Get tapering window parameters. Values are in Q15.
<span class="lineNum">     145 </span>            :     int16_t muting_window, muting_window_increment;
<span class="lineNum">     146 </span>            :     int16_t unmuting_window, unmuting_window_increment;
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     if (fs_hz_ == 8000) {</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       muting_window = DspHelper::kMuteFactorStart8kHz;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :       muting_window_increment = DspHelper::kMuteFactorIncrement8kHz;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       unmuting_window = DspHelper::kUnmuteFactorStart8kHz;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       unmuting_window_increment = DspHelper::kUnmuteFactorIncrement8kHz;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     } else if (fs_hz_ == 16000) {</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :       muting_window = DspHelper::kMuteFactorStart16kHz;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :       muting_window_increment = DspHelper::kMuteFactorIncrement16kHz;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :       unmuting_window = DspHelper::kUnmuteFactorStart16kHz;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       unmuting_window_increment = DspHelper::kUnmuteFactorIncrement16kHz;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     } else if (fs_hz_ == 32000) {</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       muting_window = DspHelper::kMuteFactorStart32kHz;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       muting_window_increment = DspHelper::kMuteFactorIncrement32kHz;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       unmuting_window = DspHelper::kUnmuteFactorStart32kHz;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       unmuting_window_increment = DspHelper::kUnmuteFactorIncrement32kHz;</span>
<span class="lineNum">     162 </span>            :     } else {  // fs_ == 48000
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       muting_window = DspHelper::kMuteFactorStart48kHz;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       muting_window_increment = DspHelper::kMuteFactorIncrement48kHz;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       unmuting_window = DspHelper::kUnmuteFactorStart48kHz;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       unmuting_window_increment = DspHelper::kUnmuteFactorIncrement48kHz;</span>
<span class="lineNum">     167 </span>            :     }
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :     // Smooth the expanded if it has not been muted to a low amplitude and
<span class="lineNum">     170 </span>            :     // |current_voice_mix_factor| is larger than 0.5.
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     if ((parameters.mute_factor &gt; 819) &amp;&amp;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         (parameters.current_voice_mix_factor &gt; 8192)) {</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       size_t start_ix = sync_buffer_-&gt;Size() - overlap_length_;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; overlap_length_; i++) {</span>
<span class="lineNum">     175 </span>            :         // Do overlap add between new vector and overlap.
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         (*sync_buffer_)[channel_ix][start_ix + i] =</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :             (((*sync_buffer_)[channel_ix][start_ix + i] * muting_window) +</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 (((parameters.mute_factor * voiced_vector_storage[i]) &gt;&gt; 14) *</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                     unmuting_window) + 16384) &gt;&gt; 15;</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :         muting_window += muting_window_increment;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         unmuting_window += unmuting_window_increment;</span>
<span class="lineNum">     182 </span>            :       }
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     } else if (parameters.mute_factor == 0) {</span>
<span class="lineNum">     184 </span>            :       // The expanded signal will consist of only comfort noise if
<span class="lineNum">     185 </span>            :       // mute_factor = 0. Set the output length to 15 ms for best noise
<span class="lineNum">     186 </span>            :       // production.
<span class="lineNum">     187 </span>            :       // TODO(hlundin): This has been disabled since the length of
<span class="lineNum">     188 </span>            :       // parameters.expand_vector0 and parameters.expand_vector1 no longer
<span class="lineNum">     189 </span>            :       // match with expand_lags_, causing invalid reads and writes. Is it a good
<span class="lineNum">     190 </span>            :       // idea to enable this again, and solve the vector size problem?
<span class="lineNum">     191 </span>            : //      max_lag_ = fs_mult * 120;
<span class="lineNum">     192 </span>            : //      expand_lags_[0] = fs_mult * 120;
<span class="lineNum">     193 </span>            : //      expand_lags_[1] = fs_mult * 120;
<span class="lineNum">     194 </span>            : //      expand_lags_[2] = fs_mult * 120;
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :     // Unvoiced part.
<span class="lineNum">     198 </span>            :     // Filter |scaled_random_vector| through |ar_filter_|.
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     memcpy(unvoiced_vector - kUnvoicedLpcOrder, parameters.ar_filter_state,</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * kUnvoicedLpcOrder);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     int32_t add_constant = 0;</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     if (parameters.ar_gain_scale &gt; 0) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       add_constant = 1 &lt;&lt; (parameters.ar_gain_scale - 1);</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     WebRtcSpl_AffineTransformVector(scaled_random_vector, random_vector,</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :                                     parameters.ar_gain, add_constant,</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :                                     parameters.ar_gain_scale,</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :                                     current_lag);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     WebRtcSpl_FilterARFastQ12(scaled_random_vector, unvoiced_vector,</span>
<span class="lineNum">     210 </span>            :                               parameters.ar_filter, kUnvoicedLpcOrder + 1,
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :                               current_lag);</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     memcpy(parameters.ar_filter_state,</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :            &amp;(unvoiced_vector[current_lag - kUnvoicedLpcOrder]),</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * kUnvoicedLpcOrder);</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     // Combine voiced and unvoiced contributions.
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     // Set a suitable cross-fading slope.
<span class="lineNum">     219 </span>            :     // For lag =
<span class="lineNum">     220 </span>            :     //   &lt;= 31 * fs_mult            =&gt; go from 1 to 0 in about 8 ms;
<span class="lineNum">     221 </span>            :     //  (&gt;= 31 .. &lt;= 63) * fs_mult  =&gt; go from 1 to 0 in about 16 ms;
<span class="lineNum">     222 </span>            :     //   &gt;= 64 * fs_mult            =&gt; go from 1 to 0 in about 32 ms.
<span class="lineNum">     223 </span>            :     // temp_shift = getbits(max_lag_) - 5.
<span class="lineNum">     224 </span>            :     int temp_shift =
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         (31 - WebRtcSpl_NormW32(rtc::checked_cast&lt;int32_t&gt;(max_lag_))) - 5;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     int16_t mix_factor_increment = 256 &gt;&gt; temp_shift;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     if (stop_muting_) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       mix_factor_increment = 0;</span>
<span class="lineNum">     229 </span>            :     }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            :     // Create combined signal by shifting in more and more of unvoiced part.
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     temp_shift = 8 - temp_shift;  // = getbits(mix_factor_increment).</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     size_t temp_length = (parameters.current_voice_mix_factor -</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         parameters.voice_mix_factor) &gt;&gt; temp_shift;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     temp_length = std::min(temp_length, current_lag);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     DspHelper::CrossFade(voiced_vector, unvoiced_vector, temp_length,</span>
<span class="lineNum">     237 </span>            :                          &amp;parameters.current_voice_mix_factor,
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                          mix_factor_increment, temp_data);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     // End of cross-fading period was reached before end of expanded signal
<span class="lineNum">     241 </span>            :     // path. Mix the rest with a fixed mixing factor.
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     if (temp_length &lt; current_lag) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       if (mix_factor_increment != 0) {</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         parameters.current_voice_mix_factor = parameters.voice_mix_factor;</span>
<span class="lineNum">     245 </span>            :       }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       int16_t temp_scale = 16384 - parameters.current_voice_mix_factor;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       WebRtcSpl_ScaleAndAddVectorsWithRound(</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :           voiced_vector + temp_length, parameters.current_voice_mix_factor,</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :           unvoiced_vector + temp_length, temp_scale, 14,</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :           temp_data + temp_length, current_lag - temp_length);</span>
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :     // Select muting slope depending on how many consecutive expands we have
<span class="lineNum">     254 </span>            :     // done.
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     if (consecutive_expands_ == 3) {</span>
<span class="lineNum">     256 </span>            :       // Let the mute factor decrease from 1.0 to 0.95 in 6.25 ms.
<span class="lineNum">     257 </span>            :       // mute_slope = 0.0010 / fs_mult in Q20.
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       parameters.mute_slope = std::max(parameters.mute_slope, 1049 / fs_mult);</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     if (consecutive_expands_ == 7) {</span>
<span class="lineNum">     261 </span>            :       // Let the mute factor decrease from 1.0 to 0.90 in 6.25 ms.
<span class="lineNum">     262 </span>            :       // mute_slope = 0.0020 / fs_mult in Q20.
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       parameters.mute_slope = std::max(parameters.mute_slope, 2097 / fs_mult);</span>
<span class="lineNum">     264 </span>            :     }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :     // Mute segment according to slope value.
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if ((consecutive_expands_ != 0) || !parameters.onset) {</span>
<span class="lineNum">     268 </span>            :       // Mute to the previous level, then continue with the muting.
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       WebRtcSpl_AffineTransformVector(temp_data, temp_data,</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :                                       parameters.mute_factor, 8192,</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                                       14, current_lag);</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       if (!stop_muting_) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         DspHelper::MuteSignal(temp_data, parameters.mute_slope, current_lag);</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :         // Shift by 6 to go from Q20 to Q14.
<span class="lineNum">     277 </span>            :         // TODO(hlundin): Adding 8192 before shifting 6 steps seems wrong.
<span class="lineNum">     278 </span>            :         // Legacy.
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         int16_t gain = static_cast&lt;int16_t&gt;(16384 -</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             (((current_lag * parameters.mute_slope) + 8192) &gt;&gt; 6));</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         gain = ((gain * parameters.mute_factor) + 8192) &gt;&gt; 14;</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :         // Guard against getting stuck with very small (but sometimes audible)
<span class="lineNum">     284 </span>            :         // gain.
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         if ((consecutive_expands_ &gt; 3) &amp;&amp; (gain &gt;= parameters.mute_factor)) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :           parameters.mute_factor = 0;</span>
<span class="lineNum">     287 </span>            :         } else {
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :           parameters.mute_factor = gain;</span>
<span class="lineNum">     289 </span>            :         }
<span class="lineNum">     290 </span>            :       }
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     // Background noise part.
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     GenerateBackgroundNoise(random_vector,</span>
<span class="lineNum">     295 </span>            :                             channel_ix,
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                             channel_parameters_[channel_ix].mute_slope,</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                             TooManyExpands(),</span>
<span class="lineNum">     298 </span>            :                             current_lag,
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :                             unvoiced_array_memory);</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     // Add background noise to the combined voiced-unvoiced signal.
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; current_lag; i++) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       temp_data[i] = temp_data[i] + noise_vector[i];</span>
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     if (channel_ix == 0) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :       output-&gt;AssertSize(current_lag);</span>
<span class="lineNum">     307 </span>            :     } else {
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       assert(output-&gt;Size() == current_lag);</span>
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     (*output)[channel_ix].OverwriteAt(temp_data, current_lag, 0);</span>
<span class="lineNum">     311 </span>            :   }
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :   // Increase call number and cap it.
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   consecutive_expands_ = consecutive_expands_ &gt;= kMaxConsecutiveExpands ?</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       kMaxConsecutiveExpands : consecutive_expands_ + 1;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   expand_duration_samples_ += output-&gt;Size();</span>
<span class="lineNum">     317 </span>            :   // Clamp the duration counter at 2 seconds.
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   expand_duration_samples_ =</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       std::min(expand_duration_samples_, rtc::checked_cast&lt;size_t&gt;(fs_hz_ * 2));</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="321"><span class="lineNum">     321 </span>            : }</a>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 : void Expand::SetParametersForNormalAfterExpand() {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   current_lag_index_ = 0;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   lag_index_direction_ = 0;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   stop_muting_ = true;  // Do not mute signal any more.</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   statistics_-&gt;LogDelayedPacketOutageEvent(</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       rtc::checked_cast&lt;int&gt;(expand_duration_samples_) / (fs_hz_ / 1000));</span>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineNoCov">          0 : void Expand::SetParametersForMergeAfterExpand() {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   current_lag_index_ = -1; /* out of the 3 possible ones */</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   lag_index_direction_ = 1; /* make sure we get the &quot;optimal&quot; lag */</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   stop_muting_ = true;</span>
<a name="335"><span class="lineNum">     335 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : bool Expand::Muted() const {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   if (first_expand_ || stop_muting_)</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   RTC_DCHECK(channel_parameters_);</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :   for (size_t ch = 0; ch &lt; num_channels_; ++ch) {</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if (channel_parameters_[ch].mute_factor != 0)</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">     344 </span>            :   }
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   return true;</span>
<a name="346"><span class="lineNum">     346 </span>            : }</a>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : size_t Expand::overlap_length() const {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   return overlap_length_;</span>
<a name="350"><span class="lineNum">     350 </span>            : }</a>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 : void Expand::InitializeForAnExpandPeriod() {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   lag_index_direction_ = 1;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   current_lag_index_ = -1;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   stop_muting_ = false;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   random_vector_-&gt;set_seed_increment(1);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   consecutive_expands_ = 0;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   for (size_t ix = 0; ix &lt; num_channels_; ++ix) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     channel_parameters_[ix].current_voice_mix_factor = 16384;  // 1.0 in Q14.</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     channel_parameters_[ix].mute_factor = 16384;  // 1.0 in Q14.</span>
<span class="lineNum">     361 </span>            :     // Start with 0 gain for background noise.
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     background_noise_-&gt;SetMuteFactor(ix, 0);</span>
<span class="lineNum">     363 </span>            :   }
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineNoCov">          0 : bool Expand::TooManyExpands() {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   return consecutive_expands_ &gt;= kMaxConsecutiveExpands;</span>
<a name="368"><span class="lineNum">     368 </span>            : }</a>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : void Expand::AnalyzeSignal(int16_t* random_vector) {</span>
<span class="lineNum">     371 </span>            :   int32_t auto_correlation[kUnvoicedLpcOrder + 1];
<span class="lineNum">     372 </span>            :   int16_t reflection_coeff[kUnvoicedLpcOrder];
<span class="lineNum">     373 </span>            :   int16_t correlation_vector[kMaxSampleRate / 8000 * 102];
<span class="lineNum">     374 </span>            :   size_t best_correlation_index[kNumCorrelationCandidates];
<span class="lineNum">     375 </span>            :   int16_t best_correlation[kNumCorrelationCandidates];
<span class="lineNum">     376 </span>            :   size_t best_distortion_index[kNumCorrelationCandidates];
<span class="lineNum">     377 </span>            :   int16_t best_distortion[kNumCorrelationCandidates];
<span class="lineNum">     378 </span>            :   int32_t correlation_vector2[(99 * kMaxSampleRate / 8000) + 1];
<span class="lineNum">     379 </span>            :   int32_t best_distortion_w32[kNumCorrelationCandidates];
<span class="lineNum">     380 </span>            :   static const size_t kNoiseLpcOrder = BackgroundNoise::kMaxLpcOrder;
<span class="lineNum">     381 </span>            :   int16_t unvoiced_array_memory[kNoiseLpcOrder + kMaxSampleRate / 8000 * 125];
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   int16_t* unvoiced_vector = unvoiced_array_memory + kUnvoicedLpcOrder;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   int fs_mult = fs_hz_ / 8000;</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   // Pre-calculate common multiplications with fs_mult.
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   size_t fs_mult_4 = static_cast&lt;size_t&gt;(fs_mult * 4);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   size_t fs_mult_20 = static_cast&lt;size_t&gt;(fs_mult * 20);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   size_t fs_mult_120 = static_cast&lt;size_t&gt;(fs_mult * 120);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   size_t fs_mult_dist_len = fs_mult * kDistortionLength;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   size_t fs_mult_lpc_analysis_len = fs_mult * kLpcAnalysisLength;</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   const size_t signal_length = static_cast&lt;size_t&gt;(256 * fs_mult);</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   const size_t audio_history_position = sync_buffer_-&gt;Size() - signal_length;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   std::unique_ptr&lt;int16_t[]&gt; audio_history(new int16_t[signal_length]);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   (*sync_buffer_)[0].CopyTo(signal_length, audio_history_position,</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                             audio_history.get());</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :   // Initialize.
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   InitializeForAnExpandPeriod();</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :   // Calculate correlation in downsampled domain (4 kHz sample rate).
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   size_t correlation_length = 51;  // TODO(hlundin): Legacy bit-exactness.</span>
<span class="lineNum">     405 </span>            :   // If it is decided to break bit-exactness |correlation_length| should be
<span class="lineNum">     406 </span>            :   // initialized to the return value of Correlation().
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   Correlation(audio_history.get(), signal_length, correlation_vector);</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :   // Find peaks in correlation vector.
<span class="lineNum">     410 </span>            :   DspHelper::PeakDetection(correlation_vector, correlation_length,
<span class="lineNum">     411 </span>            :                            kNumCorrelationCandidates, fs_mult,
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                            best_correlation_index, best_correlation);</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :   // Adjust peak locations; cross-correlation lags start at 2.5 ms
<span class="lineNum">     415 </span>            :   // (20 * fs_mult samples).
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   best_correlation_index[0] += fs_mult_20;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   best_correlation_index[1] += fs_mult_20;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   best_correlation_index[2] += fs_mult_20;</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   // Calculate distortion around the |kNumCorrelationCandidates| best lags.
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   int distortion_scale = 0;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; kNumCorrelationCandidates; i++) {</span>
<span class="lineNum">     423 </span>            :     size_t min_index = std::max(fs_mult_20,
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                                 best_correlation_index[i] - fs_mult_4);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     size_t max_index = std::min(fs_mult_120 - 1,</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                                 best_correlation_index[i] + fs_mult_4);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     best_distortion_index[i] = DspHelper::MinDistortion(</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - fs_mult_dist_len]), min_index,</span>
<span class="lineNum">     429 </span>            :         max_index, fs_mult_dist_len, &amp;best_distortion_w32[i]);
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     distortion_scale = std::max(16 - WebRtcSpl_NormW32(best_distortion_w32[i]),</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                                 distortion_scale);</span>
<span class="lineNum">     432 </span>            :   }
<span class="lineNum">     433 </span>            :   // Shift the distortion values to fit in 16 bits.
<span class="lineNum">     434 </span>            :   WebRtcSpl_VectorBitShiftW32ToW16(best_distortion, kNumCorrelationCandidates,
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                                    best_distortion_w32, distortion_scale);</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   // Find the maximizing index |i| of the cost function
<span class="lineNum">     438 </span>            :   // f[i] = best_correlation[i] / best_distortion[i].
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :   int32_t best_ratio = std::numeric_limits&lt;int32_t&gt;::min();</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   size_t best_index = std::numeric_limits&lt;size_t&gt;::max();</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; kNumCorrelationCandidates; ++i) {</span>
<span class="lineNum">     442 </span>            :     int32_t ratio;
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     if (best_distortion[i] &gt; 0) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :       ratio = (best_correlation[i] * (1 &lt;&lt; 16)) / best_distortion[i];</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     } else if (best_correlation[i] == 0) {</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       ratio = 0;  // No correlation set result to zero.</span>
<span class="lineNum">     447 </span>            :     } else {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       ratio = std::numeric_limits&lt;int32_t&gt;::max();  // Denominator is zero.</span>
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     if (ratio &gt; best_ratio) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       best_index = i;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       best_ratio = ratio;</span>
<span class="lineNum">     453 </span>            :     }
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   size_t distortion_lag = best_distortion_index[best_index];</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   size_t correlation_lag = best_correlation_index[best_index];</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   max_lag_ = std::max(distortion_lag, correlation_lag);</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   // Calculate the exact best correlation in the range between
<span class="lineNum">     461 </span>            :   // |correlation_lag| and |distortion_lag|.
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   correlation_length =</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       std::max(std::min(distortion_lag + 10, fs_mult_120),</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                static_cast&lt;size_t&gt;(60 * fs_mult));</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   size_t start_index = std::min(distortion_lag, correlation_lag);</span>
<span class="lineNum">     467 </span>            :   size_t correlation_lags = static_cast&lt;size_t&gt;(
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :       WEBRTC_SPL_ABS_W16((distortion_lag-correlation_lag)) + 1);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   assert(correlation_lags &lt;= static_cast&lt;size_t&gt;(99 * fs_mult + 1));</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   for (size_t channel_ix = 0; channel_ix &lt; num_channels_; ++channel_ix) {</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     ChannelParameters&amp; parameters = channel_parameters_[channel_ix];</span>
<span class="lineNum">     473 </span>            :     // Calculate suitable scaling.
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     int16_t signal_max = WebRtcSpl_MaxAbsValueW16(</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         &amp;audio_history[signal_length - correlation_length - start_index</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                        - correlation_lags],</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                        correlation_length + start_index + correlation_lags - 1);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     int correlation_scale = (31 - WebRtcSpl_NormW32(signal_max * signal_max)) +</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         (31 - WebRtcSpl_NormW32(static_cast&lt;int32_t&gt;(correlation_length))) - 31;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     correlation_scale = std::max(0, correlation_scale);</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     // Calculate the correlation, store in |correlation_vector2|.
<span class="lineNum">     483 </span>            :     WebRtcSpl_CrossCorrelation(
<span class="lineNum">     484 </span>            :         correlation_vector2,
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length]),</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length - start_index]),</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         correlation_length, correlation_lags, correlation_scale, -1);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :     // Find maximizing index.
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     best_index = WebRtcSpl_MaxIndexW32(correlation_vector2, correlation_lags);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     int32_t max_correlation = correlation_vector2[best_index];</span>
<span class="lineNum">     492 </span>            :     // Compensate index with start offset.
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     best_index = best_index + start_index;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :     // Calculate energies.
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     int32_t energy1 = WebRtcSpl_DotProductWithScale(</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length]),</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length]),</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         correlation_length, correlation_scale);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     int32_t energy2 = WebRtcSpl_DotProductWithScale(</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length - best_index]),</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         &amp;(audio_history[signal_length - correlation_length - best_index]),</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         correlation_length, correlation_scale);</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :     // Calculate the correlation coefficient between the two portions of the
<span class="lineNum">     506 </span>            :     // signal.
<span class="lineNum">     507 </span>            :     int32_t corr_coefficient;
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     if ((energy1 &gt; 0) &amp;&amp; (energy2 &gt; 0)) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       int energy1_scale = std::max(16 - WebRtcSpl_NormW32(energy1), 0);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :       int energy2_scale = std::max(16 - WebRtcSpl_NormW32(energy2), 0);</span>
<span class="lineNum">     511 </span>            :       // Make sure total scaling is even (to simplify scale factor after sqrt).
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :       if ((energy1_scale + energy2_scale) &amp; 1) {</span>
<span class="lineNum">     513 </span>            :         // If sum is odd, add 1 to make it even.
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         energy1_scale += 1;</span>
<span class="lineNum">     515 </span>            :       }
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       int32_t scaled_energy1 = energy1 &gt;&gt; energy1_scale;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :       int32_t scaled_energy2 = energy2 &gt;&gt; energy2_scale;</span>
<span class="lineNum">     518 </span>            :       int16_t sqrt_energy_product = static_cast&lt;int16_t&gt;(
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :           WebRtcSpl_SqrtFloor(scaled_energy1 * scaled_energy2));</span>
<span class="lineNum">     520 </span>            :       // Calculate max_correlation / sqrt(energy1 * energy2) in Q14.
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       int cc_shift = 14 - (energy1_scale + energy2_scale) / 2;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       max_correlation = WEBRTC_SPL_SHIFT_W32(max_correlation, cc_shift);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :       corr_coefficient = WebRtcSpl_DivW32W16(max_correlation,</span>
<span class="lineNum">     524 </span>            :                                              sqrt_energy_product);
<span class="lineNum">     525 </span>            :       // Cap at 1.0 in Q14.
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       corr_coefficient = std::min(16384, corr_coefficient);</span>
<span class="lineNum">     527 </span>            :     } else {
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       corr_coefficient = 0;</span>
<span class="lineNum">     529 </span>            :     }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :     // Extract the two vectors expand_vector0 and expand_vector1 from
<span class="lineNum">     532 </span>            :     // |audio_history|.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     size_t expansion_length = max_lag_ + overlap_length_;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     const int16_t* vector1 = &amp;(audio_history[signal_length - expansion_length]);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     const int16_t* vector2 = vector1 - distortion_lag;</span>
<span class="lineNum">     536 </span>            :     // Normalize the second vector to the same energy as the first.
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     energy1 = WebRtcSpl_DotProductWithScale(vector1, vector1, expansion_length,</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :                                             correlation_scale);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     energy2 = WebRtcSpl_DotProductWithScale(vector2, vector2, expansion_length,</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                                             correlation_scale);</span>
<span class="lineNum">     541 </span>            :     // Confirm that amplitude ratio sqrt(energy1 / energy2) is within 0.5 - 2.0,
<span class="lineNum">     542 </span>            :     // i.e., energy1 / energy2 is within 0.25 - 4.
<span class="lineNum">     543 </span>            :     int16_t amplitude_ratio;
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     if ((energy1 / 4 &lt; energy2) &amp;&amp; (energy1 &gt; energy2 / 4)) {</span>
<span class="lineNum">     545 </span>            :       // Energy constraint fulfilled. Use both vectors and scale them
<span class="lineNum">     546 </span>            :       // accordingly.
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :       int32_t scaled_energy2 = std::max(16 - WebRtcSpl_NormW32(energy2), 0);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :       int32_t scaled_energy1 = scaled_energy2 - 13;</span>
<span class="lineNum">     549 </span>            :       // Calculate scaled_energy1 / scaled_energy2 in Q13.
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :       int32_t energy_ratio = WebRtcSpl_DivW32W16(</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :           WEBRTC_SPL_SHIFT_W32(energy1, -scaled_energy1),</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :           static_cast&lt;int16_t&gt;(energy2 &gt;&gt; scaled_energy2));</span>
<span class="lineNum">     553 </span>            :       // Calculate sqrt ratio in Q13 (sqrt of en1/en2 in Q26).
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       amplitude_ratio =</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :           static_cast&lt;int16_t&gt;(WebRtcSpl_SqrtFloor(energy_ratio &lt;&lt; 13));</span>
<span class="lineNum">     556 </span>            :       // Copy the two vectors and give them the same energy.
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.Clear();</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.PushBack(vector1, expansion_length);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       parameters.expand_vector1.Clear();</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :       if (parameters.expand_vector1.Size() &lt; expansion_length) {</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :         parameters.expand_vector1.Extend(</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :             expansion_length - parameters.expand_vector1.Size());</span>
<span class="lineNum">     563 </span>            :       }
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       std::unique_ptr&lt;int16_t[]&gt; temp_1(new int16_t[expansion_length]);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :       WebRtcSpl_AffineTransformVector(temp_1.get(),</span>
<span class="lineNum">     566 </span>            :                                       const_cast&lt;int16_t*&gt;(vector2),
<span class="lineNum">     567 </span>            :                                       amplitude_ratio,
<span class="lineNum">     568 </span>            :                                       4096,
<span class="lineNum">     569 </span>            :                                       13,
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                                       expansion_length);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :       parameters.expand_vector1.OverwriteAt(temp_1.get(), expansion_length, 0);</span>
<span class="lineNum">     572 </span>            :     } else {
<span class="lineNum">     573 </span>            :       // Energy change constraint not fulfilled. Only use last vector.
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.Clear();</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.PushBack(vector1, expansion_length);</span>
<span class="lineNum">     576 </span>            :       // Copy from expand_vector0 to expand_vector1.
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       parameters.expand_vector0.CopyTo(&amp;parameters.expand_vector1);</span>
<span class="lineNum">     578 </span>            :       // Set the energy_ratio since it is used by muting slope.
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :       if ((energy1 / 4 &lt; energy2) || (energy2 == 0)) {</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         amplitude_ratio = 4096;  // 0.5 in Q13.</span>
<span class="lineNum">     581 </span>            :       } else {
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         amplitude_ratio = 16384;  // 2.0 in Q13.</span>
<span class="lineNum">     583 </span>            :       }
<span class="lineNum">     584 </span>            :     }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :     // Set the 3 lag values.
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     if (distortion_lag == correlation_lag) {</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :       expand_lags_[0] = distortion_lag;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       expand_lags_[1] = distortion_lag;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       expand_lags_[2] = distortion_lag;</span>
<span class="lineNum">     591 </span>            :     } else {
<span class="lineNum">     592 </span>            :       // |distortion_lag| and |correlation_lag| are not equal; use different
<span class="lineNum">     593 </span>            :       // combinations of the two.
<span class="lineNum">     594 </span>            :       // First lag is |distortion_lag| only.
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       expand_lags_[0] = distortion_lag;</span>
<span class="lineNum">     596 </span>            :       // Second lag is the average of the two.
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       expand_lags_[1] = (distortion_lag + correlation_lag) / 2;</span>
<span class="lineNum">     598 </span>            :       // Third lag is the average again, but rounding towards |correlation_lag|.
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       if (distortion_lag &gt; correlation_lag) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         expand_lags_[2] = (distortion_lag + correlation_lag - 1) / 2;</span>
<span class="lineNum">     601 </span>            :       } else {
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :         expand_lags_[2] = (distortion_lag + correlation_lag + 1) / 2;</span>
<span class="lineNum">     603 </span>            :       }
<span class="lineNum">     604 </span>            :     }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :     // Calculate the LPC and the gain of the filters.
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :     // Calculate kUnvoicedLpcOrder + 1 lags of the auto-correlation function.
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     size_t temp_index = signal_length - fs_mult_lpc_analysis_len -</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         kUnvoicedLpcOrder;</span>
<span class="lineNum">     611 </span>            :     // Copy signal to temporary vector to be able to pad with leading zeros.
<span class="lineNum">     612 </span>            :     int16_t* temp_signal = new int16_t[fs_mult_lpc_analysis_len
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                                        + kUnvoicedLpcOrder];</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     memset(temp_signal, 0,</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * (fs_mult_lpc_analysis_len + kUnvoicedLpcOrder));</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     memcpy(&amp;temp_signal[kUnvoicedLpcOrder],</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :            &amp;audio_history[temp_index + kUnvoicedLpcOrder],</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * fs_mult_lpc_analysis_len);</span>
<span class="lineNum">     619 </span>            :     CrossCorrelationWithAutoShift(
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         &amp;temp_signal[kUnvoicedLpcOrder], &amp;temp_signal[kUnvoicedLpcOrder],</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :         fs_mult_lpc_analysis_len, kUnvoicedLpcOrder + 1, -1, auto_correlation);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     delete [] temp_signal;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :     // Verify that variance is positive.
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     if (auto_correlation[0] &gt; 0) {</span>
<span class="lineNum">     626 </span>            :       // Estimate AR filter parameters using Levinson-Durbin algorithm;
<span class="lineNum">     627 </span>            :       // kUnvoicedLpcOrder + 1 filter coefficients.
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       int16_t stability = WebRtcSpl_LevinsonDurbin(auto_correlation,</span>
<span class="lineNum">     629 </span>            :                                                    parameters.ar_filter,
<span class="lineNum">     630 </span>            :                                                    reflection_coeff,
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                                                    kUnvoicedLpcOrder);</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :       // Keep filter parameters only if filter is stable.
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       if (stability != 1) {</span>
<span class="lineNum">     635 </span>            :         // Set first coefficient to 4096 (1.0 in Q12).
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         parameters.ar_filter[0] = 4096;</span>
<span class="lineNum">     637 </span>            :         // Set remaining |kUnvoicedLpcOrder| coefficients to zero.
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         WebRtcSpl_MemSetW16(parameters.ar_filter + 1, 0, kUnvoicedLpcOrder);</span>
<span class="lineNum">     639 </span>            :       }
<span class="lineNum">     640 </span>            :     }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     if (channel_ix == 0) {</span>
<span class="lineNum">     643 </span>            :       // Extract a noise segment.
<span class="lineNum">     644 </span>            :       size_t noise_length;
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       if (distortion_lag &lt; 40) {</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         noise_length = 2 * distortion_lag + 30;</span>
<span class="lineNum">     647 </span>            :       } else {
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         noise_length = distortion_lag + 30;</span>
<span class="lineNum">     649 </span>            :       }
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       if (noise_length &lt;= RandomVector::kRandomTableSize) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         memcpy(random_vector, RandomVector::kRandomTable,</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :                sizeof(int16_t) * noise_length);</span>
<span class="lineNum">     653 </span>            :       } else {
<span class="lineNum">     654 </span>            :         // Only applies to SWB where length could be larger than
<span class="lineNum">     655 </span>            :         // |kRandomTableSize|.
<span class="lineNum">     656 </span>            :         memcpy(random_vector, RandomVector::kRandomTable,
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                sizeof(int16_t) * RandomVector::kRandomTableSize);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         assert(noise_length &lt;= kMaxSampleRate / 8000 * 120 + 30);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         random_vector_-&gt;IncreaseSeedIncrement(2);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         random_vector_-&gt;Generate(</span>
<span class="lineNum">     661 </span>            :             noise_length - RandomVector::kRandomTableSize,
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :             &amp;random_vector[RandomVector::kRandomTableSize]);</span>
<span class="lineNum">     663 </span>            :       }
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :     // Set up state vector and calculate scale factor for unvoiced filtering.
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     memcpy(parameters.ar_filter_state,</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :            &amp;(audio_history[signal_length - kUnvoicedLpcOrder]),</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * kUnvoicedLpcOrder);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     memcpy(unvoiced_vector - kUnvoicedLpcOrder,</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :            &amp;(audio_history[signal_length - 128 - kUnvoicedLpcOrder]),</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * kUnvoicedLpcOrder);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     WebRtcSpl_FilterMAFastQ12(&amp;audio_history[signal_length - 128],</span>
<span class="lineNum">     674 </span>            :                               unvoiced_vector,
<span class="lineNum">     675 </span>            :                               parameters.ar_filter,
<a name="676"><span class="lineNum">     676 </span>            :                               kUnvoicedLpcOrder + 1,</a>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                               128);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     const int unvoiced_max_abs = [&amp;] {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :       const int16_t max_abs = WebRtcSpl_MaxAbsValueW16(unvoiced_vector, 128);</span>
<span class="lineNum">     680 </span>            :       // Since WebRtcSpl_MaxAbsValueW16 returns 2^15 - 1 when the input contains
<span class="lineNum">     681 </span>            :       // -2^15, we have to conservatively bump the return value by 1
<span class="lineNum">     682 </span>            :       // if it is 2^15 - 1.
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :       return max_abs == WEBRTC_SPL_WORD16_MAX ? max_abs + 1 : max_abs;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     }();</span>
<span class="lineNum">     685 </span>            :     // Pick the smallest n such that 2^n &gt; unvoiced_max_abs; then the maximum
<span class="lineNum">     686 </span>            :     // value of the dot product is less than 2^7 * 2^(2*n) = 2^(2*n + 7), so to
<span class="lineNum">     687 </span>            :     // prevent overflows we want 2n + 7 &lt;= 31, which means we should shift by
<span class="lineNum">     688 </span>            :     // 2n + 7 - 31 bits, if this value is greater than zero.
<span class="lineNum">     689 </span>            :     int unvoiced_prescale =
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         std::max(0, 2 * WebRtcSpl_GetSizeInBits(unvoiced_max_abs) - 24);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     int32_t unvoiced_energy = WebRtcSpl_DotProductWithScale(unvoiced_vector,</span>
<span class="lineNum">     693 </span>            :                                                             unvoiced_vector,
<span class="lineNum">     694 </span>            :                                                             128,
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                                                             unvoiced_prescale);</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :     // Normalize |unvoiced_energy| to 28 or 29 bits to preserve sqrt() accuracy.
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     int16_t unvoiced_scale = WebRtcSpl_NormW32(unvoiced_energy) - 3;</span>
<span class="lineNum">     699 </span>            :     // Make sure we do an odd number of shifts since we already have 7 shifts
<span class="lineNum">     700 </span>            :     // from dividing with 128 earlier. This will make the total scale factor
<span class="lineNum">     701 </span>            :     // even, which is suitable for the sqrt.
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     unvoiced_scale += ((unvoiced_scale &amp; 0x1) ^ 0x1);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     unvoiced_energy = WEBRTC_SPL_SHIFT_W32(unvoiced_energy, unvoiced_scale);</span>
<span class="lineNum">     704 </span>            :     int16_t unvoiced_gain =
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         static_cast&lt;int16_t&gt;(WebRtcSpl_SqrtFloor(unvoiced_energy));</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     parameters.ar_gain_scale = 13</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         + (unvoiced_scale + 7 - unvoiced_prescale) / 2;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     parameters.ar_gain = unvoiced_gain;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :     // Calculate voice_mix_factor from corr_coefficient.
<span class="lineNum">     711 </span>            :     // Let x = corr_coefficient. Then, we compute:
<span class="lineNum">     712 </span>            :     // if (x &gt; 0.48)
<span class="lineNum">     713 </span>            :     //   voice_mix_factor = (-5179 + 19931x - 16422x^2 + 5776x^3) / 4096;
<span class="lineNum">     714 </span>            :     // else
<span class="lineNum">     715 </span>            :     //   voice_mix_factor = 0;
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :     if (corr_coefficient &gt; 7875) {</span>
<span class="lineNum">     717 </span>            :       int16_t x1, x2, x3;
<span class="lineNum">     718 </span>            :       // |corr_coefficient| is in Q14.
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       x1 = static_cast&lt;int16_t&gt;(corr_coefficient);</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       x2 = (x1 * x1) &gt;&gt; 14;   // Shift 14 to keep result in Q14.</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       x3 = (x1 * x2) &gt;&gt; 14;</span>
<span class="lineNum">     722 </span>            :       static const int kCoefficients[4] = { -5179, 19931, -16422, 5776 };
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       int32_t temp_sum = kCoefficients[0] * 16384;</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       temp_sum += kCoefficients[1] * x1;</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       temp_sum += kCoefficients[2] * x2;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :       temp_sum += kCoefficients[3] * x3;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :       parameters.voice_mix_factor =</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :           static_cast&lt;int16_t&gt;(std::min(temp_sum / 4096, 16384));</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       parameters.voice_mix_factor = std::max(parameters.voice_mix_factor,</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                                              static_cast&lt;int16_t&gt;(0));</span>
<span class="lineNum">     731 </span>            :     } else {
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       parameters.voice_mix_factor = 0;</span>
<span class="lineNum">     733 </span>            :     }
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :     // Calculate muting slope. Reuse value from earlier scaling of
<span class="lineNum">     736 </span>            :     // |expand_vector0| and |expand_vector1|.
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     int16_t slope = amplitude_ratio;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     if (slope &gt; 12288) {</span>
<span class="lineNum">     739 </span>            :       // slope &gt; 1.5.
<span class="lineNum">     740 </span>            :       // Calculate (1 - (1 / slope)) / distortion_lag =
<span class="lineNum">     741 </span>            :       // (slope - 1) / (distortion_lag * slope).
<span class="lineNum">     742 </span>            :       // |slope| is in Q13, so 1 corresponds to 8192. Shift up to Q25 before
<span class="lineNum">     743 </span>            :       // the division.
<span class="lineNum">     744 </span>            :       // Shift the denominator from Q13 to Q5 before the division. The result of
<span class="lineNum">     745 </span>            :       // the division will then be in Q20.
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       int temp_ratio = WebRtcSpl_DivW32W16(</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :           (slope - 8192) &lt;&lt; 12,</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :           static_cast&lt;int16_t&gt;((distortion_lag * slope) &gt;&gt; 8));</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       if (slope &gt; 14746) {</span>
<span class="lineNum">     750 </span>            :         // slope &gt; 1.8.
<span class="lineNum">     751 </span>            :         // Divide by 2, with proper rounding.
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         parameters.mute_slope = (temp_ratio + 1) / 2;</span>
<span class="lineNum">     753 </span>            :       } else {
<span class="lineNum">     754 </span>            :         // Divide by 8, with proper rounding.
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         parameters.mute_slope = (temp_ratio + 4) / 8;</span>
<span class="lineNum">     756 </span>            :       }
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       parameters.onset = true;</span>
<span class="lineNum">     758 </span>            :     } else {
<span class="lineNum">     759 </span>            :       // Calculate (1 - slope) / distortion_lag.
<span class="lineNum">     760 </span>            :       // Shift |slope| by 7 to Q20 before the division. The result is in Q20.
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :       parameters.mute_slope = WebRtcSpl_DivW32W16(</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :           (8192 - slope) * 128, static_cast&lt;int16_t&gt;(distortion_lag));</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :       if (parameters.voice_mix_factor &lt;= 13107) {</span>
<span class="lineNum">     764 </span>            :         // Make sure the mute factor decreases from 1.0 to 0.9 in no more than
<span class="lineNum">     765 </span>            :         // 6.25 ms.
<span class="lineNum">     766 </span>            :         // mute_slope &gt;= 0.005 / fs_mult in Q20.
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         parameters.mute_slope = std::max(5243 / fs_mult, parameters.mute_slope);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       } else if (slope &gt; 8028) {</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         parameters.mute_slope = 0;</span>
<span class="lineNum">     770 </span>            :       }
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :       parameters.onset = false;</span>
<span class="lineNum">     772 </span>            :     }
<span class="lineNum">     773 </span>            :   }
<a name="774"><span class="lineNum">     774 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineNoCov">          0 : Expand::ChannelParameters::ChannelParameters()</span>
<span class="lineNum">     777 </span>            :     : mute_factor(16384),
<span class="lineNum">     778 </span>            :       ar_gain(0),
<span class="lineNum">     779 </span>            :       ar_gain_scale(0),
<span class="lineNum">     780 </span>            :       voice_mix_factor(0),
<span class="lineNum">     781 </span>            :       current_voice_mix_factor(0),
<span class="lineNum">     782 </span>            :       onset(false),
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       mute_slope(0) {</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :   memset(ar_filter, 0, sizeof(ar_filter));</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   memset(ar_filter_state, 0, sizeof(ar_filter_state));</span>
<a name="786"><span class="lineNum">     786 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 : void Expand::Correlation(const int16_t* input,</span>
<span class="lineNum">     789 </span>            :                          size_t input_length,
<span class="lineNum">     790 </span>            :                          int16_t* output) const {
<span class="lineNum">     791 </span>            :   // Set parameters depending on sample rate.
<span class="lineNum">     792 </span>            :   const int16_t* filter_coefficients;
<span class="lineNum">     793 </span>            :   size_t num_coefficients;
<span class="lineNum">     794 </span>            :   int16_t downsampling_factor;
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   if (fs_hz_ == 8000) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     num_coefficients = 3;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     downsampling_factor = 2;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     filter_coefficients = DspHelper::kDownsample8kHzTbl;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   } else if (fs_hz_ == 16000) {</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     num_coefficients = 5;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     downsampling_factor = 4;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     filter_coefficients = DspHelper::kDownsample16kHzTbl;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   } else if (fs_hz_ == 32000) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     num_coefficients = 7;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     downsampling_factor = 8;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     filter_coefficients = DspHelper::kDownsample32kHzTbl;</span>
<span class="lineNum">     807 </span>            :   } else {  // fs_hz_ == 48000.
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     num_coefficients = 7;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     downsampling_factor = 12;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     filter_coefficients = DspHelper::kDownsample48kHzTbl;</span>
<span class="lineNum">     811 </span>            :   }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :   // Correlate from lag 10 to lag 60 in downsampled domain.
<span class="lineNum">     814 </span>            :   // (Corresponds to 20-120 for narrow-band, 40-240 for wide-band, and so on.)
<span class="lineNum">     815 </span>            :   static const size_t kCorrelationStartLag = 10;
<span class="lineNum">     816 </span>            :   static const size_t kNumCorrelationLags = 54;
<span class="lineNum">     817 </span>            :   static const size_t kCorrelationLength = 60;
<span class="lineNum">     818 </span>            :   // Downsample to 4 kHz sample rate.
<span class="lineNum">     819 </span>            :   static const size_t kDownsampledLength = kCorrelationStartLag
<span class="lineNum">     820 </span>            :       + kNumCorrelationLags + kCorrelationLength;
<span class="lineNum">     821 </span>            :   int16_t downsampled_input[kDownsampledLength];
<span class="lineNum">     822 </span>            :   static const size_t kFilterDelay = 0;
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   WebRtcSpl_DownsampleFast(</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       input + input_length - kDownsampledLength * downsampling_factor,</span>
<span class="lineNum">     825 </span>            :       kDownsampledLength * downsampling_factor, downsampled_input,
<span class="lineNum">     826 </span>            :       kDownsampledLength, filter_coefficients, num_coefficients,
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       downsampling_factor, kFilterDelay);</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   // Normalize |downsampled_input| to using all 16 bits.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   int16_t max_value = WebRtcSpl_MaxAbsValueW16(downsampled_input,</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                                                kDownsampledLength);</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   int16_t norm_shift = 16 - WebRtcSpl_NormW32(max_value);</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   WebRtcSpl_VectorBitShiftW16(downsampled_input, kDownsampledLength,</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                               downsampled_input, norm_shift);</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :   int32_t correlation[kNumCorrelationLags];
<span class="lineNum">     837 </span>            :   CrossCorrelationWithAutoShift(
<span class="lineNum">     838 </span>            :       &amp;downsampled_input[kDownsampledLength - kCorrelationLength],
<span class="lineNum">     839 </span>            :       &amp;downsampled_input[kDownsampledLength - kCorrelationLength
<span class="lineNum">     840 </span>            :           - kCorrelationStartLag],
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :       kCorrelationLength, kNumCorrelationLags, -1, correlation);</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :   // Normalize and move data from 32-bit to 16-bit vector.
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :   int32_t max_correlation = WebRtcSpl_MaxAbsValueW32(correlation,</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                                                      kNumCorrelationLags);</span>
<span class="lineNum">     846 </span>            :   int16_t norm_shift2 = static_cast&lt;int16_t&gt;(
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :       std::max(18 - WebRtcSpl_NormW32(max_correlation), 0));</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   WebRtcSpl_VectorBitShiftW32ToW16(output, kNumCorrelationLags, correlation,</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                                    norm_shift2);</span>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineNoCov">          0 : void Expand::UpdateLagIndex() {</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   current_lag_index_ = current_lag_index_ + lag_index_direction_;</span>
<span class="lineNum">     854 </span>            :   // Change direction if needed.
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   if (current_lag_index_ &lt;= 0) {</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     lag_index_direction_ = 1;</span>
<span class="lineNum">     857 </span>            :   }
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   if (current_lag_index_ &gt;= kNumLags - 1) {</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :     lag_index_direction_ = -1;</span>
<span class="lineNum">     860 </span>            :   }
<a name="861"><span class="lineNum">     861 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 : Expand* ExpandFactory::Create(BackgroundNoise* background_noise,</span>
<span class="lineNum">     864 </span>            :                               SyncBuffer* sync_buffer,
<span class="lineNum">     865 </span>            :                               RandomVector* random_vector,
<span class="lineNum">     866 </span>            :                               StatisticsCalculator* statistics,
<span class="lineNum">     867 </span>            :                               int fs,
<span class="lineNum">     868 </span>            :                               size_t num_channels) const {
<span class="lineNum">     869 </span>            :   return new Expand(background_noise, sync_buffer, random_vector, statistics,
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :                     fs, num_channels);</span>
<span class="lineNum">     871 </span>            : }
<a name="872"><span class="lineNum">     872 </span>            : </a>
<span class="lineNum">     873 </span>            : // TODO(turajs): This can be moved to BackgroundNoise class.
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : void Expand::GenerateBackgroundNoise(int16_t* random_vector,</span>
<span class="lineNum">     875 </span>            :                                      size_t channel,
<span class="lineNum">     876 </span>            :                                      int mute_slope,
<span class="lineNum">     877 </span>            :                                      bool too_many_expands,
<span class="lineNum">     878 </span>            :                                      size_t num_noise_samples,
<span class="lineNum">     879 </span>            :                                      int16_t* buffer) {
<span class="lineNum">     880 </span>            :   static const size_t kNoiseLpcOrder = BackgroundNoise::kMaxLpcOrder;
<span class="lineNum">     881 </span>            :   int16_t scaled_random_vector[kMaxSampleRate / 8000 * 125];
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   assert(num_noise_samples &lt;= (kMaxSampleRate / 8000 * 125));</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   int16_t* noise_samples = &amp;buffer[kNoiseLpcOrder];</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   if (background_noise_-&gt;initialized()) {</span>
<span class="lineNum">     885 </span>            :     // Use background noise parameters.
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     memcpy(noise_samples - kNoiseLpcOrder,</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :            background_noise_-&gt;FilterState(channel),</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :            sizeof(int16_t) * kNoiseLpcOrder);</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     int dc_offset = 0;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     if (background_noise_-&gt;ScaleShift(channel) &gt; 1) {</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :       dc_offset = 1 &lt;&lt; (background_noise_-&gt;ScaleShift(channel) - 1);</span>
<span class="lineNum">     893 </span>            :     }
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            :     // Scale random vector to correct energy level.
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     WebRtcSpl_AffineTransformVector(</span>
<span class="lineNum">     897 </span>            :         scaled_random_vector, random_vector,
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         background_noise_-&gt;Scale(channel), dc_offset,</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         background_noise_-&gt;ScaleShift(channel),</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         num_noise_samples);</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     WebRtcSpl_FilterARFastQ12(scaled_random_vector, noise_samples,</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                               background_noise_-&gt;Filter(channel),</span>
<span class="lineNum">     904 </span>            :                               kNoiseLpcOrder + 1,
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :                               num_noise_samples);</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     background_noise_-&gt;SetFilterState(</span>
<span class="lineNum">     908 </span>            :         channel,
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :         &amp;(noise_samples[num_noise_samples - kNoiseLpcOrder]),</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         kNoiseLpcOrder);</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :     // Unmute the background noise.
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     int16_t bgn_mute_factor = background_noise_-&gt;MuteFactor(channel);</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     NetEq::BackgroundNoiseMode bgn_mode = background_noise_-&gt;mode();</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     if (bgn_mode == NetEq::kBgnFade &amp;&amp; too_many_expands &amp;&amp;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         bgn_mute_factor &gt; 0) {</span>
<span class="lineNum">     917 </span>            :       // Fade BGN to zero.
<span class="lineNum">     918 </span>            :       // Calculate muting slope, approximately -2^18 / fs_hz.
<span class="lineNum">     919 </span>            :       int mute_slope;
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       if (fs_hz_ == 8000) {</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         mute_slope = -32;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       } else if (fs_hz_ == 16000) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         mute_slope = -16;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       } else if (fs_hz_ == 32000) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         mute_slope = -8;</span>
<span class="lineNum">     926 </span>            :       } else {
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :         mute_slope = -5;</span>
<span class="lineNum">     928 </span>            :       }
<span class="lineNum">     929 </span>            :       // Use UnmuteSignal function with negative slope.
<span class="lineNum">     930 </span>            :       // |bgn_mute_factor| is in Q14. |mute_slope| is in Q20.
<span class="lineNum">     931 </span>            :       DspHelper::UnmuteSignal(noise_samples,
<span class="lineNum">     932 </span>            :                               num_noise_samples,
<span class="lineNum">     933 </span>            :                               &amp;bgn_mute_factor,
<span class="lineNum">     934 </span>            :                               mute_slope,
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :                               noise_samples);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     } else if (bgn_mute_factor &lt; 16384) {</span>
<span class="lineNum">     937 </span>            :       // If mode is kBgnOn, or if kBgnFade has started fading,
<span class="lineNum">     938 </span>            :       // use regular |mute_slope|.
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :       if (!stop_muting_ &amp;&amp; bgn_mode != NetEq::kBgnOff &amp;&amp;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :           !(bgn_mode == NetEq::kBgnFade &amp;&amp; too_many_expands)) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         DspHelper::UnmuteSignal(noise_samples,</span>
<span class="lineNum">     942 </span>            :                                 static_cast&lt;int&gt;(num_noise_samples),
<span class="lineNum">     943 </span>            :                                 &amp;bgn_mute_factor,
<span class="lineNum">     944 </span>            :                                 mute_slope,
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                                 noise_samples);</span>
<span class="lineNum">     946 </span>            :       } else {
<span class="lineNum">     947 </span>            :         // kBgnOn and stop muting, or
<span class="lineNum">     948 </span>            :         // kBgnOff (mute factor is always 0), or
<span class="lineNum">     949 </span>            :         // kBgnFade has reached 0.
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         WebRtcSpl_AffineTransformVector(noise_samples, noise_samples,</span>
<span class="lineNum">     951 </span>            :                                         bgn_mute_factor, 8192, 14,
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :                                         num_noise_samples);</span>
<span class="lineNum">     953 </span>            :       }
<span class="lineNum">     954 </span>            :     }
<span class="lineNum">     955 </span>            :     // Update mute_factor in BackgroundNoise class.
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     background_noise_-&gt;SetMuteFactor(channel, bgn_mute_factor);</span>
<span class="lineNum">     957 </span>            :   } else {
<span class="lineNum">     958 </span>            :     // BGN parameters have not been initialized; use zero noise.
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     memset(noise_samples, 0, sizeof(int16_t) * num_noise_samples);</span>
<span class="lineNum">     960 </span>            :   }
<a name="961"><span class="lineNum">     961 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineNoCov">          0 : void Expand::GenerateRandomVector(int16_t seed_increment,</span>
<span class="lineNum">     964 </span>            :                                   size_t length,
<span class="lineNum">     965 </span>            :                                   int16_t* random_vector) {
<span class="lineNum">     966 </span>            :   // TODO(turajs): According to hlundin The loop should not be needed. Should be
<span class="lineNum">     967 </span>            :   // just as good to generate all of the vector in one call.
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   size_t samples_generated = 0;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   const size_t kMaxRandSamples = RandomVector::kRandomTableSize;</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   while (samples_generated &lt; length) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     size_t rand_length = std::min(length - samples_generated, kMaxRandSamples);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     random_vector_-&gt;IncreaseSeedIncrement(seed_increment);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :     random_vector_-&gt;Generate(rand_length, &amp;random_vector[samples_generated]);</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     samples_generated += rand_length;</span>
<span class="lineNum">     975 </span>            :   }
<span class="lineNum">     976 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : }  // namespace webrtc
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

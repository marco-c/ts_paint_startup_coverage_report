<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/fix/source/pitch_estimator.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/fix/source</a> - pitch_estimator.c<span style="font-size: 80%;"> (source / <a href="pitch_estimator.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">205</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2011 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;webrtc/modules/audio_coding/codecs/isac/fix/source/pitch_estimator.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;webrtc/common_audio/signal_processing/include/signal_processing_library.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;webrtc/system_wrappers/include/compile_assert_c.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : /* log2[0.2, 0.5, 0.98] in Q8 */
<span class="lineNum">      16 </span>            : static const int16_t kLogLagWinQ8[3] = {
<span class="lineNum">      17 </span>            :   -594, -256, -7
<span class="lineNum">      18 </span>            : };
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : /* [1 -0.75 0.25] in Q12 */
<span class="lineNum">      21 </span>            : static const int16_t kACoefQ12[3] = {
<span class="lineNum">      22 </span>            :   4096, -3072, 1024
<a name="23"><span class="lineNum">      23 </span>            : };</a>
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span><span class="lineNoCov">          0 : int32_t WebRtcIsacfix_Log2Q8(uint32_t x) {</span>
<span class="lineNum">      26 </span>            :   int32_t zeros;
<span class="lineNum">      27 </span>            :   int16_t frac;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   zeros=WebRtcSpl_NormU32(x);</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :   frac = (int16_t)(((x &lt;&lt; zeros) &amp; 0x7FFFFFFF) &gt;&gt; 23);</span>
<span class="lineNum">      31 </span>            :   /* log2(magn(i)) */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   return ((31 - zeros) &lt;&lt; 8) + frac;</span>
<a name="34"><span class="lineNum">      34 </span>            : }</a>
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span><span class="lineNoCov">          0 : static __inline int16_t Exp2Q10(int16_t x) { // Both in and out in Q10</span>
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :   int16_t tmp16_1, tmp16_2;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   tmp16_2=(int16_t)(0x0400|(x&amp;0x03FF));</span>
<span class="lineNum">      41 </span><span class="lineNoCov">          0 :   tmp16_1 = -(x &gt;&gt; 10);</span>
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :   if(tmp16_1&gt;0)</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     return tmp16_2 &gt;&gt; tmp16_1;</span>
<span class="lineNum">      44 </span>            :   else
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :     return tmp16_2 &lt;&lt; -tmp16_1;</span>
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : }
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : 
<a name="50"><span class="lineNum">      50 </span>            : </a>
<span class="lineNum">      51 </span>            : /* 1D parabolic interpolation . All input and output values are in Q8 */
<span class="lineNum">      52 </span><span class="lineNoCov">          0 : static __inline void Intrp1DQ8(int32_t *x, int32_t *fx, int32_t *y, int32_t *fy) {</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   int16_t sign1=1, sign2=1;</span>
<span class="lineNum">      55 </span>            :   int32_t r32, q32, t32, nom32, den32;
<span class="lineNum">      56 </span>            :   int16_t t16, tmp16, tmp16_1;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   if ((fx[0]&gt;0) &amp;&amp; (fx[2]&gt;0)) {</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :     r32=fx[1]-fx[2];</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     q32=fx[0]-fx[1];</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     nom32=q32+r32;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :     den32 = (q32 - r32) * 2;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     if (nom32&lt;0)</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :       sign1=-1;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     if (den32&lt;0)</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :       sign2=-1;</span>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :     /* t = (q32+r32)/(2*(q32-r32)) = (fx[0]-fx[1] + fx[1]-fx[2])/(2 * fx[0]-fx[1] - (fx[1]-fx[2]))*/
<span class="lineNum">      69 </span>            :     /* (Signs are removed because WebRtcSpl_DivResultInQ31 can't handle negative numbers) */
<span class="lineNum">      70 </span>            :     /* t in Q31, without signs */
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     t32 = WebRtcSpl_DivResultInQ31(nom32 * sign1, den32 * sign2);</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     t16 = (int16_t)(t32 &gt;&gt; 23);  /* Q8 */</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     t16=t16*sign1*sign2;        /* t in Q8 with signs */</span>
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     *y = x[0]+t16;          /* Q8 */</span>
<span class="lineNum">      77 </span>            :     // *y = x[1]+t16;          /* Q8 */
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :     /* The following code calculates fy in three steps */
<span class="lineNum">      80 </span>            :     /* fy = 0.5 * t * (t-1) * fx[0] + (1-t*t) * fx[1] + 0.5 * t * (t+1) * fx[2]; */
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :     /* Part I: 0.5 * t * (t-1) * fx[0] */
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     tmp16_1 = (int16_t)(t16 * t16);  /* Q8*Q8=Q16 */</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     tmp16_1 &gt;&gt;= 2;  /* Q16&gt;&gt;2 = Q14 */</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     t16 &lt;&lt;= 6;  /* Q8&lt;&lt;6 = Q14  */</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     tmp16 = tmp16_1-t16;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     *fy = WEBRTC_SPL_MUL_16_32_RSFT15(tmp16, fx[0]); /* (Q14 * Q8 &gt;&gt;15)/2 = Q8 */</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     /* Part II: (1-t*t) * fx[1] */
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     tmp16 = 16384-tmp16_1;        /* 1 in Q14 - Q14 */</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     *fy += WEBRTC_SPL_MUL_16_32_RSFT14(tmp16, fx[1]);/* Q14 * Q8 &gt;&gt; 14 = Q8 */</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     /* Part III: 0.5 * t * (t+1) * fx[2] */
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     tmp16 = tmp16_1+t16;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     *fy += WEBRTC_SPL_MUL_16_32_RSFT15(tmp16, fx[2]);/* (Q14 * Q8 &gt;&gt;15)/2 = Q8 */</span>
<span class="lineNum">      96 </span>            :   } else {
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     *y = x[0];</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     *fy= fx[1];</span>
<span class="lineNum">      99 </span>            :   }
<span class="lineNum">     100 </span><span class="lineNoCov">          0 : }</span>
<a name="101"><span class="lineNum">     101 </span>            : </a>
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineNoCov">          0 : static void FindFour32(int32_t *in, int16_t length, int16_t *bestind)</span>
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   int32_t best[4]= {-100, -100, -100, -100};</span>
<span class="lineNum">     106 </span>            :   int16_t k;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   for (k=0; k&lt;length; k++) {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     if (in[k] &gt; best[3]) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :       if (in[k] &gt; best[2]) {</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :         if (in[k] &gt; best[1]) {</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :           if (in[k] &gt; best[0]) { // The Best</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :             best[3] = best[2];</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :             bestind[3] = bestind[2];</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             best[2] = best[1];</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :             bestind[2] = bestind[1];</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :             best[1] = best[0];</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             bestind[1] = bestind[0];</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :             best[0] = in[k];</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :             bestind[0] = k;</span>
<span class="lineNum">     121 </span>            :           } else { // 2nd best
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :             best[3] = best[2];</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             bestind[3] = bestind[2];</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :             best[2] = best[1];</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :             bestind[2] = bestind[1];</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :             best[1] = in[k];</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :             bestind[1] = k;</span>
<span class="lineNum">     128 </span>            :           }
<span class="lineNum">     129 </span>            :         } else { // 3rd best
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :           best[3] = best[2];</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :           bestind[3] = bestind[2];</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :           best[2] = in[k];</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :           bestind[2] = k;</span>
<span class="lineNum">     134 </span>            :         }
<span class="lineNum">     135 </span>            :       } else {  // 4th best
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         best[3] = in[k];</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         bestind[3] = k;</span>
<span class="lineNum">     138 </span>            :       }
<span class="lineNum">     139 </span>            :     }
<span class="lineNum">     140 </span>            :   }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : extern void WebRtcIsacfix_PCorr2Q32(const int16_t *in, int32_t *logcorQ8);
<span class="lineNum">     148 </span>            : 
<a name="149"><span class="lineNum">     149 </span>            : </a>
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 : void WebRtcIsacfix_InitialPitch(const int16_t *in, /* Q0 */</span>
<span class="lineNum">     152 </span>            :                                 PitchAnalysisStruct *State,
<span class="lineNum">     153 </span>            :                                 int16_t *lagsQ7                   /* Q7 */
<span class="lineNum">     154 </span>            :                                 )
<span class="lineNum">     155 </span>            : {
<span class="lineNum">     156 </span>            :   int16_t buf_dec16[PITCH_CORR_LEN2+PITCH_CORR_STEP2+PITCH_MAX_LAG/2+2];
<span class="lineNum">     157 </span>            :   int32_t *crrvecQ8_1,*crrvecQ8_2;
<span class="lineNum">     158 </span>            :   int32_t cv1q[PITCH_LAG_SPAN2+2],cv2q[PITCH_LAG_SPAN2+2], peakvq[PITCH_LAG_SPAN2+2];
<span class="lineNum">     159 </span>            :   int k;
<span class="lineNum">     160 </span>            :   int16_t peaks_indq;
<span class="lineNum">     161 </span>            :   int16_t peakiq[PITCH_LAG_SPAN2];
<span class="lineNum">     162 </span>            :   int32_t corr;
<span class="lineNum">     163 </span>            :   int32_t corr32, corr_max32, corr_max_o32;
<span class="lineNum">     164 </span>            :   int16_t npkq;
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   int16_t best4q[4]={0,0,0,0};</span>
<span class="lineNum">     166 </span>            :   int32_t xq[3],yq[1],fyq[1];
<span class="lineNum">     167 </span>            :   int32_t *fxq;
<span class="lineNum">     168 </span>            :   int32_t best_lag1q, best_lag2q;
<span class="lineNum">     169 </span>            :   int32_t tmp32a,tmp32b,lag32,ratq;
<span class="lineNum">     170 </span>            :   int16_t start;
<span class="lineNum">     171 </span>            :   int16_t oldgQ12, tmp16a, tmp16b, gain_bias16,tmp16c, tmp16d, bias16;
<span class="lineNum">     172 </span>            :   int32_t tmp32c,tmp32d, tmp32e;
<span class="lineNum">     173 </span>            :   int16_t old_lagQ;
<span class="lineNum">     174 </span>            :   int32_t old_lagQ8;
<span class="lineNum">     175 </span>            :   int32_t lagsQ8[4];
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   old_lagQ = State-&gt;PFstr_wght.oldlagQ7; // Q7</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   old_lagQ8 = old_lagQ &lt;&lt; 1;  // Q8</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   oldgQ12= State-&gt;PFstr_wght.oldgainQ12;</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   crrvecQ8_1=&amp;cv1q[1];</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   crrvecQ8_2=&amp;cv2q[1];</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :   /* copy old values from state buffer */
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   memcpy(buf_dec16, State-&gt;dec_buffer16, sizeof(State-&gt;dec_buffer16));</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   /* decimation; put result after the old values */
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_DecimateAllpass32(in, State-&gt;decimator_state32, PITCH_FRAME_LEN,</span>
<span class="lineNum">     191 </span>            :                                   &amp;buf_dec16[PITCH_CORR_LEN2+PITCH_CORR_STEP2+PITCH_MAX_LAG/2-PITCH_FRAME_LEN/2+2]);
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   /* low-pass filtering */
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   start= PITCH_CORR_LEN2+PITCH_CORR_STEP2+PITCH_MAX_LAG/2-PITCH_FRAME_LEN/2+2;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   WebRtcSpl_FilterARFastQ12(&amp;buf_dec16[start],&amp;buf_dec16[start],(int16_t*)kACoefQ12,3, PITCH_FRAME_LEN/2);</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   /* copy end part back into state buffer */
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; (PITCH_CORR_LEN2+PITCH_CORR_STEP2+PITCH_MAX_LAG/2-PITCH_FRAME_LEN/2+2); k++)</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     State-&gt;dec_buffer16[k] = buf_dec16[k+PITCH_FRAME_LEN/2];</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :   /* compute correlation for first and second half of the frame */
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_PCorr2Q32(buf_dec16, crrvecQ8_1);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_PCorr2Q32(buf_dec16 + PITCH_CORR_STEP2, crrvecQ8_2);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /* bias towards pitch lag of previous frame */
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   tmp32a = WebRtcIsacfix_Log2Q8((uint32_t) old_lagQ8) - 2304;</span>
<span class="lineNum">     209 </span>            :       // log2(0.5*oldlag) in Q8
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   tmp32b = oldgQ12 * oldgQ12 &gt;&gt; 10;  // Q12 &amp; * 4.0;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   gain_bias16 = (int16_t) tmp32b;  //Q12</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   if (gain_bias16 &gt; 3276) gain_bias16 = 3276; // 0.8 in Q12</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; PITCH_LAG_SPAN2; k++)</span>
<span class="lineNum">     216 </span>            :   {
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     if (crrvecQ8_1[k]&gt;0) {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :       tmp32b = WebRtcIsacfix_Log2Q8((uint32_t) (k + (PITCH_MIN_LAG/2-2)));</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :       tmp16a = (int16_t) (tmp32b - tmp32a); // Q8 &amp; fabs(ratio)&lt;4</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       tmp32c = tmp16a * tmp16a &gt;&gt; 6;  // Q10</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       tmp16b = (int16_t) tmp32c; // Q10 &amp; &lt;8</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :       tmp32d = tmp16b * 177 &gt;&gt; 8;  // mult with ln2 in Q8</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       tmp16c = (int16_t) tmp32d; // Q10 &amp; &lt;4</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :       tmp16d = Exp2Q10((int16_t) -tmp16c); //Q10</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :       tmp32c = gain_bias16 * tmp16d &gt;&gt; 13;  // Q10  &amp; * 0.5</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :       bias16 = (int16_t) (1024 + tmp32c); // Q10</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :       tmp32b = WebRtcIsacfix_Log2Q8((uint32_t)bias16) - 2560;</span>
<span class="lineNum">     228 </span>            :           // Q10 in -&gt; Q8 out with 10*2^8 offset
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :       crrvecQ8_1[k] += tmp32b ; // -10*2^8 offset</span>
<span class="lineNum">     230 </span>            :     }
<span class="lineNum">     231 </span>            :   }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   /* taper correlation functions */
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 3; k++) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     crrvecQ8_1[k] += kLogLagWinQ8[k];</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     crrvecQ8_2[k] += kLogLagWinQ8[k];</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     crrvecQ8_1[PITCH_LAG_SPAN2-1-k] += kLogLagWinQ8[k];</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     crrvecQ8_2[PITCH_LAG_SPAN2-1-k] += kLogLagWinQ8[k];</span>
<span class="lineNum">     240 </span>            :   }
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   /* Make zeropadded corr vectors */
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   cv1q[0]=0;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   cv2q[0]=0;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   cv1q[PITCH_LAG_SPAN2+1]=0;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :   cv2q[PITCH_LAG_SPAN2+1]=0;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   corr_max32 = 0;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt;= PITCH_LAG_SPAN2; k++)</span>
<span class="lineNum">     251 </span>            :   {
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     corr32=crrvecQ8_1[k-1];</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     if (corr32 &gt; corr_max32)</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       corr_max32 = corr32;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     corr32=crrvecQ8_2[k-1];</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     corr32 += -4; // Compensate for later (log2(0.99))</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     if (corr32 &gt; corr_max32)</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       corr_max32 = corr32;</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   /* threshold value to qualify as a peak */
<span class="lineNum">     267 </span>            :   // corr_max32 += -726; // log(0.14)/log(2.0) in Q8
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   corr_max32 += -1000; // log(0.14)/log(2.0) in Q8</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   corr_max_o32 = corr_max32;</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :   /* find peaks in corr1 */
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   peaks_indq = 0;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt;= PITCH_LAG_SPAN2; k++)</span>
<span class="lineNum">     275 </span>            :   {
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     corr32=cv1q[k];</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if (corr32&gt;corr_max32) { // Disregard small peaks</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       if ((corr32&gt;=cv1q[k-1]) &amp;&amp; (corr32&gt;cv1q[k+1])) { // Peak?</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         peakvq[peaks_indq] = corr32;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         peakiq[peaks_indq++] = k;</span>
<span class="lineNum">     281 </span>            :       }
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span>            :   }
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :   /* find highest interpolated peak */
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   corr_max32=0;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   best_lag1q =0;</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   if (peaks_indq &gt; 0) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     FindFour32(peakvq, (int16_t) peaks_indq, best4q);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     npkq = WEBRTC_SPL_MIN(peaks_indq, 4);</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     for (k=0;k&lt;npkq;k++) {</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       lag32 =  peakiq[best4q[k]];</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       fxq = &amp;cv1q[peakiq[best4q[k]]-1];</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :       xq[0]= lag32;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :       xq[0] &lt;&lt;= 8;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       Intrp1DQ8(xq, fxq, yq, fyq);</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       tmp32a= WebRtcIsacfix_Log2Q8((uint32_t) *yq) - 2048; // offset 8*2^8</span>
<span class="lineNum">     302 </span>            :       /* Bias towards short lags */
<span class="lineNum">     303 </span>            :       /* log(pow(0.8, log(2.0 * *y )))/log(2.0) */
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       tmp32b = (int16_t)tmp32a * -42 &gt;&gt; 8;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       tmp32c= tmp32b + 256;</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :       *fyq += tmp32c;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       if (*fyq &gt; corr_max32) {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         corr_max32 = *fyq;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         best_lag1q = *yq;</span>
<span class="lineNum">     310 </span>            :       }
<span class="lineNum">     311 </span>            :     }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     tmp32b = (best_lag1q - OFFSET_Q8) * 2;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     lagsQ8[0] = tmp32b + PITCH_MIN_LAG_Q8;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     lagsQ8[1] = lagsQ8[0];</span>
<span class="lineNum">     315 </span>            :   } else {
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     lagsQ8[0] = old_lagQ8;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     lagsQ8[1] = lagsQ8[0];</span>
<span class="lineNum">     318 </span>            :   }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   /* Bias towards constant pitch */
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   tmp32a = lagsQ8[0] - PITCH_MIN_LAG_Q8;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   ratq = (tmp32a &gt;&gt; 1) + OFFSET_Q8;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt;= PITCH_LAG_SPAN2; k++)</span>
<span class="lineNum">     325 </span>            :   {
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     tmp32a = k &lt;&lt; 7; // 0.5*k Q8</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     tmp32b = tmp32a * 2 - ratq;  // Q8</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     tmp32c = (int16_t)tmp32b * (int16_t)tmp32b &gt;&gt; 8;  // Q8</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     tmp32b = tmp32c + (ratq &gt;&gt; 1);</span>
<span class="lineNum">     331 </span>            :         // (k-r)^2 + 0.5 * r  Q8
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     tmp32c = WebRtcIsacfix_Log2Q8((uint32_t)tmp32a) - 2048;</span>
<span class="lineNum">     333 </span>            :         // offset 8*2^8 , log2(0.5*k) Q8
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     tmp32d = WebRtcIsacfix_Log2Q8((uint32_t)tmp32b) - 2048;</span>
<span class="lineNum">     335 </span>            :         // offset 8*2^8 , log2(0.5*k) Q8
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     tmp32e =  tmp32c - tmp32d;</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     cv2q[k] += tmp32e &gt;&gt; 1;</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   /* find peaks in corr2 */
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   corr_max32 = corr_max_o32;</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   peaks_indq = 0;</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   for (k = 1; k &lt;= PITCH_LAG_SPAN2; k++)</span>
<span class="lineNum">     347 </span>            :   {
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     corr=cv2q[k];</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if (corr&gt;corr_max32) { // Disregard small peaks</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       if ((corr&gt;=cv2q[k-1]) &amp;&amp; (corr&gt;cv2q[k+1])) { // Peak?</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         peakvq[peaks_indq] = corr;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         peakiq[peaks_indq++] = k;</span>
<span class="lineNum">     353 </span>            :       }
<span class="lineNum">     354 </span>            :     }
<span class="lineNum">     355 </span>            :   }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   /* find highest interpolated peak */
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   corr_max32 = 0;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   best_lag2q =0;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   if (peaks_indq &gt; 0) {</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     FindFour32(peakvq, (int16_t) peaks_indq, best4q);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     npkq = WEBRTC_SPL_MIN(peaks_indq, 4);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     for (k=0;k&lt;npkq;k++) {</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       lag32 =  peakiq[best4q[k]];</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       fxq = &amp;cv2q[peakiq[best4q[k]]-1];</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       xq[0]= lag32;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       xq[0] &lt;&lt;= 8;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :       Intrp1DQ8(xq, fxq, yq, fyq);</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :       /* Bias towards short lags */
<span class="lineNum">     376 </span>            :       /* log(pow(0.8, log(2.0f * *y )))/log(2.0f) */
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       tmp32a= WebRtcIsacfix_Log2Q8((uint32_t) *yq) - 2048; // offset 8*2^8</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       tmp32b = (int16_t)tmp32a * -82 &gt;&gt; 8;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :       tmp32c= tmp32b + 256;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       *fyq += tmp32c;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       if (*fyq &gt; corr_max32) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         corr_max32 = *fyq;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         best_lag2q = *yq;</span>
<span class="lineNum">     384 </span>            :       }
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     tmp32b = (best_lag2q - OFFSET_Q8) * 2;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     lagsQ8[2] = tmp32b + PITCH_MIN_LAG_Q8;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     lagsQ8[3] = lagsQ8[2];</span>
<span class="lineNum">     390 </span>            :   } else {
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     lagsQ8[2] = lagsQ8[0];</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     lagsQ8[3] = lagsQ8[0];</span>
<span class="lineNum">     393 </span>            :   }
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   lagsQ7[0] = (int16_t)(lagsQ8[0] &gt;&gt; 1);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   lagsQ7[1] = (int16_t)(lagsQ8[1] &gt;&gt; 1);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   lagsQ7[2] = (int16_t)(lagsQ8[2] &gt;&gt; 1);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   lagsQ7[3] = (int16_t)(lagsQ8[3] &gt;&gt; 1);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     400 </span>            : 
<a name="401"><span class="lineNum">     401 </span>            : </a>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : void WebRtcIsacfix_PitchAnalysis(const int16_t *inn,               /* PITCH_FRAME_LEN samples */</span>
<span class="lineNum">     404 </span>            :                                  int16_t *outQ0,                  /* PITCH_FRAME_LEN+QLOOKAHEAD samples */
<span class="lineNum">     405 </span>            :                                  PitchAnalysisStruct *State,
<span class="lineNum">     406 </span>            :                                  int16_t *PitchLags_Q7,
<span class="lineNum">     407 </span>            :                                  int16_t *PitchGains_Q12)
<span class="lineNum">     408 </span>            : {
<span class="lineNum">     409 </span>            :   int16_t inbufQ0[PITCH_FRAME_LEN + QLOOKAHEAD];
<span class="lineNum">     410 </span>            :   int16_t k;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :   /* inital pitch estimate */
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_InitialPitch(inn, State,  PitchLags_Q7);</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   /* Calculate gain */
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_PitchFilterGains(inn, &amp;(State-&gt;PFstr_wght), PitchLags_Q7, PitchGains_Q12);</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   /* concatenate previous input's end and current input */
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; QLOOKAHEAD; k++) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     inbufQ0[k] = State-&gt;inbuf[k];</span>
<span class="lineNum">     422 </span>            :   }
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; PITCH_FRAME_LEN; k++) {</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     inbufQ0[k+QLOOKAHEAD] = (int16_t) inn[k];</span>
<span class="lineNum">     425 </span>            :   }
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   /* lookahead pitch filtering for masking analysis */
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_PitchFilter(inbufQ0, outQ0, &amp;(State-&gt;PFstr), PitchLags_Q7,PitchGains_Q12, 2);</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   /* store last part of input */
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; QLOOKAHEAD; k++) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     State-&gt;inbuf[k] = inbufQ0[k + PITCH_FRAME_LEN];</span>
<span class="lineNum">     434 </span>            :   }
<span class="lineNum">     435 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

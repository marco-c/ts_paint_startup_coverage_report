<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/main/source/encode.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/main/source</a> - encode.c<span style="font-size: 80%;"> (source / <a href="encode.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">459</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : /*
<span class="lineNum">      12 </span>            :  * encode.c
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * This file contains definition of funtions for encoding.
<span class="lineNum">      15 </span>            :  * Decoding of upper-band, including 8-12 kHz, when the bandwidth is
<span class="lineNum">      16 </span>            :  * 0-12 kHz, and 8-16 kHz, when the bandwidth is 0-16 kHz.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;structs.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;codec.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;pitch_estimator.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;entropy_coding.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;arith_routines.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;pitch_gain_tables.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;pitch_lag_tables.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;spectrum_ar_model_tables.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;lpc_tables.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;lpc_analysis.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;bandwidth_estimator.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;lpc_shape_swb12_tables.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;lpc_shape_swb16_tables.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;lpc_gain_swb_tables.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #define UB_LOOKAHEAD 24
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /*
<span class="lineNum">      44 </span>            :   Rate allocation tables of lower and upper-band bottleneck for
<span class="lineNum">      45 </span>            :   12kHz &amp; 16kHz bandwidth.
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :   12 kHz bandwidth
<span class="lineNum">      48 </span>            :   -----------------
<span class="lineNum">      49 </span>            :   The overall bottleneck of the coder is between 38 kbps and 45 kbps. We have
<span class="lineNum">      50 </span>            :   considered 7 enteries, uniformly distributed in this interval, i.e. 38,
<span class="lineNum">      51 </span>            :   39.17, 40.33, 41.5, 42.67, 43.83 and 45. For every entery, the lower-band
<span class="lineNum">      52 </span>            :   and the upper-band bottlenecks are specified in
<span class="lineNum">      53 </span>            :   'kLowerBandBitRate12' and 'kUpperBandBitRate12'
<span class="lineNum">      54 </span>            :   tables, respectively. E.g. the overall rate of 41.5 kbps corresponts to a
<span class="lineNum">      55 </span>            :   bottleneck of 31 kbps for lower-band and 27 kbps for upper-band. Given an
<span class="lineNum">      56 </span>            :   overall bottleneck of the codec, we use linear interpolation to get
<span class="lineNum">      57 </span>            :   lower-band and upper-band bottlenecks.
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            :   16 kHz bandwidth
<span class="lineNum">      60 </span>            :   -----------------
<span class="lineNum">      61 </span>            :   The overall bottleneck of the coder is between 50 kbps and 56 kbps. We have
<span class="lineNum">      62 </span>            :   considered 7 enteries, uniformly distributed in this interval, i.e. 50, 51.2,
<span class="lineNum">      63 </span>            :   52.4, 53.6, 54.8 and 56. For every entery, the lower-band and the upper-band
<span class="lineNum">      64 </span>            :   bottlenecks are specified in 'kLowerBandBitRate16' and
<span class="lineNum">      65 </span>            :   'kUpperBandBitRate16' tables, respectively. E.g. the overall rate
<span class="lineNum">      66 </span>            :   of 53.6 kbps corresponts to a bottleneck of 32 kbps for lower-band and 30
<span class="lineNum">      67 </span>            :   kbps for upper-band. Given an overall bottleneck of the codec, we use linear
<span class="lineNum">      68 </span>            :   interpolation to get lower-band and upper-band bottlenecks.
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :  */
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /*     38  39.17  40.33   41.5  42.67  43.83     45 */
<span class="lineNum">      73 </span>            : static const int16_t kLowerBandBitRate12[7] = {
<span class="lineNum">      74 </span>            :     29000, 30000, 30000, 31000, 31000, 32000, 32000 };
<span class="lineNum">      75 </span>            : static const int16_t kUpperBandBitRate12[7] = {
<span class="lineNum">      76 </span>            :     25000, 25000, 27000, 27000, 29000, 29000, 32000 };
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /*    50     51.2  52.4   53.6   54.8    56 */
<span class="lineNum">      79 </span>            : static const int16_t kLowerBandBitRate16[6] = {
<span class="lineNum">      80 </span>            :     31000, 31000, 32000, 32000, 32000, 32000 };
<span class="lineNum">      81 </span>            : static const int16_t kUpperBandBitRate16[6] = {
<span class="lineNum">      82 </span>            :     28000, 29000, 29000, 30000, 31000, 32000 };
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : /******************************************************************************
<span class="lineNum">      85 </span>            :  * WebRtcIsac_RateAllocation()
<span class="lineNum">      86 </span>            :  * Internal function to perform a rate-allocation for upper and lower-band,
<span class="lineNum">      87 </span>            :  * given a total rate.
<span class="lineNum">      88 </span>            :  *
<span class="lineNum">      89 </span>            :  * Input:
<span class="lineNum">      90 </span>            :  *   - inRateBitPerSec           : a total bottleneck in bits/sec.
<span class="lineNum">      91 </span>            :  *
<span class="lineNum">      92 </span>            :  * Output:
<span class="lineNum">      93 </span>            :  *   - rateLBBitPerSec           : a bottleneck allocated to the lower-band
<span class="lineNum">      94 </span>            :  *                                 in bits/sec.
<span class="lineNum">      95 </span>            :  *   - rateUBBitPerSec           : a bottleneck allocated to the upper-band
<span class="lineNum">      96 </span>            :  *                                 in bits/sec.
<span class="lineNum">      97 </span>            :  *
<span class="lineNum">      98 </span>            :  * Return value                  : 0 if rate allocation has been successful.
<span class="lineNum">      99 </span>            :  *                                -1 if failed to allocate rates.
<a name="100"><span class="lineNum">     100 </span>            :  */</a>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineNoCov">          0 : int16_t WebRtcIsac_RateAllocation(int32_t inRateBitPerSec,</span>
<span class="lineNum">     103 </span>            :                                         double* rateLBBitPerSec,
<span class="lineNum">     104 </span>            :                                         double* rateUBBitPerSec,
<span class="lineNum">     105 </span>            :                                         enum ISACBandwidth* bandwidthKHz) {
<span class="lineNum">     106 </span>            :   int16_t idx;
<span class="lineNum">     107 </span>            :   double idxD;
<span class="lineNum">     108 </span>            :   double idxErr;
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   if (inRateBitPerSec &lt; 38000) {</span>
<span class="lineNum">     110 </span>            :     /* If the given overall bottleneck is less than 38000 then
<span class="lineNum">     111 </span>            :      * then codec has to operate in wideband mode, i.e. 8 kHz
<span class="lineNum">     112 </span>            :      * bandwidth. */
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :     *rateLBBitPerSec = (int16_t)((inRateBitPerSec &gt; 32000) ?</span>
<span class="lineNum">     114 </span>            :         32000 : inRateBitPerSec);
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     *rateUBBitPerSec = 0;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :     *bandwidthKHz = isac8kHz;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   } else if ((inRateBitPerSec &gt;= 38000) &amp;&amp; (inRateBitPerSec &lt; 50000)) {</span>
<span class="lineNum">     118 </span>            :     /* At a bottleneck between 38 and 50 kbps the codec is operating
<span class="lineNum">     119 </span>            :      * at 12 kHz bandwidth. Using xxxBandBitRate12[] to calculates
<span class="lineNum">     120 </span>            :      * upper/lower bottleneck */
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     /* Find the bottlenecks by linear interpolation,
<span class="lineNum">     123 </span>            :      * step is (45000 - 38000)/6.0 we use the inverse of it. */
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     const double stepSizeInv = 8.5714286e-4;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     idxD = (inRateBitPerSec - 38000) * stepSizeInv;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     idx = (idxD &gt;= 6) ? 6 : ((int16_t)idxD);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     idxErr = idxD - idx;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     *rateLBBitPerSec = kLowerBandBitRate12[idx];</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     *rateUBBitPerSec = kUpperBandBitRate12[idx];</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     if (idx &lt; 6) {</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :       *rateLBBitPerSec += (int16_t)(</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :           idxErr * (kLowerBandBitRate12[idx + 1] - kLowerBandBitRate12[idx]));</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       *rateUBBitPerSec += (int16_t)(</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :           idxErr * (kUpperBandBitRate12[idx + 1] - kUpperBandBitRate12[idx]));</span>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     *bandwidthKHz = isac12kHz;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   } else if ((inRateBitPerSec &gt;= 50000) &amp;&amp; (inRateBitPerSec &lt;= 56000)) {</span>
<span class="lineNum">     139 </span>            :     /* A bottleneck between 50 and 56 kbps corresponds to bandwidth
<span class="lineNum">     140 </span>            :      * of 16 kHz. Using xxxBandBitRate16[] to calculates
<span class="lineNum">     141 </span>            :      * upper/lower bottleneck. */
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :     /* Find the bottlenecks by linear interpolation
<span class="lineNum">     144 </span>            :      * step is (56000 - 50000)/5 we use the inverse of it. */
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     const double stepSizeInv = 8.3333333e-4;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     idxD = (inRateBitPerSec - 50000) * stepSizeInv;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     idx = (idxD &gt;= 5) ? 5 : ((int16_t)idxD);</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     idxErr = idxD - idx;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     *rateLBBitPerSec = kLowerBandBitRate16[idx];</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     *rateUBBitPerSec  = kUpperBandBitRate16[idx];</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     if (idx &lt; 5) {</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :       *rateLBBitPerSec += (int16_t)(idxErr *</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :           (kLowerBandBitRate16[idx + 1] -</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :               kLowerBandBitRate16[idx]));</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :       *rateUBBitPerSec += (int16_t)(idxErr *</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :           (kUpperBandBitRate16[idx + 1] -</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :               kUpperBandBitRate16[idx]));</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     *bandwidthKHz = isac16kHz;</span>
<span class="lineNum">     162 </span>            :   } else {
<span class="lineNum">     163 </span>            :     /* Out-of-range botlteneck value. */
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     165 </span>            :   }
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :   /* limit the values. */
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   *rateLBBitPerSec = (*rateLBBitPerSec &gt; 32000) ? 32000 : *rateLBBitPerSec;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   *rateUBBitPerSec = (*rateUBBitPerSec &gt; 32000) ? 32000 : *rateUBBitPerSec;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     171 </span>            : }
<a name="172"><span class="lineNum">     172 </span>            : </a>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineNoCov">          0 : void WebRtcIsac_ResetBitstream(Bitstr* bit_stream) {</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   bit_stream-&gt;W_upper = 0xFFFFFFFF;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   bit_stream-&gt;stream_index = 0;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   bit_stream-&gt;streamval = 0;</span>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : int WebRtcIsac_EncodeLb(const TransformTables* transform_tables,</span>
<span class="lineNum">     181 </span>            :                         float* in, ISACLBEncStruct* ISACencLB_obj,
<span class="lineNum">     182 </span>            :                         int16_t codingMode,
<span class="lineNum">     183 </span>            :                         int16_t bottleneckIndex) {
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   int stream_length = 0;</span>
<span class="lineNum">     185 </span>            :   int err;
<span class="lineNum">     186 </span>            :   int k;
<span class="lineNum">     187 </span>            :   int iterCntr;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   double lofilt_coef[(ORDERLO + 1)*SUBFRAMES];
<span class="lineNum">     190 </span>            :   double hifilt_coef[(ORDERHI + 1)*SUBFRAMES];
<span class="lineNum">     191 </span>            :   float LP[FRAMESAMPLES_HALF];
<span class="lineNum">     192 </span>            :   float HP[FRAMESAMPLES_HALF];
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   double LP_lookahead[FRAMESAMPLES_HALF];
<span class="lineNum">     195 </span>            :   double HP_lookahead[FRAMESAMPLES_HALF];
<span class="lineNum">     196 </span>            :   double LP_lookahead_pf[FRAMESAMPLES_HALF + QLOOKAHEAD];
<span class="lineNum">     197 </span>            :   double LPw[FRAMESAMPLES_HALF];
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   double HPw[FRAMESAMPLES_HALF];
<span class="lineNum">     200 </span>            :   double LPw_pf[FRAMESAMPLES_HALF];
<span class="lineNum">     201 </span>            :   int16_t fre[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     202 </span>            :   int16_t fim[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :   double PitchLags[4];
<span class="lineNum">     205 </span>            :   double PitchGains[4];
<span class="lineNum">     206 </span>            :   int16_t PitchGains_Q12[4];
<span class="lineNum">     207 </span>            :   int16_t AvgPitchGain_Q12;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   int frame_mode; /* 0 for 30ms, 1 for 60ms */
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   int status = 0;</span>
<span class="lineNum">     211 </span>            :   int my_index;
<span class="lineNum">     212 </span>            :   transcode_obj transcodingParam;
<span class="lineNum">     213 </span>            :   double bytesLeftSpecCoding;
<span class="lineNum">     214 </span>            :   uint16_t payloadLimitBytes;
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :   /* Copy new frame-length and bottleneck rate only for the first 10 ms data */
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   if (ISACencLB_obj-&gt;buffer_index == 0) {</span>
<span class="lineNum">     218 </span>            :     /* Set the framelength for the next packet. */
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;current_framesamples = ISACencLB_obj-&gt;new_framelength;</span>
<span class="lineNum">     220 </span>            :   }
<span class="lineNum">     221 </span>            :   /* 'frame_mode' is 0 (30 ms) or 1 (60 ms). */
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   frame_mode = ISACencLB_obj-&gt;current_framesamples / MAX_FRAMESAMPLES;</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :   /* buffer speech samples (by 10ms packet) until the frame-length */
<span class="lineNum">     225 </span>            :   /* is reached (30 or 60 ms).                                     */
<span class="lineNum">     226 </span>            :   /*****************************************************************/
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   /* fill the buffer with 10ms input data */
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; FRAMESAMPLES_10ms; k++) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;data_buffer_float[k + ISACencLB_obj-&gt;buffer_index] = in[k];</span>
<span class="lineNum">     231 </span>            :   }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   /* If buffersize is not equal to current framesize then increase index
<span class="lineNum">     234 </span>            :    * and return. We do no encoding untill we have enough audio.  */
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   if (ISACencLB_obj-&gt;buffer_index + FRAMESAMPLES_10ms != FRAMESAMPLES) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;buffer_index += FRAMESAMPLES_10ms;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     238 </span>            :   }
<span class="lineNum">     239 </span>            :   /* If buffer reached the right size, reset index and continue with
<span class="lineNum">     240 </span>            :    * encoding the frame. */
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   ISACencLB_obj-&gt;buffer_index = 0;</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   /* End of buffer function. */
<span class="lineNum">     244 </span>            :   /**************************/
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   /* Encoding */
<span class="lineNum">     247 </span>            :   /************/
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   if (frame_mode == 0 || ISACencLB_obj-&gt;frame_nb == 0) {</span>
<span class="lineNum">     250 </span>            :     /* This is to avoid Linux warnings until we change 'int' to 'Word32'
<span class="lineNum">     251 </span>            :      * at all places. */
<span class="lineNum">     252 </span>            :     int intVar;
<span class="lineNum">     253 </span>            :     /* reset bitstream */
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     WebRtcIsac_ResetBitstream(&amp;(ISACencLB_obj-&gt;bitstr_obj));</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     if ((codingMode == 0) &amp;&amp; (frame_mode == 0) &amp;&amp;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         (ISACencLB_obj-&gt;enforceFrameSize == 0)) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;new_framelength = WebRtcIsac_GetNewFrameLength(</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :           ISACencLB_obj-&gt;bottleneck, ISACencLB_obj-&gt;current_framesamples);</span>
<span class="lineNum">     260 </span>            :     }
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;s2nr = WebRtcIsac_GetSnr(</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;bottleneck, ISACencLB_obj-&gt;current_framesamples);</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :     /* Encode frame length. */
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     status = WebRtcIsac_EncodeFrameLen(</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;current_framesamples, &amp;ISACencLB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     if (status &lt; 0) {</span>
<span class="lineNum">     269 </span>            :       /* Wrong frame size. */
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       return status;</span>
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span>            :     /* Save framelength for multiple packets memory. */
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;SaveEnc_obj.framelength =</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;current_framesamples;</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     /* To be used for Redundant Coding. */
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;lastBWIdx = bottleneckIndex;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     intVar = (int)bottleneckIndex;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncodeReceiveBw(&amp;intVar, &amp;ISACencLB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     280 </span>            :   }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :   /* Split signal in two bands. */
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   WebRtcIsac_SplitAndFilterFloat(ISACencLB_obj-&gt;data_buffer_float, LP, HP,</span>
<span class="lineNum">     284 </span>            :                                  LP_lookahead, HP_lookahead,
<span class="lineNum">     285 </span>            :                                  &amp;ISACencLB_obj-&gt;prefiltbankstr_obj);
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   /* estimate pitch parameters and pitch-filter lookahead signal */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   WebRtcIsac_PitchAnalysis(LP_lookahead, LP_lookahead_pf,</span>
<span class="lineNum">     289 </span>            :                            &amp;ISACencLB_obj-&gt;pitchanalysisstr_obj, PitchLags,
<span class="lineNum">     290 </span>            :                            PitchGains);
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :   /* Encode in FIX Q12. */
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   /* Convert PitchGain to Fixed point. */
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; PITCH_SUBFRAMES; k++) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     PitchGains_Q12[k] = (int16_t)(PitchGains[k] * 4096.0);</span>
<span class="lineNum">     297 </span>            :   }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   /* Set where to store data in multiple packets memory. */
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   if (frame_mode == 0 || ISACencLB_obj-&gt;frame_nb == 0) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;SaveEnc_obj.startIdx = 0;</span>
<span class="lineNum">     302 </span>            :   } else {
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;SaveEnc_obj.startIdx = 1;</span>
<span class="lineNum">     304 </span>            :   }
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   /* Quantize &amp; encode pitch parameters. */
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodePitchGain(PitchGains_Q12, &amp;ISACencLB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     308 </span>            :                              &amp;ISACencLB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodePitchLag(PitchLags, PitchGains_Q12,</span>
<span class="lineNum">     310 </span>            :                             &amp;ISACencLB_obj-&gt;bitstr_obj,
<span class="lineNum">     311 </span>            :                             &amp;ISACencLB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   AvgPitchGain_Q12 = (PitchGains_Q12[0] + PitchGains_Q12[1] +</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       PitchGains_Q12[2] + PitchGains_Q12[3]) &gt;&gt; 2;</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :   /* Find coefficients for perceptual pre-filters. */
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   WebRtcIsac_GetLpcCoefLb(LP_lookahead_pf, HP_lookahead,</span>
<span class="lineNum">     318 </span>            :                           &amp;ISACencLB_obj-&gt;maskfiltstr_obj, ISACencLB_obj-&gt;s2nr,
<span class="lineNum">     319 </span>            :                           PitchGains_Q12, lofilt_coef, hifilt_coef);
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   /* Code LPC model and shape - gains not quantized yet. */
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcLb(lofilt_coef, hifilt_coef, &amp;ISACencLB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     323 </span>            :                          &amp;ISACencLB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :   /* Convert PitchGains back to FLOAT for pitchfilter_pre. */
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 4; k++) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     PitchGains[k] = ((float)PitchGains_Q12[k]) / 4096;</span>
<span class="lineNum">     328 </span>            :   }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   /* Store the state of arithmetic coder before coding LPC gains. */
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   transcodingParam.W_upper = ISACencLB_obj-&gt;bitstr_obj.W_upper;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   transcodingParam.stream_index = ISACencLB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   transcodingParam.streamval = ISACencLB_obj-&gt;bitstr_obj.streamval;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   transcodingParam.stream[0] =</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;bitstr_obj.stream[ISACencLB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     336 </span>            :                                        2];
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   transcodingParam.stream[1] =</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;bitstr_obj.stream[ISACencLB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     339 </span>            :                                        1];
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   transcodingParam.stream[2] =</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;bitstr_obj.stream[ISACencLB_obj-&gt;bitstr_obj.stream_index];</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   /* Store LPC Gains before encoding them. */
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     transcodingParam.loFiltGain[k] = lofilt_coef[(LPC_LOBAND_ORDER + 1) * k];</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     transcodingParam.hiFiltGain[k] = hifilt_coef[(LPC_HIBAND_ORDER + 1) * k];</span>
<span class="lineNum">     347 </span>            :   }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :   /* Code gains */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcGainLb(lofilt_coef, hifilt_coef,</span>
<span class="lineNum">     351 </span>            :                              &amp;ISACencLB_obj-&gt;bitstr_obj,
<span class="lineNum">     352 </span>            :                              &amp;ISACencLB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   /* Get the correct value for the payload limit and calculate the
<span class="lineNum">     355 </span>            :    * number of bytes left for coding the spectrum. */
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   if ((frame_mode == 1) &amp;&amp; (ISACencLB_obj-&gt;frame_nb == 0)) {</span>
<span class="lineNum">     357 </span>            :     /* It is a 60ms and we are in the first 30ms then the limit at
<span class="lineNum">     358 </span>            :      * this point should be half of the assigned value. */
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     payloadLimitBytes = ISACencLB_obj-&gt;payloadLimitBytes60 &gt;&gt; 1;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   } else if (frame_mode == 0) {</span>
<span class="lineNum">     361 </span>            :     /* It is a 30ms frame */
<span class="lineNum">     362 </span>            :     /* Subract 3 because termination process may add 3 bytes. */
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     payloadLimitBytes = ISACencLB_obj-&gt;payloadLimitBytes30 - 3;</span>
<span class="lineNum">     364 </span>            :   } else {
<span class="lineNum">     365 </span>            :     /* This is the second half of a 60ms frame. */
<span class="lineNum">     366 </span>            :     /* Subract 3 because termination process may add 3 bytes. */
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     payloadLimitBytes = ISACencLB_obj-&gt;payloadLimitBytes60 - 3;</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   bytesLeftSpecCoding = payloadLimitBytes - transcodingParam.stream_index;</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :   /* Perceptual pre-filtering (using normalized lattice filter). */
<span class="lineNum">     372 </span>            :   /* Low-band filtering. */
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   WebRtcIsac_NormLatticeFilterMa(ORDERLO,</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                                  ISACencLB_obj-&gt;maskfiltstr_obj.PreStateLoF,</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                                  ISACencLB_obj-&gt;maskfiltstr_obj.PreStateLoG,</span>
<span class="lineNum">     376 </span>            :                                  LP, lofilt_coef, LPw);
<span class="lineNum">     377 </span>            :   /* High-band filtering. */
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   WebRtcIsac_NormLatticeFilterMa(ORDERHI,</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                                  ISACencLB_obj-&gt;maskfiltstr_obj.PreStateHiF,</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                                  ISACencLB_obj-&gt;maskfiltstr_obj.PreStateHiG,</span>
<span class="lineNum">     381 </span>            :                                  HP, hifilt_coef, HPw);
<span class="lineNum">     382 </span>            :   /* Pitch filter. */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   WebRtcIsac_PitchfilterPre(LPw, LPw_pf, &amp;ISACencLB_obj-&gt;pitchfiltstr_obj,</span>
<span class="lineNum">     384 </span>            :                             PitchLags, PitchGains);
<span class="lineNum">     385 </span>            :   /* Transform */
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   WebRtcIsac_Time2Spec(transform_tables,</span>
<span class="lineNum">     387 </span>            :                        LPw_pf, HPw, fre, fim, &amp;ISACencLB_obj-&gt;fftstr_obj);
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   /* Save data for multiple packets memory. */
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :   my_index = ISACencLB_obj-&gt;SaveEnc_obj.startIdx * FRAMESAMPLES_HALF;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencLB_obj-&gt;SaveEnc_obj.fre[my_index], fre, sizeof(fre));</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencLB_obj-&gt;SaveEnc_obj.fim[my_index], fim, sizeof(fim));</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   ISACencLB_obj-&gt;SaveEnc_obj.AvgPitchGain[ISACencLB_obj-&gt;SaveEnc_obj.startIdx] =</span>
<span class="lineNum">     395 </span>            :       AvgPitchGain_Q12;
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   /* Quantization and loss-less coding. */
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   err = WebRtcIsac_EncodeSpec(fre, fim, AvgPitchGain_Q12, kIsacLowerBand,</span>
<span class="lineNum">     399 </span>            :                               &amp;ISACencLB_obj-&gt;bitstr_obj);
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   if ((err &lt; 0) &amp;&amp; (err != -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {</span>
<span class="lineNum">     401 </span>            :     /* There has been an error but it was not too large payload
<span class="lineNum">     402 </span>            :        (we can cure too large payload). */
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     if (frame_mode == 1 &amp;&amp; ISACencLB_obj-&gt;frame_nb == 1) {</span>
<span class="lineNum">     404 </span>            :       /* If this is the second 30ms of a 60ms frame reset
<span class="lineNum">     405 </span>            :          this such that in the next call encoder starts fresh. */
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;frame_nb = 0;</span>
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     409 </span>            :   }
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   iterCntr = 0;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   while ((ISACencLB_obj-&gt;bitstr_obj.stream_index &gt; payloadLimitBytes) ||</span>
<span class="lineNum">     412 </span>            :       (err == -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {
<span class="lineNum">     413 </span>            :     double bytesSpecCoderUsed;
<span class="lineNum">     414 </span>            :     double transcodeScale;
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     if (iterCntr &gt;= MAX_PAYLOAD_LIMIT_ITERATION) {</span>
<span class="lineNum">     417 </span>            :       /* We were not able to limit the payload size */
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       if ((frame_mode == 1) &amp;&amp; (ISACencLB_obj-&gt;frame_nb == 0)) {</span>
<span class="lineNum">     419 </span>            :         /* This was the first 30ms of a 60ms frame. Although
<span class="lineNum">     420 </span>            :            the payload is larger than it should be but we let
<span class="lineNum">     421 </span>            :            the second 30ms be encoded. Maybe together we
<span class="lineNum">     422 </span>            :            won't exceed the limit. */
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;frame_nb = 1;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       } else if ((frame_mode == 1) &amp;&amp; (ISACencLB_obj-&gt;frame_nb == 1)) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;frame_nb = 0;</span>
<span class="lineNum">     427 </span>            :       }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       if (err != -ISAC_DISALLOWED_BITSTREAM_LENGTH) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         return -ISAC_PAYLOAD_LARGER_THAN_LIMIT;</span>
<span class="lineNum">     431 </span>            :       } else {
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         return status;</span>
<span class="lineNum">     433 </span>            :       }
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     if (err == -ISAC_DISALLOWED_BITSTREAM_LENGTH) {</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       bytesSpecCoderUsed = STREAM_SIZE_MAX;</span>
<span class="lineNum">     438 </span>            :       /* Being conservative */
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       transcodeScale = bytesLeftSpecCoding / bytesSpecCoderUsed * 0.5;</span>
<span class="lineNum">     440 </span>            :     } else {
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :       bytesSpecCoderUsed = ISACencLB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :           transcodingParam.stream_index;</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       transcodeScale = bytesLeftSpecCoding / bytesSpecCoderUsed;</span>
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :     /* To be safe, we reduce the scale depending on
<span class="lineNum">     447 </span>            :        the number of iterations. */
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     transcodeScale *= (1.0 - (0.9 * (double)iterCntr /</span>
<span class="lineNum">     449 </span>            :         (double)MAX_PAYLOAD_LIMIT_ITERATION));
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :     /* Scale the LPC Gains. */
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       lofilt_coef[(LPC_LOBAND_ORDER + 1) * k] =</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :           transcodingParam.loFiltGain[k] * transcodeScale;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :       hifilt_coef[(LPC_HIBAND_ORDER + 1) * k] =</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :           transcodingParam.hiFiltGain[k] * transcodeScale;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       transcodingParam.loFiltGain[k] = lofilt_coef[(LPC_LOBAND_ORDER + 1) * k];</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       transcodingParam.hiFiltGain[k] = hifilt_coef[(LPC_HIBAND_ORDER + 1) * k];</span>
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :     /* Scale DFT coefficients. */
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; FRAMESAMPLES_HALF; k++) {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       fre[k] = (int16_t)(fre[k] * transcodeScale);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       fim[k] = (int16_t)(fim[k] * transcodeScale);</span>
<span class="lineNum">     465 </span>            :     }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     /* Save data for multiple packets memory. */
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     my_index = ISACencLB_obj-&gt;SaveEnc_obj.startIdx * FRAMESAMPLES_HALF;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     memcpy(&amp;ISACencLB_obj-&gt;SaveEnc_obj.fre[my_index], fre, sizeof(fre));</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     memcpy(&amp;ISACencLB_obj-&gt;SaveEnc_obj.fim[my_index], fim, sizeof(fim));</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :     /* Re-store the state of arithmetic coder before coding LPC gains. */
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.W_upper = transcodingParam.W_upper;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.stream_index = transcodingParam.stream_index;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.streamval = transcodingParam.streamval;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.stream[transcodingParam.stream_index - 2] =</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         transcodingParam.stream[0];</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.stream[transcodingParam.stream_index - 1] =</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         transcodingParam.stream[1];</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;bitstr_obj.stream[transcodingParam.stream_index] =</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         transcodingParam.stream[2];</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :     /* Code gains. */
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncodeLpcGainLb(lofilt_coef, hifilt_coef,</span>
<span class="lineNum">     485 </span>            :                                &amp;ISACencLB_obj-&gt;bitstr_obj,
<span class="lineNum">     486 </span>            :                                &amp;ISACencLB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     /* Update the number of bytes left for encoding the spectrum. */
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     bytesLeftSpecCoding = payloadLimitBytes - transcodingParam.stream_index;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     /* Encode the spectrum. */
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     err = WebRtcIsac_EncodeSpec(fre, fim, AvgPitchGain_Q12, kIsacLowerBand,</span>
<span class="lineNum">     493 </span>            :                                 &amp;ISACencLB_obj-&gt;bitstr_obj);
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     if ((err &lt; 0) &amp;&amp; (err != -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {</span>
<span class="lineNum">     496 </span>            :       /* There has been an error but it was not too large
<span class="lineNum">     497 </span>            :          payload (we can cure too large payload). */
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       if (frame_mode == 1 &amp;&amp; ISACencLB_obj-&gt;frame_nb == 1) {</span>
<span class="lineNum">     499 </span>            :         /* If this is the second 30 ms of a 60 ms frame reset
<span class="lineNum">     500 </span>            :            this such that in the next call encoder starts fresh. */
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;frame_nb = 0;</span>
<span class="lineNum">     502 </span>            :       }
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     iterCntr++;</span>
<span class="lineNum">     506 </span>            :   }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :   /* If 60 ms frame-size and just processed the first 30 ms, */
<span class="lineNum">     509 </span>            :   /* go back to main function to buffer the other 30 ms speech frame. */
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   if (frame_mode == 1) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     if (ISACencLB_obj-&gt;frame_nb == 0) {</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;frame_nb = 1;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     } else if (ISACencLB_obj-&gt;frame_nb == 1) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       ISACencLB_obj-&gt;frame_nb = 0;</span>
<span class="lineNum">     516 </span>            :       /* Also update the frame-length for next packet,
<span class="lineNum">     517 </span>            :          in Adaptive mode only. */
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       if (codingMode == 0 &amp;&amp; (ISACencLB_obj-&gt;enforceFrameSize == 0)) {</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         ISACencLB_obj-&gt;new_framelength =</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :             WebRtcIsac_GetNewFrameLength(ISACencLB_obj-&gt;bottleneck,</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                                          ISACencLB_obj-&gt;current_framesamples);</span>
<span class="lineNum">     522 </span>            :       }
<span class="lineNum">     523 </span>            :     }
<span class="lineNum">     524 </span>            :   } else {
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     ISACencLB_obj-&gt;frame_nb = 0;</span>
<span class="lineNum">     526 </span>            :   }
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :   /* Complete arithmetic coding. */
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   stream_length = WebRtcIsac_EncTerminate(&amp;ISACencLB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   return stream_length;</span>
<span class="lineNum">     531 </span>            : }
<span class="lineNum">     532 </span>            : 
<a name="533"><span class="lineNum">     533 </span>            : </a>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : static int LimitPayloadUb(ISACUBEncStruct* ISACencUB_obj,</span>
<span class="lineNum">     536 </span>            :                           uint16_t payloadLimitBytes,
<span class="lineNum">     537 </span>            :                           double bytesLeftSpecCoding,
<span class="lineNum">     538 </span>            :                           transcode_obj* transcodingParam,
<span class="lineNum">     539 </span>            :                           int16_t* fre, int16_t* fim,
<span class="lineNum">     540 </span>            :                           double* lpcGains, enum ISACBand band, int status) {
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   int iterCntr = 0;</span>
<span class="lineNum">     543 </span>            :   int k;
<span class="lineNum">     544 </span>            :   double bytesSpecCoderUsed;
<span class="lineNum">     545 </span>            :   double transcodeScale;
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   const int16_t kAveragePitchGain = 0.0;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :   do {
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if (iterCntr &gt;= MAX_PAYLOAD_LIMIT_ITERATION) {</span>
<span class="lineNum">     550 </span>            :       /* We were not able to limit the payload size. */
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       return -ISAC_PAYLOAD_LARGER_THAN_LIMIT;</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     if (status == -ISAC_DISALLOWED_BITSTREAM_LENGTH) {</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       bytesSpecCoderUsed = STREAM_SIZE_MAX;</span>
<span class="lineNum">     556 </span>            :       /* Being conservative. */
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       transcodeScale = bytesLeftSpecCoding / bytesSpecCoderUsed * 0.5;</span>
<span class="lineNum">     558 </span>            :     } else {
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       bytesSpecCoderUsed = ISACencUB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :           transcodingParam-&gt;stream_index;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :       transcodeScale = bytesLeftSpecCoding / bytesSpecCoderUsed;</span>
<span class="lineNum">     562 </span>            :     }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     /* To be safe, we reduce the scale depending on the
<span class="lineNum">     565 </span>            :        number of iterations. */
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     transcodeScale *= (1.0 - (0.9 * (double)iterCntr /</span>
<span class="lineNum">     567 </span>            :         (double)MAX_PAYLOAD_LIMIT_ITERATION));
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     /* Scale the LPC Gains. */
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     if (band == kIsacUpperBand16) {</span>
<span class="lineNum">     571 </span>            :       /* Two sets of coefficients if 16 kHz. */
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;loFiltGain[k] *= transcodeScale;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;hiFiltGain[k] *= transcodeScale;</span>
<span class="lineNum">     575 </span>            :       }
<span class="lineNum">     576 </span>            :     } else {
<span class="lineNum">     577 </span>            :       /* One sets of coefficients if 12 kHz. */
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;loFiltGain[k] *= transcodeScale;</span>
<span class="lineNum">     580 </span>            :       }
<span class="lineNum">     581 </span>            :     }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :     /* Scale DFT coefficients. */
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; FRAMESAMPLES_HALF; k++) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       fre[k] = (int16_t)(fre[k] * transcodeScale + 0.5);</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       fim[k] = (int16_t)(fim[k] * transcodeScale + 0.5);</span>
<span class="lineNum">     587 </span>            :     }
<span class="lineNum">     588 </span>            :     /* Store FFT coefficients for multiple encoding. */
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     memcpy(ISACencUB_obj-&gt;SaveEnc_obj.realFFT, fre,</span>
<span class="lineNum">     590 </span>            :           sizeof(ISACencUB_obj-&gt;SaveEnc_obj.realFFT));
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     memcpy(ISACencUB_obj-&gt;SaveEnc_obj.imagFFT, fim,</span>
<span class="lineNum">     592 </span>            :            sizeof(ISACencUB_obj-&gt;SaveEnc_obj.imagFFT));
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :     /* Store the state of arithmetic coder before coding LPC gains */
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.W_upper = transcodingParam-&gt;W_upper;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.stream_index = transcodingParam-&gt;stream_index;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.streamval = transcodingParam-&gt;streamval;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.stream[transcodingParam-&gt;stream_index - 2] =</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;stream[0];</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.stream[transcodingParam-&gt;stream_index - 1] =</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;stream[1];</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;bitstr_obj.stream[transcodingParam-&gt;stream_index] =</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         transcodingParam-&gt;stream[2];</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :     /* Store the gains for multiple encoding. */
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     memcpy(ISACencUB_obj-&gt;SaveEnc_obj.lpcGain, lpcGains,</span>
<span class="lineNum">     607 </span>            :            SUBFRAMES * sizeof(double));
<span class="lineNum">     608 </span>            :     /* Entropy Code lpc-gains, indices are stored for a later use.*/
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncodeLpcGainUb(transcodingParam-&gt;loFiltGain,</span>
<span class="lineNum">     610 </span>            :                                &amp;ISACencUB_obj-&gt;bitstr_obj,
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                                ISACencUB_obj-&gt;SaveEnc_obj.lpcGainIndex);</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     /* If 16kHz should do one more set. */
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     if (band == kIsacUpperBand16) {</span>
<span class="lineNum">     615 </span>            :       /* Store the gains for multiple encoding. */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       memcpy(&amp;ISACencUB_obj-&gt;SaveEnc_obj.lpcGain[SUBFRAMES],</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :              &amp;lpcGains[SUBFRAMES], SUBFRAMES * sizeof(double));</span>
<span class="lineNum">     618 </span>            :       /* Entropy Code lpc-gains, indices are stored for a later use.*/
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       WebRtcIsac_EncodeLpcGainUb(</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :           transcodingParam-&gt;hiFiltGain, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     621 </span>            :           &amp;ISACencUB_obj-&gt;SaveEnc_obj.lpcGainIndex[SUBFRAMES]);
<span class="lineNum">     622 </span>            :     }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :     /* Update the number of bytes left for encoding the spectrum. */
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     bytesLeftSpecCoding = payloadLimitBytes -</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         ISACencUB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     /* Save the bit-stream object at this point for FEC. */
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     memcpy(&amp;ISACencUB_obj-&gt;SaveEnc_obj.bitStreamObj,</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :            &amp;ISACencUB_obj-&gt;bitstr_obj, sizeof(Bitstr));</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /* Encode the spectrum. */
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     status = WebRtcIsac_EncodeSpec(fre, fim, kAveragePitchGain,</span>
<span class="lineNum">     634 </span>            :                                    band, &amp;ISACencUB_obj-&gt;bitstr_obj);
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     if ((status &lt; 0) &amp;&amp; (status != -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {</span>
<span class="lineNum">     636 </span>            :       /* There has been an error but it was not too large payload
<span class="lineNum">     637 </span>            :          (we can cure too large payload). */
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       return status;</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     iterCntr++;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   } while ((ISACencUB_obj-&gt;bitstr_obj.stream_index &gt; payloadLimitBytes) ||</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       (status == -ISAC_DISALLOWED_BITSTREAM_LENGTH));</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="644"><span class="lineNum">     644 </span>            : }</a>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : int WebRtcIsac_EncodeUb16(const TransformTables* transform_tables,</span>
<span class="lineNum">     647 </span>            :                           float* in, ISACUBEncStruct* ISACencUB_obj,
<span class="lineNum">     648 </span>            :                           int32_t jitterInfo) {
<span class="lineNum">     649 </span>            :   int err;
<span class="lineNum">     650 </span>            :   int k;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   double lpcVecs[UB_LPC_ORDER * UB16_LPC_VEC_PER_FRAME];
<span class="lineNum">     653 </span>            :   double percepFilterParams[(1 + UB_LPC_ORDER) * (SUBFRAMES &lt;&lt; 1) +
<span class="lineNum">     654 </span>            :                             (1 + UB_LPC_ORDER)];
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   double LP_lookahead[FRAMESAMPLES];
<span class="lineNum">     657 </span>            :   int16_t fre[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     658 </span>            :   int16_t fim[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   int status = 0;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :   double varscale[2];
<span class="lineNum">     663 </span>            :   double corr[SUBFRAMES &lt;&lt; 1][UB_LPC_ORDER + 1];
<span class="lineNum">     664 </span>            :   double lpcGains[SUBFRAMES &lt;&lt; 1];
<span class="lineNum">     665 </span>            :   transcode_obj transcodingParam;
<span class="lineNum">     666 </span>            :   uint16_t payloadLimitBytes;
<span class="lineNum">     667 </span>            :   double s2nr;
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   const int16_t kAveragePitchGain = 0.0;</span>
<span class="lineNum">     669 </span>            :   int bytesLeftSpecCoding;
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :   /* Buffer speech samples (by 10ms packet) until the frame-length is   */
<span class="lineNum">     672 </span>            :   /* reached (30 ms).                                                   */
<span class="lineNum">     673 </span>            :   /*********************************************************************/
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :   /* fill the buffer with 10ms input data */
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencUB_obj-&gt;data_buffer_float[ISACencUB_obj-&gt;buffer_index], in,</span>
<span class="lineNum">     677 </span>            :          FRAMESAMPLES_10ms * sizeof(float));
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :   /* If buffer size is not equal to current frame-size, and end of file is
<span class="lineNum">     680 </span>            :    * not reached yet, we don't do encoding unless we have the whole frame. */
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   if (ISACencUB_obj-&gt;buffer_index + FRAMESAMPLES_10ms &lt; FRAMESAMPLES) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;buffer_index += FRAMESAMPLES_10ms;</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     684 </span>            :   }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            :   /* End of buffer function. */
<span class="lineNum">     687 </span>            :   /**************************/
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :   /* Encoding */
<span class="lineNum">     690 </span>            :   /************/
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :   /* Reset bit-stream */
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   WebRtcIsac_ResetBitstream(&amp;(ISACencUB_obj-&gt;bitstr_obj));</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   /* Encoding of bandwidth information. */
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeJitterInfo(jitterInfo, &amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   status = WebRtcIsac_EncodeBandwidth(isac16kHz, &amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   if (status &lt; 0) {</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     return status;</span>
<span class="lineNum">     701 </span>            :   }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   s2nr = WebRtcIsac_GetSnr(ISACencUB_obj-&gt;bottleneck, FRAMESAMPLES);</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   memcpy(lpcVecs, ISACencUB_obj-&gt;lastLPCVec, UB_LPC_ORDER * sizeof(double));</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; FRAMESAMPLES; k++) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     LP_lookahead[k] = ISACencUB_obj-&gt;data_buffer_float[UB_LOOKAHEAD + k];</span>
<span class="lineNum">     709 </span>            :   }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :   /* Find coefficients for perceptual pre-filters. */
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   WebRtcIsac_GetLpcCoefUb(LP_lookahead, &amp;ISACencUB_obj-&gt;maskfiltstr_obj,</span>
<span class="lineNum">     713 </span>            :                           &amp;lpcVecs[UB_LPC_ORDER], corr, varscale, isac16kHz);
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;lastLPCVec,</span>
<span class="lineNum">     716 </span>            :          &amp;lpcVecs[(UB16_LPC_VEC_PER_FRAME - 1) * (UB_LPC_ORDER)],
<span class="lineNum">     717 </span>            :          sizeof(double) * UB_LPC_ORDER);
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   /* Code LPC model and shape - gains not quantized yet. */
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcUB(lpcVecs, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     721 </span>            :                          percepFilterParams, isac16kHz,
<span class="lineNum">     722 </span>            :                          &amp;ISACencUB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :   /* the first set of lpc parameters are from the last sub-frame of
<span class="lineNum">     725 </span>            :    * the previous frame. so we don't care about them. */
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   WebRtcIsac_GetLpcGain(s2nr, &amp;percepFilterParams[UB_LPC_ORDER + 1],</span>
<span class="lineNum">     727 </span>            :                         (SUBFRAMES &lt;&lt; 1), lpcGains, corr, varscale);
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :   /* Store the state of arithmetic coder before coding LPC gains */
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   transcodingParam.stream_index = ISACencUB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   transcodingParam.W_upper = ISACencUB_obj-&gt;bitstr_obj.W_upper;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :   transcodingParam.streamval = ISACencUB_obj-&gt;bitstr_obj.streamval;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   transcodingParam.stream[0] =</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     735 </span>            :                                        2];
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   transcodingParam.stream[1] =</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     738 </span>            :                                        1];
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   transcodingParam.stream[2] =</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index];</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :   /* Store LPC Gains before encoding them. */
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     transcodingParam.loFiltGain[k] = lpcGains[k];</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     transcodingParam.hiFiltGain[k] = lpcGains[SUBFRAMES + k];</span>
<span class="lineNum">     746 </span>            :   }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :   /* Store the gains for multiple encoding. */
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.lpcGain, lpcGains,</span>
<span class="lineNum">     750 </span>            :          (SUBFRAMES &lt;&lt; 1) * sizeof(double));
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcGainUb(lpcGains, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                              ISACencUB_obj-&gt;SaveEnc_obj.lpcGainIndex);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcGainUb(</span>
<span class="lineNum">     755 </span>            :       &amp;lpcGains[SUBFRAMES], &amp;ISACencUB_obj-&gt;bitstr_obj,
<span class="lineNum">     756 </span>            :       &amp;ISACencUB_obj-&gt;SaveEnc_obj.lpcGainIndex[SUBFRAMES]);
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   /* Get the correct value for the payload limit and calculate the number of
<span class="lineNum">     759 </span>            :      bytes left for coding the spectrum. It is a 30ms frame
<span class="lineNum">     760 </span>            :      Subract 3 because termination process may add 3 bytes */
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   payloadLimitBytes = ISACencUB_obj-&gt;maxPayloadSizeBytes -</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;numBytesUsed - 3;</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   bytesLeftSpecCoding = payloadLimitBytes -</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         ISACencUB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; (SUBFRAMES &lt;&lt; 1); k++) {</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     percepFilterParams[k * (UB_LPC_ORDER + 1) + (UB_LPC_ORDER + 1)] =</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         lpcGains[k];</span>
<span class="lineNum">     769 </span>            :   }
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :   /* LPC filtering (using normalized lattice filter), */
<span class="lineNum">     772 </span>            :   /* first half-frame. */
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   WebRtcIsac_NormLatticeFilterMa(UB_LPC_ORDER,</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :                                  ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoF,</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :                                  ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoG,</span>
<span class="lineNum">     776 </span>            :                                  &amp;ISACencUB_obj-&gt;data_buffer_float[0],
<span class="lineNum">     777 </span>            :                                  &amp;percepFilterParams[UB_LPC_ORDER + 1],
<span class="lineNum">     778 </span>            :                                  &amp;LP_lookahead[0]);
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :   /* Second half-frame filtering. */
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   WebRtcIsac_NormLatticeFilterMa(</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       UB_LPC_ORDER, ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoF,</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoG,</span>
<span class="lineNum">     784 </span>            :       &amp;ISACencUB_obj-&gt;data_buffer_float[FRAMESAMPLES_HALF],
<span class="lineNum">     785 </span>            :       &amp;percepFilterParams[(UB_LPC_ORDER + 1) + SUBFRAMES * (UB_LPC_ORDER + 1)],
<span class="lineNum">     786 </span>            :       &amp;LP_lookahead[FRAMESAMPLES_HALF]);
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   WebRtcIsac_Time2Spec(transform_tables,</span>
<span class="lineNum">     789 </span>            :                        &amp;LP_lookahead[0], &amp;LP_lookahead[FRAMESAMPLES_HALF],
<span class="lineNum">     790 </span>            :                        fre, fim, &amp;ISACencUB_obj-&gt;fftstr_obj);
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   /* Store FFT coefficients for multiple encoding. */
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.realFFT, fre, sizeof(fre));</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.imagFFT, fim, sizeof(fim));</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :   /* Prepare the audio buffer for the next packet
<span class="lineNum">     797 </span>            :    * move the last 3 ms to the beginning of the buffer. */
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;data_buffer_float,</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :          &amp;ISACencUB_obj-&gt;data_buffer_float[FRAMESAMPLES],</span>
<span class="lineNum">     800 </span>            :          LB_TOTAL_DELAY_SAMPLES * sizeof(float));
<span class="lineNum">     801 </span>            :   /* start writing with 3 ms delay to compensate for the delay
<span class="lineNum">     802 </span>            :    * of the lower-band. */
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   ISACencUB_obj-&gt;buffer_index = LB_TOTAL_DELAY_SAMPLES;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :   /* Save the bit-stream object at this point for FEC. */
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencUB_obj-&gt;SaveEnc_obj.bitStreamObj, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     807 </span>            :          sizeof(Bitstr));
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :   /* Qantization and lossless coding */
<span class="lineNum">     810 </span>            :   /* Note that there is no pitch-gain for this band so kAveragePitchGain = 0
<span class="lineNum">     811 </span>            :    * is passed to the function. In fact, the function ignores the 3rd parameter
<span class="lineNum">     812 </span>            :    * for this band. */
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   err = WebRtcIsac_EncodeSpec(fre, fim, kAveragePitchGain, kIsacUpperBand16,</span>
<span class="lineNum">     814 </span>            :                               &amp;ISACencUB_obj-&gt;bitstr_obj);
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   if ((err &lt; 0) &amp;&amp; (err != -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     817 </span>            :   }
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :   if ((ISACencUB_obj-&gt;bitstr_obj.stream_index &gt; payloadLimitBytes) ||</span>
<span class="lineNum">     820 </span>            :       (err == -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     err = LimitPayloadUb(ISACencUB_obj, payloadLimitBytes, bytesLeftSpecCoding,</span>
<span class="lineNum">     822 </span>            :                          &amp;transcodingParam, fre, fim, lpcGains,
<span class="lineNum">     823 </span>            :                          kIsacUpperBand16, err);
<span class="lineNum">     824 </span>            :   }
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   if (err &lt; 0) {</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     827 </span>            :   }
<span class="lineNum">     828 </span>            :   /* Complete arithmetic coding. */
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   return WebRtcIsac_EncTerminate(&amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     830 </span>            : }
<a name="831"><span class="lineNum">     831 </span>            : </a>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 : int WebRtcIsac_EncodeUb12(const TransformTables* transform_tables,</span>
<span class="lineNum">     834 </span>            :                           float* in, ISACUBEncStruct* ISACencUB_obj,
<span class="lineNum">     835 </span>            :                           int32_t jitterInfo) {
<span class="lineNum">     836 </span>            :   int err;
<span class="lineNum">     837 </span>            :   int k;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :   double lpcVecs[UB_LPC_ORDER * UB_LPC_VEC_PER_FRAME];
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :   double percepFilterParams[(1 + UB_LPC_ORDER) * SUBFRAMES];
<span class="lineNum">     842 </span>            :   float LP[FRAMESAMPLES_HALF];
<span class="lineNum">     843 </span>            :   float HP[FRAMESAMPLES_HALF];
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :   double LP_lookahead[FRAMESAMPLES_HALF];
<span class="lineNum">     846 </span>            :   double HP_lookahead[FRAMESAMPLES_HALF];
<span class="lineNum">     847 </span>            :   double LPw[FRAMESAMPLES_HALF];
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :   double HPw[FRAMESAMPLES_HALF];
<span class="lineNum">     850 </span>            :   int16_t fre[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     851 </span>            :   int16_t fim[FRAMESAMPLES_HALF];   /* Q7 */
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   int status = 0;</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :   double varscale[1];
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   double corr[UB_LPC_GAIN_DIM][UB_LPC_ORDER + 1];
<span class="lineNum">     858 </span>            :   double lpcGains[SUBFRAMES];
<span class="lineNum">     859 </span>            :   transcode_obj transcodingParam;
<span class="lineNum">     860 </span>            :   uint16_t payloadLimitBytes;
<span class="lineNum">     861 </span>            :   double s2nr;
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   const int16_t kAveragePitchGain = 0.0;</span>
<span class="lineNum">     863 </span>            :   double bytesLeftSpecCoding;
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :   /* Buffer speech samples (by 10ms packet) until the framelength is  */
<span class="lineNum">     866 </span>            :   /* reached (30 ms).                                                 */
<span class="lineNum">     867 </span>            :   /********************************************************************/
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :   /* Fill the buffer with 10ms input data. */
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencUB_obj-&gt;data_buffer_float[ISACencUB_obj-&gt;buffer_index], in,</span>
<span class="lineNum">     871 </span>            :          FRAMESAMPLES_10ms * sizeof(float));
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span>            :   /* if buffer-size is not equal to current frame-size then increase the
<span class="lineNum">     874 </span>            :      index and return. We do the encoding when we have enough audio.     */
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :   if (ISACencUB_obj-&gt;buffer_index + FRAMESAMPLES_10ms &lt; FRAMESAMPLES) {</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     ISACencUB_obj-&gt;buffer_index += FRAMESAMPLES_10ms;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     878 </span>            :   }
<span class="lineNum">     879 </span>            :   /* If buffer reached the right size, reset index and continue
<span class="lineNum">     880 </span>            :      with encoding the frame */
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   ISACencUB_obj-&gt;buffer_index = 0;</span>
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :   /* End of buffer function */
<span class="lineNum">     884 </span>            :   /**************************/
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :   /* Encoding */
<span class="lineNum">     887 </span>            :   /************/
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   /* Reset bit-stream. */
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   WebRtcIsac_ResetBitstream(&amp;(ISACencUB_obj-&gt;bitstr_obj));</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   /* Encoding bandwidth information. */
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeJitterInfo(jitterInfo, &amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   status = WebRtcIsac_EncodeBandwidth(isac12kHz, &amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   if (status &lt; 0) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     return status;</span>
<span class="lineNum">     897 </span>            :   }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   s2nr = WebRtcIsac_GetSnr(ISACencUB_obj-&gt;bottleneck, FRAMESAMPLES);</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :   /* Split signal in two bands. */
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   WebRtcIsac_SplitAndFilterFloat(ISACencUB_obj-&gt;data_buffer_float, HP, LP,</span>
<span class="lineNum">     903 </span>            :                                  HP_lookahead, LP_lookahead,
<span class="lineNum">     904 </span>            :                                  &amp;ISACencUB_obj-&gt;prefiltbankstr_obj);
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :   /* Find coefficients for perceptual pre-filters. */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   WebRtcIsac_GetLpcCoefUb(LP_lookahead, &amp;ISACencUB_obj-&gt;maskfiltstr_obj,</span>
<span class="lineNum">     908 </span>            :                           lpcVecs, corr, varscale, isac12kHz);
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :   /* Code LPC model and shape - gains not quantized yet. */
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcUB(lpcVecs, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     912 </span>            :                          percepFilterParams, isac12kHz,
<span class="lineNum">     913 </span>            :                          &amp;ISACencUB_obj-&gt;SaveEnc_obj);
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   WebRtcIsac_GetLpcGain(s2nr, percepFilterParams, SUBFRAMES, lpcGains, corr,</span>
<span class="lineNum">     916 </span>            :                         varscale);
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :   /* Store the state of arithmetic coder before coding LPC gains. */
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   transcodingParam.W_upper = ISACencUB_obj-&gt;bitstr_obj.W_upper;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   transcodingParam.stream_index = ISACencUB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   transcodingParam.streamval = ISACencUB_obj-&gt;bitstr_obj.streamval;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   transcodingParam.stream[0] =</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     924 </span>            :                                        2];
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   transcodingParam.stream[1] =</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index -</span>
<span class="lineNum">     927 </span>            :                                        1];
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   transcodingParam.stream[2] =</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream[ISACencUB_obj-&gt;bitstr_obj.stream_index];</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :   /* Store LPC Gains before encoding them. */
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     transcodingParam.loFiltGain[k] = lpcGains[k];</span>
<span class="lineNum">     934 </span>            :   }
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :   /* Store the gains for multiple encoding. */
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.lpcGain, lpcGains, SUBFRAMES *</span>
<span class="lineNum">     938 </span>            :          sizeof(double));
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeLpcGainUb(lpcGains, &amp;ISACencUB_obj-&gt;bitstr_obj,</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                              ISACencUB_obj-&gt;SaveEnc_obj.lpcGainIndex);</span>
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     percepFilterParams[k * (UB_LPC_ORDER + 1)] = lpcGains[k];</span>
<span class="lineNum">     945 </span>            :   }
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :   /* perceptual pre-filtering (using normalized lattice filter) */
<span class="lineNum">     948 </span>            :   /* low-band filtering */
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   WebRtcIsac_NormLatticeFilterMa(UB_LPC_ORDER,</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :                                  ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoF,</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :                                  ISACencUB_obj-&gt;maskfiltstr_obj.PreStateLoG, LP,</span>
<span class="lineNum">     952 </span>            :                                  percepFilterParams, LPw);
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :   /* Get the correct value for the payload limit and calculate the number
<span class="lineNum">     955 </span>            :      of bytes left for coding the spectrum. It is a 30ms frame Subract 3
<span class="lineNum">     956 </span>            :      because termination process may add 3 bytes */
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   payloadLimitBytes = ISACencUB_obj-&gt;maxPayloadSizeBytes -</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;numBytesUsed - 3;</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   bytesLeftSpecCoding = payloadLimitBytes -</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       ISACencUB_obj-&gt;bitstr_obj.stream_index;</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   memset(HPw, 0, sizeof(HPw));</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :   /* Transform */
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   WebRtcIsac_Time2Spec(transform_tables,</span>
<span class="lineNum">     966 </span>            :                        LPw, HPw, fre, fim, &amp;ISACencUB_obj-&gt;fftstr_obj);
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :   /* Store FFT coefficients for multiple encoding. */
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.realFFT, fre,</span>
<span class="lineNum">     970 </span>            :          sizeof(ISACencUB_obj-&gt;SaveEnc_obj.realFFT));
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   memcpy(ISACencUB_obj-&gt;SaveEnc_obj.imagFFT, fim,</span>
<span class="lineNum">     972 </span>            :          sizeof(ISACencUB_obj-&gt;SaveEnc_obj.imagFFT));
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   /* Save the bit-stream object at this point for FEC. */
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   memcpy(&amp;ISACencUB_obj-&gt;SaveEnc_obj.bitStreamObj,</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :          &amp;ISACencUB_obj-&gt;bitstr_obj, sizeof(Bitstr));</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :   /* Quantization and loss-less coding */
<span class="lineNum">     979 </span>            :   /* The 4th parameter to this function is pitch-gain, which is only used
<span class="lineNum">     980 </span>            :    * when encoding 0-8 kHz band, and irrelevant in this function, therefore,
<span class="lineNum">     981 </span>            :    * we insert zero here. */
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   err = WebRtcIsac_EncodeSpec(fre, fim, kAveragePitchGain, kIsacUpperBand12,</span>
<span class="lineNum">     983 </span>            :                               &amp;ISACencUB_obj-&gt;bitstr_obj);
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   if ((err &lt; 0) &amp;&amp; (err != -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {</span>
<span class="lineNum">     985 </span>            :     /* There has been an error but it was not too large
<span class="lineNum">     986 </span>            :        payload (we can cure too large payload) */
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     988 </span>            :   }
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   if ((ISACencUB_obj-&gt;bitstr_obj.stream_index &gt; payloadLimitBytes) ||</span>
<span class="lineNum">     991 </span>            :       (err == -ISAC_DISALLOWED_BITSTREAM_LENGTH)) {
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     err = LimitPayloadUb(ISACencUB_obj, payloadLimitBytes, bytesLeftSpecCoding,</span>
<span class="lineNum">     993 </span>            :                          &amp;transcodingParam, fre, fim, lpcGains,
<span class="lineNum">     994 </span>            :                          kIsacUpperBand12, err);
<span class="lineNum">     995 </span>            :   }
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :   if (err &lt; 0) {</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">     998 </span>            :   }
<span class="lineNum">     999 </span>            :   /* Complete arithmetic coding. */
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   return WebRtcIsac_EncTerminate(&amp;ISACencUB_obj-&gt;bitstr_obj);</span>
<span class="lineNum">    1001 </span>            : }
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : /* This function is used to create a new bit-stream with new BWE.
<span class="lineNum">    1009 </span>            :    The same data as previously encoded with the function WebRtcIsac_Encoder().
<span class="lineNum">    1010 </span>            :    The data needed is taken from the structure, where it was stored
<a name="1011"><span class="lineNum">    1011 </span>            :    when calling the encoder. */</a>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 : int WebRtcIsac_EncodeStoredDataLb(const IsacSaveEncoderData* ISACSavedEnc_obj,</span>
<span class="lineNum">    1014 </span>            :                                   Bitstr* ISACBitStr_obj, int BWnumber,
<span class="lineNum">    1015 </span>            :                                   float scale) {
<span class="lineNum">    1016 </span>            :   int ii;
<span class="lineNum">    1017 </span>            :   int status;
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   int BWno = BWnumber;</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :   const uint16_t* WebRtcIsac_kQPitchGainCdf_ptr[1];
<span class="lineNum">    1021 </span>            :   const uint16_t** cdf;
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            :   double tmpLPCcoeffs_lo[(ORDERLO + 1)*SUBFRAMES * 2];
<span class="lineNum">    1024 </span>            :   double tmpLPCcoeffs_hi[(ORDERHI + 1)*SUBFRAMES * 2];
<span class="lineNum">    1025 </span>            :   int tmpLPCindex_g[12 * 2];
<span class="lineNum">    1026 </span>            :   int16_t tmp_fre[FRAMESAMPLES], tmp_fim[FRAMESAMPLES];
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   const int kModel = 0;</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            :   /* Sanity Check - possible values for BWnumber is 0 - 23. */
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   if ((BWnumber &lt; 0) || (BWnumber &gt; 23)) {</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     return -ISAC_RANGE_ERROR_BW_ESTIMATOR;</span>
<span class="lineNum">    1032 </span>            :   }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :   /* Reset bit-stream. */
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   WebRtcIsac_ResetBitstream(ISACBitStr_obj);</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            :   /* Encode frame length */
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   status = WebRtcIsac_EncodeFrameLen(ISACSavedEnc_obj-&gt;framelength,</span>
<span class="lineNum">    1039 </span>            :                                      ISACBitStr_obj);
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   if (status &lt; 0) {</span>
<span class="lineNum">    1041 </span>            :     /* Wrong frame size. */
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     return status;</span>
<span class="lineNum">    1043 </span>            :   }
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   /* Transcoding */
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   if ((scale &gt; 0.0) &amp;&amp; (scale &lt; 1.0)) {</span>
<span class="lineNum">    1047 </span>            :     /* Compensate LPC gain. */
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :     for (ii = 0;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         ii &lt; ((ORDERLO + 1)* SUBFRAMES * (1 + ISACSavedEnc_obj-&gt;startIdx));</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         ii++) {</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       tmpLPCcoeffs_lo[ii] = scale *  ISACSavedEnc_obj-&gt;LPCcoeffs_lo[ii];</span>
<span class="lineNum">    1052 </span>            :     }
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     for (ii = 0;</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         ii &lt; ((ORDERHI + 1) * SUBFRAMES * (1 + ISACSavedEnc_obj-&gt;startIdx));</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         ii++) {</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       tmpLPCcoeffs_hi[ii] = scale *  ISACSavedEnc_obj-&gt;LPCcoeffs_hi[ii];</span>
<span class="lineNum">    1057 </span>            :     }
<span class="lineNum">    1058 </span>            :     /* Scale DFT. */
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     for (ii = 0;</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         ii &lt; (FRAMESAMPLES_HALF * (1 + ISACSavedEnc_obj-&gt;startIdx));</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         ii++) {</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :       tmp_fre[ii] = (int16_t)((scale) * (float)ISACSavedEnc_obj-&gt;fre[ii]);</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       tmp_fim[ii] = (int16_t)((scale) * (float)ISACSavedEnc_obj-&gt;fim[ii]);</span>
<span class="lineNum">    1064 </span>            :     }
<span class="lineNum">    1065 </span>            :   } else {
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     for (ii = 0;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         ii &lt; (KLT_ORDER_GAIN * (1 + ISACSavedEnc_obj-&gt;startIdx));</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         ii++) {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       tmpLPCindex_g[ii] =  ISACSavedEnc_obj-&gt;LPCindex_g[ii];</span>
<span class="lineNum">    1070 </span>            :     }
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     for (ii = 0;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         ii &lt; (FRAMESAMPLES_HALF * (1 + ISACSavedEnc_obj-&gt;startIdx));</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         ii++) {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :       tmp_fre[ii] = ISACSavedEnc_obj-&gt;fre[ii];</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :       tmp_fim[ii] = ISACSavedEnc_obj-&gt;fim[ii];</span>
<span class="lineNum">    1076 </span>            :     }
<span class="lineNum">    1077 </span>            :   }
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :   /* Encode bandwidth estimate. */
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeReceiveBw(&amp;BWno, ISACBitStr_obj);</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            :   /* Loop over number of 30 msec */
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :   for (ii = 0; ii &lt;= ISACSavedEnc_obj-&gt;startIdx; ii++) {</span>
<span class="lineNum">    1084 </span>            :     /* Encode pitch gains. */
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     *WebRtcIsac_kQPitchGainCdf_ptr = WebRtcIsac_kQPitchGainCdf;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(ISACBitStr_obj,</span>
<span class="lineNum">    1087 </span>            :                             &amp;ISACSavedEnc_obj-&gt;pitchGain_index[ii],
<span class="lineNum">    1088 </span>            :                             WebRtcIsac_kQPitchGainCdf_ptr, 1);
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :     /* Entropy coding of quantization pitch lags */
<span class="lineNum">    1091 </span>            :     /* Voicing classification. */
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :     if (ISACSavedEnc_obj-&gt;meanGain[ii] &lt; 0.2) {</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       cdf = WebRtcIsac_kQPitchLagCdfPtrLo;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     } else if (ISACSavedEnc_obj-&gt;meanGain[ii] &lt; 0.4) {</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :       cdf = WebRtcIsac_kQPitchLagCdfPtrMid;</span>
<span class="lineNum">    1096 </span>            :     } else {
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :       cdf = WebRtcIsac_kQPitchLagCdfPtrHi;</span>
<span class="lineNum">    1098 </span>            :     }
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(ISACBitStr_obj,</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                             &amp;ISACSavedEnc_obj-&gt;pitchIndex[PITCH_SUBFRAMES * ii],</span>
<span class="lineNum">    1101 </span>            :                             cdf, PITCH_SUBFRAMES);
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span>            :     /* LPC */
<span class="lineNum">    1104 </span>            :     /* Only one model exists. The entropy coding is done only for backward
<span class="lineNum">    1105 </span>            :      * compatibility. */
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(ISACBitStr_obj, &amp;kModel,</span>
<span class="lineNum">    1107 </span>            :                             WebRtcIsac_kQKltModelCdfPtr, 1);
<span class="lineNum">    1108 </span>            :     /* Entropy coding of quantization indices - LPC shape only. */
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(ISACBitStr_obj,</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                             &amp;ISACSavedEnc_obj-&gt;LPCindex_s[KLT_ORDER_SHAPE * ii],</span>
<span class="lineNum">    1111 </span>            :                             WebRtcIsac_kQKltCdfPtrShape,
<span class="lineNum">    1112 </span>            :                             KLT_ORDER_SHAPE);
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :     /* If transcoding, get new LPC gain indices */
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     if (scale &lt; 1.0) {</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       WebRtcIsac_TranscodeLPCCoef(</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :           &amp;tmpLPCcoeffs_lo[(ORDERLO + 1) * SUBFRAMES * ii],</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           &amp;tmpLPCcoeffs_hi[(ORDERHI + 1)*SUBFRAMES * ii],</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :           &amp;tmpLPCindex_g[KLT_ORDER_GAIN * ii]);</span>
<span class="lineNum">    1120 </span>            :     }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :     /* Entropy coding of quantization indices - LPC gain. */
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(ISACBitStr_obj, &amp;tmpLPCindex_g[KLT_ORDER_GAIN * ii],</span>
<span class="lineNum">    1124 </span>            :                             WebRtcIsac_kQKltCdfPtrGain, KLT_ORDER_GAIN);
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :     /* Quantization and loss-less coding. */
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     status = WebRtcIsac_EncodeSpec(&amp;tmp_fre[ii * FRAMESAMPLES_HALF],</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :                                    &amp;tmp_fim[ii * FRAMESAMPLES_HALF],</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                                    ISACSavedEnc_obj-&gt;AvgPitchGain[ii],</span>
<span class="lineNum">    1130 </span>            :                                    kIsacLowerBand, ISACBitStr_obj);
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     if (status &lt; 0) {</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :       return status;</span>
<span class="lineNum">    1133 </span>            :     }
<span class="lineNum">    1134 </span>            :   }
<span class="lineNum">    1135 </span>            :   /* Complete arithmetic coding. */
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :   return WebRtcIsac_EncTerminate(ISACBitStr_obj);</span>
<span class="lineNum">    1137 </span>            : }
<a name="1138"><span class="lineNum">    1138 </span>            : </a>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 : int WebRtcIsac_EncodeStoredDataUb(</span>
<span class="lineNum">    1141 </span>            :     const ISACUBSaveEncDataStruct* ISACSavedEnc_obj,
<span class="lineNum">    1142 </span>            :     Bitstr* bitStream,
<span class="lineNum">    1143 </span>            :     int32_t jitterInfo,
<span class="lineNum">    1144 </span>            :     float scale,
<span class="lineNum">    1145 </span>            :     enum ISACBandwidth bandwidth) {
<span class="lineNum">    1146 </span>            :   int n;
<span class="lineNum">    1147 </span>            :   int err;
<span class="lineNum">    1148 </span>            :   double lpcGain[SUBFRAMES];
<span class="lineNum">    1149 </span>            :   int16_t realFFT[FRAMESAMPLES_HALF];
<span class="lineNum">    1150 </span>            :   int16_t imagFFT[FRAMESAMPLES_HALF];
<span class="lineNum">    1151 </span>            :   const uint16_t** shape_cdf;
<span class="lineNum">    1152 </span>            :   int shape_len;
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   const int16_t kAveragePitchGain = 0.0;</span>
<span class="lineNum">    1154 </span>            :   enum ISACBand band;
<span class="lineNum">    1155 </span>            :   /* Reset bitstream. */
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   WebRtcIsac_ResetBitstream(bitStream);</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            :   /* Encode jitter index. */
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncodeJitterInfo(jitterInfo, bitStream);</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   err = WebRtcIsac_EncodeBandwidth(bandwidth, bitStream);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :   if (err &lt; 0) {</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    1164 </span>            :   }
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :   /* Encode LPC-shape. */
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   if (bandwidth == isac12kHz) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     shape_cdf = WebRtcIsac_kLpcShapeCdfMatUb12;</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :     shape_len = UB_LPC_ORDER * UB_LPC_VEC_PER_FRAME;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     band = kIsacUpperBand12;</span>
<span class="lineNum">    1171 </span>            :   } else {
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     shape_cdf = WebRtcIsac_kLpcShapeCdfMatUb16;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     shape_len = UB_LPC_ORDER * UB16_LPC_VEC_PER_FRAME;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     band = kIsacUpperBand16;</span>
<span class="lineNum">    1175 </span>            :   }
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :   WebRtcIsac_EncHistMulti(bitStream, ISACSavedEnc_obj-&gt;indexLPCShape,</span>
<span class="lineNum">    1177 </span>            :                           shape_cdf, shape_len);
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   if ((scale &lt;= 0.0) || (scale &gt;= 1.0)) {</span>
<span class="lineNum">    1180 </span>            :     /* We only consider scales between zero and one. */
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     WebRtcIsac_EncHistMulti(bitStream, ISACSavedEnc_obj-&gt;lpcGainIndex,</span>
<span class="lineNum">    1182 </span>            :                             WebRtcIsac_kLpcGainCdfMat, UB_LPC_GAIN_DIM);
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :     if (bandwidth == isac16kHz) {</span>
<span class="lineNum">    1184 </span>            :       /* Store gain indices of the second half. */
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :       WebRtcIsac_EncHistMulti(bitStream,</span>
<span class="lineNum">    1186 </span>            :                               &amp;ISACSavedEnc_obj-&gt;lpcGainIndex[SUBFRAMES],
<span class="lineNum">    1187 </span>            :                               WebRtcIsac_kLpcGainCdfMat, UB_LPC_GAIN_DIM);
<span class="lineNum">    1188 </span>            :     }
<span class="lineNum">    1189 </span>            :     /* Store FFT coefficients. */
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     err = WebRtcIsac_EncodeSpec(ISACSavedEnc_obj-&gt;realFFT,</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :                                 ISACSavedEnc_obj-&gt;imagFFT, kAveragePitchGain,</span>
<span class="lineNum">    1192 </span>            :                                 band, bitStream);
<span class="lineNum">    1193 </span>            :   } else {
<span class="lineNum">    1194 </span>            :     /* Scale LPC gain and FFT coefficients. */
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; SUBFRAMES; n++) {</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :       lpcGain[n] = scale * ISACSavedEnc_obj-&gt;lpcGain[n];</span>
<span class="lineNum">    1197 </span>            :     }
<span class="lineNum">    1198 </span>            :     /* Store LPC gains. */
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     WebRtcIsac_StoreLpcGainUb(lpcGain, bitStream);</span>
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     if (bandwidth == isac16kHz) {</span>
<span class="lineNum">    1202 </span>            :       /* Scale and code the gains of the second half of the frame, if 16kHz. */
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :       for (n = 0; n &lt; SUBFRAMES; n++) {</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         lpcGain[n] = scale * ISACSavedEnc_obj-&gt;lpcGain[n + SUBFRAMES];</span>
<span class="lineNum">    1205 </span>            :       }
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :       WebRtcIsac_StoreLpcGainUb(lpcGain, bitStream);</span>
<span class="lineNum">    1207 </span>            :     }
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; FRAMESAMPLES_HALF; n++) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :       realFFT[n] = (int16_t)(scale * (float)ISACSavedEnc_obj-&gt;realFFT[n] +</span>
<span class="lineNum">    1211 </span>            :           0.5f);
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :       imagFFT[n] = (int16_t)(scale * (float)ISACSavedEnc_obj-&gt;imagFFT[n] +</span>
<span class="lineNum">    1213 </span>            :           0.5f);
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span>            :     /* Store FFT coefficients. */
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     err = WebRtcIsac_EncodeSpec(realFFT, imagFFT, kAveragePitchGain,</span>
<span class="lineNum">    1217 </span>            :                                 band, bitStream);
<span class="lineNum">    1218 </span>            :   }
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   if (err &lt; 0) {</span>
<span class="lineNum">    1220 </span>            :     /* Error happened while encoding FFT coefficients. */
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    1222 </span>            :   }
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            :   /* Complete arithmetic coding. */
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   return WebRtcIsac_EncTerminate(bitStream);</span>
<a name="1226"><span class="lineNum">    1226 </span>            : }</a>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 : int16_t WebRtcIsac_GetRedPayloadUb(</span>
<span class="lineNum">    1229 </span>            :     const ISACUBSaveEncDataStruct* ISACSavedEncObj,
<span class="lineNum">    1230 </span>            :     Bitstr*                        bitStreamObj,
<span class="lineNum">    1231 </span>            :     enum ISACBandwidth             bandwidth) {
<span class="lineNum">    1232 </span>            :   int n;
<span class="lineNum">    1233 </span>            :   int16_t status;
<span class="lineNum">    1234 </span>            :   int16_t realFFT[FRAMESAMPLES_HALF];
<span class="lineNum">    1235 </span>            :   int16_t imagFFT[FRAMESAMPLES_HALF];
<span class="lineNum">    1236 </span>            :   enum ISACBand band;
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   const int16_t kAveragePitchGain = 0.0;</span>
<span class="lineNum">    1238 </span>            :   /* Store bit-stream object. */
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   memcpy(bitStreamObj, &amp;ISACSavedEncObj-&gt;bitStreamObj, sizeof(Bitstr));</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :   /* Scale FFT coefficients. */
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   for (n = 0; n &lt; FRAMESAMPLES_HALF; n++) {</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     realFFT[n] = (int16_t)((float)ISACSavedEncObj-&gt;realFFT[n] *</span>
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :         RCU_TRANSCODING_SCALE_UB + 0.5);</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     imagFFT[n] = (int16_t)((float)ISACSavedEncObj-&gt;imagFFT[n] *</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :         RCU_TRANSCODING_SCALE_UB + 0.5);</span>
<span class="lineNum">    1247 </span>            :   }
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :   band = (bandwidth == isac12kHz) ? kIsacUpperBand12 : kIsacUpperBand16;</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :   status = WebRtcIsac_EncodeSpec(realFFT, imagFFT, kAveragePitchGain, band,</span>
<span class="lineNum">    1251 </span>            :                                  bitStreamObj);
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   if (status &lt; 0) {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     return status;</span>
<span class="lineNum">    1254 </span>            :   } else {
<span class="lineNum">    1255 </span>            :     /* Terminate entropy coding */
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     return WebRtcIsac_EncTerminate(bitStreamObj);</span>
<span class="lineNum">    1257 </span>            :   }
<span class="lineNum">    1258 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

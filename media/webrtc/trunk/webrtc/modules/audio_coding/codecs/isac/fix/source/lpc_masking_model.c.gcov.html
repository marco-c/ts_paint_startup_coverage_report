<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/fix/source/lpc_masking_model.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../../../index.html">top level</a> - <a href="index.html">media/webrtc/trunk/webrtc/modules/audio_coding/codecs/isac/fix/source</a> - lpc_masking_model.c<span style="font-size: 80%;"> (source / <a href="lpc_masking_model.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">389</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : /*
<span class="lineNum">      12 </span>            :  * lpc_masking_model.c
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * LPC analysis and filtering functions
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;lpc_masking_model.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &lt;limits.h&gt;  /* For LLONG_MAX and LLONG_MIN. */
<span class="lineNum">      21 </span>            : #include &quot;codec.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;entropy_coding.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;settings.h&quot;
<a name="24"><span class="lineNum">      24 </span>            : </a>
<span class="lineNum">      25 </span>            : /* The conversion is implemented by the step-down algorithm */
<span class="lineNum">      26 </span><span class="lineNoCov">          0 : void WebRtcSpl_AToK_JSK(</span>
<span class="lineNum">      27 </span>            :     int16_t *a16, /* Q11 */
<span class="lineNum">      28 </span>            :     int16_t useOrder,
<span class="lineNum">      29 </span>            :     int16_t *k16  /* Q15 */
<span class="lineNum">      30 </span>            :                         )
<span class="lineNum">      31 </span>            : {
<span class="lineNum">      32 </span>            :   int m, k;
<span class="lineNum">      33 </span>            :   int32_t tmp32[MAX_AR_MODEL_ORDER];
<span class="lineNum">      34 </span>            :   int32_t tmp32b;
<span class="lineNum">      35 </span>            :   int32_t tmp_inv_denum32;
<span class="lineNum">      36 </span>            :   int16_t tmp_inv_denum16;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :   k16[useOrder-1] = a16[useOrder] &lt;&lt; 4;  // Q11&lt;&lt;4 =&gt; Q15</span>
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   for (m=useOrder-1; m&gt;0; m--) {</span>
<span class="lineNum">      41 </span>            :     // (1 - k^2) in Q30
<span class="lineNum">      42 </span><span class="lineNoCov">          0 :     tmp_inv_denum32 = 1073741823 - k16[m] * k16[m];</span>
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     tmp_inv_denum16 = (int16_t)(tmp_inv_denum32 &gt;&gt; 15);  // (1 - k^2) in Q15.</span>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :     for (k=1; k&lt;=m; k++) {</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :       tmp32b = (a16[k] &lt;&lt; 16) - ((k16[m] * a16[m - k + 1]) &lt;&lt; 1);</span>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :       tmp32[k] = WebRtcSpl_DivW32W16(tmp32b, tmp_inv_denum16); //Q27/Q15 = Q12</span>
<span class="lineNum">      49 </span>            :     }
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :     for (k=1; k&lt;m; k++) {</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :       a16[k] = (int16_t)(tmp32[k] &gt;&gt; 1);  // Q12&gt;&gt;1 =&gt; Q11</span>
<span class="lineNum">      53 </span>            :     }
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :     tmp32[m] = WEBRTC_SPL_SAT(4092, tmp32[m], -4092);</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     k16[m - 1] = (int16_t)(tmp32[m] &lt;&lt; 3);  // Q12&lt;&lt;3 =&gt; Q15</span>
<span class="lineNum">      57 </span>            :   }
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">      60 </span>            : }
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : 
<a name="64"><span class="lineNum">      64 </span>            : </a>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineNoCov">          0 : int16_t WebRtcSpl_LevinsonW32_JSK(</span>
<span class="lineNum">      67 </span>            :     int32_t *R,  /* (i) Autocorrelation of length &gt;= order+1 */
<span class="lineNum">      68 </span>            :     int16_t *A,  /* (o) A[0..order] LPC coefficients (Q11) */
<span class="lineNum">      69 </span>            :     int16_t *K,  /* (o) K[0...order-1] Reflection coefficients (Q15) */
<span class="lineNum">      70 </span>            :     int16_t order /* (i) filter order */
<span class="lineNum">      71 </span>            :                                         ) {
<span class="lineNum">      72 </span>            :   int16_t i, j;
<span class="lineNum">      73 </span>            :   int16_t R_hi[LEVINSON_MAX_ORDER+1], R_low[LEVINSON_MAX_ORDER+1];
<span class="lineNum">      74 </span>            :   /* Aurocorr coefficients in high precision */
<span class="lineNum">      75 </span>            :   int16_t A_hi[LEVINSON_MAX_ORDER+1], A_low[LEVINSON_MAX_ORDER+1];
<span class="lineNum">      76 </span>            :   /* LPC coefficients in high precicion */
<span class="lineNum">      77 </span>            :   int16_t A_upd_hi[LEVINSON_MAX_ORDER+1], A_upd_low[LEVINSON_MAX_ORDER+1];
<span class="lineNum">      78 </span>            :   /* LPC coefficients for next iteration */
<span class="lineNum">      79 </span>            :   int16_t K_hi, K_low;      /* reflection coefficient in high precision */
<span class="lineNum">      80 </span>            :   int16_t Alpha_hi, Alpha_low, Alpha_exp; /* Prediction gain Alpha in high precision
<span class="lineNum">      81 </span>            :                                                    and with scale factor */
<span class="lineNum">      82 </span>            :   int16_t tmp_hi, tmp_low;
<span class="lineNum">      83 </span>            :   int32_t temp1W32, temp2W32, temp3W32;
<span class="lineNum">      84 </span>            :   int16_t norm;
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :   /* Normalize the autocorrelation R[0]...R[order+1] */
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   norm = WebRtcSpl_NormW32(R[0]);</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   for (i=order;i&gt;=0;i--) {</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     temp1W32 = R[i] &lt;&lt; norm;</span>
<span class="lineNum">      92 </span>            :     /* Put R in hi and low format */
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     R_hi[i] = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     R_low[i] = (int16_t)((temp1W32 - ((int32_t)R_hi[i] &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">      95 </span>            :   }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   /* K = A[1] = -R[1] / R[0] */
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   temp2W32 = (R_hi[1] &lt;&lt; 16) + (R_low[1] &lt;&lt; 1);  /* R[1] in Q31      */</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   temp3W32  = WEBRTC_SPL_ABS_W32(temp2W32);      /* abs R[1]         */</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   temp1W32  = WebRtcSpl_DivW32HiLow(temp3W32, R_hi[0], R_low[0]); /* abs(R[1])/R[0] in Q31 */</span>
<span class="lineNum">     102 </span>            :   /* Put back the sign on R[1] */
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   if (temp2W32 &gt; 0) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     temp1W32 = -temp1W32;</span>
<span class="lineNum">     105 </span>            :   }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   /* Put K in hi and low format */
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   K_hi = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   K_low = (int16_t)((temp1W32 - ((int32_t)K_hi &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   /* Store first reflection coefficient */
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   K[0] = K_hi;</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   temp1W32 &gt;&gt;= 4;  /* A[1] in Q27. */</span>
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   /* Put A[1] in hi and low format */
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   A_hi[1] = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   A_low[1] = (int16_t)((temp1W32 - ((int32_t)A_hi[1] &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   /*  Alpha = R[0] * (1-K^2) */
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   temp1W32  = (((K_hi * K_low) &gt;&gt; 14) + K_hi * K_hi) &lt;&lt; 1;  /* = k^2 in Q31 */</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   temp1W32 = WEBRTC_SPL_ABS_W32(temp1W32);    /* Guard against &lt;0 */</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   temp1W32 = (int32_t)0x7fffffffL - temp1W32;    /* temp1W32 = (1 - K[0]*K[0]) in Q31 */</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :   /* Store temp1W32 = 1 - K[0]*K[0] on hi and low format */
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   tmp_hi = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   tmp_low = (int16_t)((temp1W32 - ((int32_t)tmp_hi &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :   /* Calculate Alpha in Q31 */
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   temp1W32 = (R_hi[0] * tmp_hi + ((R_hi[0] * tmp_low) &gt;&gt; 15) +</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       ((R_low[0] * tmp_hi) &gt;&gt; 15)) &lt;&lt; 1;</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :   /* Normalize Alpha and put it in hi and low format */
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   Alpha_exp = WebRtcSpl_NormW32(temp1W32);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   temp1W32 &lt;&lt;= Alpha_exp;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   Alpha_hi = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   Alpha_low = (int16_t)((temp1W32 - ((int32_t)Alpha_hi&lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   /* Perform the iterative calculations in the
<span class="lineNum">     143 </span>            :      Levinson Durbin algorithm */
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   for (i=2; i&lt;=order; i++)</span>
<span class="lineNum">     146 </span>            :   {
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     /*                    ----
<span class="lineNum">     149 </span>            :                           \
<span class="lineNum">     150 </span>            :         temp1W32 =  R[i] + &gt; R[j]*A[i-j]
<span class="lineNum">     151 </span>            :                           /
<span class="lineNum">     152 </span>            :                           ----
<span class="lineNum">     153 </span>            :                           j=1..i-1
<span class="lineNum">     154 </span>            :     */
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     temp1W32 = 0;</span>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     for(j=1; j&lt;i; j++) {</span>
<span class="lineNum">     159 </span>            :       /* temp1W32 is in Q31 */
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       temp1W32 += ((R_hi[j] * A_hi[i - j]) &lt;&lt; 1) +</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :           ((((R_hi[j] * A_low[i - j]) &gt;&gt; 15) +</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :               ((R_low[j] * A_hi[i - j]) &gt;&gt; 15)) &lt;&lt; 1);</span>
<span class="lineNum">     163 </span>            :     }
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     temp1W32 &lt;&lt;= 4;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     temp1W32 += (R_hi[i] &lt;&lt; 16) + (R_low[i] &lt;&lt; 1);</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :     /* K = -temp1W32 / Alpha */
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     temp2W32 = WEBRTC_SPL_ABS_W32(temp1W32);      /* abs(temp1W32) */</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     temp3W32 = WebRtcSpl_DivW32HiLow(temp2W32, Alpha_hi, Alpha_low); /* abs(temp1W32)/Alpha */</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     /* Put the sign of temp1W32 back again */
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     if (temp1W32 &gt; 0) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       temp3W32 = -temp3W32;</span>
<span class="lineNum">     175 </span>            :     }
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :     /* Use the Alpha shifts from earlier to denormalize */
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     norm = WebRtcSpl_NormW32(temp3W32);</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     if ((Alpha_exp &lt;= norm)||(temp3W32==0)) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :       temp3W32 &lt;&lt;= Alpha_exp;</span>
<span class="lineNum">     181 </span>            :     } else {
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       if (temp3W32 &gt; 0)</span>
<span class="lineNum">     183 </span>            :       {
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :         temp3W32 = (int32_t)0x7fffffffL;</span>
<span class="lineNum">     185 </span>            :       } else
<span class="lineNum">     186 </span>            :       {
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         temp3W32 = (int32_t)0x80000000L;</span>
<span class="lineNum">     188 </span>            :       }
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     /* Put K on hi and low format */
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     K_hi = (int16_t)(temp3W32 &gt;&gt; 16);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     K_low = (int16_t)((temp3W32 - ((int32_t)K_hi &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :     /* Store Reflection coefficient in Q15 */
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     K[i-1] = K_hi;</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /* Test for unstable filter. If unstable return 0 and let the
<span class="lineNum">     199 </span>            :        user decide what to do in that case
<span class="lineNum">     200 </span>            :     */
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     if ((int32_t)WEBRTC_SPL_ABS_W16(K_hi) &gt; (int32_t)32740) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       return(-i); /* Unstable filter */</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :     /*
<span class="lineNum">     207 </span>            :       Compute updated LPC coefficient: Anew[i]
<span class="lineNum">     208 </span>            :       Anew[j]= A[j] + K*A[i-j]   for j=1..i-1
<span class="lineNum">     209 </span>            :       Anew[i]= K
<span class="lineNum">     210 </span>            :     */
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     for(j=1; j&lt;i; j++)</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       temp1W32 = (A_hi[j] &lt;&lt; 16) + (A_low[j] &lt;&lt; 1);  // temp1W32 = A[j] in Q27</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :       temp1W32 += (K_hi * A_hi[i - j] + ((K_hi * A_low[i - j]) &gt;&gt; 15) +</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :           ((K_low * A_hi[i - j]) &gt;&gt; 15)) &lt;&lt; 1;  // temp1W32 += K*A[i-j] in Q27.</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :       /* Put Anew in hi and low format */
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       A_upd_hi[j] = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       A_upd_low[j] = (int16_t)((temp1W32 - ((int32_t)A_upd_hi[j] &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     temp3W32 &gt;&gt;= 4;  /* temp3W32 = K in Q27 (Convert from Q31 to Q27) */</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     /* Store Anew in hi and low format */
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     A_upd_hi[i] = (int16_t)(temp3W32 &gt;&gt; 16);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     A_upd_low[i] = (int16_t)((temp3W32 - ((int32_t)A_upd_hi[i] &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :     /*  Alpha = Alpha * (1-K^2) */
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     temp1W32 = (((K_hi * K_low) &gt;&gt; 14) + K_hi * K_hi) &lt;&lt; 1;  /* K*K in Q31 */</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :     temp1W32 = WEBRTC_SPL_ABS_W32(temp1W32);      /* Guard against &lt;0 */</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     temp1W32 = (int32_t)0x7fffffffL - temp1W32;      /* 1 - K*K  in Q31 */</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :     /* Convert 1- K^2 in hi and low format */
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     tmp_hi = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     tmp_low = (int16_t)((temp1W32 - ((int32_t)tmp_hi &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :     /* Calculate Alpha = Alpha * (1-K^2) in Q31 */
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     temp1W32 = (Alpha_hi * tmp_hi + ((Alpha_hi * tmp_low) &gt;&gt; 15) +</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         ((Alpha_low * tmp_hi) &gt;&gt; 15)) &lt;&lt; 1;</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :     /* Normalize Alpha and store it on hi and low format */
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     norm = WebRtcSpl_NormW32(temp1W32);</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     temp1W32 &lt;&lt;= norm;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     Alpha_hi = (int16_t)(temp1W32 &gt;&gt; 16);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     Alpha_low = (int16_t)((temp1W32 - ((int32_t)Alpha_hi &lt;&lt; 16)) &gt;&gt; 1);</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :     /* Update the total nomalization of Alpha */
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     Alpha_exp = Alpha_exp + norm;</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :     /* Update A[] */
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     for(j=1; j&lt;=i; j++)</span>
<span class="lineNum">     259 </span>            :     {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       A_hi[j] =A_upd_hi[j];</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :       A_low[j] =A_upd_low[j];</span>
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span>            :   }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :   /*
<span class="lineNum">     266 </span>            :     Set A[0] to 1.0 and store the A[i] i=1...order in Q12
<span class="lineNum">     267 </span>            :     (Convert from Q27 and use rounding)
<span class="lineNum">     268 </span>            :   */
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   A[0] = 2048;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   for(i=1; i&lt;=order; i++) {</span>
<span class="lineNum">     273 </span>            :     /* temp1W32 in Q27 */
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     temp1W32 = (A_hi[i] &lt;&lt; 16) + (A_low[i] &lt;&lt; 1);</span>
<span class="lineNum">     275 </span>            :     /* Round and store upper word */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     A[i] = (int16_t)((temp1W32 + 32768) &gt;&gt; 16);</span>
<span class="lineNum">     277 </span>            :   }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   return(1); /* Stable filters */</span>
<span class="lineNum">     279 </span>            : }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            : /* window */
<span class="lineNum">     286 </span>            : /* Matlab generation of floating point code:
<span class="lineNum">     287 </span>            :  *  t = (1:256)/257; r = 1-(1-t).^.45; w = sin(r*pi).^3; w = w/sum(w); plot((1:256)/8, w); grid;
<span class="lineNum">     288 </span>            :  *  for k=1:16, fprintf(1, '%.8f, ', w(k*16 + (-15:0))); fprintf(1, '\n'); end
<span class="lineNum">     289 </span>            :  * All values are multiplyed with 2^21 in fixed point code.
<span class="lineNum">     290 </span>            :  */
<span class="lineNum">     291 </span>            : static const int16_t kWindowAutocorr[WINLEN] = {
<span class="lineNum">     292 </span>            :   0,     0,     0,     0,     0,     1,     1,     2,     2,     3,     5,     6,
<span class="lineNum">     293 </span>            :   8,    10,    12,    14,    17,    20,    24,    28,    33,    38,    43,    49,
<span class="lineNum">     294 </span>            :   56,    63,    71,    79,    88,    98,   108,   119,   131,   143,   157,   171,
<span class="lineNum">     295 </span>            :   186,   202,   219,   237,   256,   275,   296,   318,   341,   365,   390,   416,
<span class="lineNum">     296 </span>            :   444,   472,   502,   533,   566,   600,   635,   671,   709,   748,   789,   831,
<span class="lineNum">     297 </span>            :   875,   920,   967,  1015,  1065,  1116,  1170,  1224,  1281,  1339,  1399,  1461,
<span class="lineNum">     298 </span>            :   1525,  1590,  1657,  1726,  1797,  1870,  1945,  2021,  2100,  2181,  2263,  2348,
<span class="lineNum">     299 </span>            :   2434,  2523,  2614,  2706,  2801,  2898,  2997,  3099,  3202,  3307,  3415,  3525,
<span class="lineNum">     300 </span>            :   3637,  3751,  3867,  3986,  4106,  4229,  4354,  4481,  4611,  4742,  4876,  5012,
<span class="lineNum">     301 </span>            :   5150,  5291,  5433,  5578,  5725,  5874,  6025,  6178,  6333,  6490,  6650,  6811,
<span class="lineNum">     302 </span>            :   6974,  7140,  7307,  7476,  7647,  7820,  7995,  8171,  8349,  8529,  8711,  8894,
<span class="lineNum">     303 </span>            :   9079,  9265,  9453,  9642,  9833, 10024, 10217, 10412, 10607, 10803, 11000, 11199,
<span class="lineNum">     304 </span>            :   11398, 11597, 11797, 11998, 12200, 12401, 12603, 12805, 13008, 13210, 13412, 13614,
<span class="lineNum">     305 </span>            :   13815, 14016, 14216, 14416, 14615, 14813, 15009, 15205, 15399, 15591, 15782, 15971,
<span class="lineNum">     306 </span>            :   16157, 16342, 16524, 16704, 16881, 17056, 17227, 17395, 17559, 17720, 17877, 18030,
<span class="lineNum">     307 </span>            :   18179, 18323, 18462, 18597, 18727, 18851, 18970, 19082, 19189, 19290, 19384, 19471,
<span class="lineNum">     308 </span>            :   19551, 19623, 19689, 19746, 19795, 19835, 19867, 19890, 19904, 19908, 19902, 19886,
<span class="lineNum">     309 </span>            :   19860, 19823, 19775, 19715, 19644, 19561, 19465, 19357, 19237, 19102, 18955, 18793,
<span class="lineNum">     310 </span>            :   18618, 18428, 18223, 18004, 17769, 17518, 17252, 16970, 16672, 16357, 16025, 15677,
<span class="lineNum">     311 </span>            :   15311, 14929, 14529, 14111, 13677, 13225, 12755, 12268, 11764, 11243, 10706, 10152,
<span class="lineNum">     312 </span>            :   9583,  8998,  8399,  7787,  7162,  6527,  5883,  5231,  4576,  3919,  3265,  2620,
<span class="lineNum">     313 </span>            :   1990,  1386,   825,   333
<span class="lineNum">     314 </span>            : };
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : /* By using a hearing threshold level in dB of -28 dB (higher value gives more noise),
<span class="lineNum">     318 </span>            :    the H_T_H (in float) can be calculated as:
<span class="lineNum">     319 </span>            :    H_T_H = pow(10.0, 0.05 * (-28.0)) = 0.039810717055350
<span class="lineNum">     320 </span>            :    In Q19, H_T_H becomes round(0.039810717055350*2^19) ~= 20872, i.e.
<span class="lineNum">     321 </span>            :    H_T_H = 20872/524288.0, and H_T_HQ19 = 20872;
<span class="lineNum">     322 </span>            : */
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : /* The bandwidth expansion vectors are created from:
<span class="lineNum">     326 </span>            :    kPolyVecLo=[0.900000,0.810000,0.729000,0.656100,0.590490,0.531441,0.478297,0.430467,0.387420,0.348678,0.313811,0.282430];
<span class="lineNum">     327 </span>            :    kPolyVecHi=[0.800000,0.640000,0.512000,0.409600,0.327680,0.262144];
<span class="lineNum">     328 </span>            :    round(kPolyVecLo*32768)
<span class="lineNum">     329 </span>            :    round(kPolyVecHi*32768)
<span class="lineNum">     330 </span>            : */
<span class="lineNum">     331 </span>            : static const int16_t kPolyVecLo[12] = {
<span class="lineNum">     332 </span>            :   29491, 26542, 23888, 21499, 19349, 17414, 15673, 14106, 12695, 11425, 10283, 9255
<span class="lineNum">     333 </span>            : };
<span class="lineNum">     334 </span>            : static const int16_t kPolyVecHi[6] = {
<span class="lineNum">     335 </span>            :   26214, 20972, 16777, 13422, 10737, 8590
<a name="336"><span class="lineNum">     336 </span>            : };</a>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 : static __inline int32_t log2_Q8_LPC( uint32_t x ) {</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   int32_t zeros;
<span class="lineNum">     341 </span>            :   int16_t frac;
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   zeros=WebRtcSpl_NormU32(x);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   frac = (int16_t)(((x &lt;&lt; zeros) &amp; 0x7FFFFFFF) &gt;&gt; 23);</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            :   /* log2(x) */
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   return ((31 - zeros) &lt;&lt; 8) + frac;</span>
<span class="lineNum">     348 </span>            : }
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : static const int16_t kMulPitchGain = -25; /* 200/256 in Q5 */
<span class="lineNum">     351 </span>            : static const int16_t kChngFactor = 3523; /* log10(2)*10/4*0.4/1.4=log10(2)/1.4= 0.2150 in Q14 */
<span class="lineNum">     352 </span>            : static const int16_t kExp2 = 11819; /* 1/log(2) */
<span class="lineNum">     353 </span>            : const int kShiftLowerBand = 11;  /* Shift value for lower band in Q domain. */
<a name="354"><span class="lineNum">     354 </span>            : const int kShiftHigherBand = 12;  /* Shift value for higher band in Q domain. */</a>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : void WebRtcIsacfix_GetVars(const int16_t *input, const int16_t *pitchGains_Q12,</span>
<span class="lineNum">     357 </span>            :                            uint32_t *oldEnergy, int16_t *varscale)
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :   int k;
<span class="lineNum">     360 </span>            :   uint32_t nrgQ[4];
<span class="lineNum">     361 </span>            :   int16_t nrgQlog[4];
<span class="lineNum">     362 </span>            :   int16_t tmp16, chng1, chng2, chng3, chng4, tmp, chngQ, oldNrgQlog, pgQ, pg3;
<span class="lineNum">     363 </span>            :   int32_t expPg32;
<span class="lineNum">     364 </span>            :   int16_t expPg, divVal;
<span class="lineNum">     365 </span>            :   int16_t tmp16_1, tmp16_2;
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   /* Calculate energies of first and second frame halfs */
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   nrgQ[0]=0;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   for (k = QLOOKAHEAD/2; k &lt; (FRAMESAMPLES/4 + QLOOKAHEAD) / 2; k++) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     nrgQ[0] += (uint32_t)(input[k] * input[k]);</span>
<span class="lineNum">     371 </span>            :   }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   nrgQ[1]=0;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   for ( ; k &lt; (FRAMESAMPLES/2 + QLOOKAHEAD) / 2; k++) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     nrgQ[1] += (uint32_t)(input[k] * input[k]);</span>
<span class="lineNum">     375 </span>            :   }
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   nrgQ[2]=0;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   for ( ; k &lt; (FRAMESAMPLES * 3 / 4 + QLOOKAHEAD) / 2; k++) {</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     nrgQ[2] += (uint32_t)(input[k] * input[k]);</span>
<span class="lineNum">     379 </span>            :   }
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   nrgQ[3]=0;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   for ( ; k &lt; (FRAMESAMPLES + QLOOKAHEAD) / 2; k++) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     nrgQ[3] += (uint32_t)(input[k] * input[k]);</span>
<span class="lineNum">     383 </span>            :   }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   for ( k=0; k&lt;4; k++) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     nrgQlog[k] = (int16_t)log2_Q8_LPC(nrgQ[k]); /* log2(nrgQ) */</span>
<span class="lineNum">     387 </span>            :   }
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   oldNrgQlog = (int16_t)log2_Q8_LPC(*oldEnergy);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   /* Calculate average level change */
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   chng1 = WEBRTC_SPL_ABS_W16(nrgQlog[3]-nrgQlog[2]);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   chng2 = WEBRTC_SPL_ABS_W16(nrgQlog[2]-nrgQlog[1]);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   chng3 = WEBRTC_SPL_ABS_W16(nrgQlog[1]-nrgQlog[0]);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   chng4 = WEBRTC_SPL_ABS_W16(nrgQlog[0]-oldNrgQlog);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   tmp = chng1+chng2+chng3+chng4;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   chngQ = (int16_t)(tmp * kChngFactor &gt;&gt; 10);  /* Q12 */</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   chngQ += 2926; /* + 1.0/1.4 in Q12 */</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   /* Find average pitch gain */
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   pgQ = 0;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   for (k=0; k&lt;4; k++)</span>
<span class="lineNum">     402 </span>            :   {
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     pgQ += pitchGains_Q12[k];</span>
<span class="lineNum">     404 </span>            :   }
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   pg3 = (int16_t)(pgQ * pgQ &gt;&gt; 11);  // pgQ in Q(12+2)=Q14. Q14*Q14&gt;&gt;11 =&gt; Q17</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   pg3 = (int16_t)(pgQ * pg3 &gt;&gt; 13);  /* Q14*Q17&gt;&gt;13 =&gt;Q18  */</span>
<span class="lineNum">     408 </span>            :   /* kMulPitchGain = -25 = -200 in Q-3. */
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   pg3 = (int16_t)(pg3 * kMulPitchGain &gt;&gt; 5);  // Q10</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   tmp16=(int16_t)WEBRTC_SPL_MUL_16_16_RSFT_WITH_ROUND(kExp2,pg3,13);/* Q13*Q10&gt;&gt;13 =&gt; Q10*/</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   if (tmp16&lt;0) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     tmp16_2 = (0x0400 | (tmp16 &amp; 0x03FF));</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     tmp16_1 = ((uint16_t)(tmp16 ^ 0xFFFF) &gt;&gt; 10) - 3;  /* Gives result in Q14 */</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :     if (tmp16_1&lt;0)</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       expPg = -(tmp16_2 &lt;&lt; -tmp16_1);</span>
<span class="lineNum">     416 </span>            :     else
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       expPg = -(tmp16_2 &gt;&gt; tmp16_1);</span>
<span class="lineNum">     418 </span>            :   } else
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     expPg = (int16_t) -16384; /* 1 in Q14, since 2^0=1 */</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   expPg32 = (int32_t)expPg &lt;&lt; 8;  /* Q22 */</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   divVal = WebRtcSpl_DivW32W16ResW16(expPg32, chngQ); /* Q22/Q12=Q10 */</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   tmp16=(int16_t)WEBRTC_SPL_MUL_16_16_RSFT_WITH_ROUND(kExp2,divVal,13);/* Q13*Q10&gt;&gt;13 =&gt; Q10*/</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   if (tmp16&lt;0) {</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     tmp16_2 = (0x0400 | (tmp16 &amp; 0x03FF));</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     tmp16_1 = ((uint16_t)(tmp16 ^ 0xFFFF) &gt;&gt; 10) - 3;  /* Gives result in Q14 */</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     if (tmp16_1&lt;0)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       expPg = tmp16_2 &lt;&lt; -tmp16_1;</span>
<span class="lineNum">     430 </span>            :     else
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       expPg = tmp16_2 &gt;&gt; tmp16_1;</span>
<span class="lineNum">     432 </span>            :   } else
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     expPg = (int16_t) 16384; /* 1 in Q14, since 2^0=1 */</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   *varscale = expPg-1;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   *oldEnergy = nrgQ[3];</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     438 </span>            : 
<a name="439"><span class="lineNum">     439 </span>            : </a>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : static __inline int16_t  exp2_Q10_T(int16_t x) { // Both in and out in Q10</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   int16_t tmp16_1, tmp16_2;
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   tmp16_2=(int16_t)(0x0400|(x&amp;0x03FF));</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   tmp16_1 = -(x &gt;&gt; 10);</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   if(tmp16_1&gt;0)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     return tmp16_2 &gt;&gt; tmp16_1;</span>
<span class="lineNum">     449 </span>            :   else
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     return tmp16_2 &lt;&lt; -tmp16_1;</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : // Declare function pointers.
<span class="lineNum">     456 </span>            : AutocorrFix WebRtcIsacfix_AutocorrFix;
<span class="lineNum">     457 </span>            : CalculateResidualEnergy WebRtcIsacfix_CalculateResidualEnergy;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : /* This routine calculates the residual energy for LPC.
<a name="460"><span class="lineNum">     460 </span>            :  * Formula as shown in comments inside.</a>
<span class="lineNum">     461 </span>            :  */
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : int32_t WebRtcIsacfix_CalculateResidualEnergyC(int lpc_order,</span>
<span class="lineNum">     463 </span>            :                                                int32_t q_val_corr,
<span class="lineNum">     464 </span>            :                                                int q_val_polynomial,
<span class="lineNum">     465 </span>            :                                                int16_t* a_polynomial,
<span class="lineNum">     466 </span>            :                                                int32_t* corr_coeffs,
<span class="lineNum">     467 </span>            :                                                int* q_val_residual_energy) {
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   int i = 0, j = 0;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   int shift_internal = 0, shift_norm = 0;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   int32_t tmp32 = 0, word32_high = 0, word32_low = 0, residual_energy = 0;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   int64_t sum64 = 0, sum64_tmp = 0;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt;= lpc_order; i++) {</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     for (j = i; j &lt;= lpc_order; j++) {</span>
<span class="lineNum">     475 </span>            :       /* For the case of i == 0: residual_energy +=
<span class="lineNum">     476 </span>            :        *    a_polynomial[j] * corr_coeffs[i] * a_polynomial[j - i];
<span class="lineNum">     477 </span>            :        * For the case of i != 0: residual_energy +=
<span class="lineNum">     478 </span>            :        *    a_polynomial[j] * corr_coeffs[i] * a_polynomial[j - i] * 2;
<span class="lineNum">     479 </span>            :        */
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :       tmp32 = a_polynomial[j] * a_polynomial[j - i];</span>
<span class="lineNum">     482 </span>            :                                    /* tmp32 in Q(q_val_polynomial * 2). */
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       if (i != 0) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         tmp32 &lt;&lt;= 1;</span>
<span class="lineNum">     485 </span>            :       }
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :       sum64_tmp = (int64_t)tmp32 * (int64_t)corr_coeffs[i];</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :       sum64_tmp &gt;&gt;= shift_internal;</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :       /* Test overflow and sum the result. */
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       if(((sum64_tmp &gt; 0 &amp;&amp; sum64 &gt; 0) &amp;&amp; (LLONG_MAX - sum64 &lt; sum64_tmp)) ||</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :          ((sum64_tmp &lt; 0 &amp;&amp; sum64 &lt; 0) &amp;&amp; (LLONG_MIN - sum64 &gt; sum64_tmp))) {</span>
<span class="lineNum">     492 </span>            :         /* Shift right for overflow. */
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :         shift_internal += 1;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         sum64 &gt;&gt;= 1;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :         sum64 += sum64_tmp &gt;&gt; 1;</span>
<span class="lineNum">     496 </span>            :       } else {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         sum64 += sum64_tmp;</span>
<span class="lineNum">     498 </span>            :       }
<span class="lineNum">     499 </span>            :     }
<span class="lineNum">     500 </span>            :   }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   word32_high = (int32_t)(sum64 &gt;&gt; 32);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   word32_low = (int32_t)sum64;</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   // Calculate the value of shifting (shift_norm) for the 64-bit sum.
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   if(word32_high != 0) {</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     shift_norm = 32 - WebRtcSpl_NormW32(word32_high);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     residual_energy = (int32_t)(sum64 &gt;&gt; shift_norm);</span>
<span class="lineNum">     509 </span>            :   } else {
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     if((word32_low &amp; 0x80000000) != 0) {</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :       shift_norm = 1;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :       residual_energy = (uint32_t)word32_low &gt;&gt; 1;</span>
<span class="lineNum">     513 </span>            :     } else {
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       shift_norm = WebRtcSpl_NormW32(word32_low);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       residual_energy = word32_low &lt;&lt; shift_norm;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       shift_norm = -shift_norm;</span>
<span class="lineNum">     517 </span>            :     }
<span class="lineNum">     518 </span>            :   }
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   /* Q(q_val_polynomial * 2) * Q(q_val_corr) &gt;&gt; shift_internal &gt;&gt; shift_norm
<span class="lineNum">     521 </span>            :    *   = Q(q_val_corr - shift_internal - shift_norm + q_val_polynomial * 2)
<span class="lineNum">     522 </span>            :    */
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   *q_val_residual_energy = q_val_corr - shift_internal - shift_norm</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                            + q_val_polynomial * 2;</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   return residual_energy;</span>
<a name="527"><span class="lineNum">     527 </span>            : }</a>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 : void WebRtcIsacfix_GetLpcCoef(int16_t *inLoQ0,</span>
<span class="lineNum">     530 </span>            :                               int16_t *inHiQ0,
<span class="lineNum">     531 </span>            :                               MaskFiltstr_enc *maskdata,
<span class="lineNum">     532 </span>            :                               int16_t snrQ10,
<span class="lineNum">     533 </span>            :                               const int16_t *pitchGains_Q12,
<span class="lineNum">     534 </span>            :                               int32_t *gain_lo_hiQ17,
<span class="lineNum">     535 </span>            :                               int16_t *lo_coeffQ15,
<span class="lineNum">     536 </span>            :                               int16_t *hi_coeffQ15)
<span class="lineNum">     537 </span>            : {
<span class="lineNum">     538 </span>            :   int k, n, ii;
<span class="lineNum">     539 </span>            :   int pos1, pos2;
<span class="lineNum">     540 </span>            :   int sh_lo, sh_hi, sh, ssh, shMem;
<span class="lineNum">     541 </span>            :   int16_t varscaleQ14;
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   int16_t tmpQQlo, tmpQQhi;
<span class="lineNum">     544 </span>            :   int32_t tmp32;
<span class="lineNum">     545 </span>            :   int16_t tmp16,tmp16b;
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   int16_t polyHI[ORDERHI+1];
<span class="lineNum">     548 </span>            :   int16_t rcQ15_lo[ORDERLO], rcQ15_hi[ORDERHI];
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :   int16_t DataLoQ6[WINLEN], DataHiQ6[WINLEN];
<span class="lineNum">     552 </span>            :   int32_t corrloQQ[ORDERLO+2];
<span class="lineNum">     553 </span>            :   int32_t corrhiQQ[ORDERHI+1];
<span class="lineNum">     554 </span>            :   int32_t corrlo2QQ[ORDERLO+1];
<span class="lineNum">     555 </span>            :   int16_t scale;
<span class="lineNum">     556 </span>            :   int16_t QdomLO, QdomHI, newQdomHI, newQdomLO;
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :   int32_t res_nrgQQ;
<span class="lineNum">     559 </span>            :   int32_t sqrt_nrg;
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :   /* less-noise-at-low-frequencies factor */
<span class="lineNum">     562 </span>            :   int16_t aaQ14;
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :   /* Multiplication with 1/sqrt(12) ~= 0.28901734104046 can be done by convertion to
<span class="lineNum">     565 </span>            :      Q15, i.e. round(0.28901734104046*32768) = 9471, and use 9471/32768.0 ~= 0.289032
<span class="lineNum">     566 </span>            :   */
<span class="lineNum">     567 </span>            :   int16_t snrq;
<span class="lineNum">     568 </span>            :   int shft;
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   int16_t tmp16a;
<span class="lineNum">     571 </span>            :   int32_t tmp32a, tmp32b, tmp32c;
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :   int16_t a_LOQ11[ORDERLO+1];
<span class="lineNum">     574 </span>            :   int16_t k_vecloQ15[ORDERLO];
<span class="lineNum">     575 </span>            :   int16_t a_HIQ12[ORDERHI+1];
<span class="lineNum">     576 </span>            :   int16_t k_vechiQ15[ORDERHI];
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   int16_t stab;
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   snrq=snrQ10;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :   /* SNR= C * 2 ^ (D * snrq) ; C=0.289, D=0.05*log2(10)=0.166 (~=172 in Q10)*/
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   tmp16 = (int16_t)(snrq * 172 &gt;&gt; 10);  // Q10</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   tmp16b = exp2_Q10_T(tmp16); // Q10</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   snrq = (int16_t)(tmp16b * 285 &gt;&gt; 10);  // Q10</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   /* change quallevel depending on pitch gains and level fluctuations */
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   WebRtcIsacfix_GetVars(inLoQ0, pitchGains_Q12, &amp;(maskdata-&gt;OldEnergy), &amp;varscaleQ14);</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   /* less-noise-at-low-frequencies factor */
<span class="lineNum">     591 </span>            :   /* Calculation of 0.35 * (0.5 + 0.5 * varscale) in fixpoint:
<span class="lineNum">     592 </span>            :      With 0.35 in Q16 (0.35 ~= 22938/65536.0 = 0.3500061) and varscaleQ14 in Q14,
<span class="lineNum">     593 </span>            :      we get Q16*Q14&gt;&gt;16 = Q14
<span class="lineNum">     594 </span>            :   */
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   aaQ14 = (int16_t)((22938 * (8192 + (varscaleQ14 &gt;&gt; 1)) + 32768) &gt;&gt; 16);</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :   /* Calculate tmp = (1.0 + aa*aa); in Q12 */
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   tmp16 = (int16_t)(aaQ14 * aaQ14 &gt;&gt; 15);  // Q14*Q14&gt;&gt;15 = Q13</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   tmpQQlo = 4096 + (tmp16 &gt;&gt; 1);  // Q12 + Q13&gt;&gt;1 = Q12.</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   /* Calculate tmp = (1.0+aa) * (1.0+aa); */
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   tmp16 = 8192 + (aaQ14 &gt;&gt; 1);  // 1+a in Q13.</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   tmpQQhi = (int16_t)(tmp16 * tmp16 &gt;&gt; 14);  // Q13*Q13&gt;&gt;14 = Q12</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   /* replace data in buffer by new look-ahead data */
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   for (pos1 = 0; pos1 &lt; QLOOKAHEAD; pos1++) {</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     maskdata-&gt;DataBufferLoQ0[pos1 + WINLEN - QLOOKAHEAD] = inLoQ0[pos1];</span>
<span class="lineNum">     608 </span>            :   }
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; SUBFRAMES; k++) {</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :     /* Update input buffer and multiply signal with window */
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     for (pos1 = 0; pos1 &lt; WINLEN - UPDATE/2; pos1++) {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :       maskdata-&gt;DataBufferLoQ0[pos1] = maskdata-&gt;DataBufferLoQ0[pos1 + UPDATE/2];</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       maskdata-&gt;DataBufferHiQ0[pos1] = maskdata-&gt;DataBufferHiQ0[pos1 + UPDATE/2];</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       DataLoQ6[pos1] = (int16_t)(maskdata-&gt;DataBufferLoQ0[pos1] *</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           kWindowAutocorr[pos1] &gt;&gt; 15);  // Q0*Q21&gt;&gt;15 = Q6</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :       DataHiQ6[pos1] = (int16_t)(maskdata-&gt;DataBufferHiQ0[pos1] *</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :           kWindowAutocorr[pos1] &gt;&gt; 15);  // Q0*Q21&gt;&gt;15 = Q6</span>
<span class="lineNum">     620 </span>            :     }
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     pos2 = (int16_t)(k * UPDATE / 2);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; UPDATE/2; n++, pos1++) {</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :       maskdata-&gt;DataBufferLoQ0[pos1] = inLoQ0[QLOOKAHEAD + pos2];</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       maskdata-&gt;DataBufferHiQ0[pos1] = inHiQ0[pos2++];</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       DataLoQ6[pos1] = (int16_t)(maskdata-&gt;DataBufferLoQ0[pos1] *</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :           kWindowAutocorr[pos1] &gt;&gt; 15);  // Q0*Q21&gt;&gt;15 = Q6</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       DataHiQ6[pos1] = (int16_t)(maskdata-&gt;DataBufferHiQ0[pos1] *</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :           kWindowAutocorr[pos1] &gt;&gt; 15);  // Q0*Q21&gt;&gt;15 = Q6</span>
<span class="lineNum">     629 </span>            :     }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :     /* Get correlation coefficients */
<span class="lineNum">     632 </span>            :     /* The highest absolute value measured inside DataLo in the test set
<span class="lineNum">     633 </span>            :        For DataHi, corresponding value was 160.
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :        This means that it should be possible to represent the input values
<span class="lineNum">     636 </span>            :        to WebRtcSpl_AutoCorrelation() as Q6 values (since 307*2^6 =
<span class="lineNum">     637 </span>            :        19648). Of course, Q0 will also work, but due to the low energy in
<span class="lineNum">     638 </span>            :        DataLo and DataHi, the outputted autocorrelation will be more accurate
<span class="lineNum">     639 </span>            :        and mimic the floating point code better, by being in an high as possible
<span class="lineNum">     640 </span>            :        Q-domain.
<span class="lineNum">     641 </span>            :     */
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     WebRtcIsacfix_AutocorrFix(corrloQQ,DataLoQ6,WINLEN, ORDERLO+1, &amp;scale);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     QdomLO = 12-scale; // QdomLO is the Q-domain of corrloQQ</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     sh_lo = WebRtcSpl_NormW32(corrloQQ[0]);</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     QdomLO += sh_lo;</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     for (ii=0; ii&lt;ORDERLO+2; ii++) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       corrloQQ[ii] &lt;&lt;= sh_lo;</span>
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span>            :     /* It is investigated whether it was possible to use 16 bits for the
<span class="lineNum">     651 </span>            :        32-bit vector corrloQQ, but it didn't work. */
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     WebRtcIsacfix_AutocorrFix(corrhiQQ,DataHiQ6,WINLEN, ORDERHI, &amp;scale);</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     QdomHI = 12-scale; // QdomHI is the Q-domain of corrhiQQ</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     sh_hi = WebRtcSpl_NormW32(corrhiQQ[0]);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     QdomHI += sh_hi;</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     for (ii=0; ii&lt;ORDERHI+1; ii++) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       corrhiQQ[ii] &lt;&lt;= sh_hi;</span>
<span class="lineNum">     660 </span>            :     }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :     /* less noise for lower frequencies, by filtering/scaling autocorrelation sequences */
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     /* Calculate corrlo2[0] = tmpQQlo * corrlo[0] - 2.0*tmpQQlo * corrlo[1];*/
<span class="lineNum">     665 </span>            :     // |corrlo2QQ| in Q(QdomLO-5).
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     corrlo2QQ[0] = (WEBRTC_SPL_MUL_16_32_RSFT16(tmpQQlo, corrloQQ[0]) &gt;&gt; 1) -</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :         (WEBRTC_SPL_MUL_16_32_RSFT16(aaQ14, corrloQQ[1]) &gt;&gt; 2);</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :     /* Calculate corrlo2[n] = tmpQQlo * corrlo[n] - tmpQQlo * (corrlo[n-1] + corrlo[n+1]);*/
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     for (n = 1; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       tmp32 = (corrloQQ[n - 1] &gt;&gt; 1) + (corrloQQ[n + 1] &gt;&gt; 1);  // Q(QdomLO-1).</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       corrlo2QQ[n] = (WEBRTC_SPL_MUL_16_32_RSFT16(tmpQQlo, corrloQQ[n]) &gt;&gt; 1) -</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :           (WEBRTC_SPL_MUL_16_32_RSFT16(aaQ14, tmp32) &gt;&gt; 2);</span>
<span class="lineNum">     675 </span>            :     }
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     QdomLO -= 5;</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :     /* Calculate corrhi[n] = tmpQQhi * corrhi[n]; */
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERHI; n++) {</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :       corrhiQQ[n] = WEBRTC_SPL_MUL_16_32_RSFT16(tmpQQhi, corrhiQQ[n]); // Q(12+QdomHI-16) = Q(QdomHI-4)</span>
<span class="lineNum">     681 </span>            :     }
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     QdomHI -= 4;</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :     /* add white noise floor */
<span class="lineNum">     685 </span>            :     /* corrlo2QQ is in Q(QdomLO) and corrhiQQ is in Q(QdomHI) */
<span class="lineNum">     686 </span>            :     /* Calculate corrlo2[0] += 9.5367431640625e-7; and
<span class="lineNum">     687 </span>            :        corrhi[0]  += 9.5367431640625e-7, where the constant is 1/2^20 */
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     tmp32 = WEBRTC_SPL_SHIFT_W32((int32_t) 1, QdomLO-20);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     corrlo2QQ[0] += tmp32;</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     tmp32 = WEBRTC_SPL_SHIFT_W32((int32_t) 1, QdomHI-20);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     corrhiQQ[0]  += tmp32;</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :     /* corrlo2QQ is in Q(QdomLO) and corrhiQQ is in Q(QdomHI) before the following
<span class="lineNum">     695 </span>            :        code segment, where we want to make sure we get a 1-bit margin */
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       corrlo2QQ[n] &gt;&gt;= 1;  // Make sure we have a 1-bit margin.</span>
<span class="lineNum">     698 </span>            :     }
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     QdomLO -= 1; // Now, corrlo2QQ is in Q(QdomLO), with a 1-bit margin</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERHI; n++) {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       corrhiQQ[n] &gt;&gt;= 1;  // Make sure we have a 1-bit margin.</span>
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     QdomHI -= 1; // Now, corrhiQQ is in Q(QdomHI), with a 1-bit margin</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     newQdomLO = QdomLO;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     710 </span>            :       int32_t tmp, tmpB, tmpCorr;
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       int16_t alpha=328; //0.01 in Q15</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       int16_t beta=324; //(1-0.01)*0.01=0.0099 in Q15</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :       int16_t gamma=32440; //(1-0.01)=0.99 in Q15</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       if (maskdata-&gt;CorrBufLoQQ[n] != 0) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         shMem=WebRtcSpl_NormW32(maskdata-&gt;CorrBufLoQQ[n]);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         sh = QdomLO - maskdata-&gt;CorrBufLoQdom[n];</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :         if (sh&lt;=shMem) {</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufLoQQ[n], sh); // Get CorrBufLoQQ to same domain as corrlo2</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha, tmp);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         } else if ((sh-shMem)&lt;7){</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufLoQQ[n], shMem); // Shift up CorrBufLoQQ as much as possible</span>
<span class="lineNum">     723 </span>            :           // Shift |alpha| the number of times required to get |tmp| in QdomLO.
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha &lt;&lt; (sh - shMem), tmp);</span>
<span class="lineNum">     725 </span>            :         } else {
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufLoQQ[n], shMem); // Shift up CorrBufHiQQ as much as possible</span>
<span class="lineNum">     727 </span>            :           // Shift |alpha| as much as possible without overflow the number of
<span class="lineNum">     728 </span>            :           // times required to get |tmp| in QdomLO.
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha &lt;&lt; 6, tmp);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :           tmpCorr = corrloQQ[n] &gt;&gt; (sh - shMem - 6);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :           tmp = tmp + tmpCorr;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufLoQQ[n] = tmp;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :           newQdomLO = QdomLO-(sh-shMem-6);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufLoQdom[n] = newQdomLO;</span>
<span class="lineNum">     735 </span>            :         }
<span class="lineNum">     736 </span>            :       } else
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         tmp = 0;</span>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :       tmp = tmp + corrlo2QQ[n];</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :       maskdata-&gt;CorrBufLoQQ[n] = tmp;</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :       maskdata-&gt;CorrBufLoQdom[n] = QdomLO;</span>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       tmp=WEBRTC_SPL_MUL_16_32_RSFT15(beta, tmp);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       tmpB=WEBRTC_SPL_MUL_16_32_RSFT15(gamma, corrlo2QQ[n]);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :       corrlo2QQ[n] = tmp + tmpB;</span>
<span class="lineNum">     747 </span>            :     }
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     if( newQdomLO!=QdomLO) {</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       for (n = 0; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :         if (maskdata-&gt;CorrBufLoQdom[n] != newQdomLO)</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :           corrloQQ[n] &gt;&gt;= maskdata-&gt;CorrBufLoQdom[n] - newQdomLO;</span>
<span class="lineNum">     752 </span>            :       }
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       QdomLO = newQdomLO;</span>
<span class="lineNum">     754 </span>            :     }
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     newQdomHI = QdomHI;</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERHI; n++) {</span>
<span class="lineNum">     760 </span>            :       int32_t tmp, tmpB, tmpCorr;
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :       int16_t alpha=328; //0.01 in Q15</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       int16_t beta=324; //(1-0.01)*0.01=0.0099 in Q15</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :       int16_t gamma=32440; //(1-0.01)=0.99 in Q1</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :       if (maskdata-&gt;CorrBufHiQQ[n] != 0) {</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         shMem=WebRtcSpl_NormW32(maskdata-&gt;CorrBufHiQQ[n]);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :         sh = QdomHI - maskdata-&gt;CorrBufHiQdom[n];</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         if (sh&lt;=shMem) {</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufHiQQ[n], sh); // Get CorrBufHiQQ to same domain as corrhi</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha, tmp);</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :           tmpCorr = corrhiQQ[n];</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :           tmp = tmp + tmpCorr;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQQ[n] = tmp;</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQdom[n] = QdomHI;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         } else if ((sh-shMem)&lt;7) {</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufHiQQ[n], shMem); // Shift up CorrBufHiQQ as much as possible</span>
<span class="lineNum">     776 </span>            :           // Shift |alpha| the number of times required to get |tmp| in QdomHI.
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha &lt;&lt; (sh - shMem), tmp);</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :           tmpCorr = corrhiQQ[n];</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :           tmp = tmp + tmpCorr;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQQ[n] = tmp;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQdom[n] = QdomHI;</span>
<span class="lineNum">     782 </span>            :         } else {
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_SHIFT_W32(maskdata-&gt;CorrBufHiQQ[n], shMem); // Shift up CorrBufHiQQ as much as possible</span>
<span class="lineNum">     784 </span>            :           // Shift |alpha| as much as possible without overflow the number of
<span class="lineNum">     785 </span>            :           // times required to get |tmp| in QdomHI.
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :           tmp = WEBRTC_SPL_MUL_16_32_RSFT15(alpha &lt;&lt; 6, tmp);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :           tmpCorr = corrhiQQ[n] &gt;&gt; (sh - shMem - 6);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :           tmp = tmp + tmpCorr;</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQQ[n] = tmp;</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           newQdomHI = QdomHI-(sh-shMem-6);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :           maskdata-&gt;CorrBufHiQdom[n] = newQdomHI;</span>
<span class="lineNum">     792 </span>            :         }
<span class="lineNum">     793 </span>            :       } else {
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         tmp = corrhiQQ[n];</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         tmpCorr = tmp;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         maskdata-&gt;CorrBufHiQQ[n] = tmp;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         maskdata-&gt;CorrBufHiQdom[n] = QdomHI;</span>
<span class="lineNum">     798 </span>            :       }
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :       tmp=WEBRTC_SPL_MUL_16_32_RSFT15(beta, tmp);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       tmpB=WEBRTC_SPL_MUL_16_32_RSFT15(gamma, tmpCorr);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       corrhiQQ[n] = tmp + tmpB;</span>
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     if( newQdomHI!=QdomHI) {</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       for (n = 0; n &lt;= ORDERHI; n++) {</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         if (maskdata-&gt;CorrBufHiQdom[n] != newQdomHI)</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :           corrhiQQ[n] &gt;&gt;= maskdata-&gt;CorrBufHiQdom[n] - newQdomHI;</span>
<span class="lineNum">     809 </span>            :       }
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       QdomHI = newQdomHI;</span>
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     stab=WebRtcSpl_LevinsonW32_JSK(corrlo2QQ, a_LOQ11, k_vecloQ15, ORDERLO);</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     if (stab&lt;0) {  // If unstable use lower order</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       a_LOQ11[0]=2048;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       for (n = 1; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         a_LOQ11[n]=0;</span>
<span class="lineNum">     819 </span>            :       }
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       stab=WebRtcSpl_LevinsonW32_JSK(corrlo2QQ, a_LOQ11, k_vecloQ15, 8);</span>
<span class="lineNum">     822 </span>            :     }
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     WebRtcSpl_LevinsonDurbin(corrhiQQ,  a_HIQ12,  k_vechiQ15, ORDERHI);</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :     /* bandwidth expansion */
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     for (n = 1; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :       a_LOQ11[n] = (int16_t)((kPolyVecLo[n - 1] * a_LOQ11[n] + (1 &lt;&lt; 14)) &gt;&gt;</span>
<span class="lineNum">     830 </span>            :           15);
<span class="lineNum">     831 </span>            :     }
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     polyHI[0] = a_HIQ12[0];</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     for (n = 1; n &lt;= ORDERHI; n++) {</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :       a_HIQ12[n] = (int16_t)(((int32_t)(kPolyVecHi[n - 1] * a_HIQ12[n]) +</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :         (1 &lt;&lt; 14)) &gt;&gt; 15);</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       polyHI[n] = a_HIQ12[n];</span>
<span class="lineNum">     839 </span>            :     }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :     /* Normalize the corrlo2 vector */
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :     sh = WebRtcSpl_NormW32(corrlo2QQ[0]);</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt;= ORDERLO; n++) {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :       corrlo2QQ[n] &lt;&lt;= sh;</span>
<span class="lineNum">     845 </span>            :     }
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     QdomLO += sh; /* Now, corrlo2QQ is still in Q(QdomLO) */</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :     /* residual energy */
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     sh_lo = 31;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     res_nrgQQ = WebRtcIsacfix_CalculateResidualEnergy(ORDERLO, QdomLO,</span>
<span class="lineNum">     853 </span>            :         kShiftLowerBand, a_LOQ11, corrlo2QQ, &amp;sh_lo);
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :     /* Convert to reflection coefficients */
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     WebRtcSpl_AToK_JSK(a_LOQ11, ORDERLO, rcQ15_lo);</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     if (sh_lo &amp; 0x0001) {</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :       res_nrgQQ &gt;&gt;= 1;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :       sh_lo-=1;</span>
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     if( res_nrgQQ &gt; 0 )</span>
<span class="lineNum">     865 </span>            :     {
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       sqrt_nrg=WebRtcSpl_Sqrt(res_nrgQQ);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :       /* add hearing threshold and compute the gain */
<span class="lineNum">     869 </span>            :       /* lo_coeff = varscale * S_N_R / (sqrt_nrg + varscale * H_T_H); */
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       tmp32a = varscaleQ14 &gt;&gt; 1;  // H_T_HQ19=65536 (16-17=-1)</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :       ssh = sh_lo &gt;&gt; 1;  // sqrt_nrg is in Qssh.</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :       sh = ssh - 14;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       tmp32b = WEBRTC_SPL_SHIFT_W32(tmp32a, sh); // Q14-&gt;Qssh</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       tmp32c = sqrt_nrg + tmp32b;  // Qssh  (denominator)</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       tmp32a = varscaleQ14 * snrq;  // Q24 (numerator)</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :       sh = WebRtcSpl_NormW32(tmp32c);</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :       shft = 16 - sh;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :       tmp16a = (int16_t) WEBRTC_SPL_SHIFT_W32(tmp32c, -shft); // Q(ssh-shft)  (denominator)</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :       tmp32b = WebRtcSpl_DivW32W16(tmp32a, tmp16a); // Q(24-ssh+shft)</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       sh = ssh-shft-7;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       *gain_lo_hiQ17 = WEBRTC_SPL_SHIFT_W32(tmp32b, sh);  // Gains in Q17</span>
<span class="lineNum">     885 </span>            :     }
<span class="lineNum">     886 </span>            :     else
<span class="lineNum">     887 </span>            :     {
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :       *gain_lo_hiQ17 = 100;  // Gains in Q17</span>
<span class="lineNum">     889 </span>            :     }
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     gain_lo_hiQ17++;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :     /* copy coefficients to output array */
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; ORDERLO; n++) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :       *lo_coeffQ15 = (int16_t) (rcQ15_lo[n]);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       lo_coeffQ15++;</span>
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span>            :     /* residual energy */
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     sh_hi = 31;</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     res_nrgQQ = WebRtcIsacfix_CalculateResidualEnergy(ORDERHI, QdomHI,</span>
<span class="lineNum">     900 </span>            :         kShiftHigherBand, a_HIQ12, corrhiQQ, &amp;sh_hi);
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            :     /* Convert to reflection coefficients */
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     WebRtcSpl_LpcToReflCoef(polyHI, ORDERHI, rcQ15_hi);</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     if (sh_hi &amp; 0x0001) {</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       res_nrgQQ &gt;&gt;= 1;</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       sh_hi-=1;</span>
<span class="lineNum">     908 </span>            :     }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     if( res_nrgQQ &gt; 0 )</span>
<span class="lineNum">     912 </span>            :     {
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       sqrt_nrg=WebRtcSpl_Sqrt(res_nrgQQ);</span>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :       /* add hearing threshold and compute the gain */
<span class="lineNum">     917 </span>            :       /* hi_coeff = varscale * S_N_R / (sqrt_nrg + varscale * H_T_H); */
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :       tmp32a = varscaleQ14 &gt;&gt; 1;  // H_T_HQ19=65536 (16-17=-1)</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :       ssh = sh_hi &gt;&gt; 1;  // |sqrt_nrg| is in Qssh.</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       sh = ssh - 14;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :       tmp32b = WEBRTC_SPL_SHIFT_W32(tmp32a, sh); // Q14-&gt;Qssh</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       tmp32c = sqrt_nrg + tmp32b;  // Qssh  (denominator)</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :       tmp32a = varscaleQ14 * snrq;  // Q24 (numerator)</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       sh = WebRtcSpl_NormW32(tmp32c);</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :       shft = 16 - sh;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :       tmp16a = (int16_t) WEBRTC_SPL_SHIFT_W32(tmp32c, -shft); // Q(ssh-shft)  (denominator)</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       tmp32b = WebRtcSpl_DivW32W16(tmp32a, tmp16a); // Q(24-ssh+shft)</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       sh = ssh-shft-7;</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       *gain_lo_hiQ17 = WEBRTC_SPL_SHIFT_W32(tmp32b, sh);  // Gains in Q17</span>
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span>            :     else
<span class="lineNum">     936 </span>            :     {
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       *gain_lo_hiQ17 = 100;  // Gains in Q17</span>
<span class="lineNum">     938 </span>            :     }
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     gain_lo_hiQ17++;</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :     /* copy coefficients to output array */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     for (n = 0; n &lt; ORDERHI; n++) {</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :       *hi_coeffQ15 = rcQ15_hi[n];</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :       hi_coeffQ15++;</span>
<span class="lineNum">     946 </span>            :     }
<span class="lineNum">     947 </span>            :   }
<span class="lineNum">     948 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

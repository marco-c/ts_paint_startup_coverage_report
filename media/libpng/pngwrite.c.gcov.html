<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libpng/pngwrite.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">media/libpng</a> - pngwrite.c<span style="font-size: 80%;"> (source / <a href="pngwrite.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">128</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : </a>
<span class="lineNum">       2 </span>            : /* pngwrite.c - general routines to write a PNG file
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Last changed in libpng 1.6.26 [October 20, 2016]
<span class="lineNum">       5 </span>            :  * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
<span class="lineNum">       6 </span>            :  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
<span class="lineNum">       7 </span>            :  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * This code is released under the libpng license.
<span class="lineNum">      10 </span>            :  * For conditions of distribution and use, see the disclaimer
<span class="lineNum">      11 </span>            :  * and license in png.h
<span class="lineNum">      12 </span>            :  */
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;pngpriv.h&quot;
<span class="lineNum">      15 </span>            : #ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
<span class="lineNum">      16 </span>            : #  include &lt;errno.h&gt;
<span class="lineNum">      17 </span>            : #endif /* SIMPLIFIED_WRITE_STDIO */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #ifdef PNG_WRITE_SUPPORTED
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">      22 </span>            : /* Write out all the unknown chunks for the current given location */
<span class="lineNum">      23 </span>            : static void
<span class="lineNum">      24 </span>            : write_unknown_chunks(png_structrp png_ptr, png_const_inforp info_ptr,
<span class="lineNum">      25 </span>            :     unsigned int where)
<span class="lineNum">      26 </span>            : {
<span class="lineNum">      27 </span>            :    if (info_ptr-&gt;unknown_chunks_num != 0)
<span class="lineNum">      28 </span>            :    {
<span class="lineNum">      29 </span>            :       png_const_unknown_chunkp up;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            :       png_debug(5, &quot;writing extra chunks&quot;);
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            :       for (up = info_ptr-&gt;unknown_chunks;
<span class="lineNum">      34 </span>            :            up &lt; info_ptr-&gt;unknown_chunks + info_ptr-&gt;unknown_chunks_num;
<span class="lineNum">      35 </span>            :            ++up)
<span class="lineNum">      36 </span>            :          if ((up-&gt;location &amp; where) != 0)
<span class="lineNum">      37 </span>            :       {
<span class="lineNum">      38 </span>            :          /* If per-chunk unknown chunk handling is enabled use it, otherwise
<span class="lineNum">      39 </span>            :           * just write the chunks the application has set.
<span class="lineNum">      40 </span>            :           */
<span class="lineNum">      41 </span>            : #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">      42 </span>            :          int keep = png_handle_as_unknown(png_ptr, up-&gt;name);
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :          /* NOTE: this code is radically different from the read side in the
<span class="lineNum">      45 </span>            :           * matter of handling an ancillary unknown chunk.  In the read side
<span class="lineNum">      46 </span>            :           * the default behavior is to discard it, in the code below the default
<span class="lineNum">      47 </span>            :           * behavior is to write it.  Critical chunks are, however, only
<span class="lineNum">      48 </span>            :           * written if explicitly listed or if the default is set to write all
<span class="lineNum">      49 </span>            :           * unknown chunks.
<span class="lineNum">      50 </span>            :           *
<span class="lineNum">      51 </span>            :           * The default handling is also slightly weird - it is not possible to
<span class="lineNum">      52 </span>            :           * stop the writing of all unsafe-to-copy chunks!
<span class="lineNum">      53 </span>            :           *
<span class="lineNum">      54 </span>            :           * TODO: REVIEW: this would seem to be a bug.
<span class="lineNum">      55 </span>            :           */
<span class="lineNum">      56 </span>            :          if (keep != PNG_HANDLE_CHUNK_NEVER &amp;&amp;
<span class="lineNum">      57 </span>            :              ((up-&gt;name[3] &amp; 0x20) /* safe-to-copy overrides everything */ ||
<span class="lineNum">      58 </span>            :               keep == PNG_HANDLE_CHUNK_ALWAYS ||
<span class="lineNum">      59 </span>            :               (keep == PNG_HANDLE_CHUNK_AS_DEFAULT &amp;&amp;
<span class="lineNum">      60 </span>            :                png_ptr-&gt;unknown_default == PNG_HANDLE_CHUNK_ALWAYS)))
<span class="lineNum">      61 </span>            : #endif
<span class="lineNum">      62 </span>            :          {
<span class="lineNum">      63 </span>            :             /* TODO: review, what is wrong with a zero length unknown chunk? */
<span class="lineNum">      64 </span>            :             if (up-&gt;size == 0)
<span class="lineNum">      65 </span>            :                png_warning(png_ptr, &quot;Writing zero-length unknown chunk&quot;);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :             png_write_chunk(png_ptr, up-&gt;name, up-&gt;data, up-&gt;size);
<span class="lineNum">      68 </span>            :          }
<span class="lineNum">      69 </span>            :       }
<span class="lineNum">      70 </span>            :    }
<span class="lineNum">      71 </span>            : }
<span class="lineNum">      72 </span>            : #endif /* WRITE_UNKNOWN_CHUNKS */
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* Writes all the PNG information.  This is the suggested way to use the
<span class="lineNum">      75 </span>            :  * library.  If you have a new chunk to add, make a function to write it,
<span class="lineNum">      76 </span>            :  * and put it in the correct location here.  If you want the chunk written
<span class="lineNum">      77 </span>            :  * after the image data, put it in png_write_end().  I strongly encourage
<span class="lineNum">      78 </span>            :  * you to supply a PNG_INFO_ flag, and check info_ptr-&gt;valid before writing
<span class="lineNum">      79 </span>            :  * the chunk, as that will keep the code from breaking if you want to just
<span class="lineNum">      80 </span>            :  * write a plain PNG file.  If you have long comments, I suggest writing
<span class="lineNum">      81 </span>            :  * them in png_write_end(), and compressing them.
<a name="82"><span class="lineNum">      82 </span>            :  */</a>
<span class="lineNum">      83 </span>            : void PNGAPI
<span class="lineNum">      84 </span><span class="lineNoCov">          0 : png_write_info_before_PLTE(png_structrp png_ptr, png_const_inforp info_ptr)</span>
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span>            :    png_debug(1, &quot;in png_write_info_before_PLTE&quot;);
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL || info_ptr == NULL)</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :    if ((png_ptr-&gt;mode &amp; PNG_WROTE_INFO_BEFORE_PLTE) == 0)</span>
<span class="lineNum">      92 </span>            :    {
<span class="lineNum">      93 </span>            :       /* Write PNG signature */
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :       png_write_sig(png_ptr);</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : #ifdef PNG_MNG_FEATURES_SUPPORTED
<span class="lineNum">      97 </span>            :       if ((png_ptr-&gt;mode &amp; PNG_HAVE_PNG_SIGNATURE) != 0 &amp;&amp; \
<span class="lineNum">      98 </span>            :           png_ptr-&gt;mng_features_permitted != 0)
<span class="lineNum">      99 </span>            :       {
<span class="lineNum">     100 </span>            :          png_warning(png_ptr,
<span class="lineNum">     101 </span>            :              &quot;MNG features are not allowed in a PNG datastream&quot;);
<span class="lineNum">     102 </span>            :          png_ptr-&gt;mng_features_permitted = 0;
<span class="lineNum">     103 </span>            :       }
<span class="lineNum">     104 </span>            : #endif
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :       /* Write IHDR information. */
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :       png_write_IHDR(png_ptr, info_ptr-&gt;width, info_ptr-&gt;height,</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :           info_ptr-&gt;bit_depth, info_ptr-&gt;color_type, info_ptr-&gt;compression_type,</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :           info_ptr-&gt;filter_type,</span>
<span class="lineNum">     110 </span>            : #ifdef PNG_WRITE_INTERLACING_SUPPORTED
<span class="lineNum">     111 </span>            :           info_ptr-&gt;interlace_type
<span class="lineNum">     112 </span>            : #else
<span class="lineNum">     113 </span>            :           0
<span class="lineNum">     114 </span>            : #endif
<span class="lineNum">     115 </span>            :          );
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :       /* The rest of these check to see if the valid field has the appropriate
<span class="lineNum">     118 </span>            :        * flag set, and if it does, writes the chunk.
<span class="lineNum">     119 </span>            :        *
<span class="lineNum">     120 </span>            :        * 1.6.0: COLORSPACE support controls the writing of these chunks too, and
<span class="lineNum">     121 </span>            :        * the chunks will be written if the WRITE routine is there and
<span class="lineNum">     122 </span>            :        * information * is available in the COLORSPACE. (See
<span class="lineNum">     123 </span>            :        * png_colorspace_sync_info in png.c for where the valid flags get set.)
<span class="lineNum">     124 </span>            :        *
<span class="lineNum">     125 </span>            :        * Under certain circumstances the colorspace can be invalidated without
<span class="lineNum">     126 </span>            :        * syncing the info_struct 'valid' flags; this happens if libpng detects
<span class="lineNum">     127 </span>            :        * an error and calls png_error while the color space is being set, yet
<span class="lineNum">     128 </span>            :        * the application continues writing the PNG.  So check the 'invalid'
<span class="lineNum">     129 </span>            :        * flag here too.
<span class="lineNum">     130 </span>            :        */
<span class="lineNum">     131 </span>            : #ifdef PNG_WRITE_APNG_SUPPORTED
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :    if ((info_ptr-&gt;valid &amp; PNG_INFO_acTL) != 0)</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :       png_write_acTL(png_ptr, info_ptr-&gt;num_frames, info_ptr-&gt;num_plays);</span>
<span class="lineNum">     134 </span>            : #endif
<span class="lineNum">     135 </span>            : #ifdef PNG_GAMMA_SUPPORTED
<span class="lineNum">     136 </span>            : #  ifdef PNG_WRITE_gAMA_SUPPORTED
<span class="lineNum">     137 </span>            :       if ((info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) == 0 &amp;&amp;
<span class="lineNum">     138 </span>            :           (info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_FROM_gAMA) != 0 &amp;&amp;
<span class="lineNum">     139 </span>            :           (info_ptr-&gt;valid &amp; PNG_INFO_gAMA) != 0)
<span class="lineNum">     140 </span>            :          png_write_gAMA_fixed(png_ptr, info_ptr-&gt;colorspace.gamma);
<span class="lineNum">     141 </span>            : #  endif
<span class="lineNum">     142 </span>            : #endif
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : #ifdef PNG_COLORSPACE_SUPPORTED
<span class="lineNum">     145 </span>            :       /* Write only one of sRGB or an ICC profile.  If a profile was supplied
<span class="lineNum">     146 </span>            :        * and it matches one of the known sRGB ones issue a warning.
<span class="lineNum">     147 </span>            :        */
<span class="lineNum">     148 </span>            : #  ifdef PNG_WRITE_iCCP_SUPPORTED
<span class="lineNum">     149 </span>            :          if ((info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) == 0 &amp;&amp;
<span class="lineNum">     150 </span>            :              (info_ptr-&gt;valid &amp; PNG_INFO_iCCP) != 0)
<span class="lineNum">     151 </span>            :          {
<span class="lineNum">     152 </span>            : #    ifdef PNG_WRITE_sRGB_SUPPORTED
<span class="lineNum">     153 </span>            :                if ((info_ptr-&gt;valid &amp; PNG_INFO_sRGB) != 0)
<span class="lineNum">     154 </span>            :                   png_app_warning(png_ptr,
<span class="lineNum">     155 </span>            :                       &quot;profile matches sRGB but writing iCCP instead&quot;);
<span class="lineNum">     156 </span>            : #     endif
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :             png_write_iCCP(png_ptr, info_ptr-&gt;iccp_name,
<span class="lineNum">     159 </span>            :                 info_ptr-&gt;iccp_profile);
<span class="lineNum">     160 </span>            :          }
<span class="lineNum">     161 </span>            : #     ifdef PNG_WRITE_sRGB_SUPPORTED
<span class="lineNum">     162 </span>            :          else
<span class="lineNum">     163 </span>            : #     endif
<span class="lineNum">     164 </span>            : #  endif
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : #  ifdef PNG_WRITE_sRGB_SUPPORTED
<span class="lineNum">     167 </span>            :          if ((info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) == 0 &amp;&amp;
<span class="lineNum">     168 </span>            :              (info_ptr-&gt;valid &amp; PNG_INFO_sRGB) != 0)
<span class="lineNum">     169 </span>            :             png_write_sRGB(png_ptr, info_ptr-&gt;colorspace.rendering_intent);
<span class="lineNum">     170 </span>            : #  endif /* WRITE_sRGB */
<span class="lineNum">     171 </span>            : #endif /* COLORSPACE */
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : #ifdef PNG_WRITE_sBIT_SUPPORTED
<span class="lineNum">     174 </span>            :          if ((info_ptr-&gt;valid &amp; PNG_INFO_sBIT) != 0)
<span class="lineNum">     175 </span>            :             png_write_sBIT(png_ptr, &amp;(info_ptr-&gt;sig_bit), info_ptr-&gt;color_type);
<span class="lineNum">     176 </span>            : #endif
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : #ifdef PNG_COLORSPACE_SUPPORTED
<span class="lineNum">     179 </span>            : #  ifdef PNG_WRITE_cHRM_SUPPORTED
<span class="lineNum">     180 </span>            :          if ((info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) == 0 &amp;&amp;
<span class="lineNum">     181 </span>            :              (info_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_FROM_cHRM) != 0 &amp;&amp;
<span class="lineNum">     182 </span>            :              (info_ptr-&gt;valid &amp; PNG_INFO_cHRM) != 0)
<span class="lineNum">     183 </span>            :             png_write_cHRM_fixed(png_ptr, &amp;info_ptr-&gt;colorspace.end_points_xy);
<span class="lineNum">     184 </span>            : #  endif
<span class="lineNum">     185 </span>            : #endif
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">     188 </span>            :          write_unknown_chunks(png_ptr, info_ptr, PNG_HAVE_IHDR);
<span class="lineNum">     189 </span>            : #endif
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :       png_ptr-&gt;mode |= PNG_WROTE_INFO_BEFORE_PLTE;</span>
<span class="lineNum">     192 </span>            :    }
<span class="lineNum">     193 </span>            : }
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : void PNGAPI
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : png_write_info(png_structrp png_ptr, png_const_inforp info_ptr)</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span>            : #if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
<span class="lineNum">     199 </span>            :    int i;
<span class="lineNum">     200 </span>            : #endif
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :    png_debug(1, &quot;in png_write_info&quot;);
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL || info_ptr == NULL)</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :    png_write_info_before_PLTE(png_ptr, info_ptr);</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :    if ((info_ptr-&gt;valid &amp; PNG_INFO_PLTE) != 0)</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :       png_write_PLTE(png_ptr, info_ptr-&gt;palette,</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :           (png_uint_32)info_ptr-&gt;num_palette);</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :    else if (info_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       png_error(png_ptr, &quot;Valid palette required for paletted images&quot;);</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : #ifdef PNG_WRITE_tRNS_SUPPORTED
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :    if ((info_ptr-&gt;valid &amp; PNG_INFO_tRNS) !=0)</span>
<span class="lineNum">     218 </span>            :    {
<span class="lineNum">     219 </span>            : #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
<span class="lineNum">     220 </span>            :       /* Invert the alpha channel (in tRNS) */
<span class="lineNum">     221 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_INVERT_ALPHA) != 0 &amp;&amp;
<span class="lineNum">     222 </span>            :           info_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
<span class="lineNum">     223 </span>            :       {
<span class="lineNum">     224 </span>            :          int j, jend;
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :          jend = info_ptr-&gt;num_trans;
<span class="lineNum">     227 </span>            :          if (jend &gt; PNG_MAX_PALETTE_LENGTH)
<span class="lineNum">     228 </span>            :             jend = PNG_MAX_PALETTE_LENGTH;
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :          for (j = 0; j&lt;jend; ++j)
<span class="lineNum">     231 </span>            :             info_ptr-&gt;trans_alpha[j] =
<span class="lineNum">     232 </span>            :                (png_byte)(255 - info_ptr-&gt;trans_alpha[j]);
<span class="lineNum">     233 </span>            :       }
<span class="lineNum">     234 </span>            : #endif
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :       png_write_tRNS(png_ptr, info_ptr-&gt;trans_alpha, &amp;(info_ptr-&gt;trans_color),</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :           info_ptr-&gt;num_trans, info_ptr-&gt;color_type);</span>
<span class="lineNum">     237 </span>            :    }
<span class="lineNum">     238 </span>            : #endif
<span class="lineNum">     239 </span>            : #ifdef PNG_WRITE_bKGD_SUPPORTED
<span class="lineNum">     240 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_bKGD) != 0)
<span class="lineNum">     241 </span>            :       png_write_bKGD(png_ptr, &amp;(info_ptr-&gt;background), info_ptr-&gt;color_type);
<span class="lineNum">     242 </span>            : #endif
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : #ifdef PNG_WRITE_hIST_SUPPORTED
<span class="lineNum">     245 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_hIST) != 0)
<span class="lineNum">     246 </span>            :       png_write_hIST(png_ptr, info_ptr-&gt;hist, info_ptr-&gt;num_palette);
<span class="lineNum">     247 </span>            : #endif
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : #ifdef PNG_WRITE_oFFs_SUPPORTED
<span class="lineNum">     250 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_oFFs) != 0)
<span class="lineNum">     251 </span>            :       png_write_oFFs(png_ptr, info_ptr-&gt;x_offset, info_ptr-&gt;y_offset,
<span class="lineNum">     252 </span>            :           info_ptr-&gt;offset_unit_type);
<span class="lineNum">     253 </span>            : #endif
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : #ifdef PNG_WRITE_pCAL_SUPPORTED
<span class="lineNum">     256 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_pCAL) != 0)
<span class="lineNum">     257 </span>            :       png_write_pCAL(png_ptr, info_ptr-&gt;pcal_purpose, info_ptr-&gt;pcal_X0,
<span class="lineNum">     258 </span>            :           info_ptr-&gt;pcal_X1, info_ptr-&gt;pcal_type, info_ptr-&gt;pcal_nparams,
<span class="lineNum">     259 </span>            :           info_ptr-&gt;pcal_units, info_ptr-&gt;pcal_params);
<span class="lineNum">     260 </span>            : #endif
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : #ifdef PNG_WRITE_sCAL_SUPPORTED
<span class="lineNum">     263 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_sCAL) != 0)
<span class="lineNum">     264 </span>            :       png_write_sCAL_s(png_ptr, (int)info_ptr-&gt;scal_unit,
<span class="lineNum">     265 </span>            :           info_ptr-&gt;scal_s_width, info_ptr-&gt;scal_s_height);
<span class="lineNum">     266 </span>            : #endif /* sCAL */
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : #ifdef PNG_WRITE_pHYs_SUPPORTED
<span class="lineNum">     269 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_pHYs) != 0)
<span class="lineNum">     270 </span>            :       png_write_pHYs(png_ptr, info_ptr-&gt;x_pixels_per_unit,
<span class="lineNum">     271 </span>            :           info_ptr-&gt;y_pixels_per_unit, info_ptr-&gt;phys_unit_type);
<span class="lineNum">     272 </span>            : #endif /* pHYs */
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : #ifdef PNG_WRITE_tIME_SUPPORTED
<span class="lineNum">     275 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_tIME) != 0)
<span class="lineNum">     276 </span>            :    {
<span class="lineNum">     277 </span>            :       png_write_tIME(png_ptr, &amp;(info_ptr-&gt;mod_time));
<span class="lineNum">     278 </span>            :       png_ptr-&gt;mode |= PNG_WROTE_tIME;
<span class="lineNum">     279 </span>            :    }
<span class="lineNum">     280 </span>            : #endif /* tIME */
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : #ifdef PNG_WRITE_sPLT_SUPPORTED
<span class="lineNum">     283 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_sPLT) != 0)
<span class="lineNum">     284 </span>            :       for (i = 0; i &lt; (int)info_ptr-&gt;splt_palettes_num; i++)
<span class="lineNum">     285 </span>            :          png_write_sPLT(png_ptr, info_ptr-&gt;splt_palettes + i);
<span class="lineNum">     286 </span>            : #endif /* sPLT */
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : #ifdef PNG_WRITE_TEXT_SUPPORTED
<span class="lineNum">     289 </span>            :    /* Check to see if we need to write text chunks */
<span class="lineNum">     290 </span>            :    for (i = 0; i &lt; info_ptr-&gt;num_text; i++)
<span class="lineNum">     291 </span>            :    {
<span class="lineNum">     292 </span>            :       png_debug2(2, &quot;Writing header text chunk %d, type %d&quot;, i,
<span class="lineNum">     293 </span>            :           info_ptr-&gt;text[i].compression);
<span class="lineNum">     294 </span>            :       /* An internationalized chunk? */
<span class="lineNum">     295 </span>            :       if (info_ptr-&gt;text[i].compression &gt; 0)
<span class="lineNum">     296 </span>            :       {
<span class="lineNum">     297 </span>            : #ifdef PNG_WRITE_iTXt_SUPPORTED
<span class="lineNum">     298 </span>            :          /* Write international chunk */
<span class="lineNum">     299 </span>            :          png_write_iTXt(png_ptr,
<span class="lineNum">     300 </span>            :              info_ptr-&gt;text[i].compression,
<span class="lineNum">     301 </span>            :              info_ptr-&gt;text[i].key,
<span class="lineNum">     302 </span>            :              info_ptr-&gt;text[i].lang,
<span class="lineNum">     303 </span>            :              info_ptr-&gt;text[i].lang_key,
<span class="lineNum">     304 </span>            :              info_ptr-&gt;text[i].text);
<span class="lineNum">     305 </span>            :          /* Mark this chunk as written */
<span class="lineNum">     306 </span>            :          if (info_ptr-&gt;text[i].compression == PNG_TEXT_COMPRESSION_NONE)
<span class="lineNum">     307 </span>            :             info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
<span class="lineNum">     308 </span>            :          else
<span class="lineNum">     309 </span>            :             info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
<span class="lineNum">     310 </span>            : #else
<span class="lineNum">     311 </span>            :          png_warning(png_ptr, &quot;Unable to write international text&quot;);
<span class="lineNum">     312 </span>            : #endif
<span class="lineNum">     313 </span>            :       }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :       /* If we want a compressed text chunk */
<span class="lineNum">     316 </span>            :       else if (info_ptr-&gt;text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
<span class="lineNum">     317 </span>            :       {
<span class="lineNum">     318 </span>            : #ifdef PNG_WRITE_zTXt_SUPPORTED
<span class="lineNum">     319 </span>            :          /* Write compressed chunk */
<span class="lineNum">     320 </span>            :          png_write_zTXt(png_ptr, info_ptr-&gt;text[i].key,
<span class="lineNum">     321 </span>            :              info_ptr-&gt;text[i].text, info_ptr-&gt;text[i].compression);
<span class="lineNum">     322 </span>            :          /* Mark this chunk as written */
<span class="lineNum">     323 </span>            :          info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
<span class="lineNum">     324 </span>            : #else
<span class="lineNum">     325 </span>            :          png_warning(png_ptr, &quot;Unable to write compressed text&quot;);
<span class="lineNum">     326 </span>            : #endif
<span class="lineNum">     327 </span>            :       }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :       else if (info_ptr-&gt;text[i].compression == PNG_TEXT_COMPRESSION_NONE)
<span class="lineNum">     330 </span>            :       {
<span class="lineNum">     331 </span>            : #ifdef PNG_WRITE_tEXt_SUPPORTED
<span class="lineNum">     332 </span>            :          /* Write uncompressed chunk */
<span class="lineNum">     333 </span>            :          png_write_tEXt(png_ptr, info_ptr-&gt;text[i].key,
<span class="lineNum">     334 </span>            :              info_ptr-&gt;text[i].text,
<span class="lineNum">     335 </span>            :              0);
<span class="lineNum">     336 </span>            :          /* Mark this chunk as written */
<span class="lineNum">     337 </span>            :          info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
<span class="lineNum">     338 </span>            : #else
<span class="lineNum">     339 </span>            :          /* Can't get here */
<span class="lineNum">     340 </span>            :          png_warning(png_ptr, &quot;Unable to write uncompressed text&quot;);
<span class="lineNum">     341 </span>            : #endif
<span class="lineNum">     342 </span>            :       }
<span class="lineNum">     343 </span>            :    }
<span class="lineNum">     344 </span>            : #endif /* tEXt */
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">     347 </span>            :    write_unknown_chunks(png_ptr, info_ptr, PNG_HAVE_PLTE);
<span class="lineNum">     348 </span>            : #endif
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : /* Writes the end of the PNG file.  If you don't want to write comments or
<span class="lineNum">     352 </span>            :  * time information, you can pass NULL for info.  If you already wrote these
<span class="lineNum">     353 </span>            :  * in png_write_info(), do not write them again here.  If you have long
<span class="lineNum">     354 </span>            :  * comments, I suggest writing them here, and compressing them.
<a name="355"><span class="lineNum">     355 </span>            :  */</a>
<span class="lineNum">     356 </span>            : void PNGAPI
<span class="lineNum">     357 </span><span class="lineNoCov">          0 : png_write_end(png_structrp png_ptr, png_inforp info_ptr)</span>
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :    png_debug(1, &quot;in png_write_end&quot;);
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) == 0)</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       png_error(png_ptr, &quot;No IDATs written into file&quot;);</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : #ifdef PNG_WRITE_APNG_SUPPORTED
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :    if (png_ptr-&gt;num_frames_written != png_ptr-&gt;num_frames_to_write)</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       png_error(png_ptr, &quot;Not enough frames written&quot;);</span>
<span class="lineNum">     370 </span>            : #endif
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
<span class="lineNum">     373 </span>            :    if (png_ptr-&gt;num_palette_max &gt; png_ptr-&gt;num_palette)
<span class="lineNum">     374 </span>            :       png_benign_error(png_ptr, &quot;Wrote palette index exceeding num_palette&quot;);
<span class="lineNum">     375 </span>            : #endif
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :    /* See if user wants us to write information chunks */
<span class="lineNum">     378 </span>            :    if (info_ptr != NULL)
<span class="lineNum">     379 </span>            :    {
<span class="lineNum">     380 </span>            : #ifdef PNG_WRITE_TEXT_SUPPORTED
<span class="lineNum">     381 </span>            :       int i; /* local index variable */
<span class="lineNum">     382 </span>            : #endif
<span class="lineNum">     383 </span>            : #ifdef PNG_WRITE_tIME_SUPPORTED
<span class="lineNum">     384 </span>            :       /* Check to see if user has supplied a time chunk */
<span class="lineNum">     385 </span>            :       if ((info_ptr-&gt;valid &amp; PNG_INFO_tIME) != 0 &amp;&amp;
<span class="lineNum">     386 </span>            :           (png_ptr-&gt;mode &amp; PNG_WROTE_tIME) == 0)
<span class="lineNum">     387 </span>            :          png_write_tIME(png_ptr, &amp;(info_ptr-&gt;mod_time));
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : #endif
<span class="lineNum">     390 </span>            : #ifdef PNG_WRITE_TEXT_SUPPORTED
<span class="lineNum">     391 </span>            :       /* Loop through comment chunks */
<span class="lineNum">     392 </span>            :       for (i = 0; i &lt; info_ptr-&gt;num_text; i++)
<span class="lineNum">     393 </span>            :       {
<span class="lineNum">     394 </span>            :          png_debug2(2, &quot;Writing trailer text chunk %d, type %d&quot;, i,
<span class="lineNum">     395 </span>            :              info_ptr-&gt;text[i].compression);
<span class="lineNum">     396 </span>            :          /* An internationalized chunk? */
<span class="lineNum">     397 </span>            :          if (info_ptr-&gt;text[i].compression &gt; 0)
<span class="lineNum">     398 </span>            :          {
<span class="lineNum">     399 </span>            : #ifdef PNG_WRITE_iTXt_SUPPORTED
<span class="lineNum">     400 </span>            :             /* Write international chunk */
<span class="lineNum">     401 </span>            :             png_write_iTXt(png_ptr,
<span class="lineNum">     402 </span>            :                 info_ptr-&gt;text[i].compression,
<span class="lineNum">     403 </span>            :                 info_ptr-&gt;text[i].key,
<span class="lineNum">     404 </span>            :                 info_ptr-&gt;text[i].lang,
<span class="lineNum">     405 </span>            :                 info_ptr-&gt;text[i].lang_key,
<span class="lineNum">     406 </span>            :                 info_ptr-&gt;text[i].text);
<span class="lineNum">     407 </span>            :             /* Mark this chunk as written */
<span class="lineNum">     408 </span>            :             if (info_ptr-&gt;text[i].compression == PNG_TEXT_COMPRESSION_NONE)
<span class="lineNum">     409 </span>            :                info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
<span class="lineNum">     410 </span>            :             else
<span class="lineNum">     411 </span>            :                info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
<span class="lineNum">     412 </span>            : #else
<span class="lineNum">     413 </span>            :             png_warning(png_ptr, &quot;Unable to write international text&quot;);
<span class="lineNum">     414 </span>            : #endif
<span class="lineNum">     415 </span>            :          }
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :          else if (info_ptr-&gt;text[i].compression &gt;= PNG_TEXT_COMPRESSION_zTXt)
<span class="lineNum">     418 </span>            :          {
<span class="lineNum">     419 </span>            : #ifdef PNG_WRITE_zTXt_SUPPORTED
<span class="lineNum">     420 </span>            :             /* Write compressed chunk */
<span class="lineNum">     421 </span>            :             png_write_zTXt(png_ptr, info_ptr-&gt;text[i].key,
<span class="lineNum">     422 </span>            :                 info_ptr-&gt;text[i].text, info_ptr-&gt;text[i].compression);
<span class="lineNum">     423 </span>            :             /* Mark this chunk as written */
<span class="lineNum">     424 </span>            :             info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
<span class="lineNum">     425 </span>            : #else
<span class="lineNum">     426 </span>            :             png_warning(png_ptr, &quot;Unable to write compressed text&quot;);
<span class="lineNum">     427 </span>            : #endif
<span class="lineNum">     428 </span>            :          }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :          else if (info_ptr-&gt;text[i].compression == PNG_TEXT_COMPRESSION_NONE)
<span class="lineNum">     431 </span>            :          {
<span class="lineNum">     432 </span>            : #ifdef PNG_WRITE_tEXt_SUPPORTED
<span class="lineNum">     433 </span>            :             /* Write uncompressed chunk */
<span class="lineNum">     434 </span>            :             png_write_tEXt(png_ptr, info_ptr-&gt;text[i].key,
<span class="lineNum">     435 </span>            :                 info_ptr-&gt;text[i].text, 0);
<span class="lineNum">     436 </span>            :             /* Mark this chunk as written */
<span class="lineNum">     437 </span>            :             info_ptr-&gt;text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
<span class="lineNum">     438 </span>            : #else
<span class="lineNum">     439 </span>            :             png_warning(png_ptr, &quot;Unable to write uncompressed text&quot;);
<span class="lineNum">     440 </span>            : #endif
<span class="lineNum">     441 </span>            :          }
<span class="lineNum">     442 </span>            :       }
<span class="lineNum">     443 </span>            : #endif
<span class="lineNum">     444 </span>            : #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">     445 </span>            :       write_unknown_chunks(png_ptr, info_ptr, PNG_AFTER_IDAT);
<span class="lineNum">     446 </span>            : #endif
<span class="lineNum">     447 </span>            :    }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :    png_ptr-&gt;mode |= PNG_AFTER_IDAT;</span>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :    /* Write end of PNG file */
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :    png_write_IEND(png_ptr);</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :    /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
<span class="lineNum">     455 </span>            :     * and restored again in libpng-1.2.30, may cause some applications that
<span class="lineNum">     456 </span>            :     * do not set png_ptr-&gt;output_flush_fn to crash.  If your application
<span class="lineNum">     457 </span>            :     * experiences a problem, please try building libpng with
<span class="lineNum">     458 </span>            :     * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to
<span class="lineNum">     459 </span>            :     * png-mng-implement at lists.sf.net .
<span class="lineNum">     460 </span>            :     */
<span class="lineNum">     461 </span>            : #ifdef PNG_WRITE_FLUSH_SUPPORTED
<span class="lineNum">     462 </span>            : #  ifdef PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
<span class="lineNum">     463 </span>            :    png_flush(png_ptr);
<span class="lineNum">     464 </span>            : #  endif
<span class="lineNum">     465 </span>            : #endif
<span class="lineNum">     466 </span>            : }
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : #ifdef PNG_CONVERT_tIME_SUPPORTED
<span class="lineNum">     469 </span>            : void PNGAPI
<span class="lineNum">     470 </span>            : png_convert_from_struct_tm(png_timep ptime, PNG_CONST struct tm * ttime)
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :    png_debug(1, &quot;in png_convert_from_struct_tm&quot;);
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :    ptime-&gt;year = (png_uint_16)(1900 + ttime-&gt;tm_year);
<span class="lineNum">     475 </span>            :    ptime-&gt;month = (png_byte)(ttime-&gt;tm_mon + 1);
<span class="lineNum">     476 </span>            :    ptime-&gt;day = (png_byte)ttime-&gt;tm_mday;
<span class="lineNum">     477 </span>            :    ptime-&gt;hour = (png_byte)ttime-&gt;tm_hour;
<span class="lineNum">     478 </span>            :    ptime-&gt;minute = (png_byte)ttime-&gt;tm_min;
<span class="lineNum">     479 </span>            :    ptime-&gt;second = (png_byte)ttime-&gt;tm_sec;
<span class="lineNum">     480 </span>            : }
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : void PNGAPI
<span class="lineNum">     483 </span>            : png_convert_from_time_t(png_timep ptime, time_t ttime)
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span>            :    struct tm *tbuf;
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :    png_debug(1, &quot;in png_convert_from_time_t&quot;);
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :    tbuf = gmtime(&amp;ttime);
<span class="lineNum">     490 </span>            :    png_convert_from_struct_tm(ptime, tbuf);
<span class="lineNum">     491 </span>            : }
<span class="lineNum">     492 </span>            : #endif
<a name="493"><span class="lineNum">     493 </span>            : </a>
<span class="lineNum">     494 </span>            : /* Initialize png_ptr structure, and allocate any memory needed */
<span class="lineNum">     495 </span><span class="lineNoCov">          0 : PNG_FUNCTION(png_structp,PNGAPI</span>
<span class="lineNum">     496 </span>            : png_create_write_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
<span class="lineNum">     497 </span>            :     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
<span class="lineNum">     498 </span>            : {
<span class="lineNum">     499 </span>            : #ifndef PNG_USER_MEM_SUPPORTED
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :    png_structrp png_ptr = png_create_png_struct(user_png_ver, error_ptr,</span>
<span class="lineNum">     501 </span>            :        error_fn, warn_fn, NULL, NULL, NULL);
<span class="lineNum">     502 </span>            : #else
<span class="lineNum">     503 </span>            :    return png_create_write_struct_2(user_png_ver, error_ptr, error_fn,
<span class="lineNum">     504 </span>            :        warn_fn, NULL, NULL, NULL);
<span class="lineNum">     505 </span>            : }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : /* Alternate initialize png_ptr structure, and allocate any memory needed */
<span class="lineNum">     508 </span>            : PNG_FUNCTION(png_structp,PNGAPI
<span class="lineNum">     509 </span>            : png_create_write_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
<span class="lineNum">     510 </span>            :     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
<span class="lineNum">     511 </span>            :     png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)
<span class="lineNum">     512 </span>            : {
<span class="lineNum">     513 </span>            :    png_structrp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
<span class="lineNum">     514 </span>            :        error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
<span class="lineNum">     515 </span>            : #endif /* USER_MEM */
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :    if (png_ptr != NULL)</span>
<span class="lineNum">     517 </span>            :    {
<span class="lineNum">     518 </span>            :       /* Set the zlib control values to defaults; they can be overridden by the
<span class="lineNum">     519 </span>            :        * application after the struct has been created.
<span class="lineNum">     520 </span>            :        */
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zbuffer_size = PNG_ZBUF_SIZE;</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :       /* The 'zlib_strategy' setting is irrelevant because png_default_claim in
<span class="lineNum">     524 </span>            :        * pngwutil.c defaults it according to whether or not filters will be
<span class="lineNum">     525 </span>            :        * used, and ignores this setting.
<span class="lineNum">     526 </span>            :        */
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zlib_strategy = PNG_Z_DEFAULT_STRATEGY;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zlib_level = PNG_Z_DEFAULT_COMPRESSION;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zlib_mem_level = 8;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zlib_window_bits = 15;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       png_ptr-&gt;zlib_method = 8;</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : #ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
<span class="lineNum">     534 </span>            :       png_ptr-&gt;zlib_text_strategy = PNG_TEXT_Z_DEFAULT_STRATEGY;
<span class="lineNum">     535 </span>            :       png_ptr-&gt;zlib_text_level = PNG_TEXT_Z_DEFAULT_COMPRESSION;
<span class="lineNum">     536 </span>            :       png_ptr-&gt;zlib_text_mem_level = 8;
<span class="lineNum">     537 </span>            :       png_ptr-&gt;zlib_text_window_bits = 15;
<span class="lineNum">     538 </span>            :       png_ptr-&gt;zlib_text_method = 8;
<span class="lineNum">     539 </span>            : #endif /* WRITE_COMPRESSED_TEXT */
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :       /* This is a highly dubious configuration option; by default it is off,
<span class="lineNum">     542 </span>            :        * but it may be appropriate for private builds that are testing
<span class="lineNum">     543 </span>            :        * extensions not conformant to the current specification, or of
<span class="lineNum">     544 </span>            :        * applications that must not fail to write at all costs!
<span class="lineNum">     545 </span>            :        */
<span class="lineNum">     546 </span>            : #ifdef PNG_BENIGN_WRITE_ERRORS_SUPPORTED
<span class="lineNum">     547 </span>            :       /* In stable builds only warn if an application error can be completely
<span class="lineNum">     548 </span>            :        * handled.
<span class="lineNum">     549 </span>            :        */
<span class="lineNum">     550 </span>            :       png_ptr-&gt;flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
<span class="lineNum">     551 </span>            : #endif
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :       /* App warnings are warnings in release (or release candidate) builds but
<span class="lineNum">     554 </span>            :        * are errors during development.
<span class="lineNum">     555 </span>            :        */
<span class="lineNum">     556 </span>            : #if PNG_RELEASE_BUILD
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       png_ptr-&gt;flags |= PNG_FLAG_APP_WARNINGS_WARN;</span>
<span class="lineNum">     558 </span>            : #endif
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :       /* TODO: delay this, it can be done in png_init_io() (if the app doesn't
<span class="lineNum">     561 </span>            :        * do it itself) avoiding setting the default function if it is not
<span class="lineNum">     562 </span>            :        * required.
<span class="lineNum">     563 </span>            :        */
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :       png_set_write_fn(png_ptr, NULL, NULL, NULL);</span>
<span class="lineNum">     565 </span>            :    }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :    return png_ptr;</span>
<span class="lineNum">     568 </span>            : }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : /* Write a few rows of image data.  If the image is interlaced,
<span class="lineNum">     572 </span>            :  * either you will have to write the 7 sub images, or, if you
<span class="lineNum">     573 </span>            :  * have called png_set_interlace_handling(), you will have to
<span class="lineNum">     574 </span>            :  * &quot;write&quot; the image seven times.
<a name="575"><span class="lineNum">     575 </span>            :  */</a>
<span class="lineNum">     576 </span>            : void PNGAPI
<span class="lineNum">     577 </span><span class="lineNoCov">          0 : png_write_rows(png_structrp png_ptr, png_bytepp row,</span>
<span class="lineNum">     578 </span>            :     png_uint_32 num_rows)
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span>            :    png_uint_32 i; /* row counter */
<span class="lineNum">     581 </span>            :    png_bytepp rp; /* row pointer */
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :    png_debug(1, &quot;in png_write_rows&quot;);
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :    /* Loop through the rows */
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :    for (i = 0, rp = row; i &lt; num_rows; i++, rp++)</span>
<span class="lineNum">     590 </span>            :    {
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       png_write_row(png_ptr, *rp);</span>
<span class="lineNum">     592 </span>            :    }
<span class="lineNum">     593 </span>            : }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : /* Write the image.  You only need to call this function once, even
<span class="lineNum">     596 </span>            :  * if you are writing an interlaced image.
<a name="597"><span class="lineNum">     597 </span>            :  */</a>
<span class="lineNum">     598 </span>            : void PNGAPI
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : png_write_image(png_structrp png_ptr, png_bytepp image)</span>
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span>            :    png_uint_32 i; /* row index */
<span class="lineNum">     602 </span>            :    int pass, num_pass; /* pass variables */
<span class="lineNum">     603 </span>            :    png_bytepp rp; /* points to current row */
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :    png_debug(1, &quot;in png_write_image&quot;);
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            : #ifdef PNG_WRITE_INTERLACING_SUPPORTED
<span class="lineNum">     611 </span>            :    /* Initialize interlace handling.  If image is not interlaced,
<span class="lineNum">     612 </span>            :     * this will set pass to 1
<span class="lineNum">     613 </span>            :     */
<span class="lineNum">     614 </span>            :    num_pass = png_set_interlace_handling(png_ptr);
<span class="lineNum">     615 </span>            : #else
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :    num_pass = 1;</span>
<span class="lineNum">     617 </span>            : #endif
<span class="lineNum">     618 </span>            :    /* Loop through passes */
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :    for (pass = 0; pass &lt; num_pass; pass++)</span>
<span class="lineNum">     620 </span>            :    {
<span class="lineNum">     621 </span>            :       /* Loop through image */
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       for (i = 0, rp = image; i &lt; png_ptr-&gt;height; i++, rp++)</span>
<span class="lineNum">     623 </span>            :       {
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :          png_write_row(png_ptr, *rp);</span>
<span class="lineNum">     625 </span>            :       }
<span class="lineNum">     626 </span>            :    }
<span class="lineNum">     627 </span>            : }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            : #ifdef PNG_MNG_FEATURES_SUPPORTED
<span class="lineNum">     630 </span>            : /* Performs intrapixel differencing  */
<span class="lineNum">     631 </span>            : static void
<span class="lineNum">     632 </span>            : png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span>            :    png_debug(1, &quot;in png_do_write_intrapixel&quot;);
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :    if ((row_info-&gt;color_type &amp; PNG_COLOR_MASK_COLOR) != 0)
<span class="lineNum">     637 </span>            :    {
<span class="lineNum">     638 </span>            :       int bytes_per_pixel;
<span class="lineNum">     639 </span>            :       png_uint_32 row_width = row_info-&gt;width;
<span class="lineNum">     640 </span>            :       if (row_info-&gt;bit_depth == 8)
<span class="lineNum">     641 </span>            :       {
<span class="lineNum">     642 </span>            :          png_bytep rp;
<span class="lineNum">     643 </span>            :          png_uint_32 i;
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :          if (row_info-&gt;color_type == PNG_COLOR_TYPE_RGB)
<span class="lineNum">     646 </span>            :             bytes_per_pixel = 3;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :          else if (row_info-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA)
<span class="lineNum">     649 </span>            :             bytes_per_pixel = 4;
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :          else
<span class="lineNum">     652 </span>            :             return;
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :          for (i = 0, rp = row; i &lt; row_width; i++, rp += bytes_per_pixel)
<span class="lineNum">     655 </span>            :          {
<span class="lineNum">     656 </span>            :             *(rp)     = (png_byte)(*rp       - *(rp + 1));
<span class="lineNum">     657 </span>            :             *(rp + 2) = (png_byte)(*(rp + 2) - *(rp + 1));
<span class="lineNum">     658 </span>            :          }
<span class="lineNum">     659 </span>            :       }
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : #ifdef PNG_WRITE_16BIT_SUPPORTED
<span class="lineNum">     662 </span>            :       else if (row_info-&gt;bit_depth == 16)
<span class="lineNum">     663 </span>            :       {
<span class="lineNum">     664 </span>            :          png_bytep rp;
<span class="lineNum">     665 </span>            :          png_uint_32 i;
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :          if (row_info-&gt;color_type == PNG_COLOR_TYPE_RGB)
<span class="lineNum">     668 </span>            :             bytes_per_pixel = 6;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :          else if (row_info-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA)
<span class="lineNum">     671 </span>            :             bytes_per_pixel = 8;
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :          else
<span class="lineNum">     674 </span>            :             return;
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :          for (i = 0, rp = row; i &lt; row_width; i++, rp += bytes_per_pixel)
<span class="lineNum">     677 </span>            :          {
<span class="lineNum">     678 </span>            :             png_uint_32 s0   = (png_uint_32)(*(rp    ) &lt;&lt; 8) | *(rp + 1);
<span class="lineNum">     679 </span>            :             png_uint_32 s1   = (png_uint_32)(*(rp + 2) &lt;&lt; 8) | *(rp + 3);
<span class="lineNum">     680 </span>            :             png_uint_32 s2   = (png_uint_32)(*(rp + 4) &lt;&lt; 8) | *(rp + 5);
<span class="lineNum">     681 </span>            :             png_uint_32 red  = (png_uint_32)((s0 - s1) &amp; 0xffffL);
<span class="lineNum">     682 </span>            :             png_uint_32 blue = (png_uint_32)((s2 - s1) &amp; 0xffffL);
<span class="lineNum">     683 </span>            :             *(rp    ) = (png_byte)(red &gt;&gt; 8);
<span class="lineNum">     684 </span>            :             *(rp + 1) = (png_byte)red;
<span class="lineNum">     685 </span>            :             *(rp + 4) = (png_byte)(blue &gt;&gt; 8);
<span class="lineNum">     686 </span>            :             *(rp + 5) = (png_byte)blue;
<span class="lineNum">     687 </span>            :          }
<span class="lineNum">     688 </span>            :       }
<span class="lineNum">     689 </span>            : #endif /* WRITE_16BIT */
<span class="lineNum">     690 </span>            :    }
<span class="lineNum">     691 </span>            : }
<span class="lineNum">     692 </span>            : #endif /* MNG_FEATURES */
<span class="lineNum">     693 </span>            : 
<a name="694"><span class="lineNum">     694 </span>            : /* Called by user to write a row of image data */</a>
<span class="lineNum">     695 </span>            : void PNGAPI
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : png_write_row(png_structrp png_ptr, png_const_bytep row)</span>
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span>            :    /* 1.5.6: moved from png_struct to be a local structure: */
<span class="lineNum">     699 </span>            :    png_row_info row_info;
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :    png_debug2(1, &quot;in png_write_row (row %u, pass %d)&quot;,
<span class="lineNum">     705 </span>            :        png_ptr-&gt;row_number, png_ptr-&gt;pass);
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :    /* Initialize transformations and other stuff if first time */
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :    if (png_ptr-&gt;row_number == 0 &amp;&amp; png_ptr-&gt;pass == 0)</span>
<span class="lineNum">     709 </span>            :    {
<span class="lineNum">     710 </span>            :       /* Make sure we wrote the header info */
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       if ((png_ptr-&gt;mode &amp; PNG_WROTE_INFO_BEFORE_PLTE) == 0)</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :          png_error(png_ptr,</span>
<span class="lineNum">     713 </span>            :              &quot;png_write_info was never called before png_write_row&quot;);
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :       /* Check for transforms that have been set but were defined out */
<span class="lineNum">     716 </span>            : #if !defined(PNG_WRITE_INVERT_SUPPORTED) &amp;&amp; defined(PNG_READ_INVERT_SUPPORTED)
<span class="lineNum">     717 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_INVERT_MONO) != 0)
<span class="lineNum">     718 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_INVERT_SUPPORTED is not defined&quot;);
<span class="lineNum">     719 </span>            : #endif
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            : #if !defined(PNG_WRITE_FILLER_SUPPORTED) &amp;&amp; defined(PNG_READ_FILLER_SUPPORTED)
<span class="lineNum">     722 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_FILLER) != 0)
<span class="lineNum">     723 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_FILLER_SUPPORTED is not defined&quot;);
<span class="lineNum">     724 </span>            : #endif
<span class="lineNum">     725 </span>            : #if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) &amp;&amp; \
<span class="lineNum">     726 </span>            :     defined(PNG_READ_PACKSWAP_SUPPORTED)
<span class="lineNum">     727 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_PACKSWAP) != 0)
<span class="lineNum">     728 </span>            :          png_warning(png_ptr,
<span class="lineNum">     729 </span>            :              &quot;PNG_WRITE_PACKSWAP_SUPPORTED is not defined&quot;);
<span class="lineNum">     730 </span>            : #endif
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : #if !defined(PNG_WRITE_PACK_SUPPORTED) &amp;&amp; defined(PNG_READ_PACK_SUPPORTED)
<span class="lineNum">     733 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_PACK) != 0)
<span class="lineNum">     734 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_PACK_SUPPORTED is not defined&quot;);
<span class="lineNum">     735 </span>            : #endif
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : #if !defined(PNG_WRITE_SHIFT_SUPPORTED) &amp;&amp; defined(PNG_READ_SHIFT_SUPPORTED)
<span class="lineNum">     738 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_SHIFT) != 0)
<span class="lineNum">     739 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_SHIFT_SUPPORTED is not defined&quot;);
<span class="lineNum">     740 </span>            : #endif
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : #if !defined(PNG_WRITE_BGR_SUPPORTED) &amp;&amp; defined(PNG_READ_BGR_SUPPORTED)
<span class="lineNum">     743 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_BGR) != 0)
<span class="lineNum">     744 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_BGR_SUPPORTED is not defined&quot;);
<span class="lineNum">     745 </span>            : #endif
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : #if !defined(PNG_WRITE_SWAP_SUPPORTED) &amp;&amp; defined(PNG_READ_SWAP_SUPPORTED)
<span class="lineNum">     748 </span>            :       if ((png_ptr-&gt;transformations &amp; PNG_SWAP_BYTES) != 0)
<span class="lineNum">     749 </span>            :          png_warning(png_ptr, &quot;PNG_WRITE_SWAP_SUPPORTED is not defined&quot;);
<span class="lineNum">     750 </span>            : #endif
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       png_write_start_row(png_ptr);</span>
<span class="lineNum">     753 </span>            :    }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : #ifdef PNG_WRITE_INTERLACING_SUPPORTED
<span class="lineNum">     756 </span>            :    /* If interlaced and not interested in row, return */
<span class="lineNum">     757 </span>            :    if (png_ptr-&gt;interlaced != 0 &amp;&amp;
<span class="lineNum">     758 </span>            :        (png_ptr-&gt;transformations &amp; PNG_INTERLACE) != 0)
<span class="lineNum">     759 </span>            :    {
<span class="lineNum">     760 </span>            :       switch (png_ptr-&gt;pass)
<span class="lineNum">     761 </span>            :       {
<span class="lineNum">     762 </span>            :          case 0:
<span class="lineNum">     763 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x07) != 0)
<span class="lineNum">     764 </span>            :             {
<span class="lineNum">     765 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     766 </span>            :                return;
<span class="lineNum">     767 </span>            :             }
<span class="lineNum">     768 </span>            :             break;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :          case 1:
<span class="lineNum">     771 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x07) != 0 || png_ptr-&gt;width &lt; 5)
<span class="lineNum">     772 </span>            :             {
<span class="lineNum">     773 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     774 </span>            :                return;
<span class="lineNum">     775 </span>            :             }
<span class="lineNum">     776 </span>            :             break;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :          case 2:
<span class="lineNum">     779 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x07) != 4)
<span class="lineNum">     780 </span>            :             {
<span class="lineNum">     781 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     782 </span>            :                return;
<span class="lineNum">     783 </span>            :             }
<span class="lineNum">     784 </span>            :             break;
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :          case 3:
<span class="lineNum">     787 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x03) != 0 || png_ptr-&gt;width &lt; 3)
<span class="lineNum">     788 </span>            :             {
<span class="lineNum">     789 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     790 </span>            :                return;
<span class="lineNum">     791 </span>            :             }
<span class="lineNum">     792 </span>            :             break;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :          case 4:
<span class="lineNum">     795 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x03) != 2)
<span class="lineNum">     796 </span>            :             {
<span class="lineNum">     797 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     798 </span>            :                return;
<span class="lineNum">     799 </span>            :             }
<span class="lineNum">     800 </span>            :             break;
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :          case 5:
<span class="lineNum">     803 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x01) != 0 || png_ptr-&gt;width &lt; 2)
<span class="lineNum">     804 </span>            :             {
<span class="lineNum">     805 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     806 </span>            :                return;
<span class="lineNum">     807 </span>            :             }
<span class="lineNum">     808 </span>            :             break;
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :          case 6:
<span class="lineNum">     811 </span>            :             if ((png_ptr-&gt;row_number &amp; 0x01) == 0)
<span class="lineNum">     812 </span>            :             {
<span class="lineNum">     813 </span>            :                png_write_finish_row(png_ptr);
<span class="lineNum">     814 </span>            :                return;
<span class="lineNum">     815 </span>            :             }
<span class="lineNum">     816 </span>            :             break;
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :          default: /* error: ignore it */
<span class="lineNum">     819 </span>            :             break;
<span class="lineNum">     820 </span>            :       }
<span class="lineNum">     821 </span>            :    }
<span class="lineNum">     822 </span>            : #endif
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :    /* Set up row info for transformations */
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :    row_info.color_type = png_ptr-&gt;color_type;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :    row_info.width = png_ptr-&gt;usr_width;</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :    row_info.channels = png_ptr-&gt;usr_channels;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :    row_info.bit_depth = png_ptr-&gt;usr_bit_depth;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :    row_info.pixel_depth = (png_byte)(row_info.bit_depth * row_info.channels);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :    row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :    png_debug1(3, &quot;row_info-&gt;color_type = %d&quot;, row_info.color_type);
<span class="lineNum">     833 </span>            :    png_debug1(3, &quot;row_info-&gt;width = %u&quot;, row_info.width);
<span class="lineNum">     834 </span>            :    png_debug1(3, &quot;row_info-&gt;channels = %d&quot;, row_info.channels);
<span class="lineNum">     835 </span>            :    png_debug1(3, &quot;row_info-&gt;bit_depth = %d&quot;, row_info.bit_depth);
<span class="lineNum">     836 </span>            :    png_debug1(3, &quot;row_info-&gt;pixel_depth = %d&quot;, row_info.pixel_depth);
<span class="lineNum">     837 </span>            :    png_debug1(3, &quot;row_info-&gt;rowbytes = %lu&quot;, (unsigned long)row_info.rowbytes);
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :    /* Copy user's row into buffer, leaving room for filter byte. */
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :    memcpy(png_ptr-&gt;row_buf + 1, row, row_info.rowbytes);</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : #ifdef PNG_WRITE_INTERLACING_SUPPORTED
<span class="lineNum">     843 </span>            :    /* Handle interlacing */
<span class="lineNum">     844 </span>            :    if (png_ptr-&gt;interlaced &amp;&amp; png_ptr-&gt;pass &lt; 6 &amp;&amp;
<span class="lineNum">     845 </span>            :        (png_ptr-&gt;transformations &amp; PNG_INTERLACE) != 0)
<span class="lineNum">     846 </span>            :    {
<span class="lineNum">     847 </span>            :       png_do_write_interlace(&amp;row_info, png_ptr-&gt;row_buf + 1, png_ptr-&gt;pass);
<span class="lineNum">     848 </span>            :       /* This should always get caught above, but still ... */
<span class="lineNum">     849 </span>            :       if (row_info.width == 0)
<span class="lineNum">     850 </span>            :       {
<span class="lineNum">     851 </span>            :          png_write_finish_row(png_ptr);
<span class="lineNum">     852 </span>            :          return;
<span class="lineNum">     853 </span>            :       }
<span class="lineNum">     854 </span>            :    }
<span class="lineNum">     855 </span>            : #endif
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : #ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
<span class="lineNum">     858 </span>            :    /* Handle other transformations */
<span class="lineNum">     859 </span>            :    if (png_ptr-&gt;transformations != 0)
<span class="lineNum">     860 </span>            :       png_do_write_transformations(png_ptr, &amp;row_info);
<span class="lineNum">     861 </span>            : #endif
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :    /* At this point the row_info pixel depth must match the 'transformed' depth,
<span class="lineNum">     864 </span>            :     * which is also the output depth.
<span class="lineNum">     865 </span>            :     */
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :    if (row_info.pixel_depth != png_ptr-&gt;pixel_depth ||</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :        row_info.pixel_depth != png_ptr-&gt;transformed_pixel_depth)</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       png_error(png_ptr, &quot;internal write transform logic error&quot;);</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            : #ifdef PNG_MNG_FEATURES_SUPPORTED
<span class="lineNum">     871 </span>            :    /* Write filter_method 64 (intrapixel differencing) only if
<span class="lineNum">     872 </span>            :     * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
<span class="lineNum">     873 </span>            :     * 2. Libpng did not write a PNG signature (this filter_method is only
<span class="lineNum">     874 </span>            :     *    used in PNG datastreams that are embedded in MNG datastreams) and
<span class="lineNum">     875 </span>            :     * 3. The application called png_permit_mng_features with a mask that
<span class="lineNum">     876 </span>            :     *    included PNG_FLAG_MNG_FILTER_64 and
<span class="lineNum">     877 </span>            :     * 4. The filter_method is 64 and
<span class="lineNum">     878 </span>            :     * 5. The color_type is RGB or RGBA
<span class="lineNum">     879 </span>            :     */
<span class="lineNum">     880 </span>            :    if ((png_ptr-&gt;mng_features_permitted &amp; PNG_FLAG_MNG_FILTER_64) != 0 &amp;&amp;
<span class="lineNum">     881 </span>            :        (png_ptr-&gt;filter_type == PNG_INTRAPIXEL_DIFFERENCING))
<span class="lineNum">     882 </span>            :    {
<span class="lineNum">     883 </span>            :       /* Intrapixel differencing */
<span class="lineNum">     884 </span>            :       png_do_write_intrapixel(&amp;row_info, png_ptr-&gt;row_buf + 1);
<span class="lineNum">     885 </span>            :    }
<span class="lineNum">     886 </span>            : #endif
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : /* Added at libpng-1.5.10 */
<span class="lineNum">     889 </span>            : #ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
<span class="lineNum">     890 </span>            :    /* Check for out-of-range palette index */
<span class="lineNum">     891 </span>            :    if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &amp;&amp;
<span class="lineNum">     892 </span>            :        png_ptr-&gt;num_palette_max &gt;= 0)
<span class="lineNum">     893 </span>            :       png_do_check_palette_indexes(png_ptr, &amp;row_info);
<span class="lineNum">     894 </span>            : #endif
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :    /* Find a filter if necessary, filter the row and write it out. */
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :    png_write_find_filter(png_ptr, &amp;row_info);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :    if (png_ptr-&gt;write_row_fn != NULL)</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       (*(png_ptr-&gt;write_row_fn))(png_ptr, png_ptr-&gt;row_number, png_ptr-&gt;pass);</span>
<span class="lineNum">     901 </span>            : }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : #ifdef PNG_WRITE_FLUSH_SUPPORTED
<a name="904"><span class="lineNum">     904 </span>            : /* Set the automatic flush interval or 0 to turn flushing off */</a>
<span class="lineNum">     905 </span>            : void PNGAPI
<span class="lineNum">     906 </span><span class="lineNoCov">          0 : png_set_flush(png_structrp png_ptr, int nrows)</span>
<span class="lineNum">     907 </span>            : {
<span class="lineNum">     908 </span>            :    png_debug(1, &quot;in png_set_flush&quot;);
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :    png_ptr-&gt;flush_dist = (nrows &lt; 0 ? 0 : (png_uint_32)nrows);</span>
<span class="lineNum">     914 </span>            : }
<span class="lineNum">     915 </span>            : 
<a name="916"><span class="lineNum">     916 </span>            : /* Flush the current output buffers now */</a>
<span class="lineNum">     917 </span>            : void PNGAPI
<span class="lineNum">     918 </span><span class="lineNoCov">          0 : png_write_flush(png_structrp png_ptr)</span>
<span class="lineNum">     919 </span>            : {
<span class="lineNum">     920 </span>            :    png_debug(1, &quot;in png_write_flush&quot;);
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :    /* We have already written out all of the data */
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :    if (png_ptr-&gt;row_number &gt;= png_ptr-&gt;num_rows)</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :    png_compress_IDAT(png_ptr, NULL, 0, Z_SYNC_FLUSH);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :    png_ptr-&gt;flush_rows = 0;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :    png_flush(png_ptr);</span>
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : #endif /* WRITE_FLUSH */
<span class="lineNum">     934 </span>            : 
<a name="935"><span class="lineNum">     935 </span>            : /* Free any memory used in png_ptr struct without freeing the struct itself. */</a>
<span class="lineNum">     936 </span>            : static void
<span class="lineNum">     937 </span><span class="lineNoCov">          0 : png_write_destroy(png_structrp png_ptr)</span>
<span class="lineNum">     938 </span>            : {
<span class="lineNum">     939 </span>            :    png_debug(1, &quot;in png_write_destroy&quot;);
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :    /* Free any memory zlib uses */
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :    if ((png_ptr-&gt;flags &amp; PNG_FLAG_ZSTREAM_INITIALIZED) != 0)</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       deflateEnd(&amp;png_ptr-&gt;zstream);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :    /* Free our memory.  png_free checks NULL for us. */
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :    png_free_buffer_list(png_ptr, &amp;png_ptr-&gt;zbuffer_list);</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :    png_free(png_ptr, png_ptr-&gt;row_buf);</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :    png_ptr-&gt;row_buf = NULL;</span>
<span class="lineNum">     949 </span>            : #ifdef PNG_WRITE_FILTER_SUPPORTED
<span class="lineNum">     950 </span>            :    png_free(png_ptr, png_ptr-&gt;prev_row);
<span class="lineNum">     951 </span>            :    png_free(png_ptr, png_ptr-&gt;try_row);
<span class="lineNum">     952 </span>            :    png_free(png_ptr, png_ptr-&gt;tst_row);
<span class="lineNum">     953 </span>            :    png_ptr-&gt;prev_row = NULL;
<span class="lineNum">     954 </span>            :    png_ptr-&gt;try_row = NULL;
<span class="lineNum">     955 </span>            :    png_ptr-&gt;tst_row = NULL;
<span class="lineNum">     956 </span>            : #endif
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            : #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
<span class="lineNum">     959 </span>            :    png_free(png_ptr, png_ptr-&gt;chunk_list);
<span class="lineNum">     960 </span>            :    png_ptr-&gt;chunk_list = NULL;
<span class="lineNum">     961 </span>            : #endif
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :    /* The error handling and memory handling information is left intact at this
<span class="lineNum">     964 </span>            :     * point: the jmp_buf may still have to be freed.  See png_destroy_png_struct
<span class="lineNum">     965 </span>            :     * for how this happens.
<span class="lineNum">     966 </span>            :     */
<span class="lineNum">     967 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : /* Free all memory used by the write.
<span class="lineNum">     970 </span>            :  * In libpng 1.6.0 this API changed quietly to no longer accept a NULL value for
<span class="lineNum">     971 </span>            :  * *png_ptr_ptr.  Prior to 1.6.0 it would accept such a value and it would free
<span class="lineNum">     972 </span>            :  * the passed in info_structs but it would quietly fail to free any of the data
<span class="lineNum">     973 </span>            :  * inside them.  In 1.6.0 it quietly does nothing (it has to be quiet because it
<span class="lineNum">     974 </span>            :  * has no png_ptr.)
<a name="975"><span class="lineNum">     975 </span>            :  */</a>
<span class="lineNum">     976 </span>            : void PNGAPI
<span class="lineNum">     977 </span><span class="lineNoCov">          0 : png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)</span>
<span class="lineNum">     978 </span>            : {
<span class="lineNum">     979 </span>            :    png_debug(1, &quot;in png_destroy_write_struct&quot;);
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :    if (png_ptr_ptr != NULL)</span>
<span class="lineNum">     982 </span>            :    {
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :       png_structrp png_ptr = *png_ptr_ptr;</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       if (png_ptr != NULL) /* added in libpng 1.6.0 */</span>
<span class="lineNum">     986 </span>            :       {
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :          png_destroy_info_struct(png_ptr, info_ptr_ptr);</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :          *png_ptr_ptr = NULL;</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :          png_write_destroy(png_ptr);</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :          png_destroy_png_struct(png_ptr);</span>
<span class="lineNum">     992 </span>            :       }
<span class="lineNum">     993 </span>            :    }
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     995 </span>            : 
<a name="996"><span class="lineNum">     996 </span>            : /* Allow the application to select one or more row filters to use. */</a>
<span class="lineNum">     997 </span>            : void PNGAPI
<span class="lineNum">     998 </span><span class="lineNoCov">          0 : png_set_filter(png_structrp png_ptr, int method, int filters)</span>
<span class="lineNum">     999 </span>            : {
<span class="lineNum">    1000 </span>            :    png_debug(1, &quot;in png_set_filter&quot;);
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : #ifdef PNG_MNG_FEATURES_SUPPORTED
<span class="lineNum">    1006 </span>            :    if ((png_ptr-&gt;mng_features_permitted &amp; PNG_FLAG_MNG_FILTER_64) != 0 &amp;&amp;
<span class="lineNum">    1007 </span>            :        (method == PNG_INTRAPIXEL_DIFFERENCING))
<span class="lineNum">    1008 </span>            :       method = PNG_FILTER_TYPE_BASE;
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            : #endif
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :    if (method == PNG_FILTER_TYPE_BASE)</span>
<span class="lineNum">    1012 </span>            :    {
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       switch (filters &amp; (PNG_ALL_FILTERS | 0x07))</span>
<span class="lineNum">    1014 </span>            :       {
<span class="lineNum">    1015 </span>            : #ifdef PNG_WRITE_FILTER_SUPPORTED
<span class="lineNum">    1016 </span>            :          case 5:
<span class="lineNum">    1017 </span>            :          case 6:
<span class="lineNum">    1018 </span>            :          case 7: png_app_error(png_ptr, &quot;Unknown row filter for method 0&quot;);
<span class="lineNum">    1019 </span>            :             /* FALL THROUGH */
<span class="lineNum">    1020 </span>            : #endif /* WRITE_FILTER */
<span class="lineNum">    1021 </span>            :          case PNG_FILTER_VALUE_NONE:
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             png_ptr-&gt;do_filter = PNG_FILTER_NONE; break;</span>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            : #ifdef PNG_WRITE_FILTER_SUPPORTED
<span class="lineNum">    1025 </span>            :          case PNG_FILTER_VALUE_SUB:
<span class="lineNum">    1026 </span>            :             png_ptr-&gt;do_filter = PNG_FILTER_SUB; break;
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :          case PNG_FILTER_VALUE_UP:
<span class="lineNum">    1029 </span>            :             png_ptr-&gt;do_filter = PNG_FILTER_UP; break;
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :          case PNG_FILTER_VALUE_AVG:
<span class="lineNum">    1032 </span>            :             png_ptr-&gt;do_filter = PNG_FILTER_AVG; break;
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :          case PNG_FILTER_VALUE_PAETH:
<span class="lineNum">    1035 </span>            :             png_ptr-&gt;do_filter = PNG_FILTER_PAETH; break;
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            :          default:
<span class="lineNum">    1038 </span>            :             png_ptr-&gt;do_filter = (png_byte)filters; break;
<span class="lineNum">    1039 </span>            : #else
<span class="lineNum">    1040 </span>            :          default:
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :             png_app_error(png_ptr, &quot;Unknown row filter for method 0&quot;);</span>
<span class="lineNum">    1042 </span>            : #endif /* WRITE_FILTER */
<span class="lineNum">    1043 </span>            :       }
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            : #ifdef PNG_WRITE_FILTER_SUPPORTED
<span class="lineNum">    1046 </span>            :       /* If we have allocated the row_buf, this means we have already started
<span class="lineNum">    1047 </span>            :        * with the image and we should have allocated all of the filter buffers
<span class="lineNum">    1048 </span>            :        * that have been selected.  If prev_row isn't already allocated, then
<span class="lineNum">    1049 </span>            :        * it is too late to start using the filters that need it, since we
<span class="lineNum">    1050 </span>            :        * will be missing the data in the previous row.  If an application
<span class="lineNum">    1051 </span>            :        * wants to start and stop using particular filters during compression,
<span class="lineNum">    1052 </span>            :        * it should start out with all of the filters, and then remove them
<span class="lineNum">    1053 </span>            :        * or add them back after the start of compression.
<span class="lineNum">    1054 </span>            :        *
<span class="lineNum">    1055 </span>            :        * NOTE: this is a nasty constraint on the code, because it means that the
<span class="lineNum">    1056 </span>            :        * prev_row buffer must be maintained even if there are currently no
<span class="lineNum">    1057 </span>            :        * 'prev_row' requiring filters active.
<span class="lineNum">    1058 </span>            :        */
<span class="lineNum">    1059 </span>            :       if (png_ptr-&gt;row_buf != NULL)
<span class="lineNum">    1060 </span>            :       {
<span class="lineNum">    1061 </span>            :          int num_filters;
<span class="lineNum">    1062 </span>            :          png_alloc_size_t buf_size;
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :          /* Repeat the checks in png_write_start_row; 1 pixel high or wide
<span class="lineNum">    1065 </span>            :           * images cannot benefit from certain filters.  If this isn't done here
<span class="lineNum">    1066 </span>            :           * the check below will fire on 1 pixel high images.
<span class="lineNum">    1067 </span>            :           */
<span class="lineNum">    1068 </span>            :          if (png_ptr-&gt;height == 1)
<span class="lineNum">    1069 </span>            :             filters &amp;= ~(PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH);
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :          if (png_ptr-&gt;width == 1)
<span class="lineNum">    1072 </span>            :             filters &amp;= ~(PNG_FILTER_SUB|PNG_FILTER_AVG|PNG_FILTER_PAETH);
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :          if ((filters &amp; (PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH)) != 0
<span class="lineNum">    1075 </span>            :             &amp;&amp; png_ptr-&gt;prev_row == NULL)
<span class="lineNum">    1076 </span>            :          {
<span class="lineNum">    1077 </span>            :             /* This is the error case, however it is benign - the previous row
<span class="lineNum">    1078 </span>            :              * is not available so the filter can't be used.  Just warn here.
<span class="lineNum">    1079 </span>            :              */
<span class="lineNum">    1080 </span>            :             png_app_warning(png_ptr,
<span class="lineNum">    1081 </span>            :                 &quot;png_set_filter: UP/AVG/PAETH cannot be added after start&quot;);
<span class="lineNum">    1082 </span>            :             filters &amp;= ~(PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH);
<span class="lineNum">    1083 </span>            :          }
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :          num_filters = 0;
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :          if (filters &amp; PNG_FILTER_SUB)
<span class="lineNum">    1088 </span>            :             num_filters++;
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :          if (filters &amp; PNG_FILTER_UP)
<span class="lineNum">    1091 </span>            :             num_filters++;
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :          if (filters &amp; PNG_FILTER_AVG)
<span class="lineNum">    1094 </span>            :             num_filters++;
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :          if (filters &amp; PNG_FILTER_PAETH)
<span class="lineNum">    1097 </span>            :             num_filters++;
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :          /* Allocate needed row buffers if they have not already been
<span class="lineNum">    1100 </span>            :           * allocated.
<span class="lineNum">    1101 </span>            :           */
<span class="lineNum">    1102 </span>            :          buf_size = PNG_ROWBYTES(png_ptr-&gt;usr_channels * png_ptr-&gt;usr_bit_depth,
<span class="lineNum">    1103 </span>            :              png_ptr-&gt;width) + 1;
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span>            :          if (png_ptr-&gt;try_row == NULL)
<span class="lineNum">    1106 </span>            :             png_ptr-&gt;try_row = png_voidcast(png_bytep,
<span class="lineNum">    1107 </span>            :                 png_malloc(png_ptr, buf_size));
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :          if (num_filters &gt; 1)
<span class="lineNum">    1110 </span>            :          {
<span class="lineNum">    1111 </span>            :             if (png_ptr-&gt;tst_row == NULL)
<span class="lineNum">    1112 </span>            :                png_ptr-&gt;tst_row = png_voidcast(png_bytep,
<span class="lineNum">    1113 </span>            :                    png_malloc(png_ptr, buf_size));
<span class="lineNum">    1114 </span>            :          }
<span class="lineNum">    1115 </span>            :       }
<span class="lineNum">    1116 </span>            :       png_ptr-&gt;do_filter = (png_byte)filters;
<span class="lineNum">    1117 </span>            : #endif
<span class="lineNum">    1118 </span>            :    }
<span class="lineNum">    1119 </span>            :    else
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :       png_error(png_ptr, &quot;Unknown custom filter method&quot;);</span>
<span class="lineNum">    1121 </span>            : }
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            : #ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* DEPRECATED */
<span class="lineNum">    1124 </span>            : /* Provide floating and fixed point APIs */
<span class="lineNum">    1125 </span>            : #ifdef PNG_FLOATING_POINT_SUPPORTED
<span class="lineNum">    1126 </span>            : void PNGAPI
<span class="lineNum">    1127 </span>            : png_set_filter_heuristics(png_structrp png_ptr, int heuristic_method,
<span class="lineNum">    1128 </span>            :     int num_weights, png_const_doublep filter_weights,
<span class="lineNum">    1129 </span>            :     png_const_doublep filter_costs)
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span>            :    PNG_UNUSED(png_ptr)
<span class="lineNum">    1132 </span>            :    PNG_UNUSED(heuristic_method)
<span class="lineNum">    1133 </span>            :    PNG_UNUSED(num_weights)
<span class="lineNum">    1134 </span>            :    PNG_UNUSED(filter_weights)
<span class="lineNum">    1135 </span>            :    PNG_UNUSED(filter_costs)
<span class="lineNum">    1136 </span>            : }
<span class="lineNum">    1137 </span>            : #endif /* FLOATING_POINT */
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            : #ifdef PNG_FIXED_POINT_SUPPORTED
<span class="lineNum">    1140 </span>            : void PNGAPI
<span class="lineNum">    1141 </span>            : png_set_filter_heuristics_fixed(png_structrp png_ptr, int heuristic_method,
<span class="lineNum">    1142 </span>            :     int num_weights, png_const_fixed_point_p filter_weights,
<span class="lineNum">    1143 </span>            :     png_const_fixed_point_p filter_costs)
<span class="lineNum">    1144 </span>            : {
<span class="lineNum">    1145 </span>            :    PNG_UNUSED(png_ptr)
<span class="lineNum">    1146 </span>            :    PNG_UNUSED(heuristic_method)
<span class="lineNum">    1147 </span>            :    PNG_UNUSED(num_weights)
<span class="lineNum">    1148 </span>            :    PNG_UNUSED(filter_weights)
<span class="lineNum">    1149 </span>            :    PNG_UNUSED(filter_costs)
<span class="lineNum">    1150 </span>            : }
<span class="lineNum">    1151 </span>            : #endif /* FIXED_POINT */
<span class="lineNum">    1152 </span>            : #endif /* WRITE_WEIGHTED_FILTER */
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : #ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
<span class="lineNum">    1155 </span>            : void PNGAPI
<span class="lineNum">    1156 </span>            : png_set_compression_level(png_structrp png_ptr, int level)
<span class="lineNum">    1157 </span>            : {
<span class="lineNum">    1158 </span>            :    png_debug(1, &quot;in png_set_compression_level&quot;);
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1161 </span>            :       return;
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :    png_ptr-&gt;zlib_level = level;
<span class="lineNum">    1164 </span>            : }
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : void PNGAPI
<span class="lineNum">    1167 </span>            : png_set_compression_mem_level(png_structrp png_ptr, int mem_level)
<span class="lineNum">    1168 </span>            : {
<span class="lineNum">    1169 </span>            :    png_debug(1, &quot;in png_set_compression_mem_level&quot;);
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1172 </span>            :       return;
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :    png_ptr-&gt;zlib_mem_level = mem_level;
<span class="lineNum">    1175 </span>            : }
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            : void PNGAPI
<span class="lineNum">    1178 </span>            : png_set_compression_strategy(png_structrp png_ptr, int strategy)
<span class="lineNum">    1179 </span>            : {
<span class="lineNum">    1180 </span>            :    png_debug(1, &quot;in png_set_compression_strategy&quot;);
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1183 </span>            :       return;
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            :    /* The flag setting here prevents the libpng dynamic selection of strategy.
<span class="lineNum">    1186 </span>            :     */
<span class="lineNum">    1187 </span>            :    png_ptr-&gt;flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
<span class="lineNum">    1188 </span>            :    png_ptr-&gt;zlib_strategy = strategy;
<span class="lineNum">    1189 </span>            : }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : /* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
<span class="lineNum">    1192 </span>            :  * smaller value of window_bits if it can do so safely.
<span class="lineNum">    1193 </span>            :  */
<span class="lineNum">    1194 </span>            : void PNGAPI
<span class="lineNum">    1195 </span>            : png_set_compression_window_bits(png_structrp png_ptr, int window_bits)
<span class="lineNum">    1196 </span>            : {
<span class="lineNum">    1197 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1198 </span>            :       return;
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :    /* Prior to 1.6.0 this would warn but then set the window_bits value. This
<span class="lineNum">    1201 </span>            :     * meant that negative window bits values could be selected that would cause
<span class="lineNum">    1202 </span>            :     * libpng to write a non-standard PNG file with raw deflate or gzip
<span class="lineNum">    1203 </span>            :     * compressed IDAT or ancillary chunks.  Such files can be read and there is
<span class="lineNum">    1204 </span>            :     * no warning on read, so this seems like a very bad idea.
<span class="lineNum">    1205 </span>            :     */
<span class="lineNum">    1206 </span>            :    if (window_bits &gt; 15)
<span class="lineNum">    1207 </span>            :    {
<span class="lineNum">    1208 </span>            :       png_warning(png_ptr, &quot;Only compression windows &lt;= 32k supported by PNG&quot;);
<span class="lineNum">    1209 </span>            :       window_bits = 15;
<span class="lineNum">    1210 </span>            :    }
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :    else if (window_bits &lt; 8)
<span class="lineNum">    1213 </span>            :    {
<span class="lineNum">    1214 </span>            :       png_warning(png_ptr, &quot;Only compression windows &gt;= 256 supported by PNG&quot;);
<span class="lineNum">    1215 </span>            :       window_bits = 8;
<span class="lineNum">    1216 </span>            :    }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :    png_ptr-&gt;zlib_window_bits = window_bits;
<span class="lineNum">    1219 </span>            : }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : void PNGAPI
<span class="lineNum">    1222 </span>            : png_set_compression_method(png_structrp png_ptr, int method)
<span class="lineNum">    1223 </span>            : {
<span class="lineNum">    1224 </span>            :    png_debug(1, &quot;in png_set_compression_method&quot;);
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1227 </span>            :       return;
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :    /* This would produce an invalid PNG file if it worked, but it doesn't and
<span class="lineNum">    1230 </span>            :     * deflate will fault it, so it is harmless to just warn here.
<span class="lineNum">    1231 </span>            :     */
<span class="lineNum">    1232 </span>            :    if (method != 8)
<span class="lineNum">    1233 </span>            :       png_warning(png_ptr, &quot;Only compression method 8 is supported by PNG&quot;);
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :    png_ptr-&gt;zlib_method = method;
<span class="lineNum">    1236 </span>            : }
<span class="lineNum">    1237 </span>            : #endif /* WRITE_CUSTOMIZE_COMPRESSION */
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            : /* The following were added to libpng-1.5.4 */
<span class="lineNum">    1240 </span>            : #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
<span class="lineNum">    1241 </span>            : void PNGAPI
<span class="lineNum">    1242 </span>            : png_set_text_compression_level(png_structrp png_ptr, int level)
<span class="lineNum">    1243 </span>            : {
<span class="lineNum">    1244 </span>            :    png_debug(1, &quot;in png_set_text_compression_level&quot;);
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1247 </span>            :       return;
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :    png_ptr-&gt;zlib_text_level = level;
<span class="lineNum">    1250 </span>            : }
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            : void PNGAPI
<span class="lineNum">    1253 </span>            : png_set_text_compression_mem_level(png_structrp png_ptr, int mem_level)
<span class="lineNum">    1254 </span>            : {
<span class="lineNum">    1255 </span>            :    png_debug(1, &quot;in png_set_text_compression_mem_level&quot;);
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1258 </span>            :       return;
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :    png_ptr-&gt;zlib_text_mem_level = mem_level;
<span class="lineNum">    1261 </span>            : }
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            : void PNGAPI
<span class="lineNum">    1264 </span>            : png_set_text_compression_strategy(png_structrp png_ptr, int strategy)
<span class="lineNum">    1265 </span>            : {
<span class="lineNum">    1266 </span>            :    png_debug(1, &quot;in png_set_text_compression_strategy&quot;);
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1269 </span>            :       return;
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            :    png_ptr-&gt;zlib_text_strategy = strategy;
<span class="lineNum">    1272 </span>            : }
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            : /* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
<span class="lineNum">    1275 </span>            :  * smaller value of window_bits if it can do so safely.
<span class="lineNum">    1276 </span>            :  */
<span class="lineNum">    1277 </span>            : void PNGAPI
<span class="lineNum">    1278 </span>            : png_set_text_compression_window_bits(png_structrp png_ptr, int window_bits)
<span class="lineNum">    1279 </span>            : {
<span class="lineNum">    1280 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1281 </span>            :       return;
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :    if (window_bits &gt; 15)
<span class="lineNum">    1284 </span>            :    {
<span class="lineNum">    1285 </span>            :       png_warning(png_ptr, &quot;Only compression windows &lt;= 32k supported by PNG&quot;);
<span class="lineNum">    1286 </span>            :       window_bits = 15;
<span class="lineNum">    1287 </span>            :    }
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span>            :    else if (window_bits &lt; 8)
<span class="lineNum">    1290 </span>            :    {
<span class="lineNum">    1291 </span>            :       png_warning(png_ptr, &quot;Only compression windows &gt;= 256 supported by PNG&quot;);
<span class="lineNum">    1292 </span>            :       window_bits = 8;
<span class="lineNum">    1293 </span>            :    }
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :    png_ptr-&gt;zlib_text_window_bits = window_bits;
<span class="lineNum">    1296 </span>            : }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : void PNGAPI
<span class="lineNum">    1299 </span>            : png_set_text_compression_method(png_structrp png_ptr, int method)
<span class="lineNum">    1300 </span>            : {
<span class="lineNum">    1301 </span>            :    png_debug(1, &quot;in png_set_text_compression_method&quot;);
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1304 </span>            :       return;
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :    if (method != 8)
<span class="lineNum">    1307 </span>            :       png_warning(png_ptr, &quot;Only compression method 8 is supported by PNG&quot;);
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :    png_ptr-&gt;zlib_text_method = method;
<span class="lineNum">    1310 </span>            : }
<span class="lineNum">    1311 </span>            : #endif /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
<span class="lineNum">    1312 </span>            : /* end of API added to libpng-1.5.4 */
<a name="1313"><span class="lineNum">    1313 </span>            : </a>
<span class="lineNum">    1314 </span>            : void PNGAPI
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 : png_set_write_status_fn(png_structrp png_ptr, png_write_status_ptr write_row_fn)</span>
<span class="lineNum">    1316 </span>            : {
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :    if (png_ptr == NULL)</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :    png_ptr-&gt;write_row_fn = write_row_fn;</span>
<span class="lineNum">    1321 </span>            : }
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            : #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
<span class="lineNum">    1324 </span>            : void PNGAPI
<span class="lineNum">    1325 </span>            : png_set_write_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr
<span class="lineNum">    1326 </span>            :     write_user_transform_fn)
<span class="lineNum">    1327 </span>            : {
<span class="lineNum">    1328 </span>            :    png_debug(1, &quot;in png_set_write_user_transform_fn&quot;);
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            :    if (png_ptr == NULL)
<span class="lineNum">    1331 </span>            :       return;
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :    png_ptr-&gt;transformations |= PNG_USER_TRANSFORM;
<span class="lineNum">    1334 </span>            :    png_ptr-&gt;write_user_transform_fn = write_user_transform_fn;
<span class="lineNum">    1335 </span>            : }
<span class="lineNum">    1336 </span>            : #endif
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : #ifdef PNG_INFO_IMAGE_SUPPORTED
<span class="lineNum">    1340 </span>            : void PNGAPI
<span class="lineNum">    1341 </span>            : png_write_png(png_structrp png_ptr, png_inforp info_ptr,
<span class="lineNum">    1342 </span>            :     int transforms, voidp params)
<span class="lineNum">    1343 </span>            : {
<span class="lineNum">    1344 </span>            :    if (png_ptr == NULL || info_ptr == NULL)
<span class="lineNum">    1345 </span>            :       return;
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            :    if ((info_ptr-&gt;valid &amp; PNG_INFO_IDAT) == 0)
<span class="lineNum">    1348 </span>            :    {
<span class="lineNum">    1349 </span>            :       png_app_error(png_ptr, &quot;no rows for png_write_image to write&quot;);
<span class="lineNum">    1350 </span>            :       return;
<span class="lineNum">    1351 </span>            :    }
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :    /* Write the file header information. */
<span class="lineNum">    1354 </span>            :    png_write_info(png_ptr, info_ptr);
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            :    /* ------ these transformations don't touch the info structure ------- */
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :    /* Invert monochrome pixels */
<span class="lineNum">    1359 </span>            :    if ((transforms &amp; PNG_TRANSFORM_INVERT_MONO) != 0)
<span class="lineNum">    1360 </span>            : #ifdef PNG_WRITE_INVERT_SUPPORTED
<span class="lineNum">    1361 </span>            :       png_set_invert_mono(png_ptr);
<span class="lineNum">    1362 </span>            : #else
<span class="lineNum">    1363 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_INVERT_MONO not supported&quot;);
<span class="lineNum">    1364 </span>            : #endif
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :    /* Shift the pixels up to a legal bit depth and fill in
<span class="lineNum">    1367 </span>            :     * as appropriate to correctly scale the image.
<span class="lineNum">    1368 </span>            :     */
<span class="lineNum">    1369 </span>            :    if ((transforms &amp; PNG_TRANSFORM_SHIFT) != 0)
<span class="lineNum">    1370 </span>            : #ifdef PNG_WRITE_SHIFT_SUPPORTED
<span class="lineNum">    1371 </span>            :       if ((info_ptr-&gt;valid &amp; PNG_INFO_sBIT) != 0)
<span class="lineNum">    1372 </span>            :          png_set_shift(png_ptr, &amp;info_ptr-&gt;sig_bit);
<span class="lineNum">    1373 </span>            : #else
<span class="lineNum">    1374 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_SHIFT not supported&quot;);
<span class="lineNum">    1375 </span>            : #endif
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            :    /* Pack pixels into bytes */
<span class="lineNum">    1378 </span>            :    if ((transforms &amp; PNG_TRANSFORM_PACKING) != 0)
<span class="lineNum">    1379 </span>            : #ifdef PNG_WRITE_PACK_SUPPORTED
<span class="lineNum">    1380 </span>            :       png_set_packing(png_ptr);
<span class="lineNum">    1381 </span>            : #else
<span class="lineNum">    1382 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_PACKING not supported&quot;);
<span class="lineNum">    1383 </span>            : #endif
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :    /* Swap location of alpha bytes from ARGB to RGBA */
<span class="lineNum">    1386 </span>            :    if ((transforms &amp; PNG_TRANSFORM_SWAP_ALPHA) != 0)
<span class="lineNum">    1387 </span>            : #ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
<span class="lineNum">    1388 </span>            :       png_set_swap_alpha(png_ptr);
<span class="lineNum">    1389 </span>            : #else
<span class="lineNum">    1390 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_SWAP_ALPHA not supported&quot;);
<span class="lineNum">    1391 </span>            : #endif
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            :    /* Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into
<span class="lineNum">    1394 </span>            :     * RGB, note that the code expects the input color type to be G or RGB; no
<span class="lineNum">    1395 </span>            :     * alpha channel.
<span class="lineNum">    1396 </span>            :     */
<span class="lineNum">    1397 </span>            :    if ((transforms &amp; (PNG_TRANSFORM_STRIP_FILLER_AFTER|
<span class="lineNum">    1398 </span>            :        PNG_TRANSFORM_STRIP_FILLER_BEFORE)) != 0)
<span class="lineNum">    1399 </span>            :    {
<span class="lineNum">    1400 </span>            : #ifdef PNG_WRITE_FILLER_SUPPORTED
<span class="lineNum">    1401 </span>            :       if ((transforms &amp; PNG_TRANSFORM_STRIP_FILLER_AFTER) != 0)
<span class="lineNum">    1402 </span>            :       {
<span class="lineNum">    1403 </span>            :          if ((transforms &amp; PNG_TRANSFORM_STRIP_FILLER_BEFORE) != 0)
<span class="lineNum">    1404 </span>            :             png_app_error(png_ptr,
<span class="lineNum">    1405 </span>            :                 &quot;PNG_TRANSFORM_STRIP_FILLER: BEFORE+AFTER not supported&quot;);
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :          /* Continue if ignored - this is the pre-1.6.10 behavior */
<span class="lineNum">    1408 </span>            :          png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
<span class="lineNum">    1409 </span>            :       }
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :       else if ((transforms &amp; PNG_TRANSFORM_STRIP_FILLER_BEFORE) != 0)
<span class="lineNum">    1412 </span>            :          png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
<span class="lineNum">    1413 </span>            : #else
<span class="lineNum">    1414 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_STRIP_FILLER not supported&quot;);
<span class="lineNum">    1415 </span>            : #endif
<span class="lineNum">    1416 </span>            :    }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            :    /* Flip BGR pixels to RGB */
<span class="lineNum">    1419 </span>            :    if ((transforms &amp; PNG_TRANSFORM_BGR) != 0)
<span class="lineNum">    1420 </span>            : #ifdef PNG_WRITE_BGR_SUPPORTED
<span class="lineNum">    1421 </span>            :       png_set_bgr(png_ptr);
<span class="lineNum">    1422 </span>            : #else
<span class="lineNum">    1423 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_BGR not supported&quot;);
<span class="lineNum">    1424 </span>            : #endif
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :    /* Swap bytes of 16-bit files to most significant byte first */
<span class="lineNum">    1427 </span>            :    if ((transforms &amp; PNG_TRANSFORM_SWAP_ENDIAN) != 0)
<span class="lineNum">    1428 </span>            : #ifdef PNG_WRITE_SWAP_SUPPORTED
<span class="lineNum">    1429 </span>            :       png_set_swap(png_ptr);
<span class="lineNum">    1430 </span>            : #else
<span class="lineNum">    1431 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_SWAP_ENDIAN not supported&quot;);
<span class="lineNum">    1432 </span>            : #endif
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :    /* Swap bits of 1-bit, 2-bit, 4-bit packed pixel formats */
<span class="lineNum">    1435 </span>            :    if ((transforms &amp; PNG_TRANSFORM_PACKSWAP) != 0)
<span class="lineNum">    1436 </span>            : #ifdef PNG_WRITE_PACKSWAP_SUPPORTED
<span class="lineNum">    1437 </span>            :       png_set_packswap(png_ptr);
<span class="lineNum">    1438 </span>            : #else
<span class="lineNum">    1439 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_PACKSWAP not supported&quot;);
<span class="lineNum">    1440 </span>            : #endif
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :    /* Invert the alpha channel from opacity to transparency */
<span class="lineNum">    1443 </span>            :    if ((transforms &amp; PNG_TRANSFORM_INVERT_ALPHA) != 0)
<span class="lineNum">    1444 </span>            : #ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
<span class="lineNum">    1445 </span>            :       png_set_invert_alpha(png_ptr);
<span class="lineNum">    1446 </span>            : #else
<span class="lineNum">    1447 </span>            :       png_app_error(png_ptr, &quot;PNG_TRANSFORM_INVERT_ALPHA not supported&quot;);
<span class="lineNum">    1448 </span>            : #endif
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            :    /* ----------------------- end of transformations ------------------- */
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :    /* Write the bits */
<span class="lineNum">    1453 </span>            :    png_write_image(png_ptr, info_ptr-&gt;row_pointers);
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            :    /* It is REQUIRED to call this to finish writing the rest of the file */
<span class="lineNum">    1456 </span>            :    png_write_end(png_ptr, info_ptr);
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :    PNG_UNUSED(params)
<span class="lineNum">    1459 </span>            : }
<span class="lineNum">    1460 </span>            : #endif
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            : #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
<span class="lineNum">    1464 </span>            : /* Initialize the write structure - general purpose utility. */
<span class="lineNum">    1465 </span>            : static int
<span class="lineNum">    1466 </span>            : png_image_write_init(png_imagep image)
<span class="lineNum">    1467 </span>            : {
<span class="lineNum">    1468 </span>            :    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, image,
<span class="lineNum">    1469 </span>            :        png_safe_error, png_safe_warning);
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :    if (png_ptr != NULL)
<span class="lineNum">    1472 </span>            :    {
<span class="lineNum">    1473 </span>            :       png_infop info_ptr = png_create_info_struct(png_ptr);
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :       if (info_ptr != NULL)
<span class="lineNum">    1476 </span>            :       {
<span class="lineNum">    1477 </span>            :          png_controlp control = png_voidcast(png_controlp,
<span class="lineNum">    1478 </span>            :              png_malloc_warn(png_ptr, (sizeof *control)));
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span>            :          if (control != NULL)
<span class="lineNum">    1481 </span>            :          {
<span class="lineNum">    1482 </span>            :             memset(control, 0, (sizeof *control));
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span>            :             control-&gt;png_ptr = png_ptr;
<span class="lineNum">    1485 </span>            :             control-&gt;info_ptr = info_ptr;
<span class="lineNum">    1486 </span>            :             control-&gt;for_write = 1;
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            :             image-&gt;opaque = control;
<span class="lineNum">    1489 </span>            :             return 1;
<span class="lineNum">    1490 </span>            :          }
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            :          /* Error clean up */
<span class="lineNum">    1493 </span>            :          png_destroy_info_struct(png_ptr, &amp;info_ptr);
<span class="lineNum">    1494 </span>            :       }
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :       png_destroy_write_struct(&amp;png_ptr, NULL);
<span class="lineNum">    1497 </span>            :    }
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            :    return png_image_error(image, &quot;png_image_write_: out of memory&quot;);
<span class="lineNum">    1500 </span>            : }
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            : /* Arguments to png_image_write_main: */
<span class="lineNum">    1503 </span>            : typedef struct
<span class="lineNum">    1504 </span>            : {
<span class="lineNum">    1505 </span>            :    /* Arguments: */
<span class="lineNum">    1506 </span>            :    png_imagep      image;
<span class="lineNum">    1507 </span>            :    png_const_voidp buffer;
<span class="lineNum">    1508 </span>            :    png_int_32      row_stride;
<span class="lineNum">    1509 </span>            :    png_const_voidp colormap;
<span class="lineNum">    1510 </span>            :    int             convert_to_8bit;
<span class="lineNum">    1511 </span>            :    /* Local variables: */
<span class="lineNum">    1512 </span>            :    png_const_voidp first_row;
<span class="lineNum">    1513 </span>            :    ptrdiff_t       row_bytes;
<span class="lineNum">    1514 </span>            :    png_voidp       local_row;
<span class="lineNum">    1515 </span>            :    /* Byte count for memory writing */
<span class="lineNum">    1516 </span>            :    png_bytep        memory;
<span class="lineNum">    1517 </span>            :    png_alloc_size_t memory_bytes; /* not used for STDIO */
<span class="lineNum">    1518 </span>            :    png_alloc_size_t output_bytes; /* running total */
<span class="lineNum">    1519 </span>            : } png_image_write_control;
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            : /* Write png_uint_16 input to a 16-bit PNG; the png_ptr has already been set to
<span class="lineNum">    1522 </span>            :  * do any necessary byte swapping.  The component order is defined by the
<span class="lineNum">    1523 </span>            :  * png_image format value.
<span class="lineNum">    1524 </span>            :  */
<span class="lineNum">    1525 </span>            : static int
<span class="lineNum">    1526 </span>            : png_write_image_16bit(png_voidp argument)
<span class="lineNum">    1527 </span>            : {
<span class="lineNum">    1528 </span>            :    png_image_write_control *display = png_voidcast(png_image_write_control*,
<span class="lineNum">    1529 </span>            :        argument);
<span class="lineNum">    1530 </span>            :    png_imagep image = display-&gt;image;
<span class="lineNum">    1531 </span>            :    png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            :    png_const_uint_16p input_row = png_voidcast(png_const_uint_16p,
<span class="lineNum">    1534 </span>            :        display-&gt;first_row);
<span class="lineNum">    1535 </span>            :    png_uint_16p output_row = png_voidcast(png_uint_16p, display-&gt;local_row);
<span class="lineNum">    1536 </span>            :    png_uint_16p row_end;
<span class="lineNum">    1537 </span>            :    const unsigned int channels = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) != 0 ?
<span class="lineNum">    1538 </span>            :        3 : 1;
<span class="lineNum">    1539 </span>            :    int aindex = 0;
<span class="lineNum">    1540 </span>            :    png_uint_32 y = image-&gt;height;
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            :    if ((image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0)
<span class="lineNum">    1543 </span>            :    {
<span class="lineNum">    1544 </span>            : #   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
<span class="lineNum">    1545 </span>            :       if ((image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0)
<span class="lineNum">    1546 </span>            :       {
<span class="lineNum">    1547 </span>            :          aindex = -1;
<span class="lineNum">    1548 </span>            :          ++input_row; /* To point to the first component */
<span class="lineNum">    1549 </span>            :          ++output_row;
<span class="lineNum">    1550 </span>            :       }
<span class="lineNum">    1551 </span>            :          else
<span class="lineNum">    1552 </span>            :             aindex = (int)channels;
<span class="lineNum">    1553 </span>            : #     else
<span class="lineNum">    1554 </span>            :          aindex = (int)channels;
<span class="lineNum">    1555 </span>            : #     endif
<span class="lineNum">    1556 </span>            :    }
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :    else
<span class="lineNum">    1559 </span>            :       png_error(png_ptr, &quot;png_write_image: internal call error&quot;);
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            :    /* Work out the output row end and count over this, note that the increment
<span class="lineNum">    1562 </span>            :     * above to 'row' means that row_end can actually be beyond the end of the
<span class="lineNum">    1563 </span>            :     * row; this is correct.
<span class="lineNum">    1564 </span>            :     */
<span class="lineNum">    1565 </span>            :    row_end = output_row + image-&gt;width * (channels+1);
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span>            :    for (; y &gt; 0; --y)
<span class="lineNum">    1568 </span>            :    {
<span class="lineNum">    1569 </span>            :       png_const_uint_16p in_ptr = input_row;
<span class="lineNum">    1570 </span>            :       png_uint_16p out_ptr = output_row;
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            :       while (out_ptr &lt; row_end)
<span class="lineNum">    1573 </span>            :       {
<span class="lineNum">    1574 </span>            :          const png_uint_16 alpha = in_ptr[aindex];
<span class="lineNum">    1575 </span>            :          png_uint_32 reciprocal = 0;
<span class="lineNum">    1576 </span>            :          int c;
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            :          out_ptr[aindex] = alpha;
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :          /* Calculate a reciprocal.  The correct calculation is simply
<span class="lineNum">    1581 </span>            :           * component/alpha*65535 &lt;&lt; 15. (I.e. 15 bits of precision); this
<span class="lineNum">    1582 </span>            :           * allows correct rounding by adding .5 before the shift.  'reciprocal'
<span class="lineNum">    1583 </span>            :           * is only initialized when required.
<span class="lineNum">    1584 </span>            :           */
<span class="lineNum">    1585 </span>            :          if (alpha &gt; 0 &amp;&amp; alpha &lt; 65535)
<span class="lineNum">    1586 </span>            :             reciprocal = ((0xffff&lt;&lt;15)+(alpha&gt;&gt;1))/alpha;
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span>            :          c = (int)channels;
<span class="lineNum">    1589 </span>            :          do /* always at least one channel */
<span class="lineNum">    1590 </span>            :          {
<span class="lineNum">    1591 </span>            :             png_uint_16 component = *in_ptr++;
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :             /* The following gives 65535 for an alpha of 0, which is fine,
<span class="lineNum">    1594 </span>            :              * otherwise if 0/0 is represented as some other value there is more
<span class="lineNum">    1595 </span>            :              * likely to be a discontinuity which will probably damage
<span class="lineNum">    1596 </span>            :              * compression when moving from a fully transparent area to a
<span class="lineNum">    1597 </span>            :              * nearly transparent one.  (The assumption here is that opaque
<span class="lineNum">    1598 </span>            :              * areas tend not to be 0 intensity.)
<span class="lineNum">    1599 </span>            :              */
<span class="lineNum">    1600 </span>            :             if (component &gt;= alpha)
<span class="lineNum">    1601 </span>            :                component = 65535;
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :             /* component&lt;alpha, so component/alpha is less than one and
<span class="lineNum">    1604 </span>            :              * component*reciprocal is less than 2^31.
<span class="lineNum">    1605 </span>            :              */
<span class="lineNum">    1606 </span>            :             else if (component &gt; 0 &amp;&amp; alpha &lt; 65535)
<span class="lineNum">    1607 </span>            :             {
<span class="lineNum">    1608 </span>            :                png_uint_32 calc = component * reciprocal;
<span class="lineNum">    1609 </span>            :                calc += 16384; /* round to nearest */
<span class="lineNum">    1610 </span>            :                component = (png_uint_16)(calc &gt;&gt; 15);
<span class="lineNum">    1611 </span>            :             }
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :             *out_ptr++ = component;
<span class="lineNum">    1614 </span>            :          }
<span class="lineNum">    1615 </span>            :          while (--c &gt; 0);
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            :          /* Skip to next component (skip the intervening alpha channel) */
<span class="lineNum">    1618 </span>            :          ++in_ptr;
<span class="lineNum">    1619 </span>            :          ++out_ptr;
<span class="lineNum">    1620 </span>            :       }
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :       png_write_row(png_ptr, png_voidcast(png_const_bytep, display-&gt;local_row));
<span class="lineNum">    1623 </span>            :       input_row += (png_uint_16)display-&gt;row_bytes/(sizeof (png_uint_16));
<span class="lineNum">    1624 </span>            :    }
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :    return 1;
<span class="lineNum">    1627 </span>            : }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            : /* Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel
<span class="lineNum">    1630 </span>            :  * is present it must be removed from the components, the components are then
<span class="lineNum">    1631 </span>            :  * written in sRGB encoding.  No components are added or removed.
<span class="lineNum">    1632 </span>            :  *
<span class="lineNum">    1633 </span>            :  * Calculate an alpha reciprocal to reverse pre-multiplication.  As above the
<span class="lineNum">    1634 </span>            :  * calculation can be done to 15 bits of accuracy; however, the output needs to
<span class="lineNum">    1635 </span>            :  * be scaled in the range 0..255*65535, so include that scaling here.
<span class="lineNum">    1636 </span>            :  */
<span class="lineNum">    1637 </span>            : #   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)&lt;&lt;7)+(alpha&gt;&gt;1))/alpha)
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span>            : static png_byte
<span class="lineNum">    1640 </span>            : png_unpremultiply(png_uint_32 component, png_uint_32 alpha,
<span class="lineNum">    1641 </span>            :     png_uint_32 reciprocal/*from the above macro*/)
<span class="lineNum">    1642 </span>            : {
<span class="lineNum">    1643 </span>            :    /* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
<span class="lineNum">    1644 </span>            :     * is represented as some other value there is more likely to be a
<span class="lineNum">    1645 </span>            :     * discontinuity which will probably damage compression when moving from a
<span class="lineNum">    1646 </span>            :     * fully transparent area to a nearly transparent one.  (The assumption here
<span class="lineNum">    1647 </span>            :     * is that opaque areas tend not to be 0 intensity.)
<span class="lineNum">    1648 </span>            :     *
<span class="lineNum">    1649 </span>            :     * There is a rounding problem here; if alpha is less than 128 it will end up
<span class="lineNum">    1650 </span>            :     * as 0 when scaled to 8 bits.  To avoid introducing spurious colors into the
<span class="lineNum">    1651 </span>            :     * output change for this too.
<span class="lineNum">    1652 </span>            :     */
<span class="lineNum">    1653 </span>            :    if (component &gt;= alpha || alpha &lt; 128)
<span class="lineNum">    1654 </span>            :       return 255;
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span>            :    /* component&lt;alpha, so component/alpha is less than one and
<span class="lineNum">    1657 </span>            :     * component*reciprocal is less than 2^31.
<span class="lineNum">    1658 </span>            :     */
<span class="lineNum">    1659 </span>            :    else if (component &gt; 0)
<span class="lineNum">    1660 </span>            :    {
<span class="lineNum">    1661 </span>            :       /* The test is that alpha/257 (rounded) is less than 255, the first value
<span class="lineNum">    1662 </span>            :        * that becomes 255 is 65407.
<span class="lineNum">    1663 </span>            :        * NOTE: this must agree with the PNG_DIV257 macro (which must, therefore,
<span class="lineNum">    1664 </span>            :        * be exact!)  [Could also test reciprocal != 0]
<span class="lineNum">    1665 </span>            :        */
<span class="lineNum">    1666 </span>            :       if (alpha &lt; 65407)
<span class="lineNum">    1667 </span>            :       {
<span class="lineNum">    1668 </span>            :          component *= reciprocal;
<span class="lineNum">    1669 </span>            :          component += 64; /* round to nearest */
<span class="lineNum">    1670 </span>            :          component &gt;&gt;= 7;
<span class="lineNum">    1671 </span>            :       }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :       else
<span class="lineNum">    1674 </span>            :          component *= 255;
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            :       /* Convert the component to sRGB. */
<span class="lineNum">    1677 </span>            :       return (png_byte)PNG_sRGB_FROM_LINEAR(component);
<span class="lineNum">    1678 </span>            :    }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :    else
<span class="lineNum">    1681 </span>            :       return 0;
<span class="lineNum">    1682 </span>            : }
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            : static int
<span class="lineNum">    1685 </span>            : png_write_image_8bit(png_voidp argument)
<span class="lineNum">    1686 </span>            : {
<span class="lineNum">    1687 </span>            :    png_image_write_control *display = png_voidcast(png_image_write_control*,
<span class="lineNum">    1688 </span>            :        argument);
<span class="lineNum">    1689 </span>            :    png_imagep image = display-&gt;image;
<span class="lineNum">    1690 </span>            :    png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span>            :    png_const_uint_16p input_row = png_voidcast(png_const_uint_16p,
<span class="lineNum">    1693 </span>            :        display-&gt;first_row);
<span class="lineNum">    1694 </span>            :    png_bytep output_row = png_voidcast(png_bytep, display-&gt;local_row);
<span class="lineNum">    1695 </span>            :    png_uint_32 y = image-&gt;height;
<span class="lineNum">    1696 </span>            :    const unsigned int channels = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) != 0 ?
<span class="lineNum">    1697 </span>            :        3 : 1;
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            :    if ((image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0)
<span class="lineNum">    1700 </span>            :    {
<span class="lineNum">    1701 </span>            :       png_bytep row_end;
<span class="lineNum">    1702 </span>            :       int aindex;
<span class="lineNum">    1703 </span>            : 
<span class="lineNum">    1704 </span>            : #   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
<span class="lineNum">    1705 </span>            :       if ((image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0)
<span class="lineNum">    1706 </span>            :       {
<span class="lineNum">    1707 </span>            :          aindex = -1;
<span class="lineNum">    1708 </span>            :          ++input_row; /* To point to the first component */
<span class="lineNum">    1709 </span>            :          ++output_row;
<span class="lineNum">    1710 </span>            :       }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :       else
<span class="lineNum">    1713 </span>            : #   endif
<span class="lineNum">    1714 </span>            :       aindex = (int)channels;
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span>            :       /* Use row_end in place of a loop counter: */
<span class="lineNum">    1717 </span>            :       row_end = output_row + image-&gt;width * (channels+1);
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :       for (; y &gt; 0; --y)
<span class="lineNum">    1720 </span>            :       {
<span class="lineNum">    1721 </span>            :          png_const_uint_16p in_ptr = input_row;
<span class="lineNum">    1722 </span>            :          png_bytep out_ptr = output_row;
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span>            :          while (out_ptr &lt; row_end)
<span class="lineNum">    1725 </span>            :          {
<span class="lineNum">    1726 </span>            :             png_uint_16 alpha = in_ptr[aindex];
<span class="lineNum">    1727 </span>            :             png_byte alphabyte = (png_byte)PNG_DIV257(alpha);
<span class="lineNum">    1728 </span>            :             png_uint_32 reciprocal = 0;
<span class="lineNum">    1729 </span>            :             int c;
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :             /* Scale and write the alpha channel. */
<span class="lineNum">    1732 </span>            :             out_ptr[aindex] = alphabyte;
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :             if (alphabyte &gt; 0 &amp;&amp; alphabyte &lt; 255)
<span class="lineNum">    1735 </span>            :                reciprocal = UNP_RECIPROCAL(alpha);
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            :             c = (int)channels;
<span class="lineNum">    1738 </span>            :             do /* always at least one channel */
<span class="lineNum">    1739 </span>            :                *out_ptr++ = png_unpremultiply(*in_ptr++, alpha, reciprocal);
<span class="lineNum">    1740 </span>            :             while (--c &gt; 0);
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            :             /* Skip to next component (skip the intervening alpha channel) */
<span class="lineNum">    1743 </span>            :             ++in_ptr;
<span class="lineNum">    1744 </span>            :             ++out_ptr;
<span class="lineNum">    1745 </span>            :          } /* while out_ptr &lt; row_end */
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :          png_write_row(png_ptr, png_voidcast(png_const_bytep,
<span class="lineNum">    1748 </span>            :              display-&gt;local_row));
<span class="lineNum">    1749 </span>            :          input_row += (png_uint_16)display-&gt;row_bytes/(sizeof (png_uint_16));
<span class="lineNum">    1750 </span>            :       } /* while y */
<span class="lineNum">    1751 </span>            :    }
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            :    else
<span class="lineNum">    1754 </span>            :    {
<span class="lineNum">    1755 </span>            :       /* No alpha channel, so the row_end really is the end of the row and it
<span class="lineNum">    1756 </span>            :        * is sufficient to loop over the components one by one.
<span class="lineNum">    1757 </span>            :        */
<span class="lineNum">    1758 </span>            :       png_bytep row_end = output_row + image-&gt;width * channels;
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span>            :       for (; y &gt; 0; --y)
<span class="lineNum">    1761 </span>            :       {
<span class="lineNum">    1762 </span>            :          png_const_uint_16p in_ptr = input_row;
<span class="lineNum">    1763 </span>            :          png_bytep out_ptr = output_row;
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            :          while (out_ptr &lt; row_end)
<span class="lineNum">    1766 </span>            :          {
<span class="lineNum">    1767 </span>            :             png_uint_32 component = *in_ptr++;
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            :             component *= 255;
<span class="lineNum">    1770 </span>            :             *out_ptr++ = (png_byte)PNG_sRGB_FROM_LINEAR(component);
<span class="lineNum">    1771 </span>            :          }
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :          png_write_row(png_ptr, output_row);
<span class="lineNum">    1774 </span>            :          input_row += (png_uint_16)display-&gt;row_bytes/(sizeof (png_uint_16));
<span class="lineNum">    1775 </span>            :       }
<span class="lineNum">    1776 </span>            :    }
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span>            :    return 1;
<span class="lineNum">    1779 </span>            : }
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            : static void
<span class="lineNum">    1782 </span>            : png_image_set_PLTE(png_image_write_control *display)
<span class="lineNum">    1783 </span>            : {
<span class="lineNum">    1784 </span>            :    const png_imagep image = display-&gt;image;
<span class="lineNum">    1785 </span>            :    const void *cmap = display-&gt;colormap;
<span class="lineNum">    1786 </span>            :    const int entries = image-&gt;colormap_entries &gt; 256 ? 256 :
<span class="lineNum">    1787 </span>            :        (int)image-&gt;colormap_entries;
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            :    /* NOTE: the caller must check for cmap != NULL and entries != 0 */
<span class="lineNum">    1790 </span>            :    const png_uint_32 format = image-&gt;format;
<span class="lineNum">    1791 </span>            :    const unsigned int channels = PNG_IMAGE_SAMPLE_CHANNELS(format);
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            : #   if defined(PNG_FORMAT_BGR_SUPPORTED) &amp;&amp;\
<span class="lineNum">    1794 </span>            :       defined(PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED)
<span class="lineNum">    1795 </span>            :       const int afirst = (format &amp; PNG_FORMAT_FLAG_AFIRST) != 0 &amp;&amp;
<span class="lineNum">    1796 </span>            :           (format &amp; PNG_FORMAT_FLAG_ALPHA) != 0;
<span class="lineNum">    1797 </span>            : #   else
<span class="lineNum">    1798 </span>            : #     define afirst 0
<span class="lineNum">    1799 </span>            : #   endif
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            : #   ifdef PNG_FORMAT_BGR_SUPPORTED
<span class="lineNum">    1802 </span>            :       const int bgr = (format &amp; PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
<span class="lineNum">    1803 </span>            : #   else
<span class="lineNum">    1804 </span>            : #     define bgr 0
<span class="lineNum">    1805 </span>            : #   endif
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            :    int i, num_trans;
<span class="lineNum">    1808 </span>            :    png_color palette[256];
<span class="lineNum">    1809 </span>            :    png_byte tRNS[256];
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            :    memset(tRNS, 255, (sizeof tRNS));
<span class="lineNum">    1812 </span>            :    memset(palette, 0, (sizeof palette));
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            :    for (i=num_trans=0; i&lt;entries; ++i)
<span class="lineNum">    1815 </span>            :    {
<span class="lineNum">    1816 </span>            :       /* This gets automatically converted to sRGB with reversal of the
<span class="lineNum">    1817 </span>            :        * pre-multiplication if the color-map has an alpha channel.
<span class="lineNum">    1818 </span>            :        */
<span class="lineNum">    1819 </span>            :       if ((format &amp; PNG_FORMAT_FLAG_LINEAR) != 0)
<span class="lineNum">    1820 </span>            :       {
<span class="lineNum">    1821 </span>            :          png_const_uint_16p entry = png_voidcast(png_const_uint_16p, cmap);
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :          entry += (unsigned int)i * channels;
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            :          if ((channels &amp; 1) != 0) /* no alpha */
<span class="lineNum">    1826 </span>            :          {
<span class="lineNum">    1827 </span>            :             if (channels &gt;= 3) /* RGB */
<span class="lineNum">    1828 </span>            :             {
<span class="lineNum">    1829 </span>            :                palette[i].blue = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
<span class="lineNum">    1830 </span>            :                    entry[(2 ^ bgr)]);
<span class="lineNum">    1831 </span>            :                palette[i].green = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
<span class="lineNum">    1832 </span>            :                    entry[1]);
<span class="lineNum">    1833 </span>            :                palette[i].red = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
<span class="lineNum">    1834 </span>            :                    entry[bgr]);
<span class="lineNum">    1835 </span>            :             }
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :             else /* Gray */
<span class="lineNum">    1838 </span>            :                palette[i].blue = palette[i].red = palette[i].green =
<span class="lineNum">    1839 </span>            :                   (png_byte)PNG_sRGB_FROM_LINEAR(255 * *entry);
<span class="lineNum">    1840 </span>            :          }
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span>            :          else /* alpha */
<span class="lineNum">    1843 </span>            :          {
<span class="lineNum">    1844 </span>            :             png_uint_16 alpha = entry[afirst ? 0 : channels-1];
<span class="lineNum">    1845 </span>            :             png_byte alphabyte = (png_byte)PNG_DIV257(alpha);
<span class="lineNum">    1846 </span>            :             png_uint_32 reciprocal = 0;
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            :             /* Calculate a reciprocal, as in the png_write_image_8bit code above
<span class="lineNum">    1849 </span>            :              * this is designed to produce a value scaled to 255*65535 when
<span class="lineNum">    1850 </span>            :              * divided by 128 (i.e. asr 7).
<span class="lineNum">    1851 </span>            :              */
<span class="lineNum">    1852 </span>            :             if (alphabyte &gt; 0 &amp;&amp; alphabyte &lt; 255)
<span class="lineNum">    1853 </span>            :                reciprocal = (((0xffff*0xff)&lt;&lt;7)+(alpha&gt;&gt;1))/alpha;
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            :             tRNS[i] = alphabyte;
<span class="lineNum">    1856 </span>            :             if (alphabyte &lt; 255)
<span class="lineNum">    1857 </span>            :                num_trans = i+1;
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :             if (channels &gt;= 3) /* RGB */
<span class="lineNum">    1860 </span>            :             {
<span class="lineNum">    1861 </span>            :                palette[i].blue = png_unpremultiply(entry[afirst + (2 ^ bgr)],
<span class="lineNum">    1862 </span>            :                    alpha, reciprocal);
<span class="lineNum">    1863 </span>            :                palette[i].green = png_unpremultiply(entry[afirst + 1], alpha,
<span class="lineNum">    1864 </span>            :                    reciprocal);
<span class="lineNum">    1865 </span>            :                palette[i].red = png_unpremultiply(entry[afirst + bgr], alpha,
<span class="lineNum">    1866 </span>            :                    reciprocal);
<span class="lineNum">    1867 </span>            :             }
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :             else /* gray */
<span class="lineNum">    1870 </span>            :                palette[i].blue = palette[i].red = palette[i].green =
<span class="lineNum">    1871 </span>            :                    png_unpremultiply(entry[afirst], alpha, reciprocal);
<span class="lineNum">    1872 </span>            :          }
<span class="lineNum">    1873 </span>            :       }
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            :       else /* Color-map has sRGB values */
<span class="lineNum">    1876 </span>            :       {
<span class="lineNum">    1877 </span>            :          png_const_bytep entry = png_voidcast(png_const_bytep, cmap);
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span>            :          entry += (unsigned int)i * channels;
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            :          switch (channels)
<span class="lineNum">    1882 </span>            :          {
<span class="lineNum">    1883 </span>            :             case 4:
<span class="lineNum">    1884 </span>            :                tRNS[i] = entry[afirst ? 0 : 3];
<span class="lineNum">    1885 </span>            :                if (tRNS[i] &lt; 255)
<span class="lineNum">    1886 </span>            :                   num_trans = i+1;
<span class="lineNum">    1887 </span>            :                /* FALL THROUGH */
<span class="lineNum">    1888 </span>            :             case 3:
<span class="lineNum">    1889 </span>            :                palette[i].blue = entry[afirst + (2 ^ bgr)];
<span class="lineNum">    1890 </span>            :                palette[i].green = entry[afirst + 1];
<span class="lineNum">    1891 </span>            :                palette[i].red = entry[afirst + bgr];
<span class="lineNum">    1892 </span>            :                break;
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :             case 2:
<span class="lineNum">    1895 </span>            :                tRNS[i] = entry[1 ^ afirst];
<span class="lineNum">    1896 </span>            :                if (tRNS[i] &lt; 255)
<span class="lineNum">    1897 </span>            :                   num_trans = i+1;
<span class="lineNum">    1898 </span>            :                /* FALL THROUGH */
<span class="lineNum">    1899 </span>            :             case 1:
<span class="lineNum">    1900 </span>            :                palette[i].blue = palette[i].red = palette[i].green =
<span class="lineNum">    1901 </span>            :                   entry[afirst];
<span class="lineNum">    1902 </span>            :                break;
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span>            :             default:
<span class="lineNum">    1905 </span>            :                break;
<span class="lineNum">    1906 </span>            :          }
<span class="lineNum">    1907 </span>            :       }
<span class="lineNum">    1908 </span>            :    }
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span>            : #   ifdef afirst
<span class="lineNum">    1911 </span>            : #     undef afirst
<span class="lineNum">    1912 </span>            : #   endif
<span class="lineNum">    1913 </span>            : #   ifdef bgr
<span class="lineNum">    1914 </span>            : #     undef bgr
<span class="lineNum">    1915 </span>            : #   endif
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :    png_set_PLTE(image-&gt;opaque-&gt;png_ptr, image-&gt;opaque-&gt;info_ptr, palette,
<span class="lineNum">    1918 </span>            :        entries);
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :    if (num_trans &gt; 0)
<span class="lineNum">    1921 </span>            :       png_set_tRNS(image-&gt;opaque-&gt;png_ptr, image-&gt;opaque-&gt;info_ptr, tRNS,
<span class="lineNum">    1922 </span>            :           num_trans, NULL);
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            :    image-&gt;colormap_entries = (png_uint_32)entries;
<span class="lineNum">    1925 </span>            : }
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            : static int
<span class="lineNum">    1928 </span>            : png_image_write_main(png_voidp argument)
<span class="lineNum">    1929 </span>            : {
<span class="lineNum">    1930 </span>            :    png_image_write_control *display = png_voidcast(png_image_write_control*,
<span class="lineNum">    1931 </span>            :        argument);
<span class="lineNum">    1932 </span>            :    png_imagep image = display-&gt;image;
<span class="lineNum">    1933 </span>            :    png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;
<span class="lineNum">    1934 </span>            :    png_inforp info_ptr = image-&gt;opaque-&gt;info_ptr;
<span class="lineNum">    1935 </span>            :    png_uint_32 format = image-&gt;format;
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span>            :    /* The following four ints are actually booleans */
<span class="lineNum">    1938 </span>            :    int colormap = (format &amp; PNG_FORMAT_FLAG_COLORMAP);
<span class="lineNum">    1939 </span>            :    int linear = !colormap &amp;&amp; (format &amp; PNG_FORMAT_FLAG_LINEAR); /* input */
<span class="lineNum">    1940 </span>            :    int alpha = !colormap &amp;&amp; (format &amp; PNG_FORMAT_FLAG_ALPHA);
<span class="lineNum">    1941 </span>            :    int write_16bit = linear &amp;&amp; !colormap &amp;&amp; (display-&gt;convert_to_8bit == 0);
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            : #   ifdef PNG_BENIGN_ERRORS_SUPPORTED
<span class="lineNum">    1944 </span>            :       /* Make sure we error out on any bad situation */
<span class="lineNum">    1945 </span>            :       png_set_benign_errors(png_ptr, 0/*error*/);
<span class="lineNum">    1946 </span>            : #   endif
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span>            :    /* Default the 'row_stride' parameter if required, also check the row stride
<span class="lineNum">    1949 </span>            :     * and total image size to ensure that they are within the system limits.
<span class="lineNum">    1950 </span>            :     */
<span class="lineNum">    1951 </span>            :    {
<span class="lineNum">    1952 </span>            :       const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image-&gt;format);
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span>            :       if (image-&gt;width &lt;= 0x7fffffffU/channels) /* no overflow */
<span class="lineNum">    1955 </span>            :       {
<span class="lineNum">    1956 </span>            :          png_uint_32 check;
<span class="lineNum">    1957 </span>            :          const png_uint_32 png_row_stride = image-&gt;width * channels;
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span>            :          if (display-&gt;row_stride == 0)
<span class="lineNum">    1960 </span>            :             display-&gt;row_stride = (png_int_32)/*SAFE*/png_row_stride;
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            :          if (display-&gt;row_stride &lt; 0)
<span class="lineNum">    1963 </span>            :             check = (png_uint_32)(-display-&gt;row_stride);
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span>            :          else
<span class="lineNum">    1966 </span>            :             check = (png_uint_32)display-&gt;row_stride;
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span>            :          if (check &gt;= png_row_stride)
<span class="lineNum">    1969 </span>            :          {
<span class="lineNum">    1970 </span>            :             /* Now check for overflow of the image buffer calculation; this
<span class="lineNum">    1971 </span>            :              * limits the whole image size to 32 bits for API compatibility with
<span class="lineNum">    1972 </span>            :              * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
<span class="lineNum">    1973 </span>            :              */
<span class="lineNum">    1974 </span>            :             if (image-&gt;height &gt; 0xffffffffU/png_row_stride)
<span class="lineNum">    1975 </span>            :                png_error(image-&gt;opaque-&gt;png_ptr, &quot;memory image too large&quot;);
<span class="lineNum">    1976 </span>            :          }
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span>            :          else
<span class="lineNum">    1979 </span>            :             png_error(image-&gt;opaque-&gt;png_ptr, &quot;supplied row stride too small&quot;);
<span class="lineNum">    1980 </span>            :       }
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            :       else
<span class="lineNum">    1983 </span>            :          png_error(image-&gt;opaque-&gt;png_ptr, &quot;image row stride too large&quot;);
<span class="lineNum">    1984 </span>            :    }
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span>            :    /* Set the required transforms then write the rows in the correct order. */
<span class="lineNum">    1987 </span>            :    if ((format &amp; PNG_FORMAT_FLAG_COLORMAP) != 0)
<span class="lineNum">    1988 </span>            :    {
<span class="lineNum">    1989 </span>            :       if (display-&gt;colormap != NULL &amp;&amp; image-&gt;colormap_entries &gt; 0)
<span class="lineNum">    1990 </span>            :       {
<span class="lineNum">    1991 </span>            :          png_uint_32 entries = image-&gt;colormap_entries;
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span>            :          png_set_IHDR(png_ptr, info_ptr, image-&gt;width, image-&gt;height,
<span class="lineNum">    1994 </span>            :              entries &gt; 16 ? 8 : (entries &gt; 4 ? 4 : (entries &gt; 2 ? 2 : 1)),
<span class="lineNum">    1995 </span>            :              PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,
<span class="lineNum">    1996 </span>            :              PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
<span class="lineNum">    1997 </span>            : 
<span class="lineNum">    1998 </span>            :          png_image_set_PLTE(display);
<span class="lineNum">    1999 </span>            :       }
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span>            :       else
<span class="lineNum">    2002 </span>            :          png_error(image-&gt;opaque-&gt;png_ptr,
<span class="lineNum">    2003 </span>            :              &quot;no color-map for color-mapped image&quot;);
<span class="lineNum">    2004 </span>            :    }
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span>            :    else
<span class="lineNum">    2007 </span>            :       png_set_IHDR(png_ptr, info_ptr, image-&gt;width, image-&gt;height,
<span class="lineNum">    2008 </span>            :           write_16bit ? 16 : 8,
<span class="lineNum">    2009 </span>            :           ((format &amp; PNG_FORMAT_FLAG_COLOR) ? PNG_COLOR_MASK_COLOR : 0) +
<span class="lineNum">    2010 </span>            :           ((format &amp; PNG_FORMAT_FLAG_ALPHA) ? PNG_COLOR_MASK_ALPHA : 0),
<span class="lineNum">    2011 </span>            :           PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span>            :    /* Counter-intuitively the data transformations must be called *after*
<span class="lineNum">    2014 </span>            :     * png_write_info, not before as in the read code, but the 'set' functions
<span class="lineNum">    2015 </span>            :     * must still be called before.  Just set the color space information, never
<span class="lineNum">    2016 </span>            :     * write an interlaced image.
<span class="lineNum">    2017 </span>            :     */
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span>            :    if (write_16bit != 0)
<span class="lineNum">    2020 </span>            :    {
<span class="lineNum">    2021 </span>            :       /* The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB. */
<span class="lineNum">    2022 </span>            :       png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_LINEAR);
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            :       if ((image-&gt;flags &amp; PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
<span class="lineNum">    2025 </span>            :          png_set_cHRM_fixed(png_ptr, info_ptr,
<span class="lineNum">    2026 </span>            :              /* color      x       y */
<span class="lineNum">    2027 </span>            :              /* white */ 31270, 32900,
<span class="lineNum">    2028 </span>            :              /* red   */ 64000, 33000,
<span class="lineNum">    2029 </span>            :              /* green */ 30000, 60000,
<span class="lineNum">    2030 </span>            :              /* blue  */ 15000,  6000
<span class="lineNum">    2031 </span>            :          );
<span class="lineNum">    2032 </span>            :    }
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            :    else if ((image-&gt;flags &amp; PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
<span class="lineNum">    2035 </span>            :       png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_PERCEPTUAL);
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            :    /* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
<span class="lineNum">    2038 </span>            :     * space must still be gamma encoded.
<span class="lineNum">    2039 </span>            :     */
<span class="lineNum">    2040 </span>            :    else
<span class="lineNum">    2041 </span>            :       png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            :    /* Write the file header. */
<span class="lineNum">    2044 </span>            :    png_write_info(png_ptr, info_ptr);
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span>            :    /* Now set up the data transformations (*after* the header is written),
<span class="lineNum">    2047 </span>            :     * remove the handled transformations from the 'format' flags for checking.
<span class="lineNum">    2048 </span>            :     *
<span class="lineNum">    2049 </span>            :     * First check for a little endian system if writing 16-bit files.
<span class="lineNum">    2050 </span>            :     */
<span class="lineNum">    2051 </span>            :    if (write_16bit != 0)
<span class="lineNum">    2052 </span>            :    {
<span class="lineNum">    2053 </span>            :       PNG_CONST png_uint_16 le = 0x0001;
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span>            :       if ((*(png_const_bytep) &amp; le) != 0)
<span class="lineNum">    2056 </span>            :          png_set_swap(png_ptr);
<span class="lineNum">    2057 </span>            :    }
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            : #   ifdef PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
<span class="lineNum">    2060 </span>            :       if ((format &amp; PNG_FORMAT_FLAG_BGR) != 0)
<span class="lineNum">    2061 </span>            :       {
<span class="lineNum">    2062 </span>            :          if (colormap == 0 &amp;&amp; (format &amp; PNG_FORMAT_FLAG_COLOR) != 0)
<span class="lineNum">    2063 </span>            :             png_set_bgr(png_ptr);
<span class="lineNum">    2064 </span>            :          format &amp;= ~PNG_FORMAT_FLAG_BGR;
<span class="lineNum">    2065 </span>            :       }
<span class="lineNum">    2066 </span>            : #   endif
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            : #   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
<span class="lineNum">    2069 </span>            :       if ((format &amp; PNG_FORMAT_FLAG_AFIRST) != 0)
<span class="lineNum">    2070 </span>            :       {
<span class="lineNum">    2071 </span>            :          if (colormap == 0 &amp;&amp; (format &amp; PNG_FORMAT_FLAG_ALPHA) != 0)
<span class="lineNum">    2072 </span>            :             png_set_swap_alpha(png_ptr);
<span class="lineNum">    2073 </span>            :          format &amp;= ~PNG_FORMAT_FLAG_AFIRST;
<span class="lineNum">    2074 </span>            :       }
<span class="lineNum">    2075 </span>            : #   endif
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            :    /* If there are 16 or fewer color-map entries we wrote a lower bit depth
<span class="lineNum">    2078 </span>            :     * above, but the application data is still byte packed.
<span class="lineNum">    2079 </span>            :     */
<span class="lineNum">    2080 </span>            :    if (colormap != 0 &amp;&amp; image-&gt;colormap_entries &lt;= 16)
<span class="lineNum">    2081 </span>            :       png_set_packing(png_ptr);
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span>            :    /* That should have handled all (both) the transforms. */
<span class="lineNum">    2084 </span>            :    if ((format &amp; ~(png_uint_32)(PNG_FORMAT_FLAG_COLOR | PNG_FORMAT_FLAG_LINEAR |
<span class="lineNum">    2085 </span>            :          PNG_FORMAT_FLAG_ALPHA | PNG_FORMAT_FLAG_COLORMAP)) != 0)
<span class="lineNum">    2086 </span>            :       png_error(png_ptr, &quot;png_write_image: unsupported transformation&quot;);
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            :    {
<span class="lineNum">    2089 </span>            :       png_const_bytep row = png_voidcast(png_const_bytep, display-&gt;buffer);
<span class="lineNum">    2090 </span>            :       ptrdiff_t row_bytes = display-&gt;row_stride;
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :       if (linear != 0)
<span class="lineNum">    2093 </span>            :          row_bytes *= (sizeof (png_uint_16));
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span>            :       if (row_bytes &lt; 0)
<span class="lineNum">    2096 </span>            :          row += (image-&gt;height-1) * (-row_bytes);
<span class="lineNum">    2097 </span>            : 
<span class="lineNum">    2098 </span>            :       display-&gt;first_row = row;
<span class="lineNum">    2099 </span>            :       display-&gt;row_bytes = row_bytes;
<span class="lineNum">    2100 </span>            :    }
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            :    /* Apply 'fast' options if the flag is set. */
<span class="lineNum">    2103 </span>            :    if ((image-&gt;flags &amp; PNG_IMAGE_FLAG_FAST) != 0)
<span class="lineNum">    2104 </span>            :    {
<span class="lineNum">    2105 </span>            :       png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, PNG_NO_FILTERS);
<span class="lineNum">    2106 </span>            :       /* NOTE: determined by experiment using pngstest, this reflects some
<span class="lineNum">    2107 </span>            :        * balance between the time to write the image once and the time to read
<span class="lineNum">    2108 </span>            :        * it about 50 times.  The speed-up in pngstest was about 10-20% of the
<span class="lineNum">    2109 </span>            :        * total (user) time on a heavily loaded system.
<span class="lineNum">    2110 </span>            :        */
<span class="lineNum">    2111 </span>            : #   ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
<span class="lineNum">    2112 </span>            :       png_set_compression_level(png_ptr, 3);
<span class="lineNum">    2113 </span>            : #   endif
<span class="lineNum">    2114 </span>            :    }
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :    /* Check for the cases that currently require a pre-transform on the row
<span class="lineNum">    2117 </span>            :     * before it is written.  This only applies when the input is 16-bit and
<span class="lineNum">    2118 </span>            :     * either there is an alpha channel or it is converted to 8-bit.
<span class="lineNum">    2119 </span>            :     */
<span class="lineNum">    2120 </span>            :    if ((linear != 0 &amp;&amp; alpha != 0 ) ||
<span class="lineNum">    2121 </span>            :        (colormap == 0 &amp;&amp; display-&gt;convert_to_8bit != 0))
<span class="lineNum">    2122 </span>            :    {
<span class="lineNum">    2123 </span>            :       png_bytep row = png_voidcast(png_bytep, png_malloc(png_ptr,
<span class="lineNum">    2124 </span>            :           png_get_rowbytes(png_ptr, info_ptr)));
<span class="lineNum">    2125 </span>            :       int result;
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span>            :       display-&gt;local_row = row;
<span class="lineNum">    2128 </span>            :       if (write_16bit != 0)
<span class="lineNum">    2129 </span>            :          result = png_safe_execute(image, png_write_image_16bit, display);
<span class="lineNum">    2130 </span>            :       else
<span class="lineNum">    2131 </span>            :          result = png_safe_execute(image, png_write_image_8bit, display);
<span class="lineNum">    2132 </span>            :       display-&gt;local_row = NULL;
<span class="lineNum">    2133 </span>            : 
<span class="lineNum">    2134 </span>            :       png_free(png_ptr, row);
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            :       /* Skip the 'write_end' on error: */
<span class="lineNum">    2137 </span>            :       if (result == 0)
<span class="lineNum">    2138 </span>            :          return 0;
<span class="lineNum">    2139 </span>            :    }
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            :    /* Otherwise this is the case where the input is in a format currently
<span class="lineNum">    2142 </span>            :     * supported by the rest of the libpng write code; call it directly.
<span class="lineNum">    2143 </span>            :     */
<span class="lineNum">    2144 </span>            :    else
<span class="lineNum">    2145 </span>            :    {
<span class="lineNum">    2146 </span>            :       png_const_bytep row = png_voidcast(png_const_bytep, display-&gt;first_row);
<span class="lineNum">    2147 </span>            :       ptrdiff_t row_bytes = display-&gt;row_bytes;
<span class="lineNum">    2148 </span>            :       png_uint_32 y = image-&gt;height;
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span>            :       for (; y &gt; 0; --y)
<span class="lineNum">    2151 </span>            :       {
<span class="lineNum">    2152 </span>            :          png_write_row(png_ptr, row);
<span class="lineNum">    2153 </span>            :          row += row_bytes;
<span class="lineNum">    2154 </span>            :       }
<span class="lineNum">    2155 </span>            :    }
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span>            :    png_write_end(png_ptr, info_ptr);
<span class="lineNum">    2158 </span>            :    return 1;
<span class="lineNum">    2159 </span>            : }
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            : static void (PNGCBAPI
<span class="lineNum">    2163 </span>            : image_memory_write)(png_structp png_ptr, png_bytep/*const*/ data,
<span class="lineNum">    2164 </span>            :     png_size_t size)
<span class="lineNum">    2165 </span>            : {
<span class="lineNum">    2166 </span>            :    png_image_write_control *display = png_voidcast(png_image_write_control*,
<span class="lineNum">    2167 </span>            :        png_ptr-&gt;io_ptr/*backdoor: png_get_io_ptr(png_ptr)*/);
<span class="lineNum">    2168 </span>            :    const png_alloc_size_t ob = display-&gt;output_bytes;
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span>            :    /* Check for overflow; this should never happen: */
<span class="lineNum">    2171 </span>            :    if (size &lt;= ((png_alloc_size_t)-1) - ob)
<span class="lineNum">    2172 </span>            :    {
<span class="lineNum">    2173 </span>            :       /* I don't think libpng ever does this, but just in case: */
<span class="lineNum">    2174 </span>            :       if (size &gt; 0)
<span class="lineNum">    2175 </span>            :       {
<span class="lineNum">    2176 </span>            :          if (display-&gt;memory_bytes &gt;= ob+size) /* writing */
<span class="lineNum">    2177 </span>            :             memcpy(display-&gt;memory+ob, data, size);
<span class="lineNum">    2178 </span>            : 
<span class="lineNum">    2179 </span>            :          /* Always update the size: */
<span class="lineNum">    2180 </span>            :          display-&gt;output_bytes = ob+size;
<span class="lineNum">    2181 </span>            :       }
<span class="lineNum">    2182 </span>            :    }
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span>            :    else
<span class="lineNum">    2185 </span>            :       png_error(png_ptr, &quot;png_image_write_to_memory: PNG too big&quot;);
<span class="lineNum">    2186 </span>            : }
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            : static void (PNGCBAPI
<span class="lineNum">    2189 </span>            : image_memory_flush)(png_structp png_ptr)
<span class="lineNum">    2190 </span>            : {
<span class="lineNum">    2191 </span>            :    PNG_UNUSED(png_ptr)
<span class="lineNum">    2192 </span>            : }
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            : static int
<span class="lineNum">    2195 </span>            : png_image_write_memory(png_voidp argument)
<span class="lineNum">    2196 </span>            : {
<span class="lineNum">    2197 </span>            :    png_image_write_control *display = png_voidcast(png_image_write_control*,
<span class="lineNum">    2198 </span>            :        argument);
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span>            :    /* The rest of the memory-specific init and write_main in an error protected
<span class="lineNum">    2201 </span>            :     * environment.  This case needs to use callbacks for the write operations
<span class="lineNum">    2202 </span>            :     * since libpng has no built in support for writing to memory.
<span class="lineNum">    2203 </span>            :     */
<span class="lineNum">    2204 </span>            :    png_set_write_fn(display-&gt;image-&gt;opaque-&gt;png_ptr, display/*io_ptr*/,
<span class="lineNum">    2205 </span>            :        image_memory_write, image_memory_flush);
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            :    return png_image_write_main(display);
<span class="lineNum">    2208 </span>            : }
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span>            : int PNGAPI
<span class="lineNum">    2211 </span>            : png_image_write_to_memory(png_imagep image, void *memory,
<span class="lineNum">    2212 </span>            :     png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8bit,
<span class="lineNum">    2213 </span>            :     const void *buffer, png_int_32 row_stride, const void *colormap)
<span class="lineNum">    2214 </span>            : {
<span class="lineNum">    2215 </span>            :    /* Write the image to the given buffer, or count the bytes if it is NULL */
<span class="lineNum">    2216 </span>            :    if (image != NULL &amp;&amp; image-&gt;version == PNG_IMAGE_VERSION)
<span class="lineNum">    2217 </span>            :    {
<span class="lineNum">    2218 </span>            :       if (memory_bytes != NULL &amp;&amp; buffer != NULL)
<span class="lineNum">    2219 </span>            :       {
<span class="lineNum">    2220 </span>            :          /* This is to give the caller an easier error detection in the NULL
<span class="lineNum">    2221 </span>            :           * case and guard against uninitialized variable problems:
<span class="lineNum">    2222 </span>            :           */
<span class="lineNum">    2223 </span>            :          if (memory == NULL)
<span class="lineNum">    2224 </span>            :             *memory_bytes = 0;
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span>            :          if (png_image_write_init(image) != 0)
<span class="lineNum">    2227 </span>            :          {
<span class="lineNum">    2228 </span>            :             png_image_write_control display;
<span class="lineNum">    2229 </span>            :             int result;
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span>            :             memset(&amp;display, 0, (sizeof display));
<span class="lineNum">    2232 </span>            :             display.image = image;
<span class="lineNum">    2233 </span>            :             display.buffer = buffer;
<span class="lineNum">    2234 </span>            :             display.row_stride = row_stride;
<span class="lineNum">    2235 </span>            :             display.colormap = colormap;
<span class="lineNum">    2236 </span>            :             display.convert_to_8bit = convert_to_8bit;
<span class="lineNum">    2237 </span>            :             display.memory = png_voidcast(png_bytep, memory);
<span class="lineNum">    2238 </span>            :             display.memory_bytes = *memory_bytes;
<span class="lineNum">    2239 </span>            :             display.output_bytes = 0;
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span>            :             result = png_safe_execute(image, png_image_write_memory, &amp;display);
<span class="lineNum">    2242 </span>            :             png_image_free(image);
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            :             /* write_memory returns true even if we ran out of buffer. */
<span class="lineNum">    2245 </span>            :             if (result)
<span class="lineNum">    2246 </span>            :             {
<span class="lineNum">    2247 </span>            :                /* On out-of-buffer this function returns '0' but still updates
<span class="lineNum">    2248 </span>            :                 * memory_bytes:
<span class="lineNum">    2249 </span>            :                 */
<span class="lineNum">    2250 </span>            :                if (memory != NULL &amp;&amp; display.output_bytes &gt; *memory_bytes)
<span class="lineNum">    2251 </span>            :                   result = 0;
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span>            :                *memory_bytes = display.output_bytes;
<span class="lineNum">    2254 </span>            :             }
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            :             return result;
<span class="lineNum">    2257 </span>            :          }
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span>            :          else
<span class="lineNum">    2260 </span>            :             return 0;
<span class="lineNum">    2261 </span>            :       }
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            :       else
<span class="lineNum">    2264 </span>            :          return png_image_error(image,
<span class="lineNum">    2265 </span>            :              &quot;png_image_write_to_memory: invalid argument&quot;);
<span class="lineNum">    2266 </span>            :    }
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            :    else if (image != NULL)
<span class="lineNum">    2269 </span>            :       return png_image_error(image,
<span class="lineNum">    2270 </span>            :           &quot;png_image_write_to_memory: incorrect PNG_IMAGE_VERSION&quot;);
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            :    else
<span class="lineNum">    2273 </span>            :       return 0;
<span class="lineNum">    2274 </span>            : }
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span>            : #ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
<span class="lineNum">    2277 </span>            : int PNGAPI
<span class="lineNum">    2278 </span>            : png_image_write_to_stdio(png_imagep image, FILE *file, int convert_to_8bit,
<span class="lineNum">    2279 </span>            :     const void *buffer, png_int_32 row_stride, const void *colormap)
<span class="lineNum">    2280 </span>            : {
<span class="lineNum">    2281 </span>            :    /* Write the image to the given (FILE*). */
<span class="lineNum">    2282 </span>            :    if (image != NULL &amp;&amp; image-&gt;version == PNG_IMAGE_VERSION)
<span class="lineNum">    2283 </span>            :    {
<span class="lineNum">    2284 </span>            :       if (file != NULL &amp;&amp; buffer != NULL)
<span class="lineNum">    2285 </span>            :       {
<span class="lineNum">    2286 </span>            :          if (png_image_write_init(image) != 0)
<span class="lineNum">    2287 </span>            :          {
<span class="lineNum">    2288 </span>            :             png_image_write_control display;
<span class="lineNum">    2289 </span>            :             int result;
<span class="lineNum">    2290 </span>            : 
<span class="lineNum">    2291 </span>            :             /* This is slightly evil, but png_init_io doesn't do anything other
<span class="lineNum">    2292 </span>            :              * than this and we haven't changed the standard IO functions so
<span class="lineNum">    2293 </span>            :              * this saves a 'safe' function.
<span class="lineNum">    2294 </span>            :              */
<span class="lineNum">    2295 </span>            :             image-&gt;opaque-&gt;png_ptr-&gt;io_ptr = file;
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span>            :             memset(&amp;display, 0, (sizeof display));
<span class="lineNum">    2298 </span>            :             display.image = image;
<span class="lineNum">    2299 </span>            :             display.buffer = buffer;
<span class="lineNum">    2300 </span>            :             display.row_stride = row_stride;
<span class="lineNum">    2301 </span>            :             display.colormap = colormap;
<span class="lineNum">    2302 </span>            :             display.convert_to_8bit = convert_to_8bit;
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span>            :             result = png_safe_execute(image, png_image_write_main, &amp;display);
<span class="lineNum">    2305 </span>            :             png_image_free(image);
<span class="lineNum">    2306 </span>            :             return result;
<span class="lineNum">    2307 </span>            :          }
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span>            :          else
<span class="lineNum">    2310 </span>            :             return 0;
<span class="lineNum">    2311 </span>            :       }
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :       else
<span class="lineNum">    2314 </span>            :          return png_image_error(image,
<span class="lineNum">    2315 </span>            :              &quot;png_image_write_to_stdio: invalid argument&quot;);
<span class="lineNum">    2316 </span>            :    }
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span>            :    else if (image != NULL)
<span class="lineNum">    2319 </span>            :       return png_image_error(image,
<span class="lineNum">    2320 </span>            :           &quot;png_image_write_to_stdio: incorrect PNG_IMAGE_VERSION&quot;);
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            :    else
<span class="lineNum">    2323 </span>            :       return 0;
<span class="lineNum">    2324 </span>            : }
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span>            : int PNGAPI
<span class="lineNum">    2327 </span>            : png_image_write_to_file(png_imagep image, const char *file_name,
<span class="lineNum">    2328 </span>            :     int convert_to_8bit, const void *buffer, png_int_32 row_stride,
<span class="lineNum">    2329 </span>            :     const void *colormap)
<span class="lineNum">    2330 </span>            : {
<span class="lineNum">    2331 </span>            :    /* Write the image to the named file. */
<span class="lineNum">    2332 </span>            :    if (image != NULL &amp;&amp; image-&gt;version == PNG_IMAGE_VERSION)
<span class="lineNum">    2333 </span>            :    {
<span class="lineNum">    2334 </span>            :       if (file_name != NULL &amp;&amp; buffer != NULL)
<span class="lineNum">    2335 </span>            :       {
<span class="lineNum">    2336 </span>            :          FILE *fp = fopen(file_name, &quot;wb&quot;);
<span class="lineNum">    2337 </span>            : 
<span class="lineNum">    2338 </span>            :          if (fp != NULL)
<span class="lineNum">    2339 </span>            :          {
<span class="lineNum">    2340 </span>            :             if (png_image_write_to_stdio(image, fp, convert_to_8bit, buffer,
<span class="lineNum">    2341 </span>            :                 row_stride, colormap) != 0)
<span class="lineNum">    2342 </span>            :             {
<span class="lineNum">    2343 </span>            :                int error; /* from fflush/fclose */
<span class="lineNum">    2344 </span>            : 
<span class="lineNum">    2345 </span>            :                /* Make sure the file is flushed correctly. */
<span class="lineNum">    2346 </span>            :                if (fflush(fp) == 0 &amp;&amp; ferror(fp) == 0)
<span class="lineNum">    2347 </span>            :                {
<span class="lineNum">    2348 </span>            :                   if (fclose(fp) == 0)
<span class="lineNum">    2349 </span>            :                      return 1;
<span class="lineNum">    2350 </span>            : 
<span class="lineNum">    2351 </span>            :                   error = errno; /* from fclose */
<span class="lineNum">    2352 </span>            :                }
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :                else
<span class="lineNum">    2355 </span>            :                {
<span class="lineNum">    2356 </span>            :                   error = errno; /* from fflush or ferror */
<span class="lineNum">    2357 </span>            :                   (void)fclose(fp);
<span class="lineNum">    2358 </span>            :                }
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span>            :                (void)remove(file_name);
<span class="lineNum">    2361 </span>            :                /* The image has already been cleaned up; this is just used to
<span class="lineNum">    2362 </span>            :                 * set the error (because the original write succeeded).
<span class="lineNum">    2363 </span>            :                 */
<span class="lineNum">    2364 </span>            :                return png_image_error(image, strerror(error));
<span class="lineNum">    2365 </span>            :             }
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span>            :             else
<span class="lineNum">    2368 </span>            :             {
<span class="lineNum">    2369 </span>            :                /* Clean up: just the opened file. */
<span class="lineNum">    2370 </span>            :                (void)fclose(fp);
<span class="lineNum">    2371 </span>            :                (void)remove(file_name);
<span class="lineNum">    2372 </span>            :                return 0;
<span class="lineNum">    2373 </span>            :             }
<span class="lineNum">    2374 </span>            :          }
<span class="lineNum">    2375 </span>            : 
<span class="lineNum">    2376 </span>            :          else
<span class="lineNum">    2377 </span>            :             return png_image_error(image, strerror(errno));
<span class="lineNum">    2378 </span>            :       }
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span>            :       else
<span class="lineNum">    2381 </span>            :          return png_image_error(image,
<span class="lineNum">    2382 </span>            :              &quot;png_image_write_to_file: invalid argument&quot;);
<span class="lineNum">    2383 </span>            :    }
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :    else if (image != NULL)
<span class="lineNum">    2386 </span>            :       return png_image_error(image,
<span class="lineNum">    2387 </span>            :           &quot;png_image_write_to_file: incorrect PNG_IMAGE_VERSION&quot;);
<span class="lineNum">    2388 </span>            : 
<span class="lineNum">    2389 </span>            :    else
<span class="lineNum">    2390 </span>            :       return 0;
<span class="lineNum">    2391 </span>            : }
<span class="lineNum">    2392 </span>            : #endif /* SIMPLIFIED_WRITE_STDIO */
<span class="lineNum">    2393 </span>            : #endif /* SIMPLIFIED_WRITE */
<span class="lineNum">    2394 </span>            : 
<a name="2395"><span class="lineNum">    2395 </span>            : #ifdef PNG_WRITE_APNG_SUPPORTED</a>
<span class="lineNum">    2396 </span>            : void PNGAPI
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 : png_write_frame_head(png_structp png_ptr, png_infop info_ptr,</span>
<span class="lineNum">    2398 </span>            :     png_bytepp row_pointers, png_uint_32 width, png_uint_32 height,
<span class="lineNum">    2399 </span>            :     png_uint_32 x_offset, png_uint_32 y_offset,
<span class="lineNum">    2400 </span>            :     png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
<span class="lineNum">    2401 </span>            :     png_byte blend_op)
<span class="lineNum">    2402 </span>            : {
<span class="lineNum">    2403 </span>            :     png_debug(1, &quot;in png_write_frame_head&quot;);
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span>            :     /* there is a chance this has been set after png_write_info was called,
<span class="lineNum">    2406 </span>            :     * so it would be set but not written. is there a way to be sure? */
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     if ((info_ptr-&gt;valid &amp; PNG_INFO_acTL) == 0)</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :         png_error(png_ptr, &quot;png_write_frame_head(): acTL not set&quot;);</span>
<span class="lineNum">    2409 </span>            : 
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :     png_write_reset(png_ptr);</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :     png_write_reinit(png_ptr, info_ptr, width, height);</span>
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :     if ((png_ptr-&gt;apng_flags &amp; PNG_FIRST_FRAME_HIDDEN) == 0 ||</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :         png_ptr-&gt;num_frames_written != 0)</span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :         png_write_fcTL(png_ptr, width, height, x_offset, y_offset,</span>
<span class="lineNum">    2417 </span>            :                        delay_num, delay_den, dispose_op, blend_op);
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :     PNG_UNUSED(row_pointers)
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 : }</span>
<a name="2421"><span class="lineNum">    2421 </span>            : </a>
<span class="lineNum">    2422 </span>            : void PNGAPI
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 : png_write_frame_tail(png_structp png_ptr, png_infop info_ptr)</span>
<span class="lineNum">    2424 </span>            : {
<span class="lineNum">    2425 </span>            :     png_debug(1, &quot;in png_write_frame_tail&quot;);
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :     png_ptr-&gt;num_frames_written++;</span>
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            :     PNG_UNUSED(info_ptr)
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2431 </span>            : #endif /* WRITE_APNG */
<span class="lineNum">    2432 </span>            : #endif /* WRITE */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

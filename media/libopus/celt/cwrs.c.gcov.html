<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libopus/celt/cwrs.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/libopus/celt</a> - cwrs.c<span style="font-size: 80%;"> (source / <a href="cwrs.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">68</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (c) 2007-2008 CSIRO</a>
<span class="lineNum">       2 </span>            :    Copyright (c) 2007-2009 Xiph.Org Foundation
<span class="lineNum">       3 </span>            :    Copyright (c) 2007-2009 Timothy B. Terriberry
<span class="lineNum">       4 </span>            :    Written by Timothy B. Terriberry and Jean-Marc Valin */
<span class="lineNum">       5 </span>            : /*
<span class="lineNum">       6 </span>            :    Redistribution and use in source and binary forms, with or without
<span class="lineNum">       7 </span>            :    modification, are permitted provided that the following conditions
<span class="lineNum">       8 </span>            :    are met:
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            :    - Redistributions of source code must retain the above copyright
<span class="lineNum">      11 </span>            :    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :    - Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      14 </span>            :    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      15 </span>            :    documentation and/or other materials provided with the distribution.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            :    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      18 </span>            :    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      19 </span>            :    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      20 </span>            :    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
<span class="lineNum">      21 </span>            :    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<span class="lineNum">      22 </span>            :    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      23 </span>            :    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span class="lineNum">      24 </span>            :    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span class="lineNum">      25 </span>            :    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span class="lineNum">      26 </span>            :    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span class="lineNum">      27 </span>            :    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      28 </span>            : */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #ifdef HAVE_CONFIG_H
<span class="lineNum">      31 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;os_support.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;cwrs.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mathops.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;arch.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #ifdef CUSTOM_MODES
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : /*Guaranteed to return a conservatively large estimate of the binary logarithm
<span class="lineNum">      42 </span>            :    with frac bits of fractional precision.
<span class="lineNum">      43 </span>            :   Tested for all possible 32-bit inputs with frac=4, where the maximum
<span class="lineNum">      44 </span>            :    overestimation is 0.06254243 bits.*/
<span class="lineNum">      45 </span>            : int log2_frac(opus_uint32 val, int frac)
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span>            :   int l;
<span class="lineNum">      48 </span>            :   l=EC_ILOG(val);
<span class="lineNum">      49 </span>            :   if(val&amp;(val-1)){
<span class="lineNum">      50 </span>            :     /*This is (val&gt;&gt;l-16), but guaranteed to round up, even if adding a bias
<span class="lineNum">      51 </span>            :        before the shift would cause overflow (e.g., for 0xFFFFxxxx).
<span class="lineNum">      52 </span>            :        Doesn't work for val=0, but that case fails the test above.*/
<span class="lineNum">      53 </span>            :     if(l&gt;16)val=((val-1)&gt;&gt;(l-16))+1;
<span class="lineNum">      54 </span>            :     else val&lt;&lt;=16-l;
<span class="lineNum">      55 </span>            :     l=(l-1)&lt;&lt;frac;
<span class="lineNum">      56 </span>            :     /*Note that we always need one iteration, since the rounding up above means
<span class="lineNum">      57 </span>            :        that we might need to adjust the integer part of the logarithm.*/
<span class="lineNum">      58 </span>            :     do{
<span class="lineNum">      59 </span>            :       int b;
<span class="lineNum">      60 </span>            :       b=(int)(val&gt;&gt;16);
<span class="lineNum">      61 </span>            :       l+=b&lt;&lt;frac;
<span class="lineNum">      62 </span>            :       val=(val+b)&gt;&gt;b;
<span class="lineNum">      63 </span>            :       val=(val*val+0x7FFF)&gt;&gt;15;
<span class="lineNum">      64 </span>            :     }
<span class="lineNum">      65 </span>            :     while(frac--&gt;0);
<span class="lineNum">      66 </span>            :     /*If val is not exactly 0x8000, then we have to round up the remainder.*/
<span class="lineNum">      67 </span>            :     return l+(val&gt;0x8000);
<span class="lineNum">      68 </span>            :   }
<span class="lineNum">      69 </span>            :   /*Exact powers of two require no rounding.*/
<span class="lineNum">      70 </span>            :   else return (l-1)&lt;&lt;frac;
<span class="lineNum">      71 </span>            : }
<span class="lineNum">      72 </span>            : #endif
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /*Although derived separately, the pulse vector coding scheme is equivalent to
<span class="lineNum">      75 </span>            :    a Pyramid Vector Quantizer \cite{Fis86}.
<span class="lineNum">      76 </span>            :   Some additional notes about an early version appear at
<span class="lineNum">      77 </span>            :    https://people.xiph.org/~tterribe/notes/cwrs.html, but the codebook ordering
<span class="lineNum">      78 </span>            :    and the definitions of some terms have evolved since that was written.
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   The conversion from a pulse vector to an integer index (encoding) and back
<span class="lineNum">      81 </span>            :    (decoding) is governed by two related functions, V(N,K) and U(N,K).
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :   V(N,K) = the number of combinations, with replacement, of N items, taken K
<span class="lineNum">      84 </span>            :    at a time, when a sign bit is added to each item taken at least once (i.e.,
<span class="lineNum">      85 </span>            :    the number of N-dimensional unit pulse vectors with K pulses).
<span class="lineNum">      86 </span>            :   One way to compute this is via
<span class="lineNum">      87 </span>            :     V(N,K) = K&gt;0 ? sum(k=1...K,2**k*choose(N,k)*choose(K-1,k-1)) : 1,
<span class="lineNum">      88 </span>            :    where choose() is the binomial function.
<span class="lineNum">      89 </span>            :   A table of values for N&lt;10 and K&lt;10 looks like:
<span class="lineNum">      90 </span>            :   V[10][10] = {
<span class="lineNum">      91 </span>            :     {1,  0,   0,    0,    0,     0,     0,      0,      0,       0},
<span class="lineNum">      92 </span>            :     {1,  2,   2,    2,    2,     2,     2,      2,      2,       2},
<span class="lineNum">      93 </span>            :     {1,  4,   8,   12,   16,    20,    24,     28,     32,      36},
<span class="lineNum">      94 </span>            :     {1,  6,  18,   38,   66,   102,   146,    198,    258,     326},
<span class="lineNum">      95 </span>            :     {1,  8,  32,   88,  192,   360,   608,    952,   1408,    1992},
<span class="lineNum">      96 </span>            :     {1, 10,  50,  170,  450,  1002,  1970,   3530,   5890,    9290},
<span class="lineNum">      97 </span>            :     {1, 12,  72,  292,  912,  2364,  5336,  10836,  20256,   35436},
<span class="lineNum">      98 </span>            :     {1, 14,  98,  462, 1666,  4942, 12642,  28814,  59906,  115598},
<span class="lineNum">      99 </span>            :     {1, 16, 128,  688, 2816,  9424, 27008,  68464, 157184,  332688},
<span class="lineNum">     100 </span>            :     {1, 18, 162,  978, 4482, 16722, 53154, 148626, 374274,  864146}
<span class="lineNum">     101 </span>            :   };
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :   U(N,K) = the number of such combinations wherein N-1 objects are taken at
<span class="lineNum">     104 </span>            :    most K-1 at a time.
<span class="lineNum">     105 </span>            :   This is given by
<span class="lineNum">     106 </span>            :     U(N,K) = sum(k=0...K-1,V(N-1,k))
<span class="lineNum">     107 </span>            :            = K&gt;0 ? (V(N-1,K-1) + V(N,K-1))/2 : 0.
<span class="lineNum">     108 </span>            :   The latter expression also makes clear that U(N,K) is half the number of such
<span class="lineNum">     109 </span>            :    combinations wherein the first object is taken at least once.
<span class="lineNum">     110 </span>            :   Although it may not be clear from either of these definitions, U(N,K) is the
<span class="lineNum">     111 </span>            :    natural function to work with when enumerating the pulse vector codebooks,
<span class="lineNum">     112 </span>            :    not V(N,K).
<span class="lineNum">     113 </span>            :   U(N,K) is not well-defined for N=0, but with the extension
<span class="lineNum">     114 </span>            :     U(0,K) = K&gt;0 ? 0 : 1,
<span class="lineNum">     115 </span>            :    the function becomes symmetric: U(N,K) = U(K,N), with a similar table:
<span class="lineNum">     116 </span>            :   U[10][10] = {
<span class="lineNum">     117 </span>            :     {1, 0,  0,   0,    0,    0,     0,     0,      0,      0},
<span class="lineNum">     118 </span>            :     {0, 1,  1,   1,    1,    1,     1,     1,      1,      1},
<span class="lineNum">     119 </span>            :     {0, 1,  3,   5,    7,    9,    11,    13,     15,     17},
<span class="lineNum">     120 </span>            :     {0, 1,  5,  13,   25,   41,    61,    85,    113,    145},
<span class="lineNum">     121 </span>            :     {0, 1,  7,  25,   63,  129,   231,   377,    575,    833},
<span class="lineNum">     122 </span>            :     {0, 1,  9,  41,  129,  321,   681,  1289,   2241,   3649},
<span class="lineNum">     123 </span>            :     {0, 1, 11,  61,  231,  681,  1683,  3653,   7183,  13073},
<span class="lineNum">     124 </span>            :     {0, 1, 13,  85,  377, 1289,  3653,  8989,  19825,  40081},
<span class="lineNum">     125 </span>            :     {0, 1, 15, 113,  575, 2241,  7183, 19825,  48639, 108545},
<span class="lineNum">     126 </span>            :     {0, 1, 17, 145,  833, 3649, 13073, 40081, 108545, 265729}
<span class="lineNum">     127 </span>            :   };
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :   With this extension, V(N,K) may be written in terms of U(N,K):
<span class="lineNum">     130 </span>            :     V(N,K) = U(N,K) + U(N,K+1)
<span class="lineNum">     131 </span>            :    for all N&gt;=0, K&gt;=0.
<span class="lineNum">     132 </span>            :   Thus U(N,K+1) represents the number of combinations where the first element
<span class="lineNum">     133 </span>            :    is positive or zero, and U(N,K) represents the number of combinations where
<span class="lineNum">     134 </span>            :    it is negative.
<span class="lineNum">     135 </span>            :   With a large enough table of U(N,K) values, we could write O(N) encoding
<span class="lineNum">     136 </span>            :    and O(min(N*log(K),N+K)) decoding routines, but such a table would be
<span class="lineNum">     137 </span>            :    prohibitively large for small embedded devices (K may be as large as 32767
<span class="lineNum">     138 </span>            :    for small N, and N may be as large as 200).
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   Both functions obey the same recurrence relation:
<span class="lineNum">     141 </span>            :     V(N,K) = V(N-1,K) + V(N,K-1) + V(N-1,K-1),
<span class="lineNum">     142 </span>            :     U(N,K) = U(N-1,K) + U(N,K-1) + U(N-1,K-1),
<span class="lineNum">     143 </span>            :    for all N&gt;0, K&gt;0, with different initial conditions at N=0 or K=0.
<span class="lineNum">     144 </span>            :   This allows us to construct a row of one of the tables above given the
<span class="lineNum">     145 </span>            :    previous row or the next row.
<span class="lineNum">     146 </span>            :   Thus we can derive O(NK) encoding and decoding routines with O(K) memory
<span class="lineNum">     147 </span>            :    using only addition and subtraction.
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   When encoding, we build up from the U(2,K) row and work our way forwards.
<span class="lineNum">     150 </span>            :   When decoding, we need to start at the U(N,K) row and work our way backwards,
<span class="lineNum">     151 </span>            :    which requires a means of computing U(N,K).
<span class="lineNum">     152 </span>            :   U(N,K) may be computed from two previous values with the same N:
<span class="lineNum">     153 </span>            :     U(N,K) = ((2*N-1)*U(N,K-1) - U(N,K-2))/(K-1) + U(N,K-2)
<span class="lineNum">     154 </span>            :    for all N&gt;1, and since U(N,K) is symmetric, a similar relation holds for two
<span class="lineNum">     155 </span>            :    previous values with the same K:
<span class="lineNum">     156 </span>            :     U(N,K&gt;1) = ((2*K-1)*U(N-1,K) - U(N-2,K))/(N-1) + U(N-2,K)
<span class="lineNum">     157 </span>            :    for all K&gt;1.
<span class="lineNum">     158 </span>            :   This allows us to construct an arbitrary row of the U(N,K) table by starting
<span class="lineNum">     159 </span>            :    with the first two values, which are constants.
<span class="lineNum">     160 </span>            :   This saves roughly 2/3 the work in our O(NK) decoding routine, but costs O(K)
<span class="lineNum">     161 </span>            :    multiplications.
<span class="lineNum">     162 </span>            :   Similar relations can be derived for V(N,K), but are not used here.
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   For N&gt;0 and K&gt;0, U(N,K) and V(N,K) take on the form of an (N-1)-degree
<span class="lineNum">     165 </span>            :    polynomial for fixed N.
<span class="lineNum">     166 </span>            :   The first few are
<span class="lineNum">     167 </span>            :     U(1,K) = 1,
<span class="lineNum">     168 </span>            :     U(2,K) = 2*K-1,
<span class="lineNum">     169 </span>            :     U(3,K) = (2*K-2)*K+1,
<span class="lineNum">     170 </span>            :     U(4,K) = (((4*K-6)*K+8)*K-3)/3,
<span class="lineNum">     171 </span>            :     U(5,K) = ((((2*K-4)*K+10)*K-8)*K+3)/3,
<span class="lineNum">     172 </span>            :    and
<span class="lineNum">     173 </span>            :     V(1,K) = 2,
<span class="lineNum">     174 </span>            :     V(2,K) = 4*K,
<span class="lineNum">     175 </span>            :     V(3,K) = 4*K*K+2,
<span class="lineNum">     176 </span>            :     V(4,K) = 8*(K*K+2)*K/3,
<span class="lineNum">     177 </span>            :     V(5,K) = ((4*K*K+20)*K*K+6)/3,
<span class="lineNum">     178 </span>            :    for all K&gt;0.
<span class="lineNum">     179 </span>            :   This allows us to derive O(N) encoding and O(N*log(K)) decoding routines for
<span class="lineNum">     180 </span>            :    small N (and indeed decoding is also O(N) for N&lt;3).
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   @ARTICLE{Fis86,
<span class="lineNum">     183 </span>            :     author=&quot;Thomas R. Fischer&quot;,
<span class="lineNum">     184 </span>            :     title=&quot;A Pyramid Vector Quantizer&quot;,
<span class="lineNum">     185 </span>            :     journal=&quot;IEEE Transactions on Information Theory&quot;,
<span class="lineNum">     186 </span>            :     volume=&quot;IT-32&quot;,
<span class="lineNum">     187 </span>            :     number=4,
<span class="lineNum">     188 </span>            :     pages=&quot;568--583&quot;,
<span class="lineNum">     189 </span>            :     month=Jul,
<span class="lineNum">     190 </span>            :     year=1986
<span class="lineNum">     191 </span>            :   }*/
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : #if !defined(SMALL_FOOTPRINT)
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /*U(N,K) = U(K,N) := N&gt;0?K&gt;0?U(N-1,K)+U(N,K-1)+U(N-1,K-1):0:K&gt;0?1:0*/
<span class="lineNum">     196 </span>            : # define CELT_PVQ_U(_n,_k) (CELT_PVQ_U_ROW[IMIN(_n,_k)][IMAX(_n,_k)])
<span class="lineNum">     197 </span>            : /*V(N,K) := U(N,K)+U(N,K+1) = the number of PVQ codewords for a band of size N
<span class="lineNum">     198 </span>            :    with K pulses allocated to it.*/
<span class="lineNum">     199 </span>            : # define CELT_PVQ_V(_n,_k) (CELT_PVQ_U(_n,_k)+CELT_PVQ_U(_n,(_k)+1))
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /*For each V(N,K) supported, we will access element U(min(N,K+1),max(N,K+1)).
<span class="lineNum">     202 </span>            :   Thus, the number of entries in row I is the larger of the maximum number of
<span class="lineNum">     203 </span>            :    pulses we will ever allocate for a given N=I (K=128, or however many fit in
<span class="lineNum">     204 </span>            :    32 bits, whichever is smaller), plus one, and the maximum N for which
<span class="lineNum">     205 </span>            :    K=I-1 pulses fit in 32 bits.
<span class="lineNum">     206 </span>            :   The largest band size in an Opus Custom mode is 208.
<span class="lineNum">     207 </span>            :   Otherwise, we can limit things to the set of N which can be achieved by
<span class="lineNum">     208 </span>            :    splitting a band from a standard Opus mode: 176, 144, 96, 88, 72, 64, 48,
<span class="lineNum">     209 </span>            :    44, 36, 32, 24, 22, 18, 16, 8, 4, 2).*/
<span class="lineNum">     210 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     211 </span>            : static const opus_uint32 CELT_PVQ_U_DATA[1488]={
<span class="lineNum">     212 </span>            : #else
<span class="lineNum">     213 </span>            : static const opus_uint32 CELT_PVQ_U_DATA[1272]={
<span class="lineNum">     214 </span>            : #endif
<span class="lineNum">     215 </span>            :   /*N=0, K=0...176:*/
<span class="lineNum">     216 </span>            :   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     217 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     218 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     219 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     220 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     221 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     222 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     223 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     224 </span>            :   /*...208:*/
<span class="lineNum">     225 </span>            :   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
<span class="lineNum">     226 </span>            :   0, 0, 0, 0, 0, 0,
<span class="lineNum">     227 </span>            : #endif
<span class="lineNum">     228 </span>            :   /*N=1, K=1...176:*/
<span class="lineNum">     229 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     230 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     231 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     232 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     233 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     234 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     235 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     236 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     237 </span>            :   /*...208:*/
<span class="lineNum">     238 </span>            :   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
<span class="lineNum">     239 </span>            :   1, 1, 1, 1, 1, 1,
<span class="lineNum">     240 </span>            : #endif
<span class="lineNum">     241 </span>            :   /*N=2, K=2...176:*/
<span class="lineNum">     242 </span>            :   3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41,
<span class="lineNum">     243 </span>            :   43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79,
<span class="lineNum">     244 </span>            :   81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 113,
<span class="lineNum">     245 </span>            :   115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 135, 137, 139, 141, 143,
<span class="lineNum">     246 </span>            :   145, 147, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173,
<span class="lineNum">     247 </span>            :   175, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 197, 199, 201, 203,
<span class="lineNum">     248 </span>            :   205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 231, 233,
<span class="lineNum">     249 </span>            :   235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 257, 259, 261, 263,
<span class="lineNum">     250 </span>            :   265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293,
<span class="lineNum">     251 </span>            :   295, 297, 299, 301, 303, 305, 307, 309, 311, 313, 315, 317, 319, 321, 323,
<span class="lineNum">     252 </span>            :   325, 327, 329, 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351,
<span class="lineNum">     253 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     254 </span>            :   /*...208:*/
<span class="lineNum">     255 </span>            :   353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 377, 379, 381,
<span class="lineNum">     256 </span>            :   383, 385, 387, 389, 391, 393, 395, 397, 399, 401, 403, 405, 407, 409, 411,
<span class="lineNum">     257 </span>            :   413, 415,
<span class="lineNum">     258 </span>            : #endif
<span class="lineNum">     259 </span>            :   /*N=3, K=3...176:*/
<span class="lineNum">     260 </span>            :   13, 25, 41, 61, 85, 113, 145, 181, 221, 265, 313, 365, 421, 481, 545, 613,
<span class="lineNum">     261 </span>            :   685, 761, 841, 925, 1013, 1105, 1201, 1301, 1405, 1513, 1625, 1741, 1861,
<span class="lineNum">     262 </span>            :   1985, 2113, 2245, 2381, 2521, 2665, 2813, 2965, 3121, 3281, 3445, 3613, 3785,
<span class="lineNum">     263 </span>            :   3961, 4141, 4325, 4513, 4705, 4901, 5101, 5305, 5513, 5725, 5941, 6161, 6385,
<span class="lineNum">     264 </span>            :   6613, 6845, 7081, 7321, 7565, 7813, 8065, 8321, 8581, 8845, 9113, 9385, 9661,
<span class="lineNum">     265 </span>            :   9941, 10225, 10513, 10805, 11101, 11401, 11705, 12013, 12325, 12641, 12961,
<span class="lineNum">     266 </span>            :   13285, 13613, 13945, 14281, 14621, 14965, 15313, 15665, 16021, 16381, 16745,
<span class="lineNum">     267 </span>            :   17113, 17485, 17861, 18241, 18625, 19013, 19405, 19801, 20201, 20605, 21013,
<span class="lineNum">     268 </span>            :   21425, 21841, 22261, 22685, 23113, 23545, 23981, 24421, 24865, 25313, 25765,
<span class="lineNum">     269 </span>            :   26221, 26681, 27145, 27613, 28085, 28561, 29041, 29525, 30013, 30505, 31001,
<span class="lineNum">     270 </span>            :   31501, 32005, 32513, 33025, 33541, 34061, 34585, 35113, 35645, 36181, 36721,
<span class="lineNum">     271 </span>            :   37265, 37813, 38365, 38921, 39481, 40045, 40613, 41185, 41761, 42341, 42925,
<span class="lineNum">     272 </span>            :   43513, 44105, 44701, 45301, 45905, 46513, 47125, 47741, 48361, 48985, 49613,
<span class="lineNum">     273 </span>            :   50245, 50881, 51521, 52165, 52813, 53465, 54121, 54781, 55445, 56113, 56785,
<span class="lineNum">     274 </span>            :   57461, 58141, 58825, 59513, 60205, 60901, 61601,
<span class="lineNum">     275 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     276 </span>            :   /*...208:*/
<span class="lineNum">     277 </span>            :   62305, 63013, 63725, 64441, 65161, 65885, 66613, 67345, 68081, 68821, 69565,
<span class="lineNum">     278 </span>            :   70313, 71065, 71821, 72581, 73345, 74113, 74885, 75661, 76441, 77225, 78013,
<span class="lineNum">     279 </span>            :   78805, 79601, 80401, 81205, 82013, 82825, 83641, 84461, 85285, 86113,
<span class="lineNum">     280 </span>            : #endif
<span class="lineNum">     281 </span>            :   /*N=4, K=4...176:*/
<span class="lineNum">     282 </span>            :   63, 129, 231, 377, 575, 833, 1159, 1561, 2047, 2625, 3303, 4089, 4991, 6017,
<span class="lineNum">     283 </span>            :   7175, 8473, 9919, 11521, 13287, 15225, 17343, 19649, 22151, 24857, 27775,
<span class="lineNum">     284 </span>            :   30913, 34279, 37881, 41727, 45825, 50183, 54809, 59711, 64897, 70375, 76153,
<span class="lineNum">     285 </span>            :   82239, 88641, 95367, 102425, 109823, 117569, 125671, 134137, 142975, 152193,
<span class="lineNum">     286 </span>            :   161799, 171801, 182207, 193025, 204263, 215929, 228031, 240577, 253575,
<span class="lineNum">     287 </span>            :   267033, 280959, 295361, 310247, 325625, 341503, 357889, 374791, 392217,
<span class="lineNum">     288 </span>            :   410175, 428673, 447719, 467321, 487487, 508225, 529543, 551449, 573951,
<span class="lineNum">     289 </span>            :   597057, 620775, 645113, 670079, 695681, 721927, 748825, 776383, 804609,
<span class="lineNum">     290 </span>            :   833511, 863097, 893375, 924353, 956039, 988441, 1021567, 1055425, 1090023,
<span class="lineNum">     291 </span>            :   1125369, 1161471, 1198337, 1235975, 1274393, 1313599, 1353601, 1394407,
<span class="lineNum">     292 </span>            :   1436025, 1478463, 1521729, 1565831, 1610777, 1656575, 1703233, 1750759,
<span class="lineNum">     293 </span>            :   1799161, 1848447, 1898625, 1949703, 2001689, 2054591, 2108417, 2163175,
<span class="lineNum">     294 </span>            :   2218873, 2275519, 2333121, 2391687, 2451225, 2511743, 2573249, 2635751,
<span class="lineNum">     295 </span>            :   2699257, 2763775, 2829313, 2895879, 2963481, 3032127, 3101825, 3172583,
<span class="lineNum">     296 </span>            :   3244409, 3317311, 3391297, 3466375, 3542553, 3619839, 3698241, 3777767,
<span class="lineNum">     297 </span>            :   3858425, 3940223, 4023169, 4107271, 4192537, 4278975, 4366593, 4455399,
<span class="lineNum">     298 </span>            :   4545401, 4636607, 4729025, 4822663, 4917529, 5013631, 5110977, 5209575,
<span class="lineNum">     299 </span>            :   5309433, 5410559, 5512961, 5616647, 5721625, 5827903, 5935489, 6044391,
<span class="lineNum">     300 </span>            :   6154617, 6266175, 6379073, 6493319, 6608921, 6725887, 6844225, 6963943,
<span class="lineNum">     301 </span>            :   7085049, 7207551,
<span class="lineNum">     302 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     303 </span>            :   /*...208:*/
<span class="lineNum">     304 </span>            :   7331457, 7456775, 7583513, 7711679, 7841281, 7972327, 8104825, 8238783,
<span class="lineNum">     305 </span>            :   8374209, 8511111, 8649497, 8789375, 8930753, 9073639, 9218041, 9363967,
<span class="lineNum">     306 </span>            :   9511425, 9660423, 9810969, 9963071, 10116737, 10271975, 10428793, 10587199,
<span class="lineNum">     307 </span>            :   10747201, 10908807, 11072025, 11236863, 11403329, 11571431, 11741177,
<span class="lineNum">     308 </span>            :   11912575,
<span class="lineNum">     309 </span>            : #endif
<span class="lineNum">     310 </span>            :   /*N=5, K=5...176:*/
<span class="lineNum">     311 </span>            :   321, 681, 1289, 2241, 3649, 5641, 8361, 11969, 16641, 22569, 29961, 39041,
<span class="lineNum">     312 </span>            :   50049, 63241, 78889, 97281, 118721, 143529, 172041, 204609, 241601, 283401,
<span class="lineNum">     313 </span>            :   330409, 383041, 441729, 506921, 579081, 658689, 746241, 842249, 947241,
<span class="lineNum">     314 </span>            :   1061761, 1186369, 1321641, 1468169, 1626561, 1797441, 1981449, 2179241,
<span class="lineNum">     315 </span>            :   2391489, 2618881, 2862121, 3121929, 3399041, 3694209, 4008201, 4341801,
<span class="lineNum">     316 </span>            :   4695809, 5071041, 5468329, 5888521, 6332481, 6801089, 7295241, 7815849,
<span class="lineNum">     317 </span>            :   8363841, 8940161, 9545769, 10181641, 10848769, 11548161, 12280841, 13047849,
<span class="lineNum">     318 </span>            :   13850241, 14689089, 15565481, 16480521, 17435329, 18431041, 19468809,
<span class="lineNum">     319 </span>            :   20549801, 21675201, 22846209, 24064041, 25329929, 26645121, 28010881,
<span class="lineNum">     320 </span>            :   29428489, 30899241, 32424449, 34005441, 35643561, 37340169, 39096641,
<span class="lineNum">     321 </span>            :   40914369, 42794761, 44739241, 46749249, 48826241, 50971689, 53187081,
<span class="lineNum">     322 </span>            :   55473921, 57833729, 60268041, 62778409, 65366401, 68033601, 70781609,
<span class="lineNum">     323 </span>            :   73612041, 76526529, 79526721, 82614281, 85790889, 89058241, 92418049,
<span class="lineNum">     324 </span>            :   95872041, 99421961, 103069569, 106816641, 110664969, 114616361, 118672641,
<span class="lineNum">     325 </span>            :   122835649, 127107241, 131489289, 135983681, 140592321, 145317129, 150160041,
<span class="lineNum">     326 </span>            :   155123009, 160208001, 165417001, 170752009, 176215041, 181808129, 187533321,
<span class="lineNum">     327 </span>            :   193392681, 199388289, 205522241, 211796649, 218213641, 224775361, 231483969,
<span class="lineNum">     328 </span>            :   238341641, 245350569, 252512961, 259831041, 267307049, 274943241, 282741889,
<span class="lineNum">     329 </span>            :   290705281, 298835721, 307135529, 315607041, 324252609, 333074601, 342075401,
<span class="lineNum">     330 </span>            :   351257409, 360623041, 370174729, 379914921, 389846081, 399970689, 410291241,
<span class="lineNum">     331 </span>            :   420810249, 431530241, 442453761, 453583369, 464921641, 476471169, 488234561,
<span class="lineNum">     332 </span>            :   500214441, 512413449, 524834241, 537479489, 550351881, 563454121, 576788929,
<span class="lineNum">     333 </span>            :   590359041, 604167209, 618216201, 632508801,
<span class="lineNum">     334 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     335 </span>            :   /*...208:*/
<span class="lineNum">     336 </span>            :   647047809, 661836041, 676876329, 692171521, 707724481, 723538089, 739615241,
<span class="lineNum">     337 </span>            :   755958849, 772571841, 789457161, 806617769, 824056641, 841776769, 859781161,
<span class="lineNum">     338 </span>            :   878072841, 896654849, 915530241, 934702089, 954173481, 973947521, 994027329,
<span class="lineNum">     339 </span>            :   1014416041, 1035116809, 1056132801, 1077467201, 1099123209, 1121104041,
<span class="lineNum">     340 </span>            :   1143412929, 1166053121, 1189027881, 1212340489, 1235994241,
<span class="lineNum">     341 </span>            : #endif
<span class="lineNum">     342 </span>            :   /*N=6, K=6...96:*/
<span class="lineNum">     343 </span>            :   1683, 3653, 7183, 13073, 22363, 36365, 56695, 85305, 124515, 177045, 246047,
<span class="lineNum">     344 </span>            :   335137, 448427, 590557, 766727, 982729, 1244979, 1560549, 1937199, 2383409,
<span class="lineNum">     345 </span>            :   2908411, 3522221, 4235671, 5060441, 6009091, 7095093, 8332863, 9737793,
<span class="lineNum">     346 </span>            :   11326283, 13115773, 15124775, 17372905, 19880915, 22670725, 25765455,
<span class="lineNum">     347 </span>            :   29189457, 32968347, 37129037, 41699767, 46710137, 52191139, 58175189,
<span class="lineNum">     348 </span>            :   64696159, 71789409, 79491819, 87841821, 96879431, 106646281, 117185651,
<span class="lineNum">     349 </span>            :   128542501, 140763503, 153897073, 167993403, 183104493, 199284183, 216588185,
<span class="lineNum">     350 </span>            :   235074115, 254801525, 275831935, 298228865, 322057867, 347386557, 374284647,
<span class="lineNum">     351 </span>            :   402823977, 433078547, 465124549, 499040399, 534906769, 572806619, 612825229,
<span class="lineNum">     352 </span>            :   655050231, 699571641, 746481891, 795875861, 847850911, 902506913, 959946283,
<span class="lineNum">     353 </span>            :   1020274013, 1083597703, 1150027593, 1219676595, 1292660325, 1369097135,
<span class="lineNum">     354 </span>            :   1449108145, 1532817275, 1620351277, 1711839767, 1807415257, 1907213187,
<span class="lineNum">     355 </span>            :   2011371957, 2120032959,
<span class="lineNum">     356 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     357 </span>            :   /*...109:*/
<span class="lineNum">     358 </span>            :   2233340609U, 2351442379U, 2474488829U, 2602633639U, 2736033641U, 2874848851U,
<span class="lineNum">     359 </span>            :   3019242501U, 3169381071U, 3325434321U, 3487575323U, 3655980493U, 3830829623U,
<span class="lineNum">     360 </span>            :   4012305913U,
<span class="lineNum">     361 </span>            : #endif
<span class="lineNum">     362 </span>            :   /*N=7, K=7...54*/
<span class="lineNum">     363 </span>            :   8989, 19825, 40081, 75517, 134245, 227305, 369305, 579125, 880685, 1303777,
<span class="lineNum">     364 </span>            :   1884961, 2668525, 3707509, 5064793, 6814249, 9041957, 11847485, 15345233,
<span class="lineNum">     365 </span>            :   19665841, 24957661, 31388293, 39146185, 48442297, 59511829, 72616013,
<span class="lineNum">     366 </span>            :   88043969, 106114625, 127178701, 151620757, 179861305, 212358985, 249612805,
<span class="lineNum">     367 </span>            :   292164445, 340600625, 395555537, 457713341, 527810725, 606639529, 695049433,
<span class="lineNum">     368 </span>            :   793950709, 904317037, 1027188385, 1163673953, 1314955181, 1482288821,
<span class="lineNum">     369 </span>            :   1667010073, 1870535785, 2094367717,
<span class="lineNum">     370 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     371 </span>            :   /*...60:*/
<span class="lineNum">     372 </span>            :   2340095869U, 2609401873U, 2904062449U, 3225952925U, 3577050821U, 3959439497U,
<span class="lineNum">     373 </span>            : #endif
<span class="lineNum">     374 </span>            :   /*N=8, K=8...37*/
<span class="lineNum">     375 </span>            :   48639, 108545, 224143, 433905, 795455, 1392065, 2340495, 3800305, 5984767,
<span class="lineNum">     376 </span>            :   9173505, 13726991, 20103025, 28875327, 40754369, 56610575, 77500017,
<span class="lineNum">     377 </span>            :   104692735, 139703809, 184327311, 240673265, 311207743, 398796225, 506750351,
<span class="lineNum">     378 </span>            :   638878193, 799538175, 993696769, 1226990095, 1505789553, 1837271615,
<span class="lineNum">     379 </span>            :   2229491905U,
<span class="lineNum">     380 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     381 </span>            :   /*...40:*/
<span class="lineNum">     382 </span>            :   2691463695U, 3233240945U, 3866006015U,
<span class="lineNum">     383 </span>            : #endif
<span class="lineNum">     384 </span>            :   /*N=9, K=9...28:*/
<span class="lineNum">     385 </span>            :   265729, 598417, 1256465, 2485825, 4673345, 8405905, 14546705, 24331777,
<span class="lineNum">     386 </span>            :   39490049, 62390545, 96220561, 145198913, 214828609, 312193553, 446304145,
<span class="lineNum">     387 </span>            :   628496897, 872893441, 1196924561, 1621925137, 2173806145U,
<span class="lineNum">     388 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     389 </span>            :   /*...29:*/
<span class="lineNum">     390 </span>            :   2883810113U,
<span class="lineNum">     391 </span>            : #endif
<span class="lineNum">     392 </span>            :   /*N=10, K=10...24:*/
<span class="lineNum">     393 </span>            :   1462563, 3317445, 7059735, 14218905, 27298155, 50250765, 89129247, 152951073,
<span class="lineNum">     394 </span>            :   254831667, 413442773, 654862247, 1014889769, 1541911931, 2300409629U,
<span class="lineNum">     395 </span>            :   3375210671U,
<span class="lineNum">     396 </span>            :   /*N=11, K=11...19:*/
<span class="lineNum">     397 </span>            :   8097453, 18474633, 39753273, 81270333, 158819253, 298199265, 540279585,
<span class="lineNum">     398 </span>            :   948062325, 1616336765,
<span class="lineNum">     399 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     400 </span>            :   /*...20:*/
<span class="lineNum">     401 </span>            :   2684641785U,
<span class="lineNum">     402 </span>            : #endif
<span class="lineNum">     403 </span>            :   /*N=12, K=12...18:*/
<span class="lineNum">     404 </span>            :   45046719, 103274625, 224298231, 464387817, 921406335, 1759885185,
<span class="lineNum">     405 </span>            :   3248227095U,
<span class="lineNum">     406 </span>            :   /*N=13, K=13...16:*/
<span class="lineNum">     407 </span>            :   251595969, 579168825, 1267854873, 2653649025U,
<span class="lineNum">     408 </span>            :   /*N=14, K=14:*/
<span class="lineNum">     409 </span>            :   1409933619
<span class="lineNum">     410 </span>            : };
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     413 </span>            : static const opus_uint32 *const CELT_PVQ_U_ROW[15]={
<span class="lineNum">     414 </span>            :   CELT_PVQ_U_DATA+   0,CELT_PVQ_U_DATA+ 208,CELT_PVQ_U_DATA+ 415,
<span class="lineNum">     415 </span>            :   CELT_PVQ_U_DATA+ 621,CELT_PVQ_U_DATA+ 826,CELT_PVQ_U_DATA+1030,
<span class="lineNum">     416 </span>            :   CELT_PVQ_U_DATA+1233,CELT_PVQ_U_DATA+1336,CELT_PVQ_U_DATA+1389,
<span class="lineNum">     417 </span>            :   CELT_PVQ_U_DATA+1421,CELT_PVQ_U_DATA+1441,CELT_PVQ_U_DATA+1455,
<span class="lineNum">     418 </span>            :   CELT_PVQ_U_DATA+1464,CELT_PVQ_U_DATA+1470,CELT_PVQ_U_DATA+1473
<span class="lineNum">     419 </span>            : };
<span class="lineNum">     420 </span>            : #else
<span class="lineNum">     421 </span>            : static const opus_uint32 *const CELT_PVQ_U_ROW[15]={
<span class="lineNum">     422 </span>            :   CELT_PVQ_U_DATA+   0,CELT_PVQ_U_DATA+ 176,CELT_PVQ_U_DATA+ 351,
<span class="lineNum">     423 </span>            :   CELT_PVQ_U_DATA+ 525,CELT_PVQ_U_DATA+ 698,CELT_PVQ_U_DATA+ 870,
<span class="lineNum">     424 </span>            :   CELT_PVQ_U_DATA+1041,CELT_PVQ_U_DATA+1131,CELT_PVQ_U_DATA+1178,
<span class="lineNum">     425 </span>            :   CELT_PVQ_U_DATA+1207,CELT_PVQ_U_DATA+1226,CELT_PVQ_U_DATA+1240,
<span class="lineNum">     426 </span>            :   CELT_PVQ_U_DATA+1248,CELT_PVQ_U_DATA+1254,CELT_PVQ_U_DATA+1257
<span class="lineNum">     427 </span>            : };
<span class="lineNum">     428 </span>            : #endif
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : #if defined(CUSTOM_MODES)
<span class="lineNum">     431 </span>            : void get_required_bits(opus_int16 *_bits,int _n,int _maxk,int _frac){
<span class="lineNum">     432 </span>            :   int k;
<span class="lineNum">     433 </span>            :   /*_maxk==0 =&gt; there's nothing to do.*/
<span class="lineNum">     434 </span>            :   celt_assert(_maxk&gt;0);
<span class="lineNum">     435 </span>            :   _bits[0]=0;
<span class="lineNum">     436 </span>            :   for(k=1;k&lt;=_maxk;k++)_bits[k]=log2_frac(CELT_PVQ_V(_n,k),_frac);
<span class="lineNum">     437 </span>            : }
<a name="438"><span class="lineNum">     438 </span>            : #endif</a>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 : static opus_uint32 icwrs(int _n,const int *_y){</span>
<span class="lineNum">     441 </span>            :   opus_uint32 i;
<span class="lineNum">     442 </span>            :   int         j;
<span class="lineNum">     443 </span>            :   int         k;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   celt_assert(_n&gt;=2);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   j=_n-1;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   i=_y[j]&lt;0;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   k=abs(_y[j]);</span>
<span class="lineNum">     448 </span>            :   do{
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     j--;</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     i+=CELT_PVQ_U(_n-j,k);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     k+=abs(_y[j]);</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     if(_y[j]&lt;0)i+=CELT_PVQ_U(_n-j,k+1);</span>
<span class="lineNum">     453 </span>            :   }
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   while(j&gt;0);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   return i;</span>
<a name="456"><span class="lineNum">     456 </span>            : }</a>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 : void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   celt_assert(_k&gt;0);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   ec_enc_uint(_enc,icwrs(_n,_y),CELT_PVQ_V(_n,_k));</span>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 : static opus_val32 cwrsi(int _n,int _k,opus_uint32 _i,int *_y){</span>
<span class="lineNum">     464 </span>            :   opus_uint32 p;
<span class="lineNum">     465 </span>            :   int         s;
<span class="lineNum">     466 </span>            :   int         k0;
<span class="lineNum">     467 </span>            :   opus_int16  val;
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   opus_val32  yy=0;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   celt_assert(_k&gt;0);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   celt_assert(_n&gt;1);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   while(_n&gt;2){</span>
<span class="lineNum">     472 </span>            :     opus_uint32 q;
<span class="lineNum">     473 </span>            :     /*Lots of pulses case:*/
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     if(_k&gt;=_n){</span>
<span class="lineNum">     475 </span>            :       const opus_uint32 *row;
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       row=CELT_PVQ_U_ROW[_n];</span>
<span class="lineNum">     477 </span>            :       /*Are the pulses in this dimension negative?*/
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       p=row[_k+1];</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       s=-(_i&gt;=p);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       _i-=p&amp;s;</span>
<span class="lineNum">     481 </span>            :       /*Count how many pulses were placed in this dimension.*/
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       k0=_k;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       q=row[_n];</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       if(q&gt;_i){</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :         celt_assert(p&gt;q);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         _k=_n;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         do p=CELT_PVQ_U_ROW[--_k][_n];</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         while(p&gt;_i);</span>
<span class="lineNum">     489 </span>            :       }
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       else for(p=row[_k];p&gt;_i;p=row[_k])_k--;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       _i-=p;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :       val=(k0-_k+s)^s;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       *_y++=val;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :       yy=MAC16_16(yy,val,val);</span>
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span>            :     /*Lots of dimensions case:*/
<span class="lineNum">     497 </span>            :     else{
<span class="lineNum">     498 </span>            :       /*Are there any pulses in this dimension at all?*/
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       p=CELT_PVQ_U_ROW[_k][_n];</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :       q=CELT_PVQ_U_ROW[_k+1][_n];</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :       if(p&lt;=_i&amp;&amp;_i&lt;q){</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         _i-=p;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         *_y++=0;</span>
<span class="lineNum">     504 </span>            :       }
<span class="lineNum">     505 </span>            :       else{
<span class="lineNum">     506 </span>            :         /*Are the pulses in this dimension negative?*/
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         s=-(_i&gt;=q);</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :         _i-=q&amp;s;</span>
<span class="lineNum">     509 </span>            :         /*Count how many pulses were placed in this dimension.*/
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         k0=_k;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         do p=CELT_PVQ_U_ROW[--_k][_n];</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         while(p&gt;_i);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         _i-=p;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         val=(k0-_k+s)^s;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         *_y++=val;</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         yy=MAC16_16(yy,val,val);</span>
<span class="lineNum">     517 </span>            :       }
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     _n--;</span>
<span class="lineNum">     520 </span>            :   }
<span class="lineNum">     521 </span>            :   /*_n==2*/
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   p=2*_k+1;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   s=-(_i&gt;=p);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   _i-=p&amp;s;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   k0=_k;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   _k=(_i+1)&gt;&gt;1;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   if(_k)_i-=2*_k-1;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   val=(k0-_k+s)^s;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   *_y++=val;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   yy=MAC16_16(yy,val,val);</span>
<span class="lineNum">     531 </span>            :   /*_n==1*/
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   s=-(int)_i;</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   val=(_k+s)^s;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   *_y=val;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   yy=MAC16_16(yy,val,val);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   return yy;</span>
<a name="537"><span class="lineNum">     537 </span>            : }</a>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 : opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   return cwrsi(_n,_k,ec_dec_uint(_dec,CELT_PVQ_V(_n,_k)),_y);</span>
<span class="lineNum">     541 </span>            : }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : #else /* SMALL_FOOTPRINT */
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : /*Computes the next row/column of any recurrence that obeys the relation
<span class="lineNum">     546 </span>            :    u[i][j]=u[i-1][j]+u[i][j-1]+u[i-1][j-1].
<span class="lineNum">     547 </span>            :   _ui0 is the base case for the new row/column.*/
<span class="lineNum">     548 </span>            : static OPUS_INLINE void unext(opus_uint32 *_ui,unsigned _len,opus_uint32 _ui0){
<span class="lineNum">     549 </span>            :   opus_uint32 ui1;
<span class="lineNum">     550 </span>            :   unsigned      j;
<span class="lineNum">     551 </span>            :   /*This do-while will overrun the array if we don't have storage for at least
<span class="lineNum">     552 </span>            :      2 values.*/
<span class="lineNum">     553 </span>            :   j=1; do {
<span class="lineNum">     554 </span>            :     ui1=UADD32(UADD32(_ui[j],_ui[j-1]),_ui0);
<span class="lineNum">     555 </span>            :     _ui[j-1]=_ui0;
<span class="lineNum">     556 </span>            :     _ui0=ui1;
<span class="lineNum">     557 </span>            :   } while (++j&lt;_len);
<span class="lineNum">     558 </span>            :   _ui[j-1]=_ui0;
<span class="lineNum">     559 </span>            : }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /*Computes the previous row/column of any recurrence that obeys the relation
<span class="lineNum">     562 </span>            :    u[i-1][j]=u[i][j]-u[i][j-1]-u[i-1][j-1].
<span class="lineNum">     563 </span>            :   _ui0 is the base case for the new row/column.*/
<span class="lineNum">     564 </span>            : static OPUS_INLINE void uprev(opus_uint32 *_ui,unsigned _n,opus_uint32 _ui0){
<span class="lineNum">     565 </span>            :   opus_uint32 ui1;
<span class="lineNum">     566 </span>            :   unsigned      j;
<span class="lineNum">     567 </span>            :   /*This do-while will overrun the array if we don't have storage for at least
<span class="lineNum">     568 </span>            :      2 values.*/
<span class="lineNum">     569 </span>            :   j=1; do {
<span class="lineNum">     570 </span>            :     ui1=USUB32(USUB32(_ui[j],_ui[j-1]),_ui0);
<span class="lineNum">     571 </span>            :     _ui[j-1]=_ui0;
<span class="lineNum">     572 </span>            :     _ui0=ui1;
<span class="lineNum">     573 </span>            :   } while (++j&lt;_n);
<span class="lineNum">     574 </span>            :   _ui[j-1]=_ui0;
<span class="lineNum">     575 </span>            : }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : /*Compute V(_n,_k), as well as U(_n,0..._k+1).
<span class="lineNum">     578 </span>            :   _u: On exit, _u[i] contains U(_n,i) for i in [0..._k+1].*/
<span class="lineNum">     579 </span>            : static opus_uint32 ncwrs_urow(unsigned _n,unsigned _k,opus_uint32 *_u){
<span class="lineNum">     580 </span>            :   opus_uint32 um2;
<span class="lineNum">     581 </span>            :   unsigned      len;
<span class="lineNum">     582 </span>            :   unsigned      k;
<span class="lineNum">     583 </span>            :   len=_k+2;
<span class="lineNum">     584 </span>            :   /*We require storage at least 3 values (e.g., _k&gt;0).*/
<span class="lineNum">     585 </span>            :   celt_assert(len&gt;=3);
<span class="lineNum">     586 </span>            :   _u[0]=0;
<span class="lineNum">     587 </span>            :   _u[1]=um2=1;
<span class="lineNum">     588 </span>            :   /*If _n==0, _u[0] should be 1 and the rest should be 0.*/
<span class="lineNum">     589 </span>            :   /*If _n==1, _u[i] should be 1 for i&gt;1.*/
<span class="lineNum">     590 </span>            :   celt_assert(_n&gt;=2);
<span class="lineNum">     591 </span>            :   /*If _k==0, the following do-while loop will overflow the buffer.*/
<span class="lineNum">     592 </span>            :   celt_assert(_k&gt;0);
<span class="lineNum">     593 </span>            :   k=2;
<span class="lineNum">     594 </span>            :   do _u[k]=(k&lt;&lt;1)-1;
<span class="lineNum">     595 </span>            :   while(++k&lt;len);
<span class="lineNum">     596 </span>            :   for(k=2;k&lt;_n;k++)unext(_u+1,_k+1,1);
<span class="lineNum">     597 </span>            :   return _u[_k]+_u[_k+1];
<span class="lineNum">     598 </span>            : }
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            : /*Returns the _i'th combination of _k elements chosen from a set of size _n
<span class="lineNum">     601 </span>            :    with associated sign bits.
<span class="lineNum">     602 </span>            :   _y: Returns the vector of pulses.
<span class="lineNum">     603 </span>            :   _u: Must contain entries [0..._k+1] of row _n of U() on input.
<span class="lineNum">     604 </span>            :       Its contents will be destructively modified.*/
<span class="lineNum">     605 </span>            : static opus_val32 cwrsi(int _n,int _k,opus_uint32 _i,int *_y,opus_uint32 *_u){
<span class="lineNum">     606 </span>            :   int j;
<span class="lineNum">     607 </span>            :   opus_int16 val;
<span class="lineNum">     608 </span>            :   opus_val32 yy=0;
<span class="lineNum">     609 </span>            :   celt_assert(_n&gt;0);
<span class="lineNum">     610 </span>            :   j=0;
<span class="lineNum">     611 </span>            :   do{
<span class="lineNum">     612 </span>            :     opus_uint32 p;
<span class="lineNum">     613 </span>            :     int           s;
<span class="lineNum">     614 </span>            :     int           yj;
<span class="lineNum">     615 </span>            :     p=_u[_k+1];
<span class="lineNum">     616 </span>            :     s=-(_i&gt;=p);
<span class="lineNum">     617 </span>            :     _i-=p&amp;s;
<span class="lineNum">     618 </span>            :     yj=_k;
<span class="lineNum">     619 </span>            :     p=_u[_k];
<span class="lineNum">     620 </span>            :     while(p&gt;_i)p=_u[--_k];
<span class="lineNum">     621 </span>            :     _i-=p;
<span class="lineNum">     622 </span>            :     yj-=_k;
<span class="lineNum">     623 </span>            :     val=(yj+s)^s;
<span class="lineNum">     624 </span>            :     _y[j]=val;
<span class="lineNum">     625 </span>            :     yy=MAC16_16(yy,val,val);
<span class="lineNum">     626 </span>            :     uprev(_u,_k+2,0);
<span class="lineNum">     627 </span>            :   }
<span class="lineNum">     628 </span>            :   while(++j&lt;_n);
<span class="lineNum">     629 </span>            :   return yy;
<span class="lineNum">     630 </span>            : }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : /*Returns the index of the given combination of K elements chosen from a set
<span class="lineNum">     633 </span>            :    of size 1 with associated sign bits.
<span class="lineNum">     634 </span>            :   _y: The vector of pulses, whose sum of absolute values is K.
<span class="lineNum">     635 </span>            :   _k: Returns K.*/
<span class="lineNum">     636 </span>            : static OPUS_INLINE opus_uint32 icwrs1(const int *_y,int *_k){
<span class="lineNum">     637 </span>            :   *_k=abs(_y[0]);
<span class="lineNum">     638 </span>            :   return _y[0]&lt;0;
<span class="lineNum">     639 </span>            : }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : /*Returns the index of the given combination of K elements chosen from a set
<span class="lineNum">     642 </span>            :    of size _n with associated sign bits.
<span class="lineNum">     643 </span>            :   _y:  The vector of pulses, whose sum of absolute values must be _k.
<span class="lineNum">     644 </span>            :   _nc: Returns V(_n,_k).*/
<span class="lineNum">     645 </span>            : static OPUS_INLINE opus_uint32 icwrs(int _n,int _k,opus_uint32 *_nc,const int *_y,
<span class="lineNum">     646 </span>            :  opus_uint32 *_u){
<span class="lineNum">     647 </span>            :   opus_uint32 i;
<span class="lineNum">     648 </span>            :   int         j;
<span class="lineNum">     649 </span>            :   int         k;
<span class="lineNum">     650 </span>            :   /*We can't unroll the first two iterations of the loop unless _n&gt;=2.*/
<span class="lineNum">     651 </span>            :   celt_assert(_n&gt;=2);
<span class="lineNum">     652 </span>            :   _u[0]=0;
<span class="lineNum">     653 </span>            :   for(k=1;k&lt;=_k+1;k++)_u[k]=(k&lt;&lt;1)-1;
<span class="lineNum">     654 </span>            :   i=icwrs1(_y+_n-1,&amp;k);
<span class="lineNum">     655 </span>            :   j=_n-2;
<span class="lineNum">     656 </span>            :   i+=_u[k];
<span class="lineNum">     657 </span>            :   k+=abs(_y[j]);
<span class="lineNum">     658 </span>            :   if(_y[j]&lt;0)i+=_u[k+1];
<span class="lineNum">     659 </span>            :   while(j--&gt;0){
<span class="lineNum">     660 </span>            :     unext(_u,_k+2,0);
<span class="lineNum">     661 </span>            :     i+=_u[k];
<span class="lineNum">     662 </span>            :     k+=abs(_y[j]);
<span class="lineNum">     663 </span>            :     if(_y[j]&lt;0)i+=_u[k+1];
<span class="lineNum">     664 </span>            :   }
<span class="lineNum">     665 </span>            :   *_nc=_u[k]+_u[k+1];
<span class="lineNum">     666 </span>            :   return i;
<span class="lineNum">     667 </span>            : }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            : #ifdef CUSTOM_MODES
<span class="lineNum">     670 </span>            : void get_required_bits(opus_int16 *_bits,int _n,int _maxk,int _frac){
<span class="lineNum">     671 </span>            :   int k;
<span class="lineNum">     672 </span>            :   /*_maxk==0 =&gt; there's nothing to do.*/
<span class="lineNum">     673 </span>            :   celt_assert(_maxk&gt;0);
<span class="lineNum">     674 </span>            :   _bits[0]=0;
<span class="lineNum">     675 </span>            :   if (_n==1)
<span class="lineNum">     676 </span>            :   {
<span class="lineNum">     677 </span>            :     for (k=1;k&lt;=_maxk;k++)
<span class="lineNum">     678 </span>            :       _bits[k] = 1&lt;&lt;_frac;
<span class="lineNum">     679 </span>            :   }
<span class="lineNum">     680 </span>            :   else {
<span class="lineNum">     681 </span>            :     VARDECL(opus_uint32,u);
<span class="lineNum">     682 </span>            :     SAVE_STACK;
<span class="lineNum">     683 </span>            :     ALLOC(u,_maxk+2U,opus_uint32);
<span class="lineNum">     684 </span>            :     ncwrs_urow(_n,_maxk,u);
<span class="lineNum">     685 </span>            :     for(k=1;k&lt;=_maxk;k++)
<span class="lineNum">     686 </span>            :       _bits[k]=log2_frac(u[k]+u[k+1],_frac);
<span class="lineNum">     687 </span>            :     RESTORE_STACK;
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            : }
<span class="lineNum">     690 </span>            : #endif /* CUSTOM_MODES */
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            : void encode_pulses(const int *_y,int _n,int _k,ec_enc *_enc){
<span class="lineNum">     693 </span>            :   opus_uint32 i;
<span class="lineNum">     694 </span>            :   VARDECL(opus_uint32,u);
<span class="lineNum">     695 </span>            :   opus_uint32 nc;
<span class="lineNum">     696 </span>            :   SAVE_STACK;
<span class="lineNum">     697 </span>            :   celt_assert(_k&gt;0);
<span class="lineNum">     698 </span>            :   ALLOC(u,_k+2U,opus_uint32);
<span class="lineNum">     699 </span>            :   i=icwrs(_n,_k,&amp;nc,_y,u);
<span class="lineNum">     700 </span>            :   ec_enc_uint(_enc,i,nc);
<span class="lineNum">     701 </span>            :   RESTORE_STACK;
<span class="lineNum">     702 </span>            : }
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : opus_val32 decode_pulses(int *_y,int _n,int _k,ec_dec *_dec){
<span class="lineNum">     705 </span>            :   VARDECL(opus_uint32,u);
<span class="lineNum">     706 </span>            :   int ret;
<span class="lineNum">     707 </span>            :   SAVE_STACK;
<span class="lineNum">     708 </span>            :   celt_assert(_k&gt;0);
<span class="lineNum">     709 </span>            :   ALLOC(u,_k+2U,opus_uint32);
<span class="lineNum">     710 </span>            :   ret = cwrsi(_n,_k,ec_dec_uint(_dec,ncwrs_urow(_n,_k,u)),_y,u);
<span class="lineNum">     711 </span>            :   RESTORE_STACK;
<span class="lineNum">     712 </span>            :   return ret;
<span class="lineNum">     713 </span>            : }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : #endif /* SMALL_FOOTPRINT */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libopus/celt/vq.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/libopus/celt</a> - vq.c<span style="font-size: 80%;"> (source / <a href="vq.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">164</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (c) 2007-2008 CSIRO</a>
<span class="lineNum">       2 </span>            :    Copyright (c) 2007-2009 Xiph.Org Foundation
<span class="lineNum">       3 </span>            :    Written by Jean-Marc Valin */
<span class="lineNum">       4 </span>            : /*
<span class="lineNum">       5 </span>            :    Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            :    modification, are permitted provided that the following conditions
<span class="lineNum">       7 </span>            :    are met:
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    - Redistributions of source code must retain the above copyright
<span class="lineNum">      10 </span>            :    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            :    - Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      13 </span>            :    notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      14 </span>            :    documentation and/or other materials provided with the distribution.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      17 </span>            :    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      18 </span>            :    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      19 </span>            :    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
<span class="lineNum">      20 </span>            :    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<span class="lineNum">      21 </span>            :    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      22 </span>            :    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span class="lineNum">      23 </span>            :    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span class="lineNum">      24 </span>            :    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span class="lineNum">      25 </span>            :    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span class="lineNum">      26 </span>            :    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      27 </span>            : */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #ifdef HAVE_CONFIG_H
<span class="lineNum">      30 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      31 </span>            : #endif
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &quot;mathops.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;cwrs.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;vq.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;arch.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;os_support.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;bands.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;rate.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;pitch.h&quot;
<a name="41"><span class="lineNum">      41 </span>            : </a>
<span class="lineNum">      42 </span>            : #ifndef OVERRIDE_vq_exp_rotation1
<span class="lineNum">      43 </span><span class="lineNoCov">          0 : static void exp_rotation1(celt_norm *X, int len, int stride, opus_val16 c, opus_val16 s)</span>
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span>            :    int i;
<span class="lineNum">      46 </span>            :    opus_val16 ms;
<span class="lineNum">      47 </span>            :    celt_norm *Xptr;
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :    Xptr = X;</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :    ms = NEG16(s);</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :    for (i=0;i&lt;len-stride;i++)</span>
<span class="lineNum">      51 </span>            :    {
<span class="lineNum">      52 </span>            :       celt_norm x1, x2;
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :       x1 = Xptr[0];</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :       x2 = Xptr[stride];</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :       Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :       *Xptr++      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));</span>
<span class="lineNum">      57 </span>            :    }
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :    Xptr = &amp;X[len-2*stride-1];</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :    for (i=len-2*stride-1;i&gt;=0;i--)</span>
<span class="lineNum">      60 </span>            :    {
<span class="lineNum">      61 </span>            :       celt_norm x1, x2;
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :       x1 = Xptr[0];</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :       x2 = Xptr[stride];</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :       Xptr[stride] = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x2),  s, x1), 15));</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :       *Xptr--      = EXTRACT16(PSHR32(MAC16_16(MULT16_16(c, x1), ms, x2), 15));</span>
<span class="lineNum">      66 </span>            :    }
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : }</span>
<a name="68"><span class="lineNum">      68 </span>            : #endif /* OVERRIDE_vq_exp_rotation1 */</a>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 : void exp_rotation(celt_norm *X, int len, int dir, int stride, int K, int spread)</span>
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span>            :    static const int SPREAD_FACTOR[3]={15,10,5};
<span class="lineNum">      73 </span>            :    int i;
<span class="lineNum">      74 </span>            :    opus_val16 c, s;
<span class="lineNum">      75 </span>            :    opus_val16 gain, theta;
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :    int stride2=0;</span>
<span class="lineNum">      77 </span>            :    int factor;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :    if (2*K&gt;=len || spread==SPREAD_NONE)</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :    factor = SPREAD_FACTOR[spread-1];</span>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :    gain = celt_div((opus_val32)MULT16_16(Q15_ONE,len),(opus_val32)(len+factor*K));</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :    theta = HALF16(MULT16_16_Q15(gain,gain));</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :    c = celt_cos_norm(EXTEND32(theta));</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :    s = celt_cos_norm(EXTEND32(SUB16(Q15ONE,theta))); /*  sin(theta) */</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :    if (len&gt;=8*stride)</span>
<span class="lineNum">      90 </span>            :    {
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :       stride2 = 1;</span>
<span class="lineNum">      92 </span>            :       /* This is just a simple (equivalent) way of computing sqrt(len/stride) with rounding.
<span class="lineNum">      93 </span>            :          It's basically incrementing long as (stride2+0.5)^2 &lt; len/stride. */
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :       while ((stride2*stride2+stride2)*stride + (stride&gt;&gt;2) &lt; len)</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :          stride2++;</span>
<span class="lineNum">      96 </span>            :    }
<span class="lineNum">      97 </span>            :    /*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
<span class="lineNum">      98 </span>            :       extract_collapse_mask().*/
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :    len = celt_udiv(len, stride);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :    for (i=0;i&lt;stride;i++)</span>
<span class="lineNum">     101 </span>            :    {
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :       if (dir &lt; 0)</span>
<span class="lineNum">     103 </span>            :       {
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :          if (stride2)</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :             exp_rotation1(X+i*len, len, stride2, s, c);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :          exp_rotation1(X+i*len, len, 1, c, s);</span>
<span class="lineNum">     107 </span>            :       } else {
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :          exp_rotation1(X+i*len, len, 1, c, -s);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :          if (stride2)</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :             exp_rotation1(X+i*len, len, stride2, s, -c);</span>
<span class="lineNum">     111 </span>            :       }
<span class="lineNum">     112 </span>            :    }
<span class="lineNum">     113 </span>            : }
<span class="lineNum">     114 </span>            : 
<a name="115"><span class="lineNum">     115 </span>            : /** Takes the pitch vector and the decoded residual vector, computes the gain</a>
<span class="lineNum">     116 </span>            :     that will give ||p+g*y||=1 and mixes the residual with the pitch. */
<span class="lineNum">     117 </span><span class="lineNoCov">          0 : static void normalise_residual(int * OPUS_RESTRICT iy, celt_norm * OPUS_RESTRICT X,</span>
<span class="lineNum">     118 </span>            :       int N, opus_val32 Ryy, opus_val16 gain)
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span>            :    int i;
<span class="lineNum">     121 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     122 </span>            :    int k;
<span class="lineNum">     123 </span>            : #endif
<span class="lineNum">     124 </span>            :    opus_val32 t;
<span class="lineNum">     125 </span>            :    opus_val16 g;
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     128 </span>            :    k = celt_ilog2(Ryy)&gt;&gt;1;
<span class="lineNum">     129 </span>            : #endif
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :    t = VSHR32(Ryy, 2*(k-7));</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :    g = MULT16_16_P15(celt_rsqrt_norm(t),gain);</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :    i=0;</span>
<span class="lineNum">     134 </span>            :    do
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :       X[i] = EXTRACT16(PSHR32(MULT16_16(g, iy[i]), k+1));</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :    while (++i &lt; N);</span>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineNoCov">          0 : static unsigned extract_collapse_mask(int *iy, int N, int B)</span>
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span>            :    unsigned collapse_mask;
<span class="lineNum">     142 </span>            :    int N0;
<span class="lineNum">     143 </span>            :    int i;
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :    if (B&lt;=1)</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">     146 </span>            :    /*NOTE: As a minor optimization, we could be passing around log2(B), not B, for both this and for
<span class="lineNum">     147 </span>            :       exp_rotation().*/
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :    N0 = celt_udiv(N, B);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :    collapse_mask = 0;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :    i=0; do {</span>
<span class="lineNum">     151 </span>            :       int j;
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :       unsigned tmp=0;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :       j=0; do {</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :          tmp |= iy[i*N0+j];</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :       } while (++j&lt;N0);</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       collapse_mask |= (tmp!=0)&lt;&lt;i;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :    } while (++i&lt;B);</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :    return collapse_mask;</span>
<a name="159"><span class="lineNum">     159 </span>            : }</a>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : opus_val16 op_pvq_search_c(celt_norm *X, int *iy, int K, int N, int arch)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span>            :    VARDECL(celt_norm, y);
<span class="lineNum">     164 </span>            :    VARDECL(int, signx);
<span class="lineNum">     165 </span>            :    int i, j;
<span class="lineNum">     166 </span>            :    int pulsesLeft;
<span class="lineNum">     167 </span>            :    opus_val32 sum;
<span class="lineNum">     168 </span>            :    opus_val32 xy;
<span class="lineNum">     169 </span>            :    opus_val16 yy;
<span class="lineNum">     170 </span>            :    SAVE_STACK;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :    (void)arch;
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :    ALLOC(y, N, celt_norm);</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :    ALLOC(signx, N, int);</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :    /* Get rid of the sign */
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :    sum = 0;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :    j=0; do {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       signx[j] = X[j]&lt;0;</span>
<span class="lineNum">     180 </span>            :       /* OPT: Make sure the compiler doesn't use a branch on ABS16(). */
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       X[j] = ABS16(X[j]);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       iy[j] = 0;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       y[j] = 0;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :    } while (++j&lt;N);</span>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :    xy = yy = 0;</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :    pulsesLeft = K;</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :    /* Do a pre-search by projecting on the pyramid */
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :    if (K &gt; (N&gt;&gt;1))</span>
<span class="lineNum">     192 </span>            :    {
<span class="lineNum">     193 </span>            :       opus_val16 rcp;
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       j=0; do {</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :          sum += X[j];</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :       }  while (++j&lt;N);</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :       /* If X is too small, just replace it with a pulse at 0 */
<span class="lineNum">     199 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     200 </span>            :       if (sum &lt;= K)
<span class="lineNum">     201 </span>            : #else
<span class="lineNum">     202 </span>            :       /* Prevents infinities and NaNs from causing too many pulses
<span class="lineNum">     203 </span>            :          to be allocated. 64 is an approximation of infinity here. */
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :       if (!(sum &gt; EPSILON &amp;&amp; sum &lt; 64))</span>
<span class="lineNum">     205 </span>            : #endif
<span class="lineNum">     206 </span>            :       {
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :          X[0] = QCONST16(1.f,14);</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :          j=1; do</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             X[j]=0;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :          while (++j&lt;N);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :          sum = QCONST16(1.f,14);</span>
<span class="lineNum">     212 </span>            :       }
<span class="lineNum">     213 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     214 </span>            :       rcp = EXTRACT16(MULT16_32_Q16(K, celt_rcp(sum)));
<span class="lineNum">     215 </span>            : #else
<span class="lineNum">     216 </span>            :       /* Using K+e with e &lt; 1 guarantees we cannot get more than K pulses. */
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       rcp = EXTRACT16(MULT16_32_Q16(K+0.8f, celt_rcp(sum)));</span>
<span class="lineNum">     218 </span>            : #endif
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :       j=0; do {</span>
<span class="lineNum">     220 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     221 </span>            :          /* It's really important to round *towards zero* here */
<span class="lineNum">     222 </span>            :          iy[j] = MULT16_16_Q15(X[j],rcp);
<span class="lineNum">     223 </span>            : #else
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :          iy[j] = (int)floor(rcp*X[j]);</span>
<span class="lineNum">     225 </span>            : #endif
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :          y[j] = (celt_norm)iy[j];</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :          yy = MAC16_16(yy, y[j],y[j]);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :          xy = MAC16_16(xy, X[j],y[j]);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :          y[j] *= 2;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :          pulsesLeft -= iy[j];</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :       }  while (++j&lt;N);</span>
<span class="lineNum">     232 </span>            :    }
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :    celt_assert2(pulsesLeft&gt;=0, &quot;Allocated too many pulses in the quick pass&quot;);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :    /* This should never happen, but just in case it does (e.g. on silence)
<span class="lineNum">     236 </span>            :       we fill the first bin with pulses. */
<span class="lineNum">     237 </span>            : #ifdef FIXED_POINT_DEBUG
<span class="lineNum">     238 </span>            :    celt_assert2(pulsesLeft&lt;=N+3, &quot;Not enough pulses in the quick pass&quot;);
<span class="lineNum">     239 </span>            : #endif
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :    if (pulsesLeft &gt; N+3)</span>
<span class="lineNum">     241 </span>            :    {
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :       opus_val16 tmp = (opus_val16)pulsesLeft;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       yy = MAC16_16(yy, tmp, tmp);</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       yy = MAC16_16(yy, tmp, y[0]);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :       iy[0] += pulsesLeft;</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       pulsesLeft=0;</span>
<span class="lineNum">     247 </span>            :    }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :    for (i=0;i&lt;pulsesLeft;i++)</span>
<span class="lineNum">     250 </span>            :    {
<span class="lineNum">     251 </span>            :       opus_val16 Rxy, Ryy;
<span class="lineNum">     252 </span>            :       int best_id;
<span class="lineNum">     253 </span>            :       opus_val32 best_num;
<span class="lineNum">     254 </span>            :       opus_val16 best_den;
<span class="lineNum">     255 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     256 </span>            :       int rshift;
<span class="lineNum">     257 </span>            : #endif
<span class="lineNum">     258 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     259 </span>            :       rshift = 1+celt_ilog2(K-pulsesLeft+i+1);
<span class="lineNum">     260 </span>            : #endif
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :       best_id = 0;</span>
<span class="lineNum">     262 </span>            :       /* The squared magnitude term gets added anyway, so we might as well
<span class="lineNum">     263 </span>            :          add it outside the loop */
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       yy = ADD16(yy, 1);</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :       /* Calculations for position 0 are out of the loop, in part to reduce
<span class="lineNum">     267 </span>            :          mispredicted branches (since the if condition is usually false)
<span class="lineNum">     268 </span>            :          in the loop. */
<span class="lineNum">     269 </span>            :       /* Temporary sums of the new pulse(s) */
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[0])),rshift));</span>
<span class="lineNum">     271 </span>            :       /* We're multiplying y[j] by two so we don't have to do it here */
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       Ryy = ADD16(yy, y[0]);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :       /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
<span class="lineNum">     275 </span>            :          Rxy is positive because the sign is pre-computed) */
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       Rxy = MULT16_16_Q15(Rxy,Rxy);</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       best_den = Ryy;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       best_num = Rxy;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       j=1;</span>
<span class="lineNum">     280 </span>            :       do {
<span class="lineNum">     281 </span>            :          /* Temporary sums of the new pulse(s) */
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :          Rxy = EXTRACT16(SHR32(ADD32(xy, EXTEND32(X[j])),rshift));</span>
<span class="lineNum">     283 </span>            :          /* We're multiplying y[j] by two so we don't have to do it here */
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :          Ryy = ADD16(yy, y[j]);</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :          /* Approximate score: we maximise Rxy/sqrt(Ryy) (we're guaranteed that
<span class="lineNum">     287 </span>            :             Rxy is positive because the sign is pre-computed) */
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :          Rxy = MULT16_16_Q15(Rxy,Rxy);</span>
<span class="lineNum">     289 </span>            :          /* The idea is to check for num/den &gt;= best_num/best_den, but that way
<span class="lineNum">     290 </span>            :             we can do it without any division */
<span class="lineNum">     291 </span>            :          /* OPT: It's not clear whether a cmov is faster than a branch here
<span class="lineNum">     292 </span>            :             since the condition is more often false than true and using
<span class="lineNum">     293 </span>            :             a cmov introduces data dependencies across iterations. The optimal
<span class="lineNum">     294 </span>            :             choice may be architecture-dependent. */
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :          if (opus_unlikely(MULT16_16(best_den, Rxy) &gt; MULT16_16(Ryy, best_num)))</span>
<span class="lineNum">     296 </span>            :          {
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :             best_den = Ryy;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :             best_num = Rxy;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :             best_id = j;</span>
<span class="lineNum">     300 </span>            :          }
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       } while (++j&lt;N);</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :       /* Updating the sums of the new pulse(s) */
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :       xy = ADD32(xy, EXTEND32(X[best_id]));</span>
<span class="lineNum">     305 </span>            :       /* We're multiplying y[j] by two so we don't have to do it here */
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :       yy = ADD16(yy, y[best_id]);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :       /* Only now that we've made the final choice, update y/iy */
<span class="lineNum">     309 </span>            :       /* Multiplying y[j] by 2 so we don't have to do it everywhere else */
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       y[best_id] += 2;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :       iy[best_id]++;</span>
<span class="lineNum">     312 </span>            :    }
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :    /* Put the original sign back */
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :    j=0;</span>
<span class="lineNum">     316 </span>            :    do {
<span class="lineNum">     317 </span>            :       /*iy[j] = signx[j] ? -iy[j] : iy[j];*/
<span class="lineNum">     318 </span>            :       /* OPT: The is more likely to be compiled without a branch than the code above
<span class="lineNum">     319 </span>            :          but has the same performance otherwise. */
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       iy[j] = (iy[j]^-signx[j]) + signx[j];</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :    } while (++j&lt;N);</span>
<span class="lineNum">     322 </span>            :    RESTORE_STACK;
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :    return yy;</span>
<a name="324"><span class="lineNum">     324 </span>            : }</a>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 : unsigned alg_quant(celt_norm *X, int N, int K, int spread, int B, ec_enc *enc,</span>
<span class="lineNum">     327 </span>            :       opus_val16 gain, int resynth, int arch)
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :    VARDECL(int, iy);
<span class="lineNum">     330 </span>            :    opus_val16 yy;
<span class="lineNum">     331 </span>            :    unsigned collapse_mask;
<span class="lineNum">     332 </span>            :    SAVE_STACK;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :    celt_assert2(K&gt;0, &quot;alg_quant() needs at least one pulse&quot;);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :    celt_assert2(N&gt;1, &quot;alg_quant() needs at least two dimensions&quot;);</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :    /* Covers vectorization by up to 4. */
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :    ALLOC(iy, N+3, int);</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :    exp_rotation(X, N, 1, B, K, spread);</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :    yy = op_pvq_search(X, iy, K, N, arch);</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :    encode_pulses(iy, N, K, enc);</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :    if (resynth)</span>
<span class="lineNum">     347 </span>            :    {
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       normalise_residual(iy, X, N, yy, gain);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :       exp_rotation(X, N, -1, B, K, spread);</span>
<span class="lineNum">     350 </span>            :    }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :    collapse_mask = extract_collapse_mask(iy, N, B);</span>
<span class="lineNum">     353 </span>            :    RESTORE_STACK;
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :    return collapse_mask;</span>
<span class="lineNum">     355 </span>            : }
<span class="lineNum">     356 </span>            : 
<a name="357"><span class="lineNum">     357 </span>            : /** Decode pulse vector and combine the result with the pitch vector to produce</a>
<span class="lineNum">     358 </span>            :     the final normalised signal in the current band. */
<span class="lineNum">     359 </span><span class="lineNoCov">          0 : unsigned alg_unquant(celt_norm *X, int N, int K, int spread, int B,</span>
<span class="lineNum">     360 </span>            :       ec_dec *dec, opus_val16 gain)
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span>            :    opus_val32 Ryy;
<span class="lineNum">     363 </span>            :    unsigned collapse_mask;
<span class="lineNum">     364 </span>            :    VARDECL(int, iy);
<span class="lineNum">     365 </span>            :    SAVE_STACK;
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :    celt_assert2(K&gt;0, &quot;alg_unquant() needs at least one pulse&quot;);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :    celt_assert2(N&gt;1, &quot;alg_unquant() needs at least two dimensions&quot;);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :    ALLOC(iy, N, int);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :    Ryy = decode_pulses(iy, N, K, dec);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :    normalise_residual(iy, X, N, Ryy, gain);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :    exp_rotation(X, N, -1, B, K, spread);</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :    collapse_mask = extract_collapse_mask(iy, N, B);</span>
<span class="lineNum">     374 </span>            :    RESTORE_STACK;
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :    return collapse_mask;</span>
<span class="lineNum">     376 </span>            : }
<a name="377"><span class="lineNum">     377 </span>            : </a>
<span class="lineNum">     378 </span>            : #ifndef OVERRIDE_renormalise_vector
<span class="lineNum">     379 </span><span class="lineNoCov">          0 : void renormalise_vector(celt_norm *X, int N, opus_val16 gain, int arch)</span>
<span class="lineNum">     380 </span>            : {
<span class="lineNum">     381 </span>            :    int i;
<span class="lineNum">     382 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     383 </span>            :    int k;
<span class="lineNum">     384 </span>            : #endif
<span class="lineNum">     385 </span>            :    opus_val32 E;
<span class="lineNum">     386 </span>            :    opus_val16 g;
<span class="lineNum">     387 </span>            :    opus_val32 t;
<span class="lineNum">     388 </span>            :    celt_norm *xptr;
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :    E = EPSILON + celt_inner_prod(X, X, N, arch);</span>
<span class="lineNum">     390 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     391 </span>            :    k = celt_ilog2(E)&gt;&gt;1;
<span class="lineNum">     392 </span>            : #endif
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :    t = VSHR32(E, 2*(k-7));</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :    g = MULT16_16_P15(celt_rsqrt_norm(t),gain);</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :    xptr = X;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :    for (i=0;i&lt;N;i++)</span>
<span class="lineNum">     398 </span>            :    {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       *xptr = EXTRACT16(PSHR32(MULT16_16(g, *xptr), k+1));</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       xptr++;</span>
<span class="lineNum">     401 </span>            :    }
<span class="lineNum">     402 </span>            :    /*return celt_sqrt(E);*/
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : }</span>
<a name="404"><span class="lineNum">     404 </span>            : #endif /* OVERRIDE_renormalise_vector */</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 : int stereo_itheta(const celt_norm *X, const celt_norm *Y, int stereo, int N, int arch)</span>
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span>            :    int i;
<span class="lineNum">     409 </span>            :    int itheta;
<span class="lineNum">     410 </span>            :    opus_val16 mid, side;
<span class="lineNum">     411 </span>            :    opus_val32 Emid, Eside;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :    Emid = Eside = EPSILON;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :    if (stereo)</span>
<span class="lineNum">     415 </span>            :    {
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       for (i=0;i&lt;N;i++)</span>
<span class="lineNum">     417 </span>            :       {
<span class="lineNum">     418 </span>            :          celt_norm m, s;
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :          m = ADD16(SHR16(X[i],1),SHR16(Y[i],1));</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :          s = SUB16(SHR16(X[i],1),SHR16(Y[i],1));</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :          Emid = MAC16_16(Emid, m, m);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :          Eside = MAC16_16(Eside, s, s);</span>
<span class="lineNum">     423 </span>            :       }
<span class="lineNum">     424 </span>            :    } else {
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       Emid += celt_inner_prod(X, X, N, arch);</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :       Eside += celt_inner_prod(Y, Y, N, arch);</span>
<span class="lineNum">     427 </span>            :    }
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :    mid = celt_sqrt(Emid);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :    side = celt_sqrt(Eside);</span>
<span class="lineNum">     430 </span>            : #ifdef FIXED_POINT
<span class="lineNum">     431 </span>            :    /* 0.63662 = 2/pi */
<span class="lineNum">     432 </span>            :    itheta = MULT16_16_Q15(QCONST16(0.63662f,15),celt_atan2p(side, mid));
<span class="lineNum">     433 </span>            : #else
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :    itheta = (int)floor(.5f+16384*0.63662f*fast_atan2f(side,mid));</span>
<span class="lineNum">     435 </span>            : #endif
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :    return itheta;</span>
<span class="lineNum">     438 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

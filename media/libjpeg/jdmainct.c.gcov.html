<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libjpeg/jdmainct.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">media/libjpeg</a> - jdmainct.c<span style="font-size: 80%;"> (source / <a href="jdmainct.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">134</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * jdmainct.c
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This file was part of the Independent JPEG Group's software:
<span class="lineNum">       5 </span>            :  * Copyright (C) 1994-1996, Thomas G. Lane.
<span class="lineNum">       6 </span>            :  * libjpeg-turbo Modifications:
<span class="lineNum">       7 </span>            :  * Copyright (C) 2010, 2016, D. R. Commander.
<span class="lineNum">       8 </span>            :  * For conditions of distribution and use, see the accompanying README.ijg
<span class="lineNum">       9 </span>            :  * file.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * This file contains the main buffer controller for decompression.
<span class="lineNum">      12 </span>            :  * The main buffer lies between the JPEG decompressor proper and the
<span class="lineNum">      13 </span>            :  * post-processor; it holds downsampled data in the JPEG colorspace.
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  * Note that this code is bypassed in raw-data mode, since the application
<span class="lineNum">      16 </span>            :  * supplies the equivalent of the main buffer in that case.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;jinclude.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;jdmainct.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /*
<span class="lineNum">      24 </span>            :  * In the current system design, the main buffer need never be a full-image
<span class="lineNum">      25 </span>            :  * buffer; any full-height buffers will be found inside the coefficient or
<span class="lineNum">      26 </span>            :  * postprocessing controllers.  Nonetheless, the main controller is not
<span class="lineNum">      27 </span>            :  * trivial.  Its responsibility is to provide context rows for upsampling/
<span class="lineNum">      28 </span>            :  * rescaling, and doing this in an efficient fashion is a bit tricky.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * Postprocessor input data is counted in &quot;row groups&quot;.  A row group
<span class="lineNum">      31 </span>            :  * is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
<span class="lineNum">      32 </span>            :  * sample rows of each component.  (We require DCT_scaled_size values to be
<span class="lineNum">      33 </span>            :  * chosen such that these numbers are integers.  In practice DCT_scaled_size
<span class="lineNum">      34 </span>            :  * values will likely be powers of two, so we actually have the stronger
<span class="lineNum">      35 </span>            :  * condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
<span class="lineNum">      36 </span>            :  * Upsampling will typically produce max_v_samp_factor pixel rows from each
<span class="lineNum">      37 </span>            :  * row group (times any additional scale factor that the upsampler is
<span class="lineNum">      38 </span>            :  * applying).
<span class="lineNum">      39 </span>            :  *
<span class="lineNum">      40 </span>            :  * The coefficient controller will deliver data to us one iMCU row at a time;
<span class="lineNum">      41 </span>            :  * each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
<span class="lineNum">      42 </span>            :  * exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
<span class="lineNum">      43 </span>            :  * to one row of MCUs when the image is fully interleaved.)  Note that the
<span class="lineNum">      44 </span>            :  * number of sample rows varies across components, but the number of row
<span class="lineNum">      45 </span>            :  * groups does not.  Some garbage sample rows may be included in the last iMCU
<span class="lineNum">      46 </span>            :  * row at the bottom of the image.
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * Depending on the vertical scaling algorithm used, the upsampler may need
<span class="lineNum">      49 </span>            :  * access to the sample row(s) above and below its current input row group.
<span class="lineNum">      50 </span>            :  * The upsampler is required to set need_context_rows TRUE at global selection
<span class="lineNum">      51 </span>            :  * time if so.  When need_context_rows is FALSE, this controller can simply
<span class="lineNum">      52 </span>            :  * obtain one iMCU row at a time from the coefficient controller and dole it
<span class="lineNum">      53 </span>            :  * out as row groups to the postprocessor.
<span class="lineNum">      54 </span>            :  *
<span class="lineNum">      55 </span>            :  * When need_context_rows is TRUE, this controller guarantees that the buffer
<span class="lineNum">      56 </span>            :  * passed to postprocessing contains at least one row group's worth of samples
<span class="lineNum">      57 </span>            :  * above and below the row group(s) being processed.  Note that the context
<span class="lineNum">      58 </span>            :  * rows &quot;above&quot; the first passed row group appear at negative row offsets in
<span class="lineNum">      59 </span>            :  * the passed buffer.  At the top and bottom of the image, the required
<span class="lineNum">      60 </span>            :  * context rows are manufactured by duplicating the first or last real sample
<span class="lineNum">      61 </span>            :  * row; this avoids having special cases in the upsampling inner loops.
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  * The amount of context is fixed at one row group just because that's a
<span class="lineNum">      64 </span>            :  * convenient number for this controller to work with.  The existing
<span class="lineNum">      65 </span>            :  * upsamplers really only need one sample row of context.  An upsampler
<span class="lineNum">      66 </span>            :  * supporting arbitrary output rescaling might wish for more than one row
<span class="lineNum">      67 </span>            :  * group of context when shrinking the image; tough, we don't handle that.
<span class="lineNum">      68 </span>            :  * (This is justified by the assumption that downsizing will be handled mostly
<span class="lineNum">      69 </span>            :  * by adjusting the DCT_scaled_size values, so that the actual scale factor at
<span class="lineNum">      70 </span>            :  * the upsample step needn't be much less than one.)
<span class="lineNum">      71 </span>            :  *
<span class="lineNum">      72 </span>            :  * To provide the desired context, we have to retain the last two row groups
<span class="lineNum">      73 </span>            :  * of one iMCU row while reading in the next iMCU row.  (The last row group
<span class="lineNum">      74 </span>            :  * can't be processed until we have another row group for its below-context,
<span class="lineNum">      75 </span>            :  * and so we have to save the next-to-last group too for its above-context.)
<span class="lineNum">      76 </span>            :  * We could do this most simply by copying data around in our buffer, but
<span class="lineNum">      77 </span>            :  * that'd be very slow.  We can avoid copying any data by creating a rather
<span class="lineNum">      78 </span>            :  * strange pointer structure.  Here's how it works.  We allocate a workspace
<span class="lineNum">      79 </span>            :  * consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
<span class="lineNum">      80 </span>            :  * of row groups per iMCU row).  We create two sets of redundant pointers to
<span class="lineNum">      81 </span>            :  * the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
<span class="lineNum">      82 </span>            :  * pointer lists look like this:
<span class="lineNum">      83 </span>            :  *                   M+1                          M-1
<span class="lineNum">      84 </span>            :  * master pointer --&gt; 0         master pointer --&gt; 0
<span class="lineNum">      85 </span>            :  *                    1                            1
<span class="lineNum">      86 </span>            :  *                   ...                          ...
<span class="lineNum">      87 </span>            :  *                   M-3                          M-3
<span class="lineNum">      88 </span>            :  *                   M-2                           M
<span class="lineNum">      89 </span>            :  *                   M-1                          M+1
<span class="lineNum">      90 </span>            :  *                    M                           M-2
<span class="lineNum">      91 </span>            :  *                   M+1                          M-1
<span class="lineNum">      92 </span>            :  *                    0                            0
<span class="lineNum">      93 </span>            :  * We read alternate iMCU rows using each master pointer; thus the last two
<span class="lineNum">      94 </span>            :  * row groups of the previous iMCU row remain un-overwritten in the workspace.
<span class="lineNum">      95 </span>            :  * The pointer lists are set up so that the required context rows appear to
<span class="lineNum">      96 </span>            :  * be adjacent to the proper places when we pass the pointer lists to the
<span class="lineNum">      97 </span>            :  * upsampler.
<span class="lineNum">      98 </span>            :  *
<span class="lineNum">      99 </span>            :  * The above pictures describe the normal state of the pointer lists.
<span class="lineNum">     100 </span>            :  * At top and bottom of the image, we diddle the pointer lists to duplicate
<span class="lineNum">     101 </span>            :  * the first or last sample row as necessary (this is cheaper than copying
<span class="lineNum">     102 </span>            :  * sample rows around).
<span class="lineNum">     103 </span>            :  *
<span class="lineNum">     104 </span>            :  * This scheme breaks down if M &lt; 2, ie, min_DCT_scaled_size is 1.  In that
<span class="lineNum">     105 </span>            :  * situation each iMCU row provides only one row group so the buffering logic
<span class="lineNum">     106 </span>            :  * must be different (eg, we must read two iMCU rows before we can emit the
<span class="lineNum">     107 </span>            :  * first row group).  For now, we simply do not support providing context
<span class="lineNum">     108 </span>            :  * rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
<span class="lineNum">     109 </span>            :  * be worth providing --- if someone wants a 1/8th-size preview, they probably
<span class="lineNum">     110 </span>            :  * want it quick and dirty, so a context-free upsampler is sufficient.
<span class="lineNum">     111 </span>            :  */
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : /* Forward declarations */
<span class="lineNum">     115 </span>            : METHODDEF(void) process_data_simple_main
<span class="lineNum">     116 </span>            :         (j_decompress_ptr cinfo, JSAMPARRAY output_buf,
<span class="lineNum">     117 </span>            :          JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);
<span class="lineNum">     118 </span>            : METHODDEF(void) process_data_context_main
<span class="lineNum">     119 </span>            :         (j_decompress_ptr cinfo, JSAMPARRAY output_buf,
<span class="lineNum">     120 </span>            :          JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);
<span class="lineNum">     121 </span>            : #ifdef QUANT_2PASS_SUPPORTED
<span class="lineNum">     122 </span>            : METHODDEF(void) process_data_crank_post
<span class="lineNum">     123 </span>            :         (j_decompress_ptr cinfo, JSAMPARRAY output_buf,
<span class="lineNum">     124 </span>            :          JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);
<span class="lineNum">     125 </span>            : #endif
<span class="lineNum">     126 </span>            : 
<a name="127"><span class="lineNum">     127 </span>            : </a>
<span class="lineNum">     128 </span>            : LOCAL(void)
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : alloc_funny_pointers (j_decompress_ptr cinfo)</span>
<span class="lineNum">     130 </span>            : /* Allocate space for the funny pointer lists.
<span class="lineNum">     131 </span>            :  * This is done only once, not once per pass.
<span class="lineNum">     132 </span>            :  */
<span class="lineNum">     133 </span>            : {
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     135 </span>            :   int ci, rgroup;
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   int M = cinfo-&gt;_min_DCT_scaled_size;</span>
<span class="lineNum">     137 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     138 </span>            :   JSAMPARRAY xbuf;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :   /* Get top-level space for component array pointers.
<span class="lineNum">     141 </span>            :    * We alloc both arrays with one call to save a few cycles.
<span class="lineNum">     142 </span>            :    */
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   main_ptr-&gt;xbuffer[0] = (JSAMPIMAGE)</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :                                 cinfo-&gt;num_components * 2 * sizeof(JSAMPARRAY));</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   main_ptr-&gt;xbuffer[1] = main_ptr-&gt;xbuffer[0] + cinfo-&gt;num_components;</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     rgroup = (compptr-&gt;v_samp_factor * compptr-&gt;_DCT_scaled_size) /</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :       cinfo-&gt;_min_DCT_scaled_size; /* height of a row group of component */</span>
<span class="lineNum">     152 </span>            :     /* Get space for pointer lists --- M+4 row groups in each list.
<span class="lineNum">     153 </span>            :      * We alloc both pointer lists with one call to save a few cycles.
<span class="lineNum">     154 </span>            :      */
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     xbuf = (JSAMPARRAY)</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                                   2 * (rgroup * (M + 4)) * sizeof(JSAMPROW));</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     xbuf += rgroup;             /* want one row group at negative offsets */</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     main_ptr-&gt;xbuffer[0][ci] = xbuf;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     xbuf += rgroup * (M + 4);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     main_ptr-&gt;xbuffer[1][ci] = xbuf;</span>
<span class="lineNum">     162 </span>            :   }
<span class="lineNum">     163 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     164 </span>            : 
<a name="165"><span class="lineNum">     165 </span>            : </a>
<span class="lineNum">     166 </span>            : LOCAL(void)
<span class="lineNum">     167 </span><span class="lineNoCov">          0 : make_funny_pointers (j_decompress_ptr cinfo)</span>
<span class="lineNum">     168 </span>            : /* Create the funny pointer lists discussed in the comments above.
<span class="lineNum">     169 </span>            :  * The actual workspace is already allocated (in main_ptr-&gt;buffer),
<span class="lineNum">     170 </span>            :  * and the space for the pointer lists is allocated too.
<span class="lineNum">     171 </span>            :  * This routine just fills in the curiously ordered lists.
<span class="lineNum">     172 </span>            :  * This will be repeated at the beginning of each pass.
<span class="lineNum">     173 </span>            :  */
<span class="lineNum">     174 </span>            : {
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     176 </span>            :   int ci, i, rgroup;
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   int M = cinfo-&gt;_min_DCT_scaled_size;</span>
<span class="lineNum">     178 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     179 </span>            :   JSAMPARRAY buf, xbuf0, xbuf1;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     rgroup = (compptr-&gt;v_samp_factor * compptr-&gt;_DCT_scaled_size) /</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       cinfo-&gt;_min_DCT_scaled_size; /* height of a row group of component */</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     xbuf0 = main_ptr-&gt;xbuffer[0][ci];</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     xbuf1 = main_ptr-&gt;xbuffer[1][ci];</span>
<span class="lineNum">     187 </span>            :     /* First copy the workspace pointers as-is */
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     buf = main_ptr-&gt;buffer[ci];</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; rgroup * (M + 2); i++) {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       xbuf0[i] = xbuf1[i] = buf[i];</span>
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            :     /* In the second list, put the last four row groups in swapped order */
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; rgroup * 2; i++) {</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :       xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :       xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];</span>
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span>            :     /* The wraparound pointers at top and bottom will be filled later
<span class="lineNum">     198 </span>            :      * (see set_wraparound_pointers, below).  Initially we want the &quot;above&quot;
<span class="lineNum">     199 </span>            :      * pointers to duplicate the first actual data line.  This only needs
<span class="lineNum">     200 </span>            :      * to happen in xbuffer[0].
<span class="lineNum">     201 </span>            :      */
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; rgroup; i++) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       xbuf0[i - rgroup] = xbuf0[0];</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span>            :   }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     207 </span>            : 
<a name="208"><span class="lineNum">     208 </span>            : </a>
<span class="lineNum">     209 </span>            : LOCAL(void)
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : set_bottom_pointers (j_decompress_ptr cinfo)</span>
<span class="lineNum">     211 </span>            : /* Change the pointer lists to duplicate the last sample row at the bottom
<span class="lineNum">     212 </span>            :  * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
<span class="lineNum">     213 </span>            :  * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
<span class="lineNum">     214 </span>            :  */
<span class="lineNum">     215 </span>            : {
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     217 </span>            :   int ci, i, rgroup, iMCUheight, rows_left;
<span class="lineNum">     218 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     219 </span>            :   JSAMPARRAY xbuf;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     223 </span>            :     /* Count sample rows in one iMCU row and in one row group */
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     iMCUheight = compptr-&gt;v_samp_factor * compptr-&gt;_DCT_scaled_size;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     rgroup = iMCUheight / cinfo-&gt;_min_DCT_scaled_size;</span>
<span class="lineNum">     226 </span>            :     /* Count nondummy sample rows remaining for this component */
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     rows_left = (int) (compptr-&gt;downsampled_height % (JDIMENSION) iMCUheight);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     if (rows_left == 0) rows_left = iMCUheight;</span>
<span class="lineNum">     229 </span>            :     /* Count nondummy row groups.  Should get same answer for each component,
<span class="lineNum">     230 </span>            :      * so we need only do it once.
<span class="lineNum">     231 </span>            :      */
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     if (ci == 0) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       main_ptr-&gt;rowgroups_avail = (JDIMENSION) ((rows_left-1) / rgroup + 1);</span>
<span class="lineNum">     234 </span>            :     }
<span class="lineNum">     235 </span>            :     /* Duplicate the last real sample row rgroup*2 times; this pads out the
<span class="lineNum">     236 </span>            :      * last partial rowgroup and ensures at least one full rowgroup of context.
<span class="lineNum">     237 </span>            :      */
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     xbuf = main_ptr-&gt;xbuffer[main_ptr-&gt;whichptr][ci];</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; rgroup * 2; i++) {</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :       xbuf[rows_left + i] = xbuf[rows_left-1];</span>
<span class="lineNum">     241 </span>            :     }
<span class="lineNum">     242 </span>            :   }
<span class="lineNum">     243 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : /*
<span class="lineNum">     247 </span>            :  * Initialize for a processing pass.
<span class="lineNum">     248 </span>            :  */
<a name="249"><span class="lineNum">     249 </span>            : </a>
<span class="lineNum">     250 </span>            : METHODDEF(void)
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)</span>
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   switch (pass_mode) {</span>
<span class="lineNum">     256 </span>            :   case JBUF_PASS_THRU:
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;upsample-&gt;need_context_rows) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       main_ptr-&gt;pub.process_data = process_data_context_main;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       make_funny_pointers(cinfo); /* Create the xbuffer[] lists */</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       main_ptr-&gt;whichptr = 0;   /* Read first iMCU row into xbuffer[0] */</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :       main_ptr-&gt;context_state = CTX_PREPARE_FOR_IMCU;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       main_ptr-&gt;iMCU_row_ctr = 0;</span>
<span class="lineNum">     263 </span>            :     } else {
<span class="lineNum">     264 </span>            :       /* Simple case with no context needed */
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       main_ptr-&gt;pub.process_data = process_data_simple_main;</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer_full = FALSE;      /* Mark buffer empty */</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroup_ctr = 0;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     270 </span>            : #ifdef QUANT_2PASS_SUPPORTED
<span class="lineNum">     271 </span>            :   case JBUF_CRANK_DEST:
<span class="lineNum">     272 </span>            :     /* For last pass of 2-pass quantization, just crank the postprocessor */
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     main_ptr-&gt;pub.process_data = process_data_crank_post;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     275 </span>            : #endif
<span class="lineNum">     276 </span>            :   default:
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     279 </span>            :   }
<span class="lineNum">     280 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : /*
<span class="lineNum">     284 </span>            :  * Process some data.
<span class="lineNum">     285 </span>            :  * This handles the simple case where no context is required.
<span class="lineNum">     286 </span>            :  */
<a name="287"><span class="lineNum">     287 </span>            : </a>
<span class="lineNum">     288 </span>            : METHODDEF(void)
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : process_data_simple_main (j_decompress_ptr cinfo,</span>
<span class="lineNum">     290 </span>            :                           JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
<span class="lineNum">     291 </span>            :                           JDIMENSION out_rows_avail)
<span class="lineNum">     292 </span>            : {
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     294 </span>            :   JDIMENSION rowgroups_avail;
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   /* Read input data if we haven't filled the main buffer yet */
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   if (! main_ptr-&gt;buffer_full) {</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     if (! (*cinfo-&gt;coef-&gt;decompress_data) (cinfo, main_ptr-&gt;buffer))</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :       return;                   /* suspension forced, can do nothing more */</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer_full = TRUE;       /* OK, we have an iMCU row to work with */</span>
<span class="lineNum">     301 </span>            :   }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   /* There are always min_DCT_scaled_size row groups in an iMCU row. */
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   rowgroups_avail = (JDIMENSION) cinfo-&gt;_min_DCT_scaled_size;</span>
<span class="lineNum">     305 </span>            :   /* Note: at the bottom of the image, we may pass extra garbage row groups
<span class="lineNum">     306 </span>            :    * to the postprocessor.  The postprocessor has to check for bottom
<span class="lineNum">     307 </span>            :    * of image anyway (at row resolution), so no point in us doing it too.
<span class="lineNum">     308 </span>            :    */
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :   /* Feed the postprocessor */
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   (*cinfo-&gt;post-&gt;post_process_data) (cinfo, main_ptr-&gt;buffer,</span>
<span class="lineNum">     312 </span>            :                                      &amp;main_ptr-&gt;rowgroup_ctr, rowgroups_avail,
<span class="lineNum">     313 </span>            :                                      output_buf, out_row_ctr, out_rows_avail);
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :   /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if (main_ptr-&gt;rowgroup_ctr &gt;= rowgroups_avail) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer_full = FALSE;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroup_ctr = 0;</span>
<span class="lineNum">     319 </span>            :   }
<span class="lineNum">     320 </span>            : }
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : /*
<span class="lineNum">     324 </span>            :  * Process some data.
<span class="lineNum">     325 </span>            :  * This handles the case where context rows must be provided.
<span class="lineNum">     326 </span>            :  */
<a name="327"><span class="lineNum">     327 </span>            : </a>
<span class="lineNum">     328 </span>            : METHODDEF(void)
<span class="lineNum">     329 </span><span class="lineNoCov">          0 : process_data_context_main (j_decompress_ptr cinfo,</span>
<span class="lineNum">     330 </span>            :                            JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
<span class="lineNum">     331 </span>            :                            JDIMENSION out_rows_avail)
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   my_main_ptr main_ptr = (my_main_ptr) cinfo-&gt;main;</span>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            :   /* Read input data if we haven't filled the main buffer yet */
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   if (! main_ptr-&gt;buffer_full) {</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     if (! (*cinfo-&gt;coef-&gt;decompress_data) (cinfo,</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :                                            main_ptr-&gt;xbuffer[main_ptr-&gt;whichptr]))</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       return;                   /* suspension forced, can do nothing more */</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer_full = TRUE;       /* OK, we have an iMCU row to work with */</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     main_ptr-&gt;iMCU_row_ctr++;   /* count rows received */</span>
<span class="lineNum">     342 </span>            :   }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :   /* Postprocessor typically will not swallow all the input data it is handed
<span class="lineNum">     345 </span>            :    * in one call (due to filling the output buffer first).  Must be prepared
<span class="lineNum">     346 </span>            :    * to exit and restart.  This switch lets us keep track of how far we got.
<span class="lineNum">     347 </span>            :    * Note that each case falls through to the next on successful completion.
<span class="lineNum">     348 </span>            :    */
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   switch (main_ptr-&gt;context_state) {</span>
<span class="lineNum">     350 </span>            :   case CTX_POSTPONED_ROW:
<span class="lineNum">     351 </span>            :     /* Call postprocessor using previously set pointers for postponed row */
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     (*cinfo-&gt;post-&gt;post_process_data) (cinfo, main_ptr-&gt;xbuffer[main_ptr-&gt;whichptr],</span>
<span class="lineNum">     353 </span>            :                         &amp;main_ptr-&gt;rowgroup_ctr, main_ptr-&gt;rowgroups_avail,
<span class="lineNum">     354 </span>            :                         output_buf, out_row_ctr, out_rows_avail);
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     if (main_ptr-&gt;rowgroup_ctr &lt; main_ptr-&gt;rowgroups_avail)</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :       return;                   /* Need to suspend */</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     main_ptr-&gt;context_state = CTX_PREPARE_FOR_IMCU;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     if (*out_row_ctr &gt;= out_rows_avail)</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :       return;                   /* Postprocessor exactly filled output buf */</span>
<span class="lineNum">     360 </span>            :     /*FALLTHROUGH*/
<span class="lineNum">     361 </span>            :   case CTX_PREPARE_FOR_IMCU:
<span class="lineNum">     362 </span>            :     /* Prepare to process first M-1 row groups of this iMCU row */
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroup_ctr = 0;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroups_avail = (JDIMENSION) (cinfo-&gt;_min_DCT_scaled_size - 1);</span>
<span class="lineNum">     365 </span>            :     /* Check for bottom of image: if so, tweak pointers to &quot;duplicate&quot;
<span class="lineNum">     366 </span>            :      * the last sample row, and adjust rowgroups_avail to ignore padding rows.
<span class="lineNum">     367 </span>            :      */
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (main_ptr-&gt;iMCU_row_ctr == cinfo-&gt;total_iMCU_rows)</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       set_bottom_pointers(cinfo);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     main_ptr-&gt;context_state = CTX_PROCESS_IMCU;</span>
<span class="lineNum">     371 </span>            :     /*FALLTHROUGH*/
<span class="lineNum">     372 </span>            :   case CTX_PROCESS_IMCU:
<span class="lineNum">     373 </span>            :     /* Call postprocessor using previously set pointers */
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     (*cinfo-&gt;post-&gt;post_process_data) (cinfo, main_ptr-&gt;xbuffer[main_ptr-&gt;whichptr],</span>
<span class="lineNum">     375 </span>            :                         &amp;main_ptr-&gt;rowgroup_ctr, main_ptr-&gt;rowgroups_avail,
<span class="lineNum">     376 </span>            :                         output_buf, out_row_ctr, out_rows_avail);
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     if (main_ptr-&gt;rowgroup_ctr &lt; main_ptr-&gt;rowgroups_avail)</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       return;                   /* Need to suspend */</span>
<span class="lineNum">     379 </span>            :     /* After the first iMCU, change wraparound pointers to normal state */
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     if (main_ptr-&gt;iMCU_row_ctr == 1)</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :       set_wraparound_pointers(cinfo);</span>
<span class="lineNum">     382 </span>            :     /* Prepare to load new iMCU row using other xbuffer list */
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     main_ptr-&gt;whichptr ^= 1;    /* 0=&gt;1 or 1=&gt;0 */</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer_full = FALSE;</span>
<span class="lineNum">     385 </span>            :     /* Still need to process last row group of this iMCU row, */
<span class="lineNum">     386 </span>            :     /* which is saved at index M+1 of the other xbuffer */
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroup_ctr = (JDIMENSION) (cinfo-&gt;_min_DCT_scaled_size + 1);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     main_ptr-&gt;rowgroups_avail = (JDIMENSION) (cinfo-&gt;_min_DCT_scaled_size + 2);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     main_ptr-&gt;context_state = CTX_POSTPONED_ROW;</span>
<span class="lineNum">     390 </span>            :   }
<span class="lineNum">     391 </span>            : }
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : /*
<span class="lineNum">     395 </span>            :  * Process some data.
<span class="lineNum">     396 </span>            :  * Final pass of two-pass quantization: just call the postprocessor.
<span class="lineNum">     397 </span>            :  * Source data will be the postprocessor controller's internal buffer.
<span class="lineNum">     398 </span>            :  */
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : #ifdef QUANT_2PASS_SUPPORTED
<a name="401"><span class="lineNum">     401 </span>            : </a>
<span class="lineNum">     402 </span>            : METHODDEF(void)
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : process_data_crank_post (j_decompress_ptr cinfo,</span>
<span class="lineNum">     404 </span>            :                          JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
<span class="lineNum">     405 </span>            :                          JDIMENSION out_rows_avail)
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   (*cinfo-&gt;post-&gt;post_process_data) (cinfo, (JSAMPIMAGE) NULL,</span>
<span class="lineNum">     408 </span>            :                                      (JDIMENSION *) NULL, (JDIMENSION) 0,
<span class="lineNum">     409 </span>            :                                      output_buf, out_row_ctr, out_rows_avail);
<span class="lineNum">     410 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : #endif /* QUANT_2PASS_SUPPORTED */
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : /*
<span class="lineNum">     416 </span>            :  * Initialize main buffer controller.
<span class="lineNum">     417 </span>            :  */
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : GLOBAL(void)
<span class="lineNum">     420 </span><span class="lineNoCov">          0 : jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :   my_main_ptr main_ptr;
<span class="lineNum">     423 </span>            :   int ci, rgroup, ngroups;
<span class="lineNum">     424 </span>            :   jpeg_component_info *compptr;
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   main_ptr = (my_main_ptr)</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="lineNum">     428 </span>            :                                 sizeof(my_main_controller));
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   cinfo-&gt;main = (struct jpeg_d_main_controller *) main_ptr;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   main_ptr-&gt;pub.start_pass = start_pass_main;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   if (need_full_buffer)         /* shouldn't happen */</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :   /* Allocate the workspace.
<span class="lineNum">     436 </span>            :    * ngroups is the number of row groups we need.
<span class="lineNum">     437 </span>            :    */
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   if (cinfo-&gt;upsample-&gt;need_context_rows) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     if (cinfo-&gt;_min_DCT_scaled_size &lt; 2) /* unsupported, see comments above */</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       ERREXIT(cinfo, JERR_NOTIMPL);</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     ngroups = cinfo-&gt;_min_DCT_scaled_size + 2;</span>
<span class="lineNum">     443 </span>            :   } else {
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     ngroups = cinfo-&gt;_min_DCT_scaled_size;</span>
<span class="lineNum">     445 </span>            :   }
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :        ci++, compptr++) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     rgroup = (compptr-&gt;v_samp_factor * compptr-&gt;_DCT_scaled_size) /</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :       cinfo-&gt;_min_DCT_scaled_size; /* height of a row group of component */</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     main_ptr-&gt;buffer[ci] = (*cinfo-&gt;mem-&gt;alloc_sarray)</span>
<span class="lineNum">     452 </span>            :                         ((j_common_ptr) cinfo, JPOOL_IMAGE,
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                          compptr-&gt;width_in_blocks * compptr-&gt;_DCT_scaled_size,</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                          (JDIMENSION) (rgroup * ngroups));</span>
<span class="lineNum">     455 </span>            :   }
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libvpx/libvpx/vp8/encoder/denoising.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">media/libvpx/libvpx/vp8/encoder</a> - denoising.c<span style="font-size: 80%;"> (source / <a href="denoising.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">383</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2012 The WebM project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;denoising.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;vp8/common/reconinter.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;vpx/vpx_integer.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;vpx_mem/vpx_mem.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;vp8_rtcd.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : static const unsigned int NOISE_MOTION_THRESHOLD = 25 * 25;
<span class="lineNum">      21 </span>            : /* SSE_DIFF_THRESHOLD is selected as ~95% confidence assuming
<span class="lineNum">      22 </span>            :  * var(noise) ~= 100.
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : static const unsigned int SSE_DIFF_THRESHOLD = 16 * 16 * 20;
<span class="lineNum">      25 </span>            : static const unsigned int SSE_THRESHOLD = 16 * 16 * 40;
<span class="lineNum">      26 </span>            : static const unsigned int SSE_THRESHOLD_HIGH = 16 * 16 * 80;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /*
<span class="lineNum">      29 </span>            :  * The filter function was modified to reduce the computational complexity.
<span class="lineNum">      30 </span>            :  * Step 1:
<span class="lineNum">      31 </span>            :  * Instead of applying tap coefficients for each pixel, we calculated the
<span class="lineNum">      32 </span>            :  * pixel adjustments vs. pixel diff value ahead of time.
<span class="lineNum">      33 </span>            :  *     adjustment = filtered_value - current_raw
<span class="lineNum">      34 </span>            :  *                = (filter_coefficient * diff + 128) &gt;&gt; 8
<span class="lineNum">      35 </span>            :  * where
<span class="lineNum">      36 </span>            :  *     filter_coefficient = (255 &lt;&lt; 8) / (256 + ((absdiff * 330) &gt;&gt; 3));
<span class="lineNum">      37 </span>            :  *     filter_coefficient += filter_coefficient /
<span class="lineNum">      38 </span>            :  *                           (3 + motion_magnitude_adjustment);
<span class="lineNum">      39 </span>            :  *     filter_coefficient is clamped to 0 ~ 255.
<span class="lineNum">      40 </span>            :  *
<span class="lineNum">      41 </span>            :  * Step 2:
<span class="lineNum">      42 </span>            :  * The adjustment vs. diff curve becomes flat very quick when diff increases.
<span class="lineNum">      43 </span>            :  * This allowed us to use only several levels to approximate the curve without
<span class="lineNum">      44 </span>            :  * changing the filtering algorithm too much.
<span class="lineNum">      45 </span>            :  * The adjustments were further corrected by checking the motion magnitude.
<span class="lineNum">      46 </span>            :  * The levels used are:
<span class="lineNum">      47 </span>            :  * diff       adjustment w/o motion correction   adjustment w/ motion correction
<span class="lineNum">      48 </span>            :  * [-255, -16]           -6                                   -7
<span class="lineNum">      49 </span>            :  * [-15, -8]             -4                                   -5
<span class="lineNum">      50 </span>            :  * [-7, -4]              -3                                   -4
<span class="lineNum">      51 </span>            :  * [-3, 3]               diff                                 diff
<span class="lineNum">      52 </span>            :  * [4, 7]                 3                                    4
<span class="lineNum">      53 </span>            :  * [8, 15]                4                                    5
<span class="lineNum">      54 </span>            :  * [16, 255]              6                                    7
<a name="55"><span class="lineNum">      55 </span>            :  */</a>
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span><span class="lineNoCov">          0 : int vp8_denoiser_filter_c(unsigned char *mc_running_avg_y, int mc_avg_y_stride,</span>
<span class="lineNum">      58 </span>            :                           unsigned char *running_avg_y, int avg_y_stride,
<span class="lineNum">      59 </span>            :                           unsigned char *sig, int sig_stride,
<span class="lineNum">      60 </span>            :                           unsigned int motion_magnitude,
<span class="lineNum">      61 </span>            :                           int increase_denoising) {
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   unsigned char *running_avg_y_start = running_avg_y;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   unsigned char *sig_start = sig;</span>
<span class="lineNum">      64 </span>            :   int sum_diff_thresh;
<span class="lineNum">      65 </span>            :   int r, c;
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   int sum_diff = 0;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   int adj_val[3] = { 3, 4, 6 };</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   int shift_inc1 = 0;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   int shift_inc2 = 1;</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   int col_sum[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };</span>
<span class="lineNum">      71 </span>            :   /* If motion_magnitude is small, making the denoiser more aggressive by
<span class="lineNum">      72 </span>            :    * increasing the adjustment for each level. Add another increment for
<span class="lineNum">      73 </span>            :    * blocks that are labeled for increase denoising. */
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :   if (motion_magnitude &lt;= MOTION_MAGNITUDE_THRESHOLD) {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :     if (increase_denoising) {</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :       shift_inc1 = 1;</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :       shift_inc2 = 2;</span>
<span class="lineNum">      78 </span>            :     }
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     adj_val[0] += shift_inc2;</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     adj_val[1] += shift_inc2;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     adj_val[2] += shift_inc2;</span>
<span class="lineNum">      82 </span>            :   }
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   for (r = 0; r &lt; 16; ++r) {</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :     for (c = 0; c &lt; 16; ++c) {</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :       int diff = 0;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :       int adjustment = 0;</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :       int absdiff = 0;</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :       diff = mc_running_avg_y[c] - sig[c];</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :       absdiff = abs(diff);</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :       // When |diff| &lt;= |3 + shift_inc1|, use pixel value from
<span class="lineNum">      94 </span>            :       // last denoised raw.
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :       if (absdiff &lt;= 3 + shift_inc1) {</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         running_avg_y[c] = mc_running_avg_y[c];</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :         col_sum[c] += diff;</span>
<span class="lineNum">      98 </span>            :       } else {
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :         if (absdiff &gt;= 4 + shift_inc1 &amp;&amp; absdiff &lt;= 7) {</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :           adjustment = adj_val[0];</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         } else if (absdiff &gt;= 8 &amp;&amp; absdiff &lt;= 15) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :           adjustment = adj_val[1];</span>
<span class="lineNum">     103 </span>            :         } else {
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :           adjustment = adj_val[2];</span>
<span class="lineNum">     105 </span>            :         }
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         if (diff &gt; 0) {</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :           if ((sig[c] + adjustment) &gt; 255) {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :             running_avg_y[c] = 255;</span>
<span class="lineNum">     110 </span>            :           } else {
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :             running_avg_y[c] = sig[c] + adjustment;</span>
<span class="lineNum">     112 </span>            :           }
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :           col_sum[c] += adjustment;</span>
<span class="lineNum">     115 </span>            :         } else {
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :           if ((sig[c] - adjustment) &lt; 0) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :             running_avg_y[c] = 0;</span>
<span class="lineNum">     118 </span>            :           } else {
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :             running_avg_y[c] = sig[c] - adjustment;</span>
<span class="lineNum">     120 </span>            :           }
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :           col_sum[c] -= adjustment;</span>
<span class="lineNum">     123 </span>            :         }
<span class="lineNum">     124 </span>            :       }
<span class="lineNum">     125 </span>            :     }
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :     /* Update pointers for next iteration. */
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     sig += sig_stride;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     mc_running_avg_y += mc_avg_y_stride;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     running_avg_y += avg_y_stride;</span>
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   for (c = 0; c &lt; 16; ++c) {</span>
<span class="lineNum">     134 </span>            :     // Below we clip the value in the same way which SSE code use.
<span class="lineNum">     135 </span>            :     // When adopting aggressive denoiser, the adj_val for each pixel
<span class="lineNum">     136 </span>            :     // could be at most 8 (this is current max adjustment of the map).
<span class="lineNum">     137 </span>            :     // In SSE code, we calculate the sum of adj_val for
<span class="lineNum">     138 </span>            :     // the columns, so the sum could be upto 128(16 rows). However,
<span class="lineNum">     139 </span>            :     // the range of the value is -128 ~ 127 in SSE code, that's why
<span class="lineNum">     140 </span>            :     // we do this change in C code.
<span class="lineNum">     141 </span>            :     // We don't do this for UV denoiser, since there are only 8 rows,
<span class="lineNum">     142 </span>            :     // and max adjustments &lt;= 8, so the sum of the columns will not
<span class="lineNum">     143 </span>            :     // exceed 64.
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     if (col_sum[c] &gt;= 128) {</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       col_sum[c] = 127;</span>
<span class="lineNum">     146 </span>            :     }
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     sum_diff += col_sum[c];</span>
<span class="lineNum">     148 </span>            :   }
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   sum_diff_thresh = SUM_DIFF_THRESHOLD;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   if (increase_denoising) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   if (abs(sum_diff) &gt; sum_diff_thresh) {</span>
<span class="lineNum">     153 </span>            :     // Before returning to copy the block (i.e., apply no denoising), check
<span class="lineNum">     154 </span>            :     // if we can still apply some (weaker) temporal filtering to this block,
<span class="lineNum">     155 </span>            :     // that would otherwise not be denoised at all. Simplest is to apply
<span class="lineNum">     156 </span>            :     // an additional adjustment to running_avg_y to bring it closer to sig.
<span class="lineNum">     157 </span>            :     // The adjustment is capped by a maximum delta, and chosen such that
<span class="lineNum">     158 </span>            :     // in most cases the resulting sum_diff will be within the
<span class="lineNum">     159 </span>            :     // accceptable range given by sum_diff_thresh.
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     // The delta is set by the excess of absolute pixel diff over threshold.
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     int delta = ((abs(sum_diff) - sum_diff_thresh) &gt;&gt; 8) + 1;</span>
<span class="lineNum">     163 </span>            :     // Only apply the adjustment for max delta up to 3.
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :     if (delta &lt; 4) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       sig -= sig_stride * 16;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       mc_running_avg_y -= mc_avg_y_stride * 16;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       running_avg_y -= avg_y_stride * 16;</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       for (r = 0; r &lt; 16; ++r) {</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         for (c = 0; c &lt; 16; ++c) {</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :           int diff = mc_running_avg_y[c] - sig[c];</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :           int adjustment = abs(diff);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :           if (adjustment &gt; delta) adjustment = delta;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :           if (diff &gt; 0) {</span>
<span class="lineNum">     174 </span>            :             // Bring denoised signal down.
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :             if (running_avg_y[c] - adjustment &lt; 0) {</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :               running_avg_y[c] = 0;</span>
<span class="lineNum">     177 </span>            :             } else {
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :               running_avg_y[c] = running_avg_y[c] - adjustment;</span>
<span class="lineNum">     179 </span>            :             }
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :             col_sum[c] -= adjustment;</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :           } else if (diff &lt; 0) {</span>
<span class="lineNum">     182 </span>            :             // Bring denoised signal up.
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :             if (running_avg_y[c] + adjustment &gt; 255) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :               running_avg_y[c] = 255;</span>
<span class="lineNum">     185 </span>            :             } else {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :               running_avg_y[c] = running_avg_y[c] + adjustment;</span>
<span class="lineNum">     187 </span>            :             }
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :             col_sum[c] += adjustment;</span>
<span class="lineNum">     189 </span>            :           }
<span class="lineNum">     190 </span>            :         }
<span class="lineNum">     191 </span>            :         // TODO(marpan): Check here if abs(sum_diff) has gone below the
<span class="lineNum">     192 </span>            :         // threshold sum_diff_thresh, and if so, we can exit the row loop.
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         sig += sig_stride;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :         mc_running_avg_y += mc_avg_y_stride;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         running_avg_y += avg_y_stride;</span>
<span class="lineNum">     196 </span>            :       }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :       sum_diff = 0;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :       for (c = 0; c &lt; 16; ++c) {</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         if (col_sum[c] &gt;= 128) {</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :           col_sum[c] = 127;</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         sum_diff += col_sum[c];</span>
<span class="lineNum">     204 </span>            :       }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :       if (abs(sum_diff) &gt; sum_diff_thresh) return COPY_BLOCK;</span>
<span class="lineNum">     207 </span>            :     } else {
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :       return COPY_BLOCK;</span>
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span>            :   }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   vp8_copy_mem16x16(running_avg_y_start, avg_y_stride, sig_start, sig_stride);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   return FILTER_BLOCK;</span>
<a name="214"><span class="lineNum">     214 </span>            : }</a>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : int vp8_denoiser_filter_uv_c(unsigned char *mc_running_avg_uv,</span>
<span class="lineNum">     217 </span>            :                              int mc_avg_uv_stride,
<span class="lineNum">     218 </span>            :                              unsigned char *running_avg_uv, int avg_uv_stride,
<span class="lineNum">     219 </span>            :                              unsigned char *sig, int sig_stride,
<span class="lineNum">     220 </span>            :                              unsigned int motion_magnitude,
<span class="lineNum">     221 </span>            :                              int increase_denoising) {
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   unsigned char *running_avg_uv_start = running_avg_uv;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   unsigned char *sig_start = sig;</span>
<span class="lineNum">     224 </span>            :   int sum_diff_thresh;
<span class="lineNum">     225 </span>            :   int r, c;
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   int sum_diff = 0;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   int sum_block = 0;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   int adj_val[3] = { 3, 4, 6 };</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   int shift_inc1 = 0;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   int shift_inc2 = 1;</span>
<span class="lineNum">     231 </span>            :   /* If motion_magnitude is small, making the denoiser more aggressive by
<span class="lineNum">     232 </span>            :    * increasing the adjustment for each level. Add another increment for
<span class="lineNum">     233 </span>            :    * blocks that are labeled for increase denoising. */
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   if (motion_magnitude &lt;= MOTION_MAGNITUDE_THRESHOLD_UV) {</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     if (increase_denoising) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :       shift_inc1 = 1;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       shift_inc2 = 2;</span>
<span class="lineNum">     238 </span>            :     }
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     adj_val[0] += shift_inc2;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     adj_val[1] += shift_inc2;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     adj_val[2] += shift_inc2;</span>
<span class="lineNum">     242 </span>            :   }
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   // Avoid denoising color signal if its close to average level.
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   for (r = 0; r &lt; 8; ++r) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     for (c = 0; c &lt; 8; ++c) {</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       sum_block += sig[c];</span>
<span class="lineNum">     248 </span>            :     }
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     sig += sig_stride;</span>
<span class="lineNum">     250 </span>            :   }
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   if (abs(sum_block - (128 * 8 * 8)) &lt; SUM_DIFF_FROM_AVG_THRESH_UV) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     return COPY_BLOCK;</span>
<span class="lineNum">     253 </span>            :   }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   sig -= sig_stride * 8;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   for (r = 0; r &lt; 8; ++r) {</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     for (c = 0; c &lt; 8; ++c) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       int diff = 0;</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       int adjustment = 0;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :       int absdiff = 0;</span>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       diff = mc_running_avg_uv[c] - sig[c];</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       absdiff = abs(diff);</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :       // When |diff| &lt;= |3 + shift_inc1|, use pixel value from
<span class="lineNum">     266 </span>            :       // last denoised raw.
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :       if (absdiff &lt;= 3 + shift_inc1) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         running_avg_uv[c] = mc_running_avg_uv[c];</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         sum_diff += diff;</span>
<span class="lineNum">     270 </span>            :       } else {
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         if (absdiff &gt;= 4 &amp;&amp; absdiff &lt;= 7) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :           adjustment = adj_val[0];</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         } else if (absdiff &gt;= 8 &amp;&amp; absdiff &lt;= 15) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :           adjustment = adj_val[1];</span>
<span class="lineNum">     275 </span>            :         } else {
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :           adjustment = adj_val[2];</span>
<span class="lineNum">     277 </span>            :         }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         if (diff &gt; 0) {</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :           if ((sig[c] + adjustment) &gt; 255) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             running_avg_uv[c] = 255;</span>
<span class="lineNum">     281 </span>            :           } else {
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             running_avg_uv[c] = sig[c] + adjustment;</span>
<span class="lineNum">     283 </span>            :           }
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :           sum_diff += adjustment;</span>
<span class="lineNum">     285 </span>            :         } else {
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :           if ((sig[c] - adjustment) &lt; 0) {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :             running_avg_uv[c] = 0;</span>
<span class="lineNum">     288 </span>            :           } else {
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :             running_avg_uv[c] = sig[c] - adjustment;</span>
<span class="lineNum">     290 </span>            :           }
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :           sum_diff -= adjustment;</span>
<span class="lineNum">     292 </span>            :         }
<span class="lineNum">     293 </span>            :       }
<span class="lineNum">     294 </span>            :     }
<span class="lineNum">     295 </span>            :     /* Update pointers for next iteration. */
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     sig += sig_stride;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     mc_running_avg_uv += mc_avg_uv_stride;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     running_avg_uv += avg_uv_stride;</span>
<span class="lineNum">     299 </span>            :   }
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :   sum_diff_thresh = SUM_DIFF_THRESHOLD_UV;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (increase_denoising) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH_UV;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   if (abs(sum_diff) &gt; sum_diff_thresh) {</span>
<span class="lineNum">     304 </span>            :     // Before returning to copy the block (i.e., apply no denoising), check
<span class="lineNum">     305 </span>            :     // if we can still apply some (weaker) temporal filtering to this block,
<span class="lineNum">     306 </span>            :     // that would otherwise not be denoised at all. Simplest is to apply
<span class="lineNum">     307 </span>            :     // an additional adjustment to running_avg_y to bring it closer to sig.
<span class="lineNum">     308 </span>            :     // The adjustment is capped by a maximum delta, and chosen such that
<span class="lineNum">     309 </span>            :     // in most cases the resulting sum_diff will be within the
<span class="lineNum">     310 </span>            :     // accceptable range given by sum_diff_thresh.
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :     // The delta is set by the excess of absolute pixel diff over threshold.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     int delta = ((abs(sum_diff) - sum_diff_thresh) &gt;&gt; 8) + 1;</span>
<span class="lineNum">     314 </span>            :     // Only apply the adjustment for max delta up to 3.
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     if (delta &lt; 4) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :       sig -= sig_stride * 8;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :       mc_running_avg_uv -= mc_avg_uv_stride * 8;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :       running_avg_uv -= avg_uv_stride * 8;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       for (r = 0; r &lt; 8; ++r) {</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         for (c = 0; c &lt; 8; ++c) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :           int diff = mc_running_avg_uv[c] - sig[c];</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :           int adjustment = abs(diff);</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :           if (adjustment &gt; delta) adjustment = delta;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           if (diff &gt; 0) {</span>
<span class="lineNum">     325 </span>            :             // Bring denoised signal down.
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :             if (running_avg_uv[c] - adjustment &lt; 0) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :               running_avg_uv[c] = 0;</span>
<span class="lineNum">     328 </span>            :             } else {
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :               running_avg_uv[c] = running_avg_uv[c] - adjustment;</span>
<span class="lineNum">     330 </span>            :             }
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             sum_diff -= adjustment;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :           } else if (diff &lt; 0) {</span>
<span class="lineNum">     333 </span>            :             // Bring denoised signal up.
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             if (running_avg_uv[c] + adjustment &gt; 255) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :               running_avg_uv[c] = 255;</span>
<span class="lineNum">     336 </span>            :             } else {
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :               running_avg_uv[c] = running_avg_uv[c] + adjustment;</span>
<span class="lineNum">     338 </span>            :             }
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :             sum_diff += adjustment;</span>
<span class="lineNum">     340 </span>            :           }
<span class="lineNum">     341 </span>            :         }
<span class="lineNum">     342 </span>            :         // TODO(marpan): Check here if abs(sum_diff) has gone below the
<span class="lineNum">     343 </span>            :         // threshold sum_diff_thresh, and if so, we can exit the row loop.
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         sig += sig_stride;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :         mc_running_avg_uv += mc_avg_uv_stride;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         running_avg_uv += avg_uv_stride;</span>
<span class="lineNum">     347 </span>            :       }
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       if (abs(sum_diff) &gt; sum_diff_thresh) return COPY_BLOCK;</span>
<span class="lineNum">     349 </span>            :     } else {
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       return COPY_BLOCK;</span>
<span class="lineNum">     351 </span>            :     }
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   vp8_copy_mem8x8(running_avg_uv_start, avg_uv_stride, sig_start, sig_stride);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :   return FILTER_BLOCK;</span>
<a name="356"><span class="lineNum">     356 </span>            : }</a>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineNoCov">          0 : void vp8_denoiser_set_parameters(VP8_DENOISER *denoiser, int mode) {</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   assert(mode &gt; 0);  // Denoiser is allocated only if mode &gt; 0.</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   if (mode == 1) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoiser_mode = kDenoiserOnYOnly;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   } else if (mode == 2) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoiser_mode = kDenoiserOnYUV;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   } else if (mode == 3) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoiser_mode = kDenoiserOnYUVAggressive;</span>
<span class="lineNum">     366 </span>            :   } else {
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoiser_mode = kDenoiserOnYUV;</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   if (denoiser-&gt;denoiser_mode != kDenoiserOnYUVAggressive) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_sse_thresh = 1;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_motion_thresh = 8;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_increase_filter = 0;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.denoise_mv_bias = 95;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.pickmode_mv_bias = 100;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.qp_thresh = 0;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.consec_zerolast = UINT_MAX;</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.spatial_blur = 0;</span>
<span class="lineNum">     378 </span>            :   } else {
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_sse_thresh = 2;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_motion_thresh = 16;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.scale_increase_filter = 1;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.denoise_mv_bias = 60;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.pickmode_mv_bias = 75;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.qp_thresh = 80;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.consec_zerolast = 15;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_pars.spatial_blur = 0;</span>
<span class="lineNum">     387 </span>            :   }
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 : int vp8_denoiser_allocate(VP8_DENOISER *denoiser, int width, int height,</span>
<span class="lineNum">     391 </span>            :                           int num_mb_rows, int num_mb_cols, int mode) {
<span class="lineNum">     392 </span>            :   int i;
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   assert(denoiser);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   denoiser-&gt;num_mb_cols = num_mb_cols;</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; MAX_REF_FRAMES; ++i) {</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     denoiser-&gt;yv12_running_avg[i].flags = 0;</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     if (vp8_yv12_alloc_frame_buffer(&amp;(denoiser-&gt;yv12_running_avg[i]), width,</span>
<span class="lineNum">     400 </span>            :                                     height, VP8BORDERINPIXELS) &lt; 0) {
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :       vp8_denoiser_free(denoiser);</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">     403 </span>            :     }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     memset(denoiser-&gt;yv12_running_avg[i].buffer_alloc, 0,</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :            denoiser-&gt;yv12_running_avg[i].frame_size);</span>
<span class="lineNum">     406 </span>            :   }
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   denoiser-&gt;yv12_mc_running_avg.flags = 0;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   if (vp8_yv12_alloc_frame_buffer(&amp;(denoiser-&gt;yv12_mc_running_avg), width,</span>
<span class="lineNum">     410 </span>            :                                   height, VP8BORDERINPIXELS) &lt; 0) {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     vp8_denoiser_free(denoiser);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     413 </span>            :   }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   memset(denoiser-&gt;yv12_mc_running_avg.buffer_alloc, 0,</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :          denoiser-&gt;yv12_mc_running_avg.frame_size);</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   if (vp8_yv12_alloc_frame_buffer(&amp;denoiser-&gt;yv12_last_source, width, height,</span>
<span class="lineNum">     419 </span>            :                                   VP8BORDERINPIXELS) &lt; 0) {
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     vp8_denoiser_free(denoiser);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     422 </span>            :   }
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :   memset(denoiser-&gt;yv12_last_source.buffer_alloc, 0,</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :          denoiser-&gt;yv12_last_source.frame_size);</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   denoiser-&gt;denoise_state = vpx_calloc((num_mb_rows * num_mb_cols), 1);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   if (!denoiser-&gt;denoise_state) {</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     vp8_denoiser_free(denoiser);</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     430 </span>            :   }
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   memset(denoiser-&gt;denoise_state, 0, (num_mb_rows * num_mb_cols));</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   vp8_denoiser_set_parameters(denoiser, mode);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   denoiser-&gt;nmse_source_diff = 0;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   denoiser-&gt;nmse_source_diff_count = 0;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   denoiser-&gt;qp_avg = 0;</span>
<span class="lineNum">     436 </span>            :   // QP threshold below which we can go up to aggressive mode.
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   denoiser-&gt;qp_threshold_up = 80;</span>
<span class="lineNum">     438 </span>            :   // QP threshold above which we can go back down to normal mode.
<span class="lineNum">     439 </span>            :   // For now keep this second threshold high, so not used currently.
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   denoiser-&gt;qp_threshold_down = 128;</span>
<span class="lineNum">     441 </span>            :   // Bitrate thresholds and noise metric (nmse) thresholds for switching to
<span class="lineNum">     442 </span>            :   // aggressive mode.
<span class="lineNum">     443 </span>            :   // TODO(marpan): Adjust thresholds, including effect on resolution.
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   denoiser-&gt;bitrate_threshold = 400000;  // (bits/sec).</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   denoiser-&gt;threshold_aggressive_mode = 80;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if (width * height &gt; 1280 * 720) {</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     denoiser-&gt;bitrate_threshold = 3000000;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     denoiser-&gt;threshold_aggressive_mode = 200;</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   } else if (width * height &gt; 960 * 540) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     denoiser-&gt;bitrate_threshold = 1200000;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     denoiser-&gt;threshold_aggressive_mode = 120;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   } else if (width * height &gt; 640 * 480) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     denoiser-&gt;bitrate_threshold = 600000;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     denoiser-&gt;threshold_aggressive_mode = 100;</span>
<span class="lineNum">     455 </span>            :   }
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="457"><span class="lineNum">     457 </span>            : }</a>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 : void vp8_denoiser_free(VP8_DENOISER *denoiser) {</span>
<span class="lineNum">     460 </span>            :   int i;
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   assert(denoiser);</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; MAX_REF_FRAMES; ++i) {</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     vp8_yv12_de_alloc_frame_buffer(&amp;denoiser-&gt;yv12_running_avg[i]);</span>
<span class="lineNum">     465 </span>            :   }
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   vp8_yv12_de_alloc_frame_buffer(&amp;denoiser-&gt;yv12_mc_running_avg);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   vp8_yv12_de_alloc_frame_buffer(&amp;denoiser-&gt;yv12_last_source);</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   vpx_free(denoiser-&gt;denoise_state);</span>
<a name="469"><span class="lineNum">     469 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 : void vp8_denoiser_denoise_mb(VP8_DENOISER *denoiser, MACROBLOCK *x,</span>
<span class="lineNum">     472 </span>            :                              unsigned int best_sse, unsigned int zero_mv_sse,
<span class="lineNum">     473 </span>            :                              int recon_yoffset, int recon_uvoffset,
<span class="lineNum">     474 </span>            :                              loop_filter_info_n *lfi_n, int mb_row, int mb_col,
<span class="lineNum">     475 </span>            :                              int block_index, int consec_zero_last)
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span>            :   int mv_row;
<span class="lineNum">     479 </span>            :   int mv_col;
<span class="lineNum">     480 </span>            :   unsigned int motion_threshold;
<span class="lineNum">     481 </span>            :   unsigned int motion_magnitude2;
<span class="lineNum">     482 </span>            :   unsigned int sse_thresh;
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   int sse_diff_thresh = 0;</span>
<span class="lineNum">     484 </span>            :   // Spatial loop filter: only applied selectively based on
<span class="lineNum">     485 </span>            :   // temporal filter state of block relative to top/left neighbors.
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   int apply_spatial_loop_filter = 1;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   MV_REFERENCE_FRAME frame = x-&gt;best_reference_frame;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   MV_REFERENCE_FRAME zero_frame = x-&gt;best_zeromv_reference_frame;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   enum vp8_denoiser_decision decision = FILTER_BLOCK;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   enum vp8_denoiser_decision decision_u = COPY_BLOCK;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   enum vp8_denoiser_decision decision_v = COPY_BLOCK;</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   if (zero_frame) {</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     YV12_BUFFER_CONFIG *src = &amp;denoiser-&gt;yv12_running_avg[frame];</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     YV12_BUFFER_CONFIG *dst = &amp;denoiser-&gt;yv12_mc_running_avg;</span>
<span class="lineNum">     497 </span>            :     YV12_BUFFER_CONFIG saved_pre, saved_dst;
<span class="lineNum">     498 </span>            :     MB_MODE_INFO saved_mbmi;
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     MACROBLOCKD *filter_xd = &amp;x-&gt;e_mbd;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     MB_MODE_INFO *mbmi = &amp;filter_xd-&gt;mode_info_context-&gt;mbmi;</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     int sse_diff = 0;</span>
<span class="lineNum">     502 </span>            :     // Bias on zero motion vector sse.
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     const int zero_bias = denoiser-&gt;denoise_pars.denoise_mv_bias;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     zero_mv_sse = (unsigned int)((int64_t)zero_mv_sse * zero_bias / 100);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     sse_diff = (int)zero_mv_sse - (int)best_sse;</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     saved_mbmi = *mbmi;</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :     /* Use the best MV for the compensation. */
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     mbmi-&gt;ref_frame = x-&gt;best_reference_frame;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     mbmi-&gt;mode = x-&gt;best_sse_inter_mode;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     mbmi-&gt;mv = x-&gt;best_sse_mv;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     mbmi-&gt;need_to_clamp_mvs = x-&gt;need_to_clamp_best_mvs;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     mv_col = x-&gt;best_sse_mv.as_mv.col;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     mv_row = x-&gt;best_sse_mv.as_mv.row;</span>
<span class="lineNum">     516 </span>            :     // Bias to zero_mv if small amount of motion.
<span class="lineNum">     517 </span>            :     // Note sse_diff_thresh is intialized to zero, so this ensures
<span class="lineNum">     518 </span>            :     // we will always choose zero_mv for denoising if
<span class="lineNum">     519 </span>            :     // zero_mv_see &lt;= best_sse (i.e., sse_diff &lt;= 0).
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     if ((unsigned int)(mv_row * mv_row + mv_col * mv_col) &lt;=</span>
<span class="lineNum">     521 </span>            :         NOISE_MOTION_THRESHOLD) {
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       sse_diff_thresh = (int)SSE_DIFF_THRESHOLD;</span>
<span class="lineNum">     523 </span>            :     }
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     if (frame == INTRA_FRAME || sse_diff &lt;= sse_diff_thresh) {</span>
<span class="lineNum">     526 </span>            :       /*
<span class="lineNum">     527 </span>            :        * Handle intra blocks as referring to last frame with zero motion
<span class="lineNum">     528 </span>            :        * and let the absolute pixel difference affect the filter factor.
<span class="lineNum">     529 </span>            :        * Also consider small amount of motion as being random walk due
<span class="lineNum">     530 </span>            :        * to noise, if it doesn't mean that we get a much bigger error.
<span class="lineNum">     531 </span>            :        * Note that any changes to the mode info only affects the
<span class="lineNum">     532 </span>            :        * denoising.
<span class="lineNum">     533 </span>            :        */
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       x-&gt;denoise_zeromv = 1;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       mbmi-&gt;ref_frame = x-&gt;best_zeromv_reference_frame;</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       src = &amp;denoiser-&gt;yv12_running_avg[zero_frame];</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :       mbmi-&gt;mode = ZEROMV;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       mbmi-&gt;mv.as_int = 0;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       x-&gt;best_sse_inter_mode = ZEROMV;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       x-&gt;best_sse_mv.as_int = 0;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :       best_sse = zero_mv_sse;</span>
<span class="lineNum">     544 </span>            :     }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     mv_row = x-&gt;best_sse_mv.as_mv.row;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     mv_col = x-&gt;best_sse_mv.as_mv.col;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     motion_magnitude2 = mv_row * mv_row + mv_col * mv_col;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     motion_threshold =</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         denoiser-&gt;denoise_pars.scale_motion_thresh * NOISE_MOTION_THRESHOLD;</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     if (motion_magnitude2 &lt;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         denoiser-&gt;denoise_pars.scale_increase_filter * NOISE_MOTION_THRESHOLD) {</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       x-&gt;increase_denoising = 1;</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     sse_thresh = denoiser-&gt;denoise_pars.scale_sse_thresh * SSE_THRESHOLD;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     if (x-&gt;increase_denoising) {</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       sse_thresh = denoiser-&gt;denoise_pars.scale_sse_thresh * SSE_THRESHOLD_HIGH;</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     if (best_sse &gt; sse_thresh || motion_magnitude2 &gt; motion_threshold) {</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       decision = COPY_BLOCK;</span>
<span class="lineNum">     564 </span>            :     }
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :     // If block is considered skin, don't denoise if the block
<span class="lineNum">     567 </span>            :     // (1) is selected as non-zero motion for current frame, or
<span class="lineNum">     568 </span>            :     // (2) has not been selected as ZERO_LAST mode at least x past frames
<span class="lineNum">     569 </span>            :     // in a row.
<span class="lineNum">     570 </span>            :     // TODO(marpan): Parameter &quot;x&quot; should be varied with framerate.
<span class="lineNum">     571 </span>            :     // In particualar, should be reduced for layers (base layer/LAST).
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     if (x-&gt;is_skin &amp;&amp; (consec_zero_last &lt; 2 || motion_magnitude2 &gt; 0)) {</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :       decision = COPY_BLOCK;</span>
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     if (decision == FILTER_BLOCK) {</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       saved_pre = filter_xd-&gt;pre;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       saved_dst = filter_xd-&gt;dst;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :       /* Compensate the running average. */
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       filter_xd-&gt;pre.y_buffer = src-&gt;y_buffer + recon_yoffset;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       filter_xd-&gt;pre.u_buffer = src-&gt;u_buffer + recon_uvoffset;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       filter_xd-&gt;pre.v_buffer = src-&gt;v_buffer + recon_uvoffset;</span>
<span class="lineNum">     584 </span>            :       /* Write the compensated running average to the destination buffer. */
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       filter_xd-&gt;dst.y_buffer = dst-&gt;y_buffer + recon_yoffset;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       filter_xd-&gt;dst.u_buffer = dst-&gt;u_buffer + recon_uvoffset;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       filter_xd-&gt;dst.v_buffer = dst-&gt;v_buffer + recon_uvoffset;</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       if (!x-&gt;skip) {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         vp8_build_inter_predictors_mb(filter_xd);</span>
<span class="lineNum">     591 </span>            :       } else {
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :         vp8_build_inter16x16_predictors_mb(</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :             filter_xd, filter_xd-&gt;dst.y_buffer, filter_xd-&gt;dst.u_buffer,</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :             filter_xd-&gt;dst.v_buffer, filter_xd-&gt;dst.y_stride,</span>
<span class="lineNum">     595 </span>            :             filter_xd-&gt;dst.uv_stride);
<span class="lineNum">     596 </span>            :       }
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       filter_xd-&gt;pre = saved_pre;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       filter_xd-&gt;dst = saved_dst;</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       *mbmi = saved_mbmi;</span>
<span class="lineNum">     600 </span>            :     }
<span class="lineNum">     601 </span>            :   } else {
<span class="lineNum">     602 </span>            :     // zero_frame should always be 1 for real-time mode, as the
<span class="lineNum">     603 </span>            :     // ZEROMV mode is always checked, so we should never go into this branch.
<span class="lineNum">     604 </span>            :     // If case ZEROMV is not checked, then we will force no denoise (COPY).
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     decision = COPY_BLOCK;</span>
<span class="lineNum">     606 </span>            :   }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   if (decision == FILTER_BLOCK) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     unsigned char *mc_running_avg_y =</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         denoiser-&gt;yv12_mc_running_avg.y_buffer + recon_yoffset;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     int mc_avg_y_stride = denoiser-&gt;yv12_mc_running_avg.y_stride;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     unsigned char *running_avg_y =</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_buffer + recon_yoffset;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     int avg_y_stride = denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_stride;</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :     /* Filter. */
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     decision = vp8_denoiser_filter(mc_running_avg_y, mc_avg_y_stride,</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                                    running_avg_y, avg_y_stride, x-&gt;thismb, 16,</span>
<span class="lineNum">     619 </span>            :                                    motion_magnitude2, x-&gt;increase_denoising);
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_state[block_index] =</span>
<span class="lineNum">     621 </span>            :         motion_magnitude2 &gt; 0 ? kFilterNonZeroMV : kFilterZeroMV;
<span class="lineNum">     622 </span>            :     // Only denoise UV for zero motion, and if y channel was denoised.
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     if (denoiser-&gt;denoiser_mode != kDenoiserOnYOnly &amp;&amp; motion_magnitude2 == 0 &amp;&amp;</span>
<span class="lineNum">     624 </span>            :         decision == FILTER_BLOCK) {
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       unsigned char *mc_running_avg_u =</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_mc_running_avg.u_buffer + recon_uvoffset;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       unsigned char *running_avg_u =</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].u_buffer + recon_uvoffset;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       unsigned char *mc_running_avg_v =</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_mc_running_avg.v_buffer + recon_uvoffset;</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       unsigned char *running_avg_v =</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].v_buffer + recon_uvoffset;</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :       int mc_avg_uv_stride = denoiser-&gt;yv12_mc_running_avg.uv_stride;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       int avg_uv_stride = denoiser-&gt;yv12_running_avg[INTRA_FRAME].uv_stride;</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       int signal_stride = x-&gt;block[16].src_stride;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       decision_u = vp8_denoiser_filter_uv(</span>
<span class="lineNum">     637 </span>            :           mc_running_avg_u, mc_avg_uv_stride, running_avg_u, avg_uv_stride,
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :           x-&gt;block[16].src + *x-&gt;block[16].base_src, signal_stride,</span>
<span class="lineNum">     639 </span>            :           motion_magnitude2, 0);
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       decision_v = vp8_denoiser_filter_uv(</span>
<span class="lineNum">     641 </span>            :           mc_running_avg_v, mc_avg_uv_stride, running_avg_v, avg_uv_stride,
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :           x-&gt;block[20].src + *x-&gt;block[20].base_src, signal_stride,</span>
<span class="lineNum">     643 </span>            :           motion_magnitude2, 0);
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span>            :   }
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   if (decision == COPY_BLOCK) {</span>
<span class="lineNum">     647 </span>            :     /* No filtering of this block; it differs too much from the predictor,
<span class="lineNum">     648 </span>            :      * or the motion vector magnitude is considered too big.
<span class="lineNum">     649 </span>            :      */
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     x-&gt;denoise_zeromv = 0;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     vp8_copy_mem16x16(</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :         x-&gt;thismb, 16,</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_buffer + recon_yoffset,</span>
<span class="lineNum">     654 </span>            :         denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_stride);
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :     denoiser-&gt;denoise_state[block_index] = kNoFilter;</span>
<span class="lineNum">     656 </span>            :   }
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   if (denoiser-&gt;denoiser_mode != kDenoiserOnYOnly) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     if (decision_u == COPY_BLOCK) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       vp8_copy_mem8x8(</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :           x-&gt;block[16].src + *x-&gt;block[16].base_src, x-&gt;block[16].src_stride,</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].u_buffer + recon_uvoffset,</span>
<span class="lineNum">     662 </span>            :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].uv_stride);
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     if (decision_v == COPY_BLOCK) {</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       vp8_copy_mem8x8(</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :           x-&gt;block[20].src + *x-&gt;block[20].base_src, x-&gt;block[16].src_stride,</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].v_buffer + recon_uvoffset,</span>
<span class="lineNum">     668 </span>            :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].uv_stride);
<span class="lineNum">     669 </span>            :     }
<span class="lineNum">     670 </span>            :   }
<span class="lineNum">     671 </span>            :   // Option to selectively deblock the denoised signal, for y channel only.
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   if (apply_spatial_loop_filter) {</span>
<span class="lineNum">     673 </span>            :     loop_filter_info lfi;
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     int apply_filter_col = 0;</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     int apply_filter_row = 0;</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     int apply_filter = 0;</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     int y_stride = denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_stride;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     int uv_stride = denoiser-&gt;yv12_running_avg[INTRA_FRAME].uv_stride;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :     // Fix filter level to some nominal value for now.
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     int filter_level = 48;</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     int hev_index = lfi_n-&gt;hev_thr_lut[INTER_FRAME][filter_level];</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     lfi.mblim = lfi_n-&gt;mblim[filter_level];</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     lfi.blim = lfi_n-&gt;blim[filter_level];</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     lfi.lim = lfi_n-&gt;lim[filter_level];</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     lfi.hev_thr = lfi_n-&gt;hev_thr[hev_index];</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :     // Apply filter if there is a difference in the denoiser filter state
<span class="lineNum">     690 </span>            :     // between the current and left/top block, or if non-zero motion vector
<span class="lineNum">     691 </span>            :     // is used for the motion-compensated filtering.
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     if (mb_col &gt; 0) {</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       apply_filter_col =</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :           !((denoiser-&gt;denoise_state[block_index] ==</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :              denoiser-&gt;denoise_state[block_index - 1]) &amp;&amp;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :             denoiser-&gt;denoise_state[block_index] != kFilterNonZeroMV);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       if (apply_filter_col) {</span>
<span class="lineNum">     698 </span>            :         // Filter left vertical edge.
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         apply_filter = 1;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         vp8_loop_filter_mbv(</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :             denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_buffer + recon_yoffset,</span>
<span class="lineNum">     702 </span>            :             NULL, NULL, y_stride, uv_stride, &amp;lfi);
<span class="lineNum">     703 </span>            :       }
<span class="lineNum">     704 </span>            :     }
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     if (mb_row &gt; 0) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :       apply_filter_row =</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :           !((denoiser-&gt;denoise_state[block_index] ==</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :              denoiser-&gt;denoise_state[block_index - denoiser-&gt;num_mb_cols]) &amp;&amp;</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :             denoiser-&gt;denoise_state[block_index] != kFilterNonZeroMV);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       if (apply_filter_row) {</span>
<span class="lineNum">     711 </span>            :         // Filter top horizontal edge.
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         apply_filter = 1;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         vp8_loop_filter_mbh(</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :             denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_buffer + recon_yoffset,</span>
<span class="lineNum">     715 </span>            :             NULL, NULL, y_stride, uv_stride, &amp;lfi);
<span class="lineNum">     716 </span>            :       }
<span class="lineNum">     717 </span>            :     }
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     if (apply_filter) {</span>
<span class="lineNum">     719 </span>            :       // Update the signal block |x|. Pixel changes are only to top and/or
<span class="lineNum">     720 </span>            :       // left boundary pixels: can we avoid full block copy here.
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       vp8_copy_mem16x16(</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :           denoiser-&gt;yv12_running_avg[INTRA_FRAME].y_buffer + recon_yoffset,</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :           y_stride, x-&gt;thismb, 16);</span>
<span class="lineNum">     724 </span>            :     }
<span class="lineNum">     725 </span>            :   }
<span class="lineNum">     726 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

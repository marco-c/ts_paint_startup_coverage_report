<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libvpx/libvpx/vp9/encoder/vp9_encoder.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">media/libvpx/libvpx/vp9/encoder</a> - vp9_encoder.h<span style="font-size: 80%;"> (source / <a href="vp9_encoder.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">50</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *  Use of this source code is governed by a BSD-style license
<span class="lineNum">       5 </span>            :  *  that can be found in the LICENSE file in the root of the source
<span class="lineNum">       6 </span>            :  *  tree. An additional intellectual property rights grant can be found
<span class="lineNum">       7 </span>            :  *  in the file PATENTS.  All contributing project authors may
<span class="lineNum">       8 </span>            :  *  be found in the AUTHORS file in the root of the source tree.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #ifndef VP9_ENCODER_VP9_ENCODER_H_
<span class="lineNum">      12 </span>            : #define VP9_ENCODER_VP9_ENCODER_H_
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;./vpx_config.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;vpx/internal/vpx_codec_internal.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;vpx/vp8cx.h&quot;
<span class="lineNum">      19 </span>            : #if CONFIG_INTERNAL_STATS
<span class="lineNum">      20 </span>            : #include &quot;vpx_dsp/ssim.h&quot;
<span class="lineNum">      21 </span>            : #endif
<span class="lineNum">      22 </span>            : #include &quot;vpx_dsp/variance.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;vpx_ports/system_state.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;vpx_util/vpx_thread.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;vp9/common/vp9_alloccommon.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;vp9/common/vp9_ppflags.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;vp9/common/vp9_entropymode.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;vp9/common/vp9_thread_common.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;vp9/common/vp9_onyxc_int.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #include &quot;vp9/encoder/vp9_alt_ref_aq.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;vp9/encoder/vp9_aq_cyclicrefresh.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;vp9/encoder/vp9_context_tree.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;vp9/encoder/vp9_encodemb.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;vp9/encoder/vp9_firstpass.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;vp9/encoder/vp9_lookahead.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;vp9/encoder/vp9_mbgraph.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;vp9/encoder/vp9_mcomp.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;vp9/encoder/vp9_noise_estimate.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;vp9/encoder/vp9_quantize.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;vp9/encoder/vp9_ratectrl.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;vp9/encoder/vp9_rd.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;vp9/encoder/vp9_speed_features.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;vp9/encoder/vp9_svc_layercontext.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;vp9/encoder/vp9_tokenize.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #if CONFIG_VP9_TEMPORAL_DENOISING
<span class="lineNum">      49 </span>            : #include &quot;vp9/encoder/vp9_denoiser.h&quot;
<span class="lineNum">      50 </span>            : #endif
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : #ifdef __cplusplus
<span class="lineNum">      53 </span>            : extern &quot;C&quot; {
<span class="lineNum">      54 </span>            : #endif
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : // vp9 uses 10,000,000 ticks/second as time stamp
<span class="lineNum">      57 </span>            : #define TICKS_PER_SEC 10000000
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : typedef struct {
<span class="lineNum">      60 </span>            :   int nmvjointcost[MV_JOINTS];
<span class="lineNum">      61 </span>            :   int nmvcosts[2][MV_VALS];
<span class="lineNum">      62 </span>            :   int nmvcosts_hp[2][MV_VALS];
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :   vpx_prob segment_pred_probs[PREDICTION_PROBS];
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   unsigned char *last_frame_seg_map_copy;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :   // 0 = Intra, Last, GF, ARF
<span class="lineNum">      69 </span>            :   signed char last_ref_lf_deltas[MAX_REF_LF_DELTAS];
<span class="lineNum">      70 </span>            :   // 0 = ZERO_MV, MV
<span class="lineNum">      71 </span>            :   signed char last_mode_lf_deltas[MAX_MODE_LF_DELTAS];
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :   FRAME_CONTEXT fc;
<span class="lineNum">      74 </span>            : } CODING_CONTEXT;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : typedef enum {
<span class="lineNum">      77 </span>            :   // encode_breakout is disabled.
<span class="lineNum">      78 </span>            :   ENCODE_BREAKOUT_DISABLED = 0,
<span class="lineNum">      79 </span>            :   // encode_breakout is enabled.
<span class="lineNum">      80 </span>            :   ENCODE_BREAKOUT_ENABLED = 1,
<span class="lineNum">      81 </span>            :   // encode_breakout is enabled with small max_thresh limit.
<span class="lineNum">      82 </span>            :   ENCODE_BREAKOUT_LIMITED = 2
<span class="lineNum">      83 </span>            : } ENCODE_BREAKOUT_TYPE;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : typedef enum {
<span class="lineNum">      86 </span>            :   NORMAL = 0,
<span class="lineNum">      87 </span>            :   FOURFIVE = 1,
<span class="lineNum">      88 </span>            :   THREEFIVE = 2,
<span class="lineNum">      89 </span>            :   ONETWO = 3
<span class="lineNum">      90 </span>            : } VPX_SCALING;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : typedef enum {
<span class="lineNum">      93 </span>            :   // Good Quality Fast Encoding. The encoder balances quality with the amount of
<span class="lineNum">      94 </span>            :   // time it takes to encode the output. Speed setting controls how fast.
<span class="lineNum">      95 </span>            :   GOOD,
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   // The encoder places priority on the quality of the output over encoding
<span class="lineNum">      98 </span>            :   // speed. The output is compressed at the highest possible quality. This
<span class="lineNum">      99 </span>            :   // option takes the longest amount of time to encode. Speed setting ignored.
<span class="lineNum">     100 </span>            :   BEST,
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   // Realtime/Live Encoding. This mode is optimized for realtime encoding (for
<span class="lineNum">     103 </span>            :   // example, capturing a television signal or feed from a live camera). Speed
<span class="lineNum">     104 </span>            :   // setting controls how fast.
<span class="lineNum">     105 </span>            :   REALTIME
<span class="lineNum">     106 </span>            : } MODE;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : typedef enum {
<span class="lineNum">     109 </span>            :   FRAMEFLAGS_KEY = 1 &lt;&lt; 0,
<span class="lineNum">     110 </span>            :   FRAMEFLAGS_GOLDEN = 1 &lt;&lt; 1,
<span class="lineNum">     111 </span>            :   FRAMEFLAGS_ALTREF = 1 &lt;&lt; 2,
<span class="lineNum">     112 </span>            : } FRAMETYPE_FLAGS;
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : typedef enum {
<span class="lineNum">     115 </span>            :   NO_AQ = 0,
<span class="lineNum">     116 </span>            :   VARIANCE_AQ = 1,
<span class="lineNum">     117 </span>            :   COMPLEXITY_AQ = 2,
<span class="lineNum">     118 </span>            :   CYCLIC_REFRESH_AQ = 3,
<span class="lineNum">     119 </span>            :   EQUATOR360_AQ = 4,
<span class="lineNum">     120 </span>            :   // AQ based on lookahead temporal
<span class="lineNum">     121 </span>            :   // variance (only valid for altref frames)
<span class="lineNum">     122 </span>            :   LOOKAHEAD_AQ = 5,
<span class="lineNum">     123 </span>            :   AQ_MODE_COUNT  // This should always be the last member of the enum
<span class="lineNum">     124 </span>            : } AQ_MODE;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : typedef enum {
<span class="lineNum">     127 </span>            :   RESIZE_NONE = 0,    // No frame resizing allowed (except for SVC).
<span class="lineNum">     128 </span>            :   RESIZE_FIXED = 1,   // All frames are coded at the specified dimension.
<span class="lineNum">     129 </span>            :   RESIZE_DYNAMIC = 2  // Coded size of each frame is determined by the codec.
<span class="lineNum">     130 </span>            : } RESIZE_TYPE;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : typedef struct VP9EncoderConfig {
<span class="lineNum">     133 </span>            :   BITSTREAM_PROFILE profile;
<span class="lineNum">     134 </span>            :   vpx_bit_depth_t bit_depth;     // Codec bit-depth.
<span class="lineNum">     135 </span>            :   int width;                     // width of data passed to the compressor
<span class="lineNum">     136 </span>            :   int height;                    // height of data passed to the compressor
<span class="lineNum">     137 </span>            :   unsigned int input_bit_depth;  // Input bit depth.
<span class="lineNum">     138 </span>            :   double init_framerate;         // set to passed in framerate
<span class="lineNum">     139 </span>            :   int64_t target_bandwidth;      // bandwidth to be used in bits per second
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :   int noise_sensitivity;  // pre processing blur: recommendation 0
<span class="lineNum">     142 </span>            :   int sharpness;          // sharpening output: recommendation 0:
<span class="lineNum">     143 </span>            :   int speed;
<span class="lineNum">     144 </span>            :   // maximum allowed bitrate for any intra frame in % of bitrate target.
<span class="lineNum">     145 </span>            :   unsigned int rc_max_intra_bitrate_pct;
<span class="lineNum">     146 </span>            :   // maximum allowed bitrate for any inter frame in % of bitrate target.
<span class="lineNum">     147 </span>            :   unsigned int rc_max_inter_bitrate_pct;
<span class="lineNum">     148 </span>            :   // percent of rate boost for golden frame in CBR mode.
<span class="lineNum">     149 </span>            :   unsigned int gf_cbr_boost_pct;
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :   MODE mode;
<span class="lineNum">     152 </span>            :   int pass;
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :   // Key Framing Operations
<span class="lineNum">     155 </span>            :   int auto_key;  // autodetect cut scenes and set the keyframes
<span class="lineNum">     156 </span>            :   int key_freq;  // maximum distance to key frame.
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :   int lag_in_frames;  // how many frames lag before we start encoding
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :   // ----------------------------------------------------------------
<span class="lineNum">     161 </span>            :   // DATARATE CONTROL OPTIONS
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   // vbr, cbr, constrained quality or constant quality
<span class="lineNum">     164 </span>            :   enum vpx_rc_mode rc_mode;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :   // buffer targeting aggressiveness
<span class="lineNum">     167 </span>            :   int under_shoot_pct;
<span class="lineNum">     168 </span>            :   int over_shoot_pct;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   // buffering parameters
<span class="lineNum">     171 </span>            :   int64_t starting_buffer_level_ms;
<span class="lineNum">     172 </span>            :   int64_t optimal_buffer_level_ms;
<span class="lineNum">     173 </span>            :   int64_t maximum_buffer_size_ms;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   // Frame drop threshold.
<span class="lineNum">     176 </span>            :   int drop_frames_water_mark;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   // controlling quality
<span class="lineNum">     179 </span>            :   int fixed_q;
<span class="lineNum">     180 </span>            :   int worst_allowed_q;
<span class="lineNum">     181 </span>            :   int best_allowed_q;
<span class="lineNum">     182 </span>            :   int cq_level;
<span class="lineNum">     183 </span>            :   AQ_MODE aq_mode;  // Adaptive Quantization mode
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :   // Special handling of Adaptive Quantization for AltRef frames
<span class="lineNum">     186 </span>            :   int alt_ref_aq;
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :   // Internal frame size scaling.
<span class="lineNum">     189 </span>            :   RESIZE_TYPE resize_mode;
<span class="lineNum">     190 </span>            :   int scaled_frame_width;
<span class="lineNum">     191 </span>            :   int scaled_frame_height;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   // Enable feature to reduce the frame quantization every x frames.
<span class="lineNum">     194 </span>            :   int frame_periodic_boost;
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   // two pass datarate control
<span class="lineNum">     197 </span>            :   int two_pass_vbrbias;  // two pass datarate control tweaks
<span class="lineNum">     198 </span>            :   int two_pass_vbrmin_section;
<span class="lineNum">     199 </span>            :   int two_pass_vbrmax_section;
<span class="lineNum">     200 </span>            :   // END DATARATE CONTROL OPTIONS
<span class="lineNum">     201 </span>            :   // ----------------------------------------------------------------
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   // Spatial and temporal scalability.
<span class="lineNum">     204 </span>            :   int ss_number_layers;  // Number of spatial layers.
<span class="lineNum">     205 </span>            :   int ts_number_layers;  // Number of temporal layers.
<span class="lineNum">     206 </span>            :   // Bitrate allocation for spatial layers.
<span class="lineNum">     207 </span>            :   int layer_target_bitrate[VPX_MAX_LAYERS];
<span class="lineNum">     208 </span>            :   int ss_target_bitrate[VPX_SS_MAX_LAYERS];
<span class="lineNum">     209 </span>            :   int ss_enable_auto_arf[VPX_SS_MAX_LAYERS];
<span class="lineNum">     210 </span>            :   // Bitrate allocation (CBR mode) and framerate factor, for temporal layers.
<span class="lineNum">     211 </span>            :   int ts_rate_decimator[VPX_TS_MAX_LAYERS];
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   int enable_auto_arf;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   int encode_breakout;  // early breakout : for video conf recommend 800
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   /* Bitfield defining the error resiliency features to enable.
<span class="lineNum">     218 </span>            :    * Can provide decodable frames after losses in previous
<span class="lineNum">     219 </span>            :    * frames and decodable partitions after losses in the same frame.
<span class="lineNum">     220 </span>            :    */
<span class="lineNum">     221 </span>            :   unsigned int error_resilient_mode;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   /* Bitfield defining the parallel decoding mode where the
<span class="lineNum">     224 </span>            :    * decoding in successive frames may be conducted in parallel
<span class="lineNum">     225 </span>            :    * just by decoding the frame headers.
<span class="lineNum">     226 </span>            :    */
<span class="lineNum">     227 </span>            :   unsigned int frame_parallel_decoding_mode;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   int arnr_max_frames;
<span class="lineNum">     230 </span>            :   int arnr_strength;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   int min_gf_interval;
<span class="lineNum">     233 </span>            :   int max_gf_interval;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   int tile_columns;
<span class="lineNum">     236 </span>            :   int tile_rows;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   int max_threads;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :   unsigned int target_level;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   vpx_fixed_buf_t two_pass_stats_in;
<span class="lineNum">     243 </span>            :   struct vpx_codec_pkt_list *output_pkt_list;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : #if CONFIG_FP_MB_STATS
<span class="lineNum">     246 </span>            :   vpx_fixed_buf_t firstpass_mb_stats_in;
<span class="lineNum">     247 </span>            : #endif
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   vp8e_tuning tuning;
<span class="lineNum">     250 </span>            :   vp9e_tune_content content;
<span class="lineNum">     251 </span>            : #if CONFIG_VP9_HIGHBITDEPTH
<span class="lineNum">     252 </span>            :   int use_highbitdepth;
<span class="lineNum">     253 </span>            : #endif
<span class="lineNum">     254 </span>            :   vpx_color_space_t color_space;
<span class="lineNum">     255 </span>            :   vpx_color_range_t color_range;
<span class="lineNum">     256 </span>            :   int render_width;
<span class="lineNum">     257 </span>            :   int render_height;
<span class="lineNum">     258 </span>            :   VP9E_TEMPORAL_LAYERING_MODE temporal_layering_mode;
<a name="259"><span class="lineNum">     259 </span>            : } VP9EncoderConfig;</a>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineNoCov">          0 : static INLINE int is_lossless_requested(const VP9EncoderConfig *cfg) {</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :   return cfg-&gt;best_allowed_q == 0 &amp;&amp; cfg-&gt;worst_allowed_q == 0;</span>
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : // TODO(jingning) All spatially adaptive variables should go to TileDataEnc.
<span class="lineNum">     266 </span>            : typedef struct TileDataEnc {
<span class="lineNum">     267 </span>            :   TileInfo tile_info;
<span class="lineNum">     268 </span>            :   int thresh_freq_fact[BLOCK_SIZES][MAX_MODES];
<span class="lineNum">     269 </span>            :   int mode_map[BLOCK_SIZES][MAX_MODES];
<span class="lineNum">     270 </span>            :   int m_search_count;
<span class="lineNum">     271 </span>            :   int ex_search_count;
<span class="lineNum">     272 </span>            : } TileDataEnc;
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : typedef struct RD_COUNTS {
<span class="lineNum">     275 </span>            :   vp9_coeff_count coef_counts[TX_SIZES][PLANE_TYPES];
<span class="lineNum">     276 </span>            :   int64_t comp_pred_diff[REFERENCE_MODES];
<span class="lineNum">     277 </span>            :   int64_t filter_diff[SWITCHABLE_FILTER_CONTEXTS];
<span class="lineNum">     278 </span>            : } RD_COUNTS;
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : typedef struct ThreadData {
<span class="lineNum">     281 </span>            :   MACROBLOCK mb;
<span class="lineNum">     282 </span>            :   RD_COUNTS rd_counts;
<span class="lineNum">     283 </span>            :   FRAME_COUNTS *counts;
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   PICK_MODE_CONTEXT *leaf_tree;
<span class="lineNum">     286 </span>            :   PC_TREE *pc_tree;
<span class="lineNum">     287 </span>            :   PC_TREE *pc_root;
<span class="lineNum">     288 </span>            : } ThreadData;
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : struct EncWorkerData;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : typedef struct ActiveMap {
<span class="lineNum">     293 </span>            :   int enabled;
<span class="lineNum">     294 </span>            :   int update;
<span class="lineNum">     295 </span>            :   unsigned char *map;
<span class="lineNum">     296 </span>            : } ActiveMap;
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : typedef enum { Y, U, V, ALL } STAT_TYPE;
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : typedef struct IMAGE_STAT {
<span class="lineNum">     301 </span>            :   double stat[ALL + 1];
<span class="lineNum">     302 </span>            :   double worst;
<span class="lineNum">     303 </span>            : } ImageStat;
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : // Kf noise filtering currently disabled by default in build.
<span class="lineNum">     306 </span>            : // #define ENABLE_KF_DENOISE 1
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : #define CPB_WINDOW_SIZE 4
<span class="lineNum">     309 </span>            : #define FRAME_WINDOW_SIZE 128
<span class="lineNum">     310 </span>            : #define SAMPLE_RATE_GRACE_P 0.015
<span class="lineNum">     311 </span>            : #define VP9_LEVELS 14
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : typedef enum {
<span class="lineNum">     314 </span>            :   LEVEL_UNKNOWN = 0,
<span class="lineNum">     315 </span>            :   LEVEL_1 = 10,
<span class="lineNum">     316 </span>            :   LEVEL_1_1 = 11,
<span class="lineNum">     317 </span>            :   LEVEL_2 = 20,
<span class="lineNum">     318 </span>            :   LEVEL_2_1 = 21,
<span class="lineNum">     319 </span>            :   LEVEL_3 = 30,
<span class="lineNum">     320 </span>            :   LEVEL_3_1 = 31,
<span class="lineNum">     321 </span>            :   LEVEL_4 = 40,
<span class="lineNum">     322 </span>            :   LEVEL_4_1 = 41,
<span class="lineNum">     323 </span>            :   LEVEL_5 = 50,
<span class="lineNum">     324 </span>            :   LEVEL_5_1 = 51,
<span class="lineNum">     325 </span>            :   LEVEL_5_2 = 52,
<span class="lineNum">     326 </span>            :   LEVEL_6 = 60,
<span class="lineNum">     327 </span>            :   LEVEL_6_1 = 61,
<span class="lineNum">     328 </span>            :   LEVEL_6_2 = 62,
<span class="lineNum">     329 </span>            :   LEVEL_MAX = 255
<span class="lineNum">     330 </span>            : } VP9_LEVEL;
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : typedef struct {
<span class="lineNum">     333 </span>            :   VP9_LEVEL level;
<span class="lineNum">     334 </span>            :   uint64_t max_luma_sample_rate;
<span class="lineNum">     335 </span>            :   uint32_t max_luma_picture_size;
<span class="lineNum">     336 </span>            :   double average_bitrate;  // in kilobits per second
<span class="lineNum">     337 </span>            :   double max_cpb_size;     // in kilobits
<span class="lineNum">     338 </span>            :   double compression_ratio;
<span class="lineNum">     339 </span>            :   uint8_t max_col_tiles;
<span class="lineNum">     340 </span>            :   uint32_t min_altref_distance;
<span class="lineNum">     341 </span>            :   uint8_t max_ref_frame_buffers;
<span class="lineNum">     342 </span>            : } Vp9LevelSpec;
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : extern const Vp9LevelSpec vp9_level_defs[VP9_LEVELS];
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : typedef struct {
<span class="lineNum">     347 </span>            :   int64_t ts;  // timestamp
<span class="lineNum">     348 </span>            :   uint32_t luma_samples;
<span class="lineNum">     349 </span>            :   uint32_t size;  // in bytes
<span class="lineNum">     350 </span>            : } FrameRecord;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : typedef struct {
<span class="lineNum">     353 </span>            :   FrameRecord buf[FRAME_WINDOW_SIZE];
<span class="lineNum">     354 </span>            :   uint8_t start;
<span class="lineNum">     355 </span>            :   uint8_t len;
<span class="lineNum">     356 </span>            : } FrameWindowBuffer;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : typedef struct {
<span class="lineNum">     359 </span>            :   uint8_t seen_first_altref;
<span class="lineNum">     360 </span>            :   uint32_t frames_since_last_altref;
<span class="lineNum">     361 </span>            :   uint64_t total_compressed_size;
<span class="lineNum">     362 </span>            :   uint64_t total_uncompressed_size;
<span class="lineNum">     363 </span>            :   double time_encoded;  // in seconds
<span class="lineNum">     364 </span>            :   FrameWindowBuffer frame_window_buffer;
<span class="lineNum">     365 </span>            :   int ref_refresh_map;
<span class="lineNum">     366 </span>            : } Vp9LevelStats;
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : typedef struct {
<span class="lineNum">     369 </span>            :   Vp9LevelStats level_stats;
<span class="lineNum">     370 </span>            :   Vp9LevelSpec level_spec;
<span class="lineNum">     371 </span>            : } Vp9LevelInfo;
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : typedef enum {
<span class="lineNum">     374 </span>            :   BITRATE_TOO_LARGE = 0,
<span class="lineNum">     375 </span>            :   LUMA_PIC_SIZE_TOO_LARGE = 1,
<span class="lineNum">     376 </span>            :   LUMA_SAMPLE_RATE_TOO_LARGE = 2,
<span class="lineNum">     377 </span>            :   CPB_TOO_LARGE = 3,
<span class="lineNum">     378 </span>            :   COMPRESSION_RATIO_TOO_SMALL = 4,
<span class="lineNum">     379 </span>            :   TOO_MANY_COLUMN_TILE = 5,
<span class="lineNum">     380 </span>            :   ALTREF_DIST_TOO_SMALL = 6,
<span class="lineNum">     381 </span>            :   TOO_MANY_REF_BUFFER = 7,
<span class="lineNum">     382 </span>            :   TARGET_LEVEL_FAIL_IDS = 8
<span class="lineNum">     383 </span>            : } TARGET_LEVEL_FAIL_ID;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : typedef struct {
<span class="lineNum">     386 </span>            :   int8_t level_index;
<span class="lineNum">     387 </span>            :   uint8_t rc_config_updated;
<span class="lineNum">     388 </span>            :   uint8_t fail_flag;
<span class="lineNum">     389 </span>            :   int max_frame_size;   // in bits
<span class="lineNum">     390 </span>            :   double max_cpb_size;  // in bits
<span class="lineNum">     391 </span>            : } LevelConstraint;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : typedef struct VP9_COMP {
<span class="lineNum">     394 </span>            :   QUANTS quants;
<span class="lineNum">     395 </span>            :   ThreadData td;
<span class="lineNum">     396 </span>            :   MB_MODE_INFO_EXT *mbmi_ext_base;
<span class="lineNum">     397 </span>            :   DECLARE_ALIGNED(16, int16_t, y_dequant[QINDEX_RANGE][8]);
<span class="lineNum">     398 </span>            :   DECLARE_ALIGNED(16, int16_t, uv_dequant[QINDEX_RANGE][8]);
<span class="lineNum">     399 </span>            :   VP9_COMMON common;
<span class="lineNum">     400 </span>            :   VP9EncoderConfig oxcf;
<span class="lineNum">     401 </span>            :   struct lookahead_ctx *lookahead;
<span class="lineNum">     402 </span>            :   struct lookahead_entry *alt_ref_source;
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   YV12_BUFFER_CONFIG *Source;
<span class="lineNum">     405 </span>            :   YV12_BUFFER_CONFIG *Last_Source;  // NULL for first frame and alt_ref frames
<span class="lineNum">     406 </span>            :   YV12_BUFFER_CONFIG *un_scaled_source;
<span class="lineNum">     407 </span>            :   YV12_BUFFER_CONFIG scaled_source;
<span class="lineNum">     408 </span>            :   YV12_BUFFER_CONFIG *unscaled_last_source;
<span class="lineNum">     409 </span>            :   YV12_BUFFER_CONFIG scaled_last_source;
<span class="lineNum">     410 </span>            : #ifdef ENABLE_KF_DENOISE
<span class="lineNum">     411 </span>            :   YV12_BUFFER_CONFIG raw_unscaled_source;
<span class="lineNum">     412 </span>            :   YV12_BUFFER_CONFIG raw_scaled_source;
<span class="lineNum">     413 </span>            : #endif
<span class="lineNum">     414 </span>            :   YV12_BUFFER_CONFIG *raw_source_frame;
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   TileDataEnc *tile_data;
<span class="lineNum">     417 </span>            :   int allocated_tiles;  // Keep track of memory allocated for tiles.
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   // For a still frame, this flag is set to 1 to skip partition search.
<span class="lineNum">     420 </span>            :   int partition_search_skippable_frame;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   int scaled_ref_idx[MAX_REF_FRAMES];
<span class="lineNum">     423 </span>            :   int lst_fb_idx;
<span class="lineNum">     424 </span>            :   int gld_fb_idx;
<span class="lineNum">     425 </span>            :   int alt_fb_idx;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   int refresh_last_frame;
<span class="lineNum">     428 </span>            :   int refresh_golden_frame;
<span class="lineNum">     429 </span>            :   int refresh_alt_ref_frame;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   int ext_refresh_frame_flags_pending;
<span class="lineNum">     432 </span>            :   int ext_refresh_last_frame;
<span class="lineNum">     433 </span>            :   int ext_refresh_golden_frame;
<span class="lineNum">     434 </span>            :   int ext_refresh_alt_ref_frame;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   int ext_refresh_frame_context_pending;
<span class="lineNum">     437 </span>            :   int ext_refresh_frame_context;
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :   YV12_BUFFER_CONFIG last_frame_uf;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :   TOKENEXTRA *tile_tok[4][1 &lt;&lt; 6];
<span class="lineNum">     442 </span>            :   uint32_t tok_count[4][1 &lt;&lt; 6];
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   // Ambient reconstruction err target for force key frames
<span class="lineNum">     445 </span>            :   int64_t ambient_err;
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   RD_OPT rd;
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   CODING_CONTEXT coding_context;
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :   int *nmvcosts[2];
<span class="lineNum">     452 </span>            :   int *nmvcosts_hp[2];
<span class="lineNum">     453 </span>            :   int *nmvsadcosts[2];
<span class="lineNum">     454 </span>            :   int *nmvsadcosts_hp[2];
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   int64_t last_time_stamp_seen;
<span class="lineNum">     457 </span>            :   int64_t last_end_time_stamp_seen;
<span class="lineNum">     458 </span>            :   int64_t first_time_stamp_ever;
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :   RATE_CONTROL rc;
<span class="lineNum">     461 </span>            :   double framerate;
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :   int interp_filter_selected[MAX_REF_FRAMES][SWITCHABLE];
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   struct vpx_codec_pkt_list *output_pkt_list;
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :   MBGRAPH_FRAME_STATS mbgraph_stats[MAX_LAG_BUFFERS];
<span class="lineNum">     468 </span>            :   int mbgraph_n_frames;  // number of frames filled in the above
<span class="lineNum">     469 </span>            :   int static_mb_pct;     // % forced skip mbs by segmentation
<span class="lineNum">     470 </span>            :   int ref_frame_flags;
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   SPEED_FEATURES sf;
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :   uint32_t max_mv_magnitude;
<span class="lineNum">     475 </span>            :   int mv_step_param;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   int allow_comp_inter_inter;
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :   // Default value is 1. From first pass stats, encode_breakout may be disabled.
<span class="lineNum">     480 </span>            :   ENCODE_BREAKOUT_TYPE allow_encode_breakout;
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :   // Get threshold from external input. A suggested threshold is 800 for HD
<span class="lineNum">     483 </span>            :   // clips, and 300 for &lt; HD clips.
<span class="lineNum">     484 </span>            :   int encode_breakout;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   uint8_t *segmentation_map;
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :   // segment threashold for encode breakout
<span class="lineNum">     489 </span>            :   int segment_encode_breakout[MAX_SEGMENTS];
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   CYCLIC_REFRESH *cyclic_refresh;
<span class="lineNum">     492 </span>            :   ActiveMap active_map;
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :   fractional_mv_step_fp *find_fractional_mv_step;
<span class="lineNum">     495 </span>            :   vp9_full_search_fn_t full_search_sad;
<span class="lineNum">     496 </span>            :   vp9_diamond_search_fn_t diamond_search_sad;
<span class="lineNum">     497 </span>            :   vp9_variance_fn_ptr_t fn_ptr[BLOCK_SIZES];
<span class="lineNum">     498 </span>            :   uint64_t time_receive_data;
<span class="lineNum">     499 </span>            :   uint64_t time_compress_data;
<span class="lineNum">     500 </span>            :   uint64_t time_pick_lpf;
<span class="lineNum">     501 </span>            :   uint64_t time_encode_sb_row;
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : #if CONFIG_FP_MB_STATS
<span class="lineNum">     504 </span>            :   int use_fp_mb_stats;
<span class="lineNum">     505 </span>            : #endif
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   TWO_PASS twopass;
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :   // Force recalculation of segment_ids for each mode info
<span class="lineNum">     510 </span>            :   uint8_t force_update_segmentation;
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   YV12_BUFFER_CONFIG alt_ref_buffer;
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :   // class responsible for adaptive
<span class="lineNum">     515 </span>            :   // quantization of altref frames
<span class="lineNum">     516 </span>            :   struct ALT_REF_AQ *alt_ref_aq;
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : #if CONFIG_INTERNAL_STATS
<span class="lineNum">     519 </span>            :   unsigned int mode_chosen_counts[MAX_MODES];
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :   int count;
<span class="lineNum">     522 </span>            :   uint64_t total_sq_error;
<span class="lineNum">     523 </span>            :   uint64_t total_samples;
<span class="lineNum">     524 </span>            :   ImageStat psnr;
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :   uint64_t totalp_sq_error;
<span class="lineNum">     527 </span>            :   uint64_t totalp_samples;
<span class="lineNum">     528 </span>            :   ImageStat psnrp;
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   double total_blockiness;
<span class="lineNum">     531 </span>            :   double worst_blockiness;
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :   int bytes;
<span class="lineNum">     534 </span>            :   double summed_quality;
<span class="lineNum">     535 </span>            :   double summed_weights;
<span class="lineNum">     536 </span>            :   double summedp_quality;
<span class="lineNum">     537 </span>            :   double summedp_weights;
<span class="lineNum">     538 </span>            :   unsigned int tot_recode_hits;
<span class="lineNum">     539 </span>            :   double worst_ssim;
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :   ImageStat ssimg;
<span class="lineNum">     542 </span>            :   ImageStat fastssim;
<span class="lineNum">     543 </span>            :   ImageStat psnrhvs;
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   int b_calculate_ssimg;
<span class="lineNum">     546 </span>            :   int b_calculate_blockiness;
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :   int b_calculate_consistency;
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   double total_inconsistency;
<span class="lineNum">     551 </span>            :   double worst_consistency;
<span class="lineNum">     552 </span>            :   Ssimv *ssim_vars;
<span class="lineNum">     553 </span>            :   Metrics metrics;
<span class="lineNum">     554 </span>            : #endif
<span class="lineNum">     555 </span>            :   int b_calculate_psnr;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :   int droppable;
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :   int initial_width;
<span class="lineNum">     560 </span>            :   int initial_height;
<span class="lineNum">     561 </span>            :   int initial_mbs;  // Number of MBs in the full-size frame; to be used to
<span class="lineNum">     562 </span>            :                     // normalize the firstpass stats. This will differ from the
<span class="lineNum">     563 </span>            :                     // number of MBs in the current frame when the frame is
<span class="lineNum">     564 </span>            :                     // scaled.
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :   int use_svc;
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :   SVC svc;
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   // Store frame variance info in SOURCE_VAR_BASED_PARTITION search type.
<span class="lineNum">     571 </span>            :   diff *source_diff_var;
<span class="lineNum">     572 </span>            :   // The threshold used in SOURCE_VAR_BASED_PARTITION search type.
<span class="lineNum">     573 </span>            :   unsigned int source_var_thresh;
<span class="lineNum">     574 </span>            :   int frames_till_next_var_check;
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :   int frame_flags;
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   search_site_config ss_cfg;
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   int mbmode_cost[INTRA_MODES];
<span class="lineNum">     581 </span>            :   unsigned int inter_mode_cost[INTER_MODE_CONTEXTS][INTER_MODES];
<span class="lineNum">     582 </span>            :   int intra_uv_mode_cost[FRAME_TYPES][INTRA_MODES][INTRA_MODES];
<span class="lineNum">     583 </span>            :   int y_mode_costs[INTRA_MODES][INTRA_MODES][INTRA_MODES];
<span class="lineNum">     584 </span>            :   int switchable_interp_costs[SWITCHABLE_FILTER_CONTEXTS][SWITCHABLE_FILTERS];
<span class="lineNum">     585 </span>            :   int partition_cost[PARTITION_CONTEXTS][PARTITION_TYPES];
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   int multi_arf_allowed;
<span class="lineNum">     588 </span>            :   int multi_arf_enabled;
<span class="lineNum">     589 </span>            :   int multi_arf_last_grp_enabled;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : #if CONFIG_VP9_TEMPORAL_DENOISING
<span class="lineNum">     592 </span>            :   VP9_DENOISER denoiser;
<span class="lineNum">     593 </span>            : #endif
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   int resize_pending;
<span class="lineNum">     596 </span>            :   int resize_state;
<span class="lineNum">     597 </span>            :   int external_resize;
<span class="lineNum">     598 </span>            :   int resize_scale_num;
<span class="lineNum">     599 </span>            :   int resize_scale_den;
<span class="lineNum">     600 </span>            :   int resize_avg_qp;
<span class="lineNum">     601 </span>            :   int resize_buffer_underflow;
<span class="lineNum">     602 </span>            :   int resize_count;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   int use_skin_detection;
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :   int target_level;
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :   NOISE_ESTIMATE noise_estimate;
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :   // Count on how many consecutive times a block uses small/zeromv for encoding.
<span class="lineNum">     611 </span>            :   uint8_t *consec_zero_mv;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :   // VAR_BASED_PARTITION thresholds
<span class="lineNum">     614 </span>            :   // 0 - threshold_64x64; 1 - threshold_32x32;
<span class="lineNum">     615 </span>            :   // 2 - threshold_16x16; 3 - vbp_threshold_8x8;
<span class="lineNum">     616 </span>            :   int64_t vbp_thresholds[4];
<span class="lineNum">     617 </span>            :   int64_t vbp_threshold_minmax;
<span class="lineNum">     618 </span>            :   int64_t vbp_threshold_sad;
<span class="lineNum">     619 </span>            :   // Threshold used for partition copy
<span class="lineNum">     620 </span>            :   int64_t vbp_threshold_copy;
<span class="lineNum">     621 </span>            :   BLOCK_SIZE vbp_bsize_min;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   // Multi-threading
<span class="lineNum">     624 </span>            :   int num_workers;
<span class="lineNum">     625 </span>            :   VPxWorker *workers;
<span class="lineNum">     626 </span>            :   struct EncWorkerData *tile_thr_data;
<span class="lineNum">     627 </span>            :   VP9LfSync lf_row_sync;
<span class="lineNum">     628 </span>            :   struct VP9BitstreamWorkerData *vp9_bitstream_worker_data;
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :   int keep_level_stats;
<span class="lineNum">     631 </span>            :   Vp9LevelInfo level_info;
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :   // Previous Partition Info
<span class="lineNum">     634 </span>            :   BLOCK_SIZE *prev_partition;
<span class="lineNum">     635 </span>            :   int8_t *prev_segment_id;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   LevelConstraint level_constraint;
<span class="lineNum">     638 </span>            : } VP9_COMP;
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : void vp9_initialize_enc(void);
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : struct VP9_COMP *vp9_create_compressor(VP9EncoderConfig *oxcf,
<span class="lineNum">     643 </span>            :                                        BufferPool *const pool);
<span class="lineNum">     644 </span>            : void vp9_remove_compressor(VP9_COMP *cpi);
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : void vp9_change_config(VP9_COMP *cpi, const VP9EncoderConfig *oxcf);
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : // receive a frames worth of data. caller can assume that a copy of this
<span class="lineNum">     649 </span>            : // frame is made and not just a copy of the pointer..
<span class="lineNum">     650 </span>            : int vp9_receive_raw_frame(VP9_COMP *cpi, vpx_enc_frame_flags_t frame_flags,
<span class="lineNum">     651 </span>            :                           YV12_BUFFER_CONFIG *sd, int64_t time_stamp,
<span class="lineNum">     652 </span>            :                           int64_t end_time_stamp);
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : int vp9_get_compressed_data(VP9_COMP *cpi, unsigned int *frame_flags,
<span class="lineNum">     655 </span>            :                             size_t *size, uint8_t *dest, int64_t *time_stamp,
<span class="lineNum">     656 </span>            :                             int64_t *time_end, int flush);
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            : int vp9_get_preview_raw_frame(VP9_COMP *cpi, YV12_BUFFER_CONFIG *dest,
<span class="lineNum">     659 </span>            :                               vp9_ppflags_t *flags);
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : int vp9_use_as_reference(VP9_COMP *cpi, int ref_frame_flags);
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : void vp9_update_reference(VP9_COMP *cpi, int ref_frame_flags);
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : int vp9_copy_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,
<span class="lineNum">     666 </span>            :                            YV12_BUFFER_CONFIG *sd);
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : int vp9_set_reference_enc(VP9_COMP *cpi, VP9_REFFRAME ref_frame_flag,
<span class="lineNum">     669 </span>            :                           YV12_BUFFER_CONFIG *sd);
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : int vp9_update_entropy(VP9_COMP *cpi, int update);
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : int vp9_set_active_map(VP9_COMP *cpi, unsigned char *map, int rows, int cols);
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : int vp9_get_active_map(VP9_COMP *cpi, unsigned char *map, int rows, int cols);
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : int vp9_set_internal_size(VP9_COMP *cpi, VPX_SCALING horiz_mode,
<span class="lineNum">     678 </span>            :                           VPX_SCALING vert_mode);
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : int vp9_set_size_literal(VP9_COMP *cpi, unsigned int width,
<span class="lineNum">     681 </span>            :                          unsigned int height);
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : void vp9_set_svc(VP9_COMP *cpi, int use_svc);
<span class="lineNum">     684 </span>            : 
<a name="685"><span class="lineNum">     685 </span>            : int vp9_get_quantizer(struct VP9_COMP *cpi);</a>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : static INLINE int frame_is_kf_gf_arf(const VP9_COMP *cpi) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   return frame_is_intra_only(&amp;cpi-&gt;common) || cpi-&gt;refresh_alt_ref_frame ||</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :          (cpi-&gt;refresh_golden_frame &amp;&amp; !cpi-&gt;rc.is_src_frame_alt_ref);</span>
<a name="690"><span class="lineNum">     690 </span>            : }</a>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 : static INLINE int get_ref_frame_map_idx(const VP9_COMP *cpi,</span>
<span class="lineNum">     693 </span>            :                                         MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   if (ref_frame == LAST_FRAME) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     return cpi-&gt;lst_fb_idx;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   } else if (ref_frame == GOLDEN_FRAME) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     return cpi-&gt;gld_fb_idx;</span>
<span class="lineNum">     698 </span>            :   } else {
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     return cpi-&gt;alt_fb_idx;</span>
<span class="lineNum">     700 </span>            :   }
<a name="701"><span class="lineNum">     701 </span>            : }</a>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 : static INLINE int get_ref_frame_buf_idx(const VP9_COMP *const cpi,</span>
<span class="lineNum">     704 </span>            :                                         int ref_frame) {
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   const VP9_COMMON *const cm = &amp;cpi-&gt;common;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   const int map_idx = get_ref_frame_map_idx(cpi, ref_frame);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   return (map_idx != INVALID_IDX) ? cm-&gt;ref_frame_map[map_idx] : INVALID_IDX;</span>
<a name="708"><span class="lineNum">     708 </span>            : }</a>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineNoCov">          0 : static INLINE YV12_BUFFER_CONFIG *get_ref_frame_buffer(</span>
<span class="lineNum">     711 </span>            :     VP9_COMP *cpi, MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   VP9_COMMON *const cm = &amp;cpi-&gt;common;</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   return buf_idx != INVALID_IDX ? &amp;cm-&gt;buffer_pool-&gt;frame_bufs[buf_idx].buf</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :                                 : NULL;</span>
<a name="716"><span class="lineNum">     716 </span>            : }</a>
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineNoCov">          0 : static INLINE int get_token_alloc(int mb_rows, int mb_cols) {</span>
<span class="lineNum">     719 </span>            :   // TODO(JBB): double check we can't exceed this token count if we have a
<span class="lineNum">     720 </span>            :   // 32x32 transform crossing a boundary at a multiple of 16.
<span class="lineNum">     721 </span>            :   // mb_rows, cols are in units of 16 pixels. We assume 3 planes all at full
<span class="lineNum">     722 </span>            :   // resolution. We assume up to 1 token per pixel, and then allow
<span class="lineNum">     723 </span>            :   // a head room of 4.
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :   return mb_rows * mb_cols * (16 * 16 * 3 + 4);</span>
<span class="lineNum">     725 </span>            : }
<span class="lineNum">     726 </span>            : 
<a name="727"><span class="lineNum">     727 </span>            : // Get the allocated token size for a tile. It does the same calculation as in</a>
<span class="lineNum">     728 </span>            : // the frame token allocation.
<span class="lineNum">     729 </span><span class="lineNoCov">          0 : static INLINE int allocated_tokens(TileInfo tile) {</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   int tile_mb_rows = (tile.mi_row_end - tile.mi_row_start + 1) &gt;&gt; 1;</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   int tile_mb_cols = (tile.mi_col_end - tile.mi_col_start + 1) &gt;&gt; 1;</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   return get_token_alloc(tile_mb_rows, tile_mb_cols);</span>
<span class="lineNum">     734 </span>            : }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            : int64_t vp9_get_y_sse(const YV12_BUFFER_CONFIG *a, const YV12_BUFFER_CONFIG *b);
<span class="lineNum">     737 </span>            : #if CONFIG_VP9_HIGHBITDEPTH
<span class="lineNum">     738 </span>            : int64_t vp9_highbd_get_y_sse(const YV12_BUFFER_CONFIG *a,
<span class="lineNum">     739 </span>            :                              const YV12_BUFFER_CONFIG *b);
<span class="lineNum">     740 </span>            : #endif  // CONFIG_VP9_HIGHBITDEPTH
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : void vp9_scale_references(VP9_COMP *cpi);
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            : void vp9_update_reference_frames(VP9_COMP *cpi);
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            : void vp9_set_high_precision_mv(VP9_COMP *cpi, int allow_high_precision_mv);
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : YV12_BUFFER_CONFIG *vp9_svc_twostage_scale(VP9_COMMON *cm,
<span class="lineNum">     749 </span>            :                                            YV12_BUFFER_CONFIG *unscaled,
<span class="lineNum">     750 </span>            :                                            YV12_BUFFER_CONFIG *scaled,
<span class="lineNum">     751 </span>            :                                            YV12_BUFFER_CONFIG *scaled_temp);
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : YV12_BUFFER_CONFIG *vp9_scale_if_required(VP9_COMMON *cm,
<span class="lineNum">     754 </span>            :                                           YV12_BUFFER_CONFIG *unscaled,
<span class="lineNum">     755 </span>            :                                           YV12_BUFFER_CONFIG *scaled,
<span class="lineNum">     756 </span>            :                                           int use_normative_scaler);
<span class="lineNum">     757 </span>            : 
<a name="758"><span class="lineNum">     758 </span>            : void vp9_apply_encoding_flags(VP9_COMP *cpi, vpx_enc_frame_flags_t flags);</a>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineNoCov">          0 : static INLINE int is_two_pass_svc(const struct VP9_COMP *const cpi) {</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   return cpi-&gt;use_svc &amp;&amp; cpi-&gt;oxcf.pass != 0;</span>
<a name="762"><span class="lineNum">     762 </span>            : }</a>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 : static INLINE int is_one_pass_cbr_svc(const struct VP9_COMP *const cpi) {</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   return (cpi-&gt;use_svc &amp;&amp; cpi-&gt;oxcf.pass == 0);</span>
<a name="766"><span class="lineNum">     766 </span>            : }</a>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : static INLINE int is_altref_enabled(const VP9_COMP *const cpi) {</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   return !(cpi-&gt;oxcf.mode == REALTIME &amp;&amp; cpi-&gt;oxcf.rc_mode == VPX_CBR) &amp;&amp;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :          cpi-&gt;oxcf.lag_in_frames &gt; 0 &amp;&amp;</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :          (cpi-&gt;oxcf.enable_auto_arf &amp;&amp;</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           (!is_two_pass_svc(cpi) ||</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :            cpi-&gt;oxcf.ss_enable_auto_arf[cpi-&gt;svc.spatial_layer_id]));</span>
<a name="774"><span class="lineNum">     774 </span>            : }</a>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineNoCov">          0 : static INLINE void set_ref_ptrs(VP9_COMMON *cm, MACROBLOCKD *xd,</span>
<span class="lineNum">     777 </span>            :                                 MV_REFERENCE_FRAME ref0,
<span class="lineNum">     778 </span>            :                                 MV_REFERENCE_FRAME ref1) {
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   xd-&gt;block_refs[0] =</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       &amp;cm-&gt;frame_refs[ref0 &gt;= LAST_FRAME ? ref0 - LAST_FRAME : 0];</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   xd-&gt;block_refs[1] =</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       &amp;cm-&gt;frame_refs[ref1 &gt;= LAST_FRAME ? ref1 - LAST_FRAME : 0];</span>
<a name="783"><span class="lineNum">     783 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineNoCov">          0 : static INLINE int get_chessboard_index(const int frame_index) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :   return frame_index &amp; 0x1;</span>
<a name="787"><span class="lineNum">     787 </span>            : }</a>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : static INLINE int *cond_cost_list(const struct VP9_COMP *cpi, int *cost_list) {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   return cpi-&gt;sf.mv.subpel_search_method != SUBPEL_TREE ? cost_list : NULL;</span>
<a name="791"><span class="lineNum">     791 </span>            : }</a>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 : static INLINE int get_level_index(VP9_LEVEL level) {</span>
<span class="lineNum">     794 </span>            :   int i;
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; VP9_LEVELS; ++i) {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     if (level == vp9_level_defs[i].level) return i;</span>
<span class="lineNum">     797 </span>            :   }
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">     799 </span>            : }
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : VP9_LEVEL vp9_get_level(const Vp9LevelSpec *const level_spec);
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : void vp9_new_framerate(VP9_COMP *cpi, double framerate);
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            : #define LAYER_IDS_TO_IDX(sl, tl, num_tl) ((sl) * (num_tl) + (tl))
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : #ifdef __cplusplus
<span class="lineNum">     808 </span>            : }  // extern &quot;C&quot;
<span class="lineNum">     809 </span>            : #endif
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : #endif  // VP9_ENCODER_VP9_ENCODER_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

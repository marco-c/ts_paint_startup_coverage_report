<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - media/libtheora/lib/state.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">media/libtheora/lib</a> - state.c<span style="font-size: 80%;"> (source / <a href="state.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">461</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /********************************************************************</a>
<span class="lineNum">       2 </span>            :  *                                                                  *
<span class="lineNum">       3 </span>            :  * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
<span class="lineNum">       4 </span>            :  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
<span class="lineNum">       5 </span>            :  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
<span class="lineNum">       6 </span>            :  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
<span class="lineNum">       7 </span>            :  *                                                                  *
<span class="lineNum">       8 </span>            :  * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2009                *
<span class="lineNum">       9 </span>            :  * by the Xiph.Org Foundation and contributors http://www.xiph.org/ *
<span class="lineNum">      10 </span>            :  *                                                                  *
<span class="lineNum">      11 </span>            :  ********************************************************************
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :   function:
<span class="lineNum">      14 </span>            :     last mod: $Id: state.c 17576 2010-10-29 01:07:51Z tterribe $
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  ********************************************************************/
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      20 </span>            : #include &quot;state.h&quot;
<span class="lineNum">      21 </span>            : #if defined(OC_DUMP_IMAGES)
<span class="lineNum">      22 </span>            : # include &lt;stdio.h&gt;
<span class="lineNum">      23 </span>            : # include &quot;png.h&quot;
<span class="lineNum">      24 </span>            : #endif
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /*The function used to fill in the chroma plane motion vectors for a macro
<span class="lineNum">      27 </span>            :    block when 4 different motion vectors are specified in the luma plane.
<span class="lineNum">      28 </span>            :   This version is for use with chroma decimated in the X and Y directions
<span class="lineNum">      29 </span>            :    (4:2:0).
<a name="30"><span class="lineNum">      30 </span>            :   _cbmvs: The chroma block-level motion vectors to fill in.</a>
<span class="lineNum">      31 </span>            :   _lbmvs: The luma block-level motion vectors.*/
<span class="lineNum">      32 </span><span class="lineNoCov">          0 : static void oc_set_chroma_mvs00(oc_mv _cbmvs[4],const oc_mv _lbmvs[4]){</span>
<span class="lineNum">      33 </span>            :   int dx;
<span class="lineNum">      34 </span>            :   int dy;
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_lbmvs[0])+OC_MV_X(_lbmvs[1])</span>
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :    +OC_MV_X(_lbmvs[2])+OC_MV_X(_lbmvs[3]);</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_lbmvs[0])+OC_MV_Y(_lbmvs[1])</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :    +OC_MV_Y(_lbmvs[2])+OC_MV_Y(_lbmvs[3]);</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   _cbmvs[0]=OC_MV(OC_DIV_ROUND_POW2(dx,2,2),OC_DIV_ROUND_POW2(dy,2,2));</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /*The function used to fill in the chroma plane motion vectors for a macro
<span class="lineNum">      43 </span>            :    block when 4 different motion vectors are specified in the luma plane.
<span class="lineNum">      44 </span>            :   This version is for use with chroma decimated in the Y direction.
<a name="45"><span class="lineNum">      45 </span>            :   _cbmvs: The chroma block-level motion vectors to fill in.</a>
<span class="lineNum">      46 </span>            :   _lbmvs: The luma block-level motion vectors.*/
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : static void oc_set_chroma_mvs01(oc_mv _cbmvs[4],const oc_mv _lbmvs[4]){</span>
<span class="lineNum">      48 </span>            :   int dx;
<span class="lineNum">      49 </span>            :   int dy;
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_lbmvs[0])+OC_MV_X(_lbmvs[2]);</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_lbmvs[0])+OC_MV_Y(_lbmvs[2]);</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   _cbmvs[0]=OC_MV(OC_DIV_ROUND_POW2(dx,1,1),OC_DIV_ROUND_POW2(dy,1,1));</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_lbmvs[1])+OC_MV_X(_lbmvs[3]);</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_lbmvs[1])+OC_MV_Y(_lbmvs[3]);</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   _cbmvs[1]=OC_MV(OC_DIV_ROUND_POW2(dx,1,1),OC_DIV_ROUND_POW2(dy,1,1));</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /*The function used to fill in the chroma plane motion vectors for a macro
<span class="lineNum">      59 </span>            :    block when 4 different motion vectors are specified in the luma plane.
<span class="lineNum">      60 </span>            :   This version is for use with chroma decimated in the X direction (4:2:2).
<a name="61"><span class="lineNum">      61 </span>            :   _cbmvs: The chroma block-level motion vectors to fill in.</a>
<span class="lineNum">      62 </span>            :   _lbmvs: The luma block-level motion vectors.*/
<span class="lineNum">      63 </span><span class="lineNoCov">          0 : static void oc_set_chroma_mvs10(oc_mv _cbmvs[4],const oc_mv _lbmvs[4]){</span>
<span class="lineNum">      64 </span>            :   int dx;
<span class="lineNum">      65 </span>            :   int dy;
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_lbmvs[0])+OC_MV_X(_lbmvs[1]);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_lbmvs[0])+OC_MV_Y(_lbmvs[1]);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   _cbmvs[0]=OC_MV(OC_DIV_ROUND_POW2(dx,1,1),OC_DIV_ROUND_POW2(dy,1,1));</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_lbmvs[2])+OC_MV_X(_lbmvs[3]);</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_lbmvs[2])+OC_MV_Y(_lbmvs[3]);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   _cbmvs[2]=OC_MV(OC_DIV_ROUND_POW2(dx,1,1),OC_DIV_ROUND_POW2(dy,1,1));</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /*The function used to fill in the chroma plane motion vectors for a macro
<span class="lineNum">      75 </span>            :    block when 4 different motion vectors are specified in the luma plane.
<span class="lineNum">      76 </span>            :   This version is for use with no chroma decimation (4:4:4).
<span class="lineNum">      77 </span>            :   _cbmvs: The chroma block-level motion vectors to fill in.
<span class="lineNum">      78 </span>            :   _lmbmv: The luma macro-block level motion vector to fill in for use in
<a name="79"><span class="lineNum">      79 </span>            :            prediction.</a>
<span class="lineNum">      80 </span>            :   _lbmvs: The luma block-level motion vectors.*/
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : static void oc_set_chroma_mvs11(oc_mv _cbmvs[4],const oc_mv _lbmvs[4]){</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   _cbmvs[0]=_lbmvs[0];</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   _cbmvs[1]=_lbmvs[1];</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   _cbmvs[2]=_lbmvs[2];</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   _cbmvs[3]=_lbmvs[3];</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /*A table of functions used to fill in the chroma plane motion vectors for a
<span class="lineNum">      89 </span>            :    macro block when 4 different motion vectors are specified in the luma
<span class="lineNum">      90 </span>            :    plane.*/
<span class="lineNum">      91 </span>            : const oc_set_chroma_mvs_func OC_SET_CHROMA_MVS_TABLE[TH_PF_NFORMATS]={
<span class="lineNum">      92 </span>            :   (oc_set_chroma_mvs_func)oc_set_chroma_mvs00,
<span class="lineNum">      93 </span>            :   (oc_set_chroma_mvs_func)oc_set_chroma_mvs01,
<span class="lineNum">      94 </span>            :   (oc_set_chroma_mvs_func)oc_set_chroma_mvs10,
<span class="lineNum">      95 </span>            :   (oc_set_chroma_mvs_func)oc_set_chroma_mvs11
<span class="lineNum">      96 </span>            : };
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : /*Returns the fragment index of the top-left block in a macro block.
<span class="lineNum">     101 </span>            :   This can be used to test whether or not the whole macro block is valid.
<span class="lineNum">     102 </span>            :   _sb_map: The super block map.
<span class="lineNum">     103 </span>            :   _quadi:  The quadrant number.
<a name="104"><span class="lineNum">     104 </span>            :   Return: The index of the fragment of the upper left block in the macro</a>
<span class="lineNum">     105 </span>            :    block, or -1 if the block lies outside the coded frame.*/
<span class="lineNum">     106 </span><span class="lineNoCov">          0 : static ptrdiff_t oc_sb_quad_top_left_frag(oc_sb_map_quad _sb_map[4],int _quadi){</span>
<span class="lineNum">     107 </span>            :   /*It so happens that under the Hilbert curve ordering described below, the
<span class="lineNum">     108 </span>            :      upper-left block in each macro block is at index 0, except in macro block
<span class="lineNum">     109 </span>            :      3, where it is at index 2.*/
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   return _sb_map[_quadi][_quadi&amp;_quadi&lt;&lt;1];</span>
<span class="lineNum">     111 </span>            : }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /*Fills in the mapping from block positions to fragment numbers for a single
<span class="lineNum">     114 </span>            :    color plane.
<span class="lineNum">     115 </span>            :   This function also fills in the &quot;valid&quot; flag of each quadrant in the super
<span class="lineNum">     116 </span>            :    block flags.
<span class="lineNum">     117 </span>            :   _sb_maps:  The array of super block maps for the color plane.
<span class="lineNum">     118 </span>            :   _sb_flags: The array of super block flags for the color plane.
<span class="lineNum">     119 </span>            :   _frag0:    The index of the first fragment in the plane.
<a name="120"><span class="lineNum">     120 </span>            :   _hfrags:   The number of horizontal fragments in a coded frame.</a>
<span class="lineNum">     121 </span>            :   _vfrags:   The number of vertical fragments in a coded frame.*/
<span class="lineNum">     122 </span><span class="lineNoCov">          0 : static void oc_sb_create_plane_mapping(oc_sb_map _sb_maps[],</span>
<span class="lineNum">     123 </span>            :  oc_sb_flags _sb_flags[],ptrdiff_t _frag0,int _hfrags,int _vfrags){
<span class="lineNum">     124 </span>            :   /*Contains the (macro_block,block) indices for a 4x4 grid of
<span class="lineNum">     125 </span>            :      fragments.
<span class="lineNum">     126 </span>            :     The pattern is a 4x4 Hilbert space-filling curve.
<span class="lineNum">     127 </span>            :     A Hilbert curve has the nice property that as the curve grows larger, its
<span class="lineNum">     128 </span>            :      fractal dimension approaches 2.
<span class="lineNum">     129 </span>            :     The intuition is that nearby blocks in the curve are also close spatially,
<span class="lineNum">     130 </span>            :      with the previous element always an immediate neighbor, so that runs of
<span class="lineNum">     131 </span>            :      blocks should be well correlated.*/
<span class="lineNum">     132 </span>            :   static const int SB_MAP[4][4][2]={
<span class="lineNum">     133 </span>            :     {{0,0},{0,1},{3,2},{3,3}},
<span class="lineNum">     134 </span>            :     {{0,3},{0,2},{3,1},{3,0}},
<span class="lineNum">     135 </span>            :     {{1,0},{1,3},{2,0},{2,3}},
<span class="lineNum">     136 </span>            :     {{1,1},{1,2},{2,1},{2,2}}
<span class="lineNum">     137 </span>            :   };
<span class="lineNum">     138 </span>            :   ptrdiff_t  yfrag;
<span class="lineNum">     139 </span>            :   unsigned   sbi;
<span class="lineNum">     140 </span>            :   int        y;
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   sbi=0;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   yfrag=_frag0;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   for(y=0;;y+=4){</span>
<span class="lineNum">     144 </span>            :     int imax;
<span class="lineNum">     145 </span>            :     int x;
<span class="lineNum">     146 </span>            :     /*Figure out how many columns of blocks in this super block lie within the
<span class="lineNum">     147 </span>            :        image.*/
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     imax=_vfrags-y;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     if(imax&gt;4)imax=4;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     else if(imax&lt;=0)break;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     for(x=0;;x+=4,sbi++){</span>
<span class="lineNum">     152 </span>            :       ptrdiff_t xfrag;
<span class="lineNum">     153 </span>            :       int       jmax;
<span class="lineNum">     154 </span>            :       int       quadi;
<span class="lineNum">     155 </span>            :       int       i;
<span class="lineNum">     156 </span>            :       /*Figure out how many rows of blocks in this super block lie within the
<span class="lineNum">     157 </span>            :          image.*/
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :       jmax=_hfrags-x;</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       if(jmax&gt;4)jmax=4;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       else if(jmax&lt;=0)break;</span>
<span class="lineNum">     161 </span>            :       /*By default, set all fragment indices to -1.*/
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       memset(_sb_maps[sbi],0xFF,sizeof(_sb_maps[sbi]));</span>
<span class="lineNum">     163 </span>            :       /*Fill in the fragment map for this super block.*/
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       xfrag=yfrag+x;</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;imax;i++){</span>
<span class="lineNum">     166 </span>            :         int j;
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         for(j=0;j&lt;jmax;j++){</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :           _sb_maps[sbi][SB_MAP[i][j][0]][SB_MAP[i][j][1]]=xfrag+j;</span>
<span class="lineNum">     169 </span>            :         }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         xfrag+=_hfrags;</span>
<span class="lineNum">     171 </span>            :       }
<span class="lineNum">     172 </span>            :       /*Mark which quadrants of this super block lie within the image.*/
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       for(quadi=0;quadi&lt;4;quadi++){</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :         _sb_flags[sbi].quad_valid|=</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :          (oc_sb_quad_top_left_frag(_sb_maps[sbi],quadi)&gt;=0)&lt;&lt;quadi;</span>
<span class="lineNum">     176 </span>            :       }
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     yfrag+=_hfrags&lt;&lt;2;</span>
<span class="lineNum">     179 </span>            :   }
<span class="lineNum">     180 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /*Fills in the Y plane fragment map for a macro block given the fragment
<span class="lineNum">     183 </span>            :    coordinates of its upper-left hand corner.
<span class="lineNum">     184 </span>            :   _mb_map:    The macro block map to fill.
<span class="lineNum">     185 </span>            :   _fplane: The description of the Y plane.
<a name="186"><span class="lineNum">     186 </span>            :   _xfrag0: The X location of the upper-left hand fragment in the luma plane.</a>
<span class="lineNum">     187 </span>            :   _yfrag0: The Y location of the upper-left hand fragment in the luma plane.*/
<span class="lineNum">     188 </span><span class="lineNoCov">          0 : static void oc_mb_fill_ymapping(oc_mb_map_plane _mb_map[3],</span>
<span class="lineNum">     189 </span>            :  const oc_fragment_plane *_fplane,int _xfrag0,int _yfrag0){
<span class="lineNum">     190 </span>            :   int i;
<span class="lineNum">     191 </span>            :   int j;
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;2;i++)for(j=0;j&lt;2;j++){</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     _mb_map[0][i&lt;&lt;1|j]=(_yfrag0+i)*(ptrdiff_t)_fplane-&gt;nhfrags+_xfrag0+j;</span>
<span class="lineNum">     194 </span>            :   }
<span class="lineNum">     195 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /*Fills in the chroma plane fragment maps for a macro block.
<span class="lineNum">     198 </span>            :   This version is for use with chroma decimated in the X and Y directions
<span class="lineNum">     199 </span>            :    (4:2:0).
<span class="lineNum">     200 </span>            :   _mb_map:  The macro block map to fill.
<span class="lineNum">     201 </span>            :   _fplanes: The descriptions of the fragment planes.
<a name="202"><span class="lineNum">     202 </span>            :   _xfrag0:  The X location of the upper-left hand fragment in the luma plane.</a>
<span class="lineNum">     203 </span>            :   _yfrag0:  The Y location of the upper-left hand fragment in the luma plane.*/
<span class="lineNum">     204 </span><span class="lineNoCov">          0 : static void oc_mb_fill_cmapping00(oc_mb_map_plane _mb_map[3],</span>
<span class="lineNum">     205 </span>            :  const oc_fragment_plane _fplanes[3],int _xfrag0,int _yfrag0){
<span class="lineNum">     206 </span>            :   ptrdiff_t fragi;
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   _xfrag0&gt;&gt;=1;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   _yfrag0&gt;&gt;=1;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   fragi=_yfrag0*(ptrdiff_t)_fplanes[1].nhfrags+_xfrag0;</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   _mb_map[1][0]=fragi+_fplanes[1].froffset;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   _mb_map[2][0]=fragi+_fplanes[2].froffset;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : /*Fills in the chroma plane fragment maps for a macro block.
<span class="lineNum">     215 </span>            :   This version is for use with chroma decimated in the Y direction.
<span class="lineNum">     216 </span>            :   _mb_map:  The macro block map to fill.
<span class="lineNum">     217 </span>            :   _fplanes: The descriptions of the fragment planes.
<a name="218"><span class="lineNum">     218 </span>            :   _xfrag0:  The X location of the upper-left hand fragment in the luma plane.</a>
<span class="lineNum">     219 </span>            :   _yfrag0:  The Y location of the upper-left hand fragment in the luma plane.*/
<span class="lineNum">     220 </span><span class="lineNoCov">          0 : static void oc_mb_fill_cmapping01(oc_mb_map_plane _mb_map[3],</span>
<span class="lineNum">     221 </span>            :  const oc_fragment_plane _fplanes[3],int _xfrag0,int _yfrag0){
<span class="lineNum">     222 </span>            :   ptrdiff_t fragi;
<span class="lineNum">     223 </span>            :   int       j;
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   _yfrag0&gt;&gt;=1;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :   fragi=_yfrag0*(ptrdiff_t)_fplanes[1].nhfrags+_xfrag0;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   for(j=0;j&lt;2;j++){</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     _mb_map[1][j]=fragi+_fplanes[1].froffset;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     _mb_map[2][j]=fragi+_fplanes[2].froffset;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     fragi++;</span>
<span class="lineNum">     230 </span>            :   }
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : /*Fills in the chroma plane fragment maps for a macro block.
<span class="lineNum">     234 </span>            :   This version is for use with chroma decimated in the X direction (4:2:2).
<span class="lineNum">     235 </span>            :   _mb_map:  The macro block map to fill.
<span class="lineNum">     236 </span>            :   _fplanes: The descriptions of the fragment planes.
<a name="237"><span class="lineNum">     237 </span>            :   _xfrag0:  The X location of the upper-left hand fragment in the luma plane.</a>
<span class="lineNum">     238 </span>            :   _yfrag0:  The Y location of the upper-left hand fragment in the luma plane.*/
<span class="lineNum">     239 </span><span class="lineNoCov">          0 : static void oc_mb_fill_cmapping10(oc_mb_map_plane _mb_map[3],</span>
<span class="lineNum">     240 </span>            :  const oc_fragment_plane _fplanes[3],int _xfrag0,int _yfrag0){
<span class="lineNum">     241 </span>            :   ptrdiff_t fragi;
<span class="lineNum">     242 </span>            :   int       i;
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :   _xfrag0&gt;&gt;=1;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :   fragi=_yfrag0*(ptrdiff_t)_fplanes[1].nhfrags+_xfrag0;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;2;i++){</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     _mb_map[1][i&lt;&lt;1]=fragi+_fplanes[1].froffset;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     _mb_map[2][i&lt;&lt;1]=fragi+_fplanes[2].froffset;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     fragi+=_fplanes[1].nhfrags;</span>
<span class="lineNum">     249 </span>            :   }
<span class="lineNum">     250 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : /*Fills in the chroma plane fragment maps for a macro block.
<span class="lineNum">     253 </span>            :   This version is for use with no chroma decimation (4:4:4).
<span class="lineNum">     254 </span>            :   This uses the already filled-in luma plane values.
<a name="255"><span class="lineNum">     255 </span>            :   _mb_map:  The macro block map to fill.</a>
<span class="lineNum">     256 </span>            :   _fplanes: The descriptions of the fragment planes.*/
<span class="lineNum">     257 </span><span class="lineNoCov">          0 : static void oc_mb_fill_cmapping11(oc_mb_map_plane _mb_map[3],</span>
<span class="lineNum">     258 </span>            :  const oc_fragment_plane _fplanes[3]){
<span class="lineNum">     259 </span>            :   int k;
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   for(k=0;k&lt;4;k++){</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     _mb_map[1][k]=_mb_map[0][k]+_fplanes[1].froffset;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     _mb_map[2][k]=_mb_map[0][k]+_fplanes[2].froffset;</span>
<span class="lineNum">     263 </span>            :   }
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : /*The function type used to fill in the chroma plane fragment maps for a
<span class="lineNum">     267 </span>            :    macro block.
<span class="lineNum">     268 </span>            :   _mb_map:  The macro block map to fill.
<span class="lineNum">     269 </span>            :   _fplanes: The descriptions of the fragment planes.
<span class="lineNum">     270 </span>            :   _xfrag0:  The X location of the upper-left hand fragment in the luma plane.
<span class="lineNum">     271 </span>            :   _yfrag0:  The Y location of the upper-left hand fragment in the luma plane.*/
<span class="lineNum">     272 </span>            : typedef void (*oc_mb_fill_cmapping_func)(oc_mb_map_plane _mb_map[3],
<span class="lineNum">     273 </span>            :  const oc_fragment_plane _fplanes[3],int _xfrag0,int _yfrag0);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : /*A table of functions used to fill in the chroma plane fragment maps for a
<span class="lineNum">     276 </span>            :    macro block for each type of chrominance decimation.*/
<span class="lineNum">     277 </span>            : static const oc_mb_fill_cmapping_func OC_MB_FILL_CMAPPING_TABLE[4]={
<span class="lineNum">     278 </span>            :   oc_mb_fill_cmapping00,
<span class="lineNum">     279 </span>            :   oc_mb_fill_cmapping01,
<span class="lineNum">     280 </span>            :   oc_mb_fill_cmapping10,
<span class="lineNum">     281 </span>            :   (oc_mb_fill_cmapping_func)oc_mb_fill_cmapping11
<span class="lineNum">     282 </span>            : };
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : /*Fills in the mapping from macro blocks to their corresponding fragment
<span class="lineNum">     285 </span>            :    numbers in each plane.
<span class="lineNum">     286 </span>            :   _mb_maps:   The list of macro block maps.
<span class="lineNum">     287 </span>            :   _mb_modes:  The list of macro block modes; macro blocks completely outside
<span class="lineNum">     288 </span>            :                the coded region are marked invalid.
<a name="289"><span class="lineNum">     289 </span>            :   _fplanes:   The descriptions of the fragment planes.</a>
<span class="lineNum">     290 </span>            :   _pixel_fmt: The chroma decimation type.*/
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : static void oc_mb_create_mapping(oc_mb_map _mb_maps[],</span>
<span class="lineNum">     292 </span>            :  signed char _mb_modes[],const oc_fragment_plane _fplanes[3],int _pixel_fmt){
<span class="lineNum">     293 </span>            :   oc_mb_fill_cmapping_func  mb_fill_cmapping;
<span class="lineNum">     294 </span>            :   unsigned                  sbi;
<span class="lineNum">     295 </span>            :   int                       y;
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   mb_fill_cmapping=OC_MB_FILL_CMAPPING_TABLE[_pixel_fmt];</span>
<span class="lineNum">     297 </span>            :   /*Loop through the luma plane super blocks.*/
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   for(sbi=y=0;y&lt;_fplanes[0].nvfrags;y+=4){</span>
<span class="lineNum">     299 </span>            :     int x;
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     for(x=0;x&lt;_fplanes[0].nhfrags;x+=4,sbi++){</span>
<span class="lineNum">     301 </span>            :       int ymb;
<span class="lineNum">     302 </span>            :       /*Loop through the macro blocks in each super block in display order.*/
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :       for(ymb=0;ymb&lt;2;ymb++){</span>
<span class="lineNum">     304 </span>            :         int xmb;
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         for(xmb=0;xmb&lt;2;xmb++){</span>
<span class="lineNum">     306 </span>            :           unsigned mbi;
<span class="lineNum">     307 </span>            :           int      mbx;
<span class="lineNum">     308 </span>            :           int      mby;
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :           mbi=sbi&lt;&lt;2|OC_MB_MAP[ymb][xmb];</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :           mbx=x|xmb&lt;&lt;1;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :           mby=y|ymb&lt;&lt;1;</span>
<span class="lineNum">     312 </span>            :           /*Initialize fragment indices to -1.*/
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :           memset(_mb_maps[mbi],0xFF,sizeof(_mb_maps[mbi]));</span>
<span class="lineNum">     314 </span>            :           /*Make sure this macro block is within the encoded region.*/
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :           if(mbx&gt;=_fplanes[0].nhfrags||mby&gt;=_fplanes[0].nvfrags){</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :             _mb_modes[mbi]=OC_MODE_INVALID;</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     318 </span>            :           }
<span class="lineNum">     319 </span>            :           /*Fill in the fragment indices for the luma plane.*/
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :           oc_mb_fill_ymapping(_mb_maps[mbi],_fplanes,mbx,mby);</span>
<span class="lineNum">     321 </span>            :           /*Fill in the fragment indices for the chroma planes.*/
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :           (*mb_fill_cmapping)(_mb_maps[mbi],_fplanes,mbx,mby);</span>
<span class="lineNum">     323 </span>            :         }
<span class="lineNum">     324 </span>            :       }
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            :   }
<span class="lineNum">     327 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /*Marks the fragments which fall all or partially outside the displayable
<a name="330"><span class="lineNum">     330 </span>            :    region of the frame.</a>
<span class="lineNum">     331 </span>            :   _state: The Theora state containing the fragments to be marked.*/
<span class="lineNum">     332 </span><span class="lineNoCov">          0 : static void oc_state_border_init(oc_theora_state *_state){</span>
<span class="lineNum">     333 </span>            :   oc_fragment       *frag;
<span class="lineNum">     334 </span>            :   oc_fragment       *yfrag_end;
<span class="lineNum">     335 </span>            :   oc_fragment       *xfrag_end;
<span class="lineNum">     336 </span>            :   oc_fragment_plane *fplane;
<span class="lineNum">     337 </span>            :   int                crop_x0;
<span class="lineNum">     338 </span>            :   int                crop_y0;
<span class="lineNum">     339 </span>            :   int                crop_xf;
<span class="lineNum">     340 </span>            :   int                crop_yf;
<span class="lineNum">     341 </span>            :   int                pli;
<span class="lineNum">     342 </span>            :   int                y;
<span class="lineNum">     343 </span>            :   int                x;
<span class="lineNum">     344 </span>            :   /*The method we use here is slow, but the code is dead simple and handles
<span class="lineNum">     345 </span>            :      all the special cases easily.
<span class="lineNum">     346 </span>            :     We only ever need to do it once.*/
<span class="lineNum">     347 </span>            :   /*Loop through the fragments, marking those completely outside the
<span class="lineNum">     348 </span>            :      displayable region and constructing a border mask for those that straddle
<span class="lineNum">     349 </span>            :      the border.*/
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   _state-&gt;nborders=0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   yfrag_end=frag=_state-&gt;frags;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   for(pli=0;pli&lt;3;pli++){</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     fplane=_state-&gt;fplanes+pli;</span>
<span class="lineNum">     354 </span>            :     /*Set up the cropping rectangle for this plane.*/
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     crop_x0=_state-&gt;info.pic_x;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     crop_xf=_state-&gt;info.pic_x+_state-&gt;info.pic_width;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     crop_y0=_state-&gt;info.pic_y;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     crop_yf=_state-&gt;info.pic_y+_state-&gt;info.pic_height;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if(pli&gt;0){</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :       if(!(_state-&gt;info.pixel_fmt&amp;1)){</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         crop_x0=crop_x0&gt;&gt;1;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         crop_xf=crop_xf+1&gt;&gt;1;</span>
<span class="lineNum">     363 </span>            :       }
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :       if(!(_state-&gt;info.pixel_fmt&amp;2)){</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         crop_y0=crop_y0&gt;&gt;1;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         crop_yf=crop_yf+1&gt;&gt;1;</span>
<span class="lineNum">     367 </span>            :       }
<span class="lineNum">     368 </span>            :     }
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     y=0;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     for(yfrag_end+=fplane-&gt;nfrags;frag&lt;yfrag_end;y+=8){</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       x=0;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       for(xfrag_end=frag+fplane-&gt;nhfrags;frag&lt;xfrag_end;frag++,x+=8){</span>
<span class="lineNum">     373 </span>            :         /*First check to see if this fragment is completely outside the
<span class="lineNum">     374 </span>            :            displayable region.*/
<span class="lineNum">     375 </span>            :         /*Note the special checks for an empty cropping rectangle.
<span class="lineNum">     376 </span>            :           This guarantees that if we count a fragment as straddling the
<span class="lineNum">     377 </span>            :            border below, at least one pixel in the fragment will be inside
<span class="lineNum">     378 </span>            :            the displayable region.*/
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         if(x+8&lt;=crop_x0||crop_xf&lt;=x||y+8&lt;=crop_y0||crop_yf&lt;=y||</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :          crop_x0&gt;=crop_xf||crop_y0&gt;=crop_yf){</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :           frag-&gt;invalid=1;</span>
<span class="lineNum">     382 </span>            :         }
<span class="lineNum">     383 </span>            :         /*Otherwise, check to see if it straddles the border.*/
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         else if(x&lt;crop_x0&amp;&amp;crop_x0&lt;x+8||x&lt;crop_xf&amp;&amp;crop_xf&lt;x+8||</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :          y&lt;crop_y0&amp;&amp;crop_y0&lt;y+8||y&lt;crop_yf&amp;&amp;crop_yf&lt;y+8){</span>
<span class="lineNum">     386 </span>            :           ogg_int64_t mask;
<span class="lineNum">     387 </span>            :           int         npixels;
<span class="lineNum">     388 </span>            :           int         i;
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :           mask=npixels=0;</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :           for(i=0;i&lt;8;i++){</span>
<span class="lineNum">     391 </span>            :             int j;
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :             for(j=0;j&lt;8;j++){</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :               if(x+j&gt;=crop_x0&amp;&amp;x+j&lt;crop_xf&amp;&amp;y+i&gt;=crop_y0&amp;&amp;y+i&lt;crop_yf){</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :                 mask|=(ogg_int64_t)1&lt;&lt;(i&lt;&lt;3|j);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                 npixels++;</span>
<span class="lineNum">     396 </span>            :               }
<span class="lineNum">     397 </span>            :             }
<span class="lineNum">     398 </span>            :           }
<span class="lineNum">     399 </span>            :           /*Search the fragment array for border info with the same pattern.
<span class="lineNum">     400 </span>            :             In general, there will be at most 8 different patterns (per
<span class="lineNum">     401 </span>            :              plane).*/
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :           for(i=0;;i++){</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             if(i&gt;=_state-&gt;nborders){</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :               _state-&gt;nborders++;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :               _state-&gt;borders[i].mask=mask;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :               _state-&gt;borders[i].npixels=npixels;</span>
<span class="lineNum">     407 </span>            :             }
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :             else if(_state-&gt;borders[i].mask!=mask)continue;</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :             frag-&gt;borderi=i;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     411 </span>            :           }
<span class="lineNum">     412 </span>            :         }
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         else frag-&gt;borderi=-1;</span>
<span class="lineNum">     414 </span>            :       }
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span>            :   }
<a name="417"><span class="lineNum">     417 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : static int oc_state_frarray_init(oc_theora_state *_state){</span>
<span class="lineNum">     420 </span>            :   int       yhfrags;
<span class="lineNum">     421 </span>            :   int       yvfrags;
<span class="lineNum">     422 </span>            :   int       chfrags;
<span class="lineNum">     423 </span>            :   int       cvfrags;
<span class="lineNum">     424 </span>            :   ptrdiff_t yfrags;
<span class="lineNum">     425 </span>            :   ptrdiff_t cfrags;
<span class="lineNum">     426 </span>            :   ptrdiff_t nfrags;
<span class="lineNum">     427 </span>            :   unsigned  yhsbs;
<span class="lineNum">     428 </span>            :   unsigned  yvsbs;
<span class="lineNum">     429 </span>            :   unsigned  chsbs;
<span class="lineNum">     430 </span>            :   unsigned  cvsbs;
<span class="lineNum">     431 </span>            :   unsigned  ysbs;
<span class="lineNum">     432 </span>            :   unsigned  csbs;
<span class="lineNum">     433 </span>            :   unsigned  nsbs;
<span class="lineNum">     434 </span>            :   size_t    nmbs;
<span class="lineNum">     435 </span>            :   int       hdec;
<span class="lineNum">     436 </span>            :   int       vdec;
<span class="lineNum">     437 </span>            :   int       pli;
<span class="lineNum">     438 </span>            :   /*Figure out the number of fragments in each plane.*/
<span class="lineNum">     439 </span>            :   /*These parameters have already been validated to be multiples of 16.*/
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   yhfrags=_state-&gt;info.frame_width&gt;&gt;3;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   yvfrags=_state-&gt;info.frame_height&gt;&gt;3;</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :   hdec=!(_state-&gt;info.pixel_fmt&amp;1);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   vdec=!(_state-&gt;info.pixel_fmt&amp;2);</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   chfrags=yhfrags+hdec&gt;&gt;hdec;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   cvfrags=yvfrags+vdec&gt;&gt;vdec;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   yfrags=yhfrags*(ptrdiff_t)yvfrags;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   cfrags=chfrags*(ptrdiff_t)cvfrags;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :   nfrags=yfrags+2*cfrags;</span>
<span class="lineNum">     449 </span>            :   /*Figure out the number of super blocks in each plane.*/
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   yhsbs=yhfrags+3&gt;&gt;2;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   yvsbs=yvfrags+3&gt;&gt;2;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   chsbs=chfrags+3&gt;&gt;2;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   cvsbs=cvfrags+3&gt;&gt;2;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   ysbs=yhsbs*yvsbs;</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   csbs=chsbs*cvsbs;</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   nsbs=ysbs+2*csbs;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   nmbs=(size_t)ysbs&lt;&lt;2;</span>
<span class="lineNum">     458 </span>            :   /*Check for overflow.
<span class="lineNum">     459 </span>            :     We support the ridiculous upper limits of the specification (1048560 by
<span class="lineNum">     460 </span>            :      1048560, or 3 TB frames) if the target architecture has 64-bit pointers,
<span class="lineNum">     461 </span>            :      but for those with 32-bit pointers (or smaller!) we have to check.
<span class="lineNum">     462 </span>            :     If the caller wants to prevent denial-of-service by imposing a more
<span class="lineNum">     463 </span>            :      reasonable upper limit on the size of attempted allocations, they must do
<span class="lineNum">     464 </span>            :      so themselves; we have no platform independent way to determine how much
<span class="lineNum">     465 </span>            :      system memory there is nor an application-independent way to decide what a
<span class="lineNum">     466 </span>            :      &quot;reasonable&quot; allocation is.*/
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   if(yfrags/yhfrags!=yvfrags||2*cfrags&lt;cfrags||nfrags&lt;yfrags||</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :    ysbs/yhsbs!=yvsbs||2*csbs&lt;csbs||nsbs&lt;ysbs||nmbs&gt;&gt;2!=ysbs){</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     return TH_EIMPL;</span>
<span class="lineNum">     470 </span>            :   }
<span class="lineNum">     471 </span>            :   /*Initialize the fragment array.*/
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nhfrags=yhfrags;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nvfrags=yvfrags;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].froffset=0;</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nfrags=yfrags;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nhsbs=yhsbs;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nvsbs=yvsbs;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].sboffset=0;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[0].nsbs=ysbs;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nhfrags=_state-&gt;fplanes[2].nhfrags=chfrags;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nvfrags=_state-&gt;fplanes[2].nvfrags=cvfrags;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].froffset=yfrags;</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[2].froffset=yfrags+cfrags;</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nfrags=_state-&gt;fplanes[2].nfrags=cfrags;</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nhsbs=_state-&gt;fplanes[2].nhsbs=chsbs;</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nvsbs=_state-&gt;fplanes[2].nvsbs=cvsbs;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].sboffset=ysbs;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[2].sboffset=ysbs+csbs;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   _state-&gt;fplanes[1].nsbs=_state-&gt;fplanes[2].nsbs=csbs;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :   _state-&gt;nfrags=nfrags;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   _state-&gt;frags=_ogg_calloc(nfrags,sizeof(*_state-&gt;frags));</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   _state-&gt;frag_mvs=_ogg_malloc(nfrags*sizeof(*_state-&gt;frag_mvs));</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   _state-&gt;nsbs=nsbs;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   _state-&gt;sb_maps=_ogg_malloc(nsbs*sizeof(*_state-&gt;sb_maps));</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   _state-&gt;sb_flags=_ogg_calloc(nsbs,sizeof(*_state-&gt;sb_flags));</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   _state-&gt;nhmbs=yhsbs&lt;&lt;1;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   _state-&gt;nvmbs=yvsbs&lt;&lt;1;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   _state-&gt;nmbs=nmbs;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   _state-&gt;mb_maps=_ogg_calloc(nmbs,sizeof(*_state-&gt;mb_maps));</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   _state-&gt;mb_modes=_ogg_calloc(nmbs,sizeof(*_state-&gt;mb_modes));</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   _state-&gt;coded_fragis=_ogg_malloc(nfrags*sizeof(*_state-&gt;coded_fragis));</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   if(_state-&gt;frags==NULL||_state-&gt;frag_mvs==NULL||_state-&gt;sb_maps==NULL||</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :    _state-&gt;sb_flags==NULL||_state-&gt;mb_maps==NULL||_state-&gt;mb_modes==NULL||</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :    _state-&gt;coded_fragis==NULL){</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     return TH_EFAULT;</span>
<span class="lineNum">     506 </span>            :   }
<span class="lineNum">     507 </span>            :   /*Create the mapping from super blocks to fragments.*/
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   for(pli=0;pli&lt;3;pli++){</span>
<span class="lineNum">     509 </span>            :     oc_fragment_plane *fplane;
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     fplane=_state-&gt;fplanes+pli;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     oc_sb_create_plane_mapping(_state-&gt;sb_maps+fplane-&gt;sboffset,</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :      _state-&gt;sb_flags+fplane-&gt;sboffset,fplane-&gt;froffset,</span>
<span class="lineNum">     513 </span>            :      fplane-&gt;nhfrags,fplane-&gt;nvfrags);
<span class="lineNum">     514 </span>            :   }
<span class="lineNum">     515 </span>            :   /*Create the mapping from macro blocks to fragments.*/
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   oc_mb_create_mapping(_state-&gt;mb_maps,_state-&gt;mb_modes,</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :    _state-&gt;fplanes,_state-&gt;info.pixel_fmt);</span>
<span class="lineNum">     518 </span>            :   /*Initialize the invalid and borderi fields of each fragment.*/
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   oc_state_border_init(_state);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="521"><span class="lineNum">     521 </span>            : }</a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : static void oc_state_frarray_clear(oc_theora_state *_state){</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;coded_fragis);</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;mb_modes);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;mb_maps);</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;sb_flags);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;sb_maps);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;frag_mvs);</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;frags);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /*Initializes the buffers used for reconstructed frames.
<span class="lineNum">     535 </span>            :   These buffers are padded with 16 extra pixels on each side, to allow
<span class="lineNum">     536 </span>            :    unrestricted motion vectors without special casing the boundary.
<span class="lineNum">     537 </span>            :   If chroma is decimated in either direction, the padding is reduced by a
<a name="538"><span class="lineNum">     538 </span>            :    factor of 2 on the appropriate sides.</a>
<span class="lineNum">     539 </span>            :   _nrefs: The number of reference buffers to init; must be in the range 3...6.*/
<span class="lineNum">     540 </span><span class="lineNoCov">          0 : static int oc_state_ref_bufs_init(oc_theora_state *_state,int _nrefs){</span>
<span class="lineNum">     541 </span>            :   th_info       *info;
<span class="lineNum">     542 </span>            :   unsigned char *ref_frame_data;
<span class="lineNum">     543 </span>            :   size_t         ref_frame_data_sz;
<span class="lineNum">     544 </span>            :   size_t         ref_frame_sz;
<span class="lineNum">     545 </span>            :   size_t         yplane_sz;
<span class="lineNum">     546 </span>            :   size_t         cplane_sz;
<span class="lineNum">     547 </span>            :   int            yhstride;
<span class="lineNum">     548 </span>            :   int            yheight;
<span class="lineNum">     549 </span>            :   int            chstride;
<span class="lineNum">     550 </span>            :   int            cheight;
<span class="lineNum">     551 </span>            :   ptrdiff_t      align;
<span class="lineNum">     552 </span>            :   ptrdiff_t      yoffset;
<span class="lineNum">     553 </span>            :   ptrdiff_t      coffset;
<span class="lineNum">     554 </span>            :   ptrdiff_t     *frag_buf_offs;
<span class="lineNum">     555 </span>            :   ptrdiff_t      fragi;
<span class="lineNum">     556 </span>            :   int            hdec;
<span class="lineNum">     557 </span>            :   int            vdec;
<span class="lineNum">     558 </span>            :   int            rfi;
<span class="lineNum">     559 </span>            :   int            pli;
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   if(_nrefs&lt;3||_nrefs&gt;6)return TH_EINVAL;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   info=&amp;_state-&gt;info;</span>
<span class="lineNum">     562 </span>            :   /*Compute the image buffer parameters for each plane.*/
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   hdec=!(info-&gt;pixel_fmt&amp;1);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   vdec=!(info-&gt;pixel_fmt&amp;2);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   yhstride=info-&gt;frame_width+2*OC_UMV_PADDING;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   yheight=info-&gt;frame_height+2*OC_UMV_PADDING;</span>
<span class="lineNum">     567 </span>            :   /*Require 16-byte aligned rows in the chroma planes.*/
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   chstride=(yhstride&gt;&gt;hdec)+15&amp;~15;</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   cheight=yheight&gt;&gt;vdec;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   yplane_sz=yhstride*(size_t)yheight;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :   cplane_sz=chstride*(size_t)cheight;</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   yoffset=OC_UMV_PADDING+OC_UMV_PADDING*(ptrdiff_t)yhstride;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   coffset=(OC_UMV_PADDING&gt;&gt;hdec)+(OC_UMV_PADDING&gt;&gt;vdec)*(ptrdiff_t)chstride;</span>
<span class="lineNum">     574 </span>            :   /*Although we guarantee the rows of the chroma planes are a multiple of 16
<span class="lineNum">     575 </span>            :      bytes, the initial padding on the first row may only be 8 bytes.
<span class="lineNum">     576 </span>            :     Compute the offset needed to the actual image data to a multiple of 16.*/
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   align=-coffset&amp;15;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   ref_frame_sz=yplane_sz+2*cplane_sz+16;</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   ref_frame_data_sz=_nrefs*ref_frame_sz;</span>
<span class="lineNum">     580 </span>            :   /*Check for overflow.
<span class="lineNum">     581 </span>            :     The same caveats apply as for oc_state_frarray_init().*/
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   if(yplane_sz/yhstride!=(size_t)yheight||2*cplane_sz+16&lt;cplane_sz||</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :    ref_frame_sz&lt;yplane_sz||ref_frame_data_sz/_nrefs!=ref_frame_sz){</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     return TH_EIMPL;</span>
<span class="lineNum">     585 </span>            :   }
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :   ref_frame_data=oc_aligned_malloc(ref_frame_data_sz,16);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   frag_buf_offs=_state-&gt;frag_buf_offs=</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :    _ogg_malloc(_state-&gt;nfrags*sizeof(*frag_buf_offs));</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   if(ref_frame_data==NULL||frag_buf_offs==NULL){</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     _ogg_free(frag_buf_offs);</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     oc_aligned_free(ref_frame_data);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     return TH_EFAULT;</span>
<span class="lineNum">     593 </span>            :   }
<span class="lineNum">     594 </span>            :   /*Set up the width, height and stride for the image buffers.*/
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][0].width=info-&gt;frame_width;</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][0].height=info-&gt;frame_height;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][0].stride=yhstride;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][1].width=_state-&gt;ref_frame_bufs[0][2].width=</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :    info-&gt;frame_width&gt;&gt;hdec;</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][1].height=_state-&gt;ref_frame_bufs[0][2].height=</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :    info-&gt;frame_height&gt;&gt;vdec;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_bufs[0][1].stride=_state-&gt;ref_frame_bufs[0][2].stride=</span>
<span class="lineNum">     603 </span>            :    chstride;
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   for(rfi=1;rfi&lt;_nrefs;rfi++){</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     memcpy(_state-&gt;ref_frame_bufs[rfi],_state-&gt;ref_frame_bufs[0],</span>
<span class="lineNum">     606 </span>            :      sizeof(_state-&gt;ref_frame_bufs[0]));
<span class="lineNum">     607 </span>            :   }
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_handle=ref_frame_data;</span>
<span class="lineNum">     609 </span>            :   /*Set up the data pointers for the image buffers.*/
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   for(rfi=0;rfi&lt;_nrefs;rfi++){</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     _state-&gt;ref_frame_bufs[rfi][0].data=ref_frame_data+yoffset;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     ref_frame_data+=yplane_sz+align;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     _state-&gt;ref_frame_bufs[rfi][1].data=ref_frame_data+coffset;</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     ref_frame_data+=cplane_sz;</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     _state-&gt;ref_frame_bufs[rfi][2].data=ref_frame_data+coffset;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     ref_frame_data+=cplane_sz+(16-align);</span>
<span class="lineNum">     617 </span>            :     /*Flip the buffer upside down.
<span class="lineNum">     618 </span>            :       This allows us to decode Theora's bottom-up frames in their natural
<span class="lineNum">     619 </span>            :        order, yet return a top-down buffer with a positive stride to the user.*/
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     oc_ycbcr_buffer_flip(_state-&gt;ref_frame_bufs[rfi],</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :      _state-&gt;ref_frame_bufs[rfi]);</span>
<span class="lineNum">     622 </span>            :   }
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   _state-&gt;ref_ystride[0]=-yhstride;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   _state-&gt;ref_ystride[1]=_state-&gt;ref_ystride[2]=-chstride;</span>
<span class="lineNum">     625 </span>            :   /*Initialize the fragment buffer offsets.*/
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   ref_frame_data=_state-&gt;ref_frame_bufs[0][0].data;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   fragi=0;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   for(pli=0;pli&lt;3;pli++){</span>
<span class="lineNum">     629 </span>            :     th_img_plane      *iplane;
<span class="lineNum">     630 </span>            :     oc_fragment_plane *fplane;
<span class="lineNum">     631 </span>            :     unsigned char     *vpix;
<span class="lineNum">     632 </span>            :     ptrdiff_t          stride;
<span class="lineNum">     633 </span>            :     ptrdiff_t          vfragi_end;
<span class="lineNum">     634 </span>            :     int                nhfrags;
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :     iplane=_state-&gt;ref_frame_bufs[0]+pli;</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     fplane=_state-&gt;fplanes+pli;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     vpix=iplane-&gt;data;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     vfragi_end=fplane-&gt;froffset+fplane-&gt;nfrags;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     nhfrags=fplane-&gt;nhfrags;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     stride=iplane-&gt;stride;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     while(fragi&lt;vfragi_end){</span>
<span class="lineNum">     642 </span>            :       ptrdiff_t      hfragi_end;
<span class="lineNum">     643 </span>            :       unsigned char *hpix;
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :       hpix=vpix;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       for(hfragi_end=fragi+nhfrags;fragi&lt;hfragi_end;fragi++){</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         frag_buf_offs[fragi]=hpix-ref_frame_data;</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         hpix+=8;</span>
<span class="lineNum">     648 </span>            :       }
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       vpix+=stride&lt;&lt;3;</span>
<span class="lineNum">     650 </span>            :     }
<span class="lineNum">     651 </span>            :   }
<span class="lineNum">     652 </span>            :   /*Initialize the reference frame pointers and indices.*/
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_idx[OC_FRAME_GOLD]=</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_idx[OC_FRAME_PREV]=</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_idx[OC_FRAME_GOLD_ORIG]=</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_idx[OC_FRAME_PREV_ORIG]=</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_idx[OC_FRAME_SELF]=</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_idx[OC_FRAME_IO]=-1;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   _state-&gt;ref_frame_data[OC_FRAME_GOLD]=</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_data[OC_FRAME_PREV]=</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_data[OC_FRAME_GOLD_ORIG]=</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_data[OC_FRAME_PREV_ORIG]=</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_data[OC_FRAME_SELF]=</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :    _state-&gt;ref_frame_data[OC_FRAME_IO]=NULL;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="666"><span class="lineNum">     666 </span>            : }</a>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : static void oc_state_ref_bufs_clear(oc_theora_state *_state){</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   _ogg_free(_state-&gt;frag_buf_offs);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   oc_aligned_free(_state-&gt;ref_frame_handle);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : }</span>
<a name="672"><span class="lineNum">     672 </span>            : </a>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : void oc_state_accel_init_c(oc_theora_state *_state){</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   _state-&gt;cpu_flags=0;</span>
<span class="lineNum">     676 </span>            : #if defined(OC_STATE_USE_VTABLE)
<span class="lineNum">     677 </span>            :   _state-&gt;opt_vtable.frag_copy=oc_frag_copy_c;
<span class="lineNum">     678 </span>            :   _state-&gt;opt_vtable.frag_copy_list=oc_frag_copy_list_c;
<span class="lineNum">     679 </span>            :   _state-&gt;opt_vtable.frag_recon_intra=oc_frag_recon_intra_c;
<span class="lineNum">     680 </span>            :   _state-&gt;opt_vtable.frag_recon_inter=oc_frag_recon_inter_c;
<span class="lineNum">     681 </span>            :   _state-&gt;opt_vtable.frag_recon_inter2=oc_frag_recon_inter2_c;
<span class="lineNum">     682 </span>            :   _state-&gt;opt_vtable.idct8x8=oc_idct8x8_c;
<span class="lineNum">     683 </span>            :   _state-&gt;opt_vtable.state_frag_recon=oc_state_frag_recon_c;
<span class="lineNum">     684 </span>            :   _state-&gt;opt_vtable.loop_filter_init=oc_loop_filter_init_c;
<span class="lineNum">     685 </span>            :   _state-&gt;opt_vtable.state_loop_filter_frag_rows=
<span class="lineNum">     686 </span>            :    oc_state_loop_filter_frag_rows_c;
<span class="lineNum">     687 </span>            :   _state-&gt;opt_vtable.restore_fpu=oc_restore_fpu_c;
<span class="lineNum">     688 </span>            : #endif
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   _state-&gt;opt_data.dct_fzig_zag=OC_FZIG_ZAG;</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 : }</span>
<a name="691"><span class="lineNum">     691 </span>            : </a>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : int oc_state_init(oc_theora_state *_state,const th_info *_info,int _nrefs){</span>
<span class="lineNum">     694 </span>            :   int ret;
<span class="lineNum">     695 </span>            :   /*First validate the parameters.*/
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   if(_info==NULL)return TH_EFAULT;</span>
<span class="lineNum">     697 </span>            :   /*The width and height of the encoded frame must be multiples of 16.
<span class="lineNum">     698 </span>            :     They must also, when divided by 16, fit into a 16-bit unsigned integer.
<span class="lineNum">     699 </span>            :     The displayable frame offset coordinates must fit into an 8-bit unsigned
<span class="lineNum">     700 </span>            :      integer.
<span class="lineNum">     701 </span>            :     Note that the offset Y in the API is specified on the opposite side from
<span class="lineNum">     702 </span>            :      how it is specified in the bitstream, because the Y axis is flipped in
<span class="lineNum">     703 </span>            :      the bitstream.
<span class="lineNum">     704 </span>            :     The displayable frame must fit inside the encoded frame.
<span class="lineNum">     705 </span>            :     The color space must be one known by the encoder.*/
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   if((_info-&gt;frame_width&amp;0xF)||(_info-&gt;frame_height&amp;0xF)||</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :    _info-&gt;frame_width&lt;=0||_info-&gt;frame_width&gt;=0x100000||</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :    _info-&gt;frame_height&lt;=0||_info-&gt;frame_height&gt;=0x100000||</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :    _info-&gt;pic_x+_info-&gt;pic_width&gt;_info-&gt;frame_width||</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :    _info-&gt;pic_y+_info-&gt;pic_height&gt;_info-&gt;frame_height||</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :    _info-&gt;pic_x&gt;255||_info-&gt;frame_height-_info-&gt;pic_height-_info-&gt;pic_y&gt;255||</span>
<span class="lineNum">     712 </span>            :    /*Note: the following &lt;0 comparisons may generate spurious warnings on
<span class="lineNum">     713 </span>            :       platforms where enums are unsigned.
<span class="lineNum">     714 </span>            :      We could cast them to unsigned and just use the following &gt;= comparison,
<span class="lineNum">     715 </span>            :       but there are a number of compilers which will mis-optimize this.
<span class="lineNum">     716 </span>            :      It's better to live with the spurious warnings.*/
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :    _info-&gt;colorspace&lt;0||_info-&gt;colorspace&gt;=TH_CS_NSPACES||</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :    _info-&gt;pixel_fmt&lt;0||_info-&gt;pixel_fmt&gt;=TH_PF_NFORMATS){</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :     return TH_EINVAL;</span>
<span class="lineNum">     720 </span>            :   }
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   memset(_state,0,sizeof(*_state));</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   memcpy(&amp;_state-&gt;info,_info,sizeof(*_info));</span>
<span class="lineNum">     723 </span>            :   /*Invert the sense of pic_y to match Theora's right-handed coordinate
<span class="lineNum">     724 </span>            :      system.*/
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   _state-&gt;info.pic_y=_info-&gt;frame_height-_info-&gt;pic_height-_info-&gt;pic_y;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   _state-&gt;frame_type=OC_UNKWN_FRAME;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   oc_state_accel_init(_state);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   ret=oc_state_frarray_init(_state);</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   if(ret&gt;=0)ret=oc_state_ref_bufs_init(_state,_nrefs);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   if(ret&lt;0){</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     oc_state_frarray_clear(_state);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">     733 </span>            :   }
<span class="lineNum">     734 </span>            :   /*If the keyframe_granule_shift is out of range, use the maximum allowable
<span class="lineNum">     735 </span>            :      value.*/
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   if(_info-&gt;keyframe_granule_shift&lt;0||_info-&gt;keyframe_granule_shift&gt;31){</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     _state-&gt;info.keyframe_granule_shift=31;</span>
<span class="lineNum">     738 </span>            :   }
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :   _state-&gt;keyframe_num=0;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :   _state-&gt;curframe_num=-1;</span>
<span class="lineNum">     741 </span>            :   /*3.2.0 streams mark the frame index instead of the frame count.
<span class="lineNum">     742 </span>            :     This was changed with stream version 3.2.1 to conform to other Ogg
<span class="lineNum">     743 </span>            :      codecs.
<span class="lineNum">     744 </span>            :     We add an extra bias when computing granule positions for new streams.*/
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   _state-&gt;granpos_bias=TH_VERSION_CHECK(_info,3,2,1);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="747"><span class="lineNum">     747 </span>            : }</a>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : void oc_state_clear(oc_theora_state *_state){</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   oc_state_ref_bufs_clear(_state);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   oc_state_frarray_clear(_state);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : /*Duplicates the pixels on the border of the image plane out into the
<span class="lineNum">     756 </span>            :    surrounding padding for use by unrestricted motion vectors.
<span class="lineNum">     757 </span>            :   This function only adds the left and right borders, and only for the fragment
<span class="lineNum">     758 </span>            :    rows specified.
<span class="lineNum">     759 </span>            :   _refi: The index of the reference buffer to pad.
<span class="lineNum">     760 </span>            :   _pli:  The color plane.
<a name="761"><span class="lineNum">     761 </span>            :   _y0:   The Y coordinate of the first row to pad.</a>
<span class="lineNum">     762 </span>            :   _yend: The Y coordinate of the row to stop padding at.*/
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : void oc_state_borders_fill_rows(oc_theora_state *_state,int _refi,int _pli,</span>
<span class="lineNum">     764 </span>            :  int _y0,int _yend){
<span class="lineNum">     765 </span>            :   th_img_plane  *iplane;
<span class="lineNum">     766 </span>            :   unsigned char *apix;
<span class="lineNum">     767 </span>            :   unsigned char *bpix;
<span class="lineNum">     768 </span>            :   unsigned char *epix;
<span class="lineNum">     769 </span>            :   int            stride;
<span class="lineNum">     770 </span>            :   int            hpadding;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   hpadding=OC_UMV_PADDING&gt;&gt;(_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;1));</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   iplane=_state-&gt;ref_frame_bufs[_refi]+_pli;</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   stride=iplane-&gt;stride;</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   apix=iplane-&gt;data+_y0*(ptrdiff_t)stride;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   bpix=apix+iplane-&gt;width-1;</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   epix=iplane-&gt;data+_yend*(ptrdiff_t)stride;</span>
<span class="lineNum">     777 </span>            :   /*Note the use of != instead of &lt;, which allows the stride to be negative.*/
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   while(apix!=epix){</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     memset(apix-hpadding,apix[0],hpadding);</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     memset(bpix+1,bpix[0],hpadding);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     apix+=stride;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     bpix+=stride;</span>
<span class="lineNum">     783 </span>            :   }
<span class="lineNum">     784 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : /*Duplicates the pixels on the border of the image plane out into the
<span class="lineNum">     787 </span>            :    surrounding padding for use by unrestricted motion vectors.
<span class="lineNum">     788 </span>            :   This function only adds the top and bottom borders, and must be called after
<span class="lineNum">     789 </span>            :    the left and right borders are added.
<a name="790"><span class="lineNum">     790 </span>            :   _refi:      The index of the reference buffer to pad.</a>
<span class="lineNum">     791 </span>            :   _pli:       The color plane.*/
<span class="lineNum">     792 </span><span class="lineNoCov">          0 : void oc_state_borders_fill_caps(oc_theora_state *_state,int _refi,int _pli){</span>
<span class="lineNum">     793 </span>            :   th_img_plane  *iplane;
<span class="lineNum">     794 </span>            :   unsigned char *apix;
<span class="lineNum">     795 </span>            :   unsigned char *bpix;
<span class="lineNum">     796 </span>            :   unsigned char *epix;
<span class="lineNum">     797 </span>            :   int            stride;
<span class="lineNum">     798 </span>            :   int            hpadding;
<span class="lineNum">     799 </span>            :   int            vpadding;
<span class="lineNum">     800 </span>            :   int            fullw;
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   hpadding=OC_UMV_PADDING&gt;&gt;(_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;1));</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   vpadding=OC_UMV_PADDING&gt;&gt;(_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;2));</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   iplane=_state-&gt;ref_frame_bufs[_refi]+_pli;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   stride=iplane-&gt;stride;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :   fullw=iplane-&gt;width+(hpadding&lt;&lt;1);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   apix=iplane-&gt;data-hpadding;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   bpix=iplane-&gt;data+(iplane-&gt;height-1)*(ptrdiff_t)stride-hpadding;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :   epix=apix-stride*(ptrdiff_t)vpadding;</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :   while(apix!=epix){</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     memcpy(apix-stride,apix,fullw);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     memcpy(bpix+stride,bpix,fullw);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     apix-=stride;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     bpix+=stride;</span>
<span class="lineNum">     814 </span>            :   }
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : /*Duplicates the pixels on the border of the given reference image out into
<span class="lineNum">     818 </span>            :    the surrounding padding for use by unrestricted motion vectors.
<a name="819"><span class="lineNum">     819 </span>            :   _state: The context containing the reference buffers.</a>
<span class="lineNum">     820 </span>            :   _refi:  The index of the reference buffer to pad.*/
<span class="lineNum">     821 </span><span class="lineNoCov">          0 : void oc_state_borders_fill(oc_theora_state *_state,int _refi){</span>
<span class="lineNum">     822 </span>            :   int pli;
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   for(pli=0;pli&lt;3;pli++){</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     oc_state_borders_fill_rows(_state,_refi,pli,0,</span>
<span class="lineNum">     825 </span>            :      _state-&gt;ref_frame_bufs[_refi][pli].height);
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     oc_state_borders_fill_caps(_state,_refi,pli);</span>
<span class="lineNum">     827 </span>            :   }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : /*Determines the offsets in an image buffer to use for motion compensation.
<span class="lineNum">     831 </span>            :   _state:   The Theora state the offsets are to be computed with.
<span class="lineNum">     832 </span>            :   _offsets: Returns the offset for the buffer(s).
<span class="lineNum">     833 </span>            :             _offsets[0] is always set.
<span class="lineNum">     834 </span>            :             _offsets[1] is set if the motion vector has non-zero fractional
<span class="lineNum">     835 </span>            :              components.
<span class="lineNum">     836 </span>            :   _pli:     The color plane index.
<a name="837"><span class="lineNum">     837 </span>            :   _mv:      The motion vector.</a>
<span class="lineNum">     838 </span>            :   Return: The number of offsets returned: 1 or 2.*/
<span class="lineNum">     839 </span><span class="lineNoCov">          0 : int oc_state_get_mv_offsets(const oc_theora_state *_state,int _offsets[2],</span>
<span class="lineNum">     840 </span>            :  int _pli,oc_mv _mv){
<span class="lineNum">     841 </span>            :   /*Here is a brief description of how Theora handles motion vectors:
<span class="lineNum">     842 </span>            :     Motion vector components are specified to half-pixel accuracy in
<span class="lineNum">     843 </span>            :      undecimated directions of each plane, and quarter-pixel accuracy in
<span class="lineNum">     844 </span>            :      decimated directions.
<span class="lineNum">     845 </span>            :     Integer parts are extracted by dividing (not shifting) by the
<span class="lineNum">     846 </span>            :      appropriate amount, with truncation towards zero.
<span class="lineNum">     847 </span>            :     These integer values are used to calculate the first offset.
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :     If either of the fractional parts are non-zero, then a second offset is
<span class="lineNum">     850 </span>            :      computed.
<span class="lineNum">     851 </span>            :     No third or fourth offsets are computed, even if both components have
<span class="lineNum">     852 </span>            :      non-zero fractional parts.
<span class="lineNum">     853 </span>            :     The second offset is computed by dividing (not shifting) by the
<span class="lineNum">     854 </span>            :      appropriate amount, always truncating _away_ from zero.*/
<span class="lineNum">     855 </span>            : #if 0
<span class="lineNum">     856 </span>            :   /*This version of the code doesn't use any tables, but is slower.*/
<span class="lineNum">     857 </span>            :   int ystride;
<span class="lineNum">     858 </span>            :   int xprec;
<span class="lineNum">     859 </span>            :   int yprec;
<span class="lineNum">     860 </span>            :   int xfrac;
<span class="lineNum">     861 </span>            :   int yfrac;
<span class="lineNum">     862 </span>            :   int offs;
<span class="lineNum">     863 </span>            :   int dx;
<span class="lineNum">     864 </span>            :   int dy;
<span class="lineNum">     865 </span>            :   ystride=_state-&gt;ref_ystride[_pli];
<span class="lineNum">     866 </span>            :   /*These two variables decide whether we are in half- or quarter-pixel
<span class="lineNum">     867 </span>            :      precision in each component.*/
<span class="lineNum">     868 </span>            :   xprec=1+(_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;1));
<span class="lineNum">     869 </span>            :   yprec=1+(_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;2));
<span class="lineNum">     870 </span>            :   dx=OC_MV_X(_mv);
<span class="lineNum">     871 </span>            :   dy=OC_MV_Y(_mv);
<span class="lineNum">     872 </span>            :   /*These two variables are either 0 if all the fractional bits are zero or -1
<span class="lineNum">     873 </span>            :      if any of them are non-zero.*/
<span class="lineNum">     874 </span>            :   xfrac=OC_SIGNMASK(-(dx&amp;(xprec|1)));
<span class="lineNum">     875 </span>            :   yfrac=OC_SIGNMASK(-(dy&amp;(yprec|1)));
<span class="lineNum">     876 </span>            :   offs=(dx&gt;&gt;xprec)+(dy&gt;&gt;yprec)*ystride;
<span class="lineNum">     877 </span>            :   if(xfrac||yfrac){
<span class="lineNum">     878 </span>            :     int xmask;
<span class="lineNum">     879 </span>            :     int ymask;
<span class="lineNum">     880 </span>            :     xmask=OC_SIGNMASK(dx);
<span class="lineNum">     881 </span>            :     ymask=OC_SIGNMASK(dy);
<span class="lineNum">     882 </span>            :     yfrac&amp;=ystride;
<span class="lineNum">     883 </span>            :     _offsets[0]=offs-(xfrac&amp;xmask)+(yfrac&amp;ymask);
<span class="lineNum">     884 </span>            :     _offsets[1]=offs-(xfrac&amp;~xmask)+(yfrac&amp;~ymask);
<span class="lineNum">     885 </span>            :     return 2;
<span class="lineNum">     886 </span>            :   }
<span class="lineNum">     887 </span>            :   else{
<span class="lineNum">     888 </span>            :     _offsets[0]=offs;
<span class="lineNum">     889 </span>            :     return 1;
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            : #else
<span class="lineNum">     892 </span>            :   /*Using tables simplifies the code, and there's enough arithmetic to hide the
<span class="lineNum">     893 </span>            :      latencies of the memory references.*/
<span class="lineNum">     894 </span>            :   static const signed char OC_MVMAP[2][64]={
<span class="lineNum">     895 </span>            :     {
<span class="lineNum">     896 </span>            :           -15,-15,-14,-14,-13,-13,-12,-12,-11,-11,-10,-10, -9, -9, -8,
<span class="lineNum">     897 </span>            :        -8, -7, -7, -6, -6, -5, -5, -4, -4, -3, -3, -2, -2, -1, -1,  0,
<span class="lineNum">     898 </span>            :         0,  0,  1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  6,  7,  7,
<span class="lineNum">     899 </span>            :         8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15
<span class="lineNum">     900 </span>            :     },
<span class="lineNum">     901 </span>            :     {
<span class="lineNum">     902 </span>            :            -7, -7, -7, -7, -6, -6, -6, -6, -5, -5, -5, -5, -4, -4, -4,
<span class="lineNum">     903 </span>            :        -4, -3, -3, -3, -3, -2, -2, -2, -2, -1, -1, -1, -1,  0,  0,  0,
<span class="lineNum">     904 </span>            :         0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
<span class="lineNum">     905 </span>            :         4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7
<span class="lineNum">     906 </span>            :     }
<span class="lineNum">     907 </span>            :   };
<span class="lineNum">     908 </span>            :   static const signed char OC_MVMAP2[2][64]={
<span class="lineNum">     909 </span>            :     {
<span class="lineNum">     910 </span>            :         -1, 0,-1,  0,-1, 0,-1,  0,-1, 0,-1,  0,-1, 0,-1,
<span class="lineNum">     911 </span>            :       0,-1, 0,-1,  0,-1, 0,-1,  0,-1, 0,-1,  0,-1, 0,-1,
<span class="lineNum">     912 </span>            :       0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,
<span class="lineNum">     913 </span>            :       0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1,  0, 1, 0, 1
<span class="lineNum">     914 </span>            :     },
<span class="lineNum">     915 </span>            :     {
<span class="lineNum">     916 </span>            :         -1,-1,-1,  0,-1,-1,-1,  0,-1,-1,-1,  0,-1,-1,-1,
<span class="lineNum">     917 </span>            :       0,-1,-1,-1,  0,-1,-1,-1,  0,-1,-1,-1,  0,-1,-1,-1,
<span class="lineNum">     918 </span>            :       0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,
<span class="lineNum">     919 </span>            :       0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1
<span class="lineNum">     920 </span>            :     }
<span class="lineNum">     921 </span>            :   };
<span class="lineNum">     922 </span>            :   int ystride;
<span class="lineNum">     923 </span>            :   int qpx;
<span class="lineNum">     924 </span>            :   int qpy;
<span class="lineNum">     925 </span>            :   int mx;
<span class="lineNum">     926 </span>            :   int my;
<span class="lineNum">     927 </span>            :   int mx2;
<span class="lineNum">     928 </span>            :   int my2;
<span class="lineNum">     929 </span>            :   int offs;
<span class="lineNum">     930 </span>            :   int dx;
<span class="lineNum">     931 </span>            :   int dy;
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   ystride=_state-&gt;ref_ystride[_pli];</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   qpy=_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;2);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   dx=OC_MV_X(_mv);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :   dy=OC_MV_Y(_mv);</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   my=OC_MVMAP[qpy][dy+31];</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :   my2=OC_MVMAP2[qpy][dy+31];</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   qpx=_pli!=0&amp;&amp;!(_state-&gt;info.pixel_fmt&amp;1);</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   mx=OC_MVMAP[qpx][dx+31];</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   mx2=OC_MVMAP2[qpx][dx+31];</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   offs=my*ystride+mx;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   if(mx2||my2){</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :     _offsets[1]=offs+my2*ystride+mx2;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     _offsets[0]=offs;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     return 2;</span>
<span class="lineNum">     946 </span>            :   }
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   _offsets[0]=offs;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     949 </span>            : #endif
<a name="950"><span class="lineNum">     950 </span>            : }</a>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 : void oc_state_frag_recon_c(const oc_theora_state *_state,ptrdiff_t _fragi,</span>
<span class="lineNum">     953 </span>            :  int _pli,ogg_int16_t _dct_coeffs[128],int _last_zzi,ogg_uint16_t _dc_quant){
<span class="lineNum">     954 </span>            :   unsigned char *dst;
<span class="lineNum">     955 </span>            :   ptrdiff_t      frag_buf_off;
<span class="lineNum">     956 </span>            :   int            ystride;
<span class="lineNum">     957 </span>            :   int            refi;
<span class="lineNum">     958 </span>            :   /*Apply the inverse transform.*/
<span class="lineNum">     959 </span>            :   /*Special case only having a DC component.*/
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   if(_last_zzi&lt;2){</span>
<span class="lineNum">     961 </span>            :     ogg_int16_t p;
<span class="lineNum">     962 </span>            :     int         ci;
<span class="lineNum">     963 </span>            :     /*We round this dequant product (and not any of the others) because there's
<span class="lineNum">     964 </span>            :        no iDCT rounding.*/
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     p=(ogg_int16_t)(_dct_coeffs[0]*(ogg_int32_t)_dc_quant+15&gt;&gt;5);</span>
<span class="lineNum">     966 </span>            :     /*LOOP VECTORIZES.*/
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     for(ci=0;ci&lt;64;ci++)_dct_coeffs[64+ci]=p;</span>
<span class="lineNum">     968 </span>            :   }
<span class="lineNum">     969 </span>            :   else{
<span class="lineNum">     970 </span>            :     /*First, dequantize the DC coefficient.*/
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     _dct_coeffs[0]=(ogg_int16_t)(_dct_coeffs[0]*(int)_dc_quant);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :     oc_idct8x8(_state,_dct_coeffs+64,_dct_coeffs,_last_zzi);</span>
<span class="lineNum">     973 </span>            :   }
<span class="lineNum">     974 </span>            :   /*Fill in the target buffer.*/
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   frag_buf_off=_state-&gt;frag_buf_offs[_fragi];</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   refi=_state-&gt;frags[_fragi].refi;</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   ystride=_state-&gt;ref_ystride[_pli];</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   dst=_state-&gt;ref_frame_data[OC_FRAME_SELF]+frag_buf_off;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   if(refi==OC_FRAME_SELF)oc_frag_recon_intra(_state,dst,ystride,_dct_coeffs+64);</span>
<span class="lineNum">     980 </span>            :   else{
<span class="lineNum">     981 </span>            :     const unsigned char *ref;
<span class="lineNum">     982 </span>            :     int                  mvoffsets[2];
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     ref=_state-&gt;ref_frame_data[refi]+frag_buf_off;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     if(oc_state_get_mv_offsets(_state,mvoffsets,_pli,</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :      _state-&gt;frag_mvs[_fragi])&gt;1){</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :       oc_frag_recon_inter2(_state,</span>
<span class="lineNum">     987 </span>            :        dst,ref+mvoffsets[0],ref+mvoffsets[1],ystride,_dct_coeffs+64);
<span class="lineNum">     988 </span>            :     }
<span class="lineNum">     989 </span>            :     else{
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :       oc_frag_recon_inter(_state,dst,ref+mvoffsets[0],ystride,_dct_coeffs+64);</span>
<span class="lineNum">     991 </span>            :     }
<span class="lineNum">     992 </span>            :   }
<a name="993"><span class="lineNum">     993 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span><span class="lineNoCov">          0 : static void loop_filter_h(unsigned char *_pix,int _ystride,signed char *_bv){</span>
<span class="lineNum">     996 </span>            :   int y;
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   _pix-=2;</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   for(y=0;y&lt;8;y++){</span>
<span class="lineNum">     999 </span>            :     int f;
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     f=_pix[0]-_pix[3]+3*(_pix[2]-_pix[1]);</span>
<span class="lineNum">    1001 </span>            :     /*The _bv array is used to compute the function
<span class="lineNum">    1002 </span>            :       f=OC_CLAMPI(OC_MINI(-_2flimit-f,0),f,OC_MAXI(_2flimit-f,0));
<span class="lineNum">    1003 </span>            :       where _2flimit=_state-&gt;loop_filter_limits[_state-&gt;qis[0]]&lt;&lt;1;*/
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     f=*(_bv+(f+4&gt;&gt;3));</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     _pix[1]=OC_CLAMP255(_pix[1]+f);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     _pix[2]=OC_CLAMP255(_pix[2]-f);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     _pix+=_ystride;</span>
<span class="lineNum">    1008 </span>            :   }
<a name="1009"><span class="lineNum">    1009 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 : static void loop_filter_v(unsigned char *_pix,int _ystride,signed char *_bv){</span>
<span class="lineNum">    1012 </span>            :   int x;
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   _pix-=_ystride*2;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   for(x=0;x&lt;8;x++){</span>
<span class="lineNum">    1015 </span>            :     int f;
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     f=_pix[x]-_pix[_ystride*3+x]+3*(_pix[_ystride*2+x]-_pix[_ystride+x]);</span>
<span class="lineNum">    1017 </span>            :     /*The _bv array is used to compute the function
<span class="lineNum">    1018 </span>            :       f=OC_CLAMPI(OC_MINI(-_2flimit-f,0),f,OC_MAXI(_2flimit-f,0));
<span class="lineNum">    1019 </span>            :       where _2flimit=_state-&gt;loop_filter_limits[_state-&gt;qis[0]]&lt;&lt;1;*/
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     f=*(_bv+(f+4&gt;&gt;3));</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     _pix[_ystride+x]=OC_CLAMP255(_pix[_ystride+x]+f);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     _pix[_ystride*2+x]=OC_CLAMP255(_pix[_ystride*2+x]-f);</span>
<span class="lineNum">    1023 </span>            :   }
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /*Initialize the bounding values array used by the loop filter.
<a name="1027"><span class="lineNum">    1027 </span>            :   _bv: Storage for the array.</a>
<span class="lineNum">    1028 </span>            :   _flimit: The filter limit as defined in Section 7.10 of the spec.*/
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 : void oc_loop_filter_init_c(signed char _bv[256],int _flimit){</span>
<span class="lineNum">    1030 </span>            :   int i;
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   memset(_bv,0,sizeof(_bv[0])*256);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;_flimit;i++){</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     if(127-i-_flimit&gt;=0)_bv[127-i-_flimit]=(signed char)(i-_flimit);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     _bv[127-i]=(signed char)(-i);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     _bv[127+i]=(signed char)(i);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     if(127+i+_flimit&lt;256)_bv[127+i+_flimit]=(signed char)(_flimit-i);</span>
<span class="lineNum">    1037 </span>            :   }
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : /*Apply the loop filter to a given set of fragment rows in the given plane.
<span class="lineNum">    1041 </span>            :   The filter may be run on the bottom edge, affecting pixels in the next row of
<span class="lineNum">    1042 </span>            :    fragments, so this row also needs to be available.
<span class="lineNum">    1043 </span>            :   _bv:        The bounding values array.
<span class="lineNum">    1044 </span>            :   _refi:      The index of the frame buffer to filter.
<span class="lineNum">    1045 </span>            :   _pli:       The color plane to filter.
<a name="1046"><span class="lineNum">    1046 </span>            :   _fragy0:    The Y coordinate of the first fragment row to filter.</a>
<span class="lineNum">    1047 </span>            :   _fragy_end: The Y coordinate of the fragment row to stop filtering at.*/
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 : void oc_state_loop_filter_frag_rows_c(const oc_theora_state *_state,</span>
<span class="lineNum">    1049 </span>            :  signed char *_bv,int _refi,int _pli,int _fragy0,int _fragy_end){
<span class="lineNum">    1050 </span>            :   const oc_fragment_plane *fplane;
<span class="lineNum">    1051 </span>            :   const oc_fragment       *frags;
<span class="lineNum">    1052 </span>            :   const ptrdiff_t         *frag_buf_offs;
<span class="lineNum">    1053 </span>            :   unsigned char           *ref_frame_data;
<span class="lineNum">    1054 </span>            :   ptrdiff_t                fragi_top;
<span class="lineNum">    1055 </span>            :   ptrdiff_t                fragi_bot;
<span class="lineNum">    1056 </span>            :   ptrdiff_t                fragi0;
<span class="lineNum">    1057 </span>            :   ptrdiff_t                fragi0_end;
<span class="lineNum">    1058 </span>            :   int                      ystride;
<span class="lineNum">    1059 </span>            :   int                      nhfrags;
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   _bv+=127;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   fplane=_state-&gt;fplanes+_pli;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :   nhfrags=fplane-&gt;nhfrags;</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   fragi_top=fplane-&gt;froffset;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   fragi_bot=fragi_top+fplane-&gt;nfrags;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   fragi0=fragi_top+_fragy0*(ptrdiff_t)nhfrags;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   fragi0_end=fragi_top+_fragy_end*(ptrdiff_t)nhfrags;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   ystride=_state-&gt;ref_ystride[_pli];</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :   frags=_state-&gt;frags;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   frag_buf_offs=_state-&gt;frag_buf_offs;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   ref_frame_data=_state-&gt;ref_frame_data[_refi];</span>
<span class="lineNum">    1071 </span>            :   /*The following loops are constructed somewhat non-intuitively on purpose.
<span class="lineNum">    1072 </span>            :     The main idea is: if a block boundary has at least one coded fragment on
<span class="lineNum">    1073 </span>            :      it, the filter is applied to it.
<span class="lineNum">    1074 </span>            :     However, the order that the filters are applied in matters, and VP3 chose
<span class="lineNum">    1075 </span>            :      the somewhat strange ordering used below.*/
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   while(fragi0&lt;fragi0_end){</span>
<span class="lineNum">    1077 </span>            :     ptrdiff_t fragi;
<span class="lineNum">    1078 </span>            :     ptrdiff_t fragi_end;
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     fragi=fragi0;</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     fragi_end=fragi+nhfrags;</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     while(fragi&lt;fragi_end){</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :       if(frags[fragi].coded){</span>
<span class="lineNum">    1083 </span>            :         unsigned char *ref;
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         ref=ref_frame_data+frag_buf_offs[fragi];</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         if(fragi&gt;fragi0)loop_filter_h(ref,ystride,_bv);</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         if(fragi0&gt;fragi_top)loop_filter_v(ref,ystride,_bv);</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :         if(fragi+1&lt;fragi_end&amp;&amp;!frags[fragi+1].coded){</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :           loop_filter_h(ref+8,ystride,_bv);</span>
<span class="lineNum">    1089 </span>            :         }
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :         if(fragi+nhfrags&lt;fragi_bot&amp;&amp;!frags[fragi+nhfrags].coded){</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :           loop_filter_v(ref+(ystride&lt;&lt;3),ystride,_bv);</span>
<span class="lineNum">    1092 </span>            :         }
<span class="lineNum">    1093 </span>            :       }
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :       fragi++;</span>
<span class="lineNum">    1095 </span>            :     }
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     fragi0+=nhfrags;</span>
<span class="lineNum">    1097 </span>            :   }
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : #if defined(OC_DUMP_IMAGES)
<span class="lineNum">    1101 </span>            : int oc_state_dump_frame(const oc_theora_state *_state,int _frame,
<span class="lineNum">    1102 </span>            :  const char *_suf){
<span class="lineNum">    1103 </span>            :   /*Dump a PNG of the reconstructed image.*/
<span class="lineNum">    1104 </span>            :   png_structp    png;
<span class="lineNum">    1105 </span>            :   png_infop      info;
<span class="lineNum">    1106 </span>            :   png_bytep     *image;
<span class="lineNum">    1107 </span>            :   FILE          *fp;
<span class="lineNum">    1108 </span>            :   char           fname[16];
<span class="lineNum">    1109 </span>            :   unsigned char *y_row;
<span class="lineNum">    1110 </span>            :   unsigned char *u_row;
<span class="lineNum">    1111 </span>            :   unsigned char *v_row;
<span class="lineNum">    1112 </span>            :   unsigned char *y;
<span class="lineNum">    1113 </span>            :   unsigned char *u;
<span class="lineNum">    1114 </span>            :   unsigned char *v;
<span class="lineNum">    1115 </span>            :   ogg_int64_t    iframe;
<span class="lineNum">    1116 </span>            :   ogg_int64_t    pframe;
<span class="lineNum">    1117 </span>            :   int            y_stride;
<span class="lineNum">    1118 </span>            :   int            u_stride;
<span class="lineNum">    1119 </span>            :   int            v_stride;
<span class="lineNum">    1120 </span>            :   int            framei;
<span class="lineNum">    1121 </span>            :   int            width;
<span class="lineNum">    1122 </span>            :   int            height;
<span class="lineNum">    1123 </span>            :   int            imgi;
<span class="lineNum">    1124 </span>            :   int            imgj;
<span class="lineNum">    1125 </span>            :   width=_state-&gt;info.frame_width;
<span class="lineNum">    1126 </span>            :   height=_state-&gt;info.frame_height;
<span class="lineNum">    1127 </span>            :   iframe=_state-&gt;granpos&gt;&gt;_state-&gt;info.keyframe_granule_shift;
<span class="lineNum">    1128 </span>            :   pframe=_state-&gt;granpos-(iframe&lt;&lt;_state-&gt;info.keyframe_granule_shift);
<span class="lineNum">    1129 </span>            :   sprintf(fname,&quot;%08i%s.png&quot;,(int)(iframe+pframe),_suf);
<span class="lineNum">    1130 </span>            :   fp=fopen(fname,&quot;wb&quot;);
<span class="lineNum">    1131 </span>            :   if(fp==NULL)return TH_EFAULT;
<span class="lineNum">    1132 </span>            :   image=(png_bytep *)oc_malloc_2d(height,6*width,sizeof(**image));
<span class="lineNum">    1133 </span>            :   if(image==NULL){
<span class="lineNum">    1134 </span>            :     fclose(fp);
<span class="lineNum">    1135 </span>            :     return TH_EFAULT;
<span class="lineNum">    1136 </span>            :   }
<span class="lineNum">    1137 </span>            :   png=png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
<span class="lineNum">    1138 </span>            :   if(png==NULL){
<span class="lineNum">    1139 </span>            :     oc_free_2d(image);
<span class="lineNum">    1140 </span>            :     fclose(fp);
<span class="lineNum">    1141 </span>            :     return TH_EFAULT;
<span class="lineNum">    1142 </span>            :   }
<span class="lineNum">    1143 </span>            :   info=png_create_info_struct(png);
<span class="lineNum">    1144 </span>            :   if(info==NULL){
<span class="lineNum">    1145 </span>            :     png_destroy_write_struct(&amp;png,NULL);
<span class="lineNum">    1146 </span>            :     oc_free_2d(image);
<span class="lineNum">    1147 </span>            :     fclose(fp);
<span class="lineNum">    1148 </span>            :     return TH_EFAULT;
<span class="lineNum">    1149 </span>            :   }
<span class="lineNum">    1150 </span>            :   if(setjmp(png_jmpbuf(png))){
<span class="lineNum">    1151 </span>            :     png_destroy_write_struct(&amp;png,&amp;info);
<span class="lineNum">    1152 </span>            :     oc_free_2d(image);
<span class="lineNum">    1153 </span>            :     fclose(fp);
<span class="lineNum">    1154 </span>            :     return TH_EFAULT;
<span class="lineNum">    1155 </span>            :   }
<span class="lineNum">    1156 </span>            :   framei=_state-&gt;ref_frame_idx[_frame];
<span class="lineNum">    1157 </span>            :   y_row=_state-&gt;ref_frame_bufs[framei][0].data;
<span class="lineNum">    1158 </span>            :   u_row=_state-&gt;ref_frame_bufs[framei][1].data;
<span class="lineNum">    1159 </span>            :   v_row=_state-&gt;ref_frame_bufs[framei][2].data;
<span class="lineNum">    1160 </span>            :   y_stride=_state-&gt;ref_frame_bufs[framei][0].stride;
<span class="lineNum">    1161 </span>            :   u_stride=_state-&gt;ref_frame_bufs[framei][1].stride;
<span class="lineNum">    1162 </span>            :   v_stride=_state-&gt;ref_frame_bufs[framei][2].stride;
<span class="lineNum">    1163 </span>            :   /*Chroma up-sampling is just done with a box filter.
<span class="lineNum">    1164 </span>            :     This is very likely what will actually be used in practice on a real
<span class="lineNum">    1165 </span>            :      display, and also removes one more layer to search in for the source of
<span class="lineNum">    1166 </span>            :      artifacts.
<span class="lineNum">    1167 </span>            :     As an added bonus, it's dead simple.*/
<span class="lineNum">    1168 </span>            :   for(imgi=height;imgi--&gt;0;){
<span class="lineNum">    1169 </span>            :     int dc;
<span class="lineNum">    1170 </span>            :     y=y_row;
<span class="lineNum">    1171 </span>            :     u=u_row;
<span class="lineNum">    1172 </span>            :     v=v_row;
<span class="lineNum">    1173 </span>            :     for(imgj=0;imgj&lt;6*width;){
<span class="lineNum">    1174 </span>            :       float    yval;
<span class="lineNum">    1175 </span>            :       float    uval;
<span class="lineNum">    1176 </span>            :       float    vval;
<span class="lineNum">    1177 </span>            :       unsigned rval;
<span class="lineNum">    1178 </span>            :       unsigned gval;
<span class="lineNum">    1179 </span>            :       unsigned bval;
<span class="lineNum">    1180 </span>            :       /*This is intentionally slow and very accurate.*/
<span class="lineNum">    1181 </span>            :       yval=(*y-16)*(1.0F/219);
<span class="lineNum">    1182 </span>            :       uval=(*u-128)*(2*(1-0.114F)/224);
<span class="lineNum">    1183 </span>            :       vval=(*v-128)*(2*(1-0.299F)/224);
<span class="lineNum">    1184 </span>            :       rval=OC_CLAMPI(0,(int)(65535*(yval+vval)+0.5F),65535);
<span class="lineNum">    1185 </span>            :       gval=OC_CLAMPI(0,(int)(65535*(
<span class="lineNum">    1186 </span>            :        yval-uval*(0.114F/0.587F)-vval*(0.299F/0.587F))+0.5F),65535);
<span class="lineNum">    1187 </span>            :       bval=OC_CLAMPI(0,(int)(65535*(yval+uval)+0.5F),65535);
<span class="lineNum">    1188 </span>            :       image[imgi][imgj++]=(unsigned char)(rval&gt;&gt;8);
<span class="lineNum">    1189 </span>            :       image[imgi][imgj++]=(unsigned char)(rval&amp;0xFF);
<span class="lineNum">    1190 </span>            :       image[imgi][imgj++]=(unsigned char)(gval&gt;&gt;8);
<span class="lineNum">    1191 </span>            :       image[imgi][imgj++]=(unsigned char)(gval&amp;0xFF);
<span class="lineNum">    1192 </span>            :       image[imgi][imgj++]=(unsigned char)(bval&gt;&gt;8);
<span class="lineNum">    1193 </span>            :       image[imgi][imgj++]=(unsigned char)(bval&amp;0xFF);
<span class="lineNum">    1194 </span>            :       dc=(y-y_row&amp;1)|(_state-&gt;info.pixel_fmt&amp;1);
<span class="lineNum">    1195 </span>            :       y++;
<span class="lineNum">    1196 </span>            :       u+=dc;
<span class="lineNum">    1197 </span>            :       v+=dc;
<span class="lineNum">    1198 </span>            :     }
<span class="lineNum">    1199 </span>            :     dc=-((height-1-imgi&amp;1)|_state-&gt;info.pixel_fmt&gt;&gt;1);
<span class="lineNum">    1200 </span>            :     y_row+=y_stride;
<span class="lineNum">    1201 </span>            :     u_row+=dc&amp;u_stride;
<span class="lineNum">    1202 </span>            :     v_row+=dc&amp;v_stride;
<span class="lineNum">    1203 </span>            :   }
<span class="lineNum">    1204 </span>            :   png_init_io(png,fp);
<span class="lineNum">    1205 </span>            :   png_set_compression_level(png,Z_BEST_COMPRESSION);
<span class="lineNum">    1206 </span>            :   png_set_IHDR(png,info,width,height,16,PNG_COLOR_TYPE_RGB,
<span class="lineNum">    1207 </span>            :    PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);
<span class="lineNum">    1208 </span>            :   switch(_state-&gt;info.colorspace){
<span class="lineNum">    1209 </span>            :     case TH_CS_ITU_REC_470M:{
<span class="lineNum">    1210 </span>            :       png_set_gAMA(png,info,2.2);
<span class="lineNum">    1211 </span>            :       png_set_cHRM_fixed(png,info,31006,31616,
<span class="lineNum">    1212 </span>            :        67000,32000,21000,71000,14000,8000);
<span class="lineNum">    1213 </span>            :     }break;
<span class="lineNum">    1214 </span>            :     case TH_CS_ITU_REC_470BG:{
<span class="lineNum">    1215 </span>            :       png_set_gAMA(png,info,2.67);
<span class="lineNum">    1216 </span>            :       png_set_cHRM_fixed(png,info,31271,32902,
<span class="lineNum">    1217 </span>            :        64000,33000,29000,60000,15000,6000);
<span class="lineNum">    1218 </span>            :     }break;
<span class="lineNum">    1219 </span>            :     default:break;
<span class="lineNum">    1220 </span>            :   }
<span class="lineNum">    1221 </span>            :   png_set_pHYs(png,info,_state-&gt;info.aspect_numerator,
<span class="lineNum">    1222 </span>            :    _state-&gt;info.aspect_denominator,0);
<span class="lineNum">    1223 </span>            :   png_set_rows(png,info,image);
<span class="lineNum">    1224 </span>            :   png_write_png(png,info,PNG_TRANSFORM_IDENTITY,NULL);
<span class="lineNum">    1225 </span>            :   png_write_end(png,info);
<span class="lineNum">    1226 </span>            :   png_destroy_write_struct(&amp;png,&amp;info);
<span class="lineNum">    1227 </span>            :   oc_free_2d(image);
<span class="lineNum">    1228 </span>            :   fclose(fp);
<span class="lineNum">    1229 </span>            :   return 0;
<span class="lineNum">    1230 </span>            : }
<span class="lineNum">    1231 </span>            : #endif
<span class="lineNum">    1232 </span>            : 
<a name="1233"><span class="lineNum">    1233 </span>            : </a>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 : ogg_int64_t th_granule_frame(void *_encdec,ogg_int64_t _granpos){</span>
<span class="lineNum">    1236 </span>            :   oc_theora_state *state;
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   state=(oc_theora_state *)_encdec;</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   if(_granpos&gt;=0){</span>
<span class="lineNum">    1239 </span>            :     ogg_int64_t iframe;
<span class="lineNum">    1240 </span>            :     ogg_int64_t pframe;
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     iframe=_granpos&gt;&gt;state-&gt;info.keyframe_granule_shift;</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     pframe=_granpos-(iframe&lt;&lt;state-&gt;info.keyframe_granule_shift);</span>
<span class="lineNum">    1243 </span>            :     /*3.2.0 streams store the frame index in the granule position.
<span class="lineNum">    1244 </span>            :       3.2.1 and later store the frame count.
<span class="lineNum">    1245 </span>            :       We return the index, so adjust the value if we have a 3.2.1 or later
<span class="lineNum">    1246 </span>            :        stream.*/
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     return iframe+pframe-TH_VERSION_CHECK(&amp;state-&gt;info,3,2,1);</span>
<span class="lineNum">    1248 </span>            :   }
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :   return -1;</span>
<a name="1250"><span class="lineNum">    1250 </span>            : }</a>
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 : double th_granule_time(void *_encdec,ogg_int64_t _granpos){</span>
<span class="lineNum">    1253 </span>            :   oc_theora_state *state;
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   state=(oc_theora_state *)_encdec;</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   if(_granpos&gt;=0){</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     return (th_granule_frame(_encdec, _granpos)+1)*(</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :      (double)state-&gt;info.fps_denominator/state-&gt;info.fps_numerator);</span>
<span class="lineNum">    1258 </span>            :   }
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">    1260 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

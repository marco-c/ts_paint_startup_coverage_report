<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - modules/brotli/dec/decode.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">modules/brotli/dec</a> - decode.c<span style="font-size: 80%;"> (source / <a href="decode.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1133</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright 2013 Google Inc. All Rights Reserved.</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            :    Distributed under MIT license.
<span class="lineNum">       4 </span>            :    See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
<span class="lineNum">       5 </span>            : */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;./decode.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #ifdef __ARM_NEON__
<span class="lineNum">      10 </span>            : #include &lt;arm_neon.h&gt;
<span class="lineNum">      11 </span>            : #endif
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &lt;stdlib.h&gt;  /* free, malloc */
<span class="lineNum">      14 </span>            : #include &lt;string.h&gt;  /* memcpy, memset */
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;./bit_reader.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;./context.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;./dictionary.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;./huffman.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;./port.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;./prefix.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;./state.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;./transform.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #if defined(__cplusplus) || defined(c_plusplus)
<span class="lineNum">      26 </span>            : extern &quot;C&quot; {
<span class="lineNum">      27 </span>            : #endif
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #define BROTLI_FAILURE(CODE) (BROTLI_DUMP(), CODE)
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #define BROTLI_LOG_UINT(name)                                       \
<span class="lineNum">      32 </span>            :   BROTLI_LOG((&quot;[%s] %s = %lu\n&quot;, __func__, #name, (unsigned long)(name)))
<span class="lineNum">      33 </span>            : #define BROTLI_LOG_ARRAY_INDEX(array_name, idx)                     \
<span class="lineNum">      34 </span>            :   BROTLI_LOG((&quot;[%s] %s[%lu] = %lu\n&quot;, __func__, #array_name,        \
<span class="lineNum">      35 </span>            :          (unsigned long)(idx), (unsigned long)array_name[idx]))
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : static const uint32_t kDefaultCodeLength = 8;
<span class="lineNum">      38 </span>            : static const uint32_t kCodeLengthRepeatCode = 16;
<span class="lineNum">      39 </span>            : static const uint32_t kNumLiteralCodes = 256;
<span class="lineNum">      40 </span>            : static const uint32_t kNumInsertAndCopyCodes = 704;
<span class="lineNum">      41 </span>            : static const uint32_t kNumBlockLengthCodes = 26;
<span class="lineNum">      42 </span>            : static const int kLiteralContextBits = 6;
<span class="lineNum">      43 </span>            : static const int kDistanceContextBits = 2;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #define HUFFMAN_TABLE_BITS 8U
<span class="lineNum">      46 </span>            : #define HUFFMAN_TABLE_MASK 0xff
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : #define CODE_LENGTH_CODES 18
<span class="lineNum">      49 </span>            : static const uint8_t kCodeLengthCodeOrder[CODE_LENGTH_CODES] = {
<span class="lineNum">      50 </span>            :   1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
<span class="lineNum">      51 </span>            : };
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /* Static prefix code for the complex code length code lengths. */
<span class="lineNum">      54 </span>            : static const uint8_t kCodeLengthPrefixLength[16] = {
<span class="lineNum">      55 </span>            :   2, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 4,
<span class="lineNum">      56 </span>            : };
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : static const uint8_t kCodeLengthPrefixValue[16] = {
<span class="lineNum">      59 </span>            :   0, 4, 3, 2, 0, 4, 3, 1, 0, 4, 3, 2, 0, 4, 3, 5,
<span class="lineNum">      60 </span>            : };
<span class="lineNum">      61 </span>            : 
<a name="62"><span class="lineNum">      62 </span>            : #define NUM_DISTANCE_SHORT_CODES 16</a>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span><span class="lineNoCov">          0 : BrotliState* BrotliCreateState(</span>
<span class="lineNum">      65 </span>            :     brotli_alloc_func alloc_func, brotli_free_func free_func, void* opaque) {
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   BrotliState* state = 0;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   if (!alloc_func &amp;&amp; !free_func) {</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :     state = (BrotliState*)malloc(sizeof(BrotliState));</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   } else if (alloc_func &amp;&amp; free_func) {</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     state = (BrotliState*)alloc_func(opaque, sizeof(BrotliState));</span>
<span class="lineNum">      71 </span>            :   }
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   if (state == 0) {</span>
<span class="lineNum">      73 </span>            :     BROTLI_DUMP();
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   BrotliStateInitWithCustomAllocators(state, alloc_func, free_func, opaque);</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   state-&gt;error_code = BROTLI_NO_ERROR;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   return state;</span>
<span class="lineNum">      79 </span>            : }
<a name="80"><span class="lineNum">      80 </span>            : </a>
<span class="lineNum">      81 </span>            : /* Deinitializes and frees BrotliState instance. */
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : void BrotliDestroyState(BrotliState* state) {</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   if (!state) {</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">      85 </span>            :   } else {
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     brotli_free_func free_func = state-&gt;free_func;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     void* opaque = state-&gt;memory_manager_opaque;</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     BrotliStateCleanup(state);</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     free_func(opaque, state);</span>
<span class="lineNum">      90 </span>            :   }
<span class="lineNum">      91 </span>            : }
<a name="92"><span class="lineNum">      92 </span>            : </a>
<span class="lineNum">      93 </span>            : /* Saves error code and converts it to BrotliResult */
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE BrotliResult SaveErrorCode(</span>
<span class="lineNum">      95 </span>            :     BrotliState* s, BrotliErrorCode e) {
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   s-&gt;error_code = (int)e;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   switch (e) {</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     case BROTLI_SUCCESS: return BROTLI_RESULT_SUCCESS;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     case BROTLI_NEEDS_MORE_INPUT: return BROTLI_RESULT_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     case BROTLI_NEEDS_MORE_OUTPUT: return BROTLI_RESULT_NEEDS_MORE_OUTPUT;</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     default: return BROTLI_RESULT_ERROR;</span>
<span class="lineNum">     102 </span>            :   }
<span class="lineNum">     103 </span>            : }
<span class="lineNum">     104 </span>            : 
<a name="105"><span class="lineNum">     105 </span>            : /* Decodes a number in the range [9..24], by reading 1 - 7 bits.</a>
<span class="lineNum">     106 </span>            :    Precondition: bit-reader accumulator has at least 7 bits. */
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : static uint32_t DecodeWindowBits(BrotliBitReader* br) {</span>
<span class="lineNum">     108 </span>            :   uint32_t n;
<span class="lineNum">     109 </span>            :   BrotliTakeBits(br, 1, &amp;n);
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   if (n == 0) {</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     return 16;</span>
<span class="lineNum">     112 </span>            :   }
<span class="lineNum">     113 </span>            :   BrotliTakeBits(br, 3, &amp;n);
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   if (n != 0) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     return 17 + n;</span>
<span class="lineNum">     116 </span>            :   }
<span class="lineNum">     117 </span>            :   BrotliTakeBits(br, 3, &amp;n);
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   if (n != 0) {</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :     return 8 + n;</span>
<span class="lineNum">     120 </span>            :   }
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   return 17;</span>
<span class="lineNum">     122 </span>            : }
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : static BROTLI_INLINE void memmove16(uint8_t* dst, uint8_t* src) {
<span class="lineNum">     125 </span>            : #if defined(__ARM_NEON__)
<span class="lineNum">     126 </span>            :   vst1q_u8(dst, vld1q_u8(src));
<span class="lineNum">     127 </span>            : #else
<span class="lineNum">     128 </span>            :   uint32_t buffer[4];
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   memcpy(buffer, src, 16);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   memcpy(dst, buffer, 16);</span>
<span class="lineNum">     131 </span>            : #endif
<span class="lineNum">     132 </span>            : }
<a name="133"><span class="lineNum">     133 </span>            : </a>
<span class="lineNum">     134 </span>            : /* Decodes a number in the range [0..255], by reading 1 - 11 bits. */
<span class="lineNum">     135 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE BrotliErrorCode DecodeVarLenUint8(BrotliState* s,</span>
<span class="lineNum">     136 </span>            :     BrotliBitReader* br, uint32_t* value) {
<span class="lineNum">     137 </span>            :   uint32_t bits;
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   switch (s-&gt;substate_decode_uint8) {</span>
<span class="lineNum">     139 </span>            :     case BROTLI_STATE_DECODE_UINT8_NONE:
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(!BrotliSafeReadBits(br, 1, &amp;bits))) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     142 </span>            :       }
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :       if (bits == 0) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         *value = 0;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         return BROTLI_SUCCESS;</span>
<span class="lineNum">     146 </span>            :       }
<span class="lineNum">     147 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :     case BROTLI_STATE_DECODE_UINT8_SHORT:
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(!BrotliSafeReadBits(br, 3, &amp;bits))) {</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         s-&gt;substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_SHORT;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     153 </span>            :       }
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :       if (bits == 0) {</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         *value = 1;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         s-&gt;substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_NONE;</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         return BROTLI_SUCCESS;</span>
<span class="lineNum">     158 </span>            :       }
<span class="lineNum">     159 </span>            :       /* Use output value as a temporary storage. It MUST be persisted. */
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       *value = bits;</span>
<span class="lineNum">     161 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :     case BROTLI_STATE_DECODE_UINT8_LONG:
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(!BrotliSafeReadBits(br, *value, &amp;bits))) {</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :         s-&gt;substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_LONG;</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     167 </span>            :       }
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       *value = (1U &lt;&lt; *value) + bits;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       s-&gt;substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_NONE;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :       return BROTLI_SUCCESS;</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     default:
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       return BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE);</span>
<span class="lineNum">     174 </span>            :   }
<span class="lineNum">     175 </span>            : }
<a name="176"><span class="lineNum">     176 </span>            : </a>
<span class="lineNum">     177 </span>            : /* Decodes a metablock length and flags by reading 2 - 31 bits. */
<span class="lineNum">     178 </span><span class="lineNoCov">          0 : static BrotliErrorCode BROTLI_NOINLINE DecodeMetaBlockLength(</span>
<span class="lineNum">     179 </span>            :     BrotliState* s, BrotliBitReader* br) {
<span class="lineNum">     180 </span>            :   uint32_t bits;
<span class="lineNum">     181 </span>            :   int i;
<span class="lineNum">     182 </span>            :   for (;;) {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     switch (s-&gt;substate_metablock_header) {</span>
<span class="lineNum">     184 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_NONE:
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     187 </span>            :         }
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :         s-&gt;is_last_metablock = (uint8_t)bits;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         s-&gt;meta_block_remaining_len = 0;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :         s-&gt;is_uncompressed = 0;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         s-&gt;is_metadata = 0;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         if (!s-&gt;is_last_metablock) {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :           s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NIBBLES;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     195 </span>            :         }
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_EMPTY;</span>
<span class="lineNum">     197 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_EMPTY:
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     202 </span>            :         }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         if (bits) {</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :           s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :           return BROTLI_SUCCESS;</span>
<span class="lineNum">     206 </span>            :         }
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NIBBLES;</span>
<span class="lineNum">     208 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_NIBBLES:
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 2, &amp;bits)) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     213 </span>            :         }
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         s-&gt;size_nibbles = (uint8_t)(bits + 4);</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter = 0;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         if (bits == 3) {</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :           s-&gt;is_metadata = 1;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :           s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_RESERVED;</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     220 </span>            :         }
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_SIZE;</span>
<span class="lineNum">     222 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_SIZE:
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         i = s-&gt;loop_counter;</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         for (; i &lt; s-&gt;size_nibbles; ++i) {</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :           if (!BrotliSafeReadBits(br, 4, &amp;bits)) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :             s-&gt;loop_counter = i;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :             return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     230 </span>            :           }
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :           if (i + 1 == s-&gt;size_nibbles &amp;&amp; s-&gt;size_nibbles &gt; 4 &amp;&amp; bits == 0) {</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :             return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_EXUBERANT_NIBBLE);</span>
<span class="lineNum">     233 </span>            :           }
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :           s-&gt;meta_block_remaining_len |= (int)(bits &lt;&lt; (i * 4));</span>
<span class="lineNum">     235 </span>            :         }
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header =</span>
<span class="lineNum">     237 </span>            :             BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED;
<span class="lineNum">     238 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED:
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         if (!s-&gt;is_last_metablock) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :           if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     244 </span>            :           }
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :           s-&gt;is_uncompressed = (uint8_t)bits;</span>
<span class="lineNum">     246 </span>            :         }
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         ++s-&gt;meta_block_remaining_len;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         return BROTLI_SUCCESS;</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_RESERVED:
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     254 </span>            :         }
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         if (bits != 0) {</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :           return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_RESERVED);</span>
<span class="lineNum">     257 </span>            :         }
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_BYTES;</span>
<span class="lineNum">     259 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_BYTES:
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 2, &amp;bits)) {</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     264 </span>            :         }
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         if (bits == 0) {</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :           s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :           return BROTLI_SUCCESS;</span>
<span class="lineNum">     268 </span>            :         }
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         s-&gt;size_nibbles = (uint8_t)bits;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_METADATA;</span>
<span class="lineNum">     271 </span>            :         /* No break, transit to the next state. */
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_METADATA:
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         i = s-&gt;loop_counter;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         for (; i &lt; s-&gt;size_nibbles; ++i) {</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :           if (!BrotliSafeReadBits(br, 8, &amp;bits)) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :             s-&gt;loop_counter = i;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :             return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     279 </span>            :           }
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :           if (i + 1 == s-&gt;size_nibbles &amp;&amp; s-&gt;size_nibbles &gt; 1 &amp;&amp; bits == 0) {</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :             return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_EXUBERANT_META_NIBBLE);</span>
<span class="lineNum">     282 </span>            :           }
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :           s-&gt;meta_block_remaining_len |= (int)(bits &lt;&lt; (i * 8));</span>
<span class="lineNum">     284 </span>            :         }
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         ++s-&gt;meta_block_remaining_len;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :         s-&gt;substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         return BROTLI_SUCCESS;</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :       default:
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :         return BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE);</span>
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span>            : }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : /* Decodes the Huffman code.
<span class="lineNum">     296 </span>            :    This method doesn't read data from the bit reader, BUT drops the amount of
<span class="lineNum">     297 </span>            :    bits that correspond to the decoded symbol.
<span class="lineNum">     298 </span>            :    bits MUST contain at least 15 (BROTLI_HUFFMAN_MAX_CODE_LENGTH) valid bits. */
<span class="lineNum">     299 </span>            : static BROTLI_INLINE uint32_t DecodeSymbol(uint32_t bits,
<span class="lineNum">     300 </span>            :                                            const HuffmanCode* table,
<span class="lineNum">     301 </span>            :                                            BrotliBitReader* br) {
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   table += bits &amp; HUFFMAN_TABLE_MASK;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   if (table-&gt;bits &gt; HUFFMAN_TABLE_BITS) {</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     uint32_t nbits = table-&gt;bits - HUFFMAN_TABLE_BITS;</span>
<span class="lineNum">     305 </span>            :     BrotliDropBits(br, HUFFMAN_TABLE_BITS);
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     table += table-&gt;value;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     table += (bits &gt;&gt; HUFFMAN_TABLE_BITS) &amp; BitMask(nbits);</span>
<span class="lineNum">     308 </span>            :   }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   BrotliDropBits(br, table-&gt;bits);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   return table-&gt;value;</span>
<span class="lineNum">     311 </span>            : }
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : /* Reads and decodes the next Huffman code from bit-stream.
<span class="lineNum">     314 </span>            :    This method peeks 16 bits of input and drops 0 - 15 of them. */
<span class="lineNum">     315 </span>            : static BROTLI_INLINE uint32_t ReadSymbol(const HuffmanCode* table,
<span class="lineNum">     316 </span>            :                                          BrotliBitReader* br) {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   return DecodeSymbol(BrotliGet16BitsUnmasked(br), table, br);</span>
<span class="lineNum">     318 </span>            : }
<span class="lineNum">     319 </span>            : 
<a name="320"><span class="lineNum">     320 </span>            : /* Same as DecodeSymbol, but it is known that there is less than 15 bits of</a>
<span class="lineNum">     321 </span>            :    input are currently available. */
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE int SafeDecodeSymbol(const HuffmanCode* table,</span>
<span class="lineNum">     323 </span>            :                                             BrotliBitReader* br,
<span class="lineNum">     324 </span>            :                                             uint32_t* result) {
<span class="lineNum">     325 </span>            :   uint32_t val;
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   uint32_t available_bits = BrotliGetAvailableBits(br);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   if (available_bits == 0) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     if (table-&gt;bits == 0) {</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       *result = table-&gt;value;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">     331 </span>            :     }
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     return 0; /* No valid bits at all. */</span>
<span class="lineNum">     333 </span>            :   }
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   val = (uint32_t)BrotliGetBitsUnmasked(br);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   table += val &amp; HUFFMAN_TABLE_MASK;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   if (table-&gt;bits &lt;= HUFFMAN_TABLE_BITS) {</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     if (table-&gt;bits &lt;= available_bits) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :       BrotliDropBits(br, table-&gt;bits);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       *result = table-&gt;value;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">     341 </span>            :     } else {
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :       return 0; /* Not enough bits for the first level. */</span>
<span class="lineNum">     343 </span>            :     }
<span class="lineNum">     344 </span>            :   }
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   if (available_bits &lt;= HUFFMAN_TABLE_BITS) {</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     return 0; /* Not enough bits to move to the second level. */</span>
<span class="lineNum">     347 </span>            :   }
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :   /* Speculatively drop HUFFMAN_TABLE_BITS. */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   val = (val &amp; BitMask(table-&gt;bits)) &gt;&gt; HUFFMAN_TABLE_BITS;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   available_bits -= HUFFMAN_TABLE_BITS;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   table += table-&gt;value + val;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   if (available_bits &lt; table-&gt;bits) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     return 0; /* Not enough bits for the second level. */</span>
<span class="lineNum">     355 </span>            :   }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   BrotliDropBits(br, HUFFMAN_TABLE_BITS + table-&gt;bits);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   *result = table-&gt;value;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     360 </span>            : }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : static BROTLI_INLINE int SafeReadSymbol(const HuffmanCode* table,
<span class="lineNum">     363 </span>            :                                         BrotliBitReader* br,
<span class="lineNum">     364 </span>            :                                         uint32_t* result) {
<span class="lineNum">     365 </span>            :   uint32_t val;
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   if (PREDICT_TRUE(BrotliSafeGetBits(br, 15, &amp;val))) {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     *result = DecodeSymbol(val, table, br);</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     369 </span>            :   }
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   return SafeDecodeSymbol(table, br, result);</span>
<span class="lineNum">     371 </span>            : }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* Makes a look-up in first level Huffman table. Peeks 8 bits. */
<span class="lineNum">     374 </span>            : static BROTLI_INLINE void PreloadSymbol(int safe,
<span class="lineNum">     375 </span>            :                                         const HuffmanCode* table,
<span class="lineNum">     376 </span>            :                                         BrotliBitReader* br,
<span class="lineNum">     377 </span>            :                                         uint32_t* bits,
<span class="lineNum">     378 </span>            :                                         uint32_t* value) {
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   if (safe) {</span>
<span class="lineNum">     380 </span>            :     return;
<span class="lineNum">     381 </span>            :   }
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   table += BrotliGetBits(br, HUFFMAN_TABLE_BITS);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   *bits = table-&gt;bits;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   *value = table-&gt;value;</span>
<span class="lineNum">     385 </span>            : }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /* Decodes the next Huffman code using data prepared by PreloadSymbol.
<span class="lineNum">     388 </span>            :    Reads 0 - 15 bits. Also peeks 8 following bits. */
<span class="lineNum">     389 </span>            : static BROTLI_INLINE uint32_t ReadPreloadedSymbol(const HuffmanCode* table,
<span class="lineNum">     390 </span>            :                                                   BrotliBitReader* br,
<span class="lineNum">     391 </span>            :                                                   uint32_t* bits,
<span class="lineNum">     392 </span>            :                                                   uint32_t* value) {
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   uint32_t result = *value;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   if (PREDICT_FALSE(*bits &gt; HUFFMAN_TABLE_BITS)) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     uint32_t val = BrotliGet16BitsUnmasked(br);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     const HuffmanCode* ext = table + (val &amp; HUFFMAN_TABLE_MASK) + *value;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     uint32_t mask = BitMask((*bits - HUFFMAN_TABLE_BITS));</span>
<span class="lineNum">     398 </span>            :     BrotliDropBits(br, HUFFMAN_TABLE_BITS);
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     ext += (val &gt;&gt; HUFFMAN_TABLE_BITS) &amp; mask;</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     BrotliDropBits(br, ext-&gt;bits);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     result = ext-&gt;value;</span>
<span class="lineNum">     402 </span>            :   } else {
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     BrotliDropBits(br, *bits);</span>
<span class="lineNum">     404 </span>            :   }
<span class="lineNum">     405 </span>            :   PreloadSymbol(0, table, br, bits, value);
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     407 </span>            : }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : static BROTLI_INLINE uint32_t Log2Floor(uint32_t x) {
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   uint32_t result = 0;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   while (x) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     x &gt;&gt;= 1;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     ++result;</span>
<span class="lineNum">     414 </span>            :   }
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     416 </span>            : }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : /* Reads (s-&gt;symbol + 1) symbols.
<span class="lineNum">     419 </span>            :    Totally 1..4 symbols are read, 1..10 bits each.
<a name="420"><span class="lineNum">     420 </span>            :    The list of symbols MUST NOT contain duplicates.</a>
<span class="lineNum">     421 </span>            :  */
<span class="lineNum">     422 </span><span class="lineNoCov">          0 : static BrotliErrorCode ReadSimpleHuffmanSymbols(uint32_t alphabet_size,</span>
<span class="lineNum">     423 </span>            :                                                 BrotliState* s) {
<span class="lineNum">     424 </span>            :   /* max_bits == 1..10; symbol == 0..3; 1..40 bits will be read. */
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   uint32_t max_bits = Log2Floor(alphabet_size - 1);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   uint32_t i = s-&gt;sub_loop_counter;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   uint32_t num_symbols = s-&gt;symbol;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   while (i &lt;= num_symbols) {</span>
<span class="lineNum">     430 </span>            :     uint32_t v;
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     if (PREDICT_FALSE(!BrotliSafeReadBits(br, max_bits, &amp;v))) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       s-&gt;sub_loop_counter = i;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :       s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_READ;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     if (v &gt;= alphabet_size) {</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET);</span>
<span class="lineNum">     438 </span>            :     }
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     s-&gt;symbols_lists_array[i] = (uint16_t)v;</span>
<span class="lineNum">     440 </span>            :     BROTLI_LOG_UINT(s-&gt;symbols_lists_array[i]);
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     ++i;</span>
<span class="lineNum">     442 </span>            :   }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; num_symbols; ++i) {</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     uint32_t k = i + 1;</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     for (; k &lt;= num_symbols; ++k) {</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       if (s-&gt;symbols_lists_array[i] == s-&gt;symbols_lists_array[k]) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME);</span>
<span class="lineNum">     449 </span>            :       }
<span class="lineNum">     450 </span>            :     }
<span class="lineNum">     451 </span>            :   }
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : /* Process single decoded symbol code length:
<span class="lineNum">     457 </span>            :     A) reset the repeat variable
<span class="lineNum">     458 </span>            :     B) remember code length (if it is not 0)
<span class="lineNum">     459 </span>            :     C) extend corredponding index-chain
<span class="lineNum">     460 </span>            :     D) reduce the huffman space
<span class="lineNum">     461 </span>            :     E) update the histogram
<span class="lineNum">     462 </span>            :  */
<span class="lineNum">     463 </span>            : static BROTLI_INLINE void ProcessSingleCodeLength(uint32_t code_len,
<span class="lineNum">     464 </span>            :     uint32_t* symbol, uint32_t* repeat, uint32_t* space,
<span class="lineNum">     465 </span>            :     uint32_t* prev_code_len, uint16_t* symbol_lists,
<span class="lineNum">     466 </span>            :     uint16_t* code_length_histo, int* next_symbol) {
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   *repeat = 0;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   if (code_len != 0) { /* code_len == 1..15 */</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     symbol_lists[next_symbol[code_len]] = (uint16_t)(*symbol);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     next_symbol[code_len] = (int)(*symbol);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     *prev_code_len = code_len;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :     *space -= 32768U &gt;&gt; code_len;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     code_length_histo[code_len]++;</span>
<span class="lineNum">     474 </span>            :     BROTLI_LOG((&quot;[ReadHuffmanCode] code_length[%d] = %d\n&quot;, *symbol, code_len));
<span class="lineNum">     475 </span>            :   }
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   (*symbol)++;</span>
<span class="lineNum">     477 </span>            : }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            : /* Process repeated symbol code length.
<span class="lineNum">     480 </span>            :     A) Check if it is the extension of previous repeat sequence; if the decoded
<span class="lineNum">     481 </span>            :        value is not kCodeLengthRepeatCode, then it is a new symbol-skip
<span class="lineNum">     482 </span>            :     B) Update repeat variable
<span class="lineNum">     483 </span>            :     C) Check if operation is feasible (fits alphapet)
<span class="lineNum">     484 </span>            :     D) For each symbol do the same operations as in ProcessSingleCodeLength
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :    PRECONDITION: code_len == kCodeLengthRepeatCode or kCodeLengthRepeatCode + 1
<span class="lineNum">     487 </span>            :  */
<span class="lineNum">     488 </span>            : static BROTLI_INLINE void ProcessRepeatedCodeLength(uint32_t code_len,
<span class="lineNum">     489 </span>            :     uint32_t repeat_delta, uint32_t alphabet_size, uint32_t* symbol,
<span class="lineNum">     490 </span>            :     uint32_t* repeat, uint32_t* space, uint32_t* prev_code_len,
<span class="lineNum">     491 </span>            :     uint32_t* repeat_code_len, uint16_t* symbol_lists,
<span class="lineNum">     492 </span>            :     uint16_t* code_length_histo, int* next_symbol) {
<span class="lineNum">     493 </span>            :   uint32_t old_repeat;
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   uint32_t new_len = 0;</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   if (code_len == kCodeLengthRepeatCode) {</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     new_len = *prev_code_len;</span>
<span class="lineNum">     497 </span>            :   }
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   if (*repeat_code_len != new_len) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     *repeat = 0;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     *repeat_code_len = new_len;</span>
<span class="lineNum">     501 </span>            :   }
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   old_repeat = *repeat;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   if (*repeat &gt; 0) {</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     *repeat -= 2;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     *repeat &lt;&lt;= code_len - 14U;</span>
<span class="lineNum">     506 </span>            :   }
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :   *repeat += repeat_delta + 3U;</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   repeat_delta = *repeat - old_repeat;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   if (*symbol + repeat_delta &gt; alphabet_size) {</span>
<span class="lineNum">     510 </span>            :     BROTLI_DUMP();
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     *symbol = alphabet_size;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     *space = 0xFFFFF;</span>
<span class="lineNum">     513 </span>            :     return;
<span class="lineNum">     514 </span>            :   }
<span class="lineNum">     515 </span>            :   BROTLI_LOG((&quot;[ReadHuffmanCode] code_length[%d..%d] = %d\n&quot;,
<span class="lineNum">     516 </span>            :               *symbol, *symbol + repeat_delta - 1, *repeat_code_len));
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   if (*repeat_code_len != 0) {</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     unsigned last = *symbol + repeat_delta;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     int next = next_symbol[*repeat_code_len];</span>
<span class="lineNum">     520 </span>            :     do {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       symbol_lists[next] = (uint16_t)*symbol;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       next = (int)*symbol;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     } while (++(*symbol) != last);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     next_symbol[*repeat_code_len] = next;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     *space -= repeat_delta &lt;&lt; (15 - *repeat_code_len);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     code_length_histo[*repeat_code_len] =</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         (uint16_t)(code_length_histo[*repeat_code_len] + repeat_delta);</span>
<span class="lineNum">     528 </span>            :   } else {
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     *symbol += repeat_delta;</span>
<span class="lineNum">     530 </span>            :   }
<span class="lineNum">     531 </span>            : }
<a name="532"><span class="lineNum">     532 </span>            : </a>
<span class="lineNum">     533 </span>            : /* Reads and decodes symbol codelengths. */
<span class="lineNum">     534 </span><span class="lineNoCov">          0 : static BrotliErrorCode ReadSymbolCodeLengths(</span>
<span class="lineNum">     535 </span>            :     uint32_t alphabet_size, BrotliState* s) {
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :   uint32_t symbol = s-&gt;symbol;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :   uint32_t repeat = s-&gt;repeat;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :   uint32_t space = s-&gt;space;</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   uint32_t prev_code_len = s-&gt;prev_code_len;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   uint32_t repeat_code_len = s-&gt;repeat_code_len;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   uint16_t* symbol_lists = s-&gt;symbol_lists;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   uint16_t* code_length_histo = s-&gt;code_length_histo;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   int* next_symbol = s-&gt;next_symbol;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :   if (!BrotliWarmupBitReader(br)) {</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     547 </span>            :   }
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   while (symbol &lt; alphabet_size &amp;&amp; space &gt; 0) {</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     const HuffmanCode* p = s-&gt;table;</span>
<span class="lineNum">     550 </span>            :     uint32_t code_len;
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     if (!BrotliCheckInputAmount(br, BROTLI_SHORT_FILL_BIT_WINDOW_READ)) {</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       s-&gt;symbol = symbol;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :       s-&gt;repeat = repeat;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       s-&gt;prev_code_len = prev_code_len;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       s-&gt;repeat_code_len = repeat_code_len;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       s-&gt;space = space;</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     558 </span>            :     }
<span class="lineNum">     559 </span>            :     BrotliFillBitWindow16(br);
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :     p += BrotliGetBitsUnmasked(br) &amp;</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :         BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     BrotliDropBits(br, p-&gt;bits);  /* Use 1..5 bits */</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     code_len = p-&gt;value;  /* code_len == 0..17 */</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     if (code_len &lt; kCodeLengthRepeatCode) {</span>
<span class="lineNum">     565 </span>            :       ProcessSingleCodeLength(code_len, &amp;symbol, &amp;repeat, &amp;space,
<span class="lineNum">     566 </span>            :           &amp;prev_code_len, symbol_lists, code_length_histo, next_symbol);
<span class="lineNum">     567 </span>            :     } else { /* code_len == 16..17, extra_bits == 2..3 */
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :       uint32_t repeat_delta =</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :           (uint32_t)BrotliGetBitsUnmasked(br) &amp; BitMask(code_len - 14U);</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       BrotliDropBits(br, code_len - 14U);</span>
<span class="lineNum">     571 </span>            :       ProcessRepeatedCodeLength(code_len, repeat_delta, alphabet_size,
<span class="lineNum">     572 </span>            :           &amp;symbol, &amp;repeat, &amp;space, &amp;prev_code_len, &amp;repeat_code_len,
<span class="lineNum">     573 </span>            :           symbol_lists, code_length_histo, next_symbol);
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            :   }
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   s-&gt;space = space;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<a name="578"><span class="lineNum">     578 </span>            : }</a>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 : static BrotliErrorCode SafeReadSymbolCodeLengths(</span>
<span class="lineNum">     581 </span>            :     uint32_t alphabet_size, BrotliState* s) {
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   while (s-&gt;symbol &lt; alphabet_size &amp;&amp; s-&gt;space &gt; 0) {</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     const HuffmanCode* p = s-&gt;table;</span>
<span class="lineNum">     585 </span>            :     uint32_t code_len;
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :     uint32_t bits = 0;</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     uint32_t available_bits = BrotliGetAvailableBits(br);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     if (available_bits != 0) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       bits = (uint32_t)BrotliGetBitsUnmasked(br);</span>
<span class="lineNum">     590 </span>            :     }
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     p += bits &amp; BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :     if (p-&gt;bits &gt; available_bits) goto pullMoreInput;</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     code_len = p-&gt;value; /* code_len == 0..17 */</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     if (code_len &lt; kCodeLengthRepeatCode) {</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       BrotliDropBits(br, p-&gt;bits);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :       ProcessSingleCodeLength(code_len, &amp;s-&gt;symbol, &amp;s-&gt;repeat, &amp;s-&gt;space,</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :           &amp;s-&gt;prev_code_len, s-&gt;symbol_lists, s-&gt;code_length_histo,</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :           s-&gt;next_symbol);</span>
<span class="lineNum">     599 </span>            :     } else { /* code_len == 16..17, extra_bits == 2..3 */
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       uint32_t extra_bits = code_len - 14U;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       uint32_t repeat_delta = (bits &gt;&gt; p-&gt;bits) &amp; BitMask(extra_bits);</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :       if (available_bits &lt; p-&gt;bits + extra_bits) goto pullMoreInput;</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       BrotliDropBits(br, p-&gt;bits + extra_bits);</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       ProcessRepeatedCodeLength(code_len, repeat_delta, alphabet_size,</span>
<span class="lineNum">     605 </span>            :           &amp;s-&gt;symbol, &amp;s-&gt;repeat, &amp;s-&gt;space, &amp;s-&gt;prev_code_len,
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :           &amp;s-&gt;repeat_code_len, s-&gt;symbol_lists, s-&gt;code_length_histo,</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :           s-&gt;next_symbol);</span>
<span class="lineNum">     608 </span>            :     }
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : pullMoreInput:
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     if (!BrotliPullByte(br)) {</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :       return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     614 </span>            :     }
<span class="lineNum">     615 </span>            :   }
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">     617 </span>            : }
<span class="lineNum">     618 </span>            : 
<a name="619"><span class="lineNum">     619 </span>            : /* Reads and decodes 15..18 codes using static prefix code.</a>
<span class="lineNum">     620 </span>            :    Each code is 2..4 bits long. In total 30..72 bits are used. */
<span class="lineNum">     621 </span><span class="lineNoCov">          0 : static BrotliErrorCode ReadCodeLengthCodeLengths(BrotliState* s) {</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   uint32_t num_codes = s-&gt;repeat;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   unsigned space = s-&gt;space;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   uint32_t i = s-&gt;sub_loop_counter;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   for (; i &lt; CODE_LENGTH_CODES; ++i) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     const uint8_t code_len_idx = kCodeLengthCodeOrder[i];</span>
<span class="lineNum">     628 </span>            :     uint32_t ix;
<span class="lineNum">     629 </span>            :     uint32_t v;
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     if (PREDICT_FALSE(!BrotliSafeGetBits(br, 4, &amp;ix))) {</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       uint32_t available_bits = BrotliGetAvailableBits(br);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :       if (available_bits != 0) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         ix = BrotliGetBitsUnmasked(br) &amp; 0xF;</span>
<span class="lineNum">     634 </span>            :       } else {
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         ix = 0;</span>
<span class="lineNum">     636 </span>            :       }
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       if (kCodeLengthPrefixLength[ix] &gt; available_bits) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         s-&gt;sub_loop_counter = i;</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         s-&gt;repeat = num_codes;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         s-&gt;space = space;</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_COMPLEX;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     643 </span>            :       }
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     v = kCodeLengthPrefixValue[ix];</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     BrotliDropBits(br, kCodeLengthPrefixLength[ix]);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     s-&gt;code_length_code_lengths[code_len_idx] = (uint8_t)v;</span>
<span class="lineNum">     648 </span>            :     BROTLI_LOG_ARRAY_INDEX(s-&gt;code_length_code_lengths, code_len_idx);
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     if (v != 0) {</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       space = space - (32U &gt;&gt; v);</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       ++num_codes;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :       ++s-&gt;code_length_histo[v];</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :       if (space - 1U &gt;= 32U) {</span>
<span class="lineNum">     654 </span>            :         /* space is 0 or wrapped around */
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     656 </span>            :       }
<span class="lineNum">     657 </span>            :     }
<span class="lineNum">     658 </span>            :   }
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   if (!(num_codes == 1 || space == 0)) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_CL_SPACE);</span>
<span class="lineNum">     661 </span>            :   }
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">     663 </span>            : }
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : /* Decodes the Huffman tables.
<span class="lineNum">     666 </span>            :    There are 2 scenarios:
<span class="lineNum">     667 </span>            :     A) Huffman code contains only few symbols (1..4). Those symbols are read
<span class="lineNum">     668 </span>            :        directly; their code lengths are defined by the number of symbols.
<span class="lineNum">     669 </span>            :        For this scenario 4 - 45 bits will be read.
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :     B) 2-phase decoding:
<span class="lineNum">     672 </span>            :     B.1) Small Huffman table is decoded; it is specified with code lengths
<span class="lineNum">     673 </span>            :          encoded with predefined entropy code. 32 - 74 bits are used.
<span class="lineNum">     674 </span>            :     B.2) Decoded table is used to decode code lengths of symbols in resulting
<a name="675"><span class="lineNum">     675 </span>            :          Huffman table. In worst case 3520 bits are read.</a>
<span class="lineNum">     676 </span>            : */
<span class="lineNum">     677 </span><span class="lineNoCov">          0 : static BrotliErrorCode ReadHuffmanCode(uint32_t alphabet_size,</span>
<span class="lineNum">     678 </span>            :                                        HuffmanCode* table,
<span class="lineNum">     679 </span>            :                                        uint32_t* opt_table_size,
<span class="lineNum">     680 </span>            :                                        BrotliState* s) {
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     682 </span>            :   /* Unnecessary masking, but might be good for safety. */
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   alphabet_size &amp;= 0x3ff;</span>
<span class="lineNum">     684 </span>            :   /* State machine */
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   switch (s-&gt;substate_huffman) {</span>
<span class="lineNum">     686 </span>            :     case BROTLI_STATE_HUFFMAN_NONE:
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :       if (!BrotliSafeReadBits(br, 2, &amp;s-&gt;sub_loop_counter)) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     689 </span>            :       }
<span class="lineNum">     690 </span>            :       BROTLI_LOG_UINT(s-&gt;sub_loop_counter);
<span class="lineNum">     691 </span>            :       /* The value is used as follows:
<span class="lineNum">     692 </span>            :          1 for simple code;
<span class="lineNum">     693 </span>            :          0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       if (s-&gt;sub_loop_counter != 1) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         s-&gt;space = 32;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         s-&gt;repeat = 0; /* num_codes */</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         memset(&amp;s-&gt;code_length_histo[0], 0, sizeof(s-&gt;code_length_histo[0]) *</span>
<span class="lineNum">     698 </span>            :             (BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH + 1));
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         memset(&amp;s-&gt;code_length_code_lengths[0], 0,</span>
<span class="lineNum">     700 </span>            :             sizeof(s-&gt;code_length_code_lengths));
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_COMPLEX;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         goto Complex;</span>
<span class="lineNum">     703 </span>            :       }
<span class="lineNum">     704 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :     case BROTLI_STATE_HUFFMAN_SIMPLE_SIZE:
<span class="lineNum">     707 </span>            :       /* Read symbols, codes &amp; code lengths directly. */
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       if (!BrotliSafeReadBits(br, 2, &amp;s-&gt;symbol)) { /* num_symbols */</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_SIZE;</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     711 </span>            :       }
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       s-&gt;sub_loop_counter = 0;</span>
<span class="lineNum">     713 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     714 </span>            :     case BROTLI_STATE_HUFFMAN_SIMPLE_READ: {
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       BrotliErrorCode result = ReadSimpleHuffmanSymbols(alphabet_size, s);</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     718 </span>            :       }
<span class="lineNum">     719 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span>            :     case BROTLI_STATE_HUFFMAN_SIMPLE_BUILD: {
<span class="lineNum">     722 </span>            :       uint32_t table_size;
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :       if (s-&gt;symbol == 3) {</span>
<span class="lineNum">     724 </span>            :         uint32_t bits;
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :           s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_BUILD;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     728 </span>            :         }
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :         s-&gt;symbol += bits;</span>
<span class="lineNum">     730 </span>            :       }
<span class="lineNum">     731 </span>            :       BROTLI_LOG_UINT(s-&gt;symbol);
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :       table_size = BrotliBuildSimpleHuffmanTable(</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :           table, HUFFMAN_TABLE_BITS, s-&gt;symbols_lists_array, s-&gt;symbol);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :       if (opt_table_size) {</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :         *opt_table_size = table_size;</span>
<span class="lineNum">     736 </span>            :       }
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_NONE;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       return BROTLI_SUCCESS;</span>
<span class="lineNum">     739 </span>            :     }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : Complex: /* Decode Huffman-coded code lengths. */
<span class="lineNum">     742 </span>            :     case BROTLI_STATE_HUFFMAN_COMPLEX: {
<span class="lineNum">     743 </span>            :       uint32_t i;
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :       BrotliErrorCode result = ReadCodeLengthCodeLengths(s);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :       if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     747 </span>            :       }
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :       BrotliBuildCodeLengthsHuffmanTable(s-&gt;table,</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :                                          s-&gt;code_length_code_lengths,</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :                                          s-&gt;code_length_histo);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       memset(&amp;s-&gt;code_length_histo[0], 0, sizeof(s-&gt;code_length_histo));</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt;= BROTLI_HUFFMAN_MAX_CODE_LENGTH; ++i) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         s-&gt;next_symbol[i] = (int)i - (BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         s-&gt;symbol_lists[(int)i - (BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1)] = 0xFFFF;</span>
<span class="lineNum">     755 </span>            :       }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :       s-&gt;symbol = 0;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :       s-&gt;prev_code_len = kDefaultCodeLength;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :       s-&gt;repeat = 0;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :       s-&gt;repeat_code_len = 0;</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :       s-&gt;space = 32768;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS;</span>
<span class="lineNum">     763 </span>            :       /* No break, transit to the next state. */
<span class="lineNum">     764 </span>            :     }
<span class="lineNum">     765 </span>            :     case BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS: {
<span class="lineNum">     766 </span>            :       uint32_t table_size;
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       BrotliErrorCode result = ReadSymbolCodeLengths(alphabet_size, s);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       if (result == BROTLI_NEEDS_MORE_INPUT) {</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         result = SafeReadSymbolCodeLengths(alphabet_size, s);</span>
<span class="lineNum">     770 </span>            :       }
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :       if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     773 </span>            :       }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       if (s-&gt;space != 0) {</span>
<span class="lineNum">     776 </span>            :         BROTLI_LOG((&quot;[ReadHuffmanCode] space = %d\n&quot;, s-&gt;space));
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :         return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_HUFFMAN_SPACE);</span>
<span class="lineNum">     778 </span>            :       }
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :       table_size = BrotliBuildHuffmanTable(</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :           table, HUFFMAN_TABLE_BITS, s-&gt;symbol_lists, s-&gt;code_length_histo);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       if (opt_table_size) {</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :         *opt_table_size = table_size;</span>
<span class="lineNum">     783 </span>            :       }
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       s-&gt;substate_huffman = BROTLI_STATE_HUFFMAN_NONE;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       return BROTLI_SUCCESS;</span>
<span class="lineNum">     786 </span>            :     }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     default:
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :       return BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE);</span>
<span class="lineNum">     790 </span>            :   }
<span class="lineNum">     791 </span>            : }
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            : /* Decodes a block length by reading 3..39 bits. */
<span class="lineNum">     794 </span>            : static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,
<span class="lineNum">     795 </span>            :                                               BrotliBitReader* br) {
<span class="lineNum">     796 </span>            :   uint32_t code;
<span class="lineNum">     797 </span>            :   uint32_t nbits;
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :   code = ReadSymbol(table, br);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   nbits = kBlockLengthPrefixCode[code].nbits; /* nbits == 2..24 */</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   return kBlockLengthPrefixCode[code].offset + BrotliReadBits(br, nbits);</span>
<span class="lineNum">     801 </span>            : }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            : /* WARNING: if state is not BROTLI_STATE_READ_BLOCK_LENGTH_NONE, then
<span class="lineNum">     804 </span>            :    reading can't be continued with ReadBlockLength. */
<span class="lineNum">     805 </span>            : static BROTLI_INLINE int SafeReadBlockLength(BrotliState* s,
<span class="lineNum">     806 </span>            :                                              uint32_t* result,
<span class="lineNum">     807 </span>            :                                              const HuffmanCode* table,
<span class="lineNum">     808 </span>            :                                              BrotliBitReader* br) {
<span class="lineNum">     809 </span>            :   uint32_t index;
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   if (s-&gt;substate_read_block_length == BROTLI_STATE_READ_BLOCK_LENGTH_NONE) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     if (!SafeReadSymbol(table, br, &amp;index)) {</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span>            :   } else {
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     index = s-&gt;block_length_index;</span>
<span class="lineNum">     816 </span>            :   }
<span class="lineNum">     817 </span>            :   {
<span class="lineNum">     818 </span>            :     uint32_t bits;
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     uint32_t nbits = kBlockLengthPrefixCode[index].nbits; /* nbits == 2..24 */</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     if (!BrotliSafeReadBits(br, nbits, &amp;bits)) {</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       s-&gt;block_length_index = index;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :       s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIX;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     824 </span>            :     }
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     *result = kBlockLengthPrefixCode[index].offset + bits;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :     s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     828 </span>            :   }
<span class="lineNum">     829 </span>            : }
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            : /* Transform:
<span class="lineNum">     832 </span>            :     1) initialize list L with values 0, 1,... 255
<span class="lineNum">     833 </span>            :     2) For each input element X:
<span class="lineNum">     834 </span>            :     2.1) let Y = L[X]
<span class="lineNum">     835 </span>            :     2.2) remove X-th element from L
<span class="lineNum">     836 </span>            :     2.3) prepend Y to L
<span class="lineNum">     837 </span>            :     2.4) append Y to output
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :    In most cases max(Y) &lt;= 7, so most of L remains intact.
<span class="lineNum">     840 </span>            :    To reduce the cost of initialization, we reuse L, remember the upper bound
<span class="lineNum">     841 </span>            :    of Y values, and reinitialize only first elements in L.
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :    Most of input values are 0 and 1. To reduce number of branches, we replace
<a name="844"><span class="lineNum">     844 </span>            :    inner for loop with do-while.</a>
<span class="lineNum">     845 </span>            :  */
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE void InverseMoveToFrontTransform(uint8_t* v,</span>
<span class="lineNum">     847 </span>            :     uint32_t v_len, BrotliState* state) {
<span class="lineNum">     848 </span>            :   /* Reinitialize elements that could have been changed. */
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   uint32_t i = 4;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   uint32_t upper_bound = state-&gt;mtf_upper_bound;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :   uint8_t* mtf = &amp;state-&gt;mtf[4];  /* Make mtf[-1] addressable. */</span>
<span class="lineNum">     852 </span>            :   /* Load endian-aware constant. */
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   const uint8_t b0123[4] = {0, 1, 2, 3};</span>
<span class="lineNum">     854 </span>            :   uint32_t pattern;
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   memcpy(&amp;pattern, &amp;b0123, 4);</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   /* Initialize list using 4 consequent values pattern. */
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   *(uint32_t*)mtf = pattern;</span>
<span class="lineNum">     859 </span>            :   do {
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     pattern += 0x04040404; /* Advance all 4 values by 4. */</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     *(uint32_t*)(mtf + i) = pattern;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     i += 4;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   } while (i &lt;= upper_bound);</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :   /* Transform the input. */
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   upper_bound = 0;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; v_len; ++i) {</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     int index = v[i];</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     uint8_t value = mtf[index];</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     upper_bound |= v[i];</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :     v[i] = value;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     mtf[-1] = value;</span>
<span class="lineNum">     873 </span>            :     do {
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       index--;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       mtf[index + 1] = mtf[index];</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :     } while (index &gt;= 0);</span>
<span class="lineNum">     877 </span>            :   }
<span class="lineNum">     878 </span>            :   /* Remember amount of elements to be reinitialized. */
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   state-&gt;mtf_upper_bound = upper_bound;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 : }</span>
<a name="881"><span class="lineNum">     881 </span>            : </a>
<span class="lineNum">     882 </span>            : /* Decodes a series of Huffman table using ReadHuffmanCode function. */
<span class="lineNum">     883 </span><span class="lineNoCov">          0 : static BrotliErrorCode HuffmanTreeGroupDecode(HuffmanTreeGroup* group,</span>
<span class="lineNum">     884 </span>            :                                               BrotliState* s) {
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   if (s-&gt;substate_tree_group != BROTLI_STATE_TREE_GROUP_LOOP) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     s-&gt;next = group-&gt;codes;</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     s-&gt;htree_index = 0;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     s-&gt;substate_tree_group = BROTLI_STATE_TREE_GROUP_LOOP;</span>
<span class="lineNum">     889 </span>            :   }
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   while (s-&gt;htree_index &lt; group-&gt;num_htrees) {</span>
<span class="lineNum">     891 </span>            :     uint32_t table_size;
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     BrotliErrorCode result =</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         ReadHuffmanCode(group-&gt;alphabet_size, s-&gt;next, &amp;table_size, s);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     if (result != BROTLI_SUCCESS) return result;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     group-&gt;htrees[s-&gt;htree_index] = s-&gt;next;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     s-&gt;next += table_size;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     ++s-&gt;htree_index;</span>
<span class="lineNum">     898 </span>            :   }
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   s-&gt;substate_tree_group = BROTLI_STATE_TREE_GROUP_NONE;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">     901 </span>            : }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : /* Decodes a context map.
<span class="lineNum">     904 </span>            :    Decoding is done in 4 phases:
<span class="lineNum">     905 </span>            :     1) Read auxiliary information (6..16 bits) and allocate memory.
<span class="lineNum">     906 </span>            :        In case of trivial context map, decoding is finished at this phase.
<span class="lineNum">     907 </span>            :     2) Decode Huffman table using ReadHuffmanCode function.
<span class="lineNum">     908 </span>            :        This table will be used for reading context map items.
<span class="lineNum">     909 </span>            :     3) Read context map items; &quot;0&quot; values could be run-length encoded.
<a name="910"><span class="lineNum">     910 </span>            :     4) Optionally, apply InverseMoveToFront transform to the resulting map.</a>
<span class="lineNum">     911 </span>            :  */
<span class="lineNum">     912 </span><span class="lineNoCov">          0 : static BrotliErrorCode DecodeContextMap(uint32_t context_map_size,</span>
<span class="lineNum">     913 </span>            :                                         uint32_t* num_htrees,
<span class="lineNum">     914 </span>            :                                         uint8_t** context_map_arg,
<span class="lineNum">     915 </span>            :                                         BrotliState* s) {
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :   BrotliErrorCode result = BROTLI_SUCCESS;</span>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   switch ((int)s-&gt;substate_context_map) {</span>
<span class="lineNum">     920 </span>            :     case BROTLI_STATE_CONTEXT_MAP_NONE:
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :       result = DecodeVarLenUint8(s, br, num_htrees);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :         return result;</span>
<span class="lineNum">     924 </span>            :       }
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :       (*num_htrees)++;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       s-&gt;context_index = 0;</span>
<span class="lineNum">     927 </span>            :       BROTLI_LOG_UINT(context_map_size);
<span class="lineNum">     928 </span>            :       BROTLI_LOG_UINT(*num_htrees);
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :       *context_map_arg = (uint8_t*)BROTLI_ALLOC(s, (size_t)context_map_size);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       if (*context_map_arg == 0) {</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         return BROTLI_FAILURE(BROTLI_ERROR_ALLOC_CONTEXT_MAP);</span>
<span class="lineNum">     932 </span>            :       }
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :       if (*num_htrees &lt;= 1) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         memset(*context_map_arg, 0, (size_t)context_map_size);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         return BROTLI_SUCCESS;</span>
<span class="lineNum">     936 </span>            :       }
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :       s-&gt;substate_context_map = BROTLI_STATE_CONTEXT_MAP_READ_PREFIX;</span>
<span class="lineNum">     938 </span>            :       /* No break, continue to next state. */
<span class="lineNum">     939 </span>            :     case BROTLI_STATE_CONTEXT_MAP_READ_PREFIX: {
<span class="lineNum">     940 </span>            :       uint32_t bits;
<span class="lineNum">     941 </span>            :       /* In next stage ReadHuffmanCode uses at least 4 bits, so it is safe
<span class="lineNum">     942 </span>            :          to peek 4 bits ahead. */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       if (!BrotliSafeGetBits(br, 5, &amp;bits)) {</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     945 </span>            :       }
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :       if ((bits &amp; 1) != 0) { /* Use RLE for zeroes. */</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :         s-&gt;max_run_length_prefix = (bits &gt;&gt; 1) + 1;</span>
<span class="lineNum">     948 </span>            :         BrotliDropBits(br, 5);
<span class="lineNum">     949 </span>            :       } else {
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         s-&gt;max_run_length_prefix = 0;</span>
<span class="lineNum">     951 </span>            :         BrotliDropBits(br, 1);
<span class="lineNum">     952 </span>            :       }
<span class="lineNum">     953 </span>            :       BROTLI_LOG_UINT(s-&gt;max_run_length_prefix);
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :       s-&gt;substate_context_map = BROTLI_STATE_CONTEXT_MAP_HUFFMAN;</span>
<span class="lineNum">     955 </span>            :       /* No break, continue to next state. */
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span>            :     case BROTLI_STATE_CONTEXT_MAP_HUFFMAN:
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :       result = ReadHuffmanCode(*num_htrees + s-&gt;max_run_length_prefix,</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                                s-&gt;context_map_table, NULL, s);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       if (result != BROTLI_SUCCESS) return result;</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :       s-&gt;code = 0xFFFF;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :       s-&gt;substate_context_map = BROTLI_STATE_CONTEXT_MAP_DECODE;</span>
<span class="lineNum">     963 </span>            :       /* No break, continue to next state. */
<span class="lineNum">     964 </span>            :     case BROTLI_STATE_CONTEXT_MAP_DECODE: {
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :       uint32_t context_index = s-&gt;context_index;</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :       uint32_t max_run_length_prefix = s-&gt;max_run_length_prefix;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :       uint8_t* context_map = *context_map_arg;</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       uint32_t code = s-&gt;code;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       if (code != 0xFFFF) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         goto rleCode;</span>
<span class="lineNum">     971 </span>            :       }
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :       while (context_index &lt; context_map_size) {</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         if (!SafeReadSymbol(s-&gt;context_map_table, br, &amp;code)) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :           s-&gt;code = 0xFFFF;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :           s-&gt;context_index = context_index;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     977 </span>            :         }
<span class="lineNum">     978 </span>            :         BROTLI_LOG_UINT(code);
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         if (code == 0) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :           context_map[context_index++] = 0;</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     983 </span>            :         }
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         if (code &gt; max_run_length_prefix) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :           context_map[context_index++] =</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :               (uint8_t)(code - max_run_length_prefix);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">     988 </span>            :         }
<span class="lineNum">     989 </span>            : rleCode:
<span class="lineNum">     990 </span>            :         {
<span class="lineNum">     991 </span>            :           uint32_t reps;
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :           if (!BrotliSafeReadBits(br, code, &amp;reps)) {</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :             s-&gt;code = code;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :             s-&gt;context_index = context_index;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :             return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">     996 </span>            :           }
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :           reps += 1U &lt;&lt; code;</span>
<span class="lineNum">     998 </span>            :           BROTLI_LOG_UINT(reps);
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :           if (context_index + reps &gt; context_map_size) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :             return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_CONTEXT_MAP_REPEAT);</span>
<span class="lineNum">    1001 </span>            :           }
<span class="lineNum">    1002 </span>            :           do {
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :             context_map[context_index++] = 0;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :           } while (--reps);</span>
<span class="lineNum">    1005 </span>            :         }
<span class="lineNum">    1006 </span>            :       }
<span class="lineNum">    1007 </span>            :       /* No break, continue to next state. */
<span class="lineNum">    1008 </span>            :     }
<span class="lineNum">    1009 </span>            :     case BROTLI_STATE_CONTEXT_MAP_TRANSFORM: {
<span class="lineNum">    1010 </span>            :       uint32_t bits;
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :       if (!BrotliSafeReadBits(br, 1, &amp;bits)) {</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         s-&gt;substate_context_map = BROTLI_STATE_CONTEXT_MAP_TRANSFORM;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1014 </span>            :       }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       if (bits != 0) {</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :         InverseMoveToFrontTransform(*context_map_arg, context_map_size, s);</span>
<span class="lineNum">    1017 </span>            :       }
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       s-&gt;substate_context_map = BROTLI_STATE_CONTEXT_MAP_NONE;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       return BROTLI_SUCCESS;</span>
<span class="lineNum">    1020 </span>            :     }
<span class="lineNum">    1021 </span>            :     default:
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :       return BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE);</span>
<span class="lineNum">    1023 </span>            :   }
<span class="lineNum">    1024 </span>            : }
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /* Decodes a command or literal and updates block type ringbuffer.
<span class="lineNum">    1027 </span>            :    Reads 3..54 bits. */
<span class="lineNum">    1028 </span>            : static BROTLI_INLINE int DecodeBlockTypeAndLength(int safe,
<span class="lineNum">    1029 </span>            :     BrotliState* s, int tree_type) {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   uint32_t max_block_type = s-&gt;num_block_types[tree_type];</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   const HuffmanCode* type_tree = &amp;s-&gt;block_type_trees[</span>
<span class="lineNum">    1032 </span>            :       tree_type * BROTLI_HUFFMAN_MAX_SIZE_258];
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   const HuffmanCode* len_tree = &amp;s-&gt;block_len_trees[</span>
<span class="lineNum">    1034 </span>            :       tree_type * BROTLI_HUFFMAN_MAX_SIZE_26];
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   uint32_t* ringbuffer = &amp;s-&gt;block_type_rb[tree_type * 2];</span>
<span class="lineNum">    1037 </span>            :   uint32_t block_type;
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :   /* Read 0..15 + 3..39 bits */
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   if (!safe) {</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     block_type = ReadSymbol(type_tree, br);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     s-&gt;block_length[tree_type] = ReadBlockLength(len_tree, br);</span>
<span class="lineNum">    1043 </span>            :   } else {
<span class="lineNum">    1044 </span>            :     BrotliBitReaderState memento;
<span class="lineNum">    1045 </span>            :     BrotliBitReaderSaveState(br, &amp;memento);
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     if (!SafeReadSymbol(type_tree, br, &amp;block_type)) return 0;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     if (!SafeReadBlockLength(s, &amp;s-&gt;block_length[tree_type], len_tree, br)) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;</span>
<span class="lineNum">    1049 </span>            :       BrotliBitReaderRestoreState(br, &amp;memento);
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span>            :   }
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   if (block_type == 1) {</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     block_type = ringbuffer[1] + 1;</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   } else if (block_type == 0) {</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     block_type = ringbuffer[0];</span>
<span class="lineNum">    1058 </span>            :   } else {
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     block_type -= 2;</span>
<span class="lineNum">    1060 </span>            :   }
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   if (block_type &gt;= max_block_type) {</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     block_type -= max_block_type;</span>
<span class="lineNum">    1063 </span>            :   }
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :   ringbuffer[0] = ringbuffer[1];</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :   ringbuffer[1] = block_type;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1067 </span>            : }
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            : static BROTLI_INLINE void DetectTrivialLiteralBlockTypes(BrotliState* s) {
<span class="lineNum">    1070 </span>            :   size_t i;
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; ++i) s-&gt;trivial_literal_contexts[i] = 0;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; s-&gt;num_block_types[0]; i++) {</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     size_t offset = i &lt;&lt; kLiteralContextBits;</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     size_t error = 0;</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :     size_t sample = s-&gt;context_map[offset];</span>
<span class="lineNum">    1076 </span>            :     size_t j;
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; (1u &lt;&lt; kLiteralContextBits);) {</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :       BROTLI_REPEAT(4, error |= s-&gt;context_map[offset + j++] ^ sample;)</span>
<span class="lineNum">    1079 </span>            :     }
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     if (error == 0) {</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       s-&gt;trivial_literal_contexts[i &gt;&gt; 5] |= 1u &lt;&lt; (i &amp; 31);</span>
<span class="lineNum">    1082 </span>            :     }
<span class="lineNum">    1083 </span>            :   }
<span class="lineNum">    1084 </span>            : }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            : static BROTLI_INLINE void PrepareLiteralDecoding(BrotliState* s) {
<span class="lineNum">    1087 </span>            :   uint8_t context_mode;
<span class="lineNum">    1088 </span>            :   size_t trivial;
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   uint32_t block_type = s-&gt;block_type_rb[1];</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   uint32_t context_offset = block_type &lt;&lt; kLiteralContextBits;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :   s-&gt;context_map_slice = s-&gt;context_map + context_offset;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :   trivial = s-&gt;trivial_literal_contexts[block_type &gt;&gt; 5];</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   s-&gt;trivial_literal_context = (trivial &gt;&gt; (block_type &amp; 31)) &amp; 1;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   s-&gt;literal_htree = s-&gt;literal_hgroup.htrees[s-&gt;context_map_slice[0]];</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :   context_mode = s-&gt;context_modes[block_type];</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   s-&gt;context_lookup1 = &amp;kContextLookup[kContextLookupOffsets[context_mode]];</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   s-&gt;context_lookup2 = &amp;kContextLookup[kContextLookupOffsets[context_mode + 1]];</span>
<span class="lineNum">    1098 </span>            : }
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : /* Decodes the block type and updates the state for literal context.
<span class="lineNum">    1101 </span>            :    Reads 3..54 bits. */
<span class="lineNum">    1102 </span>            : static BROTLI_INLINE int DecodeLiteralBlockSwitchInternal(int safe,
<span class="lineNum">    1103 </span>            :     BrotliState* s) {
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   if (!DecodeBlockTypeAndLength(safe, s, 0)) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1106 </span>            :   }
<span class="lineNum">    1107 </span>            :   PrepareLiteralDecoding(s);
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :   return 1;</span>
<a name="1109"><span class="lineNum">    1109 </span>            : }</a>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 : static void BROTLI_NOINLINE DecodeLiteralBlockSwitch(BrotliState* s) {</span>
<span class="lineNum">    1112 </span>            :   DecodeLiteralBlockSwitchInternal(0, s);
<a name="1113"><span class="lineNum">    1113 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 : static int BROTLI_NOINLINE SafeDecodeLiteralBlockSwitch(BrotliState* s) {</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :   return DecodeLiteralBlockSwitchInternal(1, s);</span>
<span class="lineNum">    1117 </span>            : }
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span>            : /* Block switch for insert/copy length.
<span class="lineNum">    1120 </span>            :    Reads 3..54 bits. */
<span class="lineNum">    1121 </span>            : static BROTLI_INLINE int DecodeCommandBlockSwitchInternal(int safe,
<span class="lineNum">    1122 </span>            :     BrotliState* s) {
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   if (!DecodeBlockTypeAndLength(safe, s, 1)) {</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1125 </span>            :   }
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   s-&gt;htree_command = s-&gt;insert_copy_hgroup.htrees[s-&gt;block_type_rb[3]];</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   return 1;</span>
<a name="1128"><span class="lineNum">    1128 </span>            : }</a>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 : static void BROTLI_NOINLINE DecodeCommandBlockSwitch(BrotliState* s) {</span>
<a name="1131"><span class="lineNum">    1131 </span>            :   DecodeCommandBlockSwitchInternal(0, s);</a>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 : static int BROTLI_NOINLINE SafeDecodeCommandBlockSwitch(BrotliState* s) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   return DecodeCommandBlockSwitchInternal(1, s);</span>
<span class="lineNum">    1135 </span>            : }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            : /* Block switch for distance codes.
<span class="lineNum">    1138 </span>            :    Reads 3..54 bits. */
<span class="lineNum">    1139 </span>            : static BROTLI_INLINE int DecodeDistanceBlockSwitchInternal(int safe,
<span class="lineNum">    1140 </span>            :     BrotliState* s) {
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   if (!DecodeBlockTypeAndLength(safe, s, 2)) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1143 </span>            :   }
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   s-&gt;dist_context_map_slice =</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :       s-&gt;dist_context_map + (s-&gt;block_type_rb[5] &lt;&lt; kDistanceContextBits);</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :   s-&gt;dist_htree_index = s-&gt;dist_context_map_slice[s-&gt;distance_context];</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :   return 1;</span>
<a name="1148"><span class="lineNum">    1148 </span>            : }</a>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 : static void BROTLI_NOINLINE DecodeDistanceBlockSwitch(BrotliState* s) {</span>
<span class="lineNum">    1151 </span>            :   DecodeDistanceBlockSwitchInternal(0, s);
<a name="1152"><span class="lineNum">    1152 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 : static int BROTLI_NOINLINE SafeDecodeDistanceBlockSwitch(BrotliState* s) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   return DecodeDistanceBlockSwitchInternal(1, s);</span>
<a name="1156"><span class="lineNum">    1156 </span>            : }</a>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 : static BrotliErrorCode BROTLI_NOINLINE WriteRingBuffer(size_t* available_out,</span>
<span class="lineNum">    1159 </span>            :     uint8_t** next_out, size_t* total_out, BrotliState* s) {
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   size_t pos = (s-&gt;pos &gt; s-&gt;ringbuffer_size) ? (size_t)s-&gt;ringbuffer_size</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :                                              : (size_t)(s-&gt;pos);</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :   uint8_t* start =</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       s-&gt;ringbuffer + (s-&gt;partial_pos_out &amp; (size_t)s-&gt;ringbuffer_mask);</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   size_t partial_pos_rb = (s-&gt;rb_roundtrips * (size_t)s-&gt;ringbuffer_size) + pos;</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   size_t to_write = (partial_pos_rb - s-&gt;partial_pos_out);</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   size_t num_written = *available_out;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   if (num_written &gt; to_write) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     num_written = to_write;</span>
<span class="lineNum">    1169 </span>            :   }
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   if (s-&gt;meta_block_remaining_len &lt; 0) {</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_BLOCK_LENGTH_1);</span>
<span class="lineNum">    1172 </span>            :   }
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   memcpy(*next_out, start, num_written);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   *next_out += num_written;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :   *available_out -= num_written;</span>
<span class="lineNum">    1176 </span>            :   BROTLI_LOG_UINT(to_write);
<span class="lineNum">    1177 </span>            :   BROTLI_LOG_UINT(num_written);
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   s-&gt;partial_pos_out += num_written;</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   if (total_out) *total_out = s-&gt;partial_pos_out;</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   if (num_written &lt; to_write) {</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     return BROTLI_NEEDS_MORE_OUTPUT;</span>
<span class="lineNum">    1182 </span>            :   }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :   if (s-&gt;pos &gt;= s-&gt;ringbuffer_size) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :     s-&gt;pos -= s-&gt;ringbuffer_size;</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     s-&gt;rb_roundtrips++;</span>
<span class="lineNum">    1187 </span>            :   }
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">    1189 </span>            : }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : /* Allocates ringbuffer.
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :   s-&gt;ringbuffer_size MUST be updated by BrotliCalculateRingBufferSize before
<span class="lineNum">    1194 </span>            :   this function is called.
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            :    Last two bytes of ringbuffer are initialized to 0, so context calculation
<span class="lineNum">    1197 </span>            :    could be done uniformly for the first two and all other positions.
<span class="lineNum">    1198 </span>            : 
<a name="1199"><span class="lineNum">    1199 </span>            :    Custom dictionary, if any, is copied to the end of ringbuffer.</a>
<span class="lineNum">    1200 </span>            : */
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 : static int BROTLI_NOINLINE BrotliAllocateRingBuffer(BrotliState* s) {</span>
<span class="lineNum">    1202 </span>            :   /* We need the slack region for the following reasons:
<span class="lineNum">    1203 </span>            :       - doing up to two 16-byte copies for fast backward copying
<span class="lineNum">    1204 </span>            :       - inserting transformed dictionary word (5 prefix + 24 base + 8 suffix) */
<span class="lineNum">    1205 </span>            :   static const int kRingBufferWriteAheadSlack = 42;
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer = (uint8_t*)BROTLI_ALLOC(s, (size_t)(s-&gt;ringbuffer_size +</span>
<span class="lineNum">    1207 </span>            :       kRingBufferWriteAheadSlack));
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   if (s-&gt;ringbuffer == 0) {</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1210 </span>            :   }
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer_end = s-&gt;ringbuffer + s-&gt;ringbuffer_size;</span>
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer[s-&gt;ringbuffer_size - 2] = 0;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer[s-&gt;ringbuffer_size - 1] = 0;</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   if (s-&gt;custom_dict) {</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     memcpy(&amp;s-&gt;ringbuffer[(-s-&gt;custom_dict_size) &amp; s-&gt;ringbuffer_mask],</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :            s-&gt;custom_dict, (size_t)s-&gt;custom_dict_size);</span>
<span class="lineNum">    1220 </span>            :   }
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :   return 1;</span>
<a name="1223"><span class="lineNum">    1223 </span>            : }</a>
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 : static BrotliErrorCode BROTLI_NOINLINE CopyUncompressedBlockToOutput(</span>
<span class="lineNum">    1226 </span>            :     size_t* available_out, uint8_t** next_out, size_t* total_out,
<span class="lineNum">    1227 </span>            :     BrotliState* s) {
<span class="lineNum">    1228 </span>            :   /* TODO: avoid allocation for single uncompressed block. */
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   if (!s-&gt;ringbuffer &amp;&amp; !BrotliAllocateRingBuffer(s)) {</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     return BROTLI_FAILURE(BROTLI_ERROR_ALLOC_RING_BUFFER_1);</span>
<span class="lineNum">    1231 </span>            :   }
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            :   /* State machine */
<span class="lineNum">    1234 </span>            :   for (;;) {
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     switch (s-&gt;substate_uncompressed) {</span>
<span class="lineNum">    1236 </span>            :       case BROTLI_STATE_UNCOMPRESSED_NONE: {
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         int nbytes = (int)BrotliGetRemainingBytes(&amp;s-&gt;br);</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :         if (nbytes &gt; s-&gt;meta_block_remaining_len) {</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :           nbytes = s-&gt;meta_block_remaining_len;</span>
<span class="lineNum">    1240 </span>            :         }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :         if (s-&gt;pos + nbytes &gt; s-&gt;ringbuffer_size) {</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :           nbytes = s-&gt;ringbuffer_size - s-&gt;pos;</span>
<span class="lineNum">    1243 </span>            :         }
<span class="lineNum">    1244 </span>            :         /* Copy remaining bytes from s-&gt;br.buf_ to ringbuffer. */
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :         BrotliCopyBytes(&amp;s-&gt;ringbuffer[s-&gt;pos], &amp;s-&gt;br, (size_t)nbytes);</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :         s-&gt;pos += nbytes;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         s-&gt;meta_block_remaining_len -= nbytes;</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         if (s-&gt;pos &lt; s-&gt;ringbuffer_size) {</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :           if (s-&gt;meta_block_remaining_len == 0) {</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             return BROTLI_SUCCESS;</span>
<span class="lineNum">    1251 </span>            :           }
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :           return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1253 </span>            :         }
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         s-&gt;substate_uncompressed = BROTLI_STATE_UNCOMPRESSED_WRITE;</span>
<span class="lineNum">    1255 </span>            :         /* No break, continue to next state */
<span class="lineNum">    1256 </span>            :       }
<span class="lineNum">    1257 </span>            :       case BROTLI_STATE_UNCOMPRESSED_WRITE: {
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :         BrotliErrorCode result =</span>
<span class="lineNum">    1259 </span>            :             WriteRingBuffer(available_out, next_out, total_out, s);
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :           return result;</span>
<span class="lineNum">    1262 </span>            :         }
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :         s-&gt;max_distance = s-&gt;max_backward_distance;</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         s-&gt;substate_uncompressed = BROTLI_STATE_UNCOMPRESSED_NONE;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1266 </span>            :       }
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span>            :   }
<span class="lineNum">    1269 </span>            :   BROTLI_DCHECK(0);  /* Unreachable */
<a name="1270"><span class="lineNum">    1270 </span>            : }</a>
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 : int BrotliDecompressedSize(size_t encoded_size,</span>
<span class="lineNum">    1273 </span>            :                            const uint8_t* encoded_buffer,
<span class="lineNum">    1274 </span>            :                            size_t* decoded_size) {
<span class="lineNum">    1275 </span>            :   BrotliState s;
<span class="lineNum">    1276 </span>            :   int next_block_header;
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   BrotliStateInit(&amp;s);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   s.br.next_in = encoded_buffer;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :   s.br.avail_in = encoded_size;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :   if (!BrotliWarmupBitReader(&amp;s.br)) {</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1282 </span>            :   }
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :   DecodeWindowBits(&amp;s.br);</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   if (DecodeMetaBlockLength(&amp;s, &amp;s.br) != BROTLI_SUCCESS) {</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1286 </span>            :   }
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :   *decoded_size = (size_t)s.meta_block_remaining_len;</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   if (s.is_last_metablock) {</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1290 </span>            :   }
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   if (!s.is_uncompressed || !BrotliJumpToByteBoundary(&amp;s.br)) {</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1293 </span>            :   }
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   next_block_header = BrotliPeekByte(&amp;s.br, (size_t)s.meta_block_remaining_len);</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :   return (next_block_header != -1) &amp;&amp; ((next_block_header &amp; 3) == 3);</span>
<span class="lineNum">    1296 </span>            : }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : /* Calculates the smallest feasible ring buffer.
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :    If we know the data size is small, do not allocate more ringbuffer
<span class="lineNum">    1301 </span>            :    size than needed to reduce memory usage.
<span class="lineNum">    1302 </span>            : 
<a name="1303"><span class="lineNum">    1303 </span>            :    When this method is called, metablock size and flags MUST be decoded.</a>
<span class="lineNum">    1304 </span>            : */
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 : static void BROTLI_NOINLINE BrotliCalculateRingBufferSize(BrotliState* s,</span>
<span class="lineNum">    1306 </span>            :     BrotliBitReader* br) {
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   int is_last = s-&gt;is_last_metablock;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :   int window_size = 1 &lt;&lt; s-&gt;window_bits;</span>
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer_size = window_size;</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :   if (s-&gt;is_uncompressed) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     int next_block_header =</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :         BrotliPeekByte(br, (size_t)s-&gt;meta_block_remaining_len);</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     if (next_block_header != -1) {  /* Peek succeeded */</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       if ((next_block_header &amp; 3) == 3) {  /* ISLAST and ISEMPTY */</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         is_last = 1;</span>
<span class="lineNum">    1317 </span>            :       }
<span class="lineNum">    1318 </span>            :     }
<span class="lineNum">    1319 </span>            :   }
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            :   /* We need at least 2 bytes of ring buffer size to get the last two
<span class="lineNum">    1322 </span>            :      bytes for context from there */
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   if (is_last) {</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     int min_size_x2 = (s-&gt;meta_block_remaining_len + s-&gt;custom_dict_size) * 2;</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     while (s-&gt;ringbuffer_size &gt;= min_size_x2 &amp;&amp; s-&gt;ringbuffer_size &gt; 32) {</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :       s-&gt;ringbuffer_size &gt;&gt;= 1;</span>
<span class="lineNum">    1327 </span>            :     }
<span class="lineNum">    1328 </span>            :   }
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   s-&gt;ringbuffer_mask = s-&gt;ringbuffer_size - 1;</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 : }</span>
<a name="1332"><span class="lineNum">    1332 </span>            : </a>
<span class="lineNum">    1333 </span>            : /* Reads 1..256 2-bit context modes. */
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 : static BrotliErrorCode ReadContextModes(BrotliState* s) {</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   int i = s-&gt;loop_counter;</span>
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :   while (i &lt; (int)s-&gt;num_block_types[0]) {</span>
<span class="lineNum">    1339 </span>            :     uint32_t bits;
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :     if (!BrotliSafeReadBits(br, 2, &amp;bits)) {</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :       s-&gt;loop_counter = i;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :       return BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :     s-&gt;context_modes[i] = (uint8_t)(bits &lt;&lt; 1);</span>
<span class="lineNum">    1345 </span>            :     BROTLI_LOG_ARRAY_INDEX(s-&gt;context_modes, i);
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :     i++;</span>
<span class="lineNum">    1347 </span>            :   }
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   return BROTLI_SUCCESS;</span>
<span class="lineNum">    1349 </span>            : }
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            : static BROTLI_INLINE void TakeDistanceFromRingBuffer(BrotliState* s) {
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   if (s-&gt;distance_code == 0) {</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     --s-&gt;dist_rb_idx;</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :     s-&gt;distance_code = s-&gt;dist_rb[s-&gt;dist_rb_idx &amp; 3];</span>
<span class="lineNum">    1355 </span>            :   } else {
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     int distance_code = s-&gt;distance_code &lt;&lt; 1;</span>
<span class="lineNum">    1357 </span>            :     /* kDistanceShortCodeIndexOffset has 2-bit values from LSB: */
<span class="lineNum">    1358 </span>            :     /* 3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2 */
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     const uint32_t kDistanceShortCodeIndexOffset = 0xaaafff1b;</span>
<span class="lineNum">    1360 </span>            :     /* kDistanceShortCodeValueOffset has 2-bit values from LSB: */
<span class="lineNum">    1361 </span>            :     /*-0, 0,-0, 0,-1, 1,-2, 2,-3, 3,-1, 1,-2, 2,-3, 3 */
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :     const uint32_t kDistanceShortCodeValueOffset = 0xfa5fa500;</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :     int v = (s-&gt;dist_rb_idx +</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :         (int)(kDistanceShortCodeIndexOffset &gt;&gt; distance_code)) &amp; 0x3;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     s-&gt;distance_code = s-&gt;dist_rb[v];</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     v = (int)(kDistanceShortCodeValueOffset &gt;&gt; distance_code) &amp; 0x3;</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :     if ((distance_code &amp; 0x3) != 0) {</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :       s-&gt;distance_code += v;</span>
<span class="lineNum">    1369 </span>            :     } else {
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :       s-&gt;distance_code -= v;</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :       if (s-&gt;distance_code &lt;= 0) {</span>
<span class="lineNum">    1372 </span>            :         /* A huge distance will cause a BROTLI_FAILURE() soon. */
<span class="lineNum">    1373 </span>            :         /* This is a little faster than failing here. */
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :         s-&gt;distance_code = 0x0fffffff;</span>
<span class="lineNum">    1375 </span>            :       }
<span class="lineNum">    1376 </span>            :     }
<span class="lineNum">    1377 </span>            :   }
<span class="lineNum">    1378 </span>            : }
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : static BROTLI_INLINE int SafeReadBits(
<span class="lineNum">    1381 </span>            :     BrotliBitReader* const br, uint32_t n_bits, uint32_t* val) {
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   if (n_bits != 0) {</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :     return BrotliSafeReadBits(br, n_bits, val);</span>
<span class="lineNum">    1384 </span>            :   } else {
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     *val = 0;</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1387 </span>            :   }
<span class="lineNum">    1388 </span>            : }
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span>            : /* Precondition: s-&gt;distance_code &lt; 0 */
<span class="lineNum">    1391 </span>            : static BROTLI_INLINE int ReadDistanceInternal(int safe,
<span class="lineNum">    1392 </span>            :     BrotliState* s, BrotliBitReader* br) {
<span class="lineNum">    1393 </span>            :   int distval;
<span class="lineNum">    1394 </span>            :   BrotliBitReaderState memento;
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :   HuffmanCode* distance_tree = s-&gt;distance_hgroup.htrees[s-&gt;dist_htree_index];</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   if (!safe) {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     s-&gt;distance_code = (int)ReadSymbol(distance_tree, br);</span>
<span class="lineNum">    1398 </span>            :   } else {
<span class="lineNum">    1399 </span>            :     uint32_t code;
<span class="lineNum">    1400 </span>            :     BrotliBitReaderSaveState(br, &amp;memento);
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     if (!SafeReadSymbol(distance_tree, br, &amp;code)) {</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1403 </span>            :     }
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :     s-&gt;distance_code = (int)code;</span>
<span class="lineNum">    1405 </span>            :   }
<span class="lineNum">    1406 </span>            :   /* Convert the distance code to the actual distance by possibly */
<span class="lineNum">    1407 </span>            :   /* looking up past distances from the s-&gt;ringbuffer. */
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   if ((s-&gt;distance_code &amp; ~0xf) == 0) {</span>
<span class="lineNum">    1409 </span>            :     TakeDistanceFromRingBuffer(s);
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     --s-&gt;block_length[2];</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1412 </span>            :   }
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :   distval = s-&gt;distance_code - (int)s-&gt;num_direct_distance_codes;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   if (distval &gt;= 0) {</span>
<span class="lineNum">    1415 </span>            :     uint32_t nbits;
<span class="lineNum">    1416 </span>            :     int postfix;
<span class="lineNum">    1417 </span>            :     int offset;
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :     if (!safe &amp;&amp; (s-&gt;distance_postfix_bits == 0)) {</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       nbits = ((uint32_t)distval &gt;&gt; 1) + 1;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :       offset = ((2 + (distval &amp; 1)) &lt;&lt; nbits) - 4;</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :       s-&gt;distance_code = (int)s-&gt;num_direct_distance_codes + offset +</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                          (int)BrotliReadBits(br, nbits);</span>
<span class="lineNum">    1423 </span>            :     } else {
<span class="lineNum">    1424 </span>            :       /* This branch also works well when s-&gt;distance_postfix_bits == 0 */
<span class="lineNum">    1425 </span>            :       uint32_t bits;
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       postfix = distval &amp; s-&gt;distance_postfix_mask;</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :       distval &gt;&gt;= s-&gt;distance_postfix_bits;</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :       nbits = ((uint32_t)distval &gt;&gt; 1) + 1;</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :       if (safe) {</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         if (!SafeReadBits(br, nbits, &amp;bits)) {</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :           s-&gt;distance_code = -1; /* Restore precondition. */</span>
<span class="lineNum">    1432 </span>            :           BrotliBitReaderRestoreState(br, &amp;memento);
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">    1434 </span>            :         }
<span class="lineNum">    1435 </span>            :       } else {
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :         bits = BrotliReadBits(br, nbits);</span>
<span class="lineNum">    1437 </span>            :       }
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       offset = ((2 + (distval &amp; 1)) &lt;&lt; nbits) - 4;</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       s-&gt;distance_code = (int)s-&gt;num_direct_distance_codes +</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :           ((offset + (int)bits) &lt;&lt; s-&gt;distance_postfix_bits) + postfix;</span>
<span class="lineNum">    1441 </span>            :     }
<span class="lineNum">    1442 </span>            :   }
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   s-&gt;distance_code = s-&gt;distance_code - NUM_DISTANCE_SHORT_CODES + 1;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   --s-&gt;block_length[2];</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1446 </span>            : }
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : static BROTLI_INLINE void ReadDistance(BrotliState* s, BrotliBitReader* br) {
<span class="lineNum">    1449 </span>            :   ReadDistanceInternal(0, s, br);
<span class="lineNum">    1450 </span>            : }
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : static BROTLI_INLINE int SafeReadDistance(BrotliState* s, BrotliBitReader* br) {
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   return ReadDistanceInternal(1, s, br);</span>
<span class="lineNum">    1454 </span>            : }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : static BROTLI_INLINE int ReadCommandInternal(int safe,
<span class="lineNum">    1457 </span>            :     BrotliState* s, BrotliBitReader* br, int* insert_length) {
<span class="lineNum">    1458 </span>            :   uint32_t cmd_code;
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   uint32_t insert_len_extra = 0;</span>
<span class="lineNum">    1460 </span>            :   uint32_t copy_length;
<span class="lineNum">    1461 </span>            :   CmdLutElement v;
<span class="lineNum">    1462 </span>            :   BrotliBitReaderState memento;
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   if (!safe) {</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :     cmd_code = ReadSymbol(s-&gt;htree_command, br);</span>
<span class="lineNum">    1465 </span>            :   } else {
<span class="lineNum">    1466 </span>            :     BrotliBitReaderSaveState(br, &amp;memento);
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :     if (!SafeReadSymbol(s-&gt;htree_command, br, &amp;cmd_code)) {</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1469 </span>            :     }
<span class="lineNum">    1470 </span>            :   }
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :   v = kCmdLut[cmd_code];</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   s-&gt;distance_code = v.distance_code;</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :   s-&gt;distance_context = v.context;</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   s-&gt;dist_htree_index = s-&gt;dist_context_map_slice[s-&gt;distance_context];</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :   *insert_length = v.insert_len_offset;</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :   if (!safe) {</span>
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :     if (PREDICT_FALSE(v.insert_len_extra_bits != 0)) {</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :       insert_len_extra = BrotliReadBits(br, v.insert_len_extra_bits);</span>
<span class="lineNum">    1479 </span>            :     }
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :     copy_length = BrotliReadBits(br, v.copy_len_extra_bits);</span>
<span class="lineNum">    1481 </span>            :   } else {
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :     if (!SafeReadBits(br, v.insert_len_extra_bits, &amp;insert_len_extra) ||</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         !SafeReadBits(br, v.copy_len_extra_bits, &amp;copy_length)) {</span>
<span class="lineNum">    1484 </span>            :       BrotliBitReaderRestoreState(br, &amp;memento);
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1486 </span>            :     }
<span class="lineNum">    1487 </span>            :   }
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :   s-&gt;copy_length = (int)copy_length + v.copy_len_offset;</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :   --s-&gt;block_length[1];</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :   *insert_length += (int)insert_len_extra;</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    1492 </span>            : }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            : static BROTLI_INLINE void ReadCommand(BrotliState* s, BrotliBitReader* br,
<span class="lineNum">    1495 </span>            :     int* insert_length) {
<span class="lineNum">    1496 </span>            :   ReadCommandInternal(0, s, br, insert_length);
<span class="lineNum">    1497 </span>            : }
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            : static BROTLI_INLINE int SafeReadCommand(BrotliState* s, BrotliBitReader* br,
<span class="lineNum">    1500 </span>            :     int* insert_length) {
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   return ReadCommandInternal(1, s, br, insert_length);</span>
<span class="lineNum">    1502 </span>            : }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span>            : static BROTLI_INLINE int CheckInputAmount(int safe,
<span class="lineNum">    1505 </span>            :     BrotliBitReader* const br, size_t num) {
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   if (safe) {</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1508 </span>            :   }
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   return BrotliCheckInputAmount(br, num);</span>
<span class="lineNum">    1510 </span>            : }
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            : #define BROTLI_SAFE(METHOD)               \
<span class="lineNum">    1513 </span>            :   {                                       \
<span class="lineNum">    1514 </span>            :     if (safe) {                           \
<span class="lineNum">    1515 </span>            :       if (!Safe##METHOD) {                \
<span class="lineNum">    1516 </span>            :         result = BROTLI_NEEDS_MORE_INPUT; \
<span class="lineNum">    1517 </span>            :         goto saveStateAndReturn;          \
<span class="lineNum">    1518 </span>            :       }                                   \
<span class="lineNum">    1519 </span>            :     } else {                              \
<span class="lineNum">    1520 </span>            :       METHOD;                             \
<span class="lineNum">    1521 </span>            :     }                                     \
<span class="lineNum">    1522 </span>            :   }
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            : static BROTLI_INLINE BrotliErrorCode ProcessCommandsInternal(int safe,
<span class="lineNum">    1525 </span>            :     BrotliState* s) {
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   int pos = s-&gt;pos;</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :   int i = s-&gt;loop_counter;</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :   BrotliErrorCode result = BROTLI_SUCCESS;</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   if (!CheckInputAmount(safe, br, 28)) {</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1533 </span>            :     goto saveStateAndReturn;
<span class="lineNum">    1534 </span>            :   }
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :   if (!safe) {</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     BROTLI_UNUSED(BrotliWarmupBitReader(br));</span>
<span class="lineNum">    1537 </span>            :   }
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :   /* Jump into state machine. */
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   if (s-&gt;state == BROTLI_STATE_COMMAND_BEGIN) {</span>
<span class="lineNum">    1541 </span>            :     goto CommandBegin;
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   } else if (s-&gt;state == BROTLI_STATE_COMMAND_INNER) {</span>
<span class="lineNum">    1543 </span>            :     goto CommandInner;
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   } else if (s-&gt;state == BROTLI_STATE_COMMAND_POST_DECODE_LITERALS) {</span>
<span class="lineNum">    1545 </span>            :     goto CommandPostDecodeLiterals;
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   } else if (s-&gt;state == BROTLI_STATE_COMMAND_POST_WRAP_COPY) {</span>
<span class="lineNum">    1547 </span>            :     goto CommandPostWrapCopy;
<span class="lineNum">    1548 </span>            :   } else {
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     return BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE);</span>
<span class="lineNum">    1550 </span>            :   }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            : CommandBegin:
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   if (safe) {</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_COMMAND_BEGIN;</span>
<span class="lineNum">    1555 </span>            :   }
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :   if (!CheckInputAmount(safe, br, 28)) { /* 156 bits + 7 bytes */</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_COMMAND_BEGIN;</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :     result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1559 </span>            :     goto saveStateAndReturn;
<span class="lineNum">    1560 </span>            :   }
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   if (PREDICT_FALSE(s-&gt;block_length[1] == 0)) {</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     BROTLI_SAFE(DecodeCommandBlockSwitch(s));</span>
<span class="lineNum">    1563 </span>            :     goto CommandBegin;
<span class="lineNum">    1564 </span>            :   }
<span class="lineNum">    1565 </span>            :   /* Read the insert/copy length in the command */
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   BROTLI_SAFE(ReadCommand(s, br, &amp;i));</span>
<span class="lineNum">    1567 </span>            :   BROTLI_LOG((&quot;[ProcessCommandsInternal] pos = %d insert = %d copy = %d\n&quot;,
<span class="lineNum">    1568 </span>            :               pos, i, s-&gt;copy_length));
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   if (i == 0) {</span>
<span class="lineNum">    1570 </span>            :     goto CommandPostDecodeLiterals;
<span class="lineNum">    1571 </span>            :   }
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   s-&gt;meta_block_remaining_len -= i;</span>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            : CommandInner:
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   if (safe) {</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_COMMAND_INNER;</span>
<span class="lineNum">    1577 </span>            :   }
<span class="lineNum">    1578 </span>            :   /* Read the literals in the command */
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   if (s-&gt;trivial_literal_context) {</span>
<span class="lineNum">    1580 </span>            :     uint32_t bits;
<span class="lineNum">    1581 </span>            :     uint32_t value;
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     PreloadSymbol(safe, s-&gt;literal_htree, br, &amp;bits, &amp;value);</span>
<span class="lineNum">    1583 </span>            :     do {
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :       if (!CheckInputAmount(safe, br, 28)) { /* 162 bits + 7 bytes */</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_COMMAND_INNER;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :         result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :         goto saveStateAndReturn;</span>
<span class="lineNum">    1588 </span>            :       }
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(s-&gt;block_length[0] == 0)) {</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :         BROTLI_SAFE(DecodeLiteralBlockSwitch(s));</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :         PreloadSymbol(safe, s-&gt;literal_htree, br, &amp;bits, &amp;value);</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :         if (!s-&gt;trivial_literal_context) goto CommandInner;</span>
<span class="lineNum">    1593 </span>            :       }
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       if (!safe) {</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :         s-&gt;ringbuffer[pos] =</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :             (uint8_t)ReadPreloadedSymbol(s-&gt;literal_htree, br, &amp;bits, &amp;value);</span>
<span class="lineNum">    1597 </span>            :       } else {
<span class="lineNum">    1598 </span>            :         uint32_t literal;
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         if (!SafeReadSymbol(s-&gt;literal_htree, br, &amp;literal)) {</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :           result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :           goto saveStateAndReturn;</span>
<span class="lineNum">    1602 </span>            :         }
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :         s-&gt;ringbuffer[pos] = (uint8_t)literal;</span>
<span class="lineNum">    1604 </span>            :       }
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :       --s-&gt;block_length[0];</span>
<span class="lineNum">    1606 </span>            :       BROTLI_LOG_ARRAY_INDEX(s-&gt;ringbuffer, pos);
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :       ++pos;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(pos == s-&gt;ringbuffer_size)) {</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_COMMAND_INNER_WRITE;</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :         --i;</span>
<span class="lineNum">    1611 </span>            :         goto saveStateAndReturn;
<span class="lineNum">    1612 </span>            :       }
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     } while (--i != 0);</span>
<span class="lineNum">    1614 </span>            :   } else {
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :     uint8_t p1 = s-&gt;ringbuffer[(pos - 1) &amp; s-&gt;ringbuffer_mask];</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     uint8_t p2 = s-&gt;ringbuffer[(pos - 2) &amp; s-&gt;ringbuffer_mask];</span>
<span class="lineNum">    1617 </span>            :     do {
<span class="lineNum">    1618 </span>            :       const HuffmanCode* hc;
<span class="lineNum">    1619 </span>            :       uint8_t context;
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :       if (!CheckInputAmount(safe, br, 28)) { /* 162 bits + 7 bytes */</span>
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_COMMAND_INNER;</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :         result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1623 </span>            :         goto saveStateAndReturn;
<span class="lineNum">    1624 </span>            :       }
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(s-&gt;block_length[0] == 0)) {</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :         BROTLI_SAFE(DecodeLiteralBlockSwitch(s));</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :         if (s-&gt;trivial_literal_context) goto CommandInner;</span>
<span class="lineNum">    1628 </span>            :       }
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :       context = s-&gt;context_lookup1[p1] | s-&gt;context_lookup2[p2];</span>
<span class="lineNum">    1630 </span>            :       BROTLI_LOG_UINT(context);
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :       hc = s-&gt;literal_hgroup.htrees[s-&gt;context_map_slice[context]];</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :       p2 = p1;</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :       if (!safe) {</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :         p1 = (uint8_t)ReadSymbol(hc, br);</span>
<span class="lineNum">    1635 </span>            :       } else {
<span class="lineNum">    1636 </span>            :         uint32_t literal;
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :         if (!SafeReadSymbol(hc, br, &amp;literal)) {</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :           result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :           goto saveStateAndReturn;</span>
<span class="lineNum">    1640 </span>            :         }
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :         p1 = (uint8_t)literal;</span>
<span class="lineNum">    1642 </span>            :       }
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :       s-&gt;ringbuffer[pos] = p1;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :       --s-&gt;block_length[0];</span>
<span class="lineNum">    1645 </span>            :       BROTLI_LOG_UINT(s-&gt;context_map_slice[context]);
<span class="lineNum">    1646 </span>            :       BROTLI_LOG_ARRAY_INDEX(s-&gt;ringbuffer, pos &amp; s-&gt;ringbuffer_mask);
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :       ++pos;</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(pos == s-&gt;ringbuffer_size)) {</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_COMMAND_INNER_WRITE;</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :         --i;</span>
<span class="lineNum">    1651 </span>            :         goto saveStateAndReturn;
<span class="lineNum">    1652 </span>            :       }
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :     } while (--i != 0);</span>
<span class="lineNum">    1654 </span>            :   }
<span class="lineNum">    1655 </span>            :   BROTLI_LOG_UINT(s-&gt;meta_block_remaining_len);
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   if (PREDICT_FALSE(s-&gt;meta_block_remaining_len &lt;= 0)) {</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    1658 </span>            :     goto saveStateAndReturn;
<span class="lineNum">    1659 </span>            :   }
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : CommandPostDecodeLiterals:
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :   if (safe) {</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;</span>
<span class="lineNum">    1664 </span>            :   }
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :   if (s-&gt;distance_code &gt;= 0) {</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :     --s-&gt;dist_rb_idx;</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :     s-&gt;distance_code = s-&gt;dist_rb[s-&gt;dist_rb_idx &amp; 3];</span>
<span class="lineNum">    1668 </span>            :     goto postReadDistance;  /* We already have the implicit distance */
<span class="lineNum">    1669 </span>            :   }
<span class="lineNum">    1670 </span>            :   /* Read distance code in the command, unless it was implicitly zero. */
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :   if (PREDICT_FALSE(s-&gt;block_length[2] == 0)) {</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :     BROTLI_SAFE(DecodeDistanceBlockSwitch(s));</span>
<span class="lineNum">    1673 </span>            :   }
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :   BROTLI_SAFE(ReadDistance(s, br));</span>
<span class="lineNum">    1675 </span>            : postReadDistance:
<span class="lineNum">    1676 </span>            :   BROTLI_LOG((&quot;[ProcessCommandsInternal] pos = %d distance = %d\n&quot;,
<span class="lineNum">    1677 </span>            :               pos, s-&gt;distance_code));
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :   if (s-&gt;max_distance != s-&gt;max_backward_distance) {</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     if (pos &lt; s-&gt;max_backward_distance_minus_custom_dict_size) {</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :       s-&gt;max_distance = pos + s-&gt;custom_dict_size;</span>
<span class="lineNum">    1681 </span>            :     } else {
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :       s-&gt;max_distance = s-&gt;max_backward_distance;</span>
<span class="lineNum">    1683 </span>            :     }
<span class="lineNum">    1684 </span>            :   }
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :   i = s-&gt;copy_length;</span>
<span class="lineNum">    1686 </span>            :   /* Apply copy of LZ77 back-reference, or static dictionary reference if
<span class="lineNum">    1687 </span>            :   the distance is larger than the max LZ77 distance */
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :   if (s-&gt;distance_code &gt; s-&gt;max_distance) {</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :     if (i &gt;= kBrotliMinDictionaryWordLength &amp;&amp;</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :         i &lt;= kBrotliMaxDictionaryWordLength) {</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :       int offset = (int)kBrotliDictionaryOffsetsByLength[i];</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :       int word_id = s-&gt;distance_code - s-&gt;max_distance - 1;</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :       uint32_t shift = kBrotliDictionarySizeBitsByLength[i];</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :       int mask = (int)BitMask(shift);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       int word_idx = word_id &amp; mask;</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :       int transform_idx = word_id &gt;&gt; shift;</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       offset += word_idx * i;</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :       if (transform_idx &lt; kNumTransforms) {</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :         const uint8_t* word = &amp;kBrotliDictionary[offset];</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :         int len = i;</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         if (transform_idx == 0) {</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :           memcpy(&amp;s-&gt;ringbuffer[pos], word, (size_t)len);</span>
<span class="lineNum">    1703 </span>            :         } else {
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :           len = TransformDictionaryWord(</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :               &amp;s-&gt;ringbuffer[pos], word, len, transform_idx);</span>
<span class="lineNum">    1706 </span>            :         }
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :         pos += len;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :         s-&gt;meta_block_remaining_len -= len;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :         if (pos &gt;= s-&gt;ringbuffer_size) {</span>
<span class="lineNum">    1710 </span>            :           /*s-&gt;partial_pos_rb += (size_t)s-&gt;ringbuffer_size;*/
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_COMMAND_POST_WRITE_1;</span>
<span class="lineNum">    1712 </span>            :           goto saveStateAndReturn;
<span class="lineNum">    1713 </span>            :         }
<span class="lineNum">    1714 </span>            :       } else {
<span class="lineNum">    1715 </span>            :         BROTLI_LOG((&quot;Invalid backward reference. pos: %d distance: %d &quot;
<span class="lineNum">    1716 </span>            :             &quot;len: %d bytes left: %d\n&quot;,
<span class="lineNum">    1717 </span>            :             pos, s-&gt;distance_code, i, s-&gt;meta_block_remaining_len));
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :         return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_TRANSFORM);</span>
<span class="lineNum">    1719 </span>            :       }
<span class="lineNum">    1720 </span>            :     } else {
<span class="lineNum">    1721 </span>            :       BROTLI_LOG((&quot;Invalid backward reference. pos: %d distance: %d &quot;
<span class="lineNum">    1722 </span>            :           &quot;len: %d bytes left: %d\n&quot;,
<span class="lineNum">    1723 </span>            :           pos, s-&gt;distance_code, i, s-&gt;meta_block_remaining_len));
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :       return BROTLI_FAILURE(BROTLI_ERROR_FORMAT_DICTIONARY);</span>
<span class="lineNum">    1725 </span>            :     }
<span class="lineNum">    1726 </span>            :   } else {
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     int src_start = (pos - s-&gt;distance_code) &amp; s-&gt;ringbuffer_mask;</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     uint8_t* copy_dst = &amp;s-&gt;ringbuffer[pos];</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     uint8_t* copy_src = &amp;s-&gt;ringbuffer[src_start];</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :     int dst_end = pos + i;</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :     int src_end = src_start + i;</span>
<span class="lineNum">    1732 </span>            :     /* update the recent distances cache */
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     s-&gt;dist_rb[s-&gt;dist_rb_idx &amp; 3] = s-&gt;distance_code;</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     ++s-&gt;dist_rb_idx;</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     s-&gt;meta_block_remaining_len -= i;</span>
<span class="lineNum">    1736 </span>            :     /* There are 32+ bytes of slack in the ringbuffer allocation.
<span class="lineNum">    1737 </span>            :        Also, we have 16 short codes, that make these 16 bytes irrelevant
<span class="lineNum">    1738 </span>            :        in the ringbuffer. Let's copy over them as a first guess.
<span class="lineNum">    1739 </span>            :      */
<span class="lineNum">    1740 </span>            :     memmove16(copy_dst, copy_src);
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :     if (src_end &gt; pos &amp;&amp; dst_end &gt; src_start) {</span>
<span class="lineNum">    1742 </span>            :       /* Regions intersect. */
<span class="lineNum">    1743 </span>            :       goto CommandPostWrapCopy;
<span class="lineNum">    1744 </span>            :     }
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :     if (dst_end &gt;= s-&gt;ringbuffer_size || src_end &gt;= s-&gt;ringbuffer_size) {</span>
<span class="lineNum">    1746 </span>            :       /* At least one region wraps. */
<span class="lineNum">    1747 </span>            :       goto CommandPostWrapCopy;
<span class="lineNum">    1748 </span>            :     }
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     pos += i;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :     if (i &gt; 16) {</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :       if (i &gt; 32) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         memcpy(copy_dst + 16, copy_src + 16, (size_t)(i - 16));</span>
<span class="lineNum">    1753 </span>            :       } else {
<span class="lineNum">    1754 </span>            :         /* This branch covers about 45% cases.
<span class="lineNum">    1755 </span>            :            Fixed size short copy allows more compiler optimizations. */
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :         memmove16(copy_dst + 16, copy_src + 16);</span>
<span class="lineNum">    1757 </span>            :       }
<span class="lineNum">    1758 </span>            :     }
<span class="lineNum">    1759 </span>            :   }
<span class="lineNum">    1760 </span>            :   BROTLI_LOG_UINT(s-&gt;meta_block_remaining_len);
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :   if (s-&gt;meta_block_remaining_len &lt;= 0) {</span>
<span class="lineNum">    1762 </span>            :     /* Next metablock, if any */
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    1764 </span>            :     goto saveStateAndReturn;
<span class="lineNum">    1765 </span>            :   } else {
<span class="lineNum">    1766 </span>            :     goto CommandBegin;
<span class="lineNum">    1767 </span>            :   }
<span class="lineNum">    1768 </span>            : CommandPostWrapCopy:
<span class="lineNum">    1769 </span>            :   {
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     int wrap_guard = s-&gt;ringbuffer_size - pos;</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     while (--i &gt;= 0) {</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :       s-&gt;ringbuffer[pos] =</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :           s-&gt;ringbuffer[(pos - s-&gt;distance_code) &amp; s-&gt;ringbuffer_mask];</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :       ++pos;</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :       if (PREDICT_FALSE(--wrap_guard == 0)) {</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_COMMAND_POST_WRITE_2;</span>
<span class="lineNum">    1777 </span>            :         goto saveStateAndReturn;
<span class="lineNum">    1778 </span>            :       }
<span class="lineNum">    1779 </span>            :     }
<span class="lineNum">    1780 </span>            :   }
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :   if (s-&gt;meta_block_remaining_len &lt;= 0) {</span>
<span class="lineNum">    1782 </span>            :     /* Next metablock, if any */
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    1784 </span>            :     goto saveStateAndReturn;
<span class="lineNum">    1785 </span>            :   } else {
<span class="lineNum">    1786 </span>            :     goto CommandBegin;
<span class="lineNum">    1787 </span>            :   }
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            : saveStateAndReturn:
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :   s-&gt;pos = pos;</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :   s-&gt;loop_counter = i;</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1793 </span>            : }
<span class="lineNum">    1794 </span>            : 
<a name="1795"><span class="lineNum">    1795 </span>            : #undef BROTLI_SAFE</a>
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE BrotliErrorCode ProcessCommands(BrotliState* s) {</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :   return ProcessCommandsInternal(0, s);</span>
<a name="1799"><span class="lineNum">    1799 </span>            : }</a>
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 : static BROTLI_NOINLINE BrotliErrorCode SafeProcessCommands(BrotliState* s) {</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :   return ProcessCommandsInternal(1, s);</span>
<a name="1803"><span class="lineNum">    1803 </span>            : }</a>
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 : BrotliResult BrotliDecompressBuffer(size_t encoded_size,</span>
<span class="lineNum">    1806 </span>            :                                     const uint8_t* encoded_buffer,
<span class="lineNum">    1807 </span>            :                                     size_t* decoded_size,
<span class="lineNum">    1808 </span>            :                                     uint8_t* decoded_buffer) {
<span class="lineNum">    1809 </span>            :   BrotliState s;
<span class="lineNum">    1810 </span>            :   BrotliResult result;
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :   size_t total_out = 0;</span>
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :   size_t available_in = encoded_size;</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :   const uint8_t* next_in = encoded_buffer;</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :   size_t available_out = *decoded_size;</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :   uint8_t* next_out = decoded_buffer;</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :   BrotliStateInit(&amp;s);</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :   result = BrotliDecompressStream(&amp;available_in, &amp;next_in, &amp;available_out,</span>
<span class="lineNum">    1818 </span>            :       &amp;next_out, &amp;total_out, &amp;s);
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :   *decoded_size = total_out;</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :   BrotliStateCleanup(&amp;s);</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :   if (result != BROTLI_RESULT_SUCCESS) {</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     result = BROTLI_RESULT_ERROR;</span>
<span class="lineNum">    1823 </span>            :   }
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1825 </span>            : }
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            : /* Invariant: input stream is never overconsumed:
<span class="lineNum">    1828 </span>            :     * invalid input implies that the whole stream is invalid -&gt; any amount of
<span class="lineNum">    1829 </span>            :       input could be read and discarded
<span class="lineNum">    1830 </span>            :     * when result is &quot;needs more input&quot;, then at leat one more byte is REQUIRED
<span class="lineNum">    1831 </span>            :       to complete decoding; all input data MUST be consumed by decoder, so
<span class="lineNum">    1832 </span>            :       client could swap the input buffer
<span class="lineNum">    1833 </span>            :     * when result is &quot;needs more output&quot; decoder MUST ensure that it doesn't
<span class="lineNum">    1834 </span>            :       hold more than 7 bits in bit reader; this saves client from swapping input
<span class="lineNum">    1835 </span>            :       buffer ahead of time
<span class="lineNum">    1836 </span>            :     * when result is &quot;success&quot; decoder MUST return all unused data back to input
<a name="1837"><span class="lineNum">    1837 </span>            :       buffer; this is possible because the invariant is hold on enter</a>
<span class="lineNum">    1838 </span>            : */
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 : BrotliResult BrotliDecompressStream(size_t* available_in,</span>
<span class="lineNum">    1840 </span>            :     const uint8_t** next_in, size_t* available_out, uint8_t** next_out,
<span class="lineNum">    1841 </span>            :     size_t* total_out, BrotliState* s) {
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :   BrotliErrorCode result = BROTLI_SUCCESS;</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :   BrotliBitReader* br = &amp;s-&gt;br;</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :   if (s-&gt;buffer_length == 0) { /* Just connect bit reader to input stream. */</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :     br-&gt;avail_in = *available_in;</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     br-&gt;next_in = *next_in;</span>
<span class="lineNum">    1847 </span>            :   } else {
<span class="lineNum">    1848 </span>            :     /* At least one byte of input is required. More than one byte of input may
<span class="lineNum">    1849 </span>            :        be required to complete the transaction -&gt; reading more data must be
<span class="lineNum">    1850 </span>            :        done in a loop -&gt; do it in a main loop. */
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :     result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     br-&gt;next_in = &amp;s-&gt;buffer.u8[0];</span>
<span class="lineNum">    1853 </span>            :   }
<span class="lineNum">    1854 </span>            :   /* State machine */
<span class="lineNum">    1855 </span>            :   for (;;) {
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :     if (result != BROTLI_SUCCESS) { /* Error | needs more input/output */</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :       if (result == BROTLI_NEEDS_MORE_INPUT) {</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :         if (s-&gt;ringbuffer != 0) { /* Proactively push output. */</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :           WriteRingBuffer(available_out, next_out, total_out, s);</span>
<span class="lineNum">    1860 </span>            :         }
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         if (s-&gt;buffer_length != 0) { /* Used with internal buffer. */</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :           if (br-&gt;avail_in == 0) { /* Successfully finished read transaction. */</span>
<span class="lineNum">    1863 </span>            :             /* Accamulator contains less than 8 bits, because internal buffer
<span class="lineNum">    1864 </span>            :                is expanded byte-by-byte until it is enough to complete read. */
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :             s-&gt;buffer_length = 0;</span>
<span class="lineNum">    1866 </span>            :             /* Switch to input stream and restart. */
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :             result = BROTLI_SUCCESS;</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :             br-&gt;avail_in = *available_in;</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :             br-&gt;next_in = *next_in;</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :           } else if (*available_in != 0) {</span>
<span class="lineNum">    1872 </span>            :             /* Not enough data in buffer, but can take one more byte from
<span class="lineNum">    1873 </span>            :                input stream. */
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :             result = BROTLI_SUCCESS;</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :             s-&gt;buffer.u8[s-&gt;buffer_length] = **next_in;</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :             s-&gt;buffer_length++;</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :             br-&gt;avail_in = s-&gt;buffer_length;</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :             (*next_in)++;</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :             (*available_in)--;</span>
<span class="lineNum">    1880 </span>            :             /* Retry with more data in buffer. */
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1882 </span>            :           }
<span class="lineNum">    1883 </span>            :           /* Can't finish reading and no more input.*/
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1885 </span>            :         } else { /* Input stream doesn't contain enough input. */
<span class="lineNum">    1886 </span>            :           /* Copy tail to internal buffer and return. */
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :           *next_in = br-&gt;next_in;</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :           *available_in = br-&gt;avail_in;</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :           while (*available_in) {</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :             s-&gt;buffer.u8[s-&gt;buffer_length] = **next_in;</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :             s-&gt;buffer_length++;</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :             (*next_in)++;</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :             (*available_in)--;</span>
<span class="lineNum">    1894 </span>            :           }
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1896 </span>            :         }
<span class="lineNum">    1897 </span>            :         /* Unreachable. */
<span class="lineNum">    1898 </span>            :       }
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :       /* Fail or needs more output. */
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :       if (s-&gt;buffer_length != 0) {</span>
<span class="lineNum">    1903 </span>            :         /* Just consumed the buffered input and produced some output. Otherwise
<span class="lineNum">    1904 </span>            :            it would result in &quot;needs more input&quot;. Reset internal buffer.*/
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :         s-&gt;buffer_length = 0;</span>
<span class="lineNum">    1906 </span>            :       } else {
<span class="lineNum">    1907 </span>            :         /* Using input stream in last iteration. When decoder switches to input
<span class="lineNum">    1908 </span>            :            stream it has less than 8 bits in accamulator, so it is safe to
<span class="lineNum">    1909 </span>            :            return unused accamulator bits there. */
<span class="lineNum">    1910 </span>            :         BrotliBitReaderUnload(br);
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :         *available_in = br-&gt;avail_in;</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :         *next_in = br-&gt;next_in;</span>
<span class="lineNum">    1913 </span>            :       }
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1915 </span>            :     }
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     switch (s-&gt;state) {</span>
<span class="lineNum">    1917 </span>            :       case BROTLI_STATE_UNINITED:
<span class="lineNum">    1918 </span>            :         /* Prepare to the first read. */
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         if (!BrotliWarmupBitReader(br)) {</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :           result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1922 </span>            :         }
<span class="lineNum">    1923 </span>            :         /* Decode window size. */
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :         s-&gt;window_bits = DecodeWindowBits(br); /* Reads 1..7 bits. */</span>
<span class="lineNum">    1925 </span>            :         BROTLI_LOG_UINT(s-&gt;window_bits);
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :         if (s-&gt;window_bits == 9) {</span>
<span class="lineNum">    1927 </span>            :           /* Value 9 is reserved for future use. */
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :           result = BROTLI_FAILURE(BROTLI_ERROR_FORMAT_WINDOW_BITS);</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1930 </span>            :         }
<span class="lineNum">    1931 </span>            :         /* Maximum distance, see section 9.1. of the spec. */
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         s-&gt;max_backward_distance = (1 &lt;&lt; s-&gt;window_bits) - 16;</span>
<span class="lineNum">    1933 </span>            :         /* Limit custom dictionary size. */
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :         if (s-&gt;custom_dict_size &gt;= s-&gt;max_backward_distance) {</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :           s-&gt;custom_dict += s-&gt;custom_dict_size - s-&gt;max_backward_distance;</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :           s-&gt;custom_dict_size = s-&gt;max_backward_distance;</span>
<span class="lineNum">    1937 </span>            :         }
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :         s-&gt;max_backward_distance_minus_custom_dict_size =</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :             s-&gt;max_backward_distance - s-&gt;custom_dict_size;</span>
<span class="lineNum">    1940 </span>            : 
<span class="lineNum">    1941 </span>            :         /* Allocate memory for both block_type_trees and block_len_trees. */
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :         s-&gt;block_type_trees = (HuffmanCode*)BROTLI_ALLOC(s,</span>
<span class="lineNum">    1943 </span>            :             sizeof(HuffmanCode) * 3 *
<span class="lineNum">    1944 </span>            :                 (BROTLI_HUFFMAN_MAX_SIZE_258 + BROTLI_HUFFMAN_MAX_SIZE_26));
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :         if (s-&gt;block_type_trees == 0) {</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :           result = BROTLI_FAILURE(BROTLI_ERROR_ALLOC_BLOCK_TYPE_TREES);</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1948 </span>            :         }
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :         s-&gt;block_len_trees =</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :             s-&gt;block_type_trees + 3 * BROTLI_HUFFMAN_MAX_SIZE_258;</span>
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_METABLOCK_BEGIN;</span>
<span class="lineNum">    1953 </span>            :         /* No break, continue to next state */
<span class="lineNum">    1954 </span>            :       case BROTLI_STATE_METABLOCK_BEGIN:
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :         BrotliStateMetablockBegin(s);</span>
<span class="lineNum">    1956 </span>            :         BROTLI_LOG_UINT(s-&gt;pos);
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_METABLOCK_HEADER;</span>
<span class="lineNum">    1958 </span>            :         /* No break, continue to next state */
<span class="lineNum">    1959 </span>            :       case BROTLI_STATE_METABLOCK_HEADER:
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :         result = DecodeMetaBlockLength(s, br); /* Reads 2 - 31 bits. */</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1963 </span>            :         }
<span class="lineNum">    1964 </span>            :         BROTLI_LOG_UINT(s-&gt;is_last_metablock);
<span class="lineNum">    1965 </span>            :         BROTLI_LOG_UINT(s-&gt;meta_block_remaining_len);
<span class="lineNum">    1966 </span>            :         BROTLI_LOG_UINT(s-&gt;is_metadata);
<span class="lineNum">    1967 </span>            :         BROTLI_LOG_UINT(s-&gt;is_uncompressed);
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         if (s-&gt;is_metadata || s-&gt;is_uncompressed) {</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :           if (!BrotliJumpToByteBoundary(br)) {</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :             result = BROTLI_FAILURE(BROTLI_ERROR_FORMAT_PADDING_1);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1972 </span>            :           }
<span class="lineNum">    1973 </span>            :         }
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :         if (s-&gt;is_metadata) {</span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_METADATA;</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1977 </span>            :         }
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :         if (s-&gt;meta_block_remaining_len == 0) {</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1981 </span>            :         }
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         if (!s-&gt;ringbuffer) {</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :           BrotliCalculateRingBufferSize(s, br);</span>
<span class="lineNum">    1984 </span>            :         }
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         if (s-&gt;is_uncompressed) {</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_UNCOMPRESSED;</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1988 </span>            :         }
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter = 0;</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_HUFFMAN_CODE_0;</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1992 </span>            :       case BROTLI_STATE_UNCOMPRESSED: {
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :         int bytes_copied = s-&gt;meta_block_remaining_len;</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :         result = CopyUncompressedBlockToOutput(</span>
<span class="lineNum">    1995 </span>            :             available_out, next_out, total_out, s);
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :         bytes_copied -= s-&gt;meta_block_remaining_len;</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1999 </span>            :         }
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2002 </span>            :       }
<span class="lineNum">    2003 </span>            :       case BROTLI_STATE_METADATA:
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :         for (; s-&gt;meta_block_remaining_len &gt; 0; --s-&gt;meta_block_remaining_len) {</span>
<span class="lineNum">    2005 </span>            :           uint32_t bits;
<span class="lineNum">    2006 </span>            :           /* Read one byte and ignore it. */
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           if (!BrotliSafeReadBits(br, 8, &amp;bits)) {</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :             result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2010 </span>            :           }
<span class="lineNum">    2011 </span>            :         }
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :         if (result == BROTLI_SUCCESS) {</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    2014 </span>            :         }
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2016 </span>            :       case BROTLI_STATE_HUFFMAN_CODE_0:
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :         if (s-&gt;loop_counter &gt;= 3) {</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_METABLOCK_HEADER_2;</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2020 </span>            :         }
<span class="lineNum">    2021 </span>            :         /* Reads 1..11 bits. */
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :         result = DecodeVarLenUint8(s, br, &amp;s-&gt;num_block_types[s-&gt;loop_counter]);</span>
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2025 </span>            :         }
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :         s-&gt;num_block_types[s-&gt;loop_counter]++;</span>
<span class="lineNum">    2027 </span>            :         BROTLI_LOG_UINT(s-&gt;num_block_types[s-&gt;loop_counter]);
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :         if (s-&gt;num_block_types[s-&gt;loop_counter] &lt; 2) {</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :           s-&gt;loop_counter++;</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2031 </span>            :         }
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_HUFFMAN_CODE_1;</span>
<span class="lineNum">    2033 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2034 </span>            :       case BROTLI_STATE_HUFFMAN_CODE_1: {
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :         int tree_offset = s-&gt;loop_counter * BROTLI_HUFFMAN_MAX_SIZE_258;</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :         result = ReadHuffmanCode(s-&gt;num_block_types[s-&gt;loop_counter] + 2,</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :             &amp;s-&gt;block_type_trees[tree_offset], NULL, s);</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) break;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_HUFFMAN_CODE_2;</span>
<span class="lineNum">    2040 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2041 </span>            :       }
<span class="lineNum">    2042 </span>            :       case BROTLI_STATE_HUFFMAN_CODE_2: {
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :         int tree_offset = s-&gt;loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :         result = ReadHuffmanCode(kNumBlockLengthCodes,</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :             &amp;s-&gt;block_len_trees[tree_offset], NULL, s);</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) break;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_HUFFMAN_CODE_3;</span>
<span class="lineNum">    2048 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2049 </span>            :       }
<span class="lineNum">    2050 </span>            :       case BROTLI_STATE_HUFFMAN_CODE_3: {
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :         int tree_offset = s-&gt;loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :         if (!SafeReadBlockLength(s, &amp;s-&gt;block_length[s-&gt;loop_counter],</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :             &amp;s-&gt;block_len_trees[tree_offset], br)) {</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :           result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2056 </span>            :         }
<span class="lineNum">    2057 </span>            :         BROTLI_LOG_UINT(s-&gt;block_length[s-&gt;loop_counter]);
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter++;</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_HUFFMAN_CODE_0;</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2061 </span>            :       }
<span class="lineNum">    2062 </span>            :       case BROTLI_STATE_METABLOCK_HEADER_2: {
<span class="lineNum">    2063 </span>            :         uint32_t bits;
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :         if (!BrotliSafeReadBits(br, 6, &amp;bits)) {</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :           result = BROTLI_NEEDS_MORE_INPUT;</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2067 </span>            :         }
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :         s-&gt;distance_postfix_bits = bits &amp; BitMask(2);</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :         bits &gt;&gt;= 2;</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :         s-&gt;num_direct_distance_codes =</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :             NUM_DISTANCE_SHORT_CODES + (bits &lt;&lt; s-&gt;distance_postfix_bits);</span>
<span class="lineNum">    2072 </span>            :         BROTLI_LOG_UINT(s-&gt;num_direct_distance_codes);
<span class="lineNum">    2073 </span>            :         BROTLI_LOG_UINT(s-&gt;distance_postfix_bits);
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         s-&gt;distance_postfix_mask = (int)BitMask(s-&gt;distance_postfix_bits);</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :         s-&gt;context_modes =</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :             (uint8_t*)BROTLI_ALLOC(s, (size_t)s-&gt;num_block_types[0]);</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :         if (s-&gt;context_modes == 0) {</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :           result = BROTLI_FAILURE(BROTLI_ERROR_ALLOC_CONTEXT_MODES);</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2080 </span>            :         }
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter = 0;</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_CONTEXT_MODES;</span>
<span class="lineNum">    2083 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2084 </span>            :       }
<span class="lineNum">    2085 </span>            :       case BROTLI_STATE_CONTEXT_MODES:
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         result = ReadContextModes(s);</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2089 </span>            :         }
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_CONTEXT_MAP_1;</span>
<span class="lineNum">    2091 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2092 </span>            :       case BROTLI_STATE_CONTEXT_MAP_1:
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :         result = DecodeContextMap(</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :             s-&gt;num_block_types[0] &lt;&lt; kLiteralContextBits,</span>
<span class="lineNum">    2095 </span>            :             &amp;s-&gt;num_literal_htrees, &amp;s-&gt;context_map, s);
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2098 </span>            :         }
<span class="lineNum">    2099 </span>            :         DetectTrivialLiteralBlockTypes(s);
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_CONTEXT_MAP_2;</span>
<span class="lineNum">    2101 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2102 </span>            :       case BROTLI_STATE_CONTEXT_MAP_2:
<span class="lineNum">    2103 </span>            :         {
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :           uint32_t num_distance_codes =</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :               s-&gt;num_direct_distance_codes + (48U &lt;&lt; s-&gt;distance_postfix_bits);</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :           result = DecodeContextMap(</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :               s-&gt;num_block_types[2] &lt;&lt; kDistanceContextBits,</span>
<span class="lineNum">    2108 </span>            :               &amp;s-&gt;num_dist_htrees, &amp;s-&gt;dist_context_map, s);
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :           if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2111 </span>            :           }
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :           BrotliHuffmanTreeGroupInit(s, &amp;s-&gt;literal_hgroup, kNumLiteralCodes,</span>
<span class="lineNum">    2113 </span>            :                                      s-&gt;num_literal_htrees);
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :           BrotliHuffmanTreeGroupInit(s, &amp;s-&gt;insert_copy_hgroup,</span>
<span class="lineNum">    2115 </span>            :                                      kNumInsertAndCopyCodes,
<span class="lineNum">    2116 </span>            :                                      s-&gt;num_block_types[1]);
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :           BrotliHuffmanTreeGroupInit(s, &amp;s-&gt;distance_hgroup, num_distance_codes,</span>
<span class="lineNum">    2118 </span>            :                                      s-&gt;num_dist_htrees);
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :           if (s-&gt;literal_hgroup.codes == 0 ||</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :               s-&gt;insert_copy_hgroup.codes == 0 ||</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :               s-&gt;distance_hgroup.codes == 0) {</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :             return SaveErrorCode(s,</span>
<span class="lineNum">    2123 </span>            :                 BROTLI_FAILURE(BROTLI_ERROR_ALLOC_TREE_GROUPS));
<span class="lineNum">    2124 </span>            :           }
<span class="lineNum">    2125 </span>            :         }
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter = 0;</span>
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_TREE_GROUP;</span>
<span class="lineNum">    2128 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2129 </span>            :       case BROTLI_STATE_TREE_GROUP:
<span class="lineNum">    2130 </span>            :         {
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :           HuffmanTreeGroup* hgroup = NULL;</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :           switch (s-&gt;loop_counter) {</span>
<span class="lineNum">    2133 </span>            :             case 0:
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :               hgroup = &amp;s-&gt;literal_hgroup;</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2136 </span>            :             case 1:
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :               hgroup = &amp;s-&gt;insert_copy_hgroup;</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2139 </span>            :             case 2:
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :               hgroup = &amp;s-&gt;distance_hgroup;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2142 </span>            :             default:
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :               return SaveErrorCode(s,</span>
<span class="lineNum">    2144 </span>            :                   BROTLI_FAILURE(BROTLI_ERROR_UNREACHABLE));
<span class="lineNum">    2145 </span>            :           }
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :           result = HuffmanTreeGroupDecode(hgroup, s);</span>
<span class="lineNum">    2147 </span>            :         }
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) break;</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         s-&gt;loop_counter++;</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :         if (s-&gt;loop_counter &gt;= 3) {</span>
<span class="lineNum">    2151 </span>            :           PrepareLiteralDecoding(s);
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :           s-&gt;dist_context_map_slice = s-&gt;dist_context_map;</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :           s-&gt;htree_command = s-&gt;insert_copy_hgroup.htrees[0];</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :           if (!s-&gt;ringbuffer &amp;&amp; !BrotliAllocateRingBuffer(s)) {</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :             result = BROTLI_FAILURE(BROTLI_ERROR_ALLOC_RING_BUFFER_2);</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2157 </span>            :           }
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_COMMAND_BEGIN;</span>
<span class="lineNum">    2159 </span>            :         }
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2161 </span>            :       case BROTLI_STATE_COMMAND_BEGIN:
<span class="lineNum">    2162 </span>            :       case BROTLI_STATE_COMMAND_INNER:
<span class="lineNum">    2163 </span>            :       case BROTLI_STATE_COMMAND_POST_DECODE_LITERALS:
<span class="lineNum">    2164 </span>            :       case BROTLI_STATE_COMMAND_POST_WRAP_COPY:
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :         result = ProcessCommands(s);</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :         if (result == BROTLI_NEEDS_MORE_INPUT) {</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :           result = SafeProcessCommands(s);</span>
<span class="lineNum">    2168 </span>            :         }
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2170 </span>            :       case BROTLI_STATE_COMMAND_INNER_WRITE:
<span class="lineNum">    2171 </span>            :       case BROTLI_STATE_COMMAND_POST_WRITE_1:
<span class="lineNum">    2172 </span>            :       case BROTLI_STATE_COMMAND_POST_WRITE_2:
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :         result = WriteRingBuffer(available_out, next_out, total_out, s);</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :         if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2176 </span>            :         }
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :         s-&gt;max_distance = s-&gt;max_backward_distance;</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :         if (s-&gt;state == BROTLI_STATE_COMMAND_POST_WRITE_1) {</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :           memcpy(s-&gt;ringbuffer, s-&gt;ringbuffer_end, (size_t)s-&gt;pos);</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :           if (s-&gt;meta_block_remaining_len == 0) {</span>
<span class="lineNum">    2181 </span>            :             /* Next metablock, if any */
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :             s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    2183 </span>            :           } else {
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :             s-&gt;state = BROTLI_STATE_COMMAND_BEGIN;</span>
<span class="lineNum">    2185 </span>            :           }
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :         } else if (s-&gt;state == BROTLI_STATE_COMMAND_POST_WRITE_2) {</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_COMMAND_POST_WRAP_COPY;</span>
<span class="lineNum">    2189 </span>            :         } else {  /* BROTLI_STATE_COMMAND_INNER_WRITE */
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :           if (s-&gt;loop_counter == 0) {</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :             if (s-&gt;meta_block_remaining_len == 0) {</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :               s-&gt;state = BROTLI_STATE_METABLOCK_DONE;</span>
<span class="lineNum">    2193 </span>            :             } else {
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :               s-&gt;state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;</span>
<span class="lineNum">    2195 </span>            :             }
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2197 </span>            :           }
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_COMMAND_INNER;</span>
<span class="lineNum">    2199 </span>            :         }
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2201 </span>            :       case BROTLI_STATE_METABLOCK_DONE:
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :         if (s-&gt;meta_block_remaining_len &lt; 0) {</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :           result = BROTLI_FAILURE(BROTLI_ERROR_FORMAT_BLOCK_LENGTH_2);</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2205 </span>            :         }
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :         BrotliStateCleanupAfterMetablock(s);</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :         if (!s-&gt;is_last_metablock) {</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :           s-&gt;state = BROTLI_STATE_METABLOCK_BEGIN;</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2210 </span>            :         }
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :         if (!BrotliJumpToByteBoundary(br)) {</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :           result = BROTLI_FAILURE(BROTLI_ERROR_FORMAT_PADDING_2);</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2214 </span>            :         }
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :         if (s-&gt;buffer_length == 0) {</span>
<span class="lineNum">    2216 </span>            :           BrotliBitReaderUnload(br);
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :           *available_in = br-&gt;avail_in;</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :           *next_in = br-&gt;next_in;</span>
<span class="lineNum">    2219 </span>            :         }
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :         s-&gt;state = BROTLI_STATE_DONE;</span>
<span class="lineNum">    2221 </span>            :         /* No break, continue to next state */
<span class="lineNum">    2222 </span>            :       case BROTLI_STATE_DONE:
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :         if (s-&gt;ringbuffer != 0) {</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :           result = WriteRingBuffer(available_out, next_out, total_out, s);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :           if (result != BROTLI_SUCCESS) {</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2227 </span>            :           }
<span class="lineNum">    2228 </span>            :         }
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :         return SaveErrorCode(s, result);</span>
<span class="lineNum">    2230 </span>            :     }
<span class="lineNum">    2231 </span>            :   }
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   return SaveErrorCode(s, result);</span>
<a name="2233"><span class="lineNum">    2233 </span>            : }</a>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 : void BrotliSetCustomDictionary(</span>
<span class="lineNum">    2236 </span>            :     size_t size, const uint8_t* dict, BrotliState* s) {
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :   if (size &gt; (1u &lt;&lt; 24)) {</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2239 </span>            :   }
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :   s-&gt;custom_dict = dict;</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :   s-&gt;custom_dict_size = (int)size;</span>
<a name="2242"><span class="lineNum">    2242 </span>            : }</a>
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 : BrotliErrorCode BrotliGetErrorCode(const BrotliState* s) {</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :   return (BrotliErrorCode)s-&gt;error_code;</span>
<a name="2246"><span class="lineNum">    2246 </span>            : }</a>
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 : const char* BrotliErrorString(BrotliErrorCode c) {</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :   switch (c) {</span>
<span class="lineNum">    2250 </span>            : #define _BROTLI_ERROR_CODE_CASE(PREFIX, NAME, CODE) \
<span class="lineNum">    2251 </span>            :     case BROTLI ## PREFIX ## NAME: return #NAME;
<span class="lineNum">    2252 </span>            : #define _BROTLI_NOTHING
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :     BROTLI_ERROR_CODES_LIST(_BROTLI_ERROR_CODE_CASE, _BROTLI_NOTHING)</span>
<span class="lineNum">    2254 </span>            : #undef _BROTLI_ERROR_CODE_CASE
<span class="lineNum">    2255 </span>            : #undef _BROTLI_NOTHING
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :     default: return &quot;INVALID&quot;;</span>
<span class="lineNum">    2257 </span>            :   }
<span class="lineNum">    2258 </span>            : }
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            : #if defined(__cplusplus) || defined(c_plusplus)
<span class="lineNum">    2261 </span>            : }  /* extern &quot;C&quot; */
<span class="lineNum">    2262 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - image/decoders/nsBMPDecoder.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">image/decoders</a> - nsBMPDecoder.cpp<span style="font-size: 80%;"> (source / <a href="nsBMPDecoder.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">449</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : // This is a cross-platform BMP Decoder, which should work everywhere,
<span class="lineNum">       8 </span>            : // including big-endian machines like the PowerPC.
<span class="lineNum">       9 </span>            : //
<span class="lineNum">      10 </span>            : // BMP is a format that has been extended multiple times. To understand the
<span class="lineNum">      11 </span>            : // decoder you need to understand this history. The summary of the history
<span class="lineNum">      12 </span>            : // below was determined from the following documents.
<span class="lineNum">      13 </span>            : //
<span class="lineNum">      14 </span>            : // - http://www.fileformat.info/format/bmp/egff.htm
<span class="lineNum">      15 </span>            : // - http://www.fileformat.info/format/os2bmp/egff.htm
<span class="lineNum">      16 </span>            : // - http://fileformats.archiveteam.org/wiki/BMP
<span class="lineNum">      17 </span>            : // - http://fileformats.archiveteam.org/wiki/OS/2_BMP
<span class="lineNum">      18 </span>            : // - https://en.wikipedia.org/wiki/BMP_file_format
<span class="lineNum">      19 </span>            : // - https://upload.wikimedia.org/wikipedia/commons/c/c4/BMPfileFormat.png
<span class="lineNum">      20 </span>            : //
<span class="lineNum">      21 </span>            : // WINDOWS VERSIONS OF THE BMP FORMAT
<span class="lineNum">      22 </span>            : // ----------------------------------
<span class="lineNum">      23 </span>            : // WinBMPv1.
<span class="lineNum">      24 </span>            : // - This version is no longer used and can be ignored.
<span class="lineNum">      25 </span>            : //
<span class="lineNum">      26 </span>            : // WinBMPv2.
<span class="lineNum">      27 </span>            : // - First is a 14 byte file header that includes: the magic number (&quot;BM&quot;),
<span class="lineNum">      28 </span>            : //   file size, and offset to the pixel data (|mDataOffset|).
<span class="lineNum">      29 </span>            : // - Next is a 12 byte info header which includes: the info header size
<span class="lineNum">      30 </span>            : //   (mBIHSize), width, height, number of color planes, and bits-per-pixel
<span class="lineNum">      31 </span>            : //   (|mBpp|) which must be 1, 4, 8 or 24.
<span class="lineNum">      32 </span>            : // - Next is the semi-optional color table, which has length 2^|mBpp| and has 3
<span class="lineNum">      33 </span>            : //   bytes per value (BGR). The color table is required if |mBpp| is 1, 4, or 8.
<span class="lineNum">      34 </span>            : // - Next is an optional gap.
<span class="lineNum">      35 </span>            : // - Next is the pixel data, which is pointed to by |mDataOffset|.
<span class="lineNum">      36 </span>            : //
<span class="lineNum">      37 </span>            : // WinBMPv3. This is the most widely used version.
<span class="lineNum">      38 </span>            : // - It changed the info header to 40 bytes by taking the WinBMPv2 info
<span class="lineNum">      39 </span>            : //   header, enlargening its width and height fields, and adding more fields
<span class="lineNum">      40 </span>            : //   including: a compression type (|mCompression|) and number of colors
<span class="lineNum">      41 </span>            : //   (|mNumColors|).
<span class="lineNum">      42 </span>            : // - The semi-optional color table is now 4 bytes per value (BGR0), and its
<span class="lineNum">      43 </span>            : //   length is |mNumColors|, or 2^|mBpp| if |mNumColors| is zero.
<span class="lineNum">      44 </span>            : // - |mCompression| can be RGB (i.e. no compression), RLE4 (if |mBpp|==4) or
<span class="lineNum">      45 </span>            : //   RLE8 (if |mBpp|==8) values.
<span class="lineNum">      46 </span>            : //
<span class="lineNum">      47 </span>            : // WinBMPv3-NT. A variant of WinBMPv3.
<span class="lineNum">      48 </span>            : // - It did not change the info header layout from WinBMPv3.
<span class="lineNum">      49 </span>            : // - |mBpp| can now be 16 or 32, in which case |mCompression| can be RGB or the
<span class="lineNum">      50 </span>            : //   new BITFIELDS value; in the latter case an additional 12 bytes of color
<span class="lineNum">      51 </span>            : //   bitfields follow the info header.
<span class="lineNum">      52 </span>            : //
<span class="lineNum">      53 </span>            : // WinBMPv4.
<span class="lineNum">      54 </span>            : // - It extended the info header to 108 bytes, including the 12 bytes of color
<span class="lineNum">      55 </span>            : //   mask data from WinBMPv3-NT, plus alpha mask data, and also color-space and
<span class="lineNum">      56 </span>            : //   gamma correction fields.
<span class="lineNum">      57 </span>            : //
<span class="lineNum">      58 </span>            : // WinBMPv5.
<span class="lineNum">      59 </span>            : // - It extended the info header to 124 bytes, adding color profile data.
<span class="lineNum">      60 </span>            : // - It also added an optional color profile table after the pixel data (and
<span class="lineNum">      61 </span>            : //   another optional gap).
<span class="lineNum">      62 </span>            : //
<span class="lineNum">      63 </span>            : // WinBMPv3-ICO. This is a variant of WinBMPv3.
<span class="lineNum">      64 </span>            : // - It's the BMP format used for BMP images within ICO files.
<span class="lineNum">      65 </span>            : // - The only difference with WinBMPv3 is that if an image is 32bpp and has no
<span class="lineNum">      66 </span>            : //   compression, then instead of treating the pixel data as 0RGB it is treated
<span class="lineNum">      67 </span>            : //   as ARGB, but only if one or more of the A values are non-zero.
<span class="lineNum">      68 </span>            : //
<span class="lineNum">      69 </span>            : // OS/2 VERSIONS OF THE BMP FORMAT
<span class="lineNum">      70 </span>            : // -------------------------------
<span class="lineNum">      71 </span>            : // OS2-BMPv1.
<span class="lineNum">      72 </span>            : // - Almost identical to WinBMPv2; the differences are basically ignorable.
<span class="lineNum">      73 </span>            : //
<span class="lineNum">      74 </span>            : // OS2-BMPv2.
<span class="lineNum">      75 </span>            : // - Similar to WinBMPv3.
<span class="lineNum">      76 </span>            : // - The info header is 64 bytes but can be reduced to as little as 16; any
<span class="lineNum">      77 </span>            : //   omitted fields are treated as zero. The first 40 bytes of these fields are
<span class="lineNum">      78 </span>            : //   nearly identical to the WinBMPv3 info header; the remaining 24 bytes are
<span class="lineNum">      79 </span>            : //   different.
<span class="lineNum">      80 </span>            : // - Also adds compression types &quot;Huffman 1D&quot; and &quot;RLE24&quot;, which we don't
<span class="lineNum">      81 </span>            : //   support.
<span class="lineNum">      82 </span>            : // - We treat OS2-BMPv2 files as if they are WinBMPv3 (i.e. ignore the extra 24
<span class="lineNum">      83 </span>            : //   bytes in the info header), which in practice is good enough.
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : #include &quot;ImageLogging.h&quot;
<span class="lineNum">      86 </span>            : #include &quot;nsBMPDecoder.h&quot;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      91 </span>            : #include &quot;mozilla/EndianUtils.h&quot;
<span class="lineNum">      92 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : #include &quot;nsIInputStream.h&quot;
<span class="lineNum">      95 </span>            : #include &quot;RasterImage.h&quot;
<span class="lineNum">      96 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : namespace mozilla {
<span class="lineNum">     101 </span>            : namespace image {
<span class="lineNum">     102 </span>            : namespace bmp {
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : struct Compression {
<span class="lineNum">     105 </span>            :   enum {
<span class="lineNum">     106 </span>            :     RGB = 0,
<span class="lineNum">     107 </span>            :     RLE8 = 1,
<span class="lineNum">     108 </span>            :     RLE4 = 2,
<span class="lineNum">     109 </span>            :     BITFIELDS = 3
<span class="lineNum">     110 </span>            :   };
<span class="lineNum">     111 </span>            : };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : // RLE escape codes and constants.
<span class="lineNum">     114 </span>            : struct RLE {
<span class="lineNum">     115 </span>            :   enum {
<span class="lineNum">     116 </span>            :     ESCAPE = 0,
<span class="lineNum">     117 </span>            :     ESCAPE_EOL = 0,
<span class="lineNum">     118 </span>            :     ESCAPE_EOF = 1,
<span class="lineNum">     119 </span>            :     ESCAPE_DELTA = 2,
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :     SEGMENT_LENGTH = 2,
<span class="lineNum">     122 </span>            :     DELTA_LENGTH = 2
<span class="lineNum">     123 </span>            :   };
<span class="lineNum">     124 </span>            : };
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : } // namespace bmp
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : using namespace bmp;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /// Sets the pixel data in aDecoded to the given values.
<span class="lineNum">     131 </span>            : /// @param aDecoded pointer to pixel to be set, will be incremented to point to
<a name="132"><span class="lineNum">     132 </span>            : /// the next pixel.</a>
<span class="lineNum">     133 </span>            : static void
<span class="lineNum">     134 </span><span class="lineNoCov">          0 : SetPixel(uint32_t*&amp; aDecoded, uint8_t aRed, uint8_t aGreen,</span>
<span class="lineNum">     135 </span>            :          uint8_t aBlue, uint8_t aAlpha = 0xFF)
<span class="lineNum">     136 </span>            : {
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   *aDecoded++ = gfxPackedPixel(aAlpha, aRed, aGreen, aBlue);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : }</span>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<span class="lineNum">     140 </span>            : static void
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : SetPixel(uint32_t*&amp; aDecoded, uint8_t idx,</span>
<span class="lineNum">     142 </span>            :          const UniquePtr&lt;ColorTableEntry[]&gt;&amp; aColors)
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   SetPixel(aDecoded,</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :            aColors[idx].mRed, aColors[idx].mGreen, aColors[idx].mBlue);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : /// Sets two (or one if aCount = 1) pixels
<span class="lineNum">     149 </span>            : /// @param aDecoded where the data is stored. Will be moved 4 resp 8 bytes
<span class="lineNum">     150 </span>            : /// depending on whether one or two pixels are written.
<span class="lineNum">     151 </span>            : /// @param aData The values for the two pixels
<a name="152"><span class="lineNum">     152 </span>            : /// @param aCount Current count. Is decremented by one or two.</a>
<span class="lineNum">     153 </span>            : static void
<span class="lineNum">     154 </span><span class="lineNoCov">          0 : Set4BitPixel(uint32_t*&amp; aDecoded, uint8_t aData, uint32_t&amp; aCount,</span>
<span class="lineNum">     155 </span>            :              const UniquePtr&lt;ColorTableEntry[]&gt;&amp; aColors)
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :   uint8_t idx = aData &gt;&gt; 4;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   SetPixel(aDecoded, idx, aColors);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   if (--aCount &gt; 0) {</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     idx = aData &amp; 0xF;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     SetPixel(aDecoded, idx, aColors);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     --aCount;</span>
<span class="lineNum">     163 </span>            :   }
<span class="lineNum">     164 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : static mozilla::LazyLogModule sBMPLog(&quot;BMPDecoder&quot;);
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : // The length of the mBIHSize field in the info header.
<a name="169"><span class="lineNum">     169 </span>            : static const uint32_t BIHSIZE_FIELD_LENGTH = 4;</a>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 : nsBMPDecoder::nsBMPDecoder(RasterImage* aImage, State aState, size_t aLength)</span>
<span class="lineNum">     172 </span>            :   : Decoder(aImage)
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   , mLexer(Transition::To(aState, aLength), Transition::TerminateSuccess())</span>
<span class="lineNum">     174 </span>            :   , mIsWithinICO(false)
<span class="lineNum">     175 </span>            :   , mMayHaveTransparency(false)
<span class="lineNum">     176 </span>            :   , mDoesHaveTransparency(false)
<span class="lineNum">     177 </span>            :   , mNumColors(0)
<span class="lineNum">     178 </span>            :   , mColors(nullptr)
<span class="lineNum">     179 </span>            :   , mBytesPerColor(0)
<span class="lineNum">     180 </span>            :   , mPreGapLength(0)
<span class="lineNum">     181 </span>            :   , mPixelRowSize(0)
<span class="lineNum">     182 </span>            :   , mCurrentRow(0)
<span class="lineNum">     183 </span>            :   , mCurrentPos(0)
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   , mAbsoluteModeNumPixels(0)</span>
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 : }</span>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<span class="lineNum">     188 </span>            : // Constructor for normal BMP files.
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : nsBMPDecoder::nsBMPDecoder(RasterImage* aImage)</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   : nsBMPDecoder(aImage, State::FILE_HEADER, FILE_HEADER_LENGTH)</span>
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineNoCov">          0 : }</span>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<span class="lineNum">     194 </span>            : // Constructor used for WinBMPv3-ICO files, which lack a file header.
<span class="lineNum">     195 </span><span class="lineNoCov">          0 : nsBMPDecoder::nsBMPDecoder(RasterImage* aImage, uint32_t aDataOffset)</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   : nsBMPDecoder(aImage, State::INFO_HEADER_SIZE, BIHSIZE_FIELD_LENGTH)</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   SetIsWithinICO();</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :   // Even though the file header isn't present in this case, the dataOffset
<span class="lineNum">     201 </span>            :   // field is set as if it is, and so we must increment mPreGapLength
<span class="lineNum">     202 </span>            :   // accordingly.
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   mPreGapLength += FILE_HEADER_LENGTH;</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // This is the one piece of data we normally get from a BMP file header, so
<span class="lineNum">     206 </span>            :   // it must be provided via an argument.
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   mH.mDataOffset = aDataOffset;</span>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : nsBMPDecoder::~nsBMPDecoder()</span>
<span class="lineNum">     211 </span>            : {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     213 </span>            : 
<a name="214"><span class="lineNum">     214 </span>            : // Obtains the size of the compressed image resource.</a>
<span class="lineNum">     215 </span>            : int32_t
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : nsBMPDecoder::GetCompressedImageSize() const</span>
<span class="lineNum">     217 </span>            : {
<span class="lineNum">     218 </span>            :   // In the RGB case mImageSize might not be set, so compute it manually.
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mPixelRowSize != 0);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   return mH.mCompression == Compression::RGB</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :        ? mPixelRowSize * AbsoluteHeight()</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :        : mH.mImageSize;</span>
<span class="lineNum">     223 </span>            : }
<a name="224"><span class="lineNum">     224 </span>            : </a>
<span class="lineNum">     225 </span>            : nsresult
<span class="lineNum">     226 </span><span class="lineNoCov">          0 : nsBMPDecoder::BeforeFinishInternal()</span>
<span class="lineNum">     227 </span>            : {
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   if (!IsMetadataDecode() &amp;&amp; !mImageData) {</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     return NS_ERROR_FAILURE;  // No image; something went wrong.</span>
<span class="lineNum">     230 </span>            :   }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     233 </span>            : }
<a name="234"><span class="lineNum">     234 </span>            : </a>
<span class="lineNum">     235 </span>            : nsresult
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : nsBMPDecoder::FinishInternal()</span>
<span class="lineNum">     237 </span>            : {
<span class="lineNum">     238 </span>            :   // We shouldn't be called in error cases.
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!HasError(), &quot;Can't call FinishInternal on error!&quot;);</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   // We should never make multiple frames.
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(GetFrameCount() &lt;= 1, &quot;Multiple BMP frames?&quot;);</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   // Send notifications if appropriate.
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :   if (!IsMetadataDecode() &amp;&amp; HasSize()) {</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :     // We should have image data.
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mImageData);</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :     // If it was truncated, fill in the missing pixels as black.
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     while (mCurrentRow &gt; 0) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       uint32_t* dst = RowBuffer();</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       while (mCurrentPos &lt; mH.mWidth) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         SetPixel(dst, 0, 0, 0);</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         mCurrentPos++;</span>
<span class="lineNum">     256 </span>            :       }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       mCurrentPos = 0;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :       FinishRow();</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :     // Invalidate.
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     nsIntRect r(0, 0, mH.mWidth, AbsoluteHeight());</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     PostInvalidation(r);</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     MOZ_ASSERT_IF(mDoesHaveTransparency, mMayHaveTransparency);</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :     // We have transparency if we either detected some in the image itself
<span class="lineNum">     268 </span>            :     // (i.e., |mDoesHaveTransparency| is true) or we're in an ICO, which could
<span class="lineNum">     269 </span>            :     // mean we have an AND mask that provides transparency (i.e., |mIsWithinICO|
<span class="lineNum">     270 </span>            :     // is true).
<span class="lineNum">     271 </span>            :     // XXX(seth): We can tell when we create the decoder if the AND mask is
<span class="lineNum">     272 </span>            :     // present, so we could be more precise about this.
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     const Opacity opacity = mDoesHaveTransparency || mIsWithinICO</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                           ? Opacity::SOME_TRANSPARENCY</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                           : Opacity::FULLY_OPAQUE;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     PostFrameStop(opacity);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     PostDecodeDone();</span>
<span class="lineNum">     279 </span>            :   }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     282 </span>            : }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : // ----------------------------------------
<span class="lineNum">     285 </span>            : // Actual Data Processing
<span class="lineNum">     286 </span>            : // ----------------------------------------
<a name="287"><span class="lineNum">     287 </span>            : </a>
<span class="lineNum">     288 </span>            : void
<span class="lineNum">     289 </span><span class="lineNoCov">          0 : BitFields::Value::Set(uint32_t aMask)</span>
<span class="lineNum">     290 </span>            : {
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   mMask = aMask;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   // Handle this exceptional case first. The chosen values don't matter
<span class="lineNum">     294 </span>            :   // (because a mask of zero will always give a value of zero) except that
<span class="lineNum">     295 </span>            :   // mBitWidth:
<span class="lineNum">     296 </span>            :   // - shouldn't be zero, because that would cause an infinite loop in Get();
<span class="lineNum">     297 </span>            :   // - shouldn't be 5 or 8, because that could cause a false positive match in
<span class="lineNum">     298 </span>            :   //   IsR5G5B5() or IsR8G8B8().
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :   if (mMask == 0x0) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     mRightShift = 0;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     mBitWidth = 1;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     303 </span>            :   }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   // Find the rightmost 1.
<span class="lineNum">     306 </span>            :   uint8_t i;
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 32; i++) {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     if (mMask &amp; (1 &lt;&lt; i)) {</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     310 </span>            :     }
<span class="lineNum">     311 </span>            :   }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :   mRightShift = i;</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :   // Now find the leftmost 1 in the same run of 1s. (If there are multiple runs
<span class="lineNum">     315 </span>            :   // of 1s -- which isn't valid -- we'll behave as if only the lowest run was
<span class="lineNum">     316 </span>            :   // present, which seems reasonable.)
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   for (i = i + 1; i &lt; 32; i++) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (!(mMask &amp; (1 &lt;&lt; i))) {</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     320 </span>            :     }
<span class="lineNum">     321 </span>            :   }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   mBitWidth = i - mRightShift;</span>
<span class="lineNum">     323 </span>            : }
<a name="324"><span class="lineNum">     324 </span>            : </a>
<span class="lineNum">     325 </span>            : MOZ_ALWAYS_INLINE uint8_t
<span class="lineNum">     326 </span><span class="lineNoCov">          0 : BitFields::Value::Get(uint32_t aValue) const</span>
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span>            :   // Extract the unscaled value.
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   uint32_t v = (aValue &amp; mMask) &gt;&gt; mRightShift;</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :   // Idea: to upscale v precisely we need to duplicate its bits, possibly
<span class="lineNum">     332 </span>            :   // repeatedly, possibly partially in the last case, from bit 7 down to bit 0
<span class="lineNum">     333 </span>            :   // in v2. For example:
<span class="lineNum">     334 </span>            :   //
<span class="lineNum">     335 </span>            :   // - mBitWidth=1:  v2 = v&lt;&lt;7 | v&lt;&lt;6 | ... | v&lt;&lt;1 | v&gt;&gt;0     k -&gt; kkkkkkkk
<span class="lineNum">     336 </span>            :   // - mBitWidth=2:  v2 = v&lt;&lt;6 | v&lt;&lt;4 | v&lt;&lt;2 | v&gt;&gt;0          jk -&gt; jkjkjkjk
<span class="lineNum">     337 </span>            :   // - mBitWidth=3:  v2 = v&lt;&lt;5 | v&lt;&lt;2 | v&gt;&gt;1                ijk -&gt; ijkijkij
<span class="lineNum">     338 </span>            :   // - mBitWidth=4:  v2 = v&lt;&lt;4 | v&gt;&gt;0                      hijk -&gt; hijkhijk
<span class="lineNum">     339 </span>            :   // - mBitWidth=5:  v2 = v&lt;&lt;3 | v&gt;&gt;2                     ghijk -&gt; ghijkghi
<span class="lineNum">     340 </span>            :   // - mBitWidth=6:  v2 = v&lt;&lt;2 | v&gt;&gt;4                    fghijk -&gt; fghijkfg
<span class="lineNum">     341 </span>            :   // - mBitWidth=7:  v2 = v&lt;&lt;1 | v&gt;&gt;6                   efghijk -&gt; efghijke
<span class="lineNum">     342 </span>            :   // - mBitWidth=8:  v2 = v&gt;&gt;0                         defghijk -&gt; defghijk
<span class="lineNum">     343 </span>            :   // - mBitWidth=9:  v2 = v&gt;&gt;1                        cdefghijk -&gt; cdefghij
<span class="lineNum">     344 </span>            :   // - mBitWidth=10: v2 = v&gt;&gt;2                       bcdefghijk -&gt; bcdefghi
<span class="lineNum">     345 </span>            :   // - mBitWidth=11: v2 = v&gt;&gt;3                      abcdefghijk -&gt; abcdefgh
<span class="lineNum">     346 </span>            :   // - etc.
<span class="lineNum">     347 </span>            :   //
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   uint8_t v2 = 0;</span>
<span class="lineNum">     349 </span>            :   int32_t i;      // must be a signed integer
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   for (i = 8 - mBitWidth; i &gt; 0; i -= mBitWidth) {</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     v2 |= v &lt;&lt; uint32_t(i);</span>
<span class="lineNum">     352 </span>            :   }
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   v2 |= v &gt;&gt; uint32_t(-i);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :   return v2;</span>
<span class="lineNum">     355 </span>            : }
<a name="356"><span class="lineNum">     356 </span>            : </a>
<span class="lineNum">     357 </span>            : MOZ_ALWAYS_INLINE uint8_t
<span class="lineNum">     358 </span><span class="lineNoCov">          0 : BitFields::Value::GetAlpha(uint32_t aValue, bool&amp; aHasAlphaOut) const</span>
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   if (mMask == 0x0) {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     return 0xff;</span>
<span class="lineNum">     362 </span>            :   }
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   aHasAlphaOut = true;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   return Get(aValue);</span>
<span class="lineNum">     365 </span>            : }
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : MOZ_ALWAYS_INLINE uint8_t
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : BitFields::Value::Get5(uint32_t aValue) const</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mBitWidth == 5);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   uint32_t v = (aValue &amp; mMask) &gt;&gt; mRightShift;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   return (v &lt;&lt; 3u) | (v &gt;&gt; 2u);</span>
<span class="lineNum">     373 </span>            : }
<a name="374"><span class="lineNum">     374 </span>            : </a>
<span class="lineNum">     375 </span>            : MOZ_ALWAYS_INLINE uint8_t
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : BitFields::Value::Get8(uint32_t aValue) const</span>
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mBitWidth == 8);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   uint32_t v = (aValue &amp; mMask) &gt;&gt; mRightShift;</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   return v;</span>
<span class="lineNum">     381 </span>            : }
<a name="382"><span class="lineNum">     382 </span>            : </a>
<span class="lineNum">     383 </span>            : void
<span class="lineNum">     384 </span><span class="lineNoCov">          0 : BitFields::SetR5G5B5()</span>
<span class="lineNum">     385 </span>            : {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   mRed.Set(0x7c00);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   mGreen.Set(0x03e0);</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   mBlue.Set(0x001f);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 : }</span>
<a name="390"><span class="lineNum">     390 </span>            : </a>
<span class="lineNum">     391 </span>            : void
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : BitFields::SetR8G8B8()</span>
<span class="lineNum">     393 </span>            : {
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   mRed.Set(0xff0000);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   mGreen.Set(0xff00);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   mBlue.Set(0x00ff);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 : }</span>
<a name="398"><span class="lineNum">     398 </span>            : </a>
<span class="lineNum">     399 </span>            : bool
<span class="lineNum">     400 </span><span class="lineNoCov">          0 : BitFields::IsR5G5B5() const</span>
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   return mRed.mBitWidth == 5 &amp;&amp;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :          mGreen.mBitWidth == 5 &amp;&amp;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :          mBlue.mBitWidth == 5 &amp;&amp;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :          mAlpha.mMask == 0x0;</span>
<span class="lineNum">     406 </span>            : }
<a name="407"><span class="lineNum">     407 </span>            : </a>
<span class="lineNum">     408 </span>            : bool
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : BitFields::IsR8G8B8() const</span>
<span class="lineNum">     410 </span>            : {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   return mRed.mBitWidth == 8 &amp;&amp;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :          mGreen.mBitWidth == 8 &amp;&amp;</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :          mBlue.mBitWidth == 8 &amp;&amp;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :          mAlpha.mMask == 0x0;</span>
<span class="lineNum">     415 </span>            : }
<a name="416"><span class="lineNum">     416 </span>            : </a>
<span class="lineNum">     417 </span>            : uint32_t*
<span class="lineNum">     418 </span><span class="lineNoCov">          0 : nsBMPDecoder::RowBuffer()</span>
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   if (mDownscaler) {</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;uint32_t*&gt;(mDownscaler-&gt;RowBuffer()) + mCurrentPos;</span>
<span class="lineNum">     422 </span>            :   }
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :   // Convert from row (1..mHeight) to absolute line (0..mHeight-1).
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :   int32_t line = (mH.mHeight &lt; 0)</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :                ? -mH.mHeight - mCurrentRow</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :                : mCurrentRow - 1;</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   int32_t offset = line * mH.mWidth + mCurrentPos;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   return reinterpret_cast&lt;uint32_t*&gt;(mImageData) + offset;</span>
<span class="lineNum">     430 </span>            : }
<a name="431"><span class="lineNum">     431 </span>            : </a>
<span class="lineNum">     432 </span>            : void
<span class="lineNum">     433 </span><span class="lineNoCov">          0 : nsBMPDecoder::FinishRow()</span>
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   if (mDownscaler) {</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     mDownscaler-&gt;CommitRow();</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     if (mDownscaler-&gt;HasInvalidation()) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       DownscalerInvalidRect invalidRect = mDownscaler-&gt;TakeInvalidRect();</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :       PostInvalidation(invalidRect.mOriginalSizeRect,</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                        Some(invalidRect.mTargetSizeRect));</span>
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span>            :   } else {
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     PostInvalidation(IntRect(0, mCurrentRow, mH.mWidth, 1));</span>
<span class="lineNum">     445 </span>            :   }
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   mCurrentRow--;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 : }</span>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : LexerResult
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : nsBMPDecoder::DoDecode(SourceBufferIterator&amp; aIterator, IResumable* aOnResume)</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!HasError(), &quot;Shouldn't call DoDecode after error!&quot;);</span>
<a name="453"><span class="lineNum">     453 </span>            : </a>
<span class="lineNum">     454 </span>            :   return mLexer.Lex(aIterator, aOnResume,
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                     [=](State aState, const char* aData, size_t aLength) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     switch (aState) {</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       case State::FILE_HEADER:      return ReadFileHeader(aData, aLength);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       case State::INFO_HEADER_SIZE: return ReadInfoHeaderSize(aData, aLength);</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       case State::INFO_HEADER_REST: return ReadInfoHeaderRest(aData, aLength);</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       case State::BITFIELDS:        return ReadBitfields(aData, aLength);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       case State::COLOR_TABLE:      return ReadColorTable(aData, aLength);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       case State::GAP:              return SkipGap();</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       case State::AFTER_GAP:        return AfterGap();</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       case State::PIXEL_ROW:        return ReadPixelRow(aData);</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :       case State::RLE_SEGMENT:      return ReadRLESegment(aData);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       case State::RLE_DELTA:        return ReadRLEDelta(aData);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       case State::RLE_ABSOLUTE:     return ReadRLEAbsolute(aData, aLength);</span>
<span class="lineNum">     468 </span>            :       default:
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;Unknown State&quot;);</span>
<span class="lineNum">     470 </span>            :     }
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   });</span>
<span class="lineNum">     472 </span>            : }
<a name="473"><span class="lineNum">     473 </span>            : </a>
<span class="lineNum">     474 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadFileHeader(const char* aData, size_t aLength)</span>
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   mPreGapLength += aLength;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   bool signatureOk = aData[0] == 'B' &amp;&amp; aData[1] == 'M';</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   if (!signatureOk) {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     482 </span>            :   }
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   // We ignore the filesize (aData + 2) and reserved (aData + 6) fields.
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   mH.mDataOffset = LittleEndian::readUint32(aData + 10);</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   return Transition::To(State::INFO_HEADER_SIZE, BIHSIZE_FIELD_LENGTH);</span>
<span class="lineNum">     489 </span>            : }
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : // We read the info header in two steps: (a) read the mBIHSize field to
<a name="492"><span class="lineNum">     492 </span>            : // determine how long the header is; (b) read the rest of the header.</a>
<span class="lineNum">     493 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     494 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadInfoHeaderSize(const char* aData, size_t aLength)</span>
<span class="lineNum">     495 </span>            : {
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   mPreGapLength += aLength;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   mH.mBIHSize = LittleEndian::readUint32(aData);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   bool bihSizeOk = mH.mBIHSize == InfoHeaderLength::WIN_V2 ||</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                    mH.mBIHSize == InfoHeaderLength::WIN_V3 ||</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                    mH.mBIHSize == InfoHeaderLength::WIN_V4 ||</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                    mH.mBIHSize == InfoHeaderLength::WIN_V5 ||</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                    (mH.mBIHSize &gt;= InfoHeaderLength::OS2_V2_MIN &amp;&amp;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                     mH.mBIHSize &lt;= InfoHeaderLength::OS2_V2_MAX);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   if (!bihSizeOk) {</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     508 </span>            :   }
<span class="lineNum">     509 </span>            :   // ICO BMPs must have a WinBMPv3 header. nsICODecoder should have already
<span class="lineNum">     510 </span>            :   // terminated decoding if this isn't the case.
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   MOZ_ASSERT_IF(mIsWithinICO, mH.mBIHSize == InfoHeaderLength::WIN_V3);</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :   return Transition::To(State::INFO_HEADER_REST,
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                         mH.mBIHSize - BIHSIZE_FIELD_LENGTH);</span>
<span class="lineNum">     515 </span>            : }
<a name="516"><span class="lineNum">     516 </span>            : </a>
<span class="lineNum">     517 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadInfoHeaderRest(const char* aData, size_t aLength)</span>
<span class="lineNum">     519 </span>            : {
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   mPreGapLength += aLength;</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   // |mWidth| and |mHeight| may be signed (Windows) or unsigned (OS/2). We just
<span class="lineNum">     523 </span>            :   // read as unsigned because in practice that's good enough.
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   if (mH.mBIHSize == InfoHeaderLength::WIN_V2) {</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     mH.mWidth  = LittleEndian::readUint16(aData + 0);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     mH.mHeight = LittleEndian::readUint16(aData + 2);</span>
<span class="lineNum">     527 </span>            :     // We ignore the planes (aData + 4) field; it should always be 1.
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     mH.mBpp    = LittleEndian::readUint16(aData + 6);</span>
<span class="lineNum">     529 </span>            :   } else {
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     mH.mWidth  = LittleEndian::readUint32(aData + 0);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     mH.mHeight = LittleEndian::readUint32(aData + 4);</span>
<span class="lineNum">     532 </span>            :     // We ignore the planes (aData + 4) field; it should always be 1.
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     mH.mBpp    = LittleEndian::readUint16(aData + 10);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :     // For OS2-BMPv2 the info header may be as little as 16 bytes, so be
<span class="lineNum">     536 </span>            :     // careful for these fields.
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     mH.mCompression = aLength &gt;= 16 ? LittleEndian::readUint32(aData + 12) : 0;</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     mH.mImageSize   = aLength &gt;= 20 ? LittleEndian::readUint32(aData + 16) : 0;</span>
<span class="lineNum">     539 </span>            :     // We ignore the xppm (aData + 20) and yppm (aData + 24) fields.
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     mH.mNumColors   = aLength &gt;= 32 ? LittleEndian::readUint32(aData + 28) : 0;</span>
<span class="lineNum">     541 </span>            :     // We ignore the important_colors (aData + 36) field.
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :     // For WinBMPv4, WinBMPv5 and (possibly) OS2-BMPv2 there are additional
<span class="lineNum">     544 </span>            :     // fields in the info header which we ignore, with the possible exception
<span class="lineNum">     545 </span>            :     // of the color bitfields (see below).
<span class="lineNum">     546 </span>            :   }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :   // Run with MOZ_LOG=BMPDecoder:5 set to see this output.
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   MOZ_LOG(sBMPLog, LogLevel::Debug,</span>
<span class="lineNum">     550 </span>            :           (&quot;BMP: bihsize=%u, %d x %d, bpp=%u, compression=%u, colors=%u\n&quot;,
<span class="lineNum">     551 </span>            :           mH.mBIHSize, mH.mWidth, mH.mHeight, uint32_t(mH.mBpp),
<span class="lineNum">     552 </span>            :           mH.mCompression, mH.mNumColors));
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   // BMPs with negative width are invalid. Also, reject extremely wide images
<span class="lineNum">     555 </span>            :   // to keep the math sane. And reject INT_MIN as a height because you can't
<span class="lineNum">     556 </span>            :   // get its absolute value (because -INT_MIN is one more than INT_MAX).
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :   const int32_t k64KWidth = 0x0000FFFF;</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   bool sizeOk = 0 &lt;= mH.mWidth &amp;&amp; mH.mWidth &lt;= k64KWidth &amp;&amp;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                 mH.mHeight != INT_MIN;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   if (!sizeOk) {</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     562 </span>            :   }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :   // Check mBpp and mCompression.
<span class="lineNum">     565 </span>            :   bool bppCompressionOk =
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     (mH.mCompression == Compression::RGB &amp;&amp;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :       (mH.mBpp ==  1 || mH.mBpp ==  4 || mH.mBpp ==  8 ||</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :        mH.mBpp == 16 || mH.mBpp == 24 || mH.mBpp == 32)) ||</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     (mH.mCompression == Compression::RLE8 &amp;&amp; mH.mBpp == 8) ||</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     (mH.mCompression == Compression::RLE4 &amp;&amp; mH.mBpp == 4) ||</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     (mH.mCompression == Compression::BITFIELDS &amp;&amp;</span>
<span class="lineNum">     572 </span>            :       // For BITFIELDS compression we require an exact match for one of the
<span class="lineNum">     573 </span>            :       // WinBMP BIH sizes; this clearly isn't an OS2 BMP.
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :       (mH.mBIHSize == InfoHeaderLength::WIN_V3 ||</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :        mH.mBIHSize == InfoHeaderLength::WIN_V4 ||</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :        mH.mBIHSize == InfoHeaderLength::WIN_V5) &amp;&amp;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       (mH.mBpp == 16 || mH.mBpp == 32));</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   if (!bppCompressionOk) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     580 </span>            :   }
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :   // Initialize our current row to the top of the image.
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   mCurrentRow = AbsoluteHeight();</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   // Round it up to the nearest byte count, then pad to 4-byte boundary.
<span class="lineNum">     586 </span>            :   // Compute this even for a metadate decode because GetCompressedImageSize()
<span class="lineNum">     587 </span>            :   // relies on it.
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   mPixelRowSize = (mH.mBpp * mH.mWidth + 7) / 8;</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   uint32_t surplus = mPixelRowSize % 4;</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   if (surplus != 0) {</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     mPixelRowSize += 4 - surplus;</span>
<span class="lineNum">     592 </span>            :   }
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   size_t bitFieldsLengthStillToRead = 0;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   if (mH.mCompression == Compression::BITFIELDS) {</span>
<span class="lineNum">     596 </span>            :     // Need to read bitfields.
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     if (mH.mBIHSize &gt;= InfoHeaderLength::WIN_V4) {</span>
<span class="lineNum">     598 </span>            :       // Bitfields are present in the info header, so we can read them
<span class="lineNum">     599 </span>            :       // immediately.
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       mBitFields.ReadFromHeader(aData + 36, /* aReadAlpha = */ true);</span>
<span class="lineNum">     601 </span>            :     } else {
<span class="lineNum">     602 </span>            :       // Bitfields are present after the info header, so we will read them in
<span class="lineNum">     603 </span>            :       // ReadBitfields().
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       bitFieldsLengthStillToRead = BitFields::LENGTH;</span>
<span class="lineNum">     605 </span>            :     }
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   } else if (mH.mBpp == 16) {</span>
<span class="lineNum">     607 </span>            :     // No bitfields specified; use the default 5-5-5 values.
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     mBitFields.SetR5G5B5();</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   } else if (mH.mBpp == 32) {</span>
<span class="lineNum">     610 </span>            :     // No bitfields specified; use the default 8-8-8 values.
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     mBitFields.SetR8G8B8();</span>
<span class="lineNum">     612 </span>            :   }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   return Transition::To(State::BITFIELDS, bitFieldsLengthStillToRead);</span>
<span class="lineNum">     615 </span>            : }
<a name="616"><span class="lineNum">     616 </span>            : </a>
<span class="lineNum">     617 </span>            : void
<span class="lineNum">     618 </span><span class="lineNoCov">          0 : BitFields::ReadFromHeader(const char* aData, bool aReadAlpha)</span>
<span class="lineNum">     619 </span>            : {
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   mRed.Set  (LittleEndian::readUint32(aData + 0));</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   mGreen.Set(LittleEndian::readUint32(aData + 4));</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   mBlue.Set (LittleEndian::readUint32(aData + 8));</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   if (aReadAlpha) {</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     mAlpha.Set(LittleEndian::readUint32(aData + 12));</span>
<span class="lineNum">     625 </span>            :   }
<span class="lineNum">     626 </span><span class="lineNoCov">          0 : }</span>
<a name="627"><span class="lineNum">     627 </span>            : </a>
<span class="lineNum">     628 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     629 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadBitfields(const char* aData, size_t aLength)</span>
<span class="lineNum">     630 </span>            : {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   mPreGapLength += aLength;</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :   // If aLength is zero there are no bitfields to read, or we already read them
<span class="lineNum">     634 </span>            :   // in ReadInfoHeader().
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   if (aLength != 0) {</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     mBitFields.ReadFromHeader(aData, /* aReadAlpha = */ false);</span>
<span class="lineNum">     637 </span>            :   }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :   // Note that RLE-encoded BMPs might be transparent because the 'delta' mode
<span class="lineNum">     640 </span>            :   // can skip pixels and cause implicit transparency.
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   mMayHaveTransparency =</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     mIsWithinICO ||</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     mH.mCompression == Compression::RLE8 ||</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     mH.mCompression == Compression::RLE4 ||</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     (mH.mCompression == Compression::BITFIELDS &amp;&amp;</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :      mBitFields.mAlpha.IsPresent());</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :   if (mMayHaveTransparency) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     PostHasTransparency();</span>
<span class="lineNum">     649 </span>            :   }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :   // Post our size to the superclass.
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   PostSize(mH.mWidth, AbsoluteHeight());</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            :   // We've now read all the headers. If we're doing a metadata decode, we're
<span class="lineNum">     655 </span>            :   // done.
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   if (IsMetadataDecode()) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     return Transition::TerminateSuccess();</span>
<span class="lineNum">     658 </span>            :   }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :   // Set up the color table, if present; it'll be filled in by ReadColorTable().
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :   if (mH.mBpp &lt;= 8) {</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     mNumColors = 1 &lt;&lt; mH.mBpp;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     if (0 &lt; mH.mNumColors &amp;&amp; mH.mNumColors &lt; mNumColors) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       mNumColors = mH.mNumColors;</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :     // Always allocate and zero 256 entries, even though mNumColors might be
<span class="lineNum">     668 </span>            :     // smaller, because the file might erroneously index past mNumColors.
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     mColors = MakeUnique&lt;ColorTableEntry[]&gt;(256);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     memset(mColors.get(), 0, 256 * sizeof(ColorTableEntry));</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :     // OS/2 Bitmaps have no padding byte.
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     mBytesPerColor = (mH.mBIHSize == InfoHeaderLength::WIN_V2) ? 3 : 4;</span>
<span class="lineNum">     674 </span>            :   }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(!mImageData, &quot;Already have a buffer allocated?&quot;);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   nsresult rv = AllocateFrame(/* aFrameNum = */ 0, OutputSize(),</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                               FullOutputFrame(),</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :                               mMayHaveTransparency ? SurfaceFormat::B8G8R8A8</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :                                                    : SurfaceFormat::B8G8R8X8);</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv)) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     683 </span>            :   }
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mImageData, &quot;Should have a buffer now&quot;);</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   if (mDownscaler) {</span>
<span class="lineNum">     687 </span>            :     // BMPs store their rows in reverse order, so the downscaler needs to
<span class="lineNum">     688 </span>            :     // reverse them again when writing its output. Unless the height is
<span class="lineNum">     689 </span>            :     // negative!
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     rv = mDownscaler-&gt;BeginFrame(Size(), Nothing(),</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :                                  mImageData, mMayHaveTransparency,</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :                                  /* aFlipVertically = */ mH.mHeight &gt;= 0);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     if (NS_FAILED(rv)) {</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       return Transition::TerminateFailure();</span>
<span class="lineNum">     695 </span>            :     }
<span class="lineNum">     696 </span>            :   }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   return Transition::To(State::COLOR_TABLE, mNumColors * mBytesPerColor);</span>
<span class="lineNum">     699 </span>            : }
<a name="700"><span class="lineNum">     700 </span>            : </a>
<span class="lineNum">     701 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     702 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadColorTable(const char* aData, size_t aLength)</span>
<span class="lineNum">     703 </span>            : {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   MOZ_ASSERT_IF(aLength != 0, mNumColors &gt; 0 &amp;&amp; mColors);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :   mPreGapLength += aLength;</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mNumColors; i++) {</span>
<span class="lineNum">     709 </span>            :     // The format is BGR or BGR0.
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :     mColors[i].mBlue  = uint8_t(aData[0]);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     mColors[i].mGreen = uint8_t(aData[1]);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :     mColors[i].mRed   = uint8_t(aData[2]);</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     aData += mBytesPerColor;</span>
<span class="lineNum">     714 </span>            :   }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :   // We know how many bytes we've read so far (mPreGapLength) and we know the
<span class="lineNum">     717 </span>            :   // offset of the pixel data (mH.mDataOffset), so we can determine the length
<span class="lineNum">     718 </span>            :   // of the gap (possibly zero) between the color table and the pixel data.
<span class="lineNum">     719 </span>            :   //
<span class="lineNum">     720 </span>            :   // If the gap is negative the file must be malformed (e.g. mH.mDataOffset
<span class="lineNum">     721 </span>            :   // points into the middle of the color palette instead of past the end) and
<span class="lineNum">     722 </span>            :   // we give up.
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   if (mPreGapLength &gt; mH.mDataOffset) {</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     return Transition::TerminateFailure();</span>
<span class="lineNum">     725 </span>            :   }
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   uint32_t gapLength = mH.mDataOffset - mPreGapLength;</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   return Transition::ToUnbuffered(State::AFTER_GAP, State::GAP, gapLength);</span>
<span class="lineNum">     729 </span>            : }
<a name="730"><span class="lineNum">     730 </span>            : </a>
<span class="lineNum">     731 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     732 </span><span class="lineNoCov">          0 : nsBMPDecoder::SkipGap()</span>
<span class="lineNum">     733 </span>            : {
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :   return Transition::ContinueUnbuffered(State::GAP);</span>
<span class="lineNum">     735 </span>            : }
<a name="736"><span class="lineNum">     736 </span>            : </a>
<span class="lineNum">     737 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     738 </span><span class="lineNoCov">          0 : nsBMPDecoder::AfterGap()</span>
<span class="lineNum">     739 </span>            : {
<span class="lineNum">     740 </span>            :   // If there are no pixels we can stop.
<span class="lineNum">     741 </span>            :   //
<span class="lineNum">     742 </span>            :   // XXX: normally, if there are no pixels we will have stopped decoding before
<span class="lineNum">     743 </span>            :   // now, outside of this decoder. However, if the BMP is within an ICO file,
<span class="lineNum">     744 </span>            :   // it's possible that the ICO claimed the image had a non-zero size while the
<span class="lineNum">     745 </span>            :   // BMP claims otherwise. This test is to catch that awkward case. If we ever
<span class="lineNum">     746 </span>            :   // come up with a more general solution to this ICO-and-BMP-disagree-on-size
<span class="lineNum">     747 </span>            :   // problem, this test can be removed.
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   if (mH.mWidth == 0 || mH.mHeight == 0) {</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     return Transition::TerminateSuccess();</span>
<span class="lineNum">     750 </span>            :   }
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   bool hasRLE = mH.mCompression == Compression::RLE8 ||</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                 mH.mCompression == Compression::RLE4;</span>
<span class="lineNum">     754 </span>            :   return hasRLE
<span class="lineNum">     755 </span>            :        ? Transition::To(State::RLE_SEGMENT, RLE::SEGMENT_LENGTH)
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :        : Transition::To(State::PIXEL_ROW, mPixelRowSize);</span>
<span class="lineNum">     757 </span>            : }
<a name="758"><span class="lineNum">     758 </span>            : </a>
<span class="lineNum">     759 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     760 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadPixelRow(const char* aData)</span>
<span class="lineNum">     761 </span>            : {
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mCurrentRow &gt; 0);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mCurrentPos == 0);</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   const uint8_t* src = reinterpret_cast&lt;const uint8_t*&gt;(aData);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   uint32_t* dst = RowBuffer();</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   uint32_t lpos = mH.mWidth;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   switch (mH.mBpp) {</span>
<span class="lineNum">     769 </span>            :     case 1:
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :       while (lpos &gt; 0) {</span>
<span class="lineNum">     771 </span>            :         int8_t bit;
<span class="lineNum">     772 </span>            :         uint8_t idx;
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :         for (bit = 7; bit &gt;= 0 &amp;&amp; lpos &gt; 0; bit--) {</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :           idx = (*src &gt;&gt; bit) &amp; 1;</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :           SetPixel(dst, idx, mColors);</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     777 </span>            :         }
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         ++src;</span>
<span class="lineNum">     779 </span>            :       }
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            :     case 4:
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       while (lpos &gt; 0) {</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :         Set4BitPixel(dst, *src, lpos, mColors);</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         ++src;</span>
<span class="lineNum">     786 </span>            :       }
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :     case 8:
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       while (lpos &gt; 0) {</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         SetPixel(dst, *src, mColors);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         --lpos;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         ++src;</span>
<span class="lineNum">     794 </span>            :       }
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     case 16:
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :       if (mBitFields.IsR5G5B5()) {</span>
<span class="lineNum">     799 </span>            :         // Specialize this common case.
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         while (lpos &gt; 0) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :           uint16_t val = LittleEndian::readUint16(src);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :           SetPixel(dst, mBitFields.mRed.Get5(val),</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                         mBitFields.mGreen.Get5(val),</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                         mBitFields.mBlue.Get5(val));</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :           src += 2;</span>
<span class="lineNum">     807 </span>            :         }
<span class="lineNum">     808 </span>            :       } else {
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         bool anyHasAlpha = false;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         while (lpos &gt; 0) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :           uint16_t val = LittleEndian::readUint16(src);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :           SetPixel(dst, mBitFields.mRed.Get(val),</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :                         mBitFields.mGreen.Get(val),</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :                         mBitFields.mBlue.Get(val),</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                         mBitFields.mAlpha.GetAlpha(val, anyHasAlpha));</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :           src += 2;</span>
<span class="lineNum">     818 </span>            :         }
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :         if (anyHasAlpha) {</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(mMayHaveTransparency);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :           mDoesHaveTransparency = true;</span>
<span class="lineNum">     822 </span>            :         }
<span class="lineNum">     823 </span>            :       }
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :     case 24:
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       while (lpos &gt; 0) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         SetPixel(dst, src[2], src[1], src[0]);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :         --lpos;</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         src += 3;</span>
<span class="lineNum">     831 </span>            :       }
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     case 32:
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :       if (mH.mCompression == Compression::RGB &amp;&amp; mIsWithinICO &amp;&amp;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :           mH.mBpp == 32) {</span>
<span class="lineNum">     837 </span>            :         // This is a special case only used for 32bpp WinBMPv3-ICO files, which
<span class="lineNum">     838 </span>            :         // could be in either 0RGB or ARGB format. We start by assuming it's
<span class="lineNum">     839 </span>            :         // an 0RGB image. If we hit a non-zero alpha value, then we know it's
<span class="lineNum">     840 </span>            :         // actually an ARGB image, and change tack accordingly.
<span class="lineNum">     841 </span>            :         // (Note: a fully-transparent ARGB image is indistinguishable from a
<span class="lineNum">     842 </span>            :         // 0RGB image, and we will render such an image as a 0RGB image, i.e.
<span class="lineNum">     843 </span>            :         // opaquely. This is unlikely to be a problem in practice.)
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         while (lpos &gt; 0) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :           if (!mDoesHaveTransparency &amp;&amp; src[3] != 0) {</span>
<span class="lineNum">     846 </span>            :             // Up until now this looked like an 0RGB image, but we now know
<span class="lineNum">     847 </span>            :             // it's actually an ARGB image. Which means every pixel we've seen
<span class="lineNum">     848 </span>            :             // so far has been fully transparent. So we go back and redo them.
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :             // Tell the Downscaler to go back to the start.
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :             if (mDownscaler) {</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :               mDownscaler-&gt;ResetForNextProgressivePass();</span>
<span class="lineNum">     853 </span>            :             }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :             // Redo the complete rows we've already done.
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(mCurrentPos == 0);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :             int32_t currentRow = mCurrentRow;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :             mCurrentRow = AbsoluteHeight();</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :             while (mCurrentRow &gt; currentRow) {</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :               dst = RowBuffer();</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :               for (int32_t i = 0; i &lt; mH.mWidth; i++) {</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                 SetPixel(dst, 0, 0, 0, 0);</span>
<span class="lineNum">     863 </span>            :               }
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :               FinishRow();</span>
<span class="lineNum">     865 </span>            :             }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :             // Redo the part of this row we've already done.
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :             dst = RowBuffer();</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :             int32_t n = mH.mWidth - lpos;</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :             for (int32_t i = 0; i &lt; n; i++) {</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :               SetPixel(dst, 0, 0, 0, 0);</span>
<span class="lineNum">     872 </span>            :             }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(mMayHaveTransparency);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :             mDoesHaveTransparency = true;</span>
<span class="lineNum">     876 </span>            :           }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :           // If mDoesHaveTransparency is false, treat this as an 0RGB image.
<span class="lineNum">     879 </span>            :           // Otherwise, treat this as an ARGB image.
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :           SetPixel(dst, src[2], src[1], src[0],</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                    mDoesHaveTransparency ? src[3] : 0xff);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :           src += 4;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       } else if (mBitFields.IsR8G8B8()) {</span>
<span class="lineNum">     886 </span>            :         // Specialize this common case.
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         while (lpos &gt; 0) {</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           uint32_t val = LittleEndian::readUint32(src);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           SetPixel(dst, mBitFields.mRed.Get8(val),</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :                         mBitFields.mGreen.Get8(val),</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :                         mBitFields.mBlue.Get8(val));</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :           src += 4;</span>
<span class="lineNum">     894 </span>            :         }
<span class="lineNum">     895 </span>            :       } else {
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         bool anyHasAlpha = false;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         while (lpos &gt; 0) {</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :           uint32_t val = LittleEndian::readUint32(src);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :           SetPixel(dst, mBitFields.mRed.Get(val),</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                         mBitFields.mGreen.Get(val),</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :                         mBitFields.mBlue.Get(val),</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                         mBitFields.mAlpha.GetAlpha(val, anyHasAlpha));</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :           --lpos;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :           src += 4;</span>
<span class="lineNum">     905 </span>            :         }
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :         if (anyHasAlpha) {</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :           MOZ_ASSERT(mMayHaveTransparency);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :           mDoesHaveTransparency = true;</span>
<span class="lineNum">     909 </span>            :         }
<span class="lineNum">     910 </span>            :       }
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     default:
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;Unsupported color depth; earlier check didn't catch it?&quot;);</span>
<span class="lineNum">     915 </span>            :   }
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :   FinishRow();</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   return mCurrentRow == 0</span>
<span class="lineNum">     919 </span>            :        ? Transition::TerminateSuccess()
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :        : Transition::To(State::PIXEL_ROW, mPixelRowSize);</span>
<span class="lineNum">     921 </span>            : }
<a name="922"><span class="lineNum">     922 </span>            : </a>
<span class="lineNum">     923 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     924 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadRLESegment(const char* aData)</span>
<span class="lineNum">     925 </span>            : {
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   if (mCurrentRow == 0) {</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     return Transition::TerminateSuccess();</span>
<span class="lineNum">     928 </span>            :   }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   uint8_t byte1 = uint8_t(aData[0]);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   uint8_t byte2 = uint8_t(aData[1]);</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   if (byte1 != RLE::ESCAPE) {</span>
<span class="lineNum">     934 </span>            :     // Encoded mode consists of two bytes: byte1 specifies the number of
<span class="lineNum">     935 </span>            :     // consecutive pixels to be drawn using the color index contained in
<span class="lineNum">     936 </span>            :     // byte2.
<span class="lineNum">     937 </span>            :     //
<span class="lineNum">     938 </span>            :     // Work around bitmaps that specify too many pixels.
<span class="lineNum">     939 </span>            :     uint32_t pixelsNeeded =
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :       std::min&lt;uint32_t&gt;(mH.mWidth - mCurrentPos, byte1);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     if (pixelsNeeded) {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       uint32_t* dst = RowBuffer();</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :       mCurrentPos += pixelsNeeded;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :       if (mH.mCompression == Compression::RLE8) {</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :           SetPixel(dst, byte2, mColors);</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :           pixelsNeeded --;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         } while (pixelsNeeded);</span>
<span class="lineNum">     949 </span>            :       } else {
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :           Set4BitPixel(dst, byte2, pixelsNeeded, mColors);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         } while (pixelsNeeded);</span>
<span class="lineNum">     953 </span>            :       }
<span class="lineNum">     954 </span>            :     }
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     return Transition::To(State::RLE_SEGMENT, RLE::SEGMENT_LENGTH);</span>
<span class="lineNum">     956 </span>            :   }
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   if (byte2 == RLE::ESCAPE_EOL) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     mCurrentPos = 0;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     FinishRow();</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :     return mCurrentRow == 0</span>
<span class="lineNum">     962 </span>            :          ? Transition::TerminateSuccess()
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :          : Transition::To(State::RLE_SEGMENT, RLE::SEGMENT_LENGTH);</span>
<span class="lineNum">     964 </span>            :   }
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   if (byte2 == RLE::ESCAPE_EOF) {</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     return Transition::TerminateSuccess();</span>
<span class="lineNum">     968 </span>            :   }
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :   if (byte2 == RLE::ESCAPE_DELTA) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     return Transition::To(State::RLE_DELTA, RLE::DELTA_LENGTH);</span>
<span class="lineNum">     972 </span>            :   }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   // Absolute mode. |byte2| gives the number of pixels. The length depends on
<span class="lineNum">     975 </span>            :   // whether it's 4-bit or 8-bit RLE. Also, the length must be even (and zero
<span class="lineNum">     976 </span>            :   // padding is used to achieve this when necessary).
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mAbsoluteModeNumPixels == 0);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   mAbsoluteModeNumPixels = byte2;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   uint32_t length = byte2;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   if (mH.mCompression == Compression::RLE4) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     length = (length + 1) / 2;    // halve, rounding up</span>
<span class="lineNum">     982 </span>            :   }
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   if (length &amp; 1) {</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     length++;</span>
<span class="lineNum">     985 </span>            :   }
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   return Transition::To(State::RLE_ABSOLUTE, length);</span>
<span class="lineNum">     987 </span>            : }
<a name="988"><span class="lineNum">     988 </span>            : </a>
<span class="lineNum">     989 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadRLEDelta(const char* aData)</span>
<span class="lineNum">     991 </span>            : {
<span class="lineNum">     992 </span>            :   // Delta encoding makes it possible to skip pixels making part of the image
<span class="lineNum">     993 </span>            :   // transparent.
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mMayHaveTransparency);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   mDoesHaveTransparency = true;</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   if (mDownscaler) {</span>
<span class="lineNum">     998 </span>            :     // Clear the skipped pixels. (This clears to the end of the row,
<span class="lineNum">     999 </span>            :     // which is perfect if there's a Y delta and harmless if not).
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     mDownscaler-&gt;ClearRestOfRow(/* aStartingAtCol = */ mCurrentPos);</span>
<span class="lineNum">    1001 </span>            :   }
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            :   // Handle the XDelta.
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   mCurrentPos += uint8_t(aData[0]);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   if (mCurrentPos &gt; mH.mWidth) {</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     mCurrentPos = mH.mWidth;</span>
<span class="lineNum">    1007 </span>            :   }
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :   // Handle the Y Delta.
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   int32_t yDelta = std::min&lt;int32_t&gt;(uint8_t(aData[1]), mCurrentRow);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   mCurrentRow -= yDelta;</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   if (mDownscaler &amp;&amp; yDelta &gt; 0) {</span>
<span class="lineNum">    1014 </span>            :     // Commit the current row (the first of the skipped rows).
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     mDownscaler-&gt;CommitRow();</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :     // Clear and commit the remaining skipped rows.
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     for (int32_t line = 1; line &lt; yDelta; line++) {</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       mDownscaler-&gt;ClearRow();</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       mDownscaler-&gt;CommitRow();</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            :   }
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   return mCurrentRow == 0</span>
<span class="lineNum">    1025 </span>            :        ? Transition::TerminateSuccess()
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :        : Transition::To(State::RLE_SEGMENT, RLE::SEGMENT_LENGTH);</span>
<span class="lineNum">    1027 </span>            : }
<a name="1028"><span class="lineNum">    1028 </span>            : </a>
<span class="lineNum">    1029 </span>            : LexerTransition&lt;nsBMPDecoder::State&gt;
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 : nsBMPDecoder::ReadRLEAbsolute(const char* aData, size_t aLength)</span>
<span class="lineNum">    1031 </span>            : {
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   uint32_t n = mAbsoluteModeNumPixels;</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :   mAbsoluteModeNumPixels = 0;</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   if (mCurrentPos + n &gt; uint32_t(mH.mWidth)) {</span>
<span class="lineNum">    1036 </span>            :     // Bad data. Stop decoding; at least part of the image may have been
<span class="lineNum">    1037 </span>            :     // decoded.
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     return Transition::TerminateSuccess();</span>
<span class="lineNum">    1039 </span>            :   }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :   // In absolute mode, n represents the number of pixels that follow, each of
<span class="lineNum">    1042 </span>            :   // which contains the color index of a single pixel.
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   uint32_t* dst = RowBuffer();</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   uint32_t iSrc = 0;</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   uint32_t* oldPos = dst;</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   if (mH.mCompression == Compression::RLE8) {</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     while (n &gt; 0) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       SetPixel(dst, aData[iSrc], mColors);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :       n--;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :       iSrc++;</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span>            :   } else {
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     while (n &gt; 0) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       Set4BitPixel(dst, aData[iSrc], n, mColors);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :       iSrc++;</span>
<span class="lineNum">    1056 </span>            :     }
<span class="lineNum">    1057 </span>            :   }
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   mCurrentPos += dst - oldPos;</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :   // We should read all the data (unless the last byte is zero padding).
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(iSrc == aLength - 1 || iSrc == aLength);</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   return Transition::To(State::RLE_SEGMENT, RLE::SEGMENT_LENGTH);</span>
<span class="lineNum">    1064 </span>            : }
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            : } // namespace image
<span class="lineNum">    1067 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - image/RasterImage.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">image</a> - RasterImage.h<span style="font-size: 80%;"> (source / <a href="RasterImage.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">72.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /** @file
<span class="lineNum">       8 </span>            :  * This file declares the RasterImage class, which
<span class="lineNum">       9 </span>            :  * handles static and animated rasterized images.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * @author  Stuart Parmenter &lt;pavlov@netscape.com&gt;
<span class="lineNum">      12 </span>            :  * @author  Chris Saari &lt;saari@netscape.com&gt;
<span class="lineNum">      13 </span>            :  * @author  Arron Mogge &lt;paper@animecity.nu&gt;
<span class="lineNum">      14 </span>            :  * @author  Andrew Smith &lt;asmith15@learn.senecac.on.ca&gt;
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #ifndef mozilla_image_RasterImage_h
<span class="lineNum">      18 </span>            : #define mozilla_image_RasterImage_h
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;Image.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;imgIContainer.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIProperties.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsTArray.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;LookupResult.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;DecodePool.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;DecoderFactory.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;FrameAnimator.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;ImageMetadata.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;ISurfaceProvider.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;Orientation.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsIObserver.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;mozilla/NotNull.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;mozilla/Pair.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;mozilla/TimeStamp.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;mozilla/WeakPtr.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;ImageContainer.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;PlaybackType.h&quot;
<span class="lineNum">      44 </span>            : #ifdef DEBUG
<span class="lineNum">      45 </span>            :   #include &quot;imgIContainerDebug.h&quot;
<span class="lineNum">      46 </span>            : #endif
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : class nsIInputStream;
<span class="lineNum">      49 </span>            : class nsIRequest;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #define NS_RASTERIMAGE_CID \
<span class="lineNum">      52 </span>            : { /* 376ff2c1-9bf6-418a-b143-3340c00112f7 */         \
<span class="lineNum">      53 </span>            :      0x376ff2c1,                                     \
<span class="lineNum">      54 </span>            :      0x9bf6,                                         \
<span class="lineNum">      55 </span>            :      0x418a,                                         \
<span class="lineNum">      56 </span>            :     {0xb1, 0x43, 0x33, 0x40, 0xc0, 0x01, 0x12, 0xf7} \
<span class="lineNum">      57 </span>            : }
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /**
<span class="lineNum">      60 </span>            :  * Handles static and animated image containers.
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  * @par A Quick Walk Through
<span class="lineNum">      64 </span>            :  * The decoder initializes this class and calls AppendFrame() to add a frame.
<span class="lineNum">      65 </span>            :  * Once RasterImage detects more than one frame, it starts the animation
<span class="lineNum">      66 </span>            :  * with StartAnimation(). Note that the invalidation events for RasterImage are
<span class="lineNum">      67 </span>            :  * generated automatically using nsRefreshDriver.
<span class="lineNum">      68 </span>            :  *
<span class="lineNum">      69 </span>            :  * @par
<span class="lineNum">      70 </span>            :  * StartAnimation() initializes the animation helper object and sets the time
<span class="lineNum">      71 </span>            :  * the first frame was displayed to the current clock time.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  * @par
<span class="lineNum">      74 </span>            :  * When the refresh driver corresponding to the imgIContainer that this image is
<span class="lineNum">      75 </span>            :  * a part of notifies the RasterImage that it's time to invalidate,
<span class="lineNum">      76 </span>            :  * RequestRefresh() is called with a given TimeStamp to advance to. As long as
<span class="lineNum">      77 </span>            :  * the timeout of the given frame (the frame's &quot;delay&quot;) plus the time that frame
<span class="lineNum">      78 </span>            :  * was first displayed is less than or equal to the TimeStamp given,
<span class="lineNum">      79 </span>            :  * RequestRefresh() calls AdvanceFrame().
<span class="lineNum">      80 </span>            :  *
<span class="lineNum">      81 </span>            :  * @par
<span class="lineNum">      82 </span>            :  * AdvanceFrame() is responsible for advancing a single frame of the animation.
<span class="lineNum">      83 </span>            :  * It can return true, meaning that the frame advanced, or false, meaning that
<span class="lineNum">      84 </span>            :  * the frame failed to advance (usually because the next frame hasn't been
<span class="lineNum">      85 </span>            :  * decoded yet). It is also responsible for performing the final animation stop
<span class="lineNum">      86 </span>            :  * procedure if the final frame of a non-looping animation is reached.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * @par
<span class="lineNum">      89 </span>            :  * Each frame can have a different method of removing itself. These are
<span class="lineNum">      90 </span>            :  * listed as imgIContainer::cDispose... constants.  Notify() calls
<span class="lineNum">      91 </span>            :  * DoComposite() to handle any special frame destruction.
<span class="lineNum">      92 </span>            :  *
<span class="lineNum">      93 </span>            :  * @par
<span class="lineNum">      94 </span>            :  * The basic path through DoComposite() is:
<span class="lineNum">      95 </span>            :  * 1) Calculate Area that needs updating, which is at least the area of
<span class="lineNum">      96 </span>            :  *    aNextFrame.
<span class="lineNum">      97 </span>            :  * 2) Dispose of previous frame.
<span class="lineNum">      98 </span>            :  * 3) Draw new image onto compositingFrame.
<span class="lineNum">      99 </span>            :  * See comments in DoComposite() for more information and optimizations.
<span class="lineNum">     100 </span>            :  *
<span class="lineNum">     101 </span>            :  * @par
<span class="lineNum">     102 </span>            :  * The rest of the RasterImage specific functions are used by DoComposite to
<span class="lineNum">     103 </span>            :  * destroy the old frame and build the new one.
<span class="lineNum">     104 </span>            :  *
<span class="lineNum">     105 </span>            :  * @note
<span class="lineNum">     106 </span>            :  * &lt;li&gt; &quot;Mask&quot;, &quot;Alpha&quot;, and &quot;Alpha Level&quot; are interchangeable phrases in
<span class="lineNum">     107 </span>            :  * respects to RasterImage.
<span class="lineNum">     108 </span>            :  *
<span class="lineNum">     109 </span>            :  * @par
<span class="lineNum">     110 </span>            :  * &lt;li&gt; GIFs never have more than a 1 bit alpha.
<span class="lineNum">     111 </span>            :  * &lt;li&gt; APNGs may have a full alpha channel.
<span class="lineNum">     112 </span>            :  *
<span class="lineNum">     113 </span>            :  * @par
<span class="lineNum">     114 </span>            :  * &lt;li&gt; Background color specified in GIF is ignored by web browsers.
<span class="lineNum">     115 </span>            :  *
<span class="lineNum">     116 </span>            :  * @par
<span class="lineNum">     117 </span>            :  * &lt;li&gt; If Frame 3 wants to dispose by restoring previous, what it wants is to
<span class="lineNum">     118 </span>            :  * restore the composition up to and including Frame 2, as well as Frame 2s
<span class="lineNum">     119 </span>            :  * disposal.  So, in the middle of DoComposite when composing Frame 3, right
<span class="lineNum">     120 </span>            :  * after destroying Frame 2's area, we copy compositingFrame to
<span class="lineNum">     121 </span>            :  * prevCompositingFrame.  When DoComposite gets called to do Frame 4, we
<span class="lineNum">     122 </span>            :  * copy prevCompositingFrame back, and then draw Frame 4 on top.
<span class="lineNum">     123 </span>            :  *
<span class="lineNum">     124 </span>            :  * @par
<span class="lineNum">     125 </span>            :  * The mAnim structure has members only needed for animated images, so
<span class="lineNum">     126 </span>            :  * it's not allocated until the second frame is added.
<span class="lineNum">     127 </span>            :  */
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : namespace mozilla {
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : namespace layers {
<span class="lineNum">     132 </span>            : class ImageContainer;
<span class="lineNum">     133 </span>            : class Image;
<span class="lineNum">     134 </span>            : } // namespace layers
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : namespace image {
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : class Decoder;
<span class="lineNum">     139 </span>            : struct DecoderFinalStatus;
<span class="lineNum">     140 </span>            : struct DecoderTelemetry;
<span class="lineNum">     141 </span>            : class ImageMetadata;
<span class="lineNum">     142 </span>            : class SourceBuffer;
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : class RasterImage final : public ImageResource
<span class="lineNum">     145 </span>            :                         , public nsIProperties
<span class="lineNum">     146 </span>            :                         , public SupportsWeakPtr&lt;RasterImage&gt;
<span class="lineNum">     147 </span>            : #ifdef DEBUG
<span class="lineNum">     148 </span>            :                         , public imgIContainerDebug
<span class="lineNum">     149 </span>            : #endif
<span class="lineNum">     150 </span>            : {
<span class="lineNum">     151 </span>            :   // (no public constructor - use ImageFactory)
<span class="lineNum">     152 </span>            :   virtual ~RasterImage();
<a name="153"><span class="lineNum">     153 </span>            : </a>
<span class="lineNum">     154 </span>            : public:
<span class="lineNum">     155 </span><span class="lineCov">         21 :   MOZ_DECLARE_WEAKREFERENCE_TYPENAME(RasterImage)</span>
<span class="lineNum">     156 </span>            :   NS_DECL_THREADSAFE_ISUPPORTS
<span class="lineNum">     157 </span>            :   NS_DECL_NSIPROPERTIES
<span class="lineNum">     158 </span>            :   NS_DECL_IMGICONTAINER
<span class="lineNum">     159 </span>            : #ifdef DEBUG
<span class="lineNum">     160 </span>            :   NS_DECL_IMGICONTAINERDEBUG
<span class="lineNum">     161 </span>            : #endif
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :   nsresult GetNativeSizes(nsTArray&lt;gfx::IntSize&gt;&amp; aNativeSizes) const override;
<span class="lineNum">     164 </span>            :   virtual nsresult StartAnimation() override;
<span class="lineNum">     165 </span>            :   virtual nsresult StopAnimation() override;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :   // Methods inherited from Image
<span class="lineNum">     168 </span>            :   virtual void OnSurfaceDiscarded(const SurfaceKey&amp; aSurfaceKey) override;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   virtual size_t SizeOfSourceWithComputedFallback(MallocSizeOf aMallocSizeOf)
<span class="lineNum">     171 </span>            :     const override;
<span class="lineNum">     172 </span>            :   virtual void CollectSizeOfSurfaces(nsTArray&lt;SurfaceMemoryCounter&gt;&amp; aCounters,
<span class="lineNum">     173 </span>            :                                      MallocSizeOf aMallocSizeOf) const override;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   /* Triggers discarding. */
<span class="lineNum">     176 </span>            :   void Discard();
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     180 </span>            :   // Decoder callbacks.
<span class="lineNum">     181 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :   /**
<span class="lineNum">     184 </span>            :    * Sends the provided progress notifications to ProgressTracker.
<span class="lineNum">     185 </span>            :    *
<span class="lineNum">     186 </span>            :    * Main-thread only.
<span class="lineNum">     187 </span>            :    *
<span class="lineNum">     188 </span>            :    * @param aProgress    The progress notifications to send.
<span class="lineNum">     189 </span>            :    * @param aInvalidRect An invalidation rect to send.
<span class="lineNum">     190 </span>            :    * @param aFrameCount  If Some(), an updated count of the number of frames of
<span class="lineNum">     191 </span>            :    *                     animation the decoder has finished decoding so far. This
<span class="lineNum">     192 </span>            :    *                     is a lower bound for the total number of animation
<span class="lineNum">     193 </span>            :    *                     frames this image has.
<span class="lineNum">     194 </span>            :    * @param aDecoderFlags The decoder flags used by the decoder that generated
<span class="lineNum">     195 </span>            :    *                      these notifications, or DefaultDecoderFlags() if the
<span class="lineNum">     196 </span>            :    *                      notifications don't come from a decoder.
<span class="lineNum">     197 </span>            :    * @param aSurfaceFlags The surface flags used by the decoder that generated
<span class="lineNum">     198 </span>            :    *                      these notifications, or DefaultSurfaceFlags() if the
<span class="lineNum">     199 </span>            :    *                      notifications don't come from a decoder.
<span class="lineNum">     200 </span>            :    */
<span class="lineNum">     201 </span>            :   void NotifyProgress(Progress aProgress,
<span class="lineNum">     202 </span>            :                       const gfx::IntRect&amp; aInvalidRect = nsIntRect(),
<span class="lineNum">     203 </span>            :                       const Maybe&lt;uint32_t&gt;&amp; aFrameCount = Nothing(),
<span class="lineNum">     204 </span>            :                       DecoderFlags aDecoderFlags = DefaultDecoderFlags(),
<span class="lineNum">     205 </span>            :                       SurfaceFlags aSurfaceFlags = DefaultSurfaceFlags());
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /**
<span class="lineNum">     208 </span>            :    * Records decoding results, sends out any final notifications, updates the
<span class="lineNum">     209 </span>            :    * state of this image, and records telemetry.
<span class="lineNum">     210 </span>            :    *
<span class="lineNum">     211 </span>            :    * Main-thread only.
<span class="lineNum">     212 </span>            :    *
<span class="lineNum">     213 </span>            :    * @param aStatus       Final status information about the decoder. (Whether it
<span class="lineNum">     214 </span>            :    *                      encountered an error, etc.)
<span class="lineNum">     215 </span>            :    * @param aMetadata     Metadata about this image that the decoder gathered.
<span class="lineNum">     216 </span>            :    * @param aTelemetry    Telemetry data about the decoder.
<span class="lineNum">     217 </span>            :    * @param aProgress     Any final progress notifications to send.
<span class="lineNum">     218 </span>            :    * @param aInvalidRect  Any final invalidation rect to send.
<span class="lineNum">     219 </span>            :    * @param aFrameCount   If Some(), a final updated count of the number of frames
<span class="lineNum">     220 </span>            :    *                      of animation the decoder has finished decoding so far.
<span class="lineNum">     221 </span>            :    *                      This is a lower bound for the total number of animation
<span class="lineNum">     222 </span>            :    *                      frames this image has.
<span class="lineNum">     223 </span>            :    * @param aDecoderFlags The decoder flags used by the decoder.
<span class="lineNum">     224 </span>            :    * @param aSurfaceFlags The surface flags used by the decoder.
<span class="lineNum">     225 </span>            :    */
<span class="lineNum">     226 </span>            :   void NotifyDecodeComplete(const DecoderFinalStatus&amp; aStatus,
<span class="lineNum">     227 </span>            :                             const ImageMetadata&amp; aMetadata,
<span class="lineNum">     228 </span>            :                             const DecoderTelemetry&amp; aTelemetry,
<span class="lineNum">     229 </span>            :                             Progress aProgress,
<span class="lineNum">     230 </span>            :                             const gfx::IntRect&amp; aInvalidRect,
<span class="lineNum">     231 </span>            :                             const Maybe&lt;uint32_t&gt;&amp; aFrameCount,
<span class="lineNum">     232 </span>            :                             DecoderFlags aDecoderFlags,
<span class="lineNum">     233 </span>            :                             SurfaceFlags aSurfaceFlags);
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   // Helper method for NotifyDecodeComplete.
<span class="lineNum">     236 </span>            :   void ReportDecoderError();
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     240 </span>            :   // Network callbacks.
<span class="lineNum">     241 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   virtual nsresult OnImageDataAvailable(nsIRequest* aRequest,
<span class="lineNum">     244 </span>            :                                         nsISupports* aContext,
<span class="lineNum">     245 </span>            :                                         nsIInputStream* aInStr,
<span class="lineNum">     246 </span>            :                                         uint64_t aSourceOffset,
<span class="lineNum">     247 </span>            :                                         uint32_t aCount) override;
<span class="lineNum">     248 </span>            :   virtual nsresult OnImageDataComplete(nsIRequest* aRequest,
<span class="lineNum">     249 </span>            :                                        nsISupports* aContext,
<span class="lineNum">     250 </span>            :                                        nsresult aStatus,
<span class="lineNum">     251 </span>            :                                        bool aLastPart) override;
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :   void NotifyForLoadEvent(Progress aProgress);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   /**
<span class="lineNum">     256 </span>            :    * A hint of the number of bytes of source data that the image contains. If
<span class="lineNum">     257 </span>            :    * called early on, this can help reduce copying and reallocations by
<span class="lineNum">     258 </span>            :    * appropriately preallocating the source data buffer.
<span class="lineNum">     259 </span>            :    *
<span class="lineNum">     260 </span>            :    * We take this approach rather than having the source data management code do
<span class="lineNum">     261 </span>            :    * something more complicated (like chunklisting) because HTTP is by far the
<span class="lineNum">     262 </span>            :    * dominant source of images, and the Content-Length header is quite reliable.
<span class="lineNum">     263 </span>            :    * Thus, pre-allocation simplifies code and reduces the total number of
<span class="lineNum">     264 </span>            :    * allocations.
<span class="lineNum">     265 </span>            :    */
<a name="266"><span class="lineNum">     266 </span>            :   nsresult SetSourceSizeHint(uint32_t aSizeHint);</a>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">         14 :  nsCString GetURIString() {</span>
<span class="lineNum">     269 </span><span class="lineCov">         14 :     nsCString spec;</span>
<span class="lineNum">     270 </span><span class="lineCov">         14 :     if (GetURI()) {</span>
<span class="lineNum">     271 </span><span class="lineCov">         14 :       GetURI()-&gt;GetSpec(spec);</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span><span class="lineCov">         14 :     return spec;</span>
<span class="lineNum">     274 </span>            :   }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : private:
<span class="lineNum">     277 </span>            :   nsresult Init(const char* aMimeType, uint32_t aFlags);
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :   /**
<span class="lineNum">     280 </span>            :    * Tries to retrieve a surface for this image with size @aSize, surface flags
<span class="lineNum">     281 </span>            :    * matching @aFlags, and a playback type of @aPlaybackType.
<span class="lineNum">     282 </span>            :    *
<span class="lineNum">     283 </span>            :    * If @aFlags specifies FLAG_SYNC_DECODE and we already have all the image
<span class="lineNum">     284 </span>            :    * data, we'll attempt a sync decode if no matching surface is found. If
<span class="lineNum">     285 </span>            :    * FLAG_SYNC_DECODE was not specified and no matching surface was found, we'll
<span class="lineNum">     286 </span>            :    * kick off an async decode so that the surface is (hopefully) available next
<span class="lineNum">     287 </span>            :    * time it's requested.
<span class="lineNum">     288 </span>            :    *
<span class="lineNum">     289 </span>            :    * @return a drawable surface, which may be empty if the requested surface
<span class="lineNum">     290 </span>            :    *         could not be found.
<span class="lineNum">     291 </span>            :    */
<span class="lineNum">     292 </span>            :   DrawableSurface LookupFrame(const gfx::IntSize&amp; aSize,
<span class="lineNum">     293 </span>            :                               uint32_t aFlags,
<span class="lineNum">     294 </span>            :                               PlaybackType aPlaybackType);
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   /// Helper method for LookupFrame().
<span class="lineNum">     297 </span>            :   LookupResult LookupFrameInternal(const gfx::IntSize&amp; aSize,
<span class="lineNum">     298 </span>            :                                    uint32_t aFlags,
<span class="lineNum">     299 </span>            :                                    PlaybackType aPlaybackType);
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   DrawResult DrawInternal(DrawableSurface&amp;&amp; aFrameRef,
<span class="lineNum">     302 </span>            :                           gfxContext* aContext,
<span class="lineNum">     303 </span>            :                           const nsIntSize&amp; aSize,
<span class="lineNum">     304 </span>            :                           const ImageRegion&amp; aRegion,
<span class="lineNum">     305 </span>            :                           gfx::SamplingFilter aSamplingFilter,
<span class="lineNum">     306 </span>            :                           uint32_t aFlags,
<span class="lineNum">     307 </span>            :                           float aOpacity);
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :   Pair&lt;DrawResult, RefPtr&lt;gfx::SourceSurface&gt;&gt;
<span class="lineNum">     310 </span>            :     GetFrameInternal(const gfx::IntSize&amp; aSize,
<span class="lineNum">     311 </span>            :                      uint32_t aWhichFrame,
<span class="lineNum">     312 </span>            :                      uint32_t aFlags);
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :   Pair&lt;DrawResult, RefPtr&lt;layers::Image&gt;&gt;
<span class="lineNum">     315 </span>            :     GetCurrentImage(layers::ImageContainer* aContainer, uint32_t aFlags);
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   void UpdateImageContainer();
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     320 </span>            :   // Decoding.
<span class="lineNum">     321 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :   /**
<span class="lineNum">     324 </span>            :    * Creates and runs a decoder, either synchronously or asynchronously
<span class="lineNum">     325 </span>            :    * according to @aFlags. Decodes at the provided target size @aSize, using
<span class="lineNum">     326 </span>            :    * decode flags @aFlags. Performs a single-frame decode of this image unless
<span class="lineNum">     327 </span>            :    * we know the image is animated *and* @aPlaybackType is
<span class="lineNum">     328 </span>            :    * PlaybackType::eAnimated.
<span class="lineNum">     329 </span>            :    *
<span class="lineNum">     330 </span>            :    * It's an error to call Decode() before this image's intrinsic size is
<span class="lineNum">     331 </span>            :    * available. A metadata decode must successfully complete first.
<span class="lineNum">     332 </span>            :    *
<span class="lineNum">     333 </span>            :    * Returns true of the decode was run synchronously.
<span class="lineNum">     334 </span>            :    */
<span class="lineNum">     335 </span>            :   bool Decode(const gfx::IntSize&amp; aSize,
<span class="lineNum">     336 </span>            :               uint32_t aFlags,
<span class="lineNum">     337 </span>            :               PlaybackType aPlaybackType);
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :   /**
<span class="lineNum">     340 </span>            :    * Creates and runs a metadata decoder, either synchronously or
<span class="lineNum">     341 </span>            :    * asynchronously according to @aFlags.
<span class="lineNum">     342 </span>            :    */
<span class="lineNum">     343 </span>            :   NS_IMETHOD DecodeMetadata(uint32_t aFlags);
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   /**
<span class="lineNum">     346 </span>            :    * Sets the size, inherent orientation, animation metadata, and other
<span class="lineNum">     347 </span>            :    * information about the image gathered during decoding.
<span class="lineNum">     348 </span>            :    *
<span class="lineNum">     349 </span>            :    * This function may be called multiple times, but will throw an error if
<span class="lineNum">     350 </span>            :    * subsequent calls do not match the first.
<span class="lineNum">     351 </span>            :    *
<span class="lineNum">     352 </span>            :    * @param aMetadata The metadata to set on this image.
<span class="lineNum">     353 </span>            :    * @param aFromMetadataDecode True if this metadata came from a metadata
<span class="lineNum">     354 </span>            :    *                            decode; false if it came from a full decode.
<span class="lineNum">     355 </span>            :    * @return |true| unless a catastrophic failure was discovered. If |false| is
<span class="lineNum">     356 </span>            :    * returned, it indicates that the image is corrupt in a way that requires all
<span class="lineNum">     357 </span>            :    * surfaces to be discarded to recover.
<span class="lineNum">     358 </span>            :    */
<span class="lineNum">     359 </span>            :   bool SetMetadata(const ImageMetadata&amp; aMetadata, bool aFromMetadataDecode);
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :   /**
<span class="lineNum">     362 </span>            :    * In catastrophic circumstances like a GPU driver crash, the contents of our
<span class="lineNum">     363 </span>            :    * frames may become invalid.  If the information we gathered during the
<span class="lineNum">     364 </span>            :    * metadata decode proves to be wrong due to image corruption, the frames we
<span class="lineNum">     365 </span>            :    * have may violate this class's invariants. Either way, we need to
<span class="lineNum">     366 </span>            :    * immediately discard the invalid frames and redecode so that callers don't
<span class="lineNum">     367 </span>            :    * perceive that we've entered an invalid state.
<span class="lineNum">     368 </span>            :    *
<span class="lineNum">     369 </span>            :    * RecoverFromInvalidFrames discards all existing frames and redecodes using
<span class="lineNum">     370 </span>            :    * the provided @aSize and @aFlags.
<span class="lineNum">     371 </span>            :    */
<span class="lineNum">     372 </span>            :   void RecoverFromInvalidFrames(const nsIntSize&amp; aSize, uint32_t aFlags);
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   void OnSurfaceDiscardedInternal(bool aAnimatedFramesDiscarded);
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : private: // data
<span class="lineNum">     377 </span>            :   nsIntSize                  mSize;
<span class="lineNum">     378 </span>            :   nsTArray&lt;nsIntSize&gt;        mNativeSizes;
<span class="lineNum">     379 </span>            :   Orientation                mOrientation;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :   /// If this has a value, we're waiting for SetSize() to send the load event.
<span class="lineNum">     382 </span>            :   Maybe&lt;Progress&gt;            mLoadProgress;
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :   nsCOMPtr&lt;nsIProperties&gt;   mProperties;
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   /// If this image is animated, a FrameAnimator which manages its animation.
<span class="lineNum">     387 </span>            :   UniquePtr&lt;FrameAnimator&gt; mFrameAnimator;
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            :   /// Animation timeline and other state for animation images.
<span class="lineNum">     390 </span>            :   Maybe&lt;AnimationState&gt; mAnimationState;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   // Image locking.
<span class="lineNum">     393 </span>            :   uint32_t                   mLockCount;
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   // The type of decoder this image needs. Computed from the MIME type in Init().
<span class="lineNum">     396 </span>            :   DecoderType                mDecoderType;
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   // How many times we've decoded this image.
<span class="lineNum">     399 </span>            :   // This is currently only used for statistics
<span class="lineNum">     400 </span>            :   int32_t                        mDecodeCount;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   // A weak pointer to our ImageContainer, which stays alive only as long as
<span class="lineNum">     403 </span>            :   // the layer system needs it.
<span class="lineNum">     404 </span>            :   WeakPtr&lt;layers::ImageContainer&gt; mImageContainer;
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :   layers::ImageContainer::ProducerID mImageProducerID;
<span class="lineNum">     407 </span>            :   layers::ImageContainer::FrameID mLastFrameID;
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :   // If mImageContainer is non-null, this contains the DrawResult we obtained
<span class="lineNum">     410 </span>            :   // the last time we updated it.
<span class="lineNum">     411 </span>            :   DrawResult mLastImageContainerDrawResult;
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : #ifdef DEBUG
<span class="lineNum">     414 </span>            :   uint32_t                       mFramesNotified;
<span class="lineNum">     415 </span>            : #endif
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   // The source data for this image.
<span class="lineNum">     418 </span>            :   NotNull&lt;RefPtr&lt;SourceBuffer&gt;&gt;  mSourceBuffer;
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :   // Boolean flags (clustered together to conserve space):
<span class="lineNum">     421 </span>            :   bool                       mHasSize:1;        // Has SetSize() been called?
<span class="lineNum">     422 </span>            :   bool                       mTransient:1;      // Is the image short-lived?
<span class="lineNum">     423 </span>            :   bool                       mSyncLoad:1;       // Are we loading synchronously?
<span class="lineNum">     424 </span>            :   bool                       mDiscardable:1;    // Is container discardable?
<span class="lineNum">     425 </span>            :   bool                       mSomeSourceData:1; // Do we have some source data?
<span class="lineNum">     426 </span>            :   bool                       mAllSourceData:1;  // Do we have all the source data?
<span class="lineNum">     427 </span>            :   bool                       mHasBeenDecoded:1; // Decoded at least once?
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :   // Whether we're waiting to start animation. If we get a StartAnimation() call
<span class="lineNum">     430 </span>            :   // but we don't yet have more than one frame, mPendingAnimation is set so that
<span class="lineNum">     431 </span>            :   // we know to start animation later if/when we have more frames.
<span class="lineNum">     432 </span>            :   bool                       mPendingAnimation:1;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   // Whether the animation can stop, due to running out
<span class="lineNum">     435 </span>            :   // of frames, or no more owning request
<span class="lineNum">     436 </span>            :   bool                       mAnimationFinished:1;
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // Whether, once we are done doing a metadata decode, we should immediately
<span class="lineNum">     439 </span>            :   // kick off a full decode.
<span class="lineNum">     440 </span>            :   bool                       mWantFullDecode:1;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :   TimeStamp mDrawStartTime;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     446 </span>            :   // Scaling.
<span class="lineNum">     447 </span>            :   //////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // Determines whether we can downscale during decode with the given
<span class="lineNum">     450 </span>            :   // parameters.
<span class="lineNum">     451 </span>            :   bool CanDownscaleDuringDecode(const nsIntSize&amp; aSize, uint32_t aFlags);
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   // Error handling.
<a name="455"><span class="lineNum">     455 </span>            :   void DoError();</a>
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   class HandleErrorWorker : public Runnable</span>
<span class="lineNum">     458 </span>            :   {
<span class="lineNum">     459 </span>            :   public:
<span class="lineNum">     460 </span>            :     /**
<span class="lineNum">     461 </span>            :      * Called from decoder threads when DoError() is called, since errors can't
<span class="lineNum">     462 </span>            :      * be handled safely off-main-thread. Dispatches an event which reinvokes
<span class="lineNum">     463 </span>            :      * DoError on the main thread if there isn't one already pending.
<span class="lineNum">     464 </span>            :      */
<span class="lineNum">     465 </span>            :     static void DispatchIfNeeded(RasterImage* aImage);
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     NS_IMETHOD Run();
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :   private:
<span class="lineNum">     470 </span>            :     explicit HandleErrorWorker(RasterImage* aImage);
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :     RefPtr&lt;RasterImage&gt; mImage;
<span class="lineNum">     473 </span>            :   };
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :   // Helpers
<span class="lineNum">     476 </span>            :   bool CanDiscard();
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :   bool IsOpaque();
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   DrawableSurface RequestDecodeForSizeInternal(const gfx::IntSize&amp; aSize, uint32_t aFlags);
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : protected:
<span class="lineNum">     483 </span>            :   explicit RasterImage(ImageURL* aURI = nullptr);
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :   bool ShouldAnimate() override;
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :   friend class ImageFactory;
<span class="lineNum">     488 </span>            : };
<a name="489"><span class="lineNum">     489 </span>            : </a>
<span class="lineNum">     490 </span>            : inline NS_IMETHODIMP
<span class="lineNum">     491 </span><span class="lineNoCov">          0 : RasterImage::GetAnimationMode(uint16_t* aAnimationMode) {</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   return GetAnimationModeInternal(aAnimationMode);</span>
<span class="lineNum">     493 </span>            : }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : } // namespace image
<span class="lineNum">     496 </span>            : } // namespace mozilla
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : /**
<span class="lineNum">     499 </span>            :  * Casting RasterImage to nsISupports is ambiguous. This method handles that.
<a name="500"><span class="lineNum">     500 </span>            :  */</a>
<span class="lineNum">     501 </span>            : inline nsISupports*
<span class="lineNum">     502 </span><span class="lineCov">         33 : ToSupports(mozilla::image::RasterImage* p)</span>
<span class="lineNum">     503 </span>            : {
<span class="lineNum">     504 </span><span class="lineCov">         33 :   return NS_ISUPPORTS_CAST(mozilla::image::ImageResource*, p);</span>
<span class="lineNum">     505 </span>            : }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            : #endif /* mozilla_image_RasterImage_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

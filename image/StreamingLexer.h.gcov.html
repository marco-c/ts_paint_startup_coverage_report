<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - image/StreamingLexer.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">image</a> - StreamingLexer.h<span style="font-size: 80%;"> (source / <a href="StreamingLexer.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">128</td>
            <td class="headerCovTableEntry">173</td>
            <td class="headerCovTableEntryLo">74.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntry">187</td>
            <td class="headerCovTableEntryLo">30.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /**
<span class="lineNum">       8 </span>            :  * StreamingLexer is a lexing framework designed to make it simple to write
<span class="lineNum">       9 </span>            :  * image decoders without worrying about the details of how the data is arriving
<span class="lineNum">      10 </span>            :  * from the network.
<span class="lineNum">      11 </span>            :  */
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #ifndef mozilla_image_StreamingLexer_h
<span class="lineNum">      14 </span>            : #define mozilla_image_StreamingLexer_h
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      17 </span>            : #include &lt;cstdint&gt;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/Move.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/Variant.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/Vector.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : namespace mozilla {
<span class="lineNum">      26 </span>            : namespace image {
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /// Buffering behaviors for StreamingLexer transitions.
<span class="lineNum">      29 </span>            : enum class BufferingStrategy
<span class="lineNum">      30 </span>            : {
<span class="lineNum">      31 </span>            :   BUFFERED,   // Data will be buffered and processed in one chunk.
<span class="lineNum">      32 </span>            :   UNBUFFERED  // Data will be processed as it arrives, in multiple chunks.
<span class="lineNum">      33 </span>            : };
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /// Control flow behaviors for StreamingLexer transitions.
<span class="lineNum">      36 </span>            : enum class ControlFlowStrategy
<span class="lineNum">      37 </span>            : {
<span class="lineNum">      38 </span>            :   CONTINUE,  // If there's enough data, proceed to the next state immediately.
<span class="lineNum">      39 </span>            :   YIELD      // Yield to the caller before proceeding to the next state.
<span class="lineNum">      40 </span>            : };
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /// Possible terminal states for the lexer.
<span class="lineNum">      43 </span>            : enum class TerminalState
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span>            :   SUCCESS,
<span class="lineNum">      46 </span>            :   FAILURE
<span class="lineNum">      47 </span>            : };
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /// Possible yield reasons for the lexer.
<span class="lineNum">      50 </span>            : enum class Yield
<span class="lineNum">      51 </span>            : {
<span class="lineNum">      52 </span>            :   NEED_MORE_DATA,   // The lexer cannot continue without more data.
<span class="lineNum">      53 </span>            :   OUTPUT_AVAILABLE  // There is output available for the caller to consume.
<span class="lineNum">      54 </span>            : };
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /// The result of a call to StreamingLexer::Lex().
<span class="lineNum">      57 </span>            : typedef Variant&lt;TerminalState, Yield&gt; LexerResult;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /**
<span class="lineNum">      60 </span>            :  * LexerTransition is a type used to give commands to the lexing framework.
<span class="lineNum">      61 </span>            :  * Code that uses StreamingLexer can create LexerTransition values using the
<span class="lineNum">      62 </span>            :  * static methods on Transition, and then return them to the lexing framework
<span class="lineNum">      63 </span>            :  * for execution.
<a name="64"><span class="lineNum">      64 </span>            :  */</a>
<span class="lineNum">      65 </span>            : template &lt;typename State&gt;
<span class="lineNum">      66 </span><span class="lineCov">        699 : class LexerTransition</span>
<span class="lineNum">      67 </span>            : {
<span class="lineNum">      68 </span>            : public:
<span class="lineNum">      69 </span>            :   // This is implicit so that Terminate{Success,Failure}() can return a
<span class="lineNum">      70 </span>            :   // TerminalState and have it implicitly converted to a
<a name="71"><span class="lineNum">      71 </span>            :   // LexerTransition&lt;State&gt;, which avoids the need for a &quot;&lt;State&gt;&quot;</a>
<span class="lineNum">      72 </span>            :   // qualification to the Terminate{Success,Failure}() callsite.
<span class="lineNum">      73 </span><span class="lineCov">         99 :   MOZ_IMPLICIT LexerTransition(TerminalState aFinalState)</span>
<span class="lineNum">      74 </span><span class="lineCov">         99 :     : mNextState(aFinalState)</span>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">         99 :   {}</span></a>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineCov">        495 :   bool NextStateIsTerminal() const</span>
<span class="lineNum">      78 </span>            :   {
<span class="lineNum">      79 </span><span class="lineCov">        495 :     return mNextState.template is&lt;TerminalState&gt;();</span>
<a name="80"><span class="lineNum">      80 </span>            :   }</a>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineCov">         33 :   TerminalState NextStateAsTerminal() const</span>
<span class="lineNum">      83 </span>            :   {
<span class="lineNum">      84 </span><span class="lineCov">         33 :     return mNextState.template as&lt;TerminalState&gt;();</span>
<a name="85"><span class="lineNum">      85 </span>            :   }</a>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineCov">        128 :   State NextState() const</span>
<span class="lineNum">      88 </span>            :   {
<span class="lineNum">      89 </span><span class="lineCov">        128 :     return mNextState.template as&lt;NonTerminalState&gt;().mState;</span>
<a name="90"><span class="lineNum">      90 </span>            :   }</a>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span><span class="lineCov">        173 :   State UnbufferedState() const</span>
<span class="lineNum">      93 </span>            :   {
<span class="lineNum">      94 </span><span class="lineCov">        173 :     return *mNextState.template as&lt;NonTerminalState&gt;().mUnbufferedState;</span>
<a name="95"><span class="lineNum">      95 </span>            :   }</a>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineCov">        131 :   size_t Size() const</span>
<span class="lineNum">      98 </span>            :   {
<span class="lineNum">      99 </span><span class="lineCov">        131 :     return mNextState.template as&lt;NonTerminalState&gt;().mSize;</span>
<a name="100"><span class="lineNum">     100 </span>            :   }</a>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineCov">        350 :   BufferingStrategy Buffering() const</span>
<span class="lineNum">     103 </span>            :   {
<span class="lineNum">     104 </span><span class="lineCov">        350 :     return mNextState.template as&lt;NonTerminalState&gt;().mBufferingStrategy;</span>
<a name="105"><span class="lineNum">     105 </span>            :   }</a>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineCov">        195 :   ControlFlowStrategy ControlFlow() const</span>
<span class="lineNum">     108 </span>            :   {
<span class="lineNum">     109 </span><span class="lineCov">        195 :     return mNextState.template as&lt;NonTerminalState&gt;().mControlFlowStrategy;</span>
<span class="lineNum">     110 </span>            :   }
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : private:
<a name="113"><span class="lineNum">     113 </span>            :   friend struct Transition;</a>
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span><span class="lineCov">        187 :   LexerTransition(State aNextState,</span>
<span class="lineNum">     116 </span>            :                   const Maybe&lt;State&gt;&amp; aUnbufferedState,
<span class="lineNum">     117 </span>            :                   size_t aSize,
<span class="lineNum">     118 </span>            :                   BufferingStrategy aBufferingStrategy,
<span class="lineNum">     119 </span>            :                   ControlFlowStrategy aControlFlowStrategy)
<span class="lineNum">     120 </span>            :     : mNextState(NonTerminalState(aNextState, aUnbufferedState, aSize,
<span class="lineNum">     121 </span><span class="lineCov">        187 :                                   aBufferingStrategy, aControlFlowStrategy))</span>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">        187 :   {}</span></a>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">        935 :   struct NonTerminalState</span>
<span class="lineNum">     125 </span>            :   {
<span class="lineNum">     126 </span>            :     State mState;
<span class="lineNum">     127 </span>            :     Maybe&lt;State&gt; mUnbufferedState;
<span class="lineNum">     128 </span>            :     size_t mSize;
<span class="lineNum">     129 </span>            :     BufferingStrategy mBufferingStrategy;
<a name="130"><span class="lineNum">     130 </span>            :     ControlFlowStrategy mControlFlowStrategy;</a>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">        187 :     NonTerminalState(State aState,</span>
<span class="lineNum">     133 </span>            :                      const Maybe&lt;State&gt;&amp; aUnbufferedState,
<span class="lineNum">     134 </span>            :                      size_t aSize,
<span class="lineNum">     135 </span>            :                      BufferingStrategy aBufferingStrategy,
<span class="lineNum">     136 </span>            :                      ControlFlowStrategy aControlFlowStrategy)
<span class="lineNum">     137 </span>            :       : mState(aState)
<span class="lineNum">     138 </span>            :       , mUnbufferedState(aUnbufferedState)
<span class="lineNum">     139 </span>            :       , mSize(aSize)
<span class="lineNum">     140 </span>            :       , mBufferingStrategy(aBufferingStrategy)
<span class="lineNum">     141 </span><span class="lineCov">        187 :       , mControlFlowStrategy(aControlFlowStrategy)</span>
<span class="lineNum">     142 </span>            :     {
<span class="lineNum">     143 </span><span class="lineCov">        187 :       MOZ_ASSERT_IF(mBufferingStrategy == BufferingStrategy::UNBUFFERED,</span>
<span class="lineNum">     144 </span>            :                     mUnbufferedState);
<span class="lineNum">     145 </span><span class="lineCov">        187 :       MOZ_ASSERT_IF(mUnbufferedState,</span>
<span class="lineNum">     146 </span>            :                     mBufferingStrategy == BufferingStrategy::UNBUFFERED);
<span class="lineNum">     147 </span><span class="lineCov">        187 :     }</span>
<span class="lineNum">     148 </span>            :   };
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            :   Variant&lt;NonTerminalState, TerminalState&gt; mNextState;
<span class="lineNum">     151 </span>            : };
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : struct Transition
<span class="lineNum">     154 </span>            : {
<span class="lineNum">     155 </span>            :   /// Transition to @aNextState, buffering @aSize bytes of data.
<a name="156"><span class="lineNum">     156 </span>            :   template &lt;typename State&gt;</a>
<span class="lineNum">     157 </span>            :   static LexerTransition&lt;State&gt;
<span class="lineNum">     158 </span><span class="lineCov">         20 :   To(const State&amp; aNextState, size_t aSize)</span>
<span class="lineNum">     159 </span>            :   {
<span class="lineNum">     160 </span>            :     return LexerTransition&lt;State&gt;(aNextState, Nothing(), aSize,
<span class="lineNum">     161 </span>            :                                   BufferingStrategy::BUFFERED,
<span class="lineNum">     162 </span><span class="lineCov">         20 :                                   ControlFlowStrategy::CONTINUE);</span>
<span class="lineNum">     163 </span>            :   }
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :   /// Yield to the caller, transitioning to @aNextState when Lex() is next
<span class="lineNum">     166 </span>            :   /// invoked. The same data that was delivered for the current state will be
<span class="lineNum">     167 </span>            :   /// delivered again.
<a name="168"><span class="lineNum">     168 </span>            :   template &lt;typename State&gt;</a>
<span class="lineNum">     169 </span>            :   static LexerTransition&lt;State&gt;
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   ToAfterYield(const State&amp; aNextState)</span>
<span class="lineNum">     171 </span>            :   {
<span class="lineNum">     172 </span>            :     return LexerTransition&lt;State&gt;(aNextState, Nothing(), 0,
<span class="lineNum">     173 </span>            :                                   BufferingStrategy::BUFFERED,
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :                                   ControlFlowStrategy::YIELD);</span>
<span class="lineNum">     175 </span>            :   }
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   /**
<span class="lineNum">     178 </span>            :    * Transition to @aNextState via @aUnbufferedState, reading @aSize bytes of
<span class="lineNum">     179 </span>            :    * data unbuffered.
<span class="lineNum">     180 </span>            :    *
<span class="lineNum">     181 </span>            :    * The unbuffered data will be delivered in state @aUnbufferedState, which may
<span class="lineNum">     182 </span>            :    * be invoked repeatedly until all @aSize bytes have been delivered. Then,
<span class="lineNum">     183 </span>            :    * @aNextState will be invoked with no data. No state transitions are allowed
<span class="lineNum">     184 </span>            :    * from @aUnbufferedState except for transitions to a terminal state, so
<span class="lineNum">     185 </span>            :    * @aNextState will always be reached unless lexing terminates early.
<span class="lineNum">     186 </span>            :    */
<a name="187"><span class="lineNum">     187 </span>            :   template &lt;typename State&gt;</a>
<span class="lineNum">     188 </span>            :   static LexerTransition&lt;State&gt;
<span class="lineNum">     189 </span><span class="lineCov">         34 :   ToUnbuffered(const State&amp; aNextState,</span>
<span class="lineNum">     190 </span>            :                const State&amp; aUnbufferedState,
<span class="lineNum">     191 </span>            :                size_t aSize)
<span class="lineNum">     192 </span>            :   {
<span class="lineNum">     193 </span>            :     return LexerTransition&lt;State&gt;(aNextState, Some(aUnbufferedState), aSize,
<span class="lineNum">     194 </span>            :                                   BufferingStrategy::UNBUFFERED,
<span class="lineNum">     195 </span><span class="lineCov">         34 :                                   ControlFlowStrategy::CONTINUE);</span>
<span class="lineNum">     196 </span>            :   }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :   /**
<span class="lineNum">     199 </span>            :    * Continue receiving unbuffered data. @aUnbufferedState should be the same
<span class="lineNum">     200 </span>            :    * state as the @aUnbufferedState specified in the preceding call to
<span class="lineNum">     201 </span>            :    * ToUnbuffered().
<span class="lineNum">     202 </span>            :    *
<span class="lineNum">     203 </span>            :    * This should be used during an unbuffered read initiated by ToUnbuffered().
<span class="lineNum">     204 </span>            :    */
<a name="205"><span class="lineNum">     205 </span>            :   template &lt;typename State&gt;</a>
<span class="lineNum">     206 </span>            :   static LexerTransition&lt;State&gt;
<span class="lineNum">     207 </span><span class="lineCov">         99 :   ContinueUnbuffered(const State&amp; aUnbufferedState)</span>
<span class="lineNum">     208 </span>            :   {
<span class="lineNum">     209 </span>            :     return LexerTransition&lt;State&gt;(aUnbufferedState, Nothing(), 0,
<span class="lineNum">     210 </span>            :                                   BufferingStrategy::BUFFERED,
<span class="lineNum">     211 </span><span class="lineCov">         99 :                                   ControlFlowStrategy::CONTINUE);</span>
<span class="lineNum">     212 </span>            :   }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :   /**
<span class="lineNum">     215 </span>            :    * Continue receiving unbuffered data. @aUnbufferedState should be the same
<span class="lineNum">     216 </span>            :    * state as the @aUnbufferedState specified in the preceding call to
<span class="lineNum">     217 </span>            :    * ToUnbuffered(). @aSize indicates the amount of data that has already been
<span class="lineNum">     218 </span>            :    * consumed; the next state will receive the same data that was delivered to
<span class="lineNum">     219 </span>            :    * the current state, without the first @aSize bytes.
<span class="lineNum">     220 </span>            :    *
<span class="lineNum">     221 </span>            :    * This should be used during an unbuffered read initiated by ToUnbuffered().
<span class="lineNum">     222 </span>            :    */
<a name="223"><span class="lineNum">     223 </span>            :   template &lt;typename State&gt;</a>
<span class="lineNum">     224 </span>            :   static LexerTransition&lt;State&gt;
<span class="lineNum">     225 </span><span class="lineCov">         34 :   ContinueUnbufferedAfterYield(const State&amp; aUnbufferedState, size_t aSize)</span>
<span class="lineNum">     226 </span>            :   {
<span class="lineNum">     227 </span>            :     return LexerTransition&lt;State&gt;(aUnbufferedState, Nothing(), aSize,
<span class="lineNum">     228 </span>            :                                   BufferingStrategy::BUFFERED,
<span class="lineNum">     229 </span><span class="lineCov">         34 :                                   ControlFlowStrategy::YIELD);</span>
<span class="lineNum">     230 </span>            :   }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /**
<span class="lineNum">     233 </span>            :    * Terminate lexing, ending up in terminal state SUCCESS. (The implicit
<span class="lineNum">     234 </span>            :    * LexerTransition constructor will convert the result to a LexerTransition
<span class="lineNum">     235 </span>            :    * as needed.)
<span class="lineNum">     236 </span>            :    *
<span class="lineNum">     237 </span>            :    * No more data will be delivered after this function is used.
<a name="238"><span class="lineNum">     238 </span>            :    */</a>
<span class="lineNum">     239 </span>            :   static TerminalState
<span class="lineNum">     240 </span><span class="lineCov">         66 :   TerminateSuccess()</span>
<span class="lineNum">     241 </span>            :   {
<span class="lineNum">     242 </span><span class="lineCov">         66 :     return TerminalState::SUCCESS;</span>
<span class="lineNum">     243 </span>            :   }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /**
<span class="lineNum">     246 </span>            :    * Terminate lexing, ending up in terminal state FAILURE. (The implicit
<span class="lineNum">     247 </span>            :    * LexerTransition constructor will convert the result to a LexerTransition
<span class="lineNum">     248 </span>            :    * as needed.)
<span class="lineNum">     249 </span>            :    *
<span class="lineNum">     250 </span>            :    * No more data will be delivered after this function is used.
<a name="251"><span class="lineNum">     251 </span>            :    */</a>
<span class="lineNum">     252 </span>            :   static TerminalState
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   TerminateFailure()</span>
<span class="lineNum">     254 </span>            :   {
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :     return TerminalState::FAILURE;</span>
<span class="lineNum">     256 </span>            :   }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : private:
<span class="lineNum">     259 </span>            :   Transition();
<span class="lineNum">     260 </span>            : };
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /**
<span class="lineNum">     263 </span>            :  * StreamingLexer is a lexing framework designed to make it simple to write
<span class="lineNum">     264 </span>            :  * image decoders without worrying about the details of how the data is arriving
<span class="lineNum">     265 </span>            :  * from the network.
<span class="lineNum">     266 </span>            :  *
<span class="lineNum">     267 </span>            :  * To use StreamingLexer:
<span class="lineNum">     268 </span>            :  *
<span class="lineNum">     269 </span>            :  *  - Create a State type. This should be an |enum class| listing all of the
<span class="lineNum">     270 </span>            :  *    states that you can be in while lexing the image format you're trying to
<span class="lineNum">     271 </span>            :  *    read.
<span class="lineNum">     272 </span>            :  *
<span class="lineNum">     273 </span>            :  *  - Add an instance of StreamingLexer&lt;State&gt; to your decoder class. Initialize
<span class="lineNum">     274 </span>            :  *    it with a Transition::To() the state that you want to start lexing in, and
<span class="lineNum">     275 </span>            :  *    a Transition::To() the state you'd like to use to handle truncated data.
<span class="lineNum">     276 </span>            :  *
<span class="lineNum">     277 </span>            :  *  - In your decoder's DoDecode() method, call Lex(), passing in the input
<span class="lineNum">     278 </span>            :  *    data and length that are passed to DoDecode(). You also need to pass
<span class="lineNum">     279 </span>            :  *    a lambda which dispatches to lexing code for each state based on the State
<span class="lineNum">     280 </span>            :  *    value that's passed in. The lambda generally should just continue a
<span class="lineNum">     281 </span>            :  *    |switch| statement that calls different methods for each State value. Each
<span class="lineNum">     282 </span>            :  *    method should return a LexerTransition&lt;State&gt;, which the lambda should
<span class="lineNum">     283 </span>            :  *    return in turn.
<span class="lineNum">     284 </span>            :  *
<span class="lineNum">     285 </span>            :  *  - Write the methods that actually implement lexing for your image format.
<span class="lineNum">     286 </span>            :  *    These methods should return either Transition::To(), to move on to another
<span class="lineNum">     287 </span>            :  *    state, or Transition::Terminate{Success,Failure}(), if lexing has
<span class="lineNum">     288 </span>            :  *    terminated in either success or failure. (There are also additional
<span class="lineNum">     289 </span>            :  *    transitions for unbuffered reads; see below.)
<span class="lineNum">     290 </span>            :  *
<span class="lineNum">     291 </span>            :  * That's the basics. The StreamingLexer will track your position in the input
<span class="lineNum">     292 </span>            :  * and buffer enough data so that your lexing methods can process everything in
<span class="lineNum">     293 </span>            :  * one pass. Lex() returns Yield::NEED_MORE_DATA if more data is needed, in
<span class="lineNum">     294 </span>            :  * which case you should just return from DoDecode(). If lexing reaches a
<span class="lineNum">     295 </span>            :  * terminal state, Lex() returns TerminalState::SUCCESS or
<span class="lineNum">     296 </span>            :  * TerminalState::FAILURE, and you can check which one to determine if lexing
<span class="lineNum">     297 </span>            :  * succeeded or failed and do any necessary cleanup.
<span class="lineNum">     298 </span>            :  *
<span class="lineNum">     299 </span>            :  * Sometimes, the input data is truncated. StreamingLexer will notify you when
<span class="lineNum">     300 </span>            :  * this happens by invoking the truncated data state you passed to the
<span class="lineNum">     301 </span>            :  * constructor. At this point you can attempt to recover and return
<span class="lineNum">     302 </span>            :  * TerminalState::SUCCESS or TerminalState::FAILURE, depending on whether you
<span class="lineNum">     303 </span>            :  * were successful. Note that you can't return anything other than a terminal
<span class="lineNum">     304 </span>            :  * state in this situation, since there's no more data to read. For the same
<span class="lineNum">     305 </span>            :  * reason, your truncated data state shouldn't require any data. (That is, the
<span class="lineNum">     306 </span>            :  * @aSize argument you pass to Transition::To() must be zero.) Violating these
<span class="lineNum">     307 </span>            :  * requirements will trigger assertions and an immediate transition to
<span class="lineNum">     308 </span>            :  * TerminalState::FAILURE.
<span class="lineNum">     309 </span>            :  *
<span class="lineNum">     310 </span>            :  * Some lexers may want to *avoid* buffering in some cases, and just process the
<span class="lineNum">     311 </span>            :  * data as it comes in. This is useful if, for example, you just want to skip
<span class="lineNum">     312 </span>            :  * over a large section of data; there's no point in buffering data you're just
<span class="lineNum">     313 </span>            :  * going to ignore.
<span class="lineNum">     314 </span>            :  *
<span class="lineNum">     315 </span>            :  * You can begin an unbuffered read with Transition::ToUnbuffered(). This works
<span class="lineNum">     316 </span>            :  * a little differently than Transition::To() in that you specify *two* states.
<span class="lineNum">     317 </span>            :  * The @aUnbufferedState argument specifies a state that will be called
<span class="lineNum">     318 </span>            :  * repeatedly with unbuffered data, as soon as it arrives. The implementation
<span class="lineNum">     319 </span>            :  * for that state should return either a transition to a terminal state, or a
<span class="lineNum">     320 </span>            :  * Transition::ContinueUnbuffered() to the same @aUnbufferedState. (From a
<span class="lineNum">     321 </span>            :  * technical perspective, it's not necessary to specify the state again, but
<span class="lineNum">     322 </span>            :  * it's helpful to human readers.) Once the amount of data requested in the
<span class="lineNum">     323 </span>            :  * original call to Transition::ToUnbuffered() has been delivered, Lex() will
<span class="lineNum">     324 </span>            :  * transition to the @aNextState state specified via Transition::ToUnbuffered().
<span class="lineNum">     325 </span>            :  * That state will be invoked with *no* data; it's just called to signal that
<span class="lineNum">     326 </span>            :  * the unbuffered read is over.
<span class="lineNum">     327 </span>            :  *
<span class="lineNum">     328 </span>            :  * It's sometimes useful for a lexer to provide incremental results, rather
<span class="lineNum">     329 </span>            :  * than simply running to completion and presenting all its output at once. For
<span class="lineNum">     330 </span>            :  * example, when decoding animated images, it may be useful to produce each
<span class="lineNum">     331 </span>            :  * frame incrementally. StreamingLexer supports this by allowing a lexer to
<span class="lineNum">     332 </span>            :  * yield.
<span class="lineNum">     333 </span>            :  *
<span class="lineNum">     334 </span>            :  * To yield back to the caller, a state implementation can simply return
<span class="lineNum">     335 </span>            :  * Transition::ToAfterYield(). ToAfterYield()'s @aNextState argument specifies
<span class="lineNum">     336 </span>            :  * the next state that the lexer should transition to, just like when using
<span class="lineNum">     337 </span>            :  * Transition::To(), but there are two differences. One is that Lex() will
<span class="lineNum">     338 </span>            :  * return to the caller before processing any more data when it encounters a
<span class="lineNum">     339 </span>            :  * yield transition. This provides an opportunity for the caller to interact with the
<span class="lineNum">     340 </span>            :  * lexer's intermediate results. The second difference is that @aNextState
<span class="lineNum">     341 </span>            :  * will be called with *the same data as the state that you returned
<span class="lineNum">     342 </span>            :  * Transition::ToAfterYield() from*. This allows a lexer to partially consume
<span class="lineNum">     343 </span>            :  * the data, return intermediate results, and then finish consuming the data
<span class="lineNum">     344 </span>            :  * when @aNextState is called.
<span class="lineNum">     345 </span>            :  *
<span class="lineNum">     346 </span>            :  * It's also possible to yield during an unbuffered read. Just return a
<span class="lineNum">     347 </span>            :  * Transition::ContinueUnbufferedAfterYield(). Just like with
<span class="lineNum">     348 </span>            :  * Transition::ContinueUnbuffered(), the @aUnbufferedState must be the same as
<span class="lineNum">     349 </span>            :  * the one originally passed to Transition::ToUnbuffered(). The second argument,
<span class="lineNum">     350 </span>            :  * @aSize, specifies the amount of data that the lexer has already consumed.
<span class="lineNum">     351 </span>            :  * When @aUnbufferedState is next invoked, it will get the same data that it
<span class="lineNum">     352 </span>            :  * received previously, except that the first @aSize bytes will be excluded.
<span class="lineNum">     353 </span>            :  * This makes it easy to consume unbuffered data incrementally.
<span class="lineNum">     354 </span>            :  *
<span class="lineNum">     355 </span>            :  * XXX(seth): We should be able to get of the |State| stuff totally once bug
<span class="lineNum">     356 </span>            :  * 1198451 lands, since we can then just return a function representing the next
<span class="lineNum">     357 </span>            :  * state directly.
<a name="358"><span class="lineNum">     358 </span>            :  */</a>
<span class="lineNum">     359 </span>            : template &lt;typename State, size_t InlineBufferSize = 16&gt;
<span class="lineNum">     360 </span><span class="lineCov">         33 : class StreamingLexer</span>
<a name="361"><span class="lineNum">     361 </span>            : {</a>
<span class="lineNum">     362 </span>            : public:
<span class="lineNum">     363 </span><span class="lineCov">         33 :   StreamingLexer(const LexerTransition&lt;State&gt;&amp; aStartState,</span>
<span class="lineNum">     364 </span>            :                  const LexerTransition&lt;State&gt;&amp; aTruncatedState)
<span class="lineNum">     365 </span>            :     : mTransition(TerminalState::FAILURE)
<span class="lineNum">     366 </span><span class="lineCov">         33 :     , mTruncatedTransition(aTruncatedState)</span>
<span class="lineNum">     367 </span>            :   {
<span class="lineNum">     368 </span><span class="lineCov">         66 :     if (!aStartState.NextStateIsTerminal() &amp;&amp;</span>
<span class="lineNum">     369 </span><span class="lineCov">         33 :         aStartState.ControlFlow() == ControlFlowStrategy::YIELD) {</span>
<span class="lineNum">     370 </span>            :       // Allowing a StreamingLexer to start in a yield state doesn't make sense
<span class="lineNum">     371 </span>            :       // semantically (since yield states are supposed to deliver the same data
<span class="lineNum">     372 </span>            :       // as previous states, and there's no previous state here), but more
<span class="lineNum">     373 </span>            :       // importantly, it's necessary to advance a SourceBufferIterator at least
<span class="lineNum">     374 </span>            :       // once before you can read from it, and adding the necessary checks to
<span class="lineNum">     375 </span>            :       // Lex() to avoid that issue has the potential to mask real bugs. So
<span class="lineNum">     376 </span>            :       // instead, it's better to forbid starting in a yield state.
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;Starting in a yield state&quot;);</span>
<span class="lineNum">     378 </span>            :       return;
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">         33 :     if (!aTruncatedState.NextStateIsTerminal() &amp;&amp;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :           (aTruncatedState.ControlFlow() == ControlFlowStrategy::YIELD ||</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :            aTruncatedState.Buffering() == BufferingStrategy::UNBUFFERED ||</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :            aTruncatedState.Size() != 0)) {</span>
<span class="lineNum">     385 </span>            :       // The truncated state can't receive any data because, by definition,
<span class="lineNum">     386 </span>            :       // there is no more data to receive. That means that yielding or an
<span class="lineNum">     387 </span>            :       // unbuffered read would not make sense, and that the state must require
<span class="lineNum">     388 </span>            :       // zero bytes.
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;Truncated state makes no sense&quot;);</span>
<span class="lineNum">     390 </span>            :       return;
<span class="lineNum">     391 </span>            :     }
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineCov">         33 :     SetTransition(aStartState);</span>
<span class="lineNum">     394 </span><span class="lineCov">         33 :   }</span>
<a name="395"><span class="lineNum">     395 </span>            : </a>
<span class="lineNum">     396 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     397 </span><span class="lineCov">         67 :   LexerResult Lex(SourceBufferIterator&amp; aIterator,</span>
<span class="lineNum">     398 </span>            :                   IResumable* aOnResume,
<span class="lineNum">     399 </span>            :                   Func aFunc)
<span class="lineNum">     400 </span>            :   {
<span class="lineNum">     401 </span><span class="lineCov">         67 :     if (mTransition.NextStateIsTerminal()) {</span>
<span class="lineNum">     402 </span>            :       // We've already reached a terminal state. We never deliver any more data
<span class="lineNum">     403 </span>            :       // in this case; just return the terminal state again immediately.
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :       return LexerResult(mTransition.NextStateAsTerminal());</span>
<span class="lineNum">     405 </span>            :     }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">        134 :     Maybe&lt;LexerResult&gt; result;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :     // If the lexer requested a yield last time, we deliver the same data again
<span class="lineNum">     410 </span>            :     // before we read anything else from |aIterator|. Note that although to the
<span class="lineNum">     411 </span>            :     // callers of Lex(), Yield::NEED_MORE_DATA is just another type of yield,
<span class="lineNum">     412 </span>            :     // internally they're different in that we don't redeliver the same data in
<span class="lineNum">     413 </span>            :     // the Yield::NEED_MORE_DATA case, and |mYieldingToState| is not set. This
<span class="lineNum">     414 </span>            :     // means that for Yield::NEED_MORE_DATA, we go directly to the loop below.
<span class="lineNum">     415 </span><span class="lineCov">         67 :     if (mYieldingToState) {</span>
<span class="lineNum">     416 </span><span class="lineCov">         68 :       result = mTransition.Buffering() == BufferingStrategy::UNBUFFERED</span>
<span class="lineNum">     417 </span><span class="lineCov">         68 :              ? UnbufferedReadAfterYield(aIterator, aFunc)</span>
<span class="lineNum">     418 </span>            :              : BufferedReadAfterYield(aIterator, aFunc);
<span class="lineNum">     419 </span>            :     }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineCov">        181 :     while (!result) {</span>
<span class="lineNum">     422 </span><span class="lineCov">         57 :       MOZ_ASSERT_IF(mTransition.Buffering() == BufferingStrategy::UNBUFFERED,</span>
<span class="lineNum">     423 </span>            :                     mUnbufferedState);
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :       // Figure out how much we need to read.
<span class="lineNum">     426 </span><span class="lineCov">         57 :       const size_t toRead = mTransition.Buffering() == BufferingStrategy::UNBUFFERED</span>
<span class="lineNum">     427 </span><span class="lineCov">         77 :                           ? mUnbufferedState-&gt;mBytesRemaining</span>
<span class="lineNum">     428 </span><span class="lineCov">         77 :                           : mTransition.Size() - mBuffer.length();</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :       // Attempt to advance the iterator by |toRead| bytes.
<span class="lineNum">     431 </span><span class="lineCov">         57 :       switch (aIterator.AdvanceOrScheduleResume(toRead, aOnResume)) {</span>
<span class="lineNum">     432 </span>            :         case SourceBufferIterator::WAITING:
<span class="lineNum">     433 </span>            :           // We can't continue because the rest of the data hasn't arrived from
<span class="lineNum">     434 </span>            :           // the network yet. We don't have to do anything special; the
<span class="lineNum">     435 </span>            :           // SourceBufferIterator will ensure that |aOnResume| gets called when
<span class="lineNum">     436 </span>            :           // more data is available.
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :           result = Some(LexerResult(Yield::NEED_MORE_DATA));</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :         case SourceBufferIterator::COMPLETE:
<span class="lineNum">     441 </span>            :           // The data is truncated; if not, the lexer would've reached a
<span class="lineNum">     442 </span>            :           // terminal state by now. We only get to
<span class="lineNum">     443 </span>            :           // SourceBufferIterator::COMPLETE after every byte of data has been
<span class="lineNum">     444 </span>            :           // delivered to the lexer.
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :           result = Truncated(aIterator, aFunc);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :         case SourceBufferIterator::READY:
<span class="lineNum">     449 </span>            :           // Process the new data that became available.
<span class="lineNum">     450 </span><span class="lineCov">         57 :           MOZ_ASSERT(aIterator.Data());</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span><span class="lineCov">        114 :           result = mTransition.Buffering() == BufferingStrategy::UNBUFFERED</span>
<span class="lineNum">     453 </span><span class="lineCov">        114 :                  ? UnbufferedRead(aIterator, aFunc)</span>
<span class="lineNum">     454 </span>            :                  : BufferedRead(aIterator, aFunc);
<span class="lineNum">     455 </span><span class="lineCov">         57 :           break;</span>
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :         default:
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :           MOZ_ASSERT_UNREACHABLE(&quot;Unknown SourceBufferIterator state&quot;);</span>
<span class="lineNum">     459 </span>            :           result = SetTransition(Transition::TerminateFailure());
<span class="lineNum">     460 </span>            :       }
<span class="lineNum">     461 </span>            :     };
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineCov">         67 :     return *result;</span>
<span class="lineNum">     464 </span>            :   }
<span class="lineNum">     465 </span>            : 
<a name="466"><span class="lineNum">     466 </span>            : private:</a>
<span class="lineNum">     467 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     468 </span><span class="lineCov">         37 :   Maybe&lt;LexerResult&gt; UnbufferedRead(SourceBufferIterator&amp; aIterator, Func aFunc)</span>
<span class="lineNum">     469 </span>            :   {
<span class="lineNum">     470 </span><span class="lineCov">         37 :     MOZ_ASSERT(mTransition.Buffering() == BufferingStrategy::UNBUFFERED);</span>
<span class="lineNum">     471 </span><span class="lineCov">         37 :     MOZ_ASSERT(mUnbufferedState);</span>
<span class="lineNum">     472 </span><span class="lineCov">         37 :     MOZ_ASSERT(!mYieldingToState);</span>
<span class="lineNum">     473 </span><span class="lineCov">         37 :     MOZ_ASSERT(mBuffer.empty(),</span>
<span class="lineNum">     474 </span>            :                &quot;Buffered read at the same time as unbuffered read?&quot;);
<span class="lineNum">     475 </span><span class="lineCov">         37 :     MOZ_ASSERT(aIterator.Length() &lt;= mUnbufferedState-&gt;mBytesRemaining,</span>
<span class="lineNum">     476 </span>            :                &quot;Read too much data during unbuffered read?&quot;);
<span class="lineNum">     477 </span><span class="lineCov">         37 :     MOZ_ASSERT(mUnbufferedState-&gt;mBytesConsumedInCurrentChunk == 0,</span>
<span class="lineNum">     478 </span>            :                &quot;Already consumed data in the current chunk, but not yielding?&quot;);
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineCov">         37 :     if (mUnbufferedState-&gt;mBytesRemaining == 0) {</span>
<span class="lineNum">     481 </span>            :       // We're done with the unbuffered read, so transition to the next state.
<span class="lineNum">     482 </span><span class="lineCov">          3 :       return SetTransition(aFunc(mTransition.NextState(), nullptr, 0));</span>
<span class="lineNum">     483 </span>            :     }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :     return ContinueUnbufferedRead(aIterator.Data(), aIterator.Length(),
<span class="lineNum">     486 </span><span class="lineCov">         34 :                                   aIterator.Length(), aFunc);</span>
<span class="lineNum">     487 </span>            :   }
<a name="488"><span class="lineNum">     488 </span>            : </a>
<span class="lineNum">     489 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     490 </span><span class="lineCov">         34 :   Maybe&lt;LexerResult&gt; UnbufferedReadAfterYield(SourceBufferIterator&amp; aIterator, Func aFunc)</span>
<span class="lineNum">     491 </span>            :   {
<span class="lineNum">     492 </span><span class="lineCov">         34 :     MOZ_ASSERT(mTransition.Buffering() == BufferingStrategy::UNBUFFERED);</span>
<span class="lineNum">     493 </span><span class="lineCov">         34 :     MOZ_ASSERT(mUnbufferedState);</span>
<span class="lineNum">     494 </span><span class="lineCov">         34 :     MOZ_ASSERT(mYieldingToState);</span>
<span class="lineNum">     495 </span><span class="lineCov">         34 :     MOZ_ASSERT(mBuffer.empty(),</span>
<span class="lineNum">     496 </span>            :                &quot;Buffered read at the same time as unbuffered read?&quot;);
<span class="lineNum">     497 </span><span class="lineCov">         34 :     MOZ_ASSERT(aIterator.Length() &lt;= mUnbufferedState-&gt;mBytesRemaining,</span>
<span class="lineNum">     498 </span>            :                &quot;Read too much data during unbuffered read?&quot;);
<span class="lineNum">     499 </span><span class="lineCov">         34 :     MOZ_ASSERT(mUnbufferedState-&gt;mBytesConsumedInCurrentChunk &lt;= aIterator.Length(),</span>
<span class="lineNum">     500 </span>            :                &quot;Consumed more data than the current chunk holds?&quot;);
<span class="lineNum">     501 </span><span class="lineCov">         34 :     MOZ_ASSERT(mTransition.UnbufferedState() == *mYieldingToState);</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineCov">         34 :     mYieldingToState = Nothing();</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineCov">         34 :     if (mUnbufferedState-&gt;mBytesRemaining == 0) {</span>
<span class="lineNum">     506 </span>            :       // We're done with the unbuffered read, so transition to the next state.
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :       return SetTransition(aFunc(mTransition.NextState(), nullptr, 0));</span>
<span class="lineNum">     508 </span>            :     }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :     // Since we've yielded, we may have already consumed some data in this
<span class="lineNum">     511 </span>            :     // chunk. Make the necessary adjustments. (Note that the std::min call is
<span class="lineNum">     512 </span>            :     // just belt-and-suspenders to keep this code memory safe even if there's
<span class="lineNum">     513 </span>            :     // a bug somewhere.)
<span class="lineNum">     514 </span>            :     const size_t toSkip =
<span class="lineNum">     515 </span><span class="lineCov">         34 :       std::min(mUnbufferedState-&gt;mBytesConsumedInCurrentChunk, aIterator.Length());</span>
<span class="lineNum">     516 </span><span class="lineCov">         34 :     const char* data = aIterator.Data() + toSkip;</span>
<span class="lineNum">     517 </span><span class="lineCov">         34 :     const size_t length = aIterator.Length() - toSkip;</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :     // If |length| is zero, we've hit the end of the current chunk. This only
<span class="lineNum">     520 </span>            :     // happens if we yield right at the end of a chunk. Rather than call |aFunc|
<span class="lineNum">     521 </span>            :     // with a |length| of zero bytes (which seems potentially surprising to
<span class="lineNum">     522 </span>            :     // decoder authors), we go ahead and read more data.
<span class="lineNum">     523 </span><span class="lineCov">         34 :     if (length == 0) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       return FinishCurrentChunkOfUnbufferedRead(aIterator.Length());</span>
<span class="lineNum">     525 </span>            :     }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">         34 :     return ContinueUnbufferedRead(data, length, aIterator.Length(), aFunc);</span>
<span class="lineNum">     528 </span>            :   }
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     531 </span><span class="lineCov">         68 :   Maybe&lt;LexerResult&gt; ContinueUnbufferedRead(const char* aData,</span>
<span class="lineNum">     532 </span>            :                                             size_t aLength,
<span class="lineNum">     533 </span>            :                                             size_t aChunkLength,
<span class="lineNum">     534 </span>            :                                             Func aFunc)
<span class="lineNum">     535 </span>            :   {
<span class="lineNum">     536 </span>            :     // Call aFunc with the unbuffered state to indicate that we're in the
<span class="lineNum">     537 </span>            :     // middle of an unbuffered read. We enforce that any state transition
<span class="lineNum">     538 </span>            :     // passed back to us is either a terminal state or takes us back to the
<span class="lineNum">     539 </span>            :     // unbuffered state.
<span class="lineNum">     540 </span>            :     LexerTransition&lt;State&gt; unbufferedTransition =
<span class="lineNum">     541 </span><span class="lineCov">        136 :       aFunc(mTransition.UnbufferedState(), aData, aLength);</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :     // If we reached a terminal state, we're done.
<span class="lineNum">     544 </span><span class="lineCov">         68 :     if (unbufferedTransition.NextStateIsTerminal()) {</span>
<span class="lineNum">     545 </span><span class="lineCov">         31 :       return SetTransition(unbufferedTransition);</span>
<span class="lineNum">     546 </span>            :     }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineCov">         37 :     MOZ_ASSERT(mTransition.UnbufferedState() ==</span>
<span class="lineNum">     549 </span>            :                  unbufferedTransition.NextState());
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :     // Perform bookkeeping.
<span class="lineNum">     552 </span><span class="lineCov">         37 :     if (unbufferedTransition.ControlFlow() == ControlFlowStrategy::YIELD) {</span>
<span class="lineNum">     553 </span><span class="lineCov">         34 :       mUnbufferedState-&gt;mBytesConsumedInCurrentChunk += unbufferedTransition.Size();</span>
<span class="lineNum">     554 </span><span class="lineCov">         34 :       return SetTransition(unbufferedTransition);</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">          3 :     MOZ_ASSERT(unbufferedTransition.Size() == 0);</span>
<span class="lineNum">     558 </span><span class="lineCov">          3 :     return FinishCurrentChunkOfUnbufferedRead(aChunkLength);</span>
<a name="559"><span class="lineNum">     559 </span>            :   }</a>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineCov">          3 :   Maybe&lt;LexerResult&gt; FinishCurrentChunkOfUnbufferedRead(size_t aChunkLength)</span>
<span class="lineNum">     562 </span>            :   {
<span class="lineNum">     563 </span>            :     // We've finished an unbuffered read of a chunk of length |aChunkLength|, so
<span class="lineNum">     564 </span>            :     // update |myBytesRemaining| to reflect that we're |aChunkLength| closer to
<span class="lineNum">     565 </span>            :     // the end of the unbuffered read. (The std::min call is just
<span class="lineNum">     566 </span>            :     // belt-and-suspenders to keep this code memory safe even if there's a bug
<span class="lineNum">     567 </span>            :     // somewhere.)
<span class="lineNum">     568 </span><span class="lineCov">          3 :     mUnbufferedState-&gt;mBytesRemaining -=</span>
<span class="lineNum">     569 </span><span class="lineCov">          3 :       std::min(mUnbufferedState-&gt;mBytesRemaining, aChunkLength);</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :     // Since we're moving on to a new chunk, we can forget about the count of
<span class="lineNum">     572 </span>            :     // bytes consumed by yielding in the current chunk.
<span class="lineNum">     573 </span><span class="lineCov">          3 :     mUnbufferedState-&gt;mBytesConsumedInCurrentChunk = 0;</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">          3 :     return Nothing();  // Keep processing.</span>
<span class="lineNum">     576 </span>            :   }
<a name="577"><span class="lineNum">     577 </span>            : </a>
<span class="lineNum">     578 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     579 </span><span class="lineCov">         20 :   Maybe&lt;LexerResult&gt; BufferedRead(SourceBufferIterator&amp; aIterator, Func aFunc)</span>
<span class="lineNum">     580 </span>            :   {
<span class="lineNum">     581 </span><span class="lineCov">         20 :     MOZ_ASSERT(mTransition.Buffering() == BufferingStrategy::BUFFERED);</span>
<span class="lineNum">     582 </span><span class="lineCov">         20 :     MOZ_ASSERT(!mYieldingToState);</span>
<span class="lineNum">     583 </span><span class="lineCov">         20 :     MOZ_ASSERT(!mUnbufferedState,</span>
<span class="lineNum">     584 </span>            :                &quot;Buffered read at the same time as unbuffered read?&quot;);
<span class="lineNum">     585 </span><span class="lineCov">         20 :     MOZ_ASSERT(mBuffer.length() &lt; mTransition.Size() ||</span>
<span class="lineNum">     586 </span>            :                (mBuffer.length() == 0 &amp;&amp; mTransition.Size() == 0),
<span class="lineNum">     587 </span>            :                &quot;Buffered more than we needed?&quot;);
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :     // If we have all the data, we don't actually need to buffer anything.
<span class="lineNum">     590 </span><span class="lineCov">         20 :     if (mBuffer.empty() &amp;&amp; aIterator.Length() == mTransition.Size()) {</span>
<span class="lineNum">     591 </span>            :       return SetTransition(aFunc(mTransition.NextState(),
<span class="lineNum">     592 </span>            :                                  aIterator.Data(),
<span class="lineNum">     593 </span><span class="lineCov">         20 :                                  aIterator.Length()));</span>
<span class="lineNum">     594 </span>            :     }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :     // We do need to buffer, so make sure the buffer has enough capacity. We
<span class="lineNum">     597 </span>            :     // deliberately wait until we know for sure we need to buffer to call
<span class="lineNum">     598 </span>            :     // reserve() since it could require memory allocation.
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     if (!mBuffer.reserve(mTransition.Size())) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       return SetTransition(Transition::TerminateFailure());</span>
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     // Append the new data we just got to the buffer.
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     if (!mBuffer.append(aIterator.Data(), aIterator.Length())) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       return SetTransition(Transition::TerminateFailure());</span>
<span class="lineNum">     606 </span>            :     }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     if (mBuffer.length() != mTransition.Size()) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       return Nothing();  // Keep processing.</span>
<span class="lineNum">     610 </span>            :     }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :     // We've buffered everything, so transition to the next state.
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     return SetTransition(aFunc(mTransition.NextState(),</span>
<span class="lineNum">     614 </span>            :                                mBuffer.begin(),
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                                mBuffer.length()));</span>
<span class="lineNum">     616 </span>            :   }
<a name="617"><span class="lineNum">     617 </span>            : </a>
<span class="lineNum">     618 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   Maybe&lt;LexerResult&gt; BufferedReadAfterYield(SourceBufferIterator&amp; aIterator,</span>
<span class="lineNum">     620 </span>            :                                             Func aFunc)
<span class="lineNum">     621 </span>            :   {
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mTransition.Buffering() == BufferingStrategy::BUFFERED);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mYieldingToState);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!mUnbufferedState,</span>
<span class="lineNum">     625 </span>            :                &quot;Buffered read at the same time as unbuffered read?&quot;);
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mBuffer.length() &lt;= mTransition.Size(),</span>
<span class="lineNum">     627 </span>            :                &quot;Buffered more than we needed?&quot;);
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     State nextState = Move(*mYieldingToState);</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :     // After a yield, we need to take the same data that we delivered to the
<span class="lineNum">     632 </span>            :     // last state, and deliver it again to the new state. We know that this is
<span class="lineNum">     633 </span>            :     // happening right at a state transition, and that the last state was a
<span class="lineNum">     634 </span>            :     // buffered read, so there are two cases:
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :     // 1. We got the data from the SourceBufferIterator directly.
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     if (mBuffer.empty() &amp;&amp; aIterator.Length() == mTransition.Size()) {</span>
<span class="lineNum">     638 </span>            :       return SetTransition(aFunc(nextState,
<span class="lineNum">     639 </span>            :                                  aIterator.Data(),
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                                  aIterator.Length()));</span>
<span class="lineNum">     641 </span>            :     }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :     // 2. We got the data from the buffer.
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     if (mBuffer.length() == mTransition.Size()) {</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       return SetTransition(aFunc(nextState,</span>
<span class="lineNum">     646 </span>            :                                  mBuffer.begin(),
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :                                  mBuffer.length()));</span>
<span class="lineNum">     648 </span>            :     }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :     // Anything else indicates a bug.
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     MOZ_ASSERT_UNREACHABLE(&quot;Unexpected state encountered during yield&quot;);</span>
<span class="lineNum">     652 </span>            :     return SetTransition(Transition::TerminateFailure());
<span class="lineNum">     653 </span>            :   }
<a name="654"><span class="lineNum">     654 </span>            : </a>
<span class="lineNum">     655 </span>            :   template &lt;typename Func&gt;
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   Maybe&lt;LexerResult&gt; Truncated(SourceBufferIterator&amp; aIterator,</span>
<span class="lineNum">     657 </span>            :                                Func aFunc)
<span class="lineNum">     658 </span>            :   {
<span class="lineNum">     659 </span>            :     // The data is truncated. Let the lexer clean up and decide which terminal
<span class="lineNum">     660 </span>            :     // state we should end up in.
<span class="lineNum">     661 </span>            :     LexerTransition&lt;State&gt; transition
<span class="lineNum">     662 </span>            :       = mTruncatedTransition.NextStateIsTerminal()
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :       ? mTruncatedTransition</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       : aFunc(mTruncatedTransition.NextState(), nullptr, 0);</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     if (!transition.NextStateIsTerminal()) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;Truncated state didn't lead to terminal state?&quot;);</span>
<span class="lineNum">     668 </span>            :       return SetTransition(Transition::TerminateFailure());
<span class="lineNum">     669 </span>            :     }
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            :     // If the SourceBuffer was completed with a failing state, we end in
<span class="lineNum">     672 </span>            :     // TerminalState::FAILURE no matter what. This only happens in exceptional
<span class="lineNum">     673 </span>            :     // situations like SourceBuffer itself encountering a failure due to OOM.
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     if (NS_FAILED(aIterator.CompletionStatus())) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       return SetTransition(Transition::TerminateFailure());</span>
<span class="lineNum">     676 </span>            :     }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     return SetTransition(transition);</span>
<a name="679"><span class="lineNum">     679 </span>            :   }</a>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineCov">        121 :   Maybe&lt;LexerResult&gt; SetTransition(const LexerTransition&lt;State&gt;&amp; aTransition)</span>
<span class="lineNum">     682 </span>            :   {
<span class="lineNum">     683 </span>            :     // There should be no transitions while we're buffering for a buffered read
<span class="lineNum">     684 </span>            :     // unless they're to terminal states. (The terminal state transitions would
<span class="lineNum">     685 </span>            :     // generally be triggered by error handling code.)
<span class="lineNum">     686 </span><span class="lineCov">        121 :     MOZ_ASSERT_IF(!mBuffer.empty(),</span>
<span class="lineNum">     687 </span>            :                   aTransition.NextStateIsTerminal() ||
<span class="lineNum">     688 </span>            :                   mBuffer.length() == mTransition.Size());
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :     // Similarly, the only transitions allowed in the middle of an unbuffered
<span class="lineNum">     691 </span>            :     // read are to a terminal state, or a yield to the same state. Otherwise, we
<span class="lineNum">     692 </span>            :     // should remain in the same state until the unbuffered read completes.
<span class="lineNum">     693 </span><span class="lineCov">        121 :     MOZ_ASSERT_IF(mUnbufferedState,</span>
<span class="lineNum">     694 </span>            :                   aTransition.NextStateIsTerminal() ||
<span class="lineNum">     695 </span>            :                   (aTransition.ControlFlow() == ControlFlowStrategy::YIELD &amp;&amp;
<span class="lineNum">     696 </span>            :                    aTransition.NextState() == mTransition.UnbufferedState()) ||
<span class="lineNum">     697 </span>            :                   mUnbufferedState-&gt;mBytesRemaining == 0);
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :     // If this transition is a yield, save the next state and return. We'll
<span class="lineNum">     700 </span>            :     // handle the rest when Lex() gets called again.
<span class="lineNum">     701 </span><span class="lineCov">        209 :     if (!aTransition.NextStateIsTerminal() &amp;&amp;</span>
<span class="lineNum">     702 </span><span class="lineCov">         88 :         aTransition.ControlFlow() == ControlFlowStrategy::YIELD) {</span>
<span class="lineNum">     703 </span><span class="lineCov">         34 :       mYieldingToState = Some(aTransition.NextState());</span>
<span class="lineNum">     704 </span><span class="lineCov">         34 :       return Some(LexerResult(Yield::OUTPUT_AVAILABLE));</span>
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :     // Update our transition.
<span class="lineNum">     708 </span><span class="lineCov">         87 :     mTransition = aTransition;</span>
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :     // Get rid of anything left over from the previous state.
<span class="lineNum">     711 </span><span class="lineCov">         87 :     mBuffer.clear();</span>
<span class="lineNum">     712 </span><span class="lineCov">         87 :     mYieldingToState = Nothing();</span>
<span class="lineNum">     713 </span><span class="lineCov">         87 :     mUnbufferedState = Nothing();</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     // If we reached a terminal state, let the caller know.
<span class="lineNum">     716 </span><span class="lineCov">         87 :     if (mTransition.NextStateIsTerminal()) {</span>
<span class="lineNum">     717 </span><span class="lineCov">         33 :       return Some(LexerResult(mTransition.NextStateAsTerminal()));</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     // If we're entering an unbuffered state, record how long we'll stay in it.
<span class="lineNum">     721 </span><span class="lineCov">         54 :     if (mTransition.Buffering() == BufferingStrategy::UNBUFFERED) {</span>
<span class="lineNum">     722 </span><span class="lineCov">         34 :       mUnbufferedState.emplace(mTransition.Size());</span>
<span class="lineNum">     723 </span>            :     }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">         54 :     return Nothing();  // Keep processing.</span>
<span class="lineNum">     726 </span>            :   }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   // State that tracks our position within an unbuffered read.
<a name="729"><span class="lineNum">     729 </span>            :   struct UnbufferedState</a>
<span class="lineNum">     730 </span>            :   {
<span class="lineNum">     731 </span><span class="lineCov">         34 :     explicit UnbufferedState(size_t aBytesRemaining)</span>
<span class="lineNum">     732 </span>            :       : mBytesRemaining(aBytesRemaining)
<span class="lineNum">     733 </span><span class="lineCov">         34 :       , mBytesConsumedInCurrentChunk(0)</span>
<span class="lineNum">     734 </span><span class="lineCov">         34 :     { }</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :     size_t mBytesRemaining;
<span class="lineNum">     737 </span>            :     size_t mBytesConsumedInCurrentChunk;
<span class="lineNum">     738 </span>            :   };
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :   Vector&lt;char, InlineBufferSize&gt; mBuffer;
<span class="lineNum">     741 </span>            :   LexerTransition&lt;State&gt; mTransition;
<span class="lineNum">     742 </span>            :   const LexerTransition&lt;State&gt; mTruncatedTransition;
<span class="lineNum">     743 </span>            :   Maybe&lt;State&gt; mYieldingToState;
<span class="lineNum">     744 </span>            :   Maybe&lt;UnbufferedState&gt; mUnbufferedState;
<span class="lineNum">     745 </span>            : };
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : } // namespace image
<span class="lineNum">     748 </span>            : } // namespace mozilla
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : #endif // mozilla_image_StreamingLexer_h
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

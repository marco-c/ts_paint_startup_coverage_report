<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - tools/profiler/lul/LulDwarfExt.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">tools/profiler/lul</a> - LulDwarfExt.h<span style="font-size: 80%;"> (source / <a href="LulDwarfExt.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">113</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : // Copyright 2006, 2010 Google Inc. All Rights Reserved.
<span class="lineNum">       5 </span>            : //
<span class="lineNum">       6 </span>            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       7 </span>            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       8 </span>            : // met:
<span class="lineNum">       9 </span>            : //
<span class="lineNum">      10 </span>            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">      11 </span>            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      12 </span>            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      13 </span>            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      14 </span>            : // in the documentation and/or other materials provided with the
<span class="lineNum">      15 </span>            : // distribution.
<span class="lineNum">      16 </span>            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      17 </span>            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      18 </span>            : // this software without specific prior written permission.
<span class="lineNum">      19 </span>            : //
<span class="lineNum">      20 </span>            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      21 </span>            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      22 </span>            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      23 </span>            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      24 </span>            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      25 </span>            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      26 </span>            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      27 </span>            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      28 </span>            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      29 </span>            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      30 </span>            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : // Original author: Jim Blandy &lt;jimb@mozilla.com&gt; &lt;jimb@red-bean.com&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : // This file is derived from the following files in
<span class="lineNum">      35 </span>            : // toolkit/crashreporter/google-breakpad:
<span class="lineNum">      36 </span>            : //   src/common/dwarf/types.h
<span class="lineNum">      37 </span>            : //   src/common/dwarf/dwarf2enums.h
<span class="lineNum">      38 </span>            : //   src/common/dwarf/bytereader.h
<span class="lineNum">      39 </span>            : //   src/common/dwarf_cfi_to_module.h
<span class="lineNum">      40 </span>            : //   src/common/dwarf/dwarf2reader.h
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #ifndef LulDwarfExt_h
<span class="lineNum">      43 </span>            : #define LulDwarfExt_h
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #include &quot;LulDwarfSummariser.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : typedef signed char         int8;
<span class="lineNum">      52 </span>            : typedef short               int16;
<span class="lineNum">      53 </span>            : typedef int                 int32;
<span class="lineNum">      54 </span>            : typedef long long           int64;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : typedef unsigned char      uint8;
<span class="lineNum">      57 </span>            : typedef unsigned short     uint16;
<span class="lineNum">      58 </span>            : typedef unsigned int       uint32;
<span class="lineNum">      59 </span>            : typedef unsigned long long uint64;
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : #ifdef __PTRDIFF_TYPE__
<span class="lineNum">      62 </span>            : typedef          __PTRDIFF_TYPE__ intptr;
<span class="lineNum">      63 </span>            : typedef unsigned __PTRDIFF_TYPE__ uintptr;
<span class="lineNum">      64 </span>            : #else
<span class="lineNum">      65 </span>            : #error &quot;Can't find pointer-sized integral types.&quot;
<span class="lineNum">      66 </span>            : #endif
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : namespace lul {
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : // Exception handling frame description pointer formats, as described
<span class="lineNum">      72 </span>            : // by the Linux Standard Base Core Specification 4.0, section 11.5,
<span class="lineNum">      73 </span>            : // DWARF Extensions.
<span class="lineNum">      74 </span>            : enum DwarfPointerEncoding
<span class="lineNum">      75 </span>            :   {
<span class="lineNum">      76 </span>            :     DW_EH_PE_absptr     = 0x00,
<span class="lineNum">      77 </span>            :     DW_EH_PE_omit       = 0xff,
<span class="lineNum">      78 </span>            :     DW_EH_PE_uleb128    = 0x01,
<span class="lineNum">      79 </span>            :     DW_EH_PE_udata2     = 0x02,
<span class="lineNum">      80 </span>            :     DW_EH_PE_udata4     = 0x03,
<span class="lineNum">      81 </span>            :     DW_EH_PE_udata8     = 0x04,
<span class="lineNum">      82 </span>            :     DW_EH_PE_sleb128    = 0x09,
<span class="lineNum">      83 </span>            :     DW_EH_PE_sdata2     = 0x0A,
<span class="lineNum">      84 </span>            :     DW_EH_PE_sdata4     = 0x0B,
<span class="lineNum">      85 </span>            :     DW_EH_PE_sdata8     = 0x0C,
<span class="lineNum">      86 </span>            :     DW_EH_PE_pcrel      = 0x10,
<span class="lineNum">      87 </span>            :     DW_EH_PE_textrel    = 0x20,
<span class="lineNum">      88 </span>            :     DW_EH_PE_datarel    = 0x30,
<span class="lineNum">      89 </span>            :     DW_EH_PE_funcrel    = 0x40,
<span class="lineNum">      90 </span>            :     DW_EH_PE_aligned    = 0x50,
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :     // The GNU toolchain sources define this enum value as well,
<span class="lineNum">      93 </span>            :     // simply to help classify the lower nybble values into signed and
<span class="lineNum">      94 </span>            :     // unsigned groups.
<span class="lineNum">      95 </span>            :     DW_EH_PE_signed     = 0x08,
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :     // This is not documented in LSB 4.0, but it is used in both the
<span class="lineNum">      98 </span>            :     // Linux and OS X toolchains. It can be added to any other
<span class="lineNum">      99 </span>            :     // encoding (except DW_EH_PE_aligned), and indicates that the
<span class="lineNum">     100 </span>            :     // encoded value represents the address at which the true address
<span class="lineNum">     101 </span>            :     // is stored, not the true address itself.
<span class="lineNum">     102 </span>            :     DW_EH_PE_indirect   = 0x80
<span class="lineNum">     103 </span>            :   };
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : // We can't use the obvious name of LITTLE_ENDIAN and BIG_ENDIAN
<span class="lineNum">     107 </span>            : // because it conflicts with a macro
<span class="lineNum">     108 </span>            : enum Endianness {
<span class="lineNum">     109 </span>            :   ENDIANNESS_BIG,
<span class="lineNum">     110 </span>            :   ENDIANNESS_LITTLE
<span class="lineNum">     111 </span>            : };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : // A ByteReader knows how to read single- and multi-byte values of
<span class="lineNum">     114 </span>            : // various endiannesses, sizes, and encodings, as used in DWARF
<span class="lineNum">     115 </span>            : // debugging information and Linux C++ exception handling data.
<span class="lineNum">     116 </span>            : class ByteReader {
<span class="lineNum">     117 </span>            :  public:
<span class="lineNum">     118 </span>            :   // Construct a ByteReader capable of reading one-, two-, four-, and
<span class="lineNum">     119 </span>            :   // eight-byte values according to ENDIANNESS, absolute machine-sized
<span class="lineNum">     120 </span>            :   // addresses, DWARF-style &quot;initial length&quot; values, signed and
<span class="lineNum">     121 </span>            :   // unsigned LEB128 numbers, and Linux C++ exception handling data's
<span class="lineNum">     122 </span>            :   // encoded pointers.
<span class="lineNum">     123 </span>            :   explicit ByteReader(enum Endianness endianness);
<span class="lineNum">     124 </span>            :   virtual ~ByteReader();
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   // Read a single byte from BUFFER and return it as an unsigned 8 bit
<span class="lineNum">     127 </span>            :   // number.
<span class="lineNum">     128 </span>            :   uint8 ReadOneByte(const char* buffer) const;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :   // Read two bytes from BUFFER and return them as an unsigned 16 bit
<span class="lineNum">     131 </span>            :   // number, using this ByteReader's endianness.
<span class="lineNum">     132 </span>            :   uint16 ReadTwoBytes(const char* buffer) const;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   // Read four bytes from BUFFER and return them as an unsigned 32 bit
<span class="lineNum">     135 </span>            :   // number, using this ByteReader's endianness. This function returns
<span class="lineNum">     136 </span>            :   // a uint64 so that it is compatible with ReadAddress and
<span class="lineNum">     137 </span>            :   // ReadOffset. The number it returns will never be outside the range
<span class="lineNum">     138 </span>            :   // of an unsigned 32 bit integer.
<span class="lineNum">     139 </span>            :   uint64 ReadFourBytes(const char* buffer) const;
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :   // Read eight bytes from BUFFER and return them as an unsigned 64
<span class="lineNum">     142 </span>            :   // bit number, using this ByteReader's endianness.
<span class="lineNum">     143 </span>            :   uint64 ReadEightBytes(const char* buffer) const;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   // Read an unsigned LEB128 (Little Endian Base 128) number from
<span class="lineNum">     146 </span>            :   // BUFFER and return it as an unsigned 64 bit integer. Set LEN to
<span class="lineNum">     147 </span>            :   // the number of bytes read.
<span class="lineNum">     148 </span>            :   //
<span class="lineNum">     149 </span>            :   // The unsigned LEB128 representation of an integer N is a variable
<span class="lineNum">     150 </span>            :   // number of bytes:
<span class="lineNum">     151 </span>            :   //
<span class="lineNum">     152 </span>            :   // - If N is between 0 and 0x7f, then its unsigned LEB128
<span class="lineNum">     153 </span>            :   //   representation is a single byte whose value is N.
<span class="lineNum">     154 </span>            :   //
<span class="lineNum">     155 </span>            :   // - Otherwise, its unsigned LEB128 representation is (N &amp; 0x7f) |
<span class="lineNum">     156 </span>            :   //   0x80, followed by the unsigned LEB128 representation of N /
<span class="lineNum">     157 </span>            :   //   128, rounded towards negative infinity.
<span class="lineNum">     158 </span>            :   //
<span class="lineNum">     159 </span>            :   // In other words, we break VALUE into groups of seven bits, put
<span class="lineNum">     160 </span>            :   // them in little-endian order, and then write them as eight-bit
<span class="lineNum">     161 </span>            :   // bytes with the high bit on all but the last.
<span class="lineNum">     162 </span>            :   uint64 ReadUnsignedLEB128(const char* buffer, size_t* len) const;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   // Read a signed LEB128 number from BUFFER and return it as an
<span class="lineNum">     165 </span>            :   // signed 64 bit integer. Set LEN to the number of bytes read.
<span class="lineNum">     166 </span>            :   //
<span class="lineNum">     167 </span>            :   // The signed LEB128 representation of an integer N is a variable
<span class="lineNum">     168 </span>            :   // number of bytes:
<span class="lineNum">     169 </span>            :   //
<span class="lineNum">     170 </span>            :   // - If N is between -0x40 and 0x3f, then its signed LEB128
<span class="lineNum">     171 </span>            :   //   representation is a single byte whose value is N in two's
<span class="lineNum">     172 </span>            :   //   complement.
<span class="lineNum">     173 </span>            :   //
<span class="lineNum">     174 </span>            :   // - Otherwise, its signed LEB128 representation is (N &amp; 0x7f) |
<span class="lineNum">     175 </span>            :   //   0x80, followed by the signed LEB128 representation of N / 128,
<span class="lineNum">     176 </span>            :   //   rounded towards negative infinity.
<span class="lineNum">     177 </span>            :   //
<span class="lineNum">     178 </span>            :   // In other words, we break VALUE into groups of seven bits, put
<span class="lineNum">     179 </span>            :   // them in little-endian order, and then write them as eight-bit
<span class="lineNum">     180 </span>            :   // bytes with the high bit on all but the last.
<span class="lineNum">     181 </span>            :   int64 ReadSignedLEB128(const char* buffer, size_t* len) const;
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :   // Indicate that addresses on this architecture are SIZE bytes long. SIZE
<span class="lineNum">     184 </span>            :   // must be either 4 or 8. (DWARF allows addresses to be any number of
<span class="lineNum">     185 </span>            :   // bytes in length from 1 to 255, but we only support 32- and 64-bit
<span class="lineNum">     186 </span>            :   // addresses at the moment.) You must call this before using the
<span class="lineNum">     187 </span>            :   // ReadAddress member function.
<span class="lineNum">     188 </span>            :   //
<span class="lineNum">     189 </span>            :   // For data in a .debug_info section, or something that .debug_info
<span class="lineNum">     190 </span>            :   // refers to like line number or macro data, the compilation unit
<span class="lineNum">     191 </span>            :   // header's address_size field indicates the address size to use. Call
<span class="lineNum">     192 </span>            :   // frame information doesn't indicate its address size (a shortcoming of
<span class="lineNum">     193 </span>            :   // the spec); you must supply the appropriate size based on the
<span class="lineNum">     194 </span>            :   // architecture of the target machine.
<span class="lineNum">     195 </span>            :   void SetAddressSize(uint8 size);
<span class="lineNum">     196 </span>            : 
<a name="197"><span class="lineNum">     197 </span>            :   // Return the current address size, in bytes. This is either 4,</a>
<span class="lineNum">     198 </span>            :   // indicating 32-bit addresses, or 8, indicating 64-bit addresses.
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   uint8 AddressSize() const { return address_size_; }</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :   // Read an address from BUFFER and return it as an unsigned 64 bit
<span class="lineNum">     202 </span>            :   // integer, respecting this ByteReader's endianness and address size. You
<span class="lineNum">     203 </span>            :   // must call SetAddressSize before calling this function.
<span class="lineNum">     204 </span>            :   uint64 ReadAddress(const char* buffer) const;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   // DWARF actually defines two slightly different formats: 32-bit DWARF
<span class="lineNum">     207 </span>            :   // and 64-bit DWARF. This is *not* related to the size of registers or
<span class="lineNum">     208 </span>            :   // addresses on the target machine; it refers only to the size of section
<span class="lineNum">     209 </span>            :   // offsets and data lengths appearing in the DWARF data. One only needs
<span class="lineNum">     210 </span>            :   // 64-bit DWARF when the debugging data itself is larger than 4GiB.
<span class="lineNum">     211 </span>            :   // 32-bit DWARF can handle x86_64 or PPC64 code just fine, unless the
<span class="lineNum">     212 </span>            :   // debugging data itself is very large.
<span class="lineNum">     213 </span>            :   //
<span class="lineNum">     214 </span>            :   // DWARF information identifies itself as 32-bit or 64-bit DWARF: each
<span class="lineNum">     215 </span>            :   // compilation unit and call frame information entry begins with an
<span class="lineNum">     216 </span>            :   // &quot;initial length&quot; field, which, in addition to giving the length of the
<span class="lineNum">     217 </span>            :   // data, also indicates the size of section offsets and lengths appearing
<span class="lineNum">     218 </span>            :   // in that data. The ReadInitialLength member function, below, reads an
<span class="lineNum">     219 </span>            :   // initial length and sets the ByteReader's offset size as a side effect.
<span class="lineNum">     220 </span>            :   // Thus, in the normal process of reading DWARF data, the appropriate
<span class="lineNum">     221 </span>            :   // offset size is set automatically. So, you should only need to call
<span class="lineNum">     222 </span>            :   // SetOffsetSize if you are using the same ByteReader to jump from the
<span class="lineNum">     223 </span>            :   // midst of one block of DWARF data into another.
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   // Read a DWARF &quot;initial length&quot; field from START, and return it as
<span class="lineNum">     226 </span>            :   // an unsigned 64 bit integer, respecting this ByteReader's
<span class="lineNum">     227 </span>            :   // endianness. Set *LEN to the length of the initial length in
<span class="lineNum">     228 </span>            :   // bytes, either four or twelve. As a side effect, set this
<span class="lineNum">     229 </span>            :   // ByteReader's offset size to either 4 (if we see a 32-bit DWARF
<span class="lineNum">     230 </span>            :   // initial length) or 8 (if we see a 64-bit DWARF initial length).
<span class="lineNum">     231 </span>            :   //
<span class="lineNum">     232 </span>            :   // A DWARF initial length is either:
<span class="lineNum">     233 </span>            :   //
<span class="lineNum">     234 </span>            :   // - a byte count stored as an unsigned 32-bit value less than
<span class="lineNum">     235 </span>            :   //   0xffffff00, indicating that the data whose length is being
<span class="lineNum">     236 </span>            :   //   measured uses the 32-bit DWARF format, or
<span class="lineNum">     237 </span>            :   //
<span class="lineNum">     238 </span>            :   // - The 32-bit value 0xffffffff, followed by a 64-bit byte count,
<span class="lineNum">     239 </span>            :   //   indicating that the data whose length is being measured uses
<span class="lineNum">     240 </span>            :   //   the 64-bit DWARF format.
<span class="lineNum">     241 </span>            :   uint64 ReadInitialLength(const char* start, size_t* len);
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   // Read an offset from BUFFER and return it as an unsigned 64 bit
<span class="lineNum">     244 </span>            :   // integer, respecting the ByteReader's endianness. In 32-bit DWARF, the
<span class="lineNum">     245 </span>            :   // offset is 4 bytes long; in 64-bit DWARF, the offset is eight bytes
<span class="lineNum">     246 </span>            :   // long. You must call ReadInitialLength or SetOffsetSize before calling
<span class="lineNum">     247 </span>            :   // this function; see the comments above for details.
<span class="lineNum">     248 </span>            :   uint64 ReadOffset(const char* buffer) const;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            :   // Return the current offset size, in bytes.
<a name="251"><span class="lineNum">     251 </span>            :   // A return value of 4 indicates that we are reading 32-bit DWARF.</a>
<span class="lineNum">     252 </span>            :   // A return value of 8 indicates that we are reading 64-bit DWARF.
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :   uint8 OffsetSize() const { return offset_size_; }</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   // Indicate that section offsets and lengths are SIZE bytes long. SIZE
<span class="lineNum">     256 </span>            :   // must be either 4 (meaning 32-bit DWARF) or 8 (meaning 64-bit DWARF).
<span class="lineNum">     257 </span>            :   // Usually, you should not call this function yourself; instead, let a
<span class="lineNum">     258 </span>            :   // call to ReadInitialLength establish the data's offset size
<span class="lineNum">     259 </span>            :   // automatically.
<span class="lineNum">     260 </span>            :   void SetOffsetSize(uint8 size);
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   // The Linux C++ ABI uses a variant of DWARF call frame information
<span class="lineNum">     263 </span>            :   // for exception handling. This data is included in the program's
<span class="lineNum">     264 </span>            :   // address space as the &quot;.eh_frame&quot; section, and intepreted at
<span class="lineNum">     265 </span>            :   // runtime to walk the stack, find exception handlers, and run
<span class="lineNum">     266 </span>            :   // cleanup code. The format is mostly the same as DWARF CFI, with
<span class="lineNum">     267 </span>            :   // some adjustments made to provide the additional
<span class="lineNum">     268 </span>            :   // exception-handling data, and to make the data easier to work with
<span class="lineNum">     269 </span>            :   // in memory --- for example, to allow it to be placed in read-only
<span class="lineNum">     270 </span>            :   // memory even when describing position-independent code.
<span class="lineNum">     271 </span>            :   //
<span class="lineNum">     272 </span>            :   // In particular, exception handling data can select a number of
<span class="lineNum">     273 </span>            :   // different encodings for pointers that appear in the data, as
<span class="lineNum">     274 </span>            :   // described by the DwarfPointerEncoding enum. There are actually
<span class="lineNum">     275 </span>            :   // four axes(!) to the encoding:
<span class="lineNum">     276 </span>            :   //
<span class="lineNum">     277 </span>            :   // - The pointer size: pointers can be 2, 4, or 8 bytes long, or use
<span class="lineNum">     278 </span>            :   //   the DWARF LEB128 encoding.
<span class="lineNum">     279 </span>            :   //
<span class="lineNum">     280 </span>            :   // - The pointer's signedness: pointers can be signed or unsigned.
<span class="lineNum">     281 </span>            :   //
<span class="lineNum">     282 </span>            :   // - The pointer's base address: the data stored in the exception
<span class="lineNum">     283 </span>            :   //   handling data can be the actual address (that is, an absolute
<span class="lineNum">     284 </span>            :   //   pointer), or relative to one of a number of different base
<span class="lineNum">     285 </span>            :   //   addreses --- including that of the encoded pointer itself, for
<span class="lineNum">     286 </span>            :   //   a form of &quot;pc-relative&quot; addressing.
<span class="lineNum">     287 </span>            :   //
<span class="lineNum">     288 </span>            :   // - The pointer may be indirect: it may be the address where the
<span class="lineNum">     289 </span>            :   //   true pointer is stored. (This is used to refer to things via
<span class="lineNum">     290 </span>            :   //   global offset table entries, program linkage table entries, or
<span class="lineNum">     291 </span>            :   //   other tricks used in position-independent code.)
<span class="lineNum">     292 </span>            :   //
<span class="lineNum">     293 </span>            :   // There are also two options that fall outside that matrix
<span class="lineNum">     294 </span>            :   // altogether: the pointer may be omitted, or it may have padding to
<span class="lineNum">     295 </span>            :   // align it on an appropriate address boundary. (That last option
<span class="lineNum">     296 </span>            :   // may seem like it should be just another axis, but it is not.)
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :   // Indicate that the exception handling data is loaded starting at
<span class="lineNum">     299 </span>            :   // SECTION_BASE, and that the start of its buffer in our own memory
<span class="lineNum">     300 </span>            :   // is BUFFER_BASE. This allows us to find the address that a given
<span class="lineNum">     301 </span>            :   // byte in our buffer would have when loaded into the program the
<span class="lineNum">     302 </span>            :   // data describes. We need this to resolve DW_EH_PE_pcrel pointers.
<span class="lineNum">     303 </span>            :   void SetCFIDataBase(uint64 section_base, const char *buffer_base);
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   // Indicate that the base address of the program's &quot;.text&quot; section
<span class="lineNum">     306 </span>            :   // is TEXT_BASE. We need this to resolve DW_EH_PE_textrel pointers.
<span class="lineNum">     307 </span>            :   void SetTextBase(uint64 text_base);
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :   // Indicate that the base address for DW_EH_PE_datarel pointers is
<span class="lineNum">     310 </span>            :   // DATA_BASE. The proper value depends on the ABI; it is usually the
<span class="lineNum">     311 </span>            :   // address of the global offset table, held in a designated register in
<span class="lineNum">     312 </span>            :   // position-independent code. You will need to look at the startup code
<span class="lineNum">     313 </span>            :   // for the target system to be sure. I tried; my eyes bled.
<span class="lineNum">     314 </span>            :   void SetDataBase(uint64 data_base);
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :   // Indicate that the base address for the FDE we are processing is
<span class="lineNum">     317 </span>            :   // FUNCTION_BASE. This is the start address of DW_EH_PE_funcrel
<span class="lineNum">     318 </span>            :   // pointers. (This encoding does not seem to be used by the GNU
<span class="lineNum">     319 </span>            :   // toolchain.)
<span class="lineNum">     320 </span>            :   void SetFunctionBase(uint64 function_base);
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :   // Indicate that we are no longer processing any FDE, so any use of
<span class="lineNum">     323 </span>            :   // a DW_EH_PE_funcrel encoding is an error.
<span class="lineNum">     324 </span>            :   void ClearFunctionBase();
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :   // Return true if ENCODING is a valid pointer encoding.
<span class="lineNum">     327 </span>            :   bool ValidEncoding(DwarfPointerEncoding encoding) const;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :   // Return true if we have all the information we need to read a
<span class="lineNum">     330 </span>            :   // pointer that uses ENCODING. This checks that the appropriate
<span class="lineNum">     331 </span>            :   // SetFooBase function for ENCODING has been called.
<span class="lineNum">     332 </span>            :   bool UsableEncoding(DwarfPointerEncoding encoding) const;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   // Read an encoded pointer from BUFFER using ENCODING; return the
<span class="lineNum">     335 </span>            :   // absolute address it represents, and set *LEN to the pointer's
<span class="lineNum">     336 </span>            :   // length in bytes, including any padding for aligned pointers.
<span class="lineNum">     337 </span>            :   //
<span class="lineNum">     338 </span>            :   // This function calls 'abort' if ENCODING is invalid or refers to a
<span class="lineNum">     339 </span>            :   // base address this reader hasn't been given, so you should check
<span class="lineNum">     340 </span>            :   // with ValidEncoding and UsableEncoding first if you would rather
<span class="lineNum">     341 </span>            :   // die in a more helpful way.
<span class="lineNum">     342 </span>            :   uint64 ReadEncodedPointer(const char *buffer, DwarfPointerEncoding encoding,
<span class="lineNum">     343 </span>            :                             size_t *len) const;
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :  private:
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :   // Function pointer type for our address and offset readers.
<span class="lineNum">     348 </span>            :   typedef uint64 (ByteReader::*AddressReader)(const char*) const;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :   // Read an offset from BUFFER and return it as an unsigned 64 bit
<span class="lineNum">     351 </span>            :   // integer.  DWARF2/3 define offsets as either 4 or 8 bytes,
<span class="lineNum">     352 </span>            :   // generally depending on the amount of DWARF2/3 info present.
<span class="lineNum">     353 </span>            :   // This function pointer gets set by SetOffsetSize.
<span class="lineNum">     354 </span>            :   AddressReader offset_reader_;
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :   // Read an address from BUFFER and return it as an unsigned 64 bit
<span class="lineNum">     357 </span>            :   // integer.  DWARF2/3 allow addresses to be any size from 0-255
<span class="lineNum">     358 </span>            :   // bytes currently.  Internally we support 4 and 8 byte addresses,
<span class="lineNum">     359 </span>            :   // and will CHECK on anything else.
<span class="lineNum">     360 </span>            :   // This function pointer gets set by SetAddressSize.
<span class="lineNum">     361 </span>            :   AddressReader address_reader_;
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :   Endianness endian_;
<span class="lineNum">     364 </span>            :   uint8 address_size_;
<span class="lineNum">     365 </span>            :   uint8 offset_size_;
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            :   // Base addresses for Linux C++ exception handling data's encoded pointers.
<span class="lineNum">     368 </span>            :   bool have_section_base_, have_text_base_, have_data_base_;
<span class="lineNum">     369 </span>            :   bool have_function_base_;
<span class="lineNum">     370 </span>            :   uint64 section_base_;
<span class="lineNum">     371 </span>            :   uint64 text_base_, data_base_, function_base_;
<span class="lineNum">     372 </span>            :   const char *buffer_base_;
<span class="lineNum">     373 </span>            : };
<a name="374"><span class="lineNum">     374 </span>            : </a>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 : inline uint8 ByteReader::ReadOneByte(const char* buffer) const {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   return buffer[0];</span>
<a name="378"><span class="lineNum">     378 </span>            : }</a>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineNoCov">          0 : inline uint16 ByteReader::ReadTwoBytes(const char* signed_buffer) const {</span>
<span class="lineNum">     381 </span>            :   const unsigned char *buffer
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     = reinterpret_cast&lt;const unsigned char *&gt;(signed_buffer);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   const uint16 buffer0 = buffer[0];</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   const uint16 buffer1 = buffer[1];</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :   if (endian_ == ENDIANNESS_LITTLE) {</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     return buffer0 | buffer1 &lt;&lt; 8;</span>
<span class="lineNum">     387 </span>            :   } else {
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     return buffer1 | buffer0 &lt;&lt; 8;</span>
<span class="lineNum">     389 </span>            :   }
<a name="390"><span class="lineNum">     390 </span>            : }</a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 : inline uint64 ByteReader::ReadFourBytes(const char* signed_buffer) const {</span>
<span class="lineNum">     393 </span>            :   const unsigned char *buffer
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     = reinterpret_cast&lt;const unsigned char *&gt;(signed_buffer);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :   const uint32 buffer0 = buffer[0];</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :   const uint32 buffer1 = buffer[1];</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :   const uint32 buffer2 = buffer[2];</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   const uint32 buffer3 = buffer[3];</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :   if (endian_ == ENDIANNESS_LITTLE) {</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     return buffer0 | buffer1 &lt;&lt; 8 | buffer2 &lt;&lt; 16 | buffer3 &lt;&lt; 24;</span>
<span class="lineNum">     401 </span>            :   } else {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     return buffer3 | buffer2 &lt;&lt; 8 | buffer1 &lt;&lt; 16 | buffer0 &lt;&lt; 24;</span>
<span class="lineNum">     403 </span>            :   }
<a name="404"><span class="lineNum">     404 </span>            : }</a>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineNoCov">          0 : inline uint64 ByteReader::ReadEightBytes(const char* signed_buffer) const {</span>
<span class="lineNum">     407 </span>            :   const unsigned char *buffer
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     = reinterpret_cast&lt;const unsigned char *&gt;(signed_buffer);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   const uint64 buffer0 = buffer[0];</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   const uint64 buffer1 = buffer[1];</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   const uint64 buffer2 = buffer[2];</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   const uint64 buffer3 = buffer[3];</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   const uint64 buffer4 = buffer[4];</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   const uint64 buffer5 = buffer[5];</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   const uint64 buffer6 = buffer[6];</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   const uint64 buffer7 = buffer[7];</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   if (endian_ == ENDIANNESS_LITTLE) {</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     return buffer0 | buffer1 &lt;&lt; 8 | buffer2 &lt;&lt; 16 | buffer3 &lt;&lt; 24 |</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       buffer4 &lt;&lt; 32 | buffer5 &lt;&lt; 40 | buffer6 &lt;&lt; 48 | buffer7 &lt;&lt; 56;</span>
<span class="lineNum">     420 </span>            :   } else {
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :     return buffer7 | buffer6 &lt;&lt; 8 | buffer5 &lt;&lt; 16 | buffer4 &lt;&lt; 24 |</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       buffer3 &lt;&lt; 32 | buffer2 &lt;&lt; 40 | buffer1 &lt;&lt; 48 | buffer0 &lt;&lt; 56;</span>
<span class="lineNum">     423 </span>            :   }
<span class="lineNum">     424 </span>            : }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : // Read an unsigned LEB128 number.  Each byte contains 7 bits of
<span class="lineNum">     427 </span>            : // information, plus one bit saying whether the number continues or
<a name="428"><span class="lineNum">     428 </span>            : // not.</a>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 : inline uint64 ByteReader::ReadUnsignedLEB128(const char* buffer,</span>
<span class="lineNum">     431 </span>            :                                              size_t* len) const {
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   uint64 result = 0;</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   size_t num_read = 0;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   unsigned int shift = 0;</span>
<span class="lineNum">     435 </span>            :   unsigned char byte;
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     byte = *buffer++;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     num_read++;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     result |= (static_cast&lt;uint64&gt;(byte &amp; 0x7f)) &lt;&lt; shift;</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     shift += 7;</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :   } while (byte &amp; 0x80);</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   *len = num_read;</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     450 </span>            : }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : // Read a signed LEB128 number.  These are like regular LEB128
<a name="453"><span class="lineNum">     453 </span>            : // numbers, except the last byte may have a sign bit set.</a>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineNoCov">          0 : inline int64 ByteReader::ReadSignedLEB128(const char* buffer,</span>
<span class="lineNum">     456 </span>            :                                           size_t* len) const {
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   int64 result = 0;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   unsigned int shift = 0;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   size_t num_read = 0;</span>
<span class="lineNum">     460 </span>            :   unsigned char byte;
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       byte = *buffer++;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :       num_read++;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :       result |= (static_cast&lt;uint64&gt;(byte &amp; 0x7f) &lt;&lt; shift);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       shift += 7;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   } while (byte &amp; 0x80);</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   if ((shift &lt; 8 * sizeof (result)) &amp;&amp; (byte &amp; 0x40))</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :     result |= -((static_cast&lt;int64&gt;(1)) &lt;&lt; shift);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   *len = num_read;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   return result;</span>
<a name="473"><span class="lineNum">     473 </span>            : }</a>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : inline uint64 ByteReader::ReadOffset(const char* buffer) const {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(this-&gt;offset_reader_);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   return (this-&gt;*offset_reader_)(buffer);</span>
<a name="478"><span class="lineNum">     478 </span>            : }</a>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineNoCov">          0 : inline uint64 ByteReader::ReadAddress(const char* buffer) const {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(this-&gt;address_reader_);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   return (this-&gt;*address_reader_)(buffer);</span>
<a name="483"><span class="lineNum">     483 </span>            : }</a>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineNoCov">          0 : inline void ByteReader::SetCFIDataBase(uint64 section_base,</span>
<span class="lineNum">     486 </span>            :                                        const char *buffer_base) {
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   section_base_ = section_base;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   buffer_base_ = buffer_base;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   have_section_base_ = true;</span>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : inline void ByteReader::SetTextBase(uint64 text_base) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   text_base_ = text_base;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   have_text_base_ = true;</span>
<a name="495"><span class="lineNum">     495 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineNoCov">          0 : inline void ByteReader::SetDataBase(uint64 data_base) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   data_base_ = data_base;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   have_data_base_ = true;</span>
<a name="500"><span class="lineNum">     500 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : inline void ByteReader::SetFunctionBase(uint64 function_base) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   function_base_ = function_base;</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   have_function_base_ = true;</span>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 : inline void ByteReader::ClearFunctionBase() {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :   have_function_base_ = false;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : // (derived from)
<span class="lineNum">     513 </span>            : // dwarf_cfi_to_module.h: Define the DwarfCFIToModule class, which
<span class="lineNum">     514 </span>            : // accepts parsed DWARF call frame info and adds it to a Summariser object.
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : // This class is a reader for DWARF's Call Frame Information.  CFI
<span class="lineNum">     517 </span>            : // describes how to unwind stack frames --- even for functions that do
<span class="lineNum">     518 </span>            : // not follow fixed conventions for saving registers, whose frame size
<span class="lineNum">     519 </span>            : // varies as they execute, etc.
<span class="lineNum">     520 </span>            : //
<span class="lineNum">     521 </span>            : // CFI describes, at each machine instruction, how to compute the
<span class="lineNum">     522 </span>            : // stack frame's base address, how to find the return address, and
<span class="lineNum">     523 </span>            : // where to find the saved values of the caller's registers (if the
<span class="lineNum">     524 </span>            : // callee has stashed them somewhere to free up the registers for its
<span class="lineNum">     525 </span>            : // own use).
<span class="lineNum">     526 </span>            : //
<span class="lineNum">     527 </span>            : // For example, suppose we have a function whose machine code looks
<span class="lineNum">     528 </span>            : // like this (imagine an assembly language that looks like C, for a
<span class="lineNum">     529 </span>            : // machine with 32-bit registers, and a stack that grows towards lower
<span class="lineNum">     530 </span>            : // addresses):
<span class="lineNum">     531 </span>            : //
<span class="lineNum">     532 </span>            : // func:                                ; entry point; return address at sp
<span class="lineNum">     533 </span>            : // func+0:      sp = sp - 16            ; allocate space for stack frame
<span class="lineNum">     534 </span>            : // func+1:      sp[12] = r0             ; save r0 at sp+12
<span class="lineNum">     535 </span>            : // ...                                  ; other code, not frame-related
<span class="lineNum">     536 </span>            : // func+10:     sp -= 4; *sp = x        ; push some x on the stack
<span class="lineNum">     537 </span>            : // ...                                  ; other code, not frame-related
<span class="lineNum">     538 </span>            : // func+20:     r0 = sp[16]             ; restore saved r0
<span class="lineNum">     539 </span>            : // func+21:     sp += 20                ; pop whole stack frame
<span class="lineNum">     540 </span>            : // func+22:     pc = *sp; sp += 4       ; pop return address and jump to it
<span class="lineNum">     541 </span>            : //
<span class="lineNum">     542 </span>            : // DWARF CFI is (a very compressed representation of) a table with a
<span class="lineNum">     543 </span>            : // row for each machine instruction address and a column for each
<span class="lineNum">     544 </span>            : // register showing how to restore it, if possible.
<span class="lineNum">     545 </span>            : //
<span class="lineNum">     546 </span>            : // A special column named &quot;CFA&quot;, for &quot;Canonical Frame Address&quot;, tells how
<span class="lineNum">     547 </span>            : // to compute the base address of the frame; registers' entries may
<span class="lineNum">     548 </span>            : // refer to the CFA in describing where the registers are saved.
<span class="lineNum">     549 </span>            : //
<span class="lineNum">     550 </span>            : // Another special column, named &quot;RA&quot;, represents the return address.
<span class="lineNum">     551 </span>            : //
<span class="lineNum">     552 </span>            : // For example, here is a complete (uncompressed) table describing the
<span class="lineNum">     553 </span>            : // function above:
<span class="lineNum">     554 </span>            : //
<span class="lineNum">     555 </span>            : //     insn      cfa    r0      r1 ...  ra
<span class="lineNum">     556 </span>            : //     =======================================
<span class="lineNum">     557 </span>            : //     func+0:   sp                     cfa[0]
<span class="lineNum">     558 </span>            : //     func+1:   sp+16                  cfa[0]
<span class="lineNum">     559 </span>            : //     func+2:   sp+16  cfa[-4]         cfa[0]
<span class="lineNum">     560 </span>            : //     func+11:  sp+20  cfa[-4]         cfa[0]
<span class="lineNum">     561 </span>            : //     func+21:  sp+20                  cfa[0]
<span class="lineNum">     562 </span>            : //     func+22:  sp                     cfa[0]
<span class="lineNum">     563 </span>            : //
<span class="lineNum">     564 </span>            : // Some things to note here:
<span class="lineNum">     565 </span>            : //
<span class="lineNum">     566 </span>            : // - Each row describes the state of affairs *before* executing the
<span class="lineNum">     567 </span>            : //   instruction at the given address.  Thus, the row for func+0
<span class="lineNum">     568 </span>            : //   describes the state before we allocate the stack frame.  In the
<span class="lineNum">     569 </span>            : //   next row, the formula for computing the CFA has changed,
<span class="lineNum">     570 </span>            : //   reflecting that allocation.
<span class="lineNum">     571 </span>            : //
<span class="lineNum">     572 </span>            : // - The other entries are written in terms of the CFA; this allows
<span class="lineNum">     573 </span>            : //   them to remain unchanged as the stack pointer gets bumped around.
<span class="lineNum">     574 </span>            : //   For example, the rule for recovering the return address (the &quot;ra&quot;
<span class="lineNum">     575 </span>            : //   column) remains unchanged throughout the function, even as the
<span class="lineNum">     576 </span>            : //   stack pointer takes on three different offsets from the return
<span class="lineNum">     577 </span>            : //   address.
<span class="lineNum">     578 </span>            : //
<span class="lineNum">     579 </span>            : // - Although we haven't shown it, most calling conventions designate
<span class="lineNum">     580 </span>            : //   &quot;callee-saves&quot; and &quot;caller-saves&quot; registers. The callee must
<span class="lineNum">     581 </span>            : //   preserve the values of callee-saves registers; if it uses them,
<span class="lineNum">     582 </span>            : //   it must save their original values somewhere, and restore them
<span class="lineNum">     583 </span>            : //   before it returns. In contrast, the callee is free to trash
<span class="lineNum">     584 </span>            : //   caller-saves registers; if the callee uses these, it will
<span class="lineNum">     585 </span>            : //   probably not bother to save them anywhere, and the CFI will
<span class="lineNum">     586 </span>            : //   probably mark their values as &quot;unrecoverable&quot;.
<span class="lineNum">     587 </span>            : //
<span class="lineNum">     588 </span>            : //   (However, since the caller cannot assume the callee was going to
<span class="lineNum">     589 </span>            : //   save them, caller-saves registers are probably dead in the caller
<span class="lineNum">     590 </span>            : //   anyway, so compilers usually don't generate CFA for caller-saves
<span class="lineNum">     591 </span>            : //   registers.)
<span class="lineNum">     592 </span>            : //
<span class="lineNum">     593 </span>            : // - Exactly where the CFA points is a matter of convention that
<span class="lineNum">     594 </span>            : //   depends on the architecture and ABI in use. In the example, the
<span class="lineNum">     595 </span>            : //   CFA is the value the stack pointer had upon entry to the
<span class="lineNum">     596 </span>            : //   function, pointing at the saved return address. But on the x86,
<span class="lineNum">     597 </span>            : //   the call frame information generated by GCC follows the
<span class="lineNum">     598 </span>            : //   convention that the CFA is the address *after* the saved return
<span class="lineNum">     599 </span>            : //   address.
<span class="lineNum">     600 </span>            : //
<span class="lineNum">     601 </span>            : //   But by definition, the CFA remains constant throughout the
<span class="lineNum">     602 </span>            : //   lifetime of the frame. This makes it a useful value for other
<span class="lineNum">     603 </span>            : //   columns to refer to. It is also gives debuggers a useful handle
<span class="lineNum">     604 </span>            : //   for identifying a frame.
<span class="lineNum">     605 </span>            : //
<span class="lineNum">     606 </span>            : // If you look at the table above, you'll notice that a given entry is
<span class="lineNum">     607 </span>            : // often the same as the one immediately above it: most instructions
<span class="lineNum">     608 </span>            : // change only one or two aspects of the stack frame, if they affect
<span class="lineNum">     609 </span>            : // it at all. The DWARF format takes advantage of this fact, and
<span class="lineNum">     610 </span>            : // reduces the size of the data by mentioning only the addresses and
<span class="lineNum">     611 </span>            : // columns at which changes take place. So for the above, DWARF CFI
<span class="lineNum">     612 </span>            : // data would only actually mention the following:
<span class="lineNum">     613 </span>            : //
<span class="lineNum">     614 </span>            : //     insn      cfa    r0      r1 ...  ra
<span class="lineNum">     615 </span>            : //     =======================================
<span class="lineNum">     616 </span>            : //     func+0:   sp                     cfa[0]
<span class="lineNum">     617 </span>            : //     func+1:   sp+16
<span class="lineNum">     618 </span>            : //     func+2:          cfa[-4]
<span class="lineNum">     619 </span>            : //     func+11:  sp+20
<span class="lineNum">     620 </span>            : //     func+21:         r0
<span class="lineNum">     621 </span>            : //     func+22:  sp
<span class="lineNum">     622 </span>            : //
<span class="lineNum">     623 </span>            : // In fact, this is the way the parser reports CFI to the consumer: as
<span class="lineNum">     624 </span>            : // a series of statements of the form, &quot;At address X, column Y changed
<span class="lineNum">     625 </span>            : // to Z,&quot; and related conventions for describing the initial state.
<span class="lineNum">     626 </span>            : //
<span class="lineNum">     627 </span>            : // Naturally, it would be impractical to have to scan the entire
<span class="lineNum">     628 </span>            : // program's CFI, noting changes as we go, just to recover the
<span class="lineNum">     629 </span>            : // unwinding rules in effect at one particular instruction. To avoid
<span class="lineNum">     630 </span>            : // this, CFI data is grouped into &quot;entries&quot;, each of which covers a
<span class="lineNum">     631 </span>            : // specified range of addresses and begins with a complete statement
<span class="lineNum">     632 </span>            : // of the rules for all recoverable registers at that starting
<span class="lineNum">     633 </span>            : // address. Each entry typically covers a single function.
<span class="lineNum">     634 </span>            : //
<span class="lineNum">     635 </span>            : // Thus, to compute the contents of a given row of the table --- that
<span class="lineNum">     636 </span>            : // is, rules for recovering the CFA, RA, and registers at a given
<span class="lineNum">     637 </span>            : // instruction --- the consumer should find the entry that covers that
<span class="lineNum">     638 </span>            : // instruction's address, start with the initial state supplied at the
<span class="lineNum">     639 </span>            : // beginning of the entry, and work forward until it has processed all
<span class="lineNum">     640 </span>            : // the changes up to and including those for the present instruction.
<span class="lineNum">     641 </span>            : //
<span class="lineNum">     642 </span>            : // There are seven kinds of rules that can appear in an entry of the
<span class="lineNum">     643 </span>            : // table:
<span class="lineNum">     644 </span>            : //
<span class="lineNum">     645 </span>            : // - &quot;undefined&quot;: The given register is not preserved by the callee;
<span class="lineNum">     646 </span>            : //   its value cannot be recovered.
<span class="lineNum">     647 </span>            : //
<span class="lineNum">     648 </span>            : // - &quot;same value&quot;: This register has the same value it did in the callee.
<span class="lineNum">     649 </span>            : //
<span class="lineNum">     650 </span>            : // - offset(N): The register is saved at offset N from the CFA.
<span class="lineNum">     651 </span>            : //
<span class="lineNum">     652 </span>            : // - val_offset(N): The value the register had in the caller is the
<span class="lineNum">     653 </span>            : //   CFA plus offset N. (This is usually only useful for describing
<span class="lineNum">     654 </span>            : //   the stack pointer.)
<span class="lineNum">     655 </span>            : //
<span class="lineNum">     656 </span>            : // - register(R): The register's value was saved in another register R.
<span class="lineNum">     657 </span>            : //
<span class="lineNum">     658 </span>            : // - expression(E): Evaluating the DWARF expression E using the
<span class="lineNum">     659 </span>            : //   current frame's registers' values yields the address at which the
<span class="lineNum">     660 </span>            : //   register was saved.
<span class="lineNum">     661 </span>            : //
<span class="lineNum">     662 </span>            : // - val_expression(E): Evaluating the DWARF expression E using the
<span class="lineNum">     663 </span>            : //   current frame's registers' values yields the value the register
<span class="lineNum">     664 </span>            : //   had in the caller.
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : class CallFrameInfo {
<span class="lineNum">     667 </span>            :  public:
<span class="lineNum">     668 </span>            :   // The different kinds of entries one finds in CFI. Used internally,
<span class="lineNum">     669 </span>            :   // and for error reporting.
<span class="lineNum">     670 </span>            :   enum EntryKind { kUnknown, kCIE, kFDE, kTerminator };
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   // The handler class to which the parser hands the parsed call frame
<span class="lineNum">     673 </span>            :   // information.  Defined below.
<span class="lineNum">     674 </span>            :   class Handler;
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   // A reporter class, which CallFrameInfo uses to report errors
<span class="lineNum">     677 </span>            :   // encountered while parsing call frame information.  Defined below.
<span class="lineNum">     678 </span>            :   class Reporter;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :   // Create a DWARF CFI parser. BUFFER points to the contents of the
<span class="lineNum">     681 </span>            :   // .debug_frame section to parse; BUFFER_LENGTH is its length in bytes.
<span class="lineNum">     682 </span>            :   // REPORTER is an error reporter the parser should use to report
<span class="lineNum">     683 </span>            :   // problems. READER is a ByteReader instance that has the endianness and
<span class="lineNum">     684 </span>            :   // address size set properly. Report the data we find to HANDLER.
<span class="lineNum">     685 </span>            :   //
<span class="lineNum">     686 </span>            :   // This class can also parse Linux C++ exception handling data, as found
<span class="lineNum">     687 </span>            :   // in '.eh_frame' sections. This data is a variant of DWARF CFI that is
<span class="lineNum">     688 </span>            :   // placed in loadable segments so that it is present in the program's
<span class="lineNum">     689 </span>            :   // address space, and is interpreted by the C++ runtime to search the
<span class="lineNum">     690 </span>            :   // call stack for a handler interested in the exception being thrown,
<span class="lineNum">     691 </span>            :   // actually pop the frames, and find cleanup code to run.
<span class="lineNum">     692 </span>            :   //
<span class="lineNum">     693 </span>            :   // There are two differences between the call frame information described
<span class="lineNum">     694 </span>            :   // in the DWARF standard and the exception handling data Linux places in
<span class="lineNum">     695 </span>            :   // the .eh_frame section:
<span class="lineNum">     696 </span>            :   //
<span class="lineNum">     697 </span>            :   // - Exception handling data uses uses a different format for call frame
<span class="lineNum">     698 </span>            :   //   information entry headers. The distinguished CIE id, the way FDEs
<span class="lineNum">     699 </span>            :   //   refer to their CIEs, and the way the end of the series of entries is
<span class="lineNum">     700 </span>            :   //   determined are all slightly different.
<span class="lineNum">     701 </span>            :   //
<span class="lineNum">     702 </span>            :   //   If the constructor's EH_FRAME argument is true, then the
<span class="lineNum">     703 </span>            :   //   CallFrameInfo parses the entry headers as Linux C++ exception
<span class="lineNum">     704 </span>            :   //   handling data. If EH_FRAME is false or omitted, the CallFrameInfo
<span class="lineNum">     705 </span>            :   //   parses standard DWARF call frame information.
<span class="lineNum">     706 </span>            :   //
<span class="lineNum">     707 </span>            :   // - Linux C++ exception handling data uses CIE augmentation strings
<span class="lineNum">     708 </span>            :   //   beginning with 'z' to specify the presence of additional data after
<span class="lineNum">     709 </span>            :   //   the CIE and FDE headers and special encodings used for addresses in
<span class="lineNum">     710 </span>            :   //   frame description entries.
<span class="lineNum">     711 </span>            :   //
<span class="lineNum">     712 </span>            :   //   CallFrameInfo can handle 'z' augmentations in either DWARF CFI or
<span class="lineNum">     713 </span>            :   //   exception handling data if you have supplied READER with the base
<span class="lineNum">     714 </span>            :   //   addresses needed to interpret the pointer encodings that 'z'
<span class="lineNum">     715 </span>            :   //   augmentations can specify. See the ByteReader interface for details
<span class="lineNum">     716 </span>            :   //   about the base addresses. See the CallFrameInfo::Handler interface
<span class="lineNum">     717 </span>            :   //   for details about the additional information one might find in
<span class="lineNum">     718 </span>            :   //   'z'-augmented data.
<span class="lineNum">     719 </span>            :   //
<span class="lineNum">     720 </span>            :   // Thus:
<span class="lineNum">     721 </span>            :   //
<span class="lineNum">     722 </span>            :   // - If you are parsing standard DWARF CFI, as found in a .debug_frame
<span class="lineNum">     723 </span>            :   //   section, you should pass false for the EH_FRAME argument, or omit
<span class="lineNum">     724 </span>            :   //   it, and you need not worry about providing READER with the
<span class="lineNum">     725 </span>            :   //   additional base addresses.
<span class="lineNum">     726 </span>            :   //
<span class="lineNum">     727 </span>            :   // - If you want to parse Linux C++ exception handling data from a
<span class="lineNum">     728 </span>            :   //   .eh_frame section, you should pass EH_FRAME as true, and call
<span class="lineNum">     729 </span>            :   //   READER's Set*Base member functions before calling our Start method.
<span class="lineNum">     730 </span>            :   //
<span class="lineNum">     731 </span>            :   // - If you want to parse DWARF CFI that uses the 'z' augmentations
<span class="lineNum">     732 </span>            :   //   (although I don't think any toolchain ever emits such data), you
<span class="lineNum">     733 </span>            :   //   could pass false for EH_FRAME, but call READER's Set*Base members.
<span class="lineNum">     734 </span>            :   //
<span class="lineNum">     735 </span>            :   // The extensions the Linux C++ ABI makes to DWARF for exception
<span class="lineNum">     736 </span>            :   // handling are described here, rather poorly:
<span class="lineNum">     737 </span>            :   // http://refspecs.linux-foundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/dwarfext.html
<span class="lineNum">     738 </span>            :   // http://refspecs.linux-foundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html
<span class="lineNum">     739 </span>            :   //
<span class="lineNum">     740 </span>            :   // The mechanics of C++ exception handling, personality routines,
<span class="lineNum">     741 </span>            :   // and language-specific data areas are described here, rather nicely:
<a name="742"><span class="lineNum">     742 </span>            :   // http://www.codesourcery.com/public/cxx-abi/abi-eh.html</a>
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   CallFrameInfo(const char *buffer, size_t buffer_length,</span>
<span class="lineNum">     745 </span>            :                 ByteReader *reader, Handler *handler, Reporter *reporter,
<span class="lineNum">     746 </span>            :                 bool eh_frame = false)
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :       : buffer_(buffer), buffer_length_(buffer_length),</span>
<span class="lineNum">     748 </span>            :         reader_(reader), handler_(handler), reporter_(reporter),
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :         eh_frame_(eh_frame) { }</span></a>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   ~CallFrameInfo() { }</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :   // Parse the entries in BUFFER, reporting what we find to HANDLER.
<span class="lineNum">     754 </span>            :   // Return true if we reach the end of the section successfully, or
<span class="lineNum">     755 </span>            :   // false if we encounter an error.
<span class="lineNum">     756 </span>            :   bool Start();
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   // Return the textual name of KIND. For error reporting.
<span class="lineNum">     759 </span>            :   static const char *KindName(EntryKind kind);
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :  private:
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :   struct CIE;
<a name="764"><span class="lineNum">     764 </span>            : </a>
<span class="lineNum">     765 </span>            :   // A CFI entry, either an FDE or a CIE.
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   struct Entry {</span>
<span class="lineNum">     767 </span>            :     // The starting offset of the entry in the section, for error
<span class="lineNum">     768 </span>            :     // reporting.
<span class="lineNum">     769 </span>            :     size_t offset;
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :     // The start of this entry in the buffer.
<span class="lineNum">     772 </span>            :     const char *start;
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :     // Which kind of entry this is.
<span class="lineNum">     775 </span>            :     //
<span class="lineNum">     776 </span>            :     // We want to be able to use this for error reporting even while we're
<span class="lineNum">     777 </span>            :     // in the midst of parsing. Error reporting code may assume that kind,
<span class="lineNum">     778 </span>            :     // offset, and start fields are valid, although kind may be kUnknown.
<span class="lineNum">     779 </span>            :     EntryKind kind;
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :     // The end of this entry's common prologue (initial length and id), and
<span class="lineNum">     782 </span>            :     // the start of this entry's kind-specific fields.
<span class="lineNum">     783 </span>            :     const char *fields;
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :     // The start of this entry's instructions.
<span class="lineNum">     786 </span>            :     const char *instructions;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     // The address past the entry's last byte in the buffer. (Note that
<span class="lineNum">     789 </span>            :     // since offset points to the entry's initial length field, and the
<span class="lineNum">     790 </span>            :     // length field is the number of bytes after that field, this is not
<span class="lineNum">     791 </span>            :     // simply buffer_ + offset + length.)
<span class="lineNum">     792 </span>            :     const char *end;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :     // For both DWARF CFI and .eh_frame sections, this is the CIE id in a
<span class="lineNum">     795 </span>            :     // CIE, and the offset of the associated CIE in an FDE.
<span class="lineNum">     796 </span>            :     uint64 id;
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :     // The CIE that applies to this entry, if we've parsed it. If this is a
<span class="lineNum">     799 </span>            :     // CIE, then this field points to this structure.
<span class="lineNum">     800 </span>            :     CIE *cie;
<span class="lineNum">     801 </span>            :   };
<a name="802"><span class="lineNum">     802 </span>            : </a>
<span class="lineNum">     803 </span>            :   // A common information entry (CIE).
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   struct CIE: public Entry {</span>
<span class="lineNum">     805 </span>            :     uint8 version;                      // CFI data version number
<span class="lineNum">     806 </span>            :     std::string augmentation;           // vendor format extension markers
<span class="lineNum">     807 </span>            :     uint64 code_alignment_factor;       // scale for code address adjustments
<span class="lineNum">     808 </span>            :     int data_alignment_factor;          // scale for stack pointer adjustments
<span class="lineNum">     809 </span>            :     unsigned return_address_register;   // which register holds the return addr
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :     // True if this CIE includes Linux C++ ABI 'z' augmentation data.
<span class="lineNum">     812 </span>            :     bool has_z_augmentation;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :     // Parsed 'z' augmentation data. These are meaningful only if
<span class="lineNum">     815 </span>            :     // has_z_augmentation is true.
<span class="lineNum">     816 </span>            :     bool has_z_lsda;                    // The 'z' augmentation included 'L'.
<span class="lineNum">     817 </span>            :     bool has_z_personality;             // The 'z' augmentation included 'P'.
<span class="lineNum">     818 </span>            :     bool has_z_signal_frame;            // The 'z' augmentation included 'S'.
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     // If has_z_lsda is true, this is the encoding to be used for language-
<span class="lineNum">     821 </span>            :     // specific data area pointers in FDEs.
<span class="lineNum">     822 </span>            :     DwarfPointerEncoding lsda_encoding;
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :     // If has_z_personality is true, this is the encoding used for the
<span class="lineNum">     825 </span>            :     // personality routine pointer in the augmentation data.
<span class="lineNum">     826 </span>            :     DwarfPointerEncoding personality_encoding;
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     // If has_z_personality is true, this is the address of the personality
<span class="lineNum">     829 </span>            :     // routine --- or, if personality_encoding &amp; DW_EH_PE_indirect, the
<span class="lineNum">     830 </span>            :     // address where the personality routine's address is stored.
<span class="lineNum">     831 </span>            :     uint64 personality_address;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :     // This is the encoding used for addresses in the FDE header and
<span class="lineNum">     834 </span>            :     // in DW_CFA_set_loc instructions. This is always valid, whether
<span class="lineNum">     835 </span>            :     // or not we saw a 'z' augmentation string; its default value is
<span class="lineNum">     836 </span>            :     // DW_EH_PE_absptr, which is what normal DWARF CFI uses.
<span class="lineNum">     837 </span>            :     DwarfPointerEncoding pointer_encoding;
<span class="lineNum">     838 </span>            :   };
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :   // A frame description entry (FDE).
<span class="lineNum">     841 </span>            :   struct FDE: public Entry {
<span class="lineNum">     842 </span>            :     uint64 address;                     // start address of described code
<span class="lineNum">     843 </span>            :     uint64 size;                        // size of described code, in bytes
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :     // If cie-&gt;has_z_lsda is true, then this is the language-specific data
<span class="lineNum">     846 </span>            :     // area's address --- or its address's address, if cie-&gt;lsda_encoding
<span class="lineNum">     847 </span>            :     // has the DW_EH_PE_indirect bit set.
<span class="lineNum">     848 </span>            :     uint64 lsda_address;
<span class="lineNum">     849 </span>            :   };
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   // Internal use.
<span class="lineNum">     852 </span>            :   class Rule;
<span class="lineNum">     853 </span>            :   class UndefinedRule;
<span class="lineNum">     854 </span>            :   class SameValueRule;
<span class="lineNum">     855 </span>            :   class OffsetRule;
<span class="lineNum">     856 </span>            :   class ValOffsetRule;
<span class="lineNum">     857 </span>            :   class RegisterRule;
<span class="lineNum">     858 </span>            :   class ExpressionRule;
<span class="lineNum">     859 </span>            :   class ValExpressionRule;
<span class="lineNum">     860 </span>            :   class RuleMap;
<span class="lineNum">     861 </span>            :   class State;
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            :   // Parse the initial length and id of a CFI entry, either a CIE, an FDE,
<span class="lineNum">     864 </span>            :   // or a .eh_frame end-of-data mark. CURSOR points to the beginning of the
<span class="lineNum">     865 </span>            :   // data to parse. On success, populate ENTRY as appropriate, and return
<span class="lineNum">     866 </span>            :   // true. On failure, report the problem, and return false. Even if we
<span class="lineNum">     867 </span>            :   // return false, set ENTRY-&gt;end to the first byte after the entry if we
<span class="lineNum">     868 </span>            :   // were able to figure that out, or NULL if we weren't.
<span class="lineNum">     869 </span>            :   bool ReadEntryPrologue(const char *cursor, Entry *entry);
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :   // Parse the fields of a CIE after the entry prologue, including any 'z'
<span class="lineNum">     872 </span>            :   // augmentation data. Assume that the 'Entry' fields of CIE are
<span class="lineNum">     873 </span>            :   // populated; use CIE-&gt;fields and CIE-&gt;end as the start and limit for
<span class="lineNum">     874 </span>            :   // parsing. On success, populate the rest of *CIE, and return true; on
<span class="lineNum">     875 </span>            :   // failure, report the problem and return false.
<span class="lineNum">     876 </span>            :   bool ReadCIEFields(CIE *cie);
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   // Parse the fields of an FDE after the entry prologue, including any 'z'
<span class="lineNum">     879 </span>            :   // augmentation data. Assume that the 'Entry' fields of *FDE are
<span class="lineNum">     880 </span>            :   // initialized; use FDE-&gt;fields and FDE-&gt;end as the start and limit for
<span class="lineNum">     881 </span>            :   // parsing. Assume that FDE-&gt;cie is fully initialized. On success,
<span class="lineNum">     882 </span>            :   // populate the rest of *FDE, and return true; on failure, report the
<span class="lineNum">     883 </span>            :   // problem and return false.
<span class="lineNum">     884 </span>            :   bool ReadFDEFields(FDE *fde);
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :   // Report that ENTRY is incomplete, and return false. This is just a
<span class="lineNum">     887 </span>            :   // trivial wrapper for invoking reporter_-&gt;Incomplete; it provides a
<span class="lineNum">     888 </span>            :   // little brevity.
<span class="lineNum">     889 </span>            :   bool ReportIncomplete(Entry *entry);
<a name="890"><span class="lineNum">     890 </span>            : </a>
<span class="lineNum">     891 </span>            :   // Return true if ENCODING has the DW_EH_PE_indirect bit set.
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   static bool IsIndirectEncoding(DwarfPointerEncoding encoding) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     return encoding &amp; DW_EH_PE_indirect;</span>
<span class="lineNum">     894 </span>            :   }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :   // The contents of the DWARF .debug_info section we're parsing.
<span class="lineNum">     897 </span>            :   const char *buffer_;
<span class="lineNum">     898 </span>            :   size_t buffer_length_;
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :   // For reading multi-byte values with the appropriate endianness.
<span class="lineNum">     901 </span>            :   ByteReader *reader_;
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :   // The handler to which we should report the data we find.
<span class="lineNum">     904 </span>            :   Handler *handler_;
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :   // For reporting problems in the info we're parsing.
<span class="lineNum">     907 </span>            :   Reporter *reporter_;
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :   // True if we are processing .eh_frame-format data.
<span class="lineNum">     910 </span>            :   bool eh_frame_;
<span class="lineNum">     911 </span>            : };
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : // The handler class for CallFrameInfo.  The a CFI parser calls the
<span class="lineNum">     915 </span>            : // member functions of a handler object to report the data it finds.
<span class="lineNum">     916 </span>            : class CallFrameInfo::Handler {
<span class="lineNum">     917 </span>            :  public:
<span class="lineNum">     918 </span>            :   // The pseudo-register number for the canonical frame address.
<a name="919"><span class="lineNum">     919 </span>            :   enum { kCFARegister = DW_REG_CFA };</a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   Handler() { }</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   virtual ~Handler() { }</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :   // The parser has found CFI for the machine code at ADDRESS,
<span class="lineNum">     925 </span>            :   // extending for LENGTH bytes. OFFSET is the offset of the frame
<span class="lineNum">     926 </span>            :   // description entry in the section, for use in error messages.
<span class="lineNum">     927 </span>            :   // VERSION is the version number of the CFI format. AUGMENTATION is
<span class="lineNum">     928 </span>            :   // a string describing any producer-specific extensions present in
<span class="lineNum">     929 </span>            :   // the data. RETURN_ADDRESS is the number of the register that holds
<span class="lineNum">     930 </span>            :   // the address to which the function should return.
<span class="lineNum">     931 </span>            :   //
<span class="lineNum">     932 </span>            :   // Entry should return true to process this CFI, or false to skip to
<span class="lineNum">     933 </span>            :   // the next entry.
<span class="lineNum">     934 </span>            :   //
<span class="lineNum">     935 </span>            :   // The parser invokes Entry for each Frame Description Entry (FDE)
<span class="lineNum">     936 </span>            :   // it finds.  The parser doesn't report Common Information Entries
<span class="lineNum">     937 </span>            :   // to the handler explicitly; instead, if the handler elects to
<span class="lineNum">     938 </span>            :   // process a given FDE, the parser reiterates the appropriate CIE's
<span class="lineNum">     939 </span>            :   // contents at the beginning of the FDE's rules.
<span class="lineNum">     940 </span>            :   virtual bool Entry(size_t offset, uint64 address, uint64 length,
<span class="lineNum">     941 </span>            :                      uint8 version, const std::string &amp;augmentation,
<span class="lineNum">     942 </span>            :                      unsigned return_address) = 0;
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            :   // When the Entry function returns true, the parser calls these
<span class="lineNum">     945 </span>            :   // handler functions repeatedly to describe the rules for recovering
<span class="lineNum">     946 </span>            :   // registers at each instruction in the given range of machine code.
<span class="lineNum">     947 </span>            :   // Immediately after a call to Entry, the handler should assume that
<span class="lineNum">     948 </span>            :   // the rule for each callee-saves register is &quot;unchanged&quot; --- that
<span class="lineNum">     949 </span>            :   // is, that the register still has the value it had in the caller.
<span class="lineNum">     950 </span>            :   //
<span class="lineNum">     951 </span>            :   // If a *Rule function returns true, we continue processing this entry's
<span class="lineNum">     952 </span>            :   // instructions. If a *Rule function returns false, we stop evaluating
<span class="lineNum">     953 </span>            :   // instructions, and skip to the next entry. Either way, we call End
<span class="lineNum">     954 </span>            :   // before going on to the next entry.
<span class="lineNum">     955 </span>            :   //
<span class="lineNum">     956 </span>            :   // In all of these functions, if the REG parameter is kCFARegister, then
<span class="lineNum">     957 </span>            :   // the rule describes how to find the canonical frame address.
<span class="lineNum">     958 </span>            :   // kCFARegister may be passed as a BASE_REGISTER argument, meaning that
<span class="lineNum">     959 </span>            :   // the canonical frame address should be used as the base address for the
<span class="lineNum">     960 </span>            :   // computation. All other REG values will be positive.
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   // At ADDRESS, register REG's value is not recoverable.
<span class="lineNum">     963 </span>            :   virtual bool UndefinedRule(uint64 address, int reg) = 0;
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            :   // At ADDRESS, register REG's value is the same as that it had in
<span class="lineNum">     966 </span>            :   // the caller.
<span class="lineNum">     967 </span>            :   virtual bool SameValueRule(uint64 address, int reg) = 0;
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   // At ADDRESS, register REG has been saved at offset OFFSET from
<span class="lineNum">     970 </span>            :   // BASE_REGISTER.
<span class="lineNum">     971 </span>            :   virtual bool OffsetRule(uint64 address, int reg,
<span class="lineNum">     972 </span>            :                           int base_register, long offset) = 0;
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   // At ADDRESS, the caller's value of register REG is the current
<span class="lineNum">     975 </span>            :   // value of BASE_REGISTER plus OFFSET. (This rule doesn't provide an
<span class="lineNum">     976 </span>            :   // address at which the register's value is saved.)
<span class="lineNum">     977 </span>            :   virtual bool ValOffsetRule(uint64 address, int reg,
<span class="lineNum">     978 </span>            :                              int base_register, long offset) = 0;
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :   // At ADDRESS, register REG has been saved in BASE_REGISTER. This differs
<span class="lineNum">     981 </span>            :   // from ValOffsetRule(ADDRESS, REG, BASE_REGISTER, 0), in that
<span class="lineNum">     982 </span>            :   // BASE_REGISTER is the &quot;home&quot; for REG's saved value: if you want to
<span class="lineNum">     983 </span>            :   // assign to a variable whose home is REG in the calling frame, you
<span class="lineNum">     984 </span>            :   // should put the value in BASE_REGISTER.
<span class="lineNum">     985 </span>            :   virtual bool RegisterRule(uint64 address, int reg, int base_register) = 0;
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            :   // At ADDRESS, the DWARF expression EXPRESSION yields the address at
<span class="lineNum">     988 </span>            :   // which REG was saved.
<span class="lineNum">     989 </span>            :   virtual bool ExpressionRule(uint64 address, int reg,
<span class="lineNum">     990 </span>            :                               const std::string &amp;expression) = 0;
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :   // At ADDRESS, the DWARF expression EXPRESSION yields the caller's
<span class="lineNum">     993 </span>            :   // value for REG. (This rule doesn't provide an address at which the
<span class="lineNum">     994 </span>            :   // register's value is saved.)
<span class="lineNum">     995 </span>            :   virtual bool ValExpressionRule(uint64 address, int reg,
<span class="lineNum">     996 </span>            :                                  const std::string &amp;expression) = 0;
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :   // Indicate that the rules for the address range reported by the
<span class="lineNum">     999 </span>            :   // last call to Entry are complete.  End should return true if
<span class="lineNum">    1000 </span>            :   // everything is okay, or false if an error has occurred and parsing
<span class="lineNum">    1001 </span>            :   // should stop.
<span class="lineNum">    1002 </span>            :   virtual bool End() = 0;
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :   // Handler functions for Linux C++ exception handling data. These are
<span class="lineNum">    1005 </span>            :   // only called if the data includes 'z' augmentation strings.
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :   // The Linux C++ ABI uses an extension of the DWARF CFI format to
<span class="lineNum">    1008 </span>            :   // walk the stack to propagate exceptions from the throw to the
<span class="lineNum">    1009 </span>            :   // appropriate catch, and do the appropriate cleanups along the way.
<span class="lineNum">    1010 </span>            :   // CFI entries used for exception handling have two additional data
<span class="lineNum">    1011 </span>            :   // associated with them:
<span class="lineNum">    1012 </span>            :   //
<span class="lineNum">    1013 </span>            :   // - The &quot;language-specific data area&quot; describes which exception
<span class="lineNum">    1014 </span>            :   //   types the function has 'catch' clauses for, and indicates how
<span class="lineNum">    1015 </span>            :   //   to go about re-entering the function at the appropriate catch
<span class="lineNum">    1016 </span>            :   //   clause. If the exception is not caught, it describes the
<span class="lineNum">    1017 </span>            :   //   destructors that must run before the frame is popped.
<span class="lineNum">    1018 </span>            :   //
<span class="lineNum">    1019 </span>            :   // - The &quot;personality routine&quot; is responsible for interpreting the
<span class="lineNum">    1020 </span>            :   //   language-specific data area's contents, and deciding whether
<span class="lineNum">    1021 </span>            :   //   the exception should continue to propagate down the stack,
<span class="lineNum">    1022 </span>            :   //   perhaps after doing some cleanup for this frame, or whether the
<span class="lineNum">    1023 </span>            :   //   exception will be caught here.
<span class="lineNum">    1024 </span>            :   //
<span class="lineNum">    1025 </span>            :   // In principle, the language-specific data area is opaque to
<span class="lineNum">    1026 </span>            :   // everybody but the personality routine. In practice, these values
<span class="lineNum">    1027 </span>            :   // may be useful or interesting to readers with extra context, and
<span class="lineNum">    1028 </span>            :   // we have to at least skip them anyway, so we might as well report
<span class="lineNum">    1029 </span>            :   // them to the handler.
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :   // This entry's exception handling personality routine's address is
<span class="lineNum">    1032 </span>            :   // ADDRESS. If INDIRECT is true, then ADDRESS is the address at
<span class="lineNum">    1033 </span>            :   // which the routine's address is stored. The default definition for
<a name="1034"><span class="lineNum">    1034 </span>            :   // this handler function simply returns true, allowing parsing of</a>
<span class="lineNum">    1035 </span>            :   // the entry to continue.
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   virtual bool PersonalityRoutine(uint64 address, bool indirect) {</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1038 </span>            :   }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   // This entry's language-specific data area (LSDA) is located at
<span class="lineNum">    1041 </span>            :   // ADDRESS. If INDIRECT is true, then ADDRESS is the address at
<span class="lineNum">    1042 </span>            :   // which the area's address is stored. The default definition for
<a name="1043"><span class="lineNum">    1043 </span>            :   // this handler function simply returns true, allowing parsing of</a>
<span class="lineNum">    1044 </span>            :   // the entry to continue.
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   virtual bool LanguageSpecificDataArea(uint64 address, bool indirect) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1047 </span>            :   }
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :   // This entry describes a signal trampoline --- this frame is the
<span class="lineNum">    1050 </span>            :   // caller of a signal handler. The default definition for this
<span class="lineNum">    1051 </span>            :   // handler function simply returns true, allowing parsing of the
<span class="lineNum">    1052 </span>            :   // entry to continue.
<span class="lineNum">    1053 </span>            :   //
<span class="lineNum">    1054 </span>            :   // The best description of the rationale for and meaning of signal
<a name="1055"><span class="lineNum">    1055 </span>            :   // trampoline CFI entries seems to be in the GCC bug database:</a>
<span class="lineNum">    1056 </span>            :   // http://gcc.gnu.org/bugzilla/show_bug.cgi?id=26208
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   virtual bool SignalHandler() { return true; }</span>
<span class="lineNum">    1058 </span>            : };
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            : // The CallFrameInfo class makes calls on an instance of this class to
<span class="lineNum">    1062 </span>            : // report errors or warn about problems in the data it is parsing.
<span class="lineNum">    1063 </span>            : // These messages are sent to the message sink |aLog| provided to the
<span class="lineNum">    1064 </span>            : // constructor.
<span class="lineNum">    1065 </span>            : class CallFrameInfo::Reporter {
<span class="lineNum">    1066 </span>            :  public:
<span class="lineNum">    1067 </span>            :   // Create an error reporter which attributes troubles to the section
<span class="lineNum">    1068 </span>            :   // named SECTION in FILENAME.
<span class="lineNum">    1069 </span>            :   //
<span class="lineNum">    1070 </span>            :   // Normally SECTION would be .debug_frame, but the Mac puts CFI data
<span class="lineNum">    1071 </span>            :   // in a Mach-O section named __debug_frame. If we support
<a name="1072"><span class="lineNum">    1072 </span>            :   // Linux-style exception handling data, we could be reading an</a>
<span class="lineNum">    1073 </span>            :   // .eh_frame section.
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   Reporter(void (*aLog)(const char*),</span>
<span class="lineNum">    1075 </span>            :            const std::string &amp;filename,
<a name="1076"><span class="lineNum">    1076 </span>            :            const std::string &amp;section = &quot;.debug_frame&quot;)</a>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :       : log_(aLog), filename_(filename), section_(section) { }</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   virtual ~Reporter() { }</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :   // The CFI entry at OFFSET ends too early to be well-formed. KIND
<span class="lineNum">    1081 </span>            :   // indicates what kind of entry it is; KIND can be kUnknown if we
<span class="lineNum">    1082 </span>            :   // haven't parsed enough of the entry to tell yet.
<span class="lineNum">    1083 </span>            :   virtual void Incomplete(uint64 offset, CallFrameInfo::EntryKind kind);
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :   // The .eh_frame data has a four-byte zero at OFFSET where the next
<span class="lineNum">    1086 </span>            :   // entry's length would be; this is a terminator. However, the buffer
<span class="lineNum">    1087 </span>            :   // length as given to the CallFrameInfo constructor says there should be
<span class="lineNum">    1088 </span>            :   // more data.
<span class="lineNum">    1089 </span>            :   virtual void EarlyEHTerminator(uint64 offset);
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :   // The FDE at OFFSET refers to the CIE at CIE_OFFSET, but the
<span class="lineNum">    1092 </span>            :   // section is not that large.
<span class="lineNum">    1093 </span>            :   virtual void CIEPointerOutOfRange(uint64 offset, uint64 cie_offset);
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :   // The FDE at OFFSET refers to the CIE at CIE_OFFSET, but the entry
<span class="lineNum">    1096 </span>            :   // there is not a CIE.
<span class="lineNum">    1097 </span>            :   virtual void BadCIEId(uint64 offset, uint64 cie_offset);
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :   // The FDE at OFFSET refers to a CIE with version number VERSION,
<span class="lineNum">    1100 </span>            :   // which we don't recognize. We cannot parse DWARF CFI if it uses
<span class="lineNum">    1101 </span>            :   // a version number we don't recognize.
<span class="lineNum">    1102 </span>            :   virtual void UnrecognizedVersion(uint64 offset, int version);
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :   // The FDE at OFFSET refers to a CIE with augmentation AUGMENTATION,
<span class="lineNum">    1105 </span>            :   // which we don't recognize. We cannot parse DWARF CFI if it uses
<span class="lineNum">    1106 </span>            :   // augmentations we don't recognize.
<span class="lineNum">    1107 </span>            :   virtual void UnrecognizedAugmentation(uint64 offset,
<span class="lineNum">    1108 </span>            :                                         const std::string &amp;augmentation);
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            :   // The pointer encoding ENCODING, specified by the CIE at OFFSET, is not
<span class="lineNum">    1111 </span>            :   // a valid encoding.
<span class="lineNum">    1112 </span>            :   virtual void InvalidPointerEncoding(uint64 offset, uint8 encoding);
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :   // The pointer encoding ENCODING, specified by the CIE at OFFSET, depends
<span class="lineNum">    1115 </span>            :   // on a base address which has not been supplied.
<span class="lineNum">    1116 </span>            :   virtual void UnusablePointerEncoding(uint64 offset, uint8 encoding);
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :   // The CIE at OFFSET contains a DW_CFA_restore instruction at
<span class="lineNum">    1119 </span>            :   // INSN_OFFSET, which may not appear in a CIE.
<span class="lineNum">    1120 </span>            :   virtual void RestoreInCIE(uint64 offset, uint64 insn_offset);
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :   // The entry at OFFSET, of kind KIND, has an unrecognized
<span class="lineNum">    1123 </span>            :   // instruction at INSN_OFFSET.
<span class="lineNum">    1124 </span>            :   virtual void BadInstruction(uint64 offset, CallFrameInfo::EntryKind kind,
<span class="lineNum">    1125 </span>            :                               uint64 insn_offset);
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :   // The instruction at INSN_OFFSET in the entry at OFFSET, of kind
<span class="lineNum">    1128 </span>            :   // KIND, establishes a rule that cites the CFA, but we have not
<span class="lineNum">    1129 </span>            :   // established a CFA rule yet.
<span class="lineNum">    1130 </span>            :   virtual void NoCFARule(uint64 offset, CallFrameInfo::EntryKind kind,
<span class="lineNum">    1131 </span>            :                          uint64 insn_offset);
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span>            :   // The instruction at INSN_OFFSET in the entry at OFFSET, of kind
<span class="lineNum">    1134 </span>            :   // KIND, is a DW_CFA_restore_state instruction, but the stack of
<span class="lineNum">    1135 </span>            :   // saved states is empty.
<span class="lineNum">    1136 </span>            :   virtual void EmptyStateStack(uint64 offset, CallFrameInfo::EntryKind kind,
<span class="lineNum">    1137 </span>            :                                uint64 insn_offset);
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :   // The DW_CFA_remember_state instruction at INSN_OFFSET in the entry
<span class="lineNum">    1140 </span>            :   // at OFFSET, of kind KIND, would restore a state that has no CFA
<span class="lineNum">    1141 </span>            :   // rule, whereas the current state does have a CFA rule. This is
<span class="lineNum">    1142 </span>            :   // bogus input, which the CallFrameInfo::Handler interface doesn't
<span class="lineNum">    1143 </span>            :   // (and shouldn't) have any way to report.
<span class="lineNum">    1144 </span>            :   virtual void ClearingCFARule(uint64 offset, CallFrameInfo::EntryKind kind,
<span class="lineNum">    1145 </span>            :                                uint64 insn_offset);
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :  private:
<span class="lineNum">    1148 </span>            :   // A logging sink function, as supplied by LUL's user.
<span class="lineNum">    1149 </span>            :   void (*log_)(const char*);
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :  protected:
<span class="lineNum">    1152 </span>            :   // The name of the file whose CFI we're reading.
<span class="lineNum">    1153 </span>            :   std::string filename_;
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            :   // The name of the CFI section in that file.
<span class="lineNum">    1156 </span>            :   std::string section_;
<span class="lineNum">    1157 </span>            : };
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : using lul::CallFrameInfo;
<span class="lineNum">    1161 </span>            : using lul::Summariser;
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : // A class that accepts parsed call frame information from the DWARF
<span class="lineNum">    1164 </span>            : // CFI parser and populates a google_breakpad::Module object with the
<span class="lineNum">    1165 </span>            : // contents.
<span class="lineNum">    1166 </span>            : class DwarfCFIToModule: public CallFrameInfo::Handler {
<span class="lineNum">    1167 </span>            :  public:
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span>            :   // DwarfCFIToModule uses an instance of this class to report errors
<span class="lineNum">    1170 </span>            :   // detected while converting DWARF CFI to Breakpad STACK CFI records.
<span class="lineNum">    1171 </span>            :   class Reporter {
<span class="lineNum">    1172 </span>            :    public:
<span class="lineNum">    1173 </span>            :     // Create a reporter that writes messages to the message sink
<span class="lineNum">    1174 </span>            :     // |aLog|. FILE is the name of the file we're processing, and
<a name="1175"><span class="lineNum">    1175 </span>            :     // SECTION is the name of the section within that file that we're</a>
<span class="lineNum">    1176 </span>            :     // looking at (.debug_frame, .eh_frame, etc.).
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     Reporter(void (*aLog)(const char*),</span>
<a name="1178"><span class="lineNum">    1178 </span>            :              const std::string &amp;file, const std::string &amp;section)</a>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :       : log_(aLog), file_(file), section_(section) { }</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     virtual ~Reporter() { }</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :     // The DWARF CFI entry at OFFSET says that REG is undefined, but the
<span class="lineNum">    1183 </span>            :     // Breakpad symbol file format cannot express this.
<span class="lineNum">    1184 </span>            :     virtual void UndefinedNotSupported(size_t offset,
<span class="lineNum">    1185 </span>            :                                        const UniqueString* reg);
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            :     // The DWARF CFI entry at OFFSET says that REG uses a DWARF
<span class="lineNum">    1188 </span>            :     // expression to find its value, but parseDwarfExpr could not
<span class="lineNum">    1189 </span>            :     // convert it to a sequence of PfxInstrs.
<span class="lineNum">    1190 </span>            :     virtual void ExpressionCouldNotBeSummarised(size_t offset,
<span class="lineNum">    1191 </span>            :                                                 const UniqueString* reg);
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :   private:
<span class="lineNum">    1194 </span>            :     // A logging sink function, as supplied by LUL's user.
<span class="lineNum">    1195 </span>            :     void (*log_)(const char*);
<span class="lineNum">    1196 </span>            :   protected:
<span class="lineNum">    1197 </span>            :     std::string file_, section_;
<span class="lineNum">    1198 </span>            :   };
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :   // Register name tables. If TABLE is a vector returned by one of these
<span class="lineNum">    1201 </span>            :   // functions, then TABLE[R] is the name of the register numbered R in
<span class="lineNum">    1202 </span>            :   // DWARF call frame information.
<span class="lineNum">    1203 </span>            :   class RegisterNames {
<span class="lineNum">    1204 </span>            :    public:
<span class="lineNum">    1205 </span>            :     // Intel's &quot;x86&quot; or IA-32.
<span class="lineNum">    1206 </span>            :     static unsigned int I386();
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :     // AMD x86_64, AMD64, Intel EM64T, or Intel 64
<span class="lineNum">    1209 </span>            :     static unsigned int X86_64();
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :     // ARM.
<span class="lineNum">    1212 </span>            :     static unsigned int ARM();
<span class="lineNum">    1213 </span>            :   };
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :   // Create a handler for the dwarf2reader::CallFrameInfo parser that
<span class="lineNum">    1216 </span>            :   // records the stack unwinding information it receives in SUMM.
<span class="lineNum">    1217 </span>            :   //
<span class="lineNum">    1218 </span>            :   // Use REGISTER_NAMES[I] as the name of register number I; *this
<span class="lineNum">    1219 </span>            :   // keeps a reference to the vector, so the vector should remain
<span class="lineNum">    1220 </span>            :   // alive for as long as the DwarfCFIToModule does.
<span class="lineNum">    1221 </span>            :   //
<a name="1222"><span class="lineNum">    1222 </span>            :   // Use REPORTER for reporting problems encountered in the conversion</a>
<span class="lineNum">    1223 </span>            :   // process.
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :   DwarfCFIToModule(const unsigned int num_dw_regs,</span>
<span class="lineNum">    1225 </span>            :                    Reporter *reporter,
<span class="lineNum">    1226 </span>            :                    ByteReader* reader,
<span class="lineNum">    1227 </span>            :                    /*MOD*/UniqueStringUniverse* usu,
<span class="lineNum">    1228 </span>            :                    /*OUT*/Summariser* summ)
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :       : summ_(summ), usu_(usu), num_dw_regs_(num_dw_regs),</span>
<a name="1230"><span class="lineNum">    1230 </span><span class="lineNoCov">          0 :         reporter_(reporter), reader_(reader), return_address_(-1) {</span></a>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   virtual ~DwarfCFIToModule() {}</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :   virtual bool Entry(size_t offset, uint64 address, uint64 length,
<span class="lineNum">    1235 </span>            :                      uint8 version, const std::string &amp;augmentation,
<span class="lineNum">    1236 </span>            :                      unsigned return_address);
<span class="lineNum">    1237 </span>            :   virtual bool UndefinedRule(uint64 address, int reg);
<span class="lineNum">    1238 </span>            :   virtual bool SameValueRule(uint64 address, int reg);
<span class="lineNum">    1239 </span>            :   virtual bool OffsetRule(uint64 address, int reg,
<span class="lineNum">    1240 </span>            :                           int base_register, long offset);
<span class="lineNum">    1241 </span>            :   virtual bool ValOffsetRule(uint64 address, int reg,
<span class="lineNum">    1242 </span>            :                              int base_register, long offset);
<span class="lineNum">    1243 </span>            :   virtual bool RegisterRule(uint64 address, int reg, int base_register);
<span class="lineNum">    1244 </span>            :   virtual bool ExpressionRule(uint64 address, int reg,
<span class="lineNum">    1245 </span>            :                               const std::string &amp;expression);
<span class="lineNum">    1246 </span>            :   virtual bool ValExpressionRule(uint64 address, int reg,
<span class="lineNum">    1247 </span>            :                                  const std::string &amp;expression);
<span class="lineNum">    1248 </span>            :   virtual bool End();
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :  private:
<span class="lineNum">    1251 </span>            :   // Return the name to use for register I.
<span class="lineNum">    1252 </span>            :   const UniqueString* RegisterName(int i);
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            :   // The Summariser to which we should give entries
<span class="lineNum">    1255 </span>            :   Summariser* summ_;
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :   // Universe for creating UniqueStrings in, should that be necessary.
<span class="lineNum">    1258 </span>            :   UniqueStringUniverse* usu_;
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :   // The number of Dwarf-defined register names for this architecture.
<span class="lineNum">    1261 </span>            :   const unsigned int num_dw_regs_;
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            :   // The reporter to use to report problems.
<span class="lineNum">    1264 </span>            :   Reporter *reporter_;
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :   // The ByteReader to use for parsing Dwarf expressions.
<span class="lineNum">    1267 </span>            :   ByteReader* reader_;
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :   // The section offset of the current frame description entry, for
<span class="lineNum">    1270 </span>            :   // use in error messages.
<span class="lineNum">    1271 </span>            :   size_t entry_offset_;
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            :   // The return address column for that entry.
<span class="lineNum">    1274 </span>            :   unsigned return_address_;
<span class="lineNum">    1275 </span>            : };
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : // Convert the Dwarf expression in |expr| into PfxInstrs stored in the
<span class="lineNum">    1279 </span>            : // SecMap referred to by |summ|, and return the index of the starting
<span class="lineNum">    1280 </span>            : // PfxInstr added, which must be &gt;= 0.  In case of failure return -1.
<span class="lineNum">    1281 </span>            : int32_t parseDwarfExpr(Summariser* summ, const ByteReader* reader,
<span class="lineNum">    1282 </span>            :                        string expr, bool debug,
<span class="lineNum">    1283 </span>            :                        bool pushCfaAtStart, bool derefAtEnd);
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            : } // namespace lul
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            : #endif // LulDwarfExt_h
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

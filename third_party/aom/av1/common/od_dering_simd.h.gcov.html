<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/common/od_dering_simd.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/common</a> - od_dering_simd.h<span style="font-size: 80%;"> (source / <a href="od_dering_simd.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">223</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;./av1_rtcd.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;./cdef_simd.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;./od_dering.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /* partial A is a 16-bit vector of the form:
<span class="lineNum">      17 </span>            :    [x8 x7 x6 x5 x4 x3 x2 x1] and partial B has the form:
<span class="lineNum">      18 </span>            :    [0  y1 y2 y3 y4 y5 y6 y7].
<span class="lineNum">      19 </span>            :    This function computes (x1^2+y1^2)*C1 + (x2^2+y2^2)*C2 + ...
<a name="20"><span class="lineNum">      20 </span>            :    (x7^2+y2^7)*C7 + (x8^2+0^2)*C8 where the C1..C8 constants are in const1</a>
<span class="lineNum">      21 </span>            :    and const2. */
<span class="lineNum">      22 </span><span class="lineNoCov">          0 : static INLINE v128 fold_mul_and_sum(v128 partiala, v128 partialb, v128 const1,</span>
<span class="lineNum">      23 </span>            :                                     v128 const2) {
<span class="lineNum">      24 </span>            :   v128 tmp;
<span class="lineNum">      25 </span>            :   /* Reverse partial B. */
<span class="lineNum">      26 </span><span class="lineNoCov">          0 :   partialb = v128_shuffle_8(</span>
<span class="lineNum">      27 </span>            :       partialb, v128_from_32(0x0f0e0100, 0x03020504, 0x07060908, 0x0b0a0d0c));
<span class="lineNum">      28 </span>            :   /* Interleave the x and y values of identical indices and pair x8 with 0. */
<span class="lineNum">      29 </span><span class="lineNoCov">          0 :   tmp = partiala;</span>
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :   partiala = v128_ziplo_16(partialb, partiala);</span>
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :   partialb = v128_ziphi_16(partialb, tmp);</span>
<span class="lineNum">      32 </span>            :   /* Square and add the corresponding x and y values. */
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   partiala = v128_madd_s16(partiala, partiala);</span>
<span class="lineNum">      34 </span><span class="lineNoCov">          0 :   partialb = v128_madd_s16(partialb, partialb);</span>
<span class="lineNum">      35 </span>            :   /* Multiply by constant. */
<span class="lineNum">      36 </span><span class="lineNoCov">          0 :   partiala = v128_mullo_s32(partiala, const1);</span>
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :   partialb = v128_mullo_s32(partialb, const2);</span>
<span class="lineNum">      38 </span>            :   /* Sum all results. */
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :   partiala = v128_add_32(partiala, partialb);</span>
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :   return partiala;</span>
<a name="41"><span class="lineNum">      41 </span>            : }</a>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineNoCov">          0 : static INLINE v128 hsum4(v128 x0, v128 x1, v128 x2, v128 x3) {</span>
<span class="lineNum">      44 </span>            :   v128 t0, t1, t2, t3;
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :   t0 = v128_ziplo_32(x1, x0);</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :   t1 = v128_ziplo_32(x3, x2);</span>
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   t2 = v128_ziphi_32(x1, x0);</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   t3 = v128_ziphi_32(x3, x2);</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   x0 = v128_ziplo_64(t1, t0);</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   x1 = v128_ziphi_64(t1, t0);</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   x2 = v128_ziplo_64(t3, t2);</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   x3 = v128_ziphi_64(t3, t2);</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :   return v128_add_32(v128_add_32(x0, x1), v128_add_32(x2, x3));</span>
<span class="lineNum">      54 </span>            : }
<span class="lineNum">      55 </span>            : 
<a name="56"><span class="lineNum">      56 </span>            : /* Computes cost for directions 0, 5, 6 and 7. We can call this function again</a>
<span class="lineNum">      57 </span>            :    to compute the remaining directions. */
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : static INLINE v128 compute_directions(v128 lines[8], int32_t tmp_cost1[4]) {</span>
<span class="lineNum">      59 </span>            :   v128 partial4a, partial4b, partial5a, partial5b, partial7a, partial7b;
<span class="lineNum">      60 </span>            :   v128 partial6;
<span class="lineNum">      61 </span>            :   v128 tmp;
<span class="lineNum">      62 </span>            :   /* Partial sums for lines 0 and 1. */
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   partial4a = v128_shl_n_byte(lines[0], 14);</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   partial4b = v128_shr_n_byte(lines[0], 2);</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[1], 12));</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[1], 4));</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   tmp = v128_add_16(lines[0], lines[1]);</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   partial5a = v128_shl_n_byte(tmp, 10);</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   partial5b = v128_shr_n_byte(tmp, 6);</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   partial7a = v128_shl_n_byte(tmp, 4);</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   partial7b = v128_shr_n_byte(tmp, 12);</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   partial6 = tmp;</span>
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   /* Partial sums for lines 2 and 3. */
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[2], 10));</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[2], 6));</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[3], 8));</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[3], 8));</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   tmp = v128_add_16(lines[2], lines[3]);</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :   partial5a = v128_add_16(partial5a, v128_shl_n_byte(tmp, 8));</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   partial5b = v128_add_16(partial5b, v128_shr_n_byte(tmp, 8));</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   partial7a = v128_add_16(partial7a, v128_shl_n_byte(tmp, 6));</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :   partial7b = v128_add_16(partial7b, v128_shr_n_byte(tmp, 10));</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :   partial6 = v128_add_16(partial6, tmp);</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :   /* Partial sums for lines 4 and 5. */
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[4], 6));</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[4], 10));</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[5], 4));</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[5], 12));</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   tmp = v128_add_16(lines[4], lines[5]);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   partial5a = v128_add_16(partial5a, v128_shl_n_byte(tmp, 6));</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   partial5b = v128_add_16(partial5b, v128_shr_n_byte(tmp, 10));</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   partial7a = v128_add_16(partial7a, v128_shl_n_byte(tmp, 8));</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   partial7b = v128_add_16(partial7b, v128_shr_n_byte(tmp, 8));</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :   partial6 = v128_add_16(partial6, tmp);</span>
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :   /* Partial sums for lines 6 and 7. */
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, v128_shl_n_byte(lines[6], 2));</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   partial4b = v128_add_16(partial4b, v128_shr_n_byte(lines[6], 14));</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   partial4a = v128_add_16(partial4a, lines[7]);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   tmp = v128_add_16(lines[6], lines[7]);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   partial5a = v128_add_16(partial5a, v128_shl_n_byte(tmp, 4));</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   partial5b = v128_add_16(partial5b, v128_shr_n_byte(tmp, 12));</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   partial7a = v128_add_16(partial7a, v128_shl_n_byte(tmp, 10));</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   partial7b = v128_add_16(partial7b, v128_shr_n_byte(tmp, 6));</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   partial6 = v128_add_16(partial6, tmp);</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :   /* Compute costs in terms of partial sums. */
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   partial4a =</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :       fold_mul_and_sum(partial4a, partial4b, v128_from_32(210, 280, 420, 840),</span>
<span class="lineNum">     112 </span>            :                        v128_from_32(105, 120, 140, 168));
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   partial7a =</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :       fold_mul_and_sum(partial7a, partial7b, v128_from_32(210, 420, 0, 0),</span>
<span class="lineNum">     115 </span>            :                        v128_from_32(105, 105, 105, 140));
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   partial5a =</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       fold_mul_and_sum(partial5a, partial5b, v128_from_32(210, 420, 0, 0),</span>
<span class="lineNum">     118 </span>            :                        v128_from_32(105, 105, 105, 140));
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   partial6 = v128_madd_s16(partial6, partial6);</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   partial6 = v128_mullo_s32(partial6, v128_dup_32(105));</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   partial4a = hsum4(partial4a, partial5a, partial6, partial7a);</span>
<span class="lineNum">     123 </span>            :   v128_store_unaligned(tmp_cost1, partial4a);
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :   return partial4a;</span>
<span class="lineNum">     125 </span>            : }
<span class="lineNum">     126 </span>            : 
<a name="127"><span class="lineNum">     127 </span>            : /* transpose and reverse the order of the lines -- equivalent to a 90-degree</a>
<span class="lineNum">     128 </span>            :    counter-clockwise rotation of the pixels. */
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : static INLINE void array_reverse_transpose_8x8(v128 *in, v128 *res) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   const v128 tr0_0 = v128_ziplo_16(in[1], in[0]);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   const v128 tr0_1 = v128_ziplo_16(in[3], in[2]);</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   const v128 tr0_2 = v128_ziphi_16(in[1], in[0]);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   const v128 tr0_3 = v128_ziphi_16(in[3], in[2]);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   const v128 tr0_4 = v128_ziplo_16(in[5], in[4]);</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   const v128 tr0_5 = v128_ziplo_16(in[7], in[6]);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   const v128 tr0_6 = v128_ziphi_16(in[5], in[4]);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   const v128 tr0_7 = v128_ziphi_16(in[7], in[6]);</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   const v128 tr1_0 = v128_ziplo_32(tr0_1, tr0_0);</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   const v128 tr1_1 = v128_ziplo_32(tr0_5, tr0_4);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   const v128 tr1_2 = v128_ziphi_32(tr0_1, tr0_0);</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   const v128 tr1_3 = v128_ziphi_32(tr0_5, tr0_4);</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   const v128 tr1_4 = v128_ziplo_32(tr0_3, tr0_2);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   const v128 tr1_5 = v128_ziplo_32(tr0_7, tr0_6);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   const v128 tr1_6 = v128_ziphi_32(tr0_3, tr0_2);</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   const v128 tr1_7 = v128_ziphi_32(tr0_7, tr0_6);</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   res[7] = v128_ziplo_64(tr1_1, tr1_0);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   res[6] = v128_ziphi_64(tr1_1, tr1_0);</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   res[5] = v128_ziplo_64(tr1_3, tr1_2);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   res[4] = v128_ziphi_64(tr1_3, tr1_2);</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   res[3] = v128_ziplo_64(tr1_5, tr1_4);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   res[2] = v128_ziphi_64(tr1_5, tr1_4);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   res[1] = v128_ziplo_64(tr1_7, tr1_6);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   res[0] = v128_ziphi_64(tr1_7, tr1_6);</span>
<a name="156"><span class="lineNum">     156 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span><span class="lineNoCov">          0 : int SIMD_FUNC(od_dir_find8)(const od_dering_in *img, int stride, int32_t *var,</span>
<span class="lineNum">     159 </span>            :                             int coeff_shift) {
<span class="lineNum">     160 </span>            :   int i;
<span class="lineNum">     161 </span>            :   int32_t cost[8];
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   int32_t best_cost = 0;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   int best_dir = 0;</span>
<span class="lineNum">     164 </span>            :   v128 lines[8];
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     lines[i] = v128_load_unaligned(&amp;img[i * stride]);</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     lines[i] =</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :         v128_sub_16(v128_shr_s16(lines[i], coeff_shift), v128_dup_16(128));</span>
<span class="lineNum">     169 </span>            :   }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : #if defined(__SSE4_1__)
<span class="lineNum">     172 </span>            :   /* Compute &quot;mostly vertical&quot; directions. */
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   __m128i dir47 = compute_directions(lines, cost + 4);</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   array_reverse_transpose_8x8(lines, lines);</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   /* Compute &quot;mostly horizontal&quot; directions. */
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   __m128i dir03 = compute_directions(lines, cost);</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :   __m128i max = _mm_max_epi32(dir03, dir47);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   max = _mm_max_epi32(max, _mm_shuffle_epi32(max, _MM_SHUFFLE(1, 0, 3, 2)));</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :   max = _mm_max_epi32(max, _mm_shuffle_epi32(max, _MM_SHUFFLE(2, 3, 0, 1)));</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   best_cost = _mm_cvtsi128_si32(max);</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   __m128i t =</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :       _mm_packs_epi32(_mm_cmpeq_epi32(max, dir03), _mm_cmpeq_epi32(max, dir47));</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   best_dir = _mm_movemask_epi8(_mm_packs_epi16(t, t));</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   best_dir = get_msb(best_dir ^ (best_dir - 1));  // Count trailing zeros</span>
<span class="lineNum">     188 </span>            : #else
<span class="lineNum">     189 </span>            :   /* Compute &quot;mostly vertical&quot; directions. */
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   compute_directions(lines, cost + 4);</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   array_reverse_transpose_8x8(lines, lines);</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   /* Compute &quot;mostly horizontal&quot; directions. */
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   compute_directions(lines, cost);</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     if (cost[i] &gt; best_cost) {</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :       best_cost = cost[i];</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :       best_dir = i;</span>
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span>            :   }
<span class="lineNum">     203 </span>            : #endif
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   /* Difference between the optimal variance and the variance along the
<span class="lineNum">     206 </span>            :      orthogonal direction. Again, the sum(x^2) terms cancel out. */
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   *var = best_cost - cost[(best_dir + 4) &amp; 7];</span>
<span class="lineNum">     208 </span>            :   /* We'd normally divide by 840, but dividing by 1024 is close enough
<span class="lineNum">     209 </span>            :      for what we're going to do with this. */
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   *var &gt;&gt;= 10;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :   return best_dir;</span>
<a name="212"><span class="lineNum">     212 </span>            : }</a>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span><span class="lineNoCov">          0 : void SIMD_FUNC(od_filter_dering_direction_4x4)(uint16_t *y, int ystride,</span>
<span class="lineNum">     215 </span>            :                                                const uint16_t *in,
<span class="lineNum">     216 </span>            :                                                int threshold, int dir,
<span class="lineNum">     217 </span>            :                                                int damping) {
<span class="lineNum">     218 </span>            :   int i;
<span class="lineNum">     219 </span>            :   v128 p0, p1, sum, row, res;
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   int o1 = OD_DIRECTION_OFFSETS_TABLE[dir][0];</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   int o2 = OD_DIRECTION_OFFSETS_TABLE[dir][1];</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   if (threshold) damping -= get_msb(threshold);</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i += 2) {</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     sum = v128_zero();</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     row = v128_from_v64(v64_load_aligned(&amp;in[i * OD_FILT_BSTRIDE]),</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                         v64_load_aligned(&amp;in[(i + 1) * OD_FILT_BSTRIDE]));</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     // p0 = constrain16(in[i*OD_FILT_BSTRIDE + offset], row, threshold, damping)
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     p0 = v128_from_v64(v64_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE + o1]),</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                        v64_load_unaligned(&amp;in[(i + 1) * OD_FILT_BSTRIDE + o1]));</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     p0 = constrain16(p0, row, threshold, damping);</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     // p1 = constrain16(in[i*OD_FILT_BSTRIDE - offset], row, threshold, damping)
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     p1 = v128_from_v64(v64_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE - o1]),</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                        v64_load_unaligned(&amp;in[(i + 1) * OD_FILT_BSTRIDE - o1]));</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     p1 = constrain16(p1, row, threshold, damping);</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :     // sum += 4 * (p0 + p1)
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     sum = v128_add_16(sum, v128_shl_n_16(v128_add_16(p0, p1), 2));</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :     // p0 = constrain16(in[i*OD_FILT_BSTRIDE + offset], row, threshold, damping)
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     p0 = v128_from_v64(v64_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE + o2]),</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                        v64_load_unaligned(&amp;in[(i + 1) * OD_FILT_BSTRIDE + o2]));</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     p0 = constrain16(p0, row, threshold, damping);</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :     // p1 = constrain16(in[i*OD_FILT_BSTRIDE - offset], row, threshold, damping)
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     p1 = v128_from_v64(v64_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE - o2]),</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                        v64_load_unaligned(&amp;in[(i + 1) * OD_FILT_BSTRIDE - o2]));</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     p1 = constrain16(p1, row, threshold, damping);</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :     // sum += 1 * (p0 + p1)
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     sum = v128_add_16(sum, v128_add_16(p0, p1));</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :     // res = row + ((sum + 8) &gt;&gt; 4)
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     res = v128_add_16(sum, v128_dup_16(8));</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     res = v128_shr_n_s16(res, 4);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     res = v128_add_16(row, res);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     v64_store_aligned(&amp;y[i * ystride], v128_high_v64(res));</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     v64_store_aligned(&amp;y[(i + 1) * ystride], v128_low_v64(res));</span>
<span class="lineNum">     261 </span>            :   }
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : void SIMD_FUNC(od_filter_dering_direction_8x8)(uint16_t *y, int ystride,</span>
<span class="lineNum">     265 </span>            :                                                const uint16_t *in,
<span class="lineNum">     266 </span>            :                                                int threshold, int dir,
<span class="lineNum">     267 </span>            :                                                int damping) {
<span class="lineNum">     268 </span>            :   int i;
<span class="lineNum">     269 </span>            :   v128 sum, p0, p1, row, res;
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   int o1 = OD_DIRECTION_OFFSETS_TABLE[dir][0];</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   int o2 = OD_DIRECTION_OFFSETS_TABLE[dir][1];</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   int o3 = OD_DIRECTION_OFFSETS_TABLE[dir][2];</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   if (threshold) damping -= get_msb(threshold);</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     sum = v128_zero();</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     row = v128_load_aligned(&amp;in[i * OD_FILT_BSTRIDE]);</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     // p0 = constrain16(in[i*OD_FILT_BSTRIDE + offset], row, threshold, damping)
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     p0 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE + o1]);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     p0 = constrain16(p0, row, threshold, damping);</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :     // p1 = constrain16(in[i*OD_FILT_BSTRIDE - offset], row, threshold, damping)
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     p1 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE - o1]);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     p1 = constrain16(p1, row, threshold, damping);</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :     // sum += 3 * (p0 + p1)
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     p0 = v128_add_16(p0, p1);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     p0 = v128_add_16(p0, v128_shl_n_16(p0, 1));</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     sum = v128_add_16(sum, p0);</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     // p0 = constrain16(in[i*OD_FILT_BSTRIDE + offset], row, threshold, damping)
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     p0 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE + o2]);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     p0 = constrain16(p0, row, threshold, damping);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :     // p1 = constrain16(in[i*OD_FILT_BSTRIDE - offset], row, threshold, damping)
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     p1 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE - o2]);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     p1 = constrain16(p1, row, threshold, damping);</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :     // sum += 2 * (p0 + p1)
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     p0 = v128_shl_n_16(v128_add_16(p0, p1), 1);</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     sum = v128_add_16(sum, p0);</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     // p0 = constrain16(in[i*OD_FILT_BSTRIDE + offset], row, threshold, damping)
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     p0 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE + o3]);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     p0 = constrain16(p0, row, threshold, damping);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     // p1 = constrain16(in[i*OD_FILT_BSTRIDE - offset], row, threshold, damping)
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :     p1 = v128_load_unaligned(&amp;in[i * OD_FILT_BSTRIDE - o3]);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     p1 = constrain16(p1, row, threshold, damping);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :     // sum += (p0 + p1)
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     p0 = v128_add_16(p0, p1);</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     sum = v128_add_16(sum, p0);</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :     // res = row + ((sum + 8) &gt;&gt; 4)
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     res = v128_add_16(sum, v128_dup_16(8));</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     res = v128_shr_n_s16(res, 4);</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     res = v128_add_16(row, res);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     v128_store_unaligned(&amp;y[i * ystride], res);</span>
<span class="lineNum">     321 </span>            :   }
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_8x8_16bit_to_8bit)(uint8_t *dst, int dstride,</span>
<span class="lineNum">     325 </span>            :                                        const uint16_t *src, int sstride) {
<span class="lineNum">     326 </span>            :   int i;
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     v128 row = v128_load_unaligned(&amp;src[i * sstride]);</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     row = v128_pack_s16_u8(row, row);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     v64_store_unaligned(&amp;dst[i * dstride], v128_low_v64(row));</span>
<span class="lineNum">     331 </span>            :   }
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_4x4_16bit_to_8bit)(uint8_t *dst, int dstride,</span>
<span class="lineNum">     335 </span>            :                                        const uint16_t *src, int sstride) {
<span class="lineNum">     336 </span>            :   int i;
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     v128 row = v128_load_unaligned(&amp;src[i * sstride]);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     row = v128_pack_s16_u8(row, row);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     u32_store_unaligned(&amp;dst[i * dstride], v128_low_u32(row));</span>
<span class="lineNum">     341 </span>            :   }
<a name="342"><span class="lineNum">     342 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_8x8_16bit_to_16bit)(uint16_t *dst, int dstride,</span>
<span class="lineNum">     345 </span>            :                                         const uint16_t *src, int sstride) {
<span class="lineNum">     346 </span>            :   int i;
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :     v128 row = v128_load_unaligned(&amp;src[i * sstride]);</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     v128_store_unaligned(&amp;dst[i * dstride], row);</span>
<span class="lineNum">     350 </span>            :   }
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_4x4_16bit_to_16bit)(uint16_t *dst, int dstride,</span>
<span class="lineNum">     354 </span>            :                                         const uint16_t *src, int sstride) {
<span class="lineNum">     355 </span>            :   int i;
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++) {</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     v64 row = v64_load_unaligned(&amp;src[i * sstride]);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     v64_store_unaligned(&amp;dst[i * dstride], row);</span>
<span class="lineNum">     359 </span>            :   }
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_rect8_8bit_to_16bit)(uint16_t *dst, int dstride,</span>
<span class="lineNum">     363 </span>            :                                          const uint8_t *src, int sstride, int v,
<span class="lineNum">     364 </span>            :                                          int h) {
<span class="lineNum">     365 </span>            :   int i, j;
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; v; i++) {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; (h &amp; ~0x7); j += 8) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       v64 row = v64_load_unaligned(&amp;src[i * sstride + j]);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       v128_store_unaligned(&amp;dst[i * dstride + j], v128_unpack_u8_s16(row));</span>
<span class="lineNum">     370 </span>            :     }
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     for (; j &lt; h; j++) {</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       dst[i * dstride + j] = src[i * sstride + j];</span>
<span class="lineNum">     373 </span>            :     }
<span class="lineNum">     374 </span>            :   }
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span><span class="lineNoCov">          0 : void SIMD_FUNC(copy_rect8_16bit_to_16bit)(uint16_t *dst, int dstride,</span>
<span class="lineNum">     378 </span>            :                                           const uint16_t *src, int sstride,
<span class="lineNum">     379 </span>            :                                           int v, int h) {
<span class="lineNum">     380 </span>            :   int i, j;
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; v; i++) {</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; (h &amp; ~0x7); j += 8) {</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       v128 row = v128_load_unaligned(&amp;src[i * sstride + j]);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       v128_store_unaligned(&amp;dst[i * dstride + j], row);</span>
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :     for (; j &lt; h; j++) {</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :       dst[i * dstride + j] = src[i * sstride + j];</span>
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            :   }
<span class="lineNum">     390 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

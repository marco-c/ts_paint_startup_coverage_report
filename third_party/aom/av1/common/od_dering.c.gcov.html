<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/common/od_dering.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/common</a> - od_dering.c<span style="font-size: 80%;"> (source / <a href="od_dering.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">222</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #ifdef HAVE_CONFIG_H
<span class="lineNum">      16 </span>            : #include &quot;./config.h&quot;
<span class="lineNum">      17 </span>            : #endif
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;./aom_dsp_rtcd.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;./av1_rtcd.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;./cdef.h&quot;
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* Generated from gen_filter_tables.c. */
<span class="lineNum">      24 </span>            : const int OD_DIRECTION_OFFSETS_TABLE[8][3] = {
<span class="lineNum">      25 </span>            :   { -1 * OD_FILT_BSTRIDE + 1, -2 * OD_FILT_BSTRIDE + 2,
<span class="lineNum">      26 </span>            :     -3 * OD_FILT_BSTRIDE + 3 },
<span class="lineNum">      27 </span>            :   { 0 * OD_FILT_BSTRIDE + 1, -1 * OD_FILT_BSTRIDE + 2,
<span class="lineNum">      28 </span>            :     -1 * OD_FILT_BSTRIDE + 3 },
<span class="lineNum">      29 </span>            :   { 0 * OD_FILT_BSTRIDE + 1, 0 * OD_FILT_BSTRIDE + 2, 0 * OD_FILT_BSTRIDE + 3 },
<span class="lineNum">      30 </span>            :   { 0 * OD_FILT_BSTRIDE + 1, 1 * OD_FILT_BSTRIDE + 2, 1 * OD_FILT_BSTRIDE + 3 },
<span class="lineNum">      31 </span>            :   { 1 * OD_FILT_BSTRIDE + 1, 2 * OD_FILT_BSTRIDE + 2, 3 * OD_FILT_BSTRIDE + 3 },
<span class="lineNum">      32 </span>            :   { 1 * OD_FILT_BSTRIDE + 0, 2 * OD_FILT_BSTRIDE + 1, 3 * OD_FILT_BSTRIDE + 1 },
<span class="lineNum">      33 </span>            :   { 1 * OD_FILT_BSTRIDE + 0, 2 * OD_FILT_BSTRIDE + 0, 3 * OD_FILT_BSTRIDE + 0 },
<span class="lineNum">      34 </span>            :   { 1 * OD_FILT_BSTRIDE + 0, 2 * OD_FILT_BSTRIDE - 1, 3 * OD_FILT_BSTRIDE - 1 },
<span class="lineNum">      35 </span>            : };
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : /* Detect direction. 0 means 45-degree up-right, 2 is horizontal, and so on.
<span class="lineNum">      38 </span>            :    The search minimizes the weighted variance along all the lines in a
<span class="lineNum">      39 </span>            :    particular direction, i.e. the squared error between the input and a
<span class="lineNum">      40 </span>            :    &quot;predicted&quot; block where each pixel is replaced by the average along a line
<span class="lineNum">      41 </span>            :    in a particular direction. Since each direction have the same sum(x^2) term,
<a name="42"><span class="lineNum">      42 </span>            :    that term is never computed. See Section 2, step 2, of:</a>
<span class="lineNum">      43 </span>            :    http://jmvalin.ca/notes/intra_paint.pdf */
<span class="lineNum">      44 </span><span class="lineNoCov">          0 : int od_dir_find8_c(const uint16_t *img, int stride, int32_t *var,</span>
<span class="lineNum">      45 </span>            :                    int coeff_shift) {
<span class="lineNum">      46 </span>            :   int i;
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :   int32_t cost[8] = { 0 };</span>
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   int partial[8][15] = { { 0 } };</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   int32_t best_cost = 0;</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :   int best_dir = 0;</span>
<span class="lineNum">      51 </span>            :   /* Instead of dividing by n between 2 and 8, we multiply by 3*5*7*8/n.
<span class="lineNum">      52 </span>            :      The output is then 840 times larger, but we don't care for finding
<span class="lineNum">      53 </span>            :      the max. */
<span class="lineNum">      54 </span>            :   static const int div_table[] = { 0, 840, 420, 280, 210, 168, 140, 120, 105 };
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">      56 </span>            :     int j;
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++) {</span>
<span class="lineNum">      58 </span>            :       int x;
<span class="lineNum">      59 </span>            :       /* We subtract 128 here to reduce the maximum range of the squared
<span class="lineNum">      60 </span>            :          partial sums. */
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :       x = (img[i * stride + j] &gt;&gt; coeff_shift) - 128;</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :       partial[0][i + j] += x;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :       partial[1][i + j / 2] += x;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :       partial[2][i] += x;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :       partial[3][3 + i - j / 2] += x;</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :       partial[4][7 + i - j] += x;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :       partial[5][3 - i / 2 + j] += x;</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :       partial[6][j] += x;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :       partial[7][i / 2 + j] += x;</span>
<span class="lineNum">      70 </span>            :     }
<span class="lineNum">      71 </span>            :   }
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :     cost[2] += partial[2][i] * partial[2][i];</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     cost[6] += partial[6][i] * partial[6][i];</span>
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :   cost[2] *= div_table[8];</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   cost[6] *= div_table[8];</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 7; i++) {</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     cost[0] += (partial[0][i] * partial[0][i] +</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :                 partial[0][14 - i] * partial[0][14 - i]) *</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :                div_table[i + 1];</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     cost[4] += (partial[4][i] * partial[4][i] +</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :                 partial[4][14 - i] * partial[4][14 - i]) *</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :                div_table[i + 1];</span>
<span class="lineNum">      85 </span>            :   }
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :   cost[0] += partial[0][7] * partial[0][7] * div_table[8];</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   cost[4] += partial[4][7] * partial[4][7] * div_table[8];</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :   for (i = 1; i &lt; 8; i += 2) {</span>
<span class="lineNum">      89 </span>            :     int j;
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4 + 1; j++) {</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :       cost[i] += partial[i][3 + j] * partial[i][3 + j];</span>
<span class="lineNum">      92 </span>            :     }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     cost[i] *= div_table[8];</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4 - 1; j++) {</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :       cost[i] += (partial[i][j] * partial[i][j] +</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :                   partial[i][10 - j] * partial[i][10 - j]) *</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                  div_table[2 * j + 2];</span>
<span class="lineNum">      98 </span>            :     }
<span class="lineNum">      99 </span>            :   }
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     if (cost[i] &gt; best_cost) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :       best_cost = cost[i];</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :       best_dir = i;</span>
<span class="lineNum">     104 </span>            :     }
<span class="lineNum">     105 </span>            :   }
<span class="lineNum">     106 </span>            :   /* Difference between the optimal variance and the variance along the
<span class="lineNum">     107 </span>            :      orthogonal direction. Again, the sum(x^2) terms cancel out. */
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   *var = best_cost - cost[(best_dir + 4) &amp; 7];</span>
<span class="lineNum">     109 </span>            :   /* We'd normally divide by 840, but dividing by 1024 is close enough
<span class="lineNum">     110 </span>            :      for what we're going to do with this. */
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   *var &gt;&gt;= 10;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   return best_dir;</span>
<span class="lineNum">     113 </span>            : }
<a name="114"><span class="lineNum">     114 </span>            : </a>
<span class="lineNum">     115 </span>            : /* Smooth in the direction detected. */
<span class="lineNum">     116 </span><span class="lineNoCov">          0 : void od_filter_dering_direction_8x8_c(uint16_t *y, int ystride,</span>
<span class="lineNum">     117 </span>            :                                       const uint16_t *in, int threshold,
<span class="lineNum">     118 </span>            :                                       int dir, int damping) {
<span class="lineNum">     119 </span>            :   int i;
<span class="lineNum">     120 </span>            :   int j;
<span class="lineNum">     121 </span>            :   int k;
<span class="lineNum">     122 </span>            :   static const int taps[3] = { 3, 2, 1 };
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++) {</span>
<span class="lineNum">     125 </span>            :       int16_t sum;
<span class="lineNum">     126 </span>            :       int16_t xx;
<span class="lineNum">     127 </span>            :       int16_t yy;
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :       xx = in[i * OD_FILT_BSTRIDE + j];</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       sum = 0;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; 3; k++) {</span>
<span class="lineNum">     131 </span>            :         int16_t p0;
<span class="lineNum">     132 </span>            :         int16_t p1;
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         p0 = in[i * OD_FILT_BSTRIDE + j + OD_DIRECTION_OFFSETS_TABLE[dir][k]] -</span>
<span class="lineNum">     134 </span>            :              xx;
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         p1 = in[i * OD_FILT_BSTRIDE + j - OD_DIRECTION_OFFSETS_TABLE[dir][k]] -</span>
<span class="lineNum">     136 </span>            :              xx;
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         sum += taps[k] * constrain(p0, threshold, damping);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         sum += taps[k] * constrain(p1, threshold, damping);</span>
<span class="lineNum">     139 </span>            :       }
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       sum = (sum + 8) &gt;&gt; 4;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :       yy = xx + sum;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :       y[i * ystride + j] = yy;</span>
<span class="lineNum">     143 </span>            :     }
<span class="lineNum">     144 </span>            :   }
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : }</span>
<a name="146"><span class="lineNum">     146 </span>            : </a>
<span class="lineNum">     147 </span>            : /* Smooth in the direction detected. */
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : void od_filter_dering_direction_4x4_c(uint16_t *y, int ystride,</span>
<span class="lineNum">     149 </span>            :                                       const uint16_t *in, int threshold,
<span class="lineNum">     150 </span>            :                                       int dir, int damping) {
<span class="lineNum">     151 </span>            :   int i;
<span class="lineNum">     152 </span>            :   int j;
<span class="lineNum">     153 </span>            :   int k;
<span class="lineNum">     154 </span>            :   static const int taps[2] = { 4, 1 };
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4; j++) {</span>
<span class="lineNum">     157 </span>            :       int16_t sum;
<span class="lineNum">     158 </span>            :       int16_t xx;
<span class="lineNum">     159 </span>            :       int16_t yy;
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       xx = in[i * OD_FILT_BSTRIDE + j];</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       sum = 0;</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; 2; k++) {</span>
<span class="lineNum">     163 </span>            :         int16_t p0;
<span class="lineNum">     164 </span>            :         int16_t p1;
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :         p0 = in[i * OD_FILT_BSTRIDE + j + OD_DIRECTION_OFFSETS_TABLE[dir][k]] -</span>
<span class="lineNum">     166 </span>            :              xx;
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         p1 = in[i * OD_FILT_BSTRIDE + j - OD_DIRECTION_OFFSETS_TABLE[dir][k]] -</span>
<span class="lineNum">     168 </span>            :              xx;
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         sum += taps[k] * constrain(p0, threshold, damping);</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         sum += taps[k] * constrain(p1, threshold, damping);</span>
<span class="lineNum">     171 </span>            :       }
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       sum = (sum + 8) &gt;&gt; 4;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :       yy = xx + sum;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       y[i * ystride + j] = yy;</span>
<span class="lineNum">     175 </span>            :     }
<span class="lineNum">     176 </span>            :   }
<span class="lineNum">     177 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /* Compute deringing filter threshold for an 8x8 block based on the
<span class="lineNum">     180 </span>            :    directional variance difference. A high variance difference means that we
<span class="lineNum">     181 </span>            :    have a highly directional pattern (e.g. a high contrast edge), so we can
<span class="lineNum">     182 </span>            :    apply more deringing. A low variance means that we either have a low
<a name="183"><span class="lineNum">     183 </span>            :    contrast edge, or a non-directional texture, so we want to be careful not</a>
<span class="lineNum">     184 </span>            :    to blur. */
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : static INLINE int od_adjust_thresh(int threshold, int32_t var) {</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   const int i = var &gt;&gt; 6 ? AOMMIN(get_msb(var &gt;&gt; 6), 12) : 0;</span>
<span class="lineNum">     187 </span>            :   /* We use the variance of 8x8 blocks to adjust the threshold. */
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   return var ? (threshold * (4 + i) + 8) &gt;&gt; 4 : 0;</span>
<a name="189"><span class="lineNum">     189 </span>            : }</a>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 : void copy_8x8_16bit_to_16bit_c(uint16_t *dst, int dstride, const uint16_t *src,</span>
<span class="lineNum">     192 </span>            :                                int sstride) {
<span class="lineNum">     193 </span>            :   int i, j;
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++)</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++) dst[i * dstride + j] = src[i * sstride + j];</span>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : void copy_4x4_16bit_to_16bit_c(uint16_t *dst, int dstride, const uint16_t *src,</span>
<span class="lineNum">     199 </span>            :                                int sstride) {
<span class="lineNum">     200 </span>            :   int i, j;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4; j++) dst[i * dstride + j] = src[i * sstride + j];</span>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 : void copy_dering_16bit_to_16bit(uint16_t *dst, int dstride, uint16_t *src,</span>
<span class="lineNum">     206 </span>            :                                 dering_list *dlist, int dering_count,
<span class="lineNum">     207 </span>            :                                 int bsize) {
<span class="lineNum">     208 </span>            :   int bi, bx, by;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   if (bsize == BLOCK_8X8) {</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       copy_8x8_16bit_to_16bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                               &amp;src[bi &lt;&lt; (3 + 3)], 8);</span>
<span class="lineNum">     216 </span>            :     }
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_4X8) {</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_16bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                               &amp;src[bi &lt;&lt; (3 + 2)], 4);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_16bit(&amp;dst[((by &lt;&lt; 3) + 4) * dstride + (bx &lt;&lt; 2)],</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                               dstride, &amp;src[(bi &lt;&lt; (3 + 2)) + 4 * 4], 4);</span>
<span class="lineNum">     225 </span>            :     }
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_8X4) {</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                               &amp;src[bi &lt;&lt; (2 + 3)], 8);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3) + 4],</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                               dstride, &amp;src[(bi &lt;&lt; (2 + 3)) + 4], 8);</span>
<span class="lineNum">     234 </span>            :     }
<span class="lineNum">     235 </span>            :   } else {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     assert(bsize == BLOCK_4X4);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                               &amp;src[bi &lt;&lt; (2 + 2)], 4);</span>
<span class="lineNum">     242 </span>            :     }
<span class="lineNum">     243 </span>            :   }
<a name="244"><span class="lineNum">     244 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : void copy_8x8_16bit_to_8bit_c(uint8_t *dst, int dstride, const uint16_t *src,</span>
<span class="lineNum">     247 </span>            :                               int sstride) {
<span class="lineNum">     248 </span>            :   int i, j;
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++)</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++)</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :       dst[i * dstride + j] = (uint8_t)src[i * sstride + j];</span>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 : void copy_4x4_16bit_to_8bit_c(uint8_t *dst, int dstride, const uint16_t *src,</span>
<span class="lineNum">     255 </span>            :                               int sstride) {
<span class="lineNum">     256 </span>            :   int i, j;
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++)</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4; j++)</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :       dst[i * dstride + j] = (uint8_t)src[i * sstride + j];</span>
<a name="260"><span class="lineNum">     260 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : static void copy_dering_16bit_to_8bit(uint8_t *dst, int dstride,</span>
<span class="lineNum">     263 </span>            :                                       const uint16_t *src, dering_list *dlist,
<span class="lineNum">     264 </span>            :                                       int dering_count, int bsize) {
<span class="lineNum">     265 </span>            :   int bi, bx, by;
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   if (bsize == BLOCK_8X8) {</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       copy_8x8_16bit_to_8bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                              &amp;src[bi &lt;&lt; (3 + 3)], 8);</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_4X8) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_8bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                              &amp;src[bi &lt;&lt; (3 + 2)], 4);</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_8bit(&amp;dst[((by &lt;&lt; 3) + 4) * dstride + (bx &lt;&lt; 2)],</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                              dstride, &amp;src[(bi &lt;&lt; (3 + 2)) + 4 * 4], 4);</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_8X4) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_8bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :                              &amp;src[bi &lt;&lt; (2 + 3)], 8);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_8bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3) + 4], dstride,</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                              &amp;src[(bi &lt;&lt; (2 + 3)) + 4], 8);</span>
<span class="lineNum">     290 </span>            :     }
<span class="lineNum">     291 </span>            :   } else {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     assert(bsize == BLOCK_4X4);</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :       copy_4x4_16bit_to_8bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                              &amp;src[bi &lt;&lt; (2 * 2)], 4);</span>
<span class="lineNum">     298 </span>            :     }
<span class="lineNum">     299 </span>            :   }
<a name="300"><span class="lineNum">     300 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : int get_filter_skip(int level) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   int filter_skip = level &amp; 1;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   if (level == 1) filter_skip = 0;</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   return filter_skip;</span>
<a name="306"><span class="lineNum">     306 </span>            : }</a>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineNoCov">          0 : void od_dering(uint8_t *dst, int dstride, uint16_t *y, uint16_t *in, int xdec,</span>
<span class="lineNum">     309 </span>            :                int ydec, int dir[OD_DERING_NBLOCKS][OD_DERING_NBLOCKS],
<span class="lineNum">     310 </span>            :                int *dirinit, int var[OD_DERING_NBLOCKS][OD_DERING_NBLOCKS],
<span class="lineNum">     311 </span>            :                int pli, dering_list *dlist, int dering_count, int level,
<span class="lineNum">     312 </span>            :                int clpf_strength, int clpf_damping, int dering_damping,
<span class="lineNum">     313 </span>            :                int coeff_shift, int skip_dering, int hbd) {
<span class="lineNum">     314 </span>            :   int bi;
<span class="lineNum">     315 </span>            :   int bx;
<span class="lineNum">     316 </span>            :   int by;
<span class="lineNum">     317 </span>            :   int bsize, bsizex, bsizey;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :   int threshold = (level &gt;&gt; 1) &lt;&lt; coeff_shift;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   int filter_skip = get_filter_skip(level);</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   if (level == 1) threshold = 31 &lt;&lt; coeff_shift;</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   od_filter_dering_direction_func filter_dering_direction[] = {</span>
<span class="lineNum">     324 </span>            :     od_filter_dering_direction_4x4, od_filter_dering_direction_8x8
<span class="lineNum">     325 </span>            :   };
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   clpf_damping += coeff_shift - (pli != AOM_PLANE_Y);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   dering_damping += coeff_shift - (pli != AOM_PLANE_Y);</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   bsize =</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       ydec ? (xdec ? BLOCK_4X4 : BLOCK_8X4) : (xdec ? BLOCK_4X8 : BLOCK_8X8);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   bsizex = 3 - xdec;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :   bsizey = 3 - ydec;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   if (!skip_dering) {</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     if (pli == 0) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       if (!dirinit || !*dirinit) {</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :           by = dlist[bi].by;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :           bx = dlist[bi].bx;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :           dir[by][bx] =</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :               od_dir_find8(&amp;in[8 * by * OD_FILT_BSTRIDE + 8 * bx],</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                            OD_FILT_BSTRIDE, &amp;var[by][bx], coeff_shift);</span>
<span class="lineNum">     342 </span>            :         }
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         if (dirinit) *dirinit = 1;</span>
<span class="lineNum">     344 </span>            :       }
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span>            :     // Only run dering for non-zero threshold (which is always the case for
<span class="lineNum">     347 </span>            :     // 4:2:2 or 4:4:0). If we don't dering, we still need to eventually write
<span class="lineNum">     348 </span>            :     // something out in y[] later.
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if (threshold != 0) {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       assert(bsize == BLOCK_8X8 || bsize == BLOCK_4X4);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         int t = !filter_skip &amp;&amp; dlist[bi].skip ? 0 : threshold;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         by = dlist[bi].by;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         bx = dlist[bi].bx;</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         (filter_dering_direction[bsize == BLOCK_8X8])(</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             &amp;y[bi &lt;&lt; (bsizex + bsizey)], 1 &lt;&lt; bsizex,</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :             &amp;in[(by * OD_FILT_BSTRIDE &lt;&lt; bsizey) + (bx &lt;&lt; bsizex)],</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :             pli ? t : od_adjust_thresh(t, var[by][bx]), dir[by][bx],</span>
<span class="lineNum">     359 </span>            :             dering_damping);
<span class="lineNum">     360 </span>            :       }
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span>            :   }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   if (clpf_strength) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :     if (threshold &amp;&amp; !skip_dering)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :       copy_dering_16bit_to_16bit(in, OD_FILT_BSTRIDE, y, dlist, dering_count,</span>
<span class="lineNum">     367 </span>            :                                  bsize);
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       int py = by &lt;&lt; bsizey;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :       int px = bx &lt;&lt; bsizex;</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :       if (!filter_skip &amp;&amp; dlist[bi].skip) continue;</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       if (!dst || hbd) {</span>
<span class="lineNum">     376 </span>            :         // 16 bit destination if high bitdepth or 8 bit destination not given
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         (!threshold || (dir[by][bx] &lt; 4 &amp;&amp; dir[by][bx]) ? aom_clpf_block_hbd</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :                                                         : aom_clpf_hblock_hbd)(</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :             dst ? (uint16_t *)dst + py * dstride + px</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                 : &amp;y[bi &lt;&lt; (bsizex + bsizey)],</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             in + py * OD_FILT_BSTRIDE + px, dst &amp;&amp; hbd ? dstride : 1 &lt;&lt; bsizex,</span>
<span class="lineNum">     382 </span>            :             OD_FILT_BSTRIDE, 1 &lt;&lt; bsizex, 1 &lt;&lt; bsizey,
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :             clpf_strength &lt;&lt; coeff_shift, clpf_damping);</span>
<span class="lineNum">     384 </span>            :       } else {
<span class="lineNum">     385 </span>            :         // Do clpf and write the result to an 8 bit destination
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         (!threshold || (dir[by][bx] &lt; 4 &amp;&amp; dir[by][bx]) ? aom_clpf_block</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :                                                         : aom_clpf_hblock)(</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :             dst + py * dstride + px, in + py * OD_FILT_BSTRIDE + px, dstride,</span>
<span class="lineNum">     389 </span>            :             OD_FILT_BSTRIDE, 1 &lt;&lt; bsizex, 1 &lt;&lt; bsizey,
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :             clpf_strength &lt;&lt; coeff_shift, clpf_damping);</span>
<span class="lineNum">     391 </span>            :       }
<span class="lineNum">     392 </span>            :     }
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   } else if (threshold != 0) {</span>
<span class="lineNum">     394 </span>            :     // No clpf, so copy instead
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :     if (hbd) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :       copy_dering_16bit_to_16bit((uint16_t *)dst, dstride, y, dlist,</span>
<span class="lineNum">     397 </span>            :                                  dering_count, bsize);
<span class="lineNum">     398 </span>            :     } else {
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       copy_dering_16bit_to_8bit(dst, dstride, y, dlist, dering_count, bsize);</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   } else if (dirinit) {</span>
<span class="lineNum">     402 </span>            :     // If we're here, both dering and clpf are off, and we still haven't written
<span class="lineNum">     403 </span>            :     // anything to y[] yet, so we just copy the input to y[]. This is necessary
<span class="lineNum">     404 </span>            :     // only for av1_cdef_search() and only av1_cdef_search() sets dirinit.
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     408 </span>            :       int iy, ix;
<span class="lineNum">     409 </span>            :       // TODO(stemidts/jmvalin): SIMD optimisations
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       for (iy = 0; iy &lt; 1 &lt;&lt; bsizey; iy++)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         for (ix = 0; ix &lt; 1 &lt;&lt; bsizex; ix++)</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :           y[(bi &lt;&lt; (bsizex + bsizey)) + (iy &lt;&lt; bsizex) + ix] =</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :               in[((by &lt;&lt; bsizey) + iy) * OD_FILT_BSTRIDE + (bx &lt;&lt; bsizex) + ix];</span>
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            :   }
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

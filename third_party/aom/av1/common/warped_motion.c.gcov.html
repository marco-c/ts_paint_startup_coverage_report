<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/common/warped_motion.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/common</a> - warped_motion.c<span style="font-size: 80%;"> (source / <a href="warped_motion.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">623</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">42</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      14 </span>            : #include &lt;memory.h&gt;
<span class="lineNum">      15 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      16 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;./av1_rtcd.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;av1/common/warped_motion.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : /* clang-format off */
<span class="lineNum">      22 </span>            : static const int error_measure_lut[512] = {
<span class="lineNum">      23 </span>            :   // pow 0.7
<span class="lineNum">      24 </span>            :   16384, 16339, 16294, 16249, 16204, 16158, 16113, 16068,
<span class="lineNum">      25 </span>            :   16022, 15977, 15932, 15886, 15840, 15795, 15749, 15703,
<span class="lineNum">      26 </span>            :   15657, 15612, 15566, 15520, 15474, 15427, 15381, 15335,
<span class="lineNum">      27 </span>            :   15289, 15242, 15196, 15149, 15103, 15056, 15010, 14963,
<span class="lineNum">      28 </span>            :   14916, 14869, 14822, 14775, 14728, 14681, 14634, 14587,
<span class="lineNum">      29 </span>            :   14539, 14492, 14445, 14397, 14350, 14302, 14254, 14206,
<span class="lineNum">      30 </span>            :   14159, 14111, 14063, 14015, 13967, 13918, 13870, 13822,
<span class="lineNum">      31 </span>            :   13773, 13725, 13676, 13628, 13579, 13530, 13481, 13432,
<span class="lineNum">      32 </span>            :   13383, 13334, 13285, 13236, 13187, 13137, 13088, 13038,
<span class="lineNum">      33 </span>            :   12988, 12939, 12889, 12839, 12789, 12739, 12689, 12639,
<span class="lineNum">      34 </span>            :   12588, 12538, 12487, 12437, 12386, 12335, 12285, 12234,
<span class="lineNum">      35 </span>            :   12183, 12132, 12080, 12029, 11978, 11926, 11875, 11823,
<span class="lineNum">      36 </span>            :   11771, 11719, 11667, 11615, 11563, 11511, 11458, 11406,
<span class="lineNum">      37 </span>            :   11353, 11301, 11248, 11195, 11142, 11089, 11036, 10982,
<span class="lineNum">      38 </span>            :   10929, 10875, 10822, 10768, 10714, 10660, 10606, 10552,
<span class="lineNum">      39 </span>            :   10497, 10443, 10388, 10333, 10279, 10224, 10168, 10113,
<span class="lineNum">      40 </span>            :   10058, 10002,  9947,  9891,  9835,  9779,  9723,  9666,
<span class="lineNum">      41 </span>            :   9610, 9553, 9497, 9440, 9383, 9326, 9268, 9211,
<span class="lineNum">      42 </span>            :   9153, 9095, 9037, 8979, 8921, 8862, 8804, 8745,
<span class="lineNum">      43 </span>            :   8686, 8627, 8568, 8508, 8449, 8389, 8329, 8269,
<span class="lineNum">      44 </span>            :   8208, 8148, 8087, 8026, 7965, 7903, 7842, 7780,
<span class="lineNum">      45 </span>            :   7718, 7656, 7593, 7531, 7468, 7405, 7341, 7278,
<span class="lineNum">      46 </span>            :   7214, 7150, 7086, 7021, 6956, 6891, 6826, 6760,
<span class="lineNum">      47 </span>            :   6695, 6628, 6562, 6495, 6428, 6361, 6293, 6225,
<span class="lineNum">      48 </span>            :   6157, 6089, 6020, 5950, 5881, 5811, 5741, 5670,
<span class="lineNum">      49 </span>            :   5599, 5527, 5456, 5383, 5311, 5237, 5164, 5090,
<span class="lineNum">      50 </span>            :   5015, 4941, 4865, 4789, 4713, 4636, 4558, 4480,
<span class="lineNum">      51 </span>            :   4401, 4322, 4242, 4162, 4080, 3998, 3916, 3832,
<span class="lineNum">      52 </span>            :   3748, 3663, 3577, 3490, 3402, 3314, 3224, 3133,
<span class="lineNum">      53 </span>            :   3041, 2948, 2854, 2758, 2661, 2562, 2461, 2359,
<span class="lineNum">      54 </span>            :   2255, 2148, 2040, 1929, 1815, 1698, 1577, 1452,
<span class="lineNum">      55 </span>            :   1323, 1187, 1045,  894,  731,  550,  339,    0,
<span class="lineNum">      56 </span>            :   339,  550,  731,  894, 1045, 1187, 1323, 1452,
<span class="lineNum">      57 </span>            :   1577, 1698, 1815, 1929, 2040, 2148, 2255, 2359,
<span class="lineNum">      58 </span>            :   2461, 2562, 2661, 2758, 2854, 2948, 3041, 3133,
<span class="lineNum">      59 </span>            :   3224, 3314, 3402, 3490, 3577, 3663, 3748, 3832,
<span class="lineNum">      60 </span>            :   3916, 3998, 4080, 4162, 4242, 4322, 4401, 4480,
<span class="lineNum">      61 </span>            :   4558, 4636, 4713, 4789, 4865, 4941, 5015, 5090,
<span class="lineNum">      62 </span>            :   5164, 5237, 5311, 5383, 5456, 5527, 5599, 5670,
<span class="lineNum">      63 </span>            :   5741, 5811, 5881, 5950, 6020, 6089, 6157, 6225,
<span class="lineNum">      64 </span>            :   6293, 6361, 6428, 6495, 6562, 6628, 6695, 6760,
<span class="lineNum">      65 </span>            :   6826, 6891, 6956, 7021, 7086, 7150, 7214, 7278,
<span class="lineNum">      66 </span>            :   7341, 7405, 7468, 7531, 7593, 7656, 7718, 7780,
<span class="lineNum">      67 </span>            :   7842, 7903, 7965, 8026, 8087, 8148, 8208, 8269,
<span class="lineNum">      68 </span>            :   8329, 8389, 8449, 8508, 8568, 8627, 8686, 8745,
<span class="lineNum">      69 </span>            :   8804, 8862, 8921, 8979, 9037, 9095, 9153, 9211,
<span class="lineNum">      70 </span>            :   9268, 9326, 9383, 9440, 9497, 9553, 9610, 9666,
<span class="lineNum">      71 </span>            :   9723,  9779,  9835,  9891,  9947, 10002, 10058, 10113,
<span class="lineNum">      72 </span>            :   10168, 10224, 10279, 10333, 10388, 10443, 10497, 10552,
<span class="lineNum">      73 </span>            :   10606, 10660, 10714, 10768, 10822, 10875, 10929, 10982,
<span class="lineNum">      74 </span>            :   11036, 11089, 11142, 11195, 11248, 11301, 11353, 11406,
<span class="lineNum">      75 </span>            :   11458, 11511, 11563, 11615, 11667, 11719, 11771, 11823,
<span class="lineNum">      76 </span>            :   11875, 11926, 11978, 12029, 12080, 12132, 12183, 12234,
<span class="lineNum">      77 </span>            :   12285, 12335, 12386, 12437, 12487, 12538, 12588, 12639,
<span class="lineNum">      78 </span>            :   12689, 12739, 12789, 12839, 12889, 12939, 12988, 13038,
<span class="lineNum">      79 </span>            :   13088, 13137, 13187, 13236, 13285, 13334, 13383, 13432,
<span class="lineNum">      80 </span>            :   13481, 13530, 13579, 13628, 13676, 13725, 13773, 13822,
<span class="lineNum">      81 </span>            :   13870, 13918, 13967, 14015, 14063, 14111, 14159, 14206,
<span class="lineNum">      82 </span>            :   14254, 14302, 14350, 14397, 14445, 14492, 14539, 14587,
<span class="lineNum">      83 </span>            :   14634, 14681, 14728, 14775, 14822, 14869, 14916, 14963,
<span class="lineNum">      84 </span>            :   15010, 15056, 15103, 15149, 15196, 15242, 15289, 15335,
<span class="lineNum">      85 </span>            :   15381, 15427, 15474, 15520, 15566, 15612, 15657, 15703,
<span class="lineNum">      86 </span>            :   15749, 15795, 15840, 15886, 15932, 15977, 16022, 16068,
<span class="lineNum">      87 </span>            :   16113, 16158, 16204, 16249, 16294, 16339, 16384, 16384,
<span class="lineNum">      88 </span>            : };
<a name="89"><span class="lineNum">      89 </span>            : /* clang-format on */</a>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span><span class="lineNoCov">          0 : static ProjectPointsFunc get_project_points_type(TransformationType type) {</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :   switch (type) {</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :     case HOMOGRAPHY: return project_points_homography;</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :     case AFFINE: return project_points_affine;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     case ROTZOOM: return project_points_rotzoom;</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     case TRANSLATION: return project_points_translation;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     default: assert(0); return NULL;</span>
<span class="lineNum">      98 </span>            :   }
<a name="99"><span class="lineNum">      99 </span>            : }</a>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 : void project_points_translation(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     102 </span>            :                                 const int n, const int stride_points,
<span class="lineNum">     103 </span>            :                                 const int stride_proj, const int subsampling_x,
<span class="lineNum">     104 </span>            :                                 const int subsampling_y) {
<span class="lineNum">     105 </span>            :   int i;
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     const int x = *(points++), y = *(points++);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :     if (subsampling_x)</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     110 </span>            :           ((x * (1 &lt;&lt; (WARPEDMODEL_PREC_BITS + 1))) + mat[0]),
<span class="lineNum">     111 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     112 </span>            :     else
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     114 </span>            :           ((x * (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) + mat[0]), WARPEDDIFF_PREC_BITS);
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     if (subsampling_y)</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     117 </span>            :           ((y * (1 &lt;&lt; (WARPEDMODEL_PREC_BITS + 1))) + mat[1]),
<span class="lineNum">     118 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     119 </span>            :     else
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     121 </span>            :           ((y * (1 &lt;&lt; WARPEDMODEL_PREC_BITS))) + mat[1], WARPEDDIFF_PREC_BITS);
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     124 </span>            :   }
<a name="125"><span class="lineNum">     125 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineNoCov">          0 : void project_points_rotzoom(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     128 </span>            :                             const int n, const int stride_points,
<span class="lineNum">     129 </span>            :                             const int stride_proj, const int subsampling_x,
<span class="lineNum">     130 </span>            :                             const int subsampling_y) {
<span class="lineNum">     131 </span>            :   int i;
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     const int x = *(points++), y = *(points++);</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     if (subsampling_x)</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     136 </span>            :           mat[2] * 2 * x + mat[3] * 2 * y + mat[0] +
<span class="lineNum">     137 </span>            :               (mat[2] + mat[3] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) / 2,
<span class="lineNum">     138 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     139 </span>            :     else
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(mat[2] * x + mat[3] * y + mat[0],</span>
<span class="lineNum">     141 </span>            :                                             WARPEDDIFF_PREC_BITS);
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :     if (subsampling_y)</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     144 </span>            :           -mat[3] * 2 * x + mat[2] * 2 * y + mat[1] +
<span class="lineNum">     145 </span>            :               (-mat[3] + mat[2] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) / 2,
<span class="lineNum">     146 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     147 </span>            :     else
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(-mat[3] * x + mat[2] * y + mat[1],</span>
<span class="lineNum">     149 </span>            :                                             WARPEDDIFF_PREC_BITS);
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     152 </span>            :   }
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineNoCov">          0 : void project_points_affine(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     156 </span>            :                            const int n, const int stride_points,
<span class="lineNum">     157 </span>            :                            const int stride_proj, const int subsampling_x,
<span class="lineNum">     158 </span>            :                            const int subsampling_y) {
<span class="lineNum">     159 </span>            :   int i;
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     const int x = *(points++), y = *(points++);</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if (subsampling_x)</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     164 </span>            :           mat[2] * 2 * x + mat[3] * 2 * y + mat[0] +
<span class="lineNum">     165 </span>            :               (mat[2] + mat[3] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) / 2,
<span class="lineNum">     166 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     167 </span>            :     else
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(mat[2] * x + mat[3] * y + mat[0],</span>
<span class="lineNum">     169 </span>            :                                             WARPEDDIFF_PREC_BITS);
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     if (subsampling_y)</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     172 </span>            :           mat[4] * 2 * x + mat[5] * 2 * y + mat[1] +
<span class="lineNum">     173 </span>            :               (mat[4] + mat[5] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) / 2,
<span class="lineNum">     174 </span>            :           WARPEDDIFF_PREC_BITS + 1);
<span class="lineNum">     175 </span>            :     else
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       *(proj++) = ROUND_POWER_OF_TWO_SIGNED(mat[4] * x + mat[5] * y + mat[1],</span>
<span class="lineNum">     177 </span>            :                                             WARPEDDIFF_PREC_BITS);
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     180 </span>            :   }
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 : void project_points_hortrapezoid(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     184 </span>            :                                  const int n, const int stride_points,
<span class="lineNum">     185 </span>            :                                  const int stride_proj, const int subsampling_x,
<span class="lineNum">     186 </span>            :                                  const int subsampling_y) {
<span class="lineNum">     187 </span>            :   int i;
<span class="lineNum">     188 </span>            :   int64_t x, y, Z;
<span class="lineNum">     189 </span>            :   int64_t xp, yp;
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     x = *(points++), y = *(points++);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     x = (subsampling_x ? 4 * x + 1 : 2 * x);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     y = (subsampling_y ? 4 * y + 1 : 2 * y);</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     Z = (mat[7] * y + (1 &lt;&lt; (WARPEDMODEL_ROW3HOMO_PREC_BITS + 1)));</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     xp = (mat[2] * x + mat[3] * y + 2 * mat[0]) *</span>
<span class="lineNum">     197 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     198 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     yp = (mat[5] * y + 2 * mat[1]) *</span>
<span class="lineNum">     200 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     201 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     xp = xp &gt; 0 ? (xp + Z / 2) / Z : (xp - Z / 2) / Z;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     yp = yp &gt; 0 ? (yp + Z / 2) / Z : (yp - Z / 2) / Z;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     if (subsampling_x) xp = (xp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :     if (subsampling_y) yp = (yp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :     *(proj++) = (int)xp;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     *(proj++) = (int)yp;</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     213 </span>            :   }
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : void project_points_vertrapezoid(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     217 </span>            :                                  const int n, const int stride_points,
<span class="lineNum">     218 </span>            :                                  const int stride_proj, const int subsampling_x,
<span class="lineNum">     219 </span>            :                                  const int subsampling_y) {
<span class="lineNum">     220 </span>            :   int i;
<span class="lineNum">     221 </span>            :   int64_t x, y, Z;
<span class="lineNum">     222 </span>            :   int64_t xp, yp;
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     x = *(points++), y = *(points++);</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     x = (subsampling_x ? 4 * x + 1 : 2 * x);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     y = (subsampling_y ? 4 * y + 1 : 2 * y);</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     Z = (mat[6] * x + (1 &lt;&lt; (WARPEDMODEL_ROW3HOMO_PREC_BITS + 1)));</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     xp = (mat[2] * x + 2 * mat[0]) *</span>
<span class="lineNum">     230 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     231 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :     yp = (mat[4] * x + mat[5] * y + 2 * mat[1]) *</span>
<span class="lineNum">     233 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     234 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     xp = xp &gt; 0 ? (xp + Z / 2) / Z : (xp - Z / 2) / Z;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     yp = yp &gt; 0 ? (yp + Z / 2) / Z : (yp - Z / 2) / Z;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     if (subsampling_x) xp = (xp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     if (subsampling_y) yp = (yp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     *(proj++) = (int)xp;</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     *(proj++) = (int)yp;</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     246 </span>            :   }
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineNoCov">          0 : void project_points_homography(const int32_t *mat, int *points, int *proj,</span>
<span class="lineNum">     250 </span>            :                                const int n, const int stride_points,
<span class="lineNum">     251 </span>            :                                const int stride_proj, const int subsampling_x,
<span class="lineNum">     252 </span>            :                                const int subsampling_y) {
<span class="lineNum">     253 </span>            :   int i;
<span class="lineNum">     254 </span>            :   int64_t x, y, Z;
<span class="lineNum">     255 </span>            :   int64_t xp, yp;
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; n; ++i) {</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     x = *(points++), y = *(points++);</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :     x = (subsampling_x ? 4 * x + 1 : 2 * x);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :     y = (subsampling_y ? 4 * y + 1 : 2 * y);</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     Z = (mat[6] * x + mat[7] * y + (1 &lt;&lt; (WARPEDMODEL_ROW3HOMO_PREC_BITS + 1)));</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :     xp = (mat[2] * x + mat[3] * y + 2 * mat[0]) *</span>
<span class="lineNum">     263 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     264 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     yp = (mat[4] * x + mat[5] * y + 2 * mat[1]) *</span>
<span class="lineNum">     266 </span>            :          (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS + WARPEDMODEL_ROW3HOMO_PREC_BITS -
<span class="lineNum">     267 </span>            :                 WARPEDMODEL_PREC_BITS));
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     xp = xp &gt; 0 ? (xp + Z / 2) / Z : (xp - Z / 2) / Z;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     yp = yp &gt; 0 ? (yp + Z / 2) / Z : (yp - Z / 2) / Z;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     if (subsampling_x) xp = (xp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     if (subsampling_y) yp = (yp - (1 &lt;&lt; (WARPEDPIXEL_PREC_BITS - 1))) / 2;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     *(proj++) = (int)xp;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     *(proj++) = (int)yp;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     points += stride_points - 2;</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :     proj += stride_proj - 2;</span>
<span class="lineNum">     279 </span>            :   }
<span class="lineNum">     280 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     281 </span>            : 
<a name="282"><span class="lineNum">     282 </span>            : // 'points' are at original scale, output 'proj's are scaled up by</a>
<span class="lineNum">     283 </span>            : // 1 &lt;&lt; WARPEDPIXEL_PREC_BITS
<span class="lineNum">     284 </span><span class="lineNoCov">          0 : void project_points(const WarpedMotionParams *wm_params, int *points, int *proj,</span>
<span class="lineNum">     285 </span>            :                     const int n, const int stride_points, const int stride_proj,
<span class="lineNum">     286 </span>            :                     const int subsampling_x, const int subsampling_y) {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   switch (wm_params-&gt;wmtype) {</span>
<span class="lineNum">     288 </span>            :     case AFFINE:
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       project_points_affine(wm_params-&gt;wmmat, points, proj, n, stride_points,</span>
<span class="lineNum">     290 </span>            :                             stride_proj, subsampling_x, subsampling_y);
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     292 </span>            :     case ROTZOOM:
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       project_points_rotzoom(wm_params-&gt;wmmat, points, proj, n, stride_points,</span>
<span class="lineNum">     294 </span>            :                              stride_proj, subsampling_x, subsampling_y);
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     296 </span>            :     case HOMOGRAPHY:
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :       project_points_homography(wm_params-&gt;wmmat, points, proj, n,</span>
<span class="lineNum">     298 </span>            :                                 stride_points, stride_proj, subsampling_x,
<span class="lineNum">     299 </span>            :                                 subsampling_y);
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     default: assert(0 &amp;&amp; &quot;Invalid warped motion type!&quot;); return;</span>
<span class="lineNum">     302 </span>            :   }
<span class="lineNum">     303 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : static const int16_t
<span class="lineNum">     306 </span>            :     filter_ntap[WARPEDPIXEL_PREC_SHIFTS][WARPEDPIXEL_FILTER_TAPS] = {
<span class="lineNum">     307 </span>            : #if WARPEDPIXEL_PREC_BITS == 6
<span class="lineNum">     308 </span>            :       { 0, 0, 128, 0, 0, 0 },      { 0, -1, 128, 2, -1, 0 },
<span class="lineNum">     309 </span>            :       { 1, -3, 127, 4, -1, 0 },    { 1, -4, 126, 6, -2, 1 },
<span class="lineNum">     310 </span>            :       { 1, -5, 126, 8, -3, 1 },    { 1, -6, 125, 11, -4, 1 },
<span class="lineNum">     311 </span>            :       { 1, -7, 124, 13, -4, 1 },   { 2, -8, 123, 15, -5, 1 },
<span class="lineNum">     312 </span>            :       { 2, -9, 122, 18, -6, 1 },   { 2, -10, 121, 20, -6, 1 },
<span class="lineNum">     313 </span>            :       { 2, -11, 120, 22, -7, 2 },  { 2, -12, 119, 25, -8, 2 },
<span class="lineNum">     314 </span>            :       { 3, -13, 117, 27, -8, 2 },  { 3, -13, 116, 29, -9, 2 },
<span class="lineNum">     315 </span>            :       { 3, -14, 114, 32, -10, 3 }, { 3, -15, 113, 35, -10, 2 },
<span class="lineNum">     316 </span>            :       { 3, -15, 111, 37, -11, 3 }, { 3, -16, 109, 40, -11, 3 },
<span class="lineNum">     317 </span>            :       { 3, -16, 108, 42, -12, 3 }, { 4, -17, 106, 45, -13, 3 },
<span class="lineNum">     318 </span>            :       { 4, -17, 104, 47, -13, 3 }, { 4, -17, 102, 50, -14, 3 },
<span class="lineNum">     319 </span>            :       { 4, -17, 100, 52, -14, 3 }, { 4, -18, 98, 55, -15, 4 },
<span class="lineNum">     320 </span>            :       { 4, -18, 96, 58, -15, 3 },  { 4, -18, 94, 60, -16, 4 },
<span class="lineNum">     321 </span>            :       { 4, -18, 91, 63, -16, 4 },  { 4, -18, 89, 65, -16, 4 },
<span class="lineNum">     322 </span>            :       { 4, -18, 87, 68, -17, 4 },  { 4, -18, 85, 70, -17, 4 },
<span class="lineNum">     323 </span>            :       { 4, -18, 82, 73, -17, 4 },  { 4, -18, 80, 75, -17, 4 },
<span class="lineNum">     324 </span>            :       { 4, -18, 78, 78, -18, 4 },  { 4, -17, 75, 80, -18, 4 },
<span class="lineNum">     325 </span>            :       { 4, -17, 73, 82, -18, 4 },  { 4, -17, 70, 85, -18, 4 },
<span class="lineNum">     326 </span>            :       { 4, -17, 68, 87, -18, 4 },  { 4, -16, 65, 89, -18, 4 },
<span class="lineNum">     327 </span>            :       { 4, -16, 63, 91, -18, 4 },  { 4, -16, 60, 94, -18, 4 },
<span class="lineNum">     328 </span>            :       { 3, -15, 58, 96, -18, 4 },  { 4, -15, 55, 98, -18, 4 },
<span class="lineNum">     329 </span>            :       { 3, -14, 52, 100, -17, 4 }, { 3, -14, 50, 102, -17, 4 },
<span class="lineNum">     330 </span>            :       { 3, -13, 47, 104, -17, 4 }, { 3, -13, 45, 106, -17, 4 },
<span class="lineNum">     331 </span>            :       { 3, -12, 42, 108, -16, 3 }, { 3, -11, 40, 109, -16, 3 },
<span class="lineNum">     332 </span>            :       { 3, -11, 37, 111, -15, 3 }, { 2, -10, 35, 113, -15, 3 },
<span class="lineNum">     333 </span>            :       { 3, -10, 32, 114, -14, 3 }, { 2, -9, 29, 116, -13, 3 },
<span class="lineNum">     334 </span>            :       { 2, -8, 27, 117, -13, 3 },  { 2, -8, 25, 119, -12, 2 },
<span class="lineNum">     335 </span>            :       { 2, -7, 22, 120, -11, 2 },  { 1, -6, 20, 121, -10, 2 },
<span class="lineNum">     336 </span>            :       { 1, -6, 18, 122, -9, 2 },   { 1, -5, 15, 123, -8, 2 },
<span class="lineNum">     337 </span>            :       { 1, -4, 13, 124, -7, 1 },   { 1, -4, 11, 125, -6, 1 },
<span class="lineNum">     338 </span>            :       { 1, -3, 8, 126, -5, 1 },    { 1, -2, 6, 126, -4, 1 },
<span class="lineNum">     339 </span>            :       { 0, -1, 4, 127, -3, 1 },    { 0, -1, 2, 128, -1, 0 },
<span class="lineNum">     340 </span>            : #elif WARPEDPIXEL_PREC_BITS == 5
<span class="lineNum">     341 </span>            :       { 0, 0, 128, 0, 0, 0 },      { 1, -3, 127, 4, -1, 0 },
<span class="lineNum">     342 </span>            :       { 1, -5, 126, 8, -3, 1 },    { 1, -7, 124, 13, -4, 1 },
<span class="lineNum">     343 </span>            :       { 2, -9, 122, 18, -6, 1 },   { 2, -11, 120, 22, -7, 2 },
<span class="lineNum">     344 </span>            :       { 3, -13, 117, 27, -8, 2 },  { 3, -14, 114, 32, -10, 3 },
<span class="lineNum">     345 </span>            :       { 3, -15, 111, 37, -11, 3 }, { 3, -16, 108, 42, -12, 3 },
<span class="lineNum">     346 </span>            :       { 4, -17, 104, 47, -13, 3 }, { 4, -17, 100, 52, -14, 3 },
<span class="lineNum">     347 </span>            :       { 4, -18, 96, 58, -15, 3 },  { 4, -18, 91, 63, -16, 4 },
<span class="lineNum">     348 </span>            :       { 4, -18, 87, 68, -17, 4 },  { 4, -18, 82, 73, -17, 4 },
<span class="lineNum">     349 </span>            :       { 4, -18, 78, 78, -18, 4 },  { 4, -17, 73, 82, -18, 4 },
<span class="lineNum">     350 </span>            :       { 4, -17, 68, 87, -18, 4 },  { 4, -16, 63, 91, -18, 4 },
<span class="lineNum">     351 </span>            :       { 3, -15, 58, 96, -18, 4 },  { 3, -14, 52, 100, -17, 4 },
<span class="lineNum">     352 </span>            :       { 3, -13, 47, 104, -17, 4 }, { 3, -12, 42, 108, -16, 3 },
<span class="lineNum">     353 </span>            :       { 3, -11, 37, 111, -15, 3 }, { 3, -10, 32, 114, -14, 3 },
<span class="lineNum">     354 </span>            :       { 2, -8, 27, 117, -13, 3 },  { 2, -7, 22, 120, -11, 2 },
<span class="lineNum">     355 </span>            :       { 1, -6, 18, 122, -9, 2 },   { 1, -4, 13, 124, -7, 1 },
<span class="lineNum">     356 </span>            :       { 1, -3, 8, 126, -5, 1 },    { 0, -1, 4, 127, -3, 1 },
<span class="lineNum">     357 </span>            : #endif  // WARPEDPIXEL_PREC_BITS == 6
<a name="358"><span class="lineNum">     358 </span>            :     };</a>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 : static int32_t do_ntap_filter(const int32_t *const p, int x) {</span>
<span class="lineNum">     361 </span>            :   int i;
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   int32_t sum = 0;</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; WARPEDPIXEL_FILTER_TAPS; ++i) {</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     sum += p[i - WARPEDPIXEL_FILTER_TAPS / 2 + 1] * filter_ntap[x][i];</span>
<span class="lineNum">     365 </span>            :   }
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   return sum;</span>
<a name="367"><span class="lineNum">     367 </span>            : }</a>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 : static int32_t do_cubic_filter(const int32_t *const p, int x) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   if (x == 0) {</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :     return p[0] * (1 &lt;&lt; WARPEDPIXEL_FILTER_BITS);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   } else if (x == (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)) {</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     return p[1] * (1 &lt;&lt; WARPEDPIXEL_FILTER_BITS);</span>
<span class="lineNum">     374 </span>            :   } else {
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     const int64_t v1 = (int64_t)x * x * x * (3 * (p[0] - p[1]) + p[2] - p[-1]);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     const int64_t v2 =</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         (int64_t)x * x * (2 * p[-1] - 5 * p[0] + 4 * p[1] - p[2]);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     const int64_t v3 = x * (p[1] - p[-1]);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     const int64_t v4 = 2 * p[0];</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     return (int32_t)ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     381 </span>            :         (v4 * (1 &lt;&lt; (3 * WARPEDPIXEL_PREC_BITS))) +
<span class="lineNum">     382 </span>            :             (v3 * (1 &lt;&lt; (2 * WARPEDPIXEL_PREC_BITS))) +
<span class="lineNum">     383 </span>            :             (v2 * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)) + v1,
<span class="lineNum">     384 </span>            :         3 * WARPEDPIXEL_PREC_BITS + 1 - WARPEDPIXEL_FILTER_BITS);
<span class="lineNum">     385 </span>            :   }
<a name="386"><span class="lineNum">     386 </span>            : }</a>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : static INLINE void get_subcolumn(int taps, const uint8_t *const ref,</span>
<span class="lineNum">     389 </span>            :                                  int32_t *col, int stride, int x, int y_start) {
<span class="lineNum">     390 </span>            :   int i;
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; taps; ++i) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     col[i] = ref[(i + y_start) * stride + x];</span>
<span class="lineNum">     393 </span>            :   }
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineNoCov">          0 : static uint8_t bi_ntap_filter(const uint8_t *const ref, int x, int y,</span>
<span class="lineNum">     397 </span>            :                               int stride) {
<span class="lineNum">     398 </span>            :   int32_t val, arr[WARPEDPIXEL_FILTER_TAPS];
<span class="lineNum">     399 </span>            :   int k;
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :   const int i = (int)x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   const int j = (int)y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; WARPEDPIXEL_FILTER_TAPS; ++k) {</span>
<span class="lineNum">     403 </span>            :     int32_t arr_temp[WARPEDPIXEL_FILTER_TAPS];
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :     get_subcolumn(WARPEDPIXEL_FILTER_TAPS, ref, arr_temp, stride,</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                   i + k + 1 - WARPEDPIXEL_FILTER_TAPS / 2,</span>
<span class="lineNum">     406 </span>            :                   j + 1 - WARPEDPIXEL_FILTER_TAPS / 2);
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     arr[k] = do_ntap_filter(arr_temp + WARPEDPIXEL_FILTER_TAPS / 2 - 1,</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                             y - (j * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     409 </span>            :   }
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :   val = do_ntap_filter(arr + WARPEDPIXEL_FILTER_TAPS / 2 - 1,</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                        x - (i * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(val, WARPEDPIXEL_FILTER_BITS * 2);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   return (uint8_t)clip_pixel(val);</span>
<a name="414"><span class="lineNum">     414 </span>            : }</a>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : static uint8_t bi_cubic_filter(const uint8_t *const ref, int x, int y,</span>
<span class="lineNum">     417 </span>            :                                int stride) {
<span class="lineNum">     418 </span>            :   int32_t val, arr[4];
<span class="lineNum">     419 </span>            :   int k;
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   const int i = (int)x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   const int j = (int)y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 4; ++k) {</span>
<span class="lineNum">     423 </span>            :     int32_t arr_temp[4];
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     get_subcolumn(4, ref, arr_temp, stride, i + k - 1, j - 1);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     arr[k] =</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :         do_cubic_filter(arr_temp + 1, y - (j * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   val = do_cubic_filter(arr + 1, x - (i * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(val, WARPEDPIXEL_FILTER_BITS * 2);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   return (uint8_t)clip_pixel(val);</span>
<a name="431"><span class="lineNum">     431 </span>            : }</a>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 : static uint8_t bi_linear_filter(const uint8_t *const ref, int x, int y,</span>
<span class="lineNum">     434 </span>            :                                 int stride) {
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :   const int ix = x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   const int iy = y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   const int sx = x - (ix * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   const int sy = y - (iy * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     439 </span>            :   int32_t val;
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     441 </span>            :       ref[iy * stride + ix] * (WARPEDPIXEL_PREC_SHIFTS - sy) *
<span class="lineNum">     442 </span>            :               (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     443 </span>            :           ref[iy * stride + ix + 1] * (WARPEDPIXEL_PREC_SHIFTS - sy) * sx +
<span class="lineNum">     444 </span>            :           ref[(iy + 1) * stride + ix] * sy * (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     445 </span>            :           ref[(iy + 1) * stride + ix + 1] * sy * sx,
<span class="lineNum">     446 </span>            :       WARPEDPIXEL_PREC_BITS * 2);
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   return (uint8_t)clip_pixel(val);</span>
<a name="448"><span class="lineNum">     448 </span>            : }</a>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : static uint8_t warp_interpolate(const uint8_t *const ref, int x, int y,</span>
<span class="lineNum">     451 </span>            :                                 int width, int height, int stride) {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   const int ix = x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :   const int iy = y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   const int sx = x - (ix * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   const int sy = y - (iy * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     456 </span>            :   int32_t v;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   if (ix &lt; 0 &amp;&amp; iy &lt; 0)</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     return ref[0];</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   else if (ix &lt; 0 &amp;&amp; iy &gt;= height - 1)</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     return ref[(height - 1) * stride];</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   else if (ix &gt;= width - 1 &amp;&amp; iy &lt; 0)</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     return ref[width - 1];</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   else if (ix &gt;= width - 1 &amp;&amp; iy &gt;= height - 1)</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     return ref[(height - 1) * stride + (width - 1)];</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   else if (ix &lt; 0) {</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     468 </span>            :         ref[iy * stride] * (WARPEDPIXEL_PREC_SHIFTS - sy) +
<span class="lineNum">     469 </span>            :             ref[(iy + 1) * stride] * sy,
<span class="lineNum">     470 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     return clip_pixel(v);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   } else if (iy &lt; 0) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     474 </span>            :         ref[ix] * (WARPEDPIXEL_PREC_SHIFTS - sx) + ref[ix + 1] * sx,
<span class="lineNum">     475 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     return clip_pixel(v);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   } else if (ix &gt;= width - 1) {</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     479 </span>            :         ref[iy * stride + width - 1] * (WARPEDPIXEL_PREC_SHIFTS - sy) +
<span class="lineNum">     480 </span>            :             ref[(iy + 1) * stride + width - 1] * sy,
<span class="lineNum">     481 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :     return clip_pixel(v);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   } else if (iy &gt;= height - 1) {</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     485 </span>            :         ref[(height - 1) * stride + ix] * (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     486 </span>            :             ref[(height - 1) * stride + ix + 1] * sx,
<span class="lineNum">     487 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     return clip_pixel(v);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   } else if (ix &gt;= WARPEDPIXEL_FILTER_TAPS / 2 - 1 &amp;&amp;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :              iy &gt;= WARPEDPIXEL_FILTER_TAPS / 2 - 1 &amp;&amp;</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :              ix &lt; width - WARPEDPIXEL_FILTER_TAPS / 2 &amp;&amp;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :              iy &lt; height - WARPEDPIXEL_FILTER_TAPS / 2) {</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     return bi_ntap_filter(ref, x, y, stride);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   } else if (ix &gt;= 1 &amp;&amp; iy &gt;= 1 &amp;&amp; ix &lt; width - 2 &amp;&amp; iy &lt; height - 2) {</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     return bi_cubic_filter(ref, x, y, stride);</span>
<span class="lineNum">     496 </span>            :   } else {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     return bi_linear_filter(ref, x, y, stride);</span>
<span class="lineNum">     498 </span>            :   }
<span class="lineNum">     499 </span>            : }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : // For warping, we really use a 6-tap filter, but we do blocks of 8 pixels
<span class="lineNum">     502 </span>            : // at a time. The zoom/rotation/shear in the model are applied to the
<span class="lineNum">     503 </span>            : // &quot;fractional&quot; position of each pixel, which therefore varies within
<span class="lineNum">     504 </span>            : // [-1, 2) * WARPEDPIXEL_PREC_SHIFTS.
<span class="lineNum">     505 </span>            : // We need an extra 2 taps to fit this in, for a total of 8 taps.
<span class="lineNum">     506 </span>            : /* clang-format off */
<span class="lineNum">     507 </span>            : const int16_t warped_filter[WARPEDPIXEL_PREC_SHIFTS * 3 + 1][8] = {
<span class="lineNum">     508 </span>            : #if WARPEDPIXEL_PREC_BITS == 6
<span class="lineNum">     509 </span>            :   // [-1, 0)
<span class="lineNum">     510 </span>            :   { 0,   0, 127,   1,   0, 0, 0, 0 }, { 0, - 1, 127,   2,   0, 0, 0, 0 },
<span class="lineNum">     511 </span>            :   { 1, - 3, 127,   4, - 1, 0, 0, 0 }, { 1, - 4, 126,   6, - 2, 1, 0, 0 },
<span class="lineNum">     512 </span>            :   { 1, - 5, 126,   8, - 3, 1, 0, 0 }, { 1, - 6, 125,  11, - 4, 1, 0, 0 },
<span class="lineNum">     513 </span>            :   { 1, - 7, 124,  13, - 4, 1, 0, 0 }, { 2, - 8, 123,  15, - 5, 1, 0, 0 },
<span class="lineNum">     514 </span>            :   { 2, - 9, 122,  18, - 6, 1, 0, 0 }, { 2, -10, 121,  20, - 6, 1, 0, 0 },
<span class="lineNum">     515 </span>            :   { 2, -11, 120,  22, - 7, 2, 0, 0 }, { 2, -12, 119,  25, - 8, 2, 0, 0 },
<span class="lineNum">     516 </span>            :   { 3, -13, 117,  27, - 8, 2, 0, 0 }, { 3, -13, 116,  29, - 9, 2, 0, 0 },
<span class="lineNum">     517 </span>            :   { 3, -14, 114,  32, -10, 3, 0, 0 }, { 3, -15, 113,  35, -10, 2, 0, 0 },
<span class="lineNum">     518 </span>            :   { 3, -15, 111,  37, -11, 3, 0, 0 }, { 3, -16, 109,  40, -11, 3, 0, 0 },
<span class="lineNum">     519 </span>            :   { 3, -16, 108,  42, -12, 3, 0, 0 }, { 4, -17, 106,  45, -13, 3, 0, 0 },
<span class="lineNum">     520 </span>            :   { 4, -17, 104,  47, -13, 3, 0, 0 }, { 4, -17, 102,  50, -14, 3, 0, 0 },
<span class="lineNum">     521 </span>            :   { 4, -17, 100,  52, -14, 3, 0, 0 }, { 4, -18,  98,  55, -15, 4, 0, 0 },
<span class="lineNum">     522 </span>            :   { 4, -18,  96,  58, -15, 3, 0, 0 }, { 4, -18,  94,  60, -16, 4, 0, 0 },
<span class="lineNum">     523 </span>            :   { 4, -18,  91,  63, -16, 4, 0, 0 }, { 4, -18,  89,  65, -16, 4, 0, 0 },
<span class="lineNum">     524 </span>            :   { 4, -18,  87,  68, -17, 4, 0, 0 }, { 4, -18,  85,  70, -17, 4, 0, 0 },
<span class="lineNum">     525 </span>            :   { 4, -18,  82,  73, -17, 4, 0, 0 }, { 4, -18,  80,  75, -17, 4, 0, 0 },
<span class="lineNum">     526 </span>            :   { 4, -18,  78,  78, -18, 4, 0, 0 }, { 4, -17,  75,  80, -18, 4, 0, 0 },
<span class="lineNum">     527 </span>            :   { 4, -17,  73,  82, -18, 4, 0, 0 }, { 4, -17,  70,  85, -18, 4, 0, 0 },
<span class="lineNum">     528 </span>            :   { 4, -17,  68,  87, -18, 4, 0, 0 }, { 4, -16,  65,  89, -18, 4, 0, 0 },
<span class="lineNum">     529 </span>            :   { 4, -16,  63,  91, -18, 4, 0, 0 }, { 4, -16,  60,  94, -18, 4, 0, 0 },
<span class="lineNum">     530 </span>            :   { 3, -15,  58,  96, -18, 4, 0, 0 }, { 4, -15,  55,  98, -18, 4, 0, 0 },
<span class="lineNum">     531 </span>            :   { 3, -14,  52, 100, -17, 4, 0, 0 }, { 3, -14,  50, 102, -17, 4, 0, 0 },
<span class="lineNum">     532 </span>            :   { 3, -13,  47, 104, -17, 4, 0, 0 }, { 3, -13,  45, 106, -17, 4, 0, 0 },
<span class="lineNum">     533 </span>            :   { 3, -12,  42, 108, -16, 3, 0, 0 }, { 3, -11,  40, 109, -16, 3, 0, 0 },
<span class="lineNum">     534 </span>            :   { 3, -11,  37, 111, -15, 3, 0, 0 }, { 2, -10,  35, 113, -15, 3, 0, 0 },
<span class="lineNum">     535 </span>            :   { 3, -10,  32, 114, -14, 3, 0, 0 }, { 2, - 9,  29, 116, -13, 3, 0, 0 },
<span class="lineNum">     536 </span>            :   { 2, - 8,  27, 117, -13, 3, 0, 0 }, { 2, - 8,  25, 119, -12, 2, 0, 0 },
<span class="lineNum">     537 </span>            :   { 2, - 7,  22, 120, -11, 2, 0, 0 }, { 1, - 6,  20, 121, -10, 2, 0, 0 },
<span class="lineNum">     538 </span>            :   { 1, - 6,  18, 122, - 9, 2, 0, 0 }, { 1, - 5,  15, 123, - 8, 2, 0, 0 },
<span class="lineNum">     539 </span>            :   { 1, - 4,  13, 124, - 7, 1, 0, 0 }, { 1, - 4,  11, 125, - 6, 1, 0, 0 },
<span class="lineNum">     540 </span>            :   { 1, - 3,   8, 126, - 5, 1, 0, 0 }, { 1, - 2,   6, 126, - 4, 1, 0, 0 },
<span class="lineNum">     541 </span>            :   { 0, - 1,   4, 127, - 3, 1, 0, 0 }, { 0,   0,   2, 127, - 1, 0, 0, 0 },
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   // [0, 1)
<span class="lineNum">     544 </span>            :   { 0,  0,   0, 127,   1,   0,  0,  0}, { 0,  0,  -1, 127,   2,   0,  0,  0},
<span class="lineNum">     545 </span>            :   { 0,  1,  -3, 127,   4,  -2,  1,  0}, { 0,  1,  -5, 127,   6,  -2,  1,  0},
<span class="lineNum">     546 </span>            :   { 0,  2,  -6, 126,   8,  -3,  1,  0}, {-1,  2,  -7, 126,  11,  -4,  2, -1},
<span class="lineNum">     547 </span>            :   {-1,  3,  -8, 125,  13,  -5,  2, -1}, {-1,  3, -10, 124,  16,  -6,  3, -1},
<span class="lineNum">     548 </span>            :   {-1,  4, -11, 123,  18,  -7,  3, -1}, {-1,  4, -12, 122,  20,  -7,  3, -1},
<span class="lineNum">     549 </span>            :   {-1,  4, -13, 121,  23,  -8,  3, -1}, {-2,  5, -14, 120,  25,  -9,  4, -1},
<span class="lineNum">     550 </span>            :   {-1,  5, -15, 119,  27, -10,  4, -1}, {-1,  5, -16, 118,  30, -11,  4, -1},
<span class="lineNum">     551 </span>            :   {-2,  6, -17, 116,  33, -12,  5, -1}, {-2,  6, -17, 114,  35, -12,  5, -1},
<span class="lineNum">     552 </span>            :   {-2,  6, -18, 113,  38, -13,  5, -1}, {-2,  7, -19, 111,  41, -14,  6, -2},
<span class="lineNum">     553 </span>            :   {-2,  7, -19, 110,  43, -15,  6, -2}, {-2,  7, -20, 108,  46, -15,  6, -2},
<span class="lineNum">     554 </span>            :   {-2,  7, -20, 106,  49, -16,  6, -2}, {-2,  7, -21, 104,  51, -16,  7, -2},
<span class="lineNum">     555 </span>            :   {-2,  7, -21, 102,  54, -17,  7, -2}, {-2,  8, -21, 100,  56, -18,  7, -2},
<span class="lineNum">     556 </span>            :   {-2,  8, -22,  98,  59, -18,  7, -2}, {-2,  8, -22,  96,  62, -19,  7, -2},
<span class="lineNum">     557 </span>            :   {-2,  8, -22,  94,  64, -19,  7, -2}, {-2,  8, -22,  91,  67, -20,  8, -2},
<span class="lineNum">     558 </span>            :   {-2,  8, -22,  89,  69, -20,  8, -2}, {-2,  8, -22,  87,  72, -21,  8, -2},
<span class="lineNum">     559 </span>            :   {-2,  8, -21,  84,  74, -21,  8, -2}, {-2,  8, -22,  82,  77, -21,  8, -2},
<span class="lineNum">     560 </span>            :   {-2,  8, -21,  79,  79, -21,  8, -2}, {-2,  8, -21,  77,  82, -22,  8, -2},
<span class="lineNum">     561 </span>            :   {-2,  8, -21,  74,  84, -21,  8, -2}, {-2,  8, -21,  72,  87, -22,  8, -2},
<span class="lineNum">     562 </span>            :   {-2,  8, -20,  69,  89, -22,  8, -2}, {-2,  8, -20,  67,  91, -22,  8, -2},
<span class="lineNum">     563 </span>            :   {-2,  7, -19,  64,  94, -22,  8, -2}, {-2,  7, -19,  62,  96, -22,  8, -2},
<span class="lineNum">     564 </span>            :   {-2,  7, -18,  59,  98, -22,  8, -2}, {-2,  7, -18,  56, 100, -21,  8, -2},
<span class="lineNum">     565 </span>            :   {-2,  7, -17,  54, 102, -21,  7, -2}, {-2,  7, -16,  51, 104, -21,  7, -2},
<span class="lineNum">     566 </span>            :   {-2,  6, -16,  49, 106, -20,  7, -2}, {-2,  6, -15,  46, 108, -20,  7, -2},
<span class="lineNum">     567 </span>            :   {-2,  6, -15,  43, 110, -19,  7, -2}, {-2,  6, -14,  41, 111, -19,  7, -2},
<span class="lineNum">     568 </span>            :   {-1,  5, -13,  38, 113, -18,  6, -2}, {-1,  5, -12,  35, 114, -17,  6, -2},
<span class="lineNum">     569 </span>            :   {-1,  5, -12,  33, 116, -17,  6, -2}, {-1,  4, -11,  30, 118, -16,  5, -1},
<span class="lineNum">     570 </span>            :   {-1,  4, -10,  27, 119, -15,  5, -1}, {-1,  4,  -9,  25, 120, -14,  5, -2},
<span class="lineNum">     571 </span>            :   {-1,  3,  -8,  23, 121, -13,  4, -1}, {-1,  3,  -7,  20, 122, -12,  4, -1},
<span class="lineNum">     572 </span>            :   {-1,  3,  -7,  18, 123, -11,  4, -1}, {-1,  3,  -6,  16, 124, -10,  3, -1},
<span class="lineNum">     573 </span>            :   {-1,  2,  -5,  13, 125,  -8,  3, -1}, {-1,  2,  -4,  11, 126,  -7,  2, -1},
<span class="lineNum">     574 </span>            :   { 0,  1,  -3,   8, 126,  -6,  2,  0}, { 0,  1,  -2,   6, 127,  -5,  1,  0},
<span class="lineNum">     575 </span>            :   { 0,  1,  -2,   4, 127,  -3,  1,  0}, { 0,  0,   0,   2, 127,  -1,  0,  0},
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :   // [1, 2)
<span class="lineNum">     578 </span>            :   { 0, 0, 0,   1, 127,   0,   0, 0 }, { 0, 0, 0, - 1, 127,   2,   0, 0 },
<span class="lineNum">     579 </span>            :   { 0, 0, 1, - 3, 127,   4, - 1, 0 }, { 0, 0, 1, - 4, 126,   6, - 2, 1 },
<span class="lineNum">     580 </span>            :   { 0, 0, 1, - 5, 126,   8, - 3, 1 }, { 0, 0, 1, - 6, 125,  11, - 4, 1 },
<span class="lineNum">     581 </span>            :   { 0, 0, 1, - 7, 124,  13, - 4, 1 }, { 0, 0, 2, - 8, 123,  15, - 5, 1 },
<span class="lineNum">     582 </span>            :   { 0, 0, 2, - 9, 122,  18, - 6, 1 }, { 0, 0, 2, -10, 121,  20, - 6, 1 },
<span class="lineNum">     583 </span>            :   { 0, 0, 2, -11, 120,  22, - 7, 2 }, { 0, 0, 2, -12, 119,  25, - 8, 2 },
<span class="lineNum">     584 </span>            :   { 0, 0, 3, -13, 117,  27, - 8, 2 }, { 0, 0, 3, -13, 116,  29, - 9, 2 },
<span class="lineNum">     585 </span>            :   { 0, 0, 3, -14, 114,  32, -10, 3 }, { 0, 0, 3, -15, 113,  35, -10, 2 },
<span class="lineNum">     586 </span>            :   { 0, 0, 3, -15, 111,  37, -11, 3 }, { 0, 0, 3, -16, 109,  40, -11, 3 },
<span class="lineNum">     587 </span>            :   { 0, 0, 3, -16, 108,  42, -12, 3 }, { 0, 0, 4, -17, 106,  45, -13, 3 },
<span class="lineNum">     588 </span>            :   { 0, 0, 4, -17, 104,  47, -13, 3 }, { 0, 0, 4, -17, 102,  50, -14, 3 },
<span class="lineNum">     589 </span>            :   { 0, 0, 4, -17, 100,  52, -14, 3 }, { 0, 0, 4, -18,  98,  55, -15, 4 },
<span class="lineNum">     590 </span>            :   { 0, 0, 4, -18,  96,  58, -15, 3 }, { 0, 0, 4, -18,  94,  60, -16, 4 },
<span class="lineNum">     591 </span>            :   { 0, 0, 4, -18,  91,  63, -16, 4 }, { 0, 0, 4, -18,  89,  65, -16, 4 },
<span class="lineNum">     592 </span>            :   { 0, 0, 4, -18,  87,  68, -17, 4 }, { 0, 0, 4, -18,  85,  70, -17, 4 },
<span class="lineNum">     593 </span>            :   { 0, 0, 4, -18,  82,  73, -17, 4 }, { 0, 0, 4, -18,  80,  75, -17, 4 },
<span class="lineNum">     594 </span>            :   { 0, 0, 4, -18,  78,  78, -18, 4 }, { 0, 0, 4, -17,  75,  80, -18, 4 },
<span class="lineNum">     595 </span>            :   { 0, 0, 4, -17,  73,  82, -18, 4 }, { 0, 0, 4, -17,  70,  85, -18, 4 },
<span class="lineNum">     596 </span>            :   { 0, 0, 4, -17,  68,  87, -18, 4 }, { 0, 0, 4, -16,  65,  89, -18, 4 },
<span class="lineNum">     597 </span>            :   { 0, 0, 4, -16,  63,  91, -18, 4 }, { 0, 0, 4, -16,  60,  94, -18, 4 },
<span class="lineNum">     598 </span>            :   { 0, 0, 3, -15,  58,  96, -18, 4 }, { 0, 0, 4, -15,  55,  98, -18, 4 },
<span class="lineNum">     599 </span>            :   { 0, 0, 3, -14,  52, 100, -17, 4 }, { 0, 0, 3, -14,  50, 102, -17, 4 },
<span class="lineNum">     600 </span>            :   { 0, 0, 3, -13,  47, 104, -17, 4 }, { 0, 0, 3, -13,  45, 106, -17, 4 },
<span class="lineNum">     601 </span>            :   { 0, 0, 3, -12,  42, 108, -16, 3 }, { 0, 0, 3, -11,  40, 109, -16, 3 },
<span class="lineNum">     602 </span>            :   { 0, 0, 3, -11,  37, 111, -15, 3 }, { 0, 0, 2, -10,  35, 113, -15, 3 },
<span class="lineNum">     603 </span>            :   { 0, 0, 3, -10,  32, 114, -14, 3 }, { 0, 0, 2, - 9,  29, 116, -13, 3 },
<span class="lineNum">     604 </span>            :   { 0, 0, 2, - 8,  27, 117, -13, 3 }, { 0, 0, 2, - 8,  25, 119, -12, 2 },
<span class="lineNum">     605 </span>            :   { 0, 0, 2, - 7,  22, 120, -11, 2 }, { 0, 0, 1, - 6,  20, 121, -10, 2 },
<span class="lineNum">     606 </span>            :   { 0, 0, 1, - 6,  18, 122, - 9, 2 }, { 0, 0, 1, - 5,  15, 123, - 8, 2 },
<span class="lineNum">     607 </span>            :   { 0, 0, 1, - 4,  13, 124, - 7, 1 }, { 0, 0, 1, - 4,  11, 125, - 6, 1 },
<span class="lineNum">     608 </span>            :   { 0, 0, 1, - 3,   8, 126, - 5, 1 }, { 0, 0, 1, - 2,   6, 126, - 4, 1 },
<span class="lineNum">     609 </span>            :   { 0, 0, 0, - 1,   4, 127, - 3, 1 }, { 0, 0, 0,   0,   2, 127, - 1, 0 },
<span class="lineNum">     610 </span>            :   // dummy (replicate row index 191)
<span class="lineNum">     611 </span>            :   { 0, 0, 0,   0,   2, 127, - 1, 0 },
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : #elif WARPEDPIXEL_PREC_BITS == 5
<span class="lineNum">     614 </span>            :   // [-1, 0)
<span class="lineNum">     615 </span>            :   {0,   0, 127,   1,   0, 0, 0, 0}, {1,  -3, 127,   4,  -1, 0, 0, 0},
<span class="lineNum">     616 </span>            :   {1,  -5, 126,   8,  -3, 1, 0, 0}, {1,  -7, 124,  13,  -4, 1, 0, 0},
<span class="lineNum">     617 </span>            :   {2,  -9, 122,  18,  -6, 1, 0, 0}, {2, -11, 120,  22,  -7, 2, 0, 0},
<span class="lineNum">     618 </span>            :   {3, -13, 117,  27,  -8, 2, 0, 0}, {3, -14, 114,  32, -10, 3, 0, 0},
<span class="lineNum">     619 </span>            :   {3, -15, 111,  37, -11, 3, 0, 0}, {3, -16, 108,  42, -12, 3, 0, 0},
<span class="lineNum">     620 </span>            :   {4, -17, 104,  47, -13, 3, 0, 0}, {4, -17, 100,  52, -14, 3, 0, 0},
<span class="lineNum">     621 </span>            :   {4, -18,  96,  58, -15, 3, 0, 0}, {4, -18,  91,  63, -16, 4, 0, 0},
<span class="lineNum">     622 </span>            :   {4, -18,  87,  68, -17, 4, 0, 0}, {4, -18,  82,  73, -17, 4, 0, 0},
<span class="lineNum">     623 </span>            :   {4, -18,  78,  78, -18, 4, 0, 0}, {4, -17,  73,  82, -18, 4, 0, 0},
<span class="lineNum">     624 </span>            :   {4, -17,  68,  87, -18, 4, 0, 0}, {4, -16,  63,  91, -18, 4, 0, 0},
<span class="lineNum">     625 </span>            :   {3, -15,  58,  96, -18, 4, 0, 0}, {3, -14,  52, 100, -17, 4, 0, 0},
<span class="lineNum">     626 </span>            :   {3, -13,  47, 104, -17, 4, 0, 0}, {3, -12,  42, 108, -16, 3, 0, 0},
<span class="lineNum">     627 </span>            :   {3, -11,  37, 111, -15, 3, 0, 0}, {3, -10,  32, 114, -14, 3, 0, 0},
<span class="lineNum">     628 </span>            :   {2,  -8,  27, 117, -13, 3, 0, 0}, {2,  -7,  22, 120, -11, 2, 0, 0},
<span class="lineNum">     629 </span>            :   {1,  -6,  18, 122,  -9, 2, 0, 0}, {1,  -4,  13, 124,  -7, 1, 0, 0},
<span class="lineNum">     630 </span>            :   {1,  -3,   8, 126,  -5, 1, 0, 0}, {0,  -1,   4, 127,  -3, 1, 0, 0},
<span class="lineNum">     631 </span>            :   // [0, 1)
<span class="lineNum">     632 </span>            :   { 0,  0,   0, 127,   1,   0,   0,  0}, { 0,  1,  -3, 127,   4,  -2,   1,  0},
<span class="lineNum">     633 </span>            :   { 0,  2,  -6, 126,   8,  -3,   1,  0}, {-1,  3,  -8, 125,  13,  -5,   2, -1},
<span class="lineNum">     634 </span>            :   {-1,  4, -11, 123,  18,  -7,   3, -1}, {-1,  4, -13, 121,  23,  -8,   3, -1},
<span class="lineNum">     635 </span>            :   {-1,  5, -15, 119,  27, -10,   4, -1}, {-2,  6, -17, 116,  33, -12,   5, -1},
<span class="lineNum">     636 </span>            :   {-2,  6, -18, 113,  38, -13,   5, -1}, {-2,  7, -19, 110,  43, -15,   6, -2},
<span class="lineNum">     637 </span>            :   {-2,  7, -20, 106,  49, -16,   6, -2}, {-2,  7, -21, 102,  54, -17,   7, -2},
<span class="lineNum">     638 </span>            :   {-2,  8, -22,  98,  59, -18,   7, -2}, {-2,  8, -22,  94,  64, -19,   7, -2},
<span class="lineNum">     639 </span>            :   {-2,  8, -22,  89,  69, -20,   8, -2}, {-2,  8, -21,  84,  74, -21,   8, -2},
<span class="lineNum">     640 </span>            :   {-2,  8, -21,  79,  79, -21,   8, -2}, {-2,  8, -21,  74,  84, -21,   8, -2},
<span class="lineNum">     641 </span>            :   {-2,  8, -20,  69,  89, -22,   8, -2}, {-2,  7, -19,  64,  94, -22,   8, -2},
<span class="lineNum">     642 </span>            :   {-2,  7, -18,  59,  98, -22,   8, -2}, {-2,  7, -17,  54, 102, -21,   7, -2},
<span class="lineNum">     643 </span>            :   {-2,  6, -16,  49, 106, -20,   7, -2}, {-2,  6, -15,  43, 110, -19,   7, -2},
<span class="lineNum">     644 </span>            :   {-1,  5, -13,  38, 113, -18,   6, -2}, {-1,  5, -12,  33, 116, -17,   6, -2},
<span class="lineNum">     645 </span>            :   {-1,  4, -10,  27, 119, -15,   5, -1}, {-1,  3,  -8,  23, 121, -13,   4, -1},
<span class="lineNum">     646 </span>            :   {-1,  3,  -7,  18, 123, -11,   4, -1}, {-1,  2,  -5,  13, 125,  -8,   3, -1},
<span class="lineNum">     647 </span>            :   { 0,  1,  -3,   8, 126,  -6,   2,  0}, { 0,  1,  -2,   4, 127,  -3,   1,  0},
<span class="lineNum">     648 </span>            :   // [1, 2)
<span class="lineNum">     649 </span>            :   {0, 0, 0,   1, 127,   0,   0, 0}, {0, 0, 1,  -3, 127,   4,  -1, 0},
<span class="lineNum">     650 </span>            :   {0, 0, 1,  -5, 126,   8,  -3, 1}, {0, 0, 1,  -7, 124,  13,  -4, 1},
<span class="lineNum">     651 </span>            :   {0, 0, 2,  -9, 122,  18,  -6, 1}, {0, 0, 2, -11, 120,  22,  -7, 2},
<span class="lineNum">     652 </span>            :   {0, 0, 3, -13, 117,  27,  -8, 2}, {0, 0, 3, -14, 114,  32, -10, 3},
<span class="lineNum">     653 </span>            :   {0, 0, 3, -15, 111,  37, -11, 3}, {0, 0, 3, -16, 108,  42, -12, 3},
<span class="lineNum">     654 </span>            :   {0, 0, 4, -17, 104,  47, -13, 3}, {0, 0, 4, -17, 100,  52, -14, 3},
<span class="lineNum">     655 </span>            :   {0, 0, 4, -18,  96,  58, -15, 3}, {0, 0, 4, -18,  91,  63, -16, 4},
<span class="lineNum">     656 </span>            :   {0, 0, 4, -18,  87,  68, -17, 4}, {0, 0, 4, -18,  82,  73, -17, 4},
<span class="lineNum">     657 </span>            :   {0, 0, 4, -18,  78,  78, -18, 4}, {0, 0, 4, -17,  73,  82, -18, 4},
<span class="lineNum">     658 </span>            :   {0, 0, 4, -17,  68,  87, -18, 4}, {0, 0, 4, -16,  63,  91, -18, 4},
<span class="lineNum">     659 </span>            :   {0, 0, 3, -15,  58,  96, -18, 4}, {0, 0, 3, -14,  52, 100, -17, 4},
<span class="lineNum">     660 </span>            :   {0, 0, 3, -13,  47, 104, -17, 4}, {0, 0, 3, -12,  42, 108, -16, 3},
<span class="lineNum">     661 </span>            :   {0, 0, 3, -11,  37, 111, -15, 3}, {0, 0, 3, -10,  32, 114, -14, 3},
<span class="lineNum">     662 </span>            :   {0, 0, 2,  -8,  27, 117, -13, 3}, {0, 0, 2,  -7,  22, 120, -11, 2},
<span class="lineNum">     663 </span>            :   {0, 0, 1,  -6,  18, 122,  -9, 2}, {0, 0, 1,  -4,  13, 124,  -7, 1},
<span class="lineNum">     664 </span>            :   {0, 0, 1,  -3,   8, 126,  -5, 1}, {0, 0, 0,  -1,   4, 127,  -3, 1},
<span class="lineNum">     665 </span>            :   // dummy (replicate row index 95)
<span class="lineNum">     666 </span>            :   {0, 0, 0,  -1,   4, 127,  -3, 1},
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : #endif  // WARPEDPIXEL_PREC_BITS == 6
<span class="lineNum">     669 </span>            : };
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : /* clang-format on */
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : #define DIV_LUT_PREC_BITS 14
<span class="lineNum">     674 </span>            : #define DIV_LUT_BITS 8
<span class="lineNum">     675 </span>            : #define DIV_LUT_NUM (1 &lt;&lt; DIV_LUT_BITS)
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : static const uint16_t div_lut[DIV_LUT_NUM + 1] = {
<span class="lineNum">     678 </span>            :   16384, 16320, 16257, 16194, 16132, 16070, 16009, 15948, 15888, 15828, 15768,
<span class="lineNum">     679 </span>            :   15709, 15650, 15592, 15534, 15477, 15420, 15364, 15308, 15252, 15197, 15142,
<span class="lineNum">     680 </span>            :   15087, 15033, 14980, 14926, 14873, 14821, 14769, 14717, 14665, 14614, 14564,
<span class="lineNum">     681 </span>            :   14513, 14463, 14413, 14364, 14315, 14266, 14218, 14170, 14122, 14075, 14028,
<span class="lineNum">     682 </span>            :   13981, 13935, 13888, 13843, 13797, 13752, 13707, 13662, 13618, 13574, 13530,
<span class="lineNum">     683 </span>            :   13487, 13443, 13400, 13358, 13315, 13273, 13231, 13190, 13148, 13107, 13066,
<span class="lineNum">     684 </span>            :   13026, 12985, 12945, 12906, 12866, 12827, 12788, 12749, 12710, 12672, 12633,
<span class="lineNum">     685 </span>            :   12596, 12558, 12520, 12483, 12446, 12409, 12373, 12336, 12300, 12264, 12228,
<span class="lineNum">     686 </span>            :   12193, 12157, 12122, 12087, 12053, 12018, 11984, 11950, 11916, 11882, 11848,
<span class="lineNum">     687 </span>            :   11815, 11782, 11749, 11716, 11683, 11651, 11619, 11586, 11555, 11523, 11491,
<span class="lineNum">     688 </span>            :   11460, 11429, 11398, 11367, 11336, 11305, 11275, 11245, 11215, 11185, 11155,
<span class="lineNum">     689 </span>            :   11125, 11096, 11067, 11038, 11009, 10980, 10951, 10923, 10894, 10866, 10838,
<span class="lineNum">     690 </span>            :   10810, 10782, 10755, 10727, 10700, 10673, 10645, 10618, 10592, 10565, 10538,
<span class="lineNum">     691 </span>            :   10512, 10486, 10460, 10434, 10408, 10382, 10356, 10331, 10305, 10280, 10255,
<span class="lineNum">     692 </span>            :   10230, 10205, 10180, 10156, 10131, 10107, 10082, 10058, 10034, 10010, 9986,
<span class="lineNum">     693 </span>            :   9963,  9939,  9916,  9892,  9869,  9846,  9823,  9800,  9777,  9754,  9732,
<span class="lineNum">     694 </span>            :   9709,  9687,  9664,  9642,  9620,  9598,  9576,  9554,  9533,  9511,  9489,
<span class="lineNum">     695 </span>            :   9468,  9447,  9425,  9404,  9383,  9362,  9341,  9321,  9300,  9279,  9259,
<span class="lineNum">     696 </span>            :   9239,  9218,  9198,  9178,  9158,  9138,  9118,  9098,  9079,  9059,  9039,
<span class="lineNum">     697 </span>            :   9020,  9001,  8981,  8962,  8943,  8924,  8905,  8886,  8867,  8849,  8830,
<span class="lineNum">     698 </span>            :   8812,  8793,  8775,  8756,  8738,  8720,  8702,  8684,  8666,  8648,  8630,
<span class="lineNum">     699 </span>            :   8613,  8595,  8577,  8560,  8542,  8525,  8508,  8490,  8473,  8456,  8439,
<span class="lineNum">     700 </span>            :   8422,  8405,  8389,  8372,  8355,  8339,  8322,  8306,  8289,  8273,  8257,
<span class="lineNum">     701 </span>            :   8240,  8224,  8208,  8192,
<span class="lineNum">     702 </span>            : };
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : #if CONFIG_WARPED_MOTION
<a name="705"><span class="lineNum">     705 </span>            : // Decomposes a divisor D such that 1/D = y/2^shift, where y is returned</a>
<span class="lineNum">     706 </span>            : // at precision of DIV_LUT_PREC_BITS along with the shift.
<span class="lineNum">     707 </span><span class="lineNoCov">          0 : static int16_t resolve_divisor_64(uint64_t D, int16_t *shift) {</span>
<span class="lineNum">     708 </span>            :   int64_t e, f;
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   *shift = (int16_t)((D &gt;&gt; 32) ? get_msb((unsigned int)(D &gt;&gt; 32)) + 32</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :                                : get_msb((unsigned int)D));</span>
<span class="lineNum">     711 </span>            :   // e is obtained from D after resetting the most significant 1 bit.
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   e = D - ((uint64_t)1 &lt;&lt; *shift);</span>
<span class="lineNum">     713 </span>            :   // Get the most significant DIV_LUT_BITS (8) bits of e into f
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   if (*shift &gt; DIV_LUT_BITS)</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     f = ROUND_POWER_OF_TWO_64(e, *shift - DIV_LUT_BITS);</span>
<span class="lineNum">     716 </span>            :   else
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     f = e &lt;&lt; (DIV_LUT_BITS - *shift);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :   assert(f &lt;= DIV_LUT_NUM);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   *shift += DIV_LUT_PREC_BITS;</span>
<span class="lineNum">     720 </span>            :   // Use f as lookup into the precomputed table of multipliers
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   return div_lut[f];</span>
<span class="lineNum">     722 </span>            : }
<a name="723"><span class="lineNum">     723 </span>            : #endif  // CONFIG_WARPED_MOTION</a>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineNoCov">          0 : static int16_t resolve_divisor_32(uint32_t D, int16_t *shift) {</span>
<span class="lineNum">     726 </span>            :   int32_t e, f;
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   *shift = get_msb(D);</span>
<span class="lineNum">     728 </span>            :   // e is obtained from D after resetting the most significant 1 bit.
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   e = D - ((uint32_t)1 &lt;&lt; *shift);</span>
<span class="lineNum">     730 </span>            :   // Get the most significant DIV_LUT_BITS (8) bits of e into f
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   if (*shift &gt; DIV_LUT_BITS)</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :     f = ROUND_POWER_OF_TWO(e, *shift - DIV_LUT_BITS);</span>
<span class="lineNum">     733 </span>            :   else
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     f = e &lt;&lt; (DIV_LUT_BITS - *shift);</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   assert(f &lt;= DIV_LUT_NUM);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   *shift += DIV_LUT_PREC_BITS;</span>
<span class="lineNum">     737 </span>            :   // Use f as lookup into the precomputed table of multipliers
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :   return div_lut[f];</span>
<a name="739"><span class="lineNum">     739 </span>            : }</a>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineNoCov">          0 : static int is_affine_valid(const WarpedMotionParams *const wm) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :   const int32_t *mat = wm-&gt;wmmat;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   return (mat[2] &gt; 0);</span>
<a name="744"><span class="lineNum">     744 </span>            : }</a>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 : static int is_affine_shear_allowed(int16_t alpha, int16_t beta, int16_t gamma,</span>
<span class="lineNum">     747 </span>            :                                    int16_t delta) {
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   if ((4 * abs(alpha) + 7 * abs(beta) &gt;= (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) ||</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :       (4 * abs(gamma) + 4 * abs(delta) &gt;= (1 &lt;&lt; WARPEDMODEL_PREC_BITS)))</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     751 </span>            :   else
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     753 </span>            : }
<a name="754"><span class="lineNum">     754 </span>            : </a>
<span class="lineNum">     755 </span>            : // Returns 1 on success or 0 on an invalid affine set
<span class="lineNum">     756 </span><span class="lineNoCov">          0 : int get_shear_params(WarpedMotionParams *wm) {</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   const int32_t *mat = wm-&gt;wmmat;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   if (!is_affine_valid(wm)) return 0;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   wm-&gt;alpha =</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :       clamp(mat[2] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS), INT16_MIN, INT16_MAX);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   wm-&gt;beta = clamp(mat[3], INT16_MIN, INT16_MAX);</span>
<span class="lineNum">     762 </span>            :   int16_t shift;
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   int16_t y = resolve_divisor_32(abs(mat[2]), &amp;shift) * (mat[2] &lt; 0 ? -1 : 1);</span>
<span class="lineNum">     764 </span>            :   int64_t v;
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   v = ((int64_t)mat[4] * (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) * y;</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   wm-&gt;gamma =</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       clamp((int)ROUND_POWER_OF_TWO_SIGNED_64(v, shift), INT16_MIN, INT16_MAX);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :   v = ((int64_t)mat[3] * mat[4]) * y;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   wm-&gt;delta = clamp(mat[5] - (int)ROUND_POWER_OF_TWO_SIGNED_64(v, shift) -</span>
<span class="lineNum">     770 </span>            :                         (1 &lt;&lt; WARPEDMODEL_PREC_BITS),
<span class="lineNum">     771 </span>            :                     INT16_MIN, INT16_MAX);
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :   if (!is_affine_shear_allowed(wm-&gt;alpha, wm-&gt;beta, wm-&gt;gamma, wm-&gt;delta))</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   wm-&gt;alpha = ROUND_POWER_OF_TWO_SIGNED(wm-&gt;alpha, WARP_PARAM_REDUCE_BITS) *</span>
<span class="lineNum">     776 </span>            :               (1 &lt;&lt; WARP_PARAM_REDUCE_BITS);
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   wm-&gt;beta = ROUND_POWER_OF_TWO_SIGNED(wm-&gt;beta, WARP_PARAM_REDUCE_BITS) *</span>
<span class="lineNum">     778 </span>            :              (1 &lt;&lt; WARP_PARAM_REDUCE_BITS);
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   wm-&gt;gamma = ROUND_POWER_OF_TWO_SIGNED(wm-&gt;gamma, WARP_PARAM_REDUCE_BITS) *</span>
<span class="lineNum">     780 </span>            :               (1 &lt;&lt; WARP_PARAM_REDUCE_BITS);
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :   wm-&gt;delta = ROUND_POWER_OF_TWO_SIGNED(wm-&gt;delta, WARP_PARAM_REDUCE_BITS) *</span>
<span class="lineNum">     782 </span>            :               (1 &lt;&lt; WARP_PARAM_REDUCE_BITS);
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     784 </span>            : }
<a name="785"><span class="lineNum">     785 </span>            : </a>
<span class="lineNum">     786 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : static INLINE void highbd_get_subcolumn(int taps, const uint16_t *const ref,</span>
<span class="lineNum">     788 </span>            :                                         int32_t *col, int stride, int x,
<span class="lineNum">     789 </span>            :                                         int y_start) {
<span class="lineNum">     790 </span>            :   int i;
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; taps; ++i) {</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     col[i] = ref[(i + y_start) * stride + x];</span>
<span class="lineNum">     793 </span>            :   }
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : static uint16_t highbd_bi_ntap_filter(const uint16_t *const ref, int x, int y,</span>
<span class="lineNum">     797 </span>            :                                       int stride, int bd) {
<span class="lineNum">     798 </span>            :   int32_t val, arr[WARPEDPIXEL_FILTER_TAPS];
<span class="lineNum">     799 </span>            :   int k;
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   const int i = (int)x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   const int j = (int)y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; WARPEDPIXEL_FILTER_TAPS; ++k) {</span>
<span class="lineNum">     803 </span>            :     int32_t arr_temp[WARPEDPIXEL_FILTER_TAPS];
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     highbd_get_subcolumn(WARPEDPIXEL_FILTER_TAPS, ref, arr_temp, stride,</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                          i + k + 1 - WARPEDPIXEL_FILTER_TAPS / 2,</span>
<span class="lineNum">     806 </span>            :                          j + 1 - WARPEDPIXEL_FILTER_TAPS / 2);
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     arr[k] = do_ntap_filter(arr_temp + WARPEDPIXEL_FILTER_TAPS / 2 - 1,</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :                             y - (j * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     809 </span>            :   }
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   val = do_ntap_filter(arr + WARPEDPIXEL_FILTER_TAPS / 2 - 1,</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                        x - (i * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(val, WARPEDPIXEL_FILTER_BITS * 2);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   return (uint16_t)clip_pixel_highbd(val, bd);</span>
<a name="814"><span class="lineNum">     814 </span>            : }</a>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 : static uint16_t highbd_bi_cubic_filter(const uint16_t *const ref, int x, int y,</span>
<span class="lineNum">     817 </span>            :                                        int stride, int bd) {
<span class="lineNum">     818 </span>            :   int32_t val, arr[4];
<span class="lineNum">     819 </span>            :   int k;
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :   const int i = (int)x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   const int j = (int)y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   for (k = 0; k &lt; 4; ++k) {</span>
<span class="lineNum">     823 </span>            :     int32_t arr_temp[4];
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     highbd_get_subcolumn(4, ref, arr_temp, stride, i + k - 1, j - 1);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :     arr[k] =</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         do_cubic_filter(arr_temp + 1, y - (j * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     827 </span>            :   }
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   val = do_cubic_filter(arr + 1, x - (i * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS)));</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(val, WARPEDPIXEL_FILTER_BITS * 2);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   return (uint16_t)clip_pixel_highbd(val, bd);</span>
<a name="831"><span class="lineNum">     831 </span>            : }</a>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 : static uint16_t highbd_bi_linear_filter(const uint16_t *const ref, int x, int y,</span>
<span class="lineNum">     834 </span>            :                                         int stride, int bd) {
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   const int ix = x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   const int iy = y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   const int sx = x - (ix * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   const int sy = y - (iy * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     839 </span>            :   int32_t val;
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   val = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     841 </span>            :       ref[iy * stride + ix] * (WARPEDPIXEL_PREC_SHIFTS - sy) *
<span class="lineNum">     842 </span>            :               (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     843 </span>            :           ref[iy * stride + ix + 1] * (WARPEDPIXEL_PREC_SHIFTS - sy) * sx +
<span class="lineNum">     844 </span>            :           ref[(iy + 1) * stride + ix] * sy * (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     845 </span>            :           ref[(iy + 1) * stride + ix + 1] * sy * sx,
<span class="lineNum">     846 </span>            :       WARPEDPIXEL_PREC_BITS * 2);
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   return (uint16_t)clip_pixel_highbd(val, bd);</span>
<a name="848"><span class="lineNum">     848 </span>            : }</a>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 : static uint16_t highbd_warp_interpolate(const uint16_t *const ref, int x, int y,</span>
<span class="lineNum">     851 </span>            :                                         int width, int height, int stride,
<span class="lineNum">     852 </span>            :                                         int bd) {
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   const int ix = x &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   const int iy = y &gt;&gt; WARPEDPIXEL_PREC_BITS;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   const int sx = x - (ix * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   const int sy = y - (iy * (1 &lt;&lt; WARPEDPIXEL_PREC_BITS));</span>
<span class="lineNum">     857 </span>            :   int32_t v;
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   if (ix &lt; 0 &amp;&amp; iy &lt; 0)</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     return ref[0];</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   else if (ix &lt; 0 &amp;&amp; iy &gt; height - 1)</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     return ref[(height - 1) * stride];</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :   else if (ix &gt; width - 1 &amp;&amp; iy &lt; 0)</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     return ref[width - 1];</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   else if (ix &gt; width - 1 &amp;&amp; iy &gt; height - 1)</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     return ref[(height - 1) * stride + (width - 1)];</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   else if (ix &lt; 0) {</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     869 </span>            :         ref[iy * stride] * (WARPEDPIXEL_PREC_SHIFTS - sy) +
<span class="lineNum">     870 </span>            :             ref[(iy + 1) * stride] * sy,
<span class="lineNum">     871 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     return clip_pixel_highbd(v, bd);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :   } else if (iy &lt; 0) {</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     875 </span>            :         ref[ix] * (WARPEDPIXEL_PREC_SHIFTS - sx) + ref[ix + 1] * sx,
<span class="lineNum">     876 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     return clip_pixel_highbd(v, bd);</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   } else if (ix &gt; width - 1) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     880 </span>            :         ref[iy * stride + width - 1] * (WARPEDPIXEL_PREC_SHIFTS - sy) +
<span class="lineNum">     881 </span>            :             ref[(iy + 1) * stride + width - 1] * sy,
<span class="lineNum">     882 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :     return clip_pixel_highbd(v, bd);</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   } else if (iy &gt; height - 1) {</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     v = ROUND_POWER_OF_TWO_SIGNED(</span>
<span class="lineNum">     886 </span>            :         ref[(height - 1) * stride + ix] * (WARPEDPIXEL_PREC_SHIFTS - sx) +
<span class="lineNum">     887 </span>            :             ref[(height - 1) * stride + ix + 1] * sx,
<span class="lineNum">     888 </span>            :         WARPEDPIXEL_PREC_BITS);
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     return clip_pixel_highbd(v, bd);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   } else if (ix &gt;= WARPEDPIXEL_FILTER_TAPS / 2 - 1 &amp;&amp;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :              iy &gt;= WARPEDPIXEL_FILTER_TAPS / 2 - 1 &amp;&amp;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :              ix &lt; width - WARPEDPIXEL_FILTER_TAPS / 2 &amp;&amp;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :              iy &lt; height - WARPEDPIXEL_FILTER_TAPS / 2) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     return highbd_bi_ntap_filter(ref, x, y, stride, bd);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   } else if (ix &gt;= 1 &amp;&amp; iy &gt;= 1 &amp;&amp; ix &lt; width - 2 &amp;&amp; iy &lt; height - 2) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     return highbd_bi_cubic_filter(ref, x, y, stride, bd);</span>
<span class="lineNum">     897 </span>            :   } else {
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     return highbd_bi_linear_filter(ref, x, y, stride, bd);</span>
<span class="lineNum">     899 </span>            :   }
<a name="900"><span class="lineNum">     900 </span>            : }</a>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 : static INLINE int highbd_error_measure(int err, int bd) {</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   const int b = bd - 8;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   const int bmask = (1 &lt;&lt; b) - 1;</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   const int v = (1 &lt;&lt; b);</span>
<span class="lineNum">     906 </span>            :   int e1, e2;
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   err = abs(err);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   e1 = err &gt;&gt; b;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   e2 = err &amp; bmask;</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   return error_measure_lut[255 + e1] * (v - e2) +</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :          error_measure_lut[256 + e1] * e2;</span>
<a name="912"><span class="lineNum">     912 </span>            : }</a>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineNoCov">          0 : static void highbd_warp_plane_old(</span>
<span class="lineNum">     915 </span>            :     const WarpedMotionParams *const wm, const uint8_t *const ref8, int width,
<span class="lineNum">     916 </span>            :     int height, int stride, const uint8_t *const pred8, int p_col, int p_row,
<span class="lineNum">     917 </span>            :     int p_width, int p_height, int p_stride, int subsampling_x,
<span class="lineNum">     918 </span>            :     int subsampling_y, int x_scale, int y_scale, int bd, int comp_avg) {
<span class="lineNum">     919 </span>            :   int i, j;
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   ProjectPointsFunc projectpoints = get_project_points_type(wm-&gt;wmtype);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :   uint16_t *pred = CONVERT_TO_SHORTPTR(pred8);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   const uint16_t *const ref = CONVERT_TO_SHORTPTR(ref8);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   if (projectpoints == NULL) return;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   for (i = p_row; i &lt; p_row + p_height; ++i) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     for (j = p_col; j &lt; p_col + p_width; ++j) {</span>
<span class="lineNum">     926 </span>            :       int in[2], out[2];
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       in[0] = j;</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :       in[1] = i;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :       projectpoints(wm-&gt;wmmat, in, out, 1, 2, 2, subsampling_x, subsampling_y);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       out[0] = ROUND_POWER_OF_TWO_SIGNED(out[0] * x_scale, 4);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       out[1] = ROUND_POWER_OF_TWO_SIGNED(out[1] * y_scale, 4);</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :       if (comp_avg)</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         pred[(j - p_col) + (i - p_row) * p_stride] = ROUND_POWER_OF_TWO(</span>
<span class="lineNum">     934 </span>            :             pred[(j - p_col) + (i - p_row) * p_stride] +
<span class="lineNum">     935 </span>            :                 highbd_warp_interpolate(ref, out[0], out[1], width, height,
<span class="lineNum">     936 </span>            :                                         stride, bd),
<span class="lineNum">     937 </span>            :             1);
<span class="lineNum">     938 </span>            :       else
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         pred[(j - p_col) + (i - p_row) * p_stride] = highbd_warp_interpolate(</span>
<span class="lineNum">     940 </span>            :             ref, out[0], out[1], width, height, stride, bd);
<span class="lineNum">     941 </span>            :     }
<span class="lineNum">     942 </span>            :   }
<span class="lineNum">     943 </span>            : }
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            : /* Note: For an explanation of the warp algorithm, and some notes on bit widths
<a name="946"><span class="lineNum">     946 </span>            :     for hardware implementations, see the comments above av1_warp_affine_c</a>
<span class="lineNum">     947 </span>            : */
<span class="lineNum">     948 </span><span class="lineNoCov">          0 : void av1_highbd_warp_affine_c(const int32_t *mat, const uint16_t *ref,</span>
<span class="lineNum">     949 </span>            :                               int width, int height, int stride, uint16_t *pred,
<span class="lineNum">     950 </span>            :                               int p_col, int p_row, int p_width, int p_height,
<span class="lineNum">     951 </span>            :                               int p_stride, int subsampling_x,
<span class="lineNum">     952 </span>            :                               int subsampling_y, int bd, int comp_avg,
<span class="lineNum">     953 </span>            :                               int16_t alpha, int16_t beta, int16_t gamma,
<span class="lineNum">     954 </span>            :                               int16_t delta) {
<span class="lineNum">     955 </span>            :   uint32_t tmp[15 * 8];
<span class="lineNum">     956 </span>            :   int i, j, k, l, m;
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   for (i = p_row; i &lt; p_row + p_height; i += 8) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     for (j = p_col; j &lt; p_col + p_width; j += 8) {</span>
<span class="lineNum">     960 </span>            :       int32_t x4, y4, ix4, sx4, iy4, sy4;
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :       if (subsampling_x)</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :         x4 = (mat[2] * 4 * (j + 4) + mat[3] * 4 * (i + 4) + mat[0] * 2 +</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :               (mat[2] + mat[3] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS))) /</span>
<span class="lineNum">     964 </span>            :              4;
<span class="lineNum">     965 </span>            :       else
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         x4 = mat[2] * (j + 4) + mat[3] * (i + 4) + mat[0];</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       if (subsampling_y)</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         y4 = (mat[4] * 4 * (j + 4) + mat[5] * 4 * (i + 4) + mat[1] * 2 +</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :               (mat[4] + mat[5] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS))) /</span>
<span class="lineNum">     971 </span>            :              4;
<span class="lineNum">     972 </span>            :       else
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         y4 = mat[4] * (j + 4) + mat[5] * (i + 4) + mat[1];</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :       ix4 = x4 &gt;&gt; WARPEDMODEL_PREC_BITS;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :       sx4 = x4 &amp; ((1 &lt;&lt; WARPEDMODEL_PREC_BITS) - 1);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :       iy4 = y4 &gt;&gt; WARPEDMODEL_PREC_BITS;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       sy4 = y4 &amp; ((1 &lt;&lt; WARPEDMODEL_PREC_BITS) - 1);</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :       sx4 += alpha * (-4) + beta * (-4);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       sy4 += gamma * (-4) + delta * (-4);</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :       sx4 &amp;= ~((1 &lt;&lt; WARP_PARAM_REDUCE_BITS) - 1);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       sy4 &amp;= ~((1 &lt;&lt; WARP_PARAM_REDUCE_BITS) - 1);</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :       // Horizontal filter
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :       for (k = -7; k &lt; 8; ++k) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :         int iy = iy4 + k;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         if (iy &lt; 0)</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :           iy = 0;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         else if (iy &gt; height - 1)</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :           iy = height - 1;</span>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :         int sx = sx4 + beta * (k + 4);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         for (l = -4; l &lt; 4; ++l) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :           int ix = ix4 + l - 3;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :           const int offs = ROUND_POWER_OF_TWO(sx, WARPEDDIFF_PREC_BITS) +</span>
<span class="lineNum">     998 </span>            :                            WARPEDPIXEL_PREC_SHIFTS;
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :           assert(offs &gt;= 0 &amp;&amp; offs &lt;= WARPEDPIXEL_PREC_SHIFTS * 3);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :           const int16_t *coeffs = warped_filter[offs];</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :           int32_t sum = 1 &lt;&lt; (bd + WARPEDPIXEL_FILTER_BITS - 1);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :           for (m = 0; m &lt; 8; ++m) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :             int sample_x = ix + m;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :             if (sample_x &lt; 0)</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :               sample_x = 0;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :             else if (sample_x &gt; width - 1)</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :               sample_x = width - 1;</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :             sum += ref[iy * stride + sample_x] * coeffs[m];</span>
<span class="lineNum">    1010 </span>            :           }
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :           sum = ROUND_POWER_OF_TWO(sum, HORSHEAR_REDUCE_PREC_BITS);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :           assert(0 &lt;= sum &amp;&amp;</span>
<span class="lineNum">    1013 </span>            :                  sum &lt; (1 &lt;&lt; (bd + WARPEDPIXEL_FILTER_BITS + 1 -
<span class="lineNum">    1014 </span>            :                               HORSHEAR_REDUCE_PREC_BITS)));
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :           tmp[(k + 7) * 8 + (l + 4)] = sum;</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :           sx += alpha;</span>
<span class="lineNum">    1017 </span>            :         }
<span class="lineNum">    1018 </span>            :       }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :       // Vertical filter
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       for (k = -4; k &lt; AOMMIN(4, p_row + p_height - i - 4); ++k) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :         int sy = sy4 + delta * (k + 4);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         for (l = -4; l &lt; 4; ++l) {</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :           uint16_t *p =</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :               &amp;pred[(i - p_row + k + 4) * p_stride + (j - p_col + l + 4)];</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :           const int offs = ROUND_POWER_OF_TWO(sy, WARPEDDIFF_PREC_BITS) +</span>
<span class="lineNum">    1027 </span>            :                            WARPEDPIXEL_PREC_SHIFTS;
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :           assert(offs &gt;= 0 &amp;&amp; offs &lt;= WARPEDPIXEL_PREC_SHIFTS * 3);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :           const int16_t *coeffs = warped_filter[offs];</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :           int32_t sum = 1 &lt;&lt; (bd + 2 * WARPEDPIXEL_FILTER_BITS -</span>
<span class="lineNum">    1032 </span>            :                               HORSHEAR_REDUCE_PREC_BITS);
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :           for (m = 0; m &lt; 8; ++m) {</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :             sum += tmp[(k + m + 4) * 8 + (l + 4)] * coeffs[m];</span>
<span class="lineNum">    1035 </span>            :           }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :           sum = ROUND_POWER_OF_TWO(sum, VERSHEAR_REDUCE_PREC_BITS);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :           assert(0 &lt;= sum &amp;&amp; sum &lt; (1 &lt;&lt; (bd + 2)));</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :           uint16_t px =</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :               clip_pixel_highbd(sum - (1 &lt;&lt; (bd - 1)) - (1 &lt;&lt; bd), bd);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           if (comp_avg)</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :             *p = ROUND_POWER_OF_TWO(*p + px, 1);</span>
<span class="lineNum">    1042 </span>            :           else
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :             *p = px;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :           sy += gamma;</span>
<span class="lineNum">    1045 </span>            :         }
<span class="lineNum">    1046 </span>            :       }
<span class="lineNum">    1047 </span>            :     }
<span class="lineNum">    1048 </span>            :   }
<a name="1049"><span class="lineNum">    1049 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 : static void highbd_warp_plane(WarpedMotionParams *wm, const uint8_t *const ref8,</span>
<span class="lineNum">    1052 </span>            :                               int width, int height, int stride,
<span class="lineNum">    1053 </span>            :                               const uint8_t *const pred8, int p_col, int p_row,
<span class="lineNum">    1054 </span>            :                               int p_width, int p_height, int p_stride,
<span class="lineNum">    1055 </span>            :                               int subsampling_x, int subsampling_y, int x_scale,
<span class="lineNum">    1056 </span>            :                               int y_scale, int bd, int comp_avg) {
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   if (wm-&gt;wmtype == ROTZOOM) {</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     wm-&gt;wmmat[5] = wm-&gt;wmmat[2];</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     wm-&gt;wmmat[4] = -wm-&gt;wmmat[3];</span>
<span class="lineNum">    1060 </span>            :   }
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   if ((wm-&gt;wmtype == ROTZOOM || wm-&gt;wmtype == AFFINE) &amp;&amp; x_scale == 16 &amp;&amp;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :       y_scale == 16) {</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     const int32_t *const mat = wm-&gt;wmmat;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     const int16_t alpha = wm-&gt;alpha;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     const int16_t beta = wm-&gt;beta;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     const int16_t gamma = wm-&gt;gamma;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     const int16_t delta = wm-&gt;delta;</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     const uint16_t *const ref = CONVERT_TO_SHORTPTR(ref8);</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     uint16_t *pred = CONVERT_TO_SHORTPTR(pred8);</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     av1_highbd_warp_affine(mat, ref, width, height, stride, pred, p_col, p_row,</span>
<span class="lineNum">    1072 </span>            :                            p_width, p_height, p_stride, subsampling_x,
<span class="lineNum">    1073 </span>            :                            subsampling_y, bd, comp_avg, alpha, beta, gamma,
<span class="lineNum">    1074 </span>            :                            delta);
<span class="lineNum">    1075 </span>            :   } else {
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     highbd_warp_plane_old(wm, ref8, width, height, stride, pred8, p_col, p_row,</span>
<span class="lineNum">    1077 </span>            :                           p_width, p_height, p_stride, subsampling_x,
<span class="lineNum">    1078 </span>            :                           subsampling_y, x_scale, y_scale, bd, comp_avg);
<span class="lineNum">    1079 </span>            :   }
<a name="1080"><span class="lineNum">    1080 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 : static int64_t highbd_frame_error(const uint16_t *const ref, int stride,</span>
<span class="lineNum">    1083 </span>            :                                   const uint16_t *const dst, int p_col,
<span class="lineNum">    1084 </span>            :                                   int p_row, int p_width, int p_height,
<span class="lineNum">    1085 </span>            :                                   int p_stride, int bd) {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :   int64_t sum_error = 0;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; p_height; ++i) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; p_width; ++j) {</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       sum_error += highbd_error_measure(</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :           dst[j + i * p_stride] - ref[(j + p_col) + (i + p_row) * stride], bd);</span>
<span class="lineNum">    1091 </span>            :     }
<span class="lineNum">    1092 </span>            :   }
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   return sum_error;</span>
<a name="1094"><span class="lineNum">    1094 </span>            : }</a>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 : static int64_t highbd_warp_error(</span>
<span class="lineNum">    1097 </span>            :     WarpedMotionParams *wm, const uint8_t *const ref8, int width, int height,
<span class="lineNum">    1098 </span>            :     int stride, const uint8_t *const dst8, int p_col, int p_row, int p_width,
<span class="lineNum">    1099 </span>            :     int p_height, int p_stride, int subsampling_x, int subsampling_y,
<span class="lineNum">    1100 </span>            :     int x_scale, int y_scale, int bd) {
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   int64_t gm_sumerr = 0;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   uint16_t *tmp = aom_malloc(p_width * p_height * sizeof(*tmp));</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   if (!tmp) return INT64_MAX;</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   highbd_warp_plane(wm, ref8, width, height, stride, CONVERT_TO_BYTEPTR(tmp),</span>
<span class="lineNum">    1106 </span>            :                     p_col, p_row, p_width, p_height, p_width, subsampling_x,
<span class="lineNum">    1107 </span>            :                     subsampling_y, x_scale, y_scale, bd, 0);
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :   gm_sumerr = highbd_frame_error(tmp, p_width, CONVERT_TO_SHORTPTR(dst8), p_col,</span>
<span class="lineNum">    1110 </span>            :                                  p_row, p_width, p_height, p_stride, bd);
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :   aom_free(tmp);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :   return gm_sumerr;</span>
<span class="lineNum">    1114 </span>            : }
<a name="1115"><span class="lineNum">    1115 </span>            : #endif  // CONFIG_HIGHBITDEPTH</a>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 : static INLINE int error_measure(int err) {</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   return error_measure_lut[255 + err];</span>
<a name="1119"><span class="lineNum">    1119 </span>            : }</a>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 : static void warp_plane_old(const WarpedMotionParams *const wm,</span>
<span class="lineNum">    1122 </span>            :                            const uint8_t *const ref, int width, int height,
<span class="lineNum">    1123 </span>            :                            int stride, uint8_t *pred, int p_col, int p_row,
<span class="lineNum">    1124 </span>            :                            int p_width, int p_height, int p_stride,
<span class="lineNum">    1125 </span>            :                            int subsampling_x, int subsampling_y, int x_scale,
<span class="lineNum">    1126 </span>            :                            int y_scale, int comp_avg) {
<span class="lineNum">    1127 </span>            :   int i, j;
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   ProjectPointsFunc projectpoints = get_project_points_type(wm-&gt;wmtype);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   if (projectpoints == NULL) return;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   for (i = p_row; i &lt; p_row + p_height; ++i) {</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     for (j = p_col; j &lt; p_col + p_width; ++j) {</span>
<span class="lineNum">    1132 </span>            :       int in[2], out[2];
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       in[0] = j;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       in[1] = i;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       projectpoints(wm-&gt;wmmat, in, out, 1, 2, 2, subsampling_x, subsampling_y);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :       out[0] = ROUND_POWER_OF_TWO_SIGNED(out[0] * x_scale, 4);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :       out[1] = ROUND_POWER_OF_TWO_SIGNED(out[1] * y_scale, 4);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :       if (comp_avg)</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         pred[(j - p_col) + (i - p_row) * p_stride] = ROUND_POWER_OF_TWO(</span>
<span class="lineNum">    1140 </span>            :             pred[(j - p_col) + (i - p_row) * p_stride] +
<span class="lineNum">    1141 </span>            :                 warp_interpolate(ref, out[0], out[1], width, height, stride),
<span class="lineNum">    1142 </span>            :             1);
<span class="lineNum">    1143 </span>            :       else
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :         pred[(j - p_col) + (i - p_row) * p_stride] =</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :             warp_interpolate(ref, out[0], out[1], width, height, stride);</span>
<span class="lineNum">    1146 </span>            :     }
<span class="lineNum">    1147 </span>            :   }
<span class="lineNum">    1148 </span>            : }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            : /* The warp filter for ROTZOOM and AFFINE models works as follows:
<span class="lineNum">    1151 </span>            :    * Split the input into 8x8 blocks
<span class="lineNum">    1152 </span>            :    * For each block, project the point (4, 4) within the block, to get the
<span class="lineNum">    1153 </span>            :      overall block position. Split into integer and fractional coordinates,
<span class="lineNum">    1154 </span>            :      maintaining full WARPEDMODEL precision
<span class="lineNum">    1155 </span>            :    * Filter horizontally: Generate 15 rows of 8 pixels each. Each pixel gets a
<span class="lineNum">    1156 </span>            :      variable horizontal offset. This means that, while the rows of the
<span class="lineNum">    1157 </span>            :      intermediate buffer align with the rows of the *reference* image, the
<span class="lineNum">    1158 </span>            :      columns align with the columns of the *destination* image.
<span class="lineNum">    1159 </span>            :    * Filter vertically: Generate the output block (up to 8x8 pixels, but if the
<span class="lineNum">    1160 </span>            :      destination is too small we crop the output at this stage). Each pixel has
<span class="lineNum">    1161 </span>            :      a variable vertical offset, so that the resulting rows are aligned with
<span class="lineNum">    1162 </span>            :      the rows of the destination image.
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :    To accomplish these alignments, we factor the warp matrix as a
<span class="lineNum">    1165 </span>            :    product of two shear / asymmetric zoom matrices:
<span class="lineNum">    1166 </span>            :    / a b \  = /   1       0    \ * / 1+alpha  beta \
<span class="lineNum">    1167 </span>            :    \ c d /    \ gamma  1+delta /   \    0      1   /
<span class="lineNum">    1168 </span>            :    where a, b, c, d are wmmat[2], wmmat[3], wmmat[4], wmmat[5] respectively.
<span class="lineNum">    1169 </span>            :    The horizontal shear (with alpha and beta) is applied first,
<span class="lineNum">    1170 </span>            :    then the vertical shear (with gamma and delta) is applied second.
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            :    The only limitation is that, to fit this in a fixed 8-tap filter size,
<span class="lineNum">    1173 </span>            :    the fractional pixel offsets must be at most +-1. Since the horizontal filter
<span class="lineNum">    1174 </span>            :    generates 15 rows of 8 columns, and the initial point we project is at (4, 4)
<span class="lineNum">    1175 </span>            :    within the block, the parameters must satisfy
<span class="lineNum">    1176 </span>            :    4 * |alpha| + 7 * |beta| &lt;= 1   and   4 * |gamma| + 4 * |delta| &lt;= 1
<span class="lineNum">    1177 </span>            :    for this filter to be applicable.
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            :    Note: This function assumes that the caller has done all of the relevant
<span class="lineNum">    1180 </span>            :    checks, ie. that we have a ROTZOOM or AFFINE model, that wm[4] and wm[5]
<span class="lineNum">    1181 </span>            :    are set appropriately (if using a ROTZOOM model), and that alpha, beta,
<span class="lineNum">    1182 </span>            :    gamma, delta are all in range.
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            :    TODO(david.barker): Maybe support scaled references?
<span class="lineNum">    1185 </span>            : */
<span class="lineNum">    1186 </span>            : /* A note on hardware implementation:
<span class="lineNum">    1187 </span>            :     The warp filter is intended to be implementable using the same hardware as
<span class="lineNum">    1188 </span>            :     the high-precision convolve filters from the loop-restoration and
<span class="lineNum">    1189 </span>            :     convolve-round experiments.
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            :     For a single filter stage, considering all of the coefficient sets for the
<span class="lineNum">    1192 </span>            :     warp filter and the regular convolution filter, an input in the range
<span class="lineNum">    1193 </span>            :     [0, 2^k - 1] is mapped into the range [-56 * (2^k - 1), 184 * (2^k - 1)]
<span class="lineNum">    1194 </span>            :     before rounding.
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            :     Allowing for some changes to the filter coefficient sets, call the range
<span class="lineNum">    1197 </span>            :     [-64 * 2^k, 192 * 2^k]. Then, if we initialize the accumulator to 64 * 2^k,
<span class="lineNum">    1198 </span>            :     we can replace this by the range [0, 256 * 2^k], which can be stored in an
<span class="lineNum">    1199 </span>            :     unsigned value with 8 + k bits.
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span>            :     This allows the derivation of the appropriate bit widths and offsets for
<span class="lineNum">    1202 </span>            :     the various intermediate values: If
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :     F := WARPEDPIXEL_FILTER_BITS = 7 (or else the above ranges need adjusting)
<span class="lineNum">    1205 </span>            :          So a *single* filter stage maps a k-bit input to a (k + F + 1)-bit
<span class="lineNum">    1206 </span>            :          intermediate value.
<span class="lineNum">    1207 </span>            :     H := HORSHEAR_REDUCE_PREC_BITS
<span class="lineNum">    1208 </span>            :     V := VERSHEAR_REDUCE_PREC_BITS
<span class="lineNum">    1209 </span>            :     (and note that we must have H + V = 2*F for the output to have the same
<span class="lineNum">    1210 </span>            :      scale as the input)
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :     then we end up with the following offsets and ranges:
<span class="lineNum">    1213 </span>            :     Horizontal filter: Apply an offset of 1 &lt;&lt; (bd + F - 1), sum fits into a
<span class="lineNum">    1214 </span>            :                        uint{bd + F + 1}
<span class="lineNum">    1215 </span>            :     After rounding: The values stored in 'tmp' fit into a uint{bd + F + 1 - H}.
<span class="lineNum">    1216 </span>            :     Vertical filter: Apply an offset of 1 &lt;&lt; (bd + 2*F - H), sum fits into a
<span class="lineNum">    1217 </span>            :                      uint{bd + 2*F + 2 - H}
<span class="lineNum">    1218 </span>            :     After rounding: The final value, before undoing the offset, fits into a
<span class="lineNum">    1219 </span>            :                     uint{bd + 2}.
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            :     Then we need to undo the offsets before clamping to a pixel. Note that,
<span class="lineNum">    1222 </span>            :     if we do this at the end, the amount to subtract is actually independent
<span class="lineNum">    1223 </span>            :     of H and V:
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            :     offset to subtract = (1 &lt;&lt; ((bd + F - 1) - H + F - V)) +
<span class="lineNum">    1226 </span>            :                          (1 &lt;&lt; ((bd + 2*F - H) - V))
<span class="lineNum">    1227 </span>            :                       == (1 &lt;&lt; (bd - 1)) + (1 &lt;&lt; bd)
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :     This allows us to entirely avoid clamping in both the warp filter and
<span class="lineNum">    1230 </span>            :     the convolve-round experiment. As of the time of writing, the Wiener filter
<span class="lineNum">    1231 </span>            :     from loop-restoration can encode a central coefficient up to 216, which
<span class="lineNum">    1232 </span>            :     leads to a maximum value of about 282 * 2^k after applying the offset.
<a name="1233"><span class="lineNum">    1233 </span>            :     So in that case we still need to clamp.</a>
<span class="lineNum">    1234 </span>            : */
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 : void av1_warp_affine_c(const int32_t *mat, const uint8_t *ref, int width,</span>
<span class="lineNum">    1236 </span>            :                        int height, int stride, uint8_t *pred, int p_col,
<span class="lineNum">    1237 </span>            :                        int p_row, int p_width, int p_height, int p_stride,
<span class="lineNum">    1238 </span>            :                        int subsampling_x, int subsampling_y, int comp_avg,
<span class="lineNum">    1239 </span>            :                        int16_t alpha, int16_t beta, int16_t gamma,
<span class="lineNum">    1240 </span>            :                        int16_t delta) {
<span class="lineNum">    1241 </span>            :   uint16_t tmp[15 * 8];
<span class="lineNum">    1242 </span>            :   int i, j, k, l, m;
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :   const int bd = 8;</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :   for (i = p_row; i &lt; p_row + p_height; i += 8) {</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     for (j = p_col; j &lt; p_col + p_width; j += 8) {</span>
<span class="lineNum">    1247 </span>            :       int32_t x4, y4, ix4, sx4, iy4, sy4;
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       if (subsampling_x)</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :         x4 = (mat[2] * 4 * (j + 4) + mat[3] * 4 * (i + 4) + mat[0] * 2 +</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :               (mat[2] + mat[3] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS))) /</span>
<span class="lineNum">    1251 </span>            :              4;
<span class="lineNum">    1252 </span>            :       else
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         x4 = mat[2] * (j + 4) + mat[3] * (i + 4) + mat[0];</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :       if (subsampling_y)</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         y4 = (mat[4] * 4 * (j + 4) + mat[5] * 4 * (i + 4) + mat[1] * 2 +</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :               (mat[4] + mat[5] - (1 &lt;&lt; WARPEDMODEL_PREC_BITS))) /</span>
<span class="lineNum">    1258 </span>            :              4;
<span class="lineNum">    1259 </span>            :       else
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         y4 = mat[4] * (j + 4) + mat[5] * (i + 4) + mat[1];</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :       ix4 = x4 &gt;&gt; WARPEDMODEL_PREC_BITS;</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :       sx4 = x4 &amp; ((1 &lt;&lt; WARPEDMODEL_PREC_BITS) - 1);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :       iy4 = y4 &gt;&gt; WARPEDMODEL_PREC_BITS;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :       sy4 = y4 &amp; ((1 &lt;&lt; WARPEDMODEL_PREC_BITS) - 1);</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :       sx4 += alpha * (-4) + beta * (-4);</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :       sy4 += gamma * (-4) + delta * (-4);</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :       sx4 &amp;= ~((1 &lt;&lt; WARP_PARAM_REDUCE_BITS) - 1);</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :       sy4 &amp;= ~((1 &lt;&lt; WARP_PARAM_REDUCE_BITS) - 1);</span>
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            :       // Horizontal filter
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :       for (k = -7; k &lt; 8; ++k) {</span>
<span class="lineNum">    1275 </span>            :         // Clamp to top/bottom edge of the frame
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         int iy = iy4 + k;</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         if (iy &lt; 0)</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :           iy = 0;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         else if (iy &gt; height - 1)</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :           iy = height - 1;</span>
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :         int sx = sx4 + beta * (k + 4);</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :         for (l = -4; l &lt; 4; ++l) {</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :           int ix = ix4 + l - 3;</span>
<span class="lineNum">    1286 </span>            :           // At this point, sx = sx4 + alpha * l + beta * k
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :           const int offs = ROUND_POWER_OF_TWO(sx, WARPEDDIFF_PREC_BITS) +</span>
<span class="lineNum">    1288 </span>            :                            WARPEDPIXEL_PREC_SHIFTS;
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :           assert(offs &gt;= 0 &amp;&amp; offs &lt;= WARPEDPIXEL_PREC_SHIFTS * 3);</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :           const int16_t *coeffs = warped_filter[offs];</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :           int32_t sum = 1 &lt;&lt; (bd + WARPEDPIXEL_FILTER_BITS - 1);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :           for (m = 0; m &lt; 8; ++m) {</span>
<span class="lineNum">    1294 </span>            :             // Clamp to left/right edge of the frame
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :             int sample_x = ix + m;</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :             if (sample_x &lt; 0)</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :               sample_x = 0;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :             else if (sample_x &gt; width - 1)</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :               sample_x = width - 1;</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :             sum += ref[iy * stride + sample_x] * coeffs[m];</span>
<span class="lineNum">    1302 </span>            :           }
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :           sum = ROUND_POWER_OF_TWO(sum, HORSHEAR_REDUCE_PREC_BITS);</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :           assert(0 &lt;= sum &amp;&amp;</span>
<span class="lineNum">    1305 </span>            :                  sum &lt; (1 &lt;&lt; (bd + WARPEDPIXEL_FILTER_BITS + 1 -
<span class="lineNum">    1306 </span>            :                               HORSHEAR_REDUCE_PREC_BITS)));
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :           tmp[(k + 7) * 8 + (l + 4)] = sum;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :           sx += alpha;</span>
<span class="lineNum">    1309 </span>            :         }
<span class="lineNum">    1310 </span>            :       }
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span>            :       // Vertical filter
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       for (k = -4; k &lt; AOMMIN(4, p_row + p_height - i - 4); ++k) {</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :         int sy = sy4 + delta * (k + 4);</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :         for (l = -4; l &lt; AOMMIN(4, p_col + p_width - j - 4); ++l) {</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :           uint8_t *p =</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :               &amp;pred[(i - p_row + k + 4) * p_stride + (j - p_col + l + 4)];</span>
<span class="lineNum">    1318 </span>            :           // At this point, sy = sy4 + gamma * l + delta * k
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :           const int offs = ROUND_POWER_OF_TWO(sy, WARPEDDIFF_PREC_BITS) +</span>
<span class="lineNum">    1320 </span>            :                            WARPEDPIXEL_PREC_SHIFTS;
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :           assert(offs &gt;= 0 &amp;&amp; offs &lt;= WARPEDPIXEL_PREC_SHIFTS * 3);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :           const int16_t *coeffs = warped_filter[offs];</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :           int32_t sum = 1 &lt;&lt; (bd + 2 * WARPEDPIXEL_FILTER_BITS -</span>
<span class="lineNum">    1325 </span>            :                               HORSHEAR_REDUCE_PREC_BITS);
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :           for (m = 0; m &lt; 8; ++m) {</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :             sum += tmp[(k + m + 4) * 8 + (l + 4)] * coeffs[m];</span>
<span class="lineNum">    1328 </span>            :           }
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :           sum = ROUND_POWER_OF_TWO(sum, VERSHEAR_REDUCE_PREC_BITS);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :           assert(0 &lt;= sum &amp;&amp; sum &lt; (1 &lt;&lt; (bd + 2)));</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :           uint8_t px = clip_pixel(sum - (1 &lt;&lt; (bd - 1)) - (1 &lt;&lt; bd));</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :           if (comp_avg)</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :             *p = ROUND_POWER_OF_TWO(*p + px, 1);</span>
<span class="lineNum">    1334 </span>            :           else
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :             *p = px;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :           sy += gamma;</span>
<span class="lineNum">    1337 </span>            :         }
<span class="lineNum">    1338 </span>            :       }
<span class="lineNum">    1339 </span>            :     }
<span class="lineNum">    1340 </span>            :   }
<a name="1341"><span class="lineNum">    1341 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 : static void warp_plane(WarpedMotionParams *wm, const uint8_t *const ref,</span>
<span class="lineNum">    1344 </span>            :                        int width, int height, int stride, uint8_t *pred,
<span class="lineNum">    1345 </span>            :                        int p_col, int p_row, int p_width, int p_height,
<span class="lineNum">    1346 </span>            :                        int p_stride, int subsampling_x, int subsampling_y,
<span class="lineNum">    1347 </span>            :                        int x_scale, int y_scale, int comp_avg) {
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   if (wm-&gt;wmtype == ROTZOOM) {</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     wm-&gt;wmmat[5] = wm-&gt;wmmat[2];</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :     wm-&gt;wmmat[4] = -wm-&gt;wmmat[3];</span>
<span class="lineNum">    1351 </span>            :   }
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   if ((wm-&gt;wmtype == ROTZOOM || wm-&gt;wmtype == AFFINE) &amp;&amp; x_scale == 16 &amp;&amp;</span>
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :       y_scale == 16) {</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :     const int32_t *const mat = wm-&gt;wmmat;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     const int16_t alpha = wm-&gt;alpha;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     const int16_t beta = wm-&gt;beta;</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :     const int16_t gamma = wm-&gt;gamma;</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     const int16_t delta = wm-&gt;delta;</span>
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :     av1_warp_affine(mat, ref, width, height, stride, pred, p_col, p_row,</span>
<span class="lineNum">    1361 </span>            :                     p_width, p_height, p_stride, subsampling_x, subsampling_y,
<span class="lineNum">    1362 </span>            :                     comp_avg, alpha, beta, gamma, delta);
<span class="lineNum">    1363 </span>            :   } else {
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :     warp_plane_old(wm, ref, width, height, stride, pred, p_col, p_row, p_width,</span>
<span class="lineNum">    1365 </span>            :                    p_height, p_stride, subsampling_x, subsampling_y, x_scale,
<span class="lineNum">    1366 </span>            :                    y_scale, comp_avg);
<span class="lineNum">    1367 </span>            :   }
<a name="1368"><span class="lineNum">    1368 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 : static int64_t frame_error(const uint8_t *const ref, int stride,</span>
<span class="lineNum">    1371 </span>            :                            const uint8_t *const dst, int p_col, int p_row,
<span class="lineNum">    1372 </span>            :                            int p_width, int p_height, int p_stride) {
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   int64_t sum_error = 0;</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; p_height; ++i) {</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     for (int j = 0; j &lt; p_width; ++j) {</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :       sum_error += (int64_t)error_measure(</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :           dst[j + i * p_stride] - ref[(j + p_col) + (i + p_row) * stride]);</span>
<span class="lineNum">    1378 </span>            :     }
<span class="lineNum">    1379 </span>            :   }
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   return sum_error;</span>
<a name="1381"><span class="lineNum">    1381 </span>            : }</a>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 : static int64_t warp_error(WarpedMotionParams *wm, const uint8_t *const ref,</span>
<span class="lineNum">    1384 </span>            :                           int width, int height, int stride,
<span class="lineNum">    1385 </span>            :                           const uint8_t *const dst, int p_col, int p_row,
<span class="lineNum">    1386 </span>            :                           int p_width, int p_height, int p_stride,
<span class="lineNum">    1387 </span>            :                           int subsampling_x, int subsampling_y, int x_scale,
<span class="lineNum">    1388 </span>            :                           int y_scale) {
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   int64_t gm_sumerr = 0;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   uint8_t *tmp = aom_malloc(p_width * p_height);</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   if (!tmp) return INT64_MAX;</span>
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   warp_plane(wm, ref, width, height, stride, tmp, p_col, p_row, p_width,</span>
<span class="lineNum">    1394 </span>            :              p_height, p_width, subsampling_x, subsampling_y, x_scale, y_scale,
<span class="lineNum">    1395 </span>            :              0);
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :   gm_sumerr =</span>
<span class="lineNum">    1398 </span>            :       frame_error(tmp, p_width, dst, p_col, p_row, p_width, p_height, p_stride);
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :   aom_free(tmp);</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   return gm_sumerr;</span>
<a name="1402"><span class="lineNum">    1402 </span>            : }</a>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : int64_t av1_frame_error(</span>
<span class="lineNum">    1405 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1406 </span>            :     int use_hbd, int bd,
<span class="lineNum">    1407 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1408 </span>            :     const uint8_t *ref, int stride, uint8_t *dst, int p_col, int p_row,
<span class="lineNum">    1409 </span>            :     int p_width, int p_height, int p_stride) {
<span class="lineNum">    1410 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   if (use_hbd) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     return highbd_frame_error(CONVERT_TO_SHORTPTR(ref), stride,</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                               CONVERT_TO_SHORTPTR(dst), p_col, p_row, p_width,</span>
<span class="lineNum">    1414 </span>            :                               p_height, p_stride, bd);
<span class="lineNum">    1415 </span>            :   }
<span class="lineNum">    1416 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   return frame_error(ref, stride, dst, p_col, p_row, p_width, p_height,</span>
<span class="lineNum">    1418 </span>            :                      p_stride);
<a name="1419"><span class="lineNum">    1419 </span>            : }</a>
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 : int64_t av1_warp_error(WarpedMotionParams *wm,</span>
<span class="lineNum">    1422 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1423 </span>            :                        int use_hbd, int bd,
<span class="lineNum">    1424 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1425 </span>            :                        const uint8_t *ref, int width, int height, int stride,
<span class="lineNum">    1426 </span>            :                        uint8_t *dst, int p_col, int p_row, int p_width,
<span class="lineNum">    1427 </span>            :                        int p_height, int p_stride, int subsampling_x,
<span class="lineNum">    1428 </span>            :                        int subsampling_y, int x_scale, int y_scale) {
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :   if (wm-&gt;wmtype &lt;= AFFINE)</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     if (!get_shear_params(wm)) return 1;</span>
<span class="lineNum">    1431 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   if (use_hbd)</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     return highbd_warp_error(wm, ref, width, height, stride, dst, p_col, p_row,</span>
<span class="lineNum">    1434 </span>            :                              p_width, p_height, p_stride, subsampling_x,
<span class="lineNum">    1435 </span>            :                              subsampling_y, x_scale, y_scale, bd);
<span class="lineNum">    1436 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   return warp_error(wm, ref, width, height, stride, dst, p_col, p_row, p_width,</span>
<span class="lineNum">    1438 </span>            :                     p_height, p_stride, subsampling_x, subsampling_y, x_scale,
<span class="lineNum">    1439 </span>            :                     y_scale);
<a name="1440"><span class="lineNum">    1440 </span>            : }</a>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 : void av1_warp_plane(WarpedMotionParams *wm,</span>
<span class="lineNum">    1443 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1444 </span>            :                     int use_hbd, int bd,
<span class="lineNum">    1445 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1446 </span>            :                     const uint8_t *ref, int width, int height, int stride,
<span class="lineNum">    1447 </span>            :                     uint8_t *pred, int p_col, int p_row, int p_width,
<span class="lineNum">    1448 </span>            :                     int p_height, int p_stride, int subsampling_x,
<span class="lineNum">    1449 </span>            :                     int subsampling_y, int x_scale, int y_scale, int comp_avg) {
<span class="lineNum">    1450 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   if (use_hbd)</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     highbd_warp_plane(wm, ref, width, height, stride, pred, p_col, p_row,</span>
<span class="lineNum">    1453 </span>            :                       p_width, p_height, p_stride, subsampling_x, subsampling_y,
<span class="lineNum">    1454 </span>            :                       x_scale, y_scale, bd, comp_avg);
<span class="lineNum">    1455 </span>            :   else
<span class="lineNum">    1456 </span>            : #endif  // CONFIG_HIGHBITDEPTH
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     warp_plane(wm, ref, width, height, stride, pred, p_col, p_row, p_width,</span>
<span class="lineNum">    1458 </span>            :                p_height, p_stride, subsampling_x, subsampling_y, x_scale,
<span class="lineNum">    1459 </span>            :                y_scale, comp_avg);
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            : #if CONFIG_WARPED_MOTION
<span class="lineNum">    1463 </span>            : #define LEAST_SQUARES_ORDER 2
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            : #define LS_MV_MAX 256  // max mv in 1/8-pel
<span class="lineNum">    1466 </span>            : #define LS_STEP 2
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            : // Assuming LS_MV_MAX is &lt; MAX_SB_SIZE * 8,
<span class="lineNum">    1469 </span>            : // the precision needed is:
<span class="lineNum">    1470 </span>            : //   (MAX_SB_SIZE_LOG2 + 3) [for sx * sx magnitude] +
<span class="lineNum">    1471 </span>            : //   (MAX_SB_SIZE_LOG2 + 4) [for sx * dx magnitude] +
<span class="lineNum">    1472 </span>            : //   1 [for sign] +
<span class="lineNum">    1473 </span>            : //   LEAST_SQUARES_SAMPLES_MAX_BITS
<span class="lineNum">    1474 </span>            : //        [for adding up to LEAST_SQUARES_SAMPLES_MAX samples]
<span class="lineNum">    1475 </span>            : // The value is 23
<span class="lineNum">    1476 </span>            : #define LS_MAT_RANGE_BITS \
<span class="lineNum">    1477 </span>            :   ((MAX_SB_SIZE_LOG2 + 4) * 2 + LEAST_SQUARES_SAMPLES_MAX_BITS)
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            : // Bit-depth reduction from the full-range
<span class="lineNum">    1480 </span>            : #define LS_MAT_DOWN_BITS 2
<span class="lineNum">    1481 </span>            : 
<span class="lineNum">    1482 </span>            : // bits range of A, Bx and By after downshifting
<span class="lineNum">    1483 </span>            : #define LS_MAT_BITS (LS_MAT_RANGE_BITS - LS_MAT_DOWN_BITS)
<span class="lineNum">    1484 </span>            : #define LS_MAT_MIN (-(1 &lt;&lt; (LS_MAT_BITS - 1)))
<span class="lineNum">    1485 </span>            : #define LS_MAT_MAX ((1 &lt;&lt; (LS_MAT_BITS - 1)) - 1)
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            : #define LS_SUM(a) ((a)*4 + LS_STEP * 2)
<span class="lineNum">    1488 </span>            : #define LS_SQUARE(a) \
<span class="lineNum">    1489 </span>            :   (((a) * (a)*4 + (a)*4 * LS_STEP + LS_STEP * LS_STEP * 2) &gt;&gt; 2)
<span class="lineNum">    1490 </span>            : #define LS_PRODUCT1(a, b) \
<span class="lineNum">    1491 </span>            :   (((a) * (b)*4 + ((a) + (b)) * 2 * LS_STEP + LS_STEP * LS_STEP) &gt;&gt; 2)
<span class="lineNum">    1492 </span>            : #define LS_PRODUCT2(a, b) \
<a name="1493"><span class="lineNum">    1493 </span>            :   (((a) * (b)*4 + ((a) + (b)) * 2 * LS_STEP + LS_STEP * LS_STEP * 2) &gt;&gt; 2)</a>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 : static int find_affine_int(int np, int *pts1, int *pts2, BLOCK_SIZE bsize,</span>
<span class="lineNum">    1496 </span>            :                            int mvy, int mvx, WarpedMotionParams *wm, int mi_row,
<span class="lineNum">    1497 </span>            :                            int mi_col) {
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :   int32_t A[2][2] = { { 0, 0 }, { 0, 0 } };</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :   int32_t Bx[2] = { 0, 0 };</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   int32_t By[2] = { 0, 0 };</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   int i, n = 0;</span>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :   const int bw = block_size_wide[bsize];</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   const int bh = block_size_high[bsize];</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   const int suy = (mi_row * MI_SIZE + AOMMAX(bh, MI_SIZE) / 2 - 1) * 8;</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   const int sux = (mi_col * MI_SIZE + AOMMAX(bw, MI_SIZE) / 2 - 1) * 8;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   const int duy = suy + mvy;</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   const int dux = sux + mvx;</span>
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span>            :   // Assume the center pixel of the block has exactly the same motion vector
<span class="lineNum">    1511 </span>            :   // as transmitted for the block. First shift the origin of the source
<span class="lineNum">    1512 </span>            :   // points to the block center, and the origin of the destination points to
<span class="lineNum">    1513 </span>            :   // the block center added to the motion vector transmitted.
<span class="lineNum">    1514 </span>            :   // Let (xi, yi) denote the source points and (xi', yi') denote destination
<span class="lineNum">    1515 </span>            :   // points after origin shfifting, for i = 0, 1, 2, .... n-1.
<span class="lineNum">    1516 </span>            :   // Then if  P = [x0, y0,
<span class="lineNum">    1517 </span>            :   //               x1, y1
<span class="lineNum">    1518 </span>            :   //               x2, y1,
<span class="lineNum">    1519 </span>            :   //                ....
<span class="lineNum">    1520 </span>            :   //              ]
<span class="lineNum">    1521 </span>            :   //          q = [x0', x1', x2', ... ]'
<span class="lineNum">    1522 </span>            :   //          r = [y0', y1', y2', ... ]'
<span class="lineNum">    1523 </span>            :   // the least squares problems that need to be solved are:
<span class="lineNum">    1524 </span>            :   //          [h1, h2]' = inv(P'P)P'q and
<span class="lineNum">    1525 </span>            :   //          [h3, h4]' = inv(P'P)P'r
<span class="lineNum">    1526 </span>            :   // where the affine transformation is given by:
<span class="lineNum">    1527 </span>            :   //          x' = h1.x + h2.y
<span class="lineNum">    1528 </span>            :   //          y' = h3.x + h4.y
<span class="lineNum">    1529 </span>            :   //
<span class="lineNum">    1530 </span>            :   // The loop below computes: A = P'P, Bx = P'q, By = P'r
<span class="lineNum">    1531 </span>            :   // We need to just compute inv(A).Bx and inv(A).By for the solutions.
<span class="lineNum">    1532 </span>            :   int sx, sy, dx, dy;
<span class="lineNum">    1533 </span>            :   // Contribution from neighbor block
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; np &amp;&amp; n &lt; LEAST_SQUARES_SAMPLES_MAX; i++) {</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :     dx = pts2[i * 2] - dux;</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :     dy = pts2[i * 2 + 1] - duy;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     sx = pts1[i * 2] - sux;</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     sy = pts1[i * 2 + 1] - suy;</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     if (abs(sx - dx) &lt; LS_MV_MAX &amp;&amp; abs(sy - dy) &lt; LS_MV_MAX) {</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :       A[0][0] += LS_SQUARE(sx);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :       A[0][1] += LS_PRODUCT1(sx, sy);</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :       A[1][1] += LS_SQUARE(sy);</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :       Bx[0] += LS_PRODUCT2(sx, dx);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :       Bx[1] += LS_PRODUCT1(sy, dx);</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :       By[0] += LS_PRODUCT1(sx, dy);</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :       By[1] += LS_PRODUCT2(sy, dy);</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :       n++;</span>
<span class="lineNum">    1548 </span>            :     }
<span class="lineNum">    1549 </span>            :   }
<span class="lineNum">    1550 </span>            :   int downshift;
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   if (n &gt;= 4)</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :     downshift = LS_MAT_DOWN_BITS;</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   else if (n &gt;= 2)</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :     downshift = LS_MAT_DOWN_BITS - 1;</span>
<span class="lineNum">    1555 </span>            :   else
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     downshift = LS_MAT_DOWN_BITS - 2;</span>
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :   // Reduce precision by downshift bits
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   A[0][0] = clamp(ROUND_POWER_OF_TWO_SIGNED(A[0][0], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1560 </span>            :                   LS_MAT_MAX);
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   A[0][1] = clamp(ROUND_POWER_OF_TWO_SIGNED(A[0][1], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1562 </span>            :                   LS_MAT_MAX);
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   A[1][1] = clamp(ROUND_POWER_OF_TWO_SIGNED(A[1][1], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1564 </span>            :                   LS_MAT_MAX);
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   Bx[0] = clamp(ROUND_POWER_OF_TWO_SIGNED(Bx[0], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1566 </span>            :                 LS_MAT_MAX);
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   Bx[1] = clamp(ROUND_POWER_OF_TWO_SIGNED(Bx[1], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1568 </span>            :                 LS_MAT_MAX);
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   By[0] = clamp(ROUND_POWER_OF_TWO_SIGNED(By[0], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1570 </span>            :                 LS_MAT_MAX);
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :   By[1] = clamp(ROUND_POWER_OF_TWO_SIGNED(By[1], downshift), LS_MAT_MIN,</span>
<span class="lineNum">    1572 </span>            :                 LS_MAT_MAX);
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            :   int64_t Px[2], Py[2], Det;
<span class="lineNum">    1575 </span>            :   int16_t iDet, shift;
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            :   // These divided by the Det, are the least squares solutions
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :   Px[0] = (int64_t)A[1][1] * Bx[0] - (int64_t)A[0][1] * Bx[1];</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   Px[1] = -(int64_t)A[0][1] * Bx[0] + (int64_t)A[0][0] * Bx[1];</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   Py[0] = (int64_t)A[1][1] * By[0] - (int64_t)A[0][1] * By[1];</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   Py[1] = -(int64_t)A[0][1] * By[0] + (int64_t)A[0][0] * By[1];</span>
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            :   // Compute Determinant of A
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   Det = (int64_t)A[0][0] * A[1][1] - (int64_t)A[0][1] * A[0][1];</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   if (Det == 0) return 1;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   iDet = resolve_divisor_64(llabs(Det), &amp;shift) * (Det &lt; 0 ? -1 : 1);</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   shift -= WARPEDMODEL_PREC_BITS;</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :   if (shift &lt; 0) {</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :     iDet &lt;&lt;= (-shift);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :     shift = 0;</span>
<span class="lineNum">    1591 </span>            :   }
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :   int64_t v;
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :   v = Px[0] * (int64_t)iDet;</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[2] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED_64(v, shift));</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   v = Px[1] * (int64_t)iDet;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[3] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED_64(v, shift));</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :   v = ((int64_t)dux * (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) -</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :       (int64_t)sux * wm-&gt;wmmat[2] - (int64_t)suy * wm-&gt;wmmat[3];</span>
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[0] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED(v, 3));</span>
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :   v = Py[0] * (int64_t)iDet;</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[4] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED_64(v, shift));</span>
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   v = Py[1] * (int64_t)iDet;</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[5] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED_64(v, shift));</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :   v = ((int64_t)duy * (1 &lt;&lt; WARPEDMODEL_PREC_BITS)) -</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :       (int64_t)sux * wm-&gt;wmmat[4] - (int64_t)suy * wm-&gt;wmmat[5];</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[1] = (int32_t)(ROUND_POWER_OF_TWO_SIGNED(v, 3));</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[6] = wm-&gt;wmmat[7] = 0;</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            :   // Clamp values
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[0] = clamp(wm-&gt;wmmat[0], -WARPEDMODEL_TRANS_CLAMP,</span>
<span class="lineNum">    1614 </span>            :                        WARPEDMODEL_TRANS_CLAMP - 1);
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[1] = clamp(wm-&gt;wmmat[1], -WARPEDMODEL_TRANS_CLAMP,</span>
<span class="lineNum">    1616 </span>            :                        WARPEDMODEL_TRANS_CLAMP - 1);
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[2] = clamp(wm-&gt;wmmat[2], -WARPEDMODEL_DIAGAFFINE_CLAMP,</span>
<span class="lineNum">    1618 </span>            :                        WARPEDMODEL_DIAGAFFINE_CLAMP - 1);
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[5] = clamp(wm-&gt;wmmat[5], -WARPEDMODEL_DIAGAFFINE_CLAMP,</span>
<span class="lineNum">    1620 </span>            :                        WARPEDMODEL_DIAGAFFINE_CLAMP - 1);
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[3] = clamp(wm-&gt;wmmat[3], -WARPEDMODEL_NONDIAGAFFINE_CLAMP,</span>
<span class="lineNum">    1622 </span>            :                        WARPEDMODEL_NONDIAGAFFINE_CLAMP - 1);
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :   wm-&gt;wmmat[4] = clamp(wm-&gt;wmmat[4], -WARPEDMODEL_NONDIAGAFFINE_CLAMP,</span>
<span class="lineNum">    1624 </span>            :                        WARPEDMODEL_NONDIAGAFFINE_CLAMP - 1);
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="1626"><span class="lineNum">    1626 </span>            : }</a>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 : int find_projection(int np, int *pts1, int *pts2, BLOCK_SIZE bsize, int mvy,</span>
<span class="lineNum">    1629 </span>            :                     int mvx, WarpedMotionParams *wm_params, int mi_row,
<span class="lineNum">    1630 </span>            :                     int mi_col) {
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :   int result = 1;</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :   switch (wm_params-&gt;wmtype) {</span>
<span class="lineNum">    1633 </span>            :     case AFFINE:
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :       result = find_affine_int(np, pts1, pts2, bsize, mvy, mvx, wm_params,</span>
<span class="lineNum">    1635 </span>            :                                mi_row, mi_col);
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     default: assert(0 &amp;&amp; &quot;Invalid warped motion type!&quot;); return 1;</span>
<span class="lineNum">    1638 </span>            :   }
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :   if (result == 0) {</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :     if (wm_params-&gt;wmtype == ROTZOOM) {</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :       wm_params-&gt;wmmat[5] = wm_params-&gt;wmmat[2];</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :       wm_params-&gt;wmmat[4] = -wm_params-&gt;wmmat[3];</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :     if (wm_params-&gt;wmtype == AFFINE || wm_params-&gt;wmtype == ROTZOOM) {</span>
<span class="lineNum">    1645 </span>            :       // check compatibility with the fast warp filter
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :       if (!get_shear_params(wm_params)) return 1;</span>
<span class="lineNum">    1647 </span>            :     }
<span class="lineNum">    1648 </span>            :   }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1651 </span>            : }
<span class="lineNum">    1652 </span>            : #endif  // CONFIG_WARPED_MOTION
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

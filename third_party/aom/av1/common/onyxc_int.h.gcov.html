<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/common/onyxc_int.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/common</a> - onyxc_int.h<span style="font-size: 80%;"> (source / <a href="onyxc_int.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">231</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef AV1_COMMON_ONYXC_INT_H_
<span class="lineNum">      13 </span>            : #define AV1_COMMON_ONYXC_INT_H_
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;./aom_config.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;./av1_rtcd.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;aom/internal/aom_codec_internal.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;aom_util/aom_thread.h&quot;
<span class="lineNum">      19 </span>            : #if CONFIG_ANS
<span class="lineNum">      20 </span>            : #include &quot;aom_dsp/ans.h&quot;
<span class="lineNum">      21 </span>            : #endif
<span class="lineNum">      22 </span>            : #include &quot;av1/common/alloccommon.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;av1/common/av1_loopfilter.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;av1/common/entropy.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;av1/common/entropymode.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;av1/common/entropymv.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;av1/common/frame_buffers.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;av1/common/mv.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;av1/common/quant_common.h&quot;
<span class="lineNum">      30 </span>            : #if CONFIG_LOOP_RESTORATION
<span class="lineNum">      31 </span>            : #include &quot;av1/common/restoration.h&quot;
<span class="lineNum">      32 </span>            : #endif  // CONFIG_LOOP_RESTORATION
<span class="lineNum">      33 </span>            : #include &quot;av1/common/tile_common.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;av1/common/odintrin.h&quot;
<span class="lineNum">      35 </span>            : #if CONFIG_PVQ
<span class="lineNum">      36 </span>            : #include &quot;av1/common/pvq.h&quot;
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : #if CONFIG_CFL
<span class="lineNum">      39 </span>            : #include &quot;av1/common/cfl.h&quot;
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : #ifdef __cplusplus
<span class="lineNum">      42 </span>            : extern &quot;C&quot; {
<span class="lineNum">      43 </span>            : #endif
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : #define CDEF_MAX_STRENGTHS 16
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #define REF_FRAMES_LOG2 3
<span class="lineNum">      48 </span>            : #define REF_FRAMES (1 &lt;&lt; REF_FRAMES_LOG2)
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : // 4 scratch frames for the new frames to support a maximum of 4 cores decoding
<span class="lineNum">      51 </span>            : // in parallel, 3 for scaled references on the encoder.
<span class="lineNum">      52 </span>            : // TODO(hkuang): Add ondemand frame buffers instead of hardcoding the number
<span class="lineNum">      53 </span>            : // of framebuffers.
<span class="lineNum">      54 </span>            : // TODO(jkoleszar): These 3 extra references could probably come from the
<span class="lineNum">      55 </span>            : // normal reference pool.
<span class="lineNum">      56 </span>            : #define FRAME_BUFFERS (REF_FRAMES + 7)
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #if CONFIG_REFERENCE_BUFFER
<span class="lineNum">      59 </span>            : /* Constant values while waiting for the sequence header */
<span class="lineNum">      60 </span>            : #define FRAME_ID_NUMBERS_PRESENT_FLAG 1
<span class="lineNum">      61 </span>            : #define FRAME_ID_LENGTH_MINUS7 8         // Allows frame id up to 2^15-1
<span class="lineNum">      62 </span>            : #define DELTA_FRAME_ID_LENGTH_MINUS2 12  // Allows frame id deltas up to 2^14-1
<span class="lineNum">      63 </span>            : #endif
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">      66 </span>            : #define FRAME_CONTEXTS_LOG2 3
<span class="lineNum">      67 </span>            : #else
<span class="lineNum">      68 </span>            : #define FRAME_CONTEXTS_LOG2 2
<span class="lineNum">      69 </span>            : #endif
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : #define FRAME_CONTEXTS (1 &lt;&lt; FRAME_CONTEXTS_LOG2)
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : #define NUM_PING_PONG_BUFFERS 2
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : typedef enum {
<span class="lineNum">      76 </span>            :   SINGLE_REFERENCE = 0,
<span class="lineNum">      77 </span>            :   COMPOUND_REFERENCE = 1,
<span class="lineNum">      78 </span>            :   REFERENCE_MODE_SELECT = 2,
<span class="lineNum">      79 </span>            :   REFERENCE_MODES = 3,
<span class="lineNum">      80 </span>            : } REFERENCE_MODE;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : typedef enum {
<span class="lineNum">      83 </span>            :   RESET_FRAME_CONTEXT_NONE = 0,
<span class="lineNum">      84 </span>            :   RESET_FRAME_CONTEXT_CURRENT = 1,
<span class="lineNum">      85 </span>            :   RESET_FRAME_CONTEXT_ALL = 2,
<span class="lineNum">      86 </span>            : } RESET_FRAME_CONTEXT_MODE;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : typedef enum {
<span class="lineNum">      89 </span>            :   /**
<span class="lineNum">      90 </span>            :    * Update frame context to values resulting from forward probability
<span class="lineNum">      91 </span>            :    * updates signaled in the frame header
<span class="lineNum">      92 </span>            :    */
<span class="lineNum">      93 </span>            :   REFRESH_FRAME_CONTEXT_FORWARD,
<span class="lineNum">      94 </span>            :   /**
<span class="lineNum">      95 </span>            :    * Update frame context to values resulting from backward probability
<span class="lineNum">      96 </span>            :    * updates based on entropy/counts in the decoded frame
<span class="lineNum">      97 </span>            :    */
<span class="lineNum">      98 </span>            :   REFRESH_FRAME_CONTEXT_BACKWARD,
<span class="lineNum">      99 </span>            : } REFRESH_FRAME_CONTEXT_MODE;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : typedef struct {
<span class="lineNum">     102 </span>            :   int_mv mv[2];
<span class="lineNum">     103 </span>            :   int_mv pred_mv[2];
<span class="lineNum">     104 </span>            :   MV_REFERENCE_FRAME ref_frame[2];
<span class="lineNum">     105 </span>            : } MV_REF;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : typedef struct {
<span class="lineNum">     108 </span>            :   int ref_count;
<span class="lineNum">     109 </span>            :   MV_REF *mvs;
<span class="lineNum">     110 </span>            :   int mi_rows;
<span class="lineNum">     111 </span>            :   int mi_cols;
<span class="lineNum">     112 </span>            : #if CONFIG_GLOBAL_MOTION
<span class="lineNum">     113 </span>            :   WarpedMotionParams global_motion[TOTAL_REFS_PER_FRAME];
<span class="lineNum">     114 </span>            : #endif  // CONFIG_GLOBAL_MOTION
<span class="lineNum">     115 </span>            :   aom_codec_frame_buffer_t raw_frame_buffer;
<span class="lineNum">     116 </span>            :   YV12_BUFFER_CONFIG buf;
<span class="lineNum">     117 </span>            : #if CONFIG_TEMPMV_SIGNALING
<span class="lineNum">     118 </span>            :   uint8_t intra_only;
<span class="lineNum">     119 </span>            : #endif
<span class="lineNum">     120 </span>            :   // The Following variables will only be used in frame parallel decode.
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   // frame_worker_owner indicates which FrameWorker owns this buffer. NULL means
<span class="lineNum">     123 </span>            :   // that no FrameWorker owns, or is decoding, this buffer.
<span class="lineNum">     124 </span>            :   AVxWorker *frame_worker_owner;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :   // row and col indicate which position frame has been decoded to in real
<span class="lineNum">     127 </span>            :   // pixel unit. They are reset to -1 when decoding begins and set to INT_MAX
<span class="lineNum">     128 </span>            :   // when the frame is fully decoded.
<span class="lineNum">     129 </span>            :   int row;
<span class="lineNum">     130 </span>            :   int col;
<span class="lineNum">     131 </span>            : } RefCntBuffer;
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : typedef struct BufferPool {
<span class="lineNum">     134 </span>            : // Protect BufferPool from being accessed by several FrameWorkers at
<span class="lineNum">     135 </span>            : // the same time during frame parallel decode.
<span class="lineNum">     136 </span>            : // TODO(hkuang): Try to use atomic variable instead of locking the whole pool.
<span class="lineNum">     137 </span>            : #if CONFIG_MULTITHREAD
<span class="lineNum">     138 </span>            :   pthread_mutex_t pool_mutex;
<span class="lineNum">     139 </span>            : #endif
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :   // Private data associated with the frame buffer callbacks.
<span class="lineNum">     142 </span>            :   void *cb_priv;
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :   aom_get_frame_buffer_cb_fn_t get_fb_cb;
<span class="lineNum">     145 </span>            :   aom_release_frame_buffer_cb_fn_t release_fb_cb;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   RefCntBuffer frame_bufs[FRAME_BUFFERS];
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   // Frame buffers allocated internally by the codec.
<span class="lineNum">     150 </span>            :   InternalFrameBufferList int_frame_buffers;
<span class="lineNum">     151 </span>            : } BufferPool;
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : typedef struct AV1Common {
<span class="lineNum">     154 </span>            :   struct aom_internal_error_info error;
<span class="lineNum">     155 </span>            :   aom_color_space_t color_space;
<span class="lineNum">     156 </span>            :   int color_range;
<span class="lineNum">     157 </span>            :   int width;
<span class="lineNum">     158 </span>            :   int height;
<span class="lineNum">     159 </span>            :   int render_width;
<span class="lineNum">     160 </span>            :   int render_height;
<span class="lineNum">     161 </span>            :   int last_width;
<span class="lineNum">     162 </span>            :   int last_height;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   // TODO(jkoleszar): this implies chroma ss right now, but could vary per
<span class="lineNum">     165 </span>            :   // plane. Revisit as part of the future change to YV12_BUFFER_CONFIG to
<span class="lineNum">     166 </span>            :   // support additional planes.
<span class="lineNum">     167 </span>            :   int subsampling_x;
<span class="lineNum">     168 </span>            :   int subsampling_y;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">     171 </span>            :   // Marks if we need to use 16bit frame buffers (1: yes, 0: no).
<span class="lineNum">     172 </span>            :   int use_highbitdepth;
<span class="lineNum">     173 </span>            : #endif
<span class="lineNum">     174 </span>            :   YV12_BUFFER_CONFIG *frame_to_show;
<span class="lineNum">     175 </span>            :   RefCntBuffer *prev_frame;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   // TODO(hkuang): Combine this with cur_buf in macroblockd.
<span class="lineNum">     178 </span>            :   RefCntBuffer *cur_frame;
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :   int ref_frame_map[REF_FRAMES]; /* maps fb_idx to reference slot */
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   // Prepare ref_frame_map for the next frame.
<span class="lineNum">     183 </span>            :   // Only used in frame parallel decode.
<span class="lineNum">     184 </span>            :   int next_ref_frame_map[REF_FRAMES];
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :   // TODO(jkoleszar): could expand active_ref_idx to 4, with 0 as intra, and
<span class="lineNum">     187 </span>            :   // roll new_fb_idx into it.
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :   // Each Inter frame can reference INTER_REFS_PER_FRAME buffers
<span class="lineNum">     190 </span>            :   RefBuffer frame_refs[INTER_REFS_PER_FRAME];
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            :   int new_fb_idx;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :   FRAME_TYPE last_frame_type; /* last frame's frame type for motion search.*/
<span class="lineNum">     195 </span>            :   FRAME_TYPE frame_type;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   int show_frame;
<span class="lineNum">     198 </span>            :   int last_show_frame;
<span class="lineNum">     199 </span>            :   int show_existing_frame;
<span class="lineNum">     200 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     201 </span>            :   // Flag for a frame used as a reference - not written to the bitstream
<span class="lineNum">     202 </span>            :   int is_reference_frame;
<span class="lineNum">     203 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // Flag signaling that the frame is encoded using only INTRA modes.
<span class="lineNum">     206 </span>            :   uint8_t intra_only;
<span class="lineNum">     207 </span>            :   uint8_t last_intra_only;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   int allow_high_precision_mv;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : #if CONFIG_PALETTE || CONFIG_INTRABC
<span class="lineNum">     212 </span>            :   int allow_screen_content_tools;
<span class="lineNum">     213 </span>            : #endif  // CONFIG_PALETTE || CONFIG_INTRABC
<span class="lineNum">     214 </span>            : #if CONFIG_EXT_INTER
<span class="lineNum">     215 </span>            : #if CONFIG_INTERINTRA
<span class="lineNum">     216 </span>            :   int allow_interintra_compound;
<span class="lineNum">     217 </span>            : #endif  // CONFIG_INTERINTRA
<span class="lineNum">     218 </span>            : #if CONFIG_WEDGE || CONFIG_COMPOUND_SEGMENT
<span class="lineNum">     219 </span>            :   int allow_masked_compound;
<span class="lineNum">     220 </span>            : #endif  // CONFIG_WEDGE || CONFIG_COMPOUND_SEGMENT
<span class="lineNum">     221 </span>            : #endif  // CONFIG_EXT_INTER
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   // Flag signaling which frame contexts should be reset to default values.
<span class="lineNum">     224 </span>            :   RESET_FRAME_CONTEXT_MODE reset_frame_context;
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   // MBs, mb_rows/cols is in 16-pixel units; mi_rows/cols is in
<span class="lineNum">     227 </span>            :   // MODE_INFO (8-pixel) units.
<span class="lineNum">     228 </span>            :   int MBs;
<span class="lineNum">     229 </span>            :   int mb_rows, mi_rows;
<span class="lineNum">     230 </span>            :   int mb_cols, mi_cols;
<span class="lineNum">     231 </span>            :   int mi_stride;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   /* profile settings */
<span class="lineNum">     234 </span>            :   TX_MODE tx_mode;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   int base_qindex;
<span class="lineNum">     237 </span>            :   int y_dc_delta_q;
<span class="lineNum">     238 </span>            :   int uv_dc_delta_q;
<span class="lineNum">     239 </span>            :   int uv_ac_delta_q;
<span class="lineNum">     240 </span>            :   int16_t y_dequant[MAX_SEGMENTS][2];
<span class="lineNum">     241 </span>            :   int16_t uv_dequant[MAX_SEGMENTS][2];
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : #if CONFIG_AOM_QM
<span class="lineNum">     244 </span>            :   // Global quant matrix tables
<span class="lineNum">     245 </span>            :   qm_val_t *giqmatrix[NUM_QM_LEVELS][2][2][TX_SIZES_ALL];
<span class="lineNum">     246 </span>            :   qm_val_t *gqmatrix[NUM_QM_LEVELS][2][2][TX_SIZES_ALL];
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   // Local quant matrix tables for each frame
<span class="lineNum">     249 </span>            :   qm_val_t *y_iqmatrix[MAX_SEGMENTS][2][TX_SIZES_ALL];
<span class="lineNum">     250 </span>            :   qm_val_t *uv_iqmatrix[MAX_SEGMENTS][2][TX_SIZES_ALL];
<span class="lineNum">     251 </span>            :   // Encoder
<span class="lineNum">     252 </span>            :   qm_val_t *y_qmatrix[MAX_SEGMENTS][2][TX_SIZES_ALL];
<span class="lineNum">     253 </span>            :   qm_val_t *uv_qmatrix[MAX_SEGMENTS][2][TX_SIZES_ALL];
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   int using_qmatrix;
<span class="lineNum">     256 </span>            :   int min_qmlevel;
<span class="lineNum">     257 </span>            :   int max_qmlevel;
<span class="lineNum">     258 </span>            : #endif
<span class="lineNum">     259 </span>            : #if CONFIG_NEW_QUANT
<span class="lineNum">     260 </span>            :   dequant_val_type_nuq y_dequant_nuq[MAX_SEGMENTS][QUANT_PROFILES][COEF_BANDS];
<span class="lineNum">     261 </span>            :   dequant_val_type_nuq uv_dequant_nuq[MAX_SEGMENTS][QUANT_PROFILES][COEF_BANDS];
<span class="lineNum">     262 </span>            : #endif
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   /* We allocate a MODE_INFO struct for each macroblock, together with
<span class="lineNum">     265 </span>            :      an extra row on top and column on the left to simplify prediction. */
<span class="lineNum">     266 </span>            :   int mi_alloc_size;
<span class="lineNum">     267 </span>            :   MODE_INFO *mip; /* Base of allocated array */
<span class="lineNum">     268 </span>            :   MODE_INFO *mi;  /* Corresponds to upper left visible macroblock */
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   // TODO(agrange): Move prev_mi into encoder structure.
<span class="lineNum">     271 </span>            :   // prev_mip and prev_mi will only be allocated in encoder.
<span class="lineNum">     272 </span>            :   MODE_INFO *prev_mip; /* MODE_INFO array 'mip' from last decoded frame */
<span class="lineNum">     273 </span>            :   MODE_INFO *prev_mi;  /* 'mi' from last frame (points into prev_mip) */
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   // Separate mi functions between encoder and decoder.
<span class="lineNum">     276 </span>            :   int (*alloc_mi)(struct AV1Common *cm, int mi_size);
<span class="lineNum">     277 </span>            :   void (*free_mi)(struct AV1Common *cm);
<span class="lineNum">     278 </span>            :   void (*setup_mi)(struct AV1Common *cm);
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :   // Grid of pointers to 8x8 MODE_INFO structs.  Any 8x8 not in the visible
<span class="lineNum">     281 </span>            :   // area will be NULL.
<span class="lineNum">     282 </span>            :   MODE_INFO **mi_grid_base;
<span class="lineNum">     283 </span>            :   MODE_INFO **mi_grid_visible;
<span class="lineNum">     284 </span>            :   MODE_INFO **prev_mi_grid_base;
<span class="lineNum">     285 </span>            :   MODE_INFO **prev_mi_grid_visible;
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   // Whether to use previous frame's motion vectors for prediction.
<span class="lineNum">     288 </span>            :   int use_prev_frame_mvs;
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   // Persistent mb segment id map used in prediction.
<span class="lineNum">     291 </span>            :   int seg_map_idx;
<span class="lineNum">     292 </span>            :   int prev_seg_map_idx;
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   uint8_t *seg_map_array[NUM_PING_PONG_BUFFERS];
<span class="lineNum">     295 </span>            :   uint8_t *last_frame_seg_map;
<span class="lineNum">     296 </span>            :   uint8_t *current_frame_seg_map;
<span class="lineNum">     297 </span>            :   int seg_map_alloc_size;
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   InterpFilter interp_filter;
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   loop_filter_info_n lf_info;
<span class="lineNum">     302 </span>            : #if CONFIG_FRAME_SUPERRES
<span class="lineNum">     303 </span>            :   // The numerator of the superres scale; the denominator is fixed.
<span class="lineNum">     304 </span>            :   uint8_t superres_scale_numerator;
<span class="lineNum">     305 </span>            : #endif  // CONFIG_FRAME_SUPERRES
<span class="lineNum">     306 </span>            : #if CONFIG_LOOP_RESTORATION
<span class="lineNum">     307 </span>            :   RestorationInfo rst_info[MAX_MB_PLANE];
<span class="lineNum">     308 </span>            :   RestorationInternal rst_internal;
<span class="lineNum">     309 </span>            : #endif  // CONFIG_LOOP_RESTORATION
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :   // Flag signaling how frame contexts should be updated at the end of
<span class="lineNum">     312 </span>            :   // a frame decode
<span class="lineNum">     313 </span>            :   REFRESH_FRAME_CONTEXT_MODE refresh_frame_context;
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :   int ref_frame_sign_bias[TOTAL_REFS_PER_FRAME]; /* Two state 0, 1 */
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   struct loopfilter lf;
<span class="lineNum">     318 </span>            :   struct segmentation seg;
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   int frame_parallel_decode;  // frame-based threading.
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : #if CONFIG_EXT_TX
<span class="lineNum">     323 </span>            :   int reduced_tx_set_used;
<span class="lineNum">     324 </span>            : #endif  // CONFIG_EXT_TX
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : // Context probabilities for reference frame prediction
<span class="lineNum">     327 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     328 </span>            :   MV_REFERENCE_FRAME comp_fwd_ref[FWD_REFS];
<span class="lineNum">     329 </span>            :   MV_REFERENCE_FRAME comp_bwd_ref[BWD_REFS];
<span class="lineNum">     330 </span>            : #else
<span class="lineNum">     331 </span>            :   MV_REFERENCE_FRAME comp_fixed_ref;
<span class="lineNum">     332 </span>            :   MV_REFERENCE_FRAME comp_var_ref[COMP_REFS];
<span class="lineNum">     333 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     334 </span>            :   REFERENCE_MODE reference_mode;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   FRAME_CONTEXT *fc;              /* this frame entropy */
<span class="lineNum">     337 </span>            :   FRAME_CONTEXT *frame_contexts;  // FRAME_CONTEXTS
<span class="lineNum">     338 </span>            :   FRAME_CONTEXT *pre_fc;          // Context referenced in this frame
<span class="lineNum">     339 </span>            :   unsigned int frame_context_idx; /* Context to use/update */
<span class="lineNum">     340 </span>            :   FRAME_COUNTS counts;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   unsigned int current_video_frame;
<span class="lineNum">     343 </span>            :   BITSTREAM_PROFILE profile;
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :   // AOM_BITS_8 in profile 0 or 1, AOM_BITS_10 or AOM_BITS_12 in profile 2 or 3.
<span class="lineNum">     346 </span>            :   aom_bit_depth_t bit_depth;
<span class="lineNum">     347 </span>            :   aom_bit_depth_t dequant_bit_depth;  // bit_depth of current dequantizer
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :   int error_resilient_mode;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : #if !CONFIG_EXT_TILE
<span class="lineNum">     352 </span>            :   int log2_tile_cols, log2_tile_rows;
<span class="lineNum">     353 </span>            : #endif  // !CONFIG_EXT_TILE
<span class="lineNum">     354 </span>            :   int tile_cols, tile_rows;
<span class="lineNum">     355 </span>            :   int tile_width, tile_height;  // In MI units
<span class="lineNum">     356 </span>            : #if CONFIG_EXT_TILE
<span class="lineNum">     357 </span>            :   unsigned int tile_encoding_mode;
<span class="lineNum">     358 </span>            : #endif  // CONFIG_EXT_TILE
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : #if CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     361 </span>            :   int dependent_horz_tiles;
<span class="lineNum">     362 </span>            : #if CONFIG_TILE_GROUPS
<span class="lineNum">     363 </span>            :   int tile_group_start_row[MAX_TILE_ROWS][MAX_TILE_COLS];
<span class="lineNum">     364 </span>            :   int tile_group_start_col[MAX_TILE_ROWS][MAX_TILE_COLS];
<span class="lineNum">     365 </span>            : #endif
<span class="lineNum">     366 </span>            : #endif
<span class="lineNum">     367 </span>            : #if CONFIG_LOOPFILTERING_ACROSS_TILES
<span class="lineNum">     368 </span>            :   int loop_filter_across_tiles_enabled;
<span class="lineNum">     369 </span>            : #endif  // CONFIG_LOOPFILTERING_ACROSS_TILES
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :   int byte_alignment;
<span class="lineNum">     372 </span>            :   int skip_loop_filter;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :   // Private data associated with the frame buffer callbacks.
<span class="lineNum">     375 </span>            :   void *cb_priv;
<span class="lineNum">     376 </span>            :   aom_get_frame_buffer_cb_fn_t get_fb_cb;
<span class="lineNum">     377 </span>            :   aom_release_frame_buffer_cb_fn_t release_fb_cb;
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   // Handles memory for the codec.
<span class="lineNum">     380 </span>            :   InternalFrameBufferList int_frame_buffers;
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :   // External BufferPool passed from outside.
<span class="lineNum">     383 </span>            :   BufferPool *buffer_pool;
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   PARTITION_CONTEXT *above_seg_context;
<span class="lineNum">     386 </span>            :   ENTROPY_CONTEXT *above_context[MAX_MB_PLANE];
<span class="lineNum">     387 </span>            : #if CONFIG_VAR_TX
<span class="lineNum">     388 </span>            :   TXFM_CONTEXT *above_txfm_context;
<span class="lineNum">     389 </span>            :   TXFM_CONTEXT *top_txfm_context[MAX_MB_PLANE];
<span class="lineNum">     390 </span>            :   TXFM_CONTEXT left_txfm_context[MAX_MB_PLANE][2 * MAX_MIB_SIZE];
<span class="lineNum">     391 </span>            : #endif
<span class="lineNum">     392 </span>            :   int above_context_alloc_cols;
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            :   // scratch memory for intraonly/keyframe forward updates from default tables
<span class="lineNum">     395 </span>            :   // - this is intentionally not placed in FRAME_CONTEXT since it's reset upon
<span class="lineNum">     396 </span>            :   // each keyframe and not used afterwards
<span class="lineNum">     397 </span>            :   aom_prob kf_y_prob[INTRA_MODES][INTRA_MODES][INTRA_MODES - 1];
<span class="lineNum">     398 </span>            : #if CONFIG_GLOBAL_MOTION
<span class="lineNum">     399 </span>            :   WarpedMotionParams global_motion[TOTAL_REFS_PER_FRAME];
<span class="lineNum">     400 </span>            : #endif
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   BLOCK_SIZE sb_size;  // Size of the superblock used for this frame
<span class="lineNum">     403 </span>            :   int mib_size;        // Size of the superblock in units of MI blocks
<span class="lineNum">     404 </span>            :   int mib_size_log2;   // Log 2 of above.
<span class="lineNum">     405 </span>            : #if CONFIG_CDEF
<span class="lineNum">     406 </span>            :   int cdef_dering_damping;
<span class="lineNum">     407 </span>            :   int cdef_clpf_damping;
<span class="lineNum">     408 </span>            :   int nb_cdef_strengths;
<span class="lineNum">     409 </span>            :   int cdef_strengths[CDEF_MAX_STRENGTHS];
<span class="lineNum">     410 </span>            :   int cdef_uv_strengths[CDEF_MAX_STRENGTHS];
<span class="lineNum">     411 </span>            :   int cdef_bits;
<span class="lineNum">     412 </span>            : #endif
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : #if CONFIG_DELTA_Q
<span class="lineNum">     415 </span>            :   int delta_q_present_flag;
<span class="lineNum">     416 </span>            :   // Resolution of delta quant
<span class="lineNum">     417 </span>            :   int delta_q_res;
<span class="lineNum">     418 </span>            : #if CONFIG_EXT_DELTA_Q
<span class="lineNum">     419 </span>            :   int delta_lf_present_flag;
<span class="lineNum">     420 </span>            :   // Resolution of delta lf level
<span class="lineNum">     421 </span>            :   int delta_lf_res;
<span class="lineNum">     422 </span>            : #endif
<span class="lineNum">     423 </span>            : #endif
<span class="lineNum">     424 </span>            : #if CONFIG_TILE_GROUPS
<span class="lineNum">     425 </span>            :   int num_tg;
<span class="lineNum">     426 </span>            : #endif
<span class="lineNum">     427 </span>            : #if CONFIG_REFERENCE_BUFFER
<span class="lineNum">     428 </span>            :   int current_frame_id;
<span class="lineNum">     429 </span>            :   int ref_frame_id[REF_FRAMES];
<span class="lineNum">     430 </span>            :   int valid_for_referencing[REF_FRAMES];
<span class="lineNum">     431 </span>            :   int refresh_mask;
<span class="lineNum">     432 </span>            :   int invalid_delta_frame_id_minus1;
<span class="lineNum">     433 </span>            : #endif
<span class="lineNum">     434 </span>            : #if CONFIG_ANS &amp;&amp; ANS_MAX_SYMBOLS
<span class="lineNum">     435 </span>            :   int ans_window_size_log2;
<span class="lineNum">     436 </span>            : #endif
<span class="lineNum">     437 </span>            : } AV1_COMMON;
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : #if CONFIG_REFERENCE_BUFFER
<span class="lineNum">     440 </span>            : /* Initial version of sequence header structure */
<span class="lineNum">     441 </span>            : typedef struct SequenceHeader {
<span class="lineNum">     442 </span>            :   int frame_id_numbers_present_flag;
<span class="lineNum">     443 </span>            :   int frame_id_length_minus7;
<span class="lineNum">     444 </span>            :   int delta_frame_id_length_minus2;
<span class="lineNum">     445 </span>            : } SequenceHeader;
<span class="lineNum">     446 </span>            : #endif
<span class="lineNum">     447 </span>            : 
<a name="448"><span class="lineNum">     448 </span>            : // TODO(hkuang): Don't need to lock the whole pool after implementing atomic</a>
<span class="lineNum">     449 </span>            : // frame reference count.
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : static void lock_buffer_pool(BufferPool *const pool) {</span>
<span class="lineNum">     451 </span>            : #if CONFIG_MULTITHREAD
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   pthread_mutex_lock(&amp;pool-&gt;pool_mutex);</span>
<span class="lineNum">     453 </span>            : #else
<span class="lineNum">     454 </span>            :   (void)pool;
<span class="lineNum">     455 </span>            : #endif
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 : static void unlock_buffer_pool(BufferPool *const pool) {</span>
<span class="lineNum">     459 </span>            : #if CONFIG_MULTITHREAD
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   pthread_mutex_unlock(&amp;pool-&gt;pool_mutex);</span>
<span class="lineNum">     461 </span>            : #else
<span class="lineNum">     462 </span>            :   (void)pool;
<span class="lineNum">     463 </span>            : #endif
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 : static INLINE YV12_BUFFER_CONFIG *get_ref_frame(AV1_COMMON *cm, int index) {</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   if (index &lt; 0 || index &gt;= REF_FRAMES) return NULL;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   if (cm-&gt;ref_frame_map[index] &lt; 0) return NULL;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   assert(cm-&gt;ref_frame_map[index] &lt; FRAME_BUFFERS);</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   return &amp;cm-&gt;buffer_pool-&gt;frame_bufs[cm-&gt;ref_frame_map[index]].buf;</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : static INLINE YV12_BUFFER_CONFIG *get_frame_new_buffer(</span>
<span class="lineNum">     474 </span>            :     const AV1_COMMON *const cm) {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   return &amp;cm-&gt;buffer_pool-&gt;frame_bufs[cm-&gt;new_fb_idx].buf;</span>
<a name="476"><span class="lineNum">     476 </span>            : }</a>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineNoCov">          0 : static INLINE int get_free_fb(AV1_COMMON *cm) {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   RefCntBuffer *const frame_bufs = cm-&gt;buffer_pool-&gt;frame_bufs;</span>
<span class="lineNum">     480 </span>            :   int i;
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   lock_buffer_pool(cm-&gt;buffer_pool);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; FRAME_BUFFERS; ++i)</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     if (frame_bufs[i].ref_count == 0) break;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   if (i != FRAME_BUFFERS) {</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     frame_bufs[i].ref_count = 1;</span>
<span class="lineNum">     488 </span>            :   } else {
<span class="lineNum">     489 </span>            :     // Reset i to be INVALID_IDX to indicate no free buffer found.
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     i = INVALID_IDX;</span>
<span class="lineNum">     491 </span>            :   }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   unlock_buffer_pool(cm-&gt;buffer_pool);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   return i;</span>
<a name="495"><span class="lineNum">     495 </span>            : }</a>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineNoCov">          0 : static INLINE void ref_cnt_fb(RefCntBuffer *bufs, int *idx, int new_idx) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   const int ref_index = *idx;</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :   if (ref_index &gt;= 0 &amp;&amp; bufs[ref_index].ref_count &gt; 0)</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     bufs[ref_index].ref_count--;</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :   *idx = new_idx;</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   bufs[new_idx].ref_count++;</span>
<a name="506"><span class="lineNum">     506 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineNoCov">          0 : static INLINE int mi_cols_aligned_to_sb(const AV1_COMMON *cm) {</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   return ALIGN_POWER_OF_TWO(cm-&gt;mi_cols, cm-&gt;mib_size_log2);</span>
<a name="510"><span class="lineNum">     510 </span>            : }</a>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineNoCov">          0 : static INLINE int mi_rows_aligned_to_sb(const AV1_COMMON *cm) {</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   return ALIGN_POWER_OF_TWO(cm-&gt;mi_rows, cm-&gt;mib_size_log2);</span>
<a name="514"><span class="lineNum">     514 </span>            : }</a>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineNoCov">          0 : static INLINE int frame_is_intra_only(const AV1_COMMON *const cm) {</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   return cm-&gt;frame_type == KEY_FRAME || cm-&gt;intra_only;</span>
<a name="518"><span class="lineNum">     518 </span>            : }</a>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : static INLINE void av1_init_macroblockd(AV1_COMMON *cm, MACROBLOCKD *xd,</span>
<span class="lineNum">     521 </span>            : #if CONFIG_PVQ
<span class="lineNum">     522 </span>            :                                         tran_low_t *pvq_ref_coeff,
<span class="lineNum">     523 </span>            : #endif
<span class="lineNum">     524 </span>            : #if CONFIG_CFL
<span class="lineNum">     525 </span>            :                                         CFL_CTX *cfl,
<span class="lineNum">     526 </span>            : #endif
<span class="lineNum">     527 </span>            :                                         tran_low_t *dqcoeff) {
<span class="lineNum">     528 </span>            :   int i;
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; MAX_MB_PLANE; ++i) {</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].dqcoeff = dqcoeff;</span>
<span class="lineNum">     531 </span>            : #if CONFIG_PVQ
<span class="lineNum">     532 </span>            :     xd-&gt;plane[i].pvq_ref_coeff = pvq_ref_coeff;
<span class="lineNum">     533 </span>            : #endif
<span class="lineNum">     534 </span>            : #if CONFIG_CFL
<span class="lineNum">     535 </span>            :     xd-&gt;cfl = cfl;
<span class="lineNum">     536 </span>            :     cfl_init(cfl, cm, xd-&gt;plane[AOM_PLANE_U].subsampling_x,
<span class="lineNum">     537 </span>            :              xd-&gt;plane[AOM_PLANE_U].subsampling_y);
<span class="lineNum">     538 </span>            : #endif
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     xd-&gt;above_context[i] = cm-&gt;above_context[i];</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     if (xd-&gt;plane[i].plane_type == PLANE_TYPE_Y) {</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       memcpy(xd-&gt;plane[i].seg_dequant, cm-&gt;y_dequant, sizeof(cm-&gt;y_dequant));</span>
<span class="lineNum">     542 </span>            : #if CONFIG_AOM_QM
<span class="lineNum">     543 </span>            :       memcpy(xd-&gt;plane[i].seg_iqmatrix, cm-&gt;y_iqmatrix, sizeof(cm-&gt;y_iqmatrix));
<span class="lineNum">     544 </span>            : #endif
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            : #if CONFIG_NEW_QUANT
<span class="lineNum">     547 </span>            :       memcpy(xd-&gt;plane[i].seg_dequant_nuq, cm-&gt;y_dequant_nuq,
<span class="lineNum">     548 </span>            :              sizeof(cm-&gt;y_dequant_nuq));
<span class="lineNum">     549 </span>            : #endif
<span class="lineNum">     550 </span>            :     } else {
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       memcpy(xd-&gt;plane[i].seg_dequant, cm-&gt;uv_dequant, sizeof(cm-&gt;uv_dequant));</span>
<span class="lineNum">     552 </span>            : #if CONFIG_AOM_QM
<span class="lineNum">     553 </span>            :       memcpy(xd-&gt;plane[i].seg_iqmatrix, cm-&gt;uv_iqmatrix,
<span class="lineNum">     554 </span>            :              sizeof(cm-&gt;uv_iqmatrix));
<span class="lineNum">     555 </span>            : #endif
<span class="lineNum">     556 </span>            : #if CONFIG_NEW_QUANT
<span class="lineNum">     557 </span>            :       memcpy(xd-&gt;plane[i].seg_dequant_nuq, cm-&gt;uv_dequant_nuq,
<span class="lineNum">     558 </span>            :              sizeof(cm-&gt;uv_dequant_nuq));
<span class="lineNum">     559 </span>            : #endif
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     xd-&gt;fc = cm-&gt;fc;</span>
<span class="lineNum">     562 </span>            :   }
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   xd-&gt;above_seg_context = cm-&gt;above_seg_context;</span>
<span class="lineNum">     564 </span>            : #if CONFIG_VAR_TX
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   xd-&gt;above_txfm_context = cm-&gt;above_txfm_context;</span>
<span class="lineNum">     566 </span>            : #endif
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   xd-&gt;mi_stride = cm-&gt;mi_stride;</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   xd-&gt;error_info = &amp;cm-&gt;error;</span>
<a name="569"><span class="lineNum">     569 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 : static INLINE void set_skip_context(MACROBLOCKD *xd, int mi_row, int mi_col) {</span>
<span class="lineNum">     572 </span>            :   int i;
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   int row_offset = mi_row;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   int col_offset = mi_col;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; MAX_MB_PLANE; ++i) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     struct macroblockd_plane *const pd = &amp;xd-&gt;plane[i];</span>
<span class="lineNum">     577 </span>            : #if CONFIG_CHROMA_SUB8X8
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     if (xd-&gt;mi[0]-&gt;mbmi.sb_type &lt; BLOCK_8X8) {</span>
<span class="lineNum">     579 </span>            :       // Offset the buffer pointer
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :       if (pd-&gt;subsampling_y &amp;&amp; (mi_row &amp; 0x01)) row_offset = mi_row - 1;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       if (pd-&gt;subsampling_x &amp;&amp; (mi_col &amp; 0x01)) col_offset = mi_col - 1;</span>
<span class="lineNum">     582 </span>            :     }
<span class="lineNum">     583 </span>            : #endif
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     int above_idx = col_offset &lt;&lt; (MI_SIZE_LOG2 - tx_size_wide_log2[0]);</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :     int left_idx = (row_offset &amp; MAX_MIB_MASK)</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                    &lt;&lt; (MI_SIZE_LOG2 - tx_size_high_log2[0]);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     pd-&gt;above_context = &amp;xd-&gt;above_context[i][above_idx &gt;&gt; pd-&gt;subsampling_x];</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     pd-&gt;left_context = &amp;xd-&gt;left_context[i][left_idx &gt;&gt; pd-&gt;subsampling_y];</span>
<span class="lineNum">     589 </span>            :   }
<a name="590"><span class="lineNum">     590 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 : static INLINE int calc_mi_size(int len) {</span>
<span class="lineNum">     593 </span>            :   // len is in mi units.
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :   return len + MAX_MIB_SIZE;</span>
<a name="595"><span class="lineNum">     595 </span>            : }</a>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 : static INLINE void set_plane_n4(MACROBLOCKD *const xd, int bw, int bh) {</span>
<span class="lineNum">     598 </span>            :   int i;
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; MAX_MB_PLANE; i++) {</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].n4_w = (bw &lt;&lt; 1) &gt;&gt; xd-&gt;plane[i].subsampling_x;</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].n4_h = (bh &lt;&lt; 1) &gt;&gt; xd-&gt;plane[i].subsampling_y;</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].width = (bw * MI_SIZE) &gt;&gt; xd-&gt;plane[i].subsampling_x;</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].height = (bh * MI_SIZE) &gt;&gt; xd-&gt;plane[i].subsampling_y;</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : #if !CONFIG_CHROMA_2X2
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].width = AOMMAX(xd-&gt;plane[i].width, 4);</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     xd-&gt;plane[i].height = AOMMAX(xd-&gt;plane[i].height, 4);</span>
<span class="lineNum">     609 </span>            : #endif
<span class="lineNum">     610 </span>            :   }
<a name="611"><span class="lineNum">     611 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineNoCov">          0 : static INLINE void set_mi_row_col(MACROBLOCKD *xd, const TileInfo *const tile,</span>
<span class="lineNum">     614 </span>            :                                   int mi_row, int bh, int mi_col, int bw,
<span class="lineNum">     615 </span>            : #if CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     616 </span>            :                                   int dependent_horz_tile_flag,
<span class="lineNum">     617 </span>            : #endif  // CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     618 </span>            :                                   int mi_rows, int mi_cols) {
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   xd-&gt;mb_to_top_edge = -((mi_row * MI_SIZE) * 8);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   xd-&gt;mb_to_bottom_edge = ((mi_rows - bh - mi_row) * MI_SIZE) * 8;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :   xd-&gt;mb_to_left_edge = -((mi_col * MI_SIZE) * 8);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   xd-&gt;mb_to_right_edge = ((mi_cols - bw - mi_col) * MI_SIZE) * 8;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : #if CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     625 </span>            :   if (dependent_horz_tile_flag) {
<span class="lineNum">     626 </span>            : #if CONFIG_TILE_GROUPS
<span class="lineNum">     627 </span>            :     xd-&gt;up_available = (mi_row &gt; tile-&gt;mi_row_start) || !tile-&gt;tg_horz_boundary;
<span class="lineNum">     628 </span>            : #else
<span class="lineNum">     629 </span>            :     xd-&gt;up_available = (mi_row &gt; 0);
<span class="lineNum">     630 </span>            : #endif  // CONFIG_TILE_GROUPS
<span class="lineNum">     631 </span>            :   } else {
<span class="lineNum">     632 </span>            : #endif  // CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     633 </span>            :     // Are edges available for intra prediction?
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     xd-&gt;up_available = (mi_row &gt; tile-&gt;mi_row_start);</span>
<span class="lineNum">     635 </span>            : #if CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     636 </span>            :   }
<span class="lineNum">     637 </span>            : #endif  // CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   xd-&gt;left_available = (mi_col &gt; tile-&gt;mi_col_start);</span>
<span class="lineNum">     640 </span>            : #if CONFIG_CHROMA_SUB8X8
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   xd-&gt;chroma_up_available = xd-&gt;up_available;</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   xd-&gt;chroma_left_available = xd-&gt;left_available;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   if (xd-&gt;plane[1].subsampling_x &amp;&amp; bw &lt; mi_size_wide[BLOCK_8X8])</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     xd-&gt;chroma_left_available = (mi_col - 1) &gt; tile-&gt;mi_col_start;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :   if (xd-&gt;plane[1].subsampling_y &amp;&amp; bh &lt; mi_size_high[BLOCK_8X8])</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     xd-&gt;chroma_up_available = (mi_row - 1) &gt; tile-&gt;mi_row_start;</span>
<span class="lineNum">     647 </span>            : #endif
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   if (xd-&gt;up_available) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     xd-&gt;above_mi = xd-&gt;mi[-xd-&gt;mi_stride];</span>
<span class="lineNum">     650 </span>            :     // above_mi may be NULL in encoder's first pass.
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     xd-&gt;above_mbmi = xd-&gt;above_mi ? &amp;xd-&gt;above_mi-&gt;mbmi : NULL;</span>
<span class="lineNum">     652 </span>            :   } else {
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     xd-&gt;above_mi = NULL;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     xd-&gt;above_mbmi = NULL;</span>
<span class="lineNum">     655 </span>            :   }
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   if (xd-&gt;left_available) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     xd-&gt;left_mi = xd-&gt;mi[-1];</span>
<span class="lineNum">     659 </span>            :     // left_mi may be NULL in encoder's first pass.
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     xd-&gt;left_mbmi = xd-&gt;left_mi ? &amp;xd-&gt;left_mi-&gt;mbmi : NULL;</span>
<span class="lineNum">     661 </span>            :   } else {
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     xd-&gt;left_mi = NULL;</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     xd-&gt;left_mbmi = NULL;</span>
<span class="lineNum">     664 </span>            :   }
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :   xd-&gt;n8_h = bh;</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :   xd-&gt;n8_w = bw;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   xd-&gt;is_sec_rect = 0;</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   if (xd-&gt;n8_w &lt; xd-&gt;n8_h)</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     if (mi_col &amp; (xd-&gt;n8_h - 1)) xd-&gt;is_sec_rect = 1;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   if (xd-&gt;n8_w &gt; xd-&gt;n8_h)</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     if (mi_row &amp; (xd-&gt;n8_w - 1)) xd-&gt;is_sec_rect = 1;</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : static INLINE const aom_prob *get_y_mode_probs(const AV1_COMMON *cm,
<span class="lineNum">     677 </span>            :                                                const MODE_INFO *mi,
<span class="lineNum">     678 </span>            :                                                const MODE_INFO *above_mi,
<span class="lineNum">     679 </span>            :                                                const MODE_INFO *left_mi,
<span class="lineNum">     680 </span>            :                                                int block) {
<span class="lineNum">     681 </span>            :   const PREDICTION_MODE above = av1_above_block_mode(mi, above_mi, block);
<span class="lineNum">     682 </span>            :   const PREDICTION_MODE left = av1_left_block_mode(mi, left_mi, block);
<span class="lineNum">     683 </span>            :   return cm-&gt;kf_y_prob[above][left];
<a name="684"><span class="lineNum">     684 </span>            : }</a>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 : static INLINE aom_cdf_prob *get_y_mode_cdf(FRAME_CONTEXT *tile_ctx,</span>
<span class="lineNum">     687 </span>            :                                            const MODE_INFO *mi,
<span class="lineNum">     688 </span>            :                                            const MODE_INFO *above_mi,
<span class="lineNum">     689 </span>            :                                            const MODE_INFO *left_mi,
<span class="lineNum">     690 </span>            :                                            int block) {
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   const PREDICTION_MODE above = av1_above_block_mode(mi, above_mi, block);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   const PREDICTION_MODE left = av1_left_block_mode(mi, left_mi, block);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   return tile_ctx-&gt;kf_y_cdf[above][left];</span>
<a name="694"><span class="lineNum">     694 </span>            : }</a>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : static INLINE void update_partition_context(MACROBLOCKD *xd, int mi_row,</span>
<span class="lineNum">     697 </span>            :                                             int mi_col, BLOCK_SIZE subsize,
<span class="lineNum">     698 </span>            :                                             BLOCK_SIZE bsize) {
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   PARTITION_CONTEXT *const above_ctx = xd-&gt;above_seg_context + mi_col;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   PARTITION_CONTEXT *const left_ctx =</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       xd-&gt;left_seg_context + (mi_row &amp; MAX_MIB_MASK);</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : #if CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">     704 </span>            :   const int bw = mi_size_wide[bsize];
<span class="lineNum">     705 </span>            :   const int bh = mi_size_high[bsize];
<span class="lineNum">     706 </span>            :   memset(above_ctx, partition_context_lookup[subsize].above, bw);
<span class="lineNum">     707 </span>            :   memset(left_ctx, partition_context_lookup[subsize].left, bh);
<span class="lineNum">     708 </span>            : #else
<span class="lineNum">     709 </span>            :   // num_4x4_blocks_wide_lookup[bsize] / 2
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   const int bs = mi_size_wide[bsize];</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            :   // update the partition context at the end notes. set partition bits
<span class="lineNum">     713 </span>            :   // of block sizes larger than the current one to be one, and partition
<span class="lineNum">     714 </span>            :   // bits of smaller block sizes to be zero.
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   memset(above_ctx, partition_context_lookup[subsize].above, bs);</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   memset(left_ctx, partition_context_lookup[subsize].left, bs);</span>
<span class="lineNum">     717 </span>            : #endif  // CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">     718 </span><span class="lineNoCov">          0 : }</span>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<span class="lineNum">     720 </span>            : #if CONFIG_CB4X4
<span class="lineNum">     721 </span><span class="lineNoCov">          0 : static INLINE int is_chroma_reference(int mi_row, int mi_col, BLOCK_SIZE bsize,</span>
<span class="lineNum">     722 </span>            :                                       int subsampling_x, int subsampling_y) {
<span class="lineNum">     723 </span>            : #if CONFIG_CHROMA_2X2
<span class="lineNum">     724 </span>            :   return 1;
<span class="lineNum">     725 </span>            : #endif
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : #if CONFIG_CHROMA_SUB8X8
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   const int bw = mi_size_wide[bsize];</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   const int bh = mi_size_high[bsize];</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   int ref_pos = ((mi_row &amp; 0x01) || !(bh &amp; 0x01) || !subsampling_y) &amp;&amp;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                 ((mi_col &amp; 0x01) || !(bw &amp; 0x01) || !subsampling_x);</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :   return ref_pos;</span>
<span class="lineNum">     735 </span>            : #else
<span class="lineNum">     736 </span>            :   int ref_pos = !(((mi_row &amp; 0x01) &amp;&amp; subsampling_y) ||
<span class="lineNum">     737 </span>            :                   ((mi_col &amp; 0x01) &amp;&amp; subsampling_x));
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   if (bsize &gt;= BLOCK_8X8) ref_pos = 1;
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :   return ref_pos;
<span class="lineNum">     742 </span>            : #endif
<a name="743"><span class="lineNum">     743 </span>            : }</a>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 : static INLINE BLOCK_SIZE scale_chroma_bsize(BLOCK_SIZE bsize, int subsampling_x,</span>
<span class="lineNum">     746 </span>            :                                             int subsampling_y) {
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   BLOCK_SIZE bs = bsize;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   if (bs &lt; BLOCK_8X8) {</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     if (subsampling_x == 1 &amp;&amp; subsampling_y == 1)</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       bs = BLOCK_8X8;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     else if (subsampling_x == 1)</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       bs = BLOCK_8X4;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     else if (subsampling_y == 1)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :       bs = BLOCK_4X8;</span>
<span class="lineNum">     756 </span>            :   }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   return bs;</span>
<span class="lineNum">     759 </span>            : }
<span class="lineNum">     760 </span>            : #endif
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            : #if CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">     763 </span>            : static INLINE void update_ext_partition_context(MACROBLOCKD *xd, int mi_row,
<span class="lineNum">     764 </span>            :                                                 int mi_col, BLOCK_SIZE subsize,
<span class="lineNum">     765 </span>            :                                                 BLOCK_SIZE bsize,
<span class="lineNum">     766 </span>            :                                                 PARTITION_TYPE partition) {
<span class="lineNum">     767 </span>            :   if (bsize &gt;= BLOCK_8X8) {
<span class="lineNum">     768 </span>            :     const int hbs = mi_size_wide[bsize] / 2;
<span class="lineNum">     769 </span>            :     BLOCK_SIZE bsize2 = get_subsize(bsize, PARTITION_SPLIT);
<span class="lineNum">     770 </span>            :     switch (partition) {
<span class="lineNum">     771 </span>            :       case PARTITION_SPLIT:
<span class="lineNum">     772 </span>            :         if (bsize != BLOCK_8X8) break;
<span class="lineNum">     773 </span>            :       case PARTITION_NONE:
<span class="lineNum">     774 </span>            :       case PARTITION_HORZ:
<span class="lineNum">     775 </span>            :       case PARTITION_VERT:
<span class="lineNum">     776 </span>            :         update_partition_context(xd, mi_row, mi_col, subsize, bsize);
<span class="lineNum">     777 </span>            :         break;
<span class="lineNum">     778 </span>            :       case PARTITION_HORZ_A:
<span class="lineNum">     779 </span>            :         update_partition_context(xd, mi_row, mi_col, bsize2, subsize);
<span class="lineNum">     780 </span>            :         update_partition_context(xd, mi_row + hbs, mi_col, subsize, subsize);
<span class="lineNum">     781 </span>            :         break;
<span class="lineNum">     782 </span>            :       case PARTITION_HORZ_B:
<span class="lineNum">     783 </span>            :         update_partition_context(xd, mi_row, mi_col, subsize, subsize);
<span class="lineNum">     784 </span>            :         update_partition_context(xd, mi_row + hbs, mi_col, bsize2, subsize);
<span class="lineNum">     785 </span>            :         break;
<span class="lineNum">     786 </span>            :       case PARTITION_VERT_A:
<span class="lineNum">     787 </span>            :         update_partition_context(xd, mi_row, mi_col, bsize2, subsize);
<span class="lineNum">     788 </span>            :         update_partition_context(xd, mi_row, mi_col + hbs, subsize, subsize);
<span class="lineNum">     789 </span>            :         break;
<span class="lineNum">     790 </span>            :       case PARTITION_VERT_B:
<span class="lineNum">     791 </span>            :         update_partition_context(xd, mi_row, mi_col, subsize, subsize);
<span class="lineNum">     792 </span>            :         update_partition_context(xd, mi_row, mi_col + hbs, bsize2, subsize);
<span class="lineNum">     793 </span>            :         break;
<span class="lineNum">     794 </span>            :       default: assert(0 &amp;&amp; &quot;Invalid partition type&quot;);
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            :   }
<span class="lineNum">     797 </span>            : }
<a name="798"><span class="lineNum">     798 </span>            : #endif  // CONFIG_EXT_PARTITION_TYPES</a>
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineNoCov">          0 : static INLINE int partition_plane_context(const MACROBLOCKD *xd, int mi_row,</span>
<span class="lineNum">     801 </span>            :                                           int mi_col,
<span class="lineNum">     802 </span>            : #if CONFIG_UNPOISON_PARTITION_CTX
<span class="lineNum">     803 </span>            :                                           int has_rows, int has_cols,
<span class="lineNum">     804 </span>            : #endif
<span class="lineNum">     805 </span>            :                                           BLOCK_SIZE bsize) {
<span class="lineNum">     806 </span>            : #if CONFIG_UNPOISON_PARTITION_CTX
<span class="lineNum">     807 </span>            :   const PARTITION_CONTEXT *above_ctx = xd-&gt;above_seg_context + mi_col;
<span class="lineNum">     808 </span>            :   const PARTITION_CONTEXT *left_ctx =
<span class="lineNum">     809 </span>            :       xd-&gt;left_seg_context + (mi_row &amp; MAX_MIB_MASK);
<span class="lineNum">     810 </span>            :   // Minimum partition point is 8x8. Offset the bsl accordingly.
<span class="lineNum">     811 </span>            :   const int bsl = mi_width_log2_lookup[bsize] - mi_width_log2_lookup[BLOCK_8X8];
<span class="lineNum">     812 </span>            :   int above = (*above_ctx &gt;&gt; bsl) &amp; 1, left = (*left_ctx &gt;&gt; bsl) &amp; 1;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   assert(b_width_log2_lookup[bsize] == b_height_log2_lookup[bsize]);
<span class="lineNum">     815 </span>            :   assert(bsl &gt;= 0);
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   if (has_rows &amp;&amp; has_cols)
<span class="lineNum">     818 </span>            :     return (left * 2 + above) + bsl * PARTITION_PLOFFSET;
<span class="lineNum">     819 </span>            :   else if (has_rows &amp;&amp; !has_cols)
<span class="lineNum">     820 </span>            :     return PARTITION_CONTEXTS_PRIMARY + bsl;
<span class="lineNum">     821 </span>            :   else if (!has_rows &amp;&amp; has_cols)
<span class="lineNum">     822 </span>            :     return PARTITION_CONTEXTS_PRIMARY + PARTITION_BLOCK_SIZES + bsl;
<span class="lineNum">     823 </span>            :   else
<span class="lineNum">     824 </span>            :     return PARTITION_CONTEXTS;  // Bogus context, forced SPLIT
<span class="lineNum">     825 </span>            : #else
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   const PARTITION_CONTEXT *above_ctx = xd-&gt;above_seg_context + mi_col;</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   const PARTITION_CONTEXT *left_ctx =</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       xd-&gt;left_seg_context + (mi_row &amp; MAX_MIB_MASK);</span>
<span class="lineNum">     829 </span>            :   // Minimum partition point is 8x8. Offset the bsl accordingly.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   const int bsl = mi_width_log2_lookup[bsize] - mi_width_log2_lookup[BLOCK_8X8];</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   int above = (*above_ctx &gt;&gt; bsl) &amp; 1, left = (*left_ctx &gt;&gt; bsl) &amp; 1;</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   assert(b_width_log2_lookup[bsize] == b_height_log2_lookup[bsize]);</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   assert(bsl &gt;= 0);</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   return (left * 2 + above) + bsl * PARTITION_PLOFFSET;</span>
<span class="lineNum">     837 </span>            : #endif
<a name="838"><span class="lineNum">     838 </span>            : }</a>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineNoCov">          0 : static INLINE int max_block_wide(const MACROBLOCKD *xd, BLOCK_SIZE bsize,</span>
<span class="lineNum">     841 </span>            :                                  int plane) {
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   int max_blocks_wide = block_size_wide[bsize];</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   const struct macroblockd_plane *const pd = &amp;xd-&gt;plane[plane];</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :   if (xd-&gt;mb_to_right_edge &lt; 0)</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     max_blocks_wide += xd-&gt;mb_to_right_edge &gt;&gt; (3 + pd-&gt;subsampling_x);</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :   // Scale the width in the transform block unit.
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   return max_blocks_wide &gt;&gt; tx_size_wide_log2[0];</span>
<a name="850"><span class="lineNum">     850 </span>            : }</a>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineNoCov">          0 : static INLINE int max_block_high(const MACROBLOCKD *xd, BLOCK_SIZE bsize,</span>
<span class="lineNum">     853 </span>            :                                  int plane) {
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :   int max_blocks_high = block_size_high[bsize];</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   const struct macroblockd_plane *const pd = &amp;xd-&gt;plane[plane];</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   if (xd-&gt;mb_to_bottom_edge &lt; 0)</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     max_blocks_high += xd-&gt;mb_to_bottom_edge &gt;&gt; (3 + pd-&gt;subsampling_y);</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   // Scale the width in the transform block unit.
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   return max_blocks_high &gt;&gt; tx_size_wide_log2[0];</span>
<a name="862"><span class="lineNum">     862 </span>            : }</a>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : static INLINE void av1_zero_above_context(AV1_COMMON *const cm,</span>
<span class="lineNum">     865 </span>            :                                           int mi_col_start, int mi_col_end) {
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :   const int width = mi_col_end - mi_col_start;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :   const int aligned_width = ALIGN_POWER_OF_TWO(width, cm-&gt;mib_size_log2);</span>
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   const int offset_y = mi_col_start &lt;&lt; (MI_SIZE_LOG2 - tx_size_wide_log2[0]);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   const int width_y = aligned_width &lt;&lt; (MI_SIZE_LOG2 - tx_size_wide_log2[0]);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   const int offset_uv = offset_y &gt;&gt; cm-&gt;subsampling_x;</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   const int width_uv = width_y &gt;&gt; cm-&gt;subsampling_x;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :   av1_zero_array(cm-&gt;above_context[0] + offset_y, width_y);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :   av1_zero_array(cm-&gt;above_context[1] + offset_uv, width_uv);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   av1_zero_array(cm-&gt;above_context[2] + offset_uv, width_uv);</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   av1_zero_array(cm-&gt;above_seg_context + mi_col_start, aligned_width);</span>
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            : #if CONFIG_VAR_TX
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   av1_zero_array(cm-&gt;above_txfm_context + (mi_col_start &lt;&lt; TX_UNIT_WIDE_LOG2),</span>
<span class="lineNum">     882 </span>            :                  aligned_width &lt;&lt; TX_UNIT_WIDE_LOG2);
<span class="lineNum">     883 </span>            : #endif  // CONFIG_VAR_TX
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineNoCov">          0 : static INLINE void av1_zero_left_context(MACROBLOCKD *const xd) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   av1_zero(xd-&gt;left_context);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   av1_zero(xd-&gt;left_seg_context);</span>
<span class="lineNum">     889 </span>            : #if CONFIG_VAR_TX
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :   av1_zero(xd-&gt;left_txfm_context_buffer);</span>
<span class="lineNum">     891 </span>            : #endif
<span class="lineNum">     892 </span><span class="lineNoCov">          0 : }</span>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<span class="lineNum">     894 </span>            : #if CONFIG_VAR_TX
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : static INLINE TX_SIZE get_min_tx_size(TX_SIZE tx_size) {</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   assert(tx_size &lt; TX_SIZES_ALL);</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   return txsize_sqr_map[tx_size];</span>
<a name="898"><span class="lineNum">     898 </span>            : }</a>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineNoCov">          0 : static INLINE void set_txfm_ctx(TXFM_CONTEXT *txfm_ctx, uint8_t txs, int len) {</span>
<span class="lineNum">     901 </span>            :   int i;
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; len; ++i) txfm_ctx[i] = txs;</span>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 : static INLINE void set_txfm_ctxs(TX_SIZE tx_size, int n8_w, int n8_h, int skip,</span>
<span class="lineNum">     906 </span>            :                                  const MACROBLOCKD *xd) {
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :   uint8_t bw = tx_size_wide[tx_size];</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   uint8_t bh = tx_size_high[tx_size];</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   if (skip) {</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     bw = n8_w * MI_SIZE;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :     bh = n8_h * MI_SIZE;</span>
<span class="lineNum">     913 </span>            :   }
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   set_txfm_ctx(xd-&gt;above_txfm_context, bw, n8_w &lt;&lt; TX_UNIT_WIDE_LOG2);</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   set_txfm_ctx(xd-&gt;left_txfm_context, bh, n8_h &lt;&lt; TX_UNIT_HIGH_LOG2);</span>
<a name="917"><span class="lineNum">     917 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineNoCov">          0 : static INLINE void txfm_partition_update(TXFM_CONTEXT *above_ctx,</span>
<span class="lineNum">     920 </span>            :                                          TXFM_CONTEXT *left_ctx,
<span class="lineNum">     921 </span>            :                                          TX_SIZE tx_size, TX_SIZE txb_size) {
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   BLOCK_SIZE bsize = txsize_to_bsize[txb_size];</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   int bh = mi_size_high[bsize] &lt;&lt; TX_UNIT_HIGH_LOG2;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :   int bw = mi_size_wide[bsize] &lt;&lt; TX_UNIT_WIDE_LOG2;</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   uint8_t txw = tx_size_wide[tx_size];</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :   uint8_t txh = tx_size_high[tx_size];</span>
<span class="lineNum">     927 </span>            :   int i;
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; bh; ++i) left_ctx[i] = txh;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; bw; ++i) above_ctx[i] = txw;</span>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineNoCov">          0 : static INLINE TX_SIZE get_sqr_tx_size(int tx_dim) {</span>
<span class="lineNum">     933 </span>            :   TX_SIZE tx_size;
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   switch (tx_dim) {</span>
<span class="lineNum">     935 </span>            : #if CONFIG_EXT_PARTITION
<span class="lineNum">     936 </span>            :     case 128:
<span class="lineNum">     937 </span>            : #endif
<span class="lineNum">     938 </span>            :     case 64:
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     case 32: tx_size = TX_32X32; break;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     case 16: tx_size = TX_16X16; break;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     case 8: tx_size = TX_8X8; break;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     default: tx_size = TX_4X4;</span>
<span class="lineNum">     943 </span>            :   }
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :   return tx_size;</span>
<a name="945"><span class="lineNum">     945 </span>            : }</a>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 : static INLINE int txfm_partition_context(TXFM_CONTEXT *above_ctx,</span>
<span class="lineNum">     948 </span>            :                                          TXFM_CONTEXT *left_ctx,
<span class="lineNum">     949 </span>            :                                          BLOCK_SIZE bsize, TX_SIZE tx_size) {
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   const uint8_t txw = tx_size_wide[tx_size];</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :   const uint8_t txh = tx_size_high[tx_size];</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   const int above = *above_ctx &lt; txw;</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   const int left = *left_ctx &lt; txh;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   int category = TXFM_PARTITION_CONTEXTS - 1;</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :   // dummy return, not used by others.
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :   if (tx_size &lt;= TX_4X4) return 0;</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :   TX_SIZE max_tx_size =</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       get_sqr_tx_size(AOMMAX(block_size_wide[bsize], block_size_high[bsize]));</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   if (max_tx_size &gt;= TX_8X8) {</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     category = (tx_size != max_tx_size &amp;&amp; max_tx_size &gt; TX_8X8) +</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                (TX_SIZES - 1 - max_tx_size) * 2;</span>
<span class="lineNum">     965 </span>            :   }
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   if (category == TXFM_PARTITION_CONTEXTS - 1) return category;</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :   return category * 3 + above + left;</span>
<span class="lineNum">     968 </span>            : }
<a name="969"><span class="lineNum">     969 </span>            : #endif</a>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineNoCov">          0 : static INLINE PARTITION_TYPE get_partition(const AV1_COMMON *const cm,</span>
<span class="lineNum">     972 </span>            :                                            int mi_row, int mi_col,
<span class="lineNum">     973 </span>            :                                            BLOCK_SIZE bsize) {
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   if (mi_row &gt;= cm-&gt;mi_rows || mi_col &gt;= cm-&gt;mi_cols) {</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     return PARTITION_INVALID;</span>
<span class="lineNum">     976 </span>            :   } else {
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     const int offset = mi_row * cm-&gt;mi_stride + mi_col;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     MODE_INFO **mi = cm-&gt;mi_grid_visible + offset;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     const MB_MODE_INFO *const mbmi = &amp;mi[0]-&gt;mbmi;</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :     const int bsl = b_width_log2_lookup[bsize];</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :     const PARTITION_TYPE partition = partition_lookup[bsl][mbmi-&gt;sb_type];</span>
<span class="lineNum">     982 </span>            : #if !CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     return partition;</span>
<span class="lineNum">     984 </span>            : #else
<span class="lineNum">     985 </span>            :     const int hbs = mi_size_wide[bsize] / 2;
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            :     assert(cm-&gt;mi_grid_visible[offset] == &amp;cm-&gt;mi[offset]);
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :     if (partition != PARTITION_NONE &amp;&amp; bsize &gt; BLOCK_8X8 &amp;&amp;
<span class="lineNum">     990 </span>            :         mi_row + hbs &lt; cm-&gt;mi_rows &amp;&amp; mi_col + hbs &lt; cm-&gt;mi_cols) {
<span class="lineNum">     991 </span>            :       const BLOCK_SIZE h = get_subsize(bsize, PARTITION_HORZ_A);
<span class="lineNum">     992 </span>            :       const BLOCK_SIZE v = get_subsize(bsize, PARTITION_VERT_A);
<span class="lineNum">     993 </span>            :       const MB_MODE_INFO *const mbmi_right = &amp;mi[hbs]-&gt;mbmi;
<span class="lineNum">     994 </span>            :       const MB_MODE_INFO *const mbmi_below = &amp;mi[hbs * cm-&gt;mi_stride]-&gt;mbmi;
<span class="lineNum">     995 </span>            :       if (mbmi-&gt;sb_type == h) {
<span class="lineNum">     996 </span>            :         return mbmi_below-&gt;sb_type == h ? PARTITION_HORZ : PARTITION_HORZ_B;
<span class="lineNum">     997 </span>            :       } else if (mbmi-&gt;sb_type == v) {
<span class="lineNum">     998 </span>            :         return mbmi_right-&gt;sb_type == v ? PARTITION_VERT : PARTITION_VERT_B;
<span class="lineNum">     999 </span>            :       } else if (mbmi_below-&gt;sb_type == h) {
<span class="lineNum">    1000 </span>            :         return PARTITION_HORZ_A;
<span class="lineNum">    1001 </span>            :       } else if (mbmi_right-&gt;sb_type == v) {
<span class="lineNum">    1002 </span>            :         return PARTITION_VERT_A;
<span class="lineNum">    1003 </span>            :       } else {
<span class="lineNum">    1004 </span>            :         return PARTITION_SPLIT;
<span class="lineNum">    1005 </span>            :       }
<span class="lineNum">    1006 </span>            :     }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :     return partition;
<span class="lineNum">    1009 </span>            : #endif  // !CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">    1010 </span>            :   }
<a name="1011"><span class="lineNum">    1011 </span>            : }</a>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 : static INLINE void set_sb_size(AV1_COMMON *const cm, BLOCK_SIZE sb_size) {</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   cm-&gt;sb_size = sb_size;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   cm-&gt;mib_size = mi_size_wide[cm-&gt;sb_size];</span>
<span class="lineNum">    1016 </span>            : #if CONFIG_CB4X4
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   cm-&gt;mib_size_log2 = b_width_log2_lookup[cm-&gt;sb_size];</span>
<span class="lineNum">    1018 </span>            : #else
<span class="lineNum">    1019 </span>            :   cm-&gt;mib_size_log2 = mi_width_log2_lookup[cm-&gt;sb_size];
<span class="lineNum">    1020 </span>            : #endif
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            : #ifdef __cplusplus
<span class="lineNum">    1024 </span>            : }  // extern &quot;C&quot;
<span class="lineNum">    1025 </span>            : #endif
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            : #endif  // AV1_COMMON_ONYXC_INT_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/encoder/encoder.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/encoder</a> - encoder.h<span style="font-size: 80%;"> (source / <a href="encoder.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">67</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #ifndef AV1_ENCODER_ENCODER_H_
<span class="lineNum">      13 </span>            : #define AV1_ENCODER_ENCODER_H_
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;./aom_config.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;aom/aomcx.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;av1/common/alloccommon.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;av1/common/entropymode.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;av1/common/thread_common.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;av1/common/onyxc_int.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;av1/encoder/aq_cyclicrefresh.h&quot;
<span class="lineNum">      25 </span>            : #if CONFIG_ANS
<span class="lineNum">      26 </span>            : #include &quot;aom_dsp/ans.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;aom_dsp/buf_ans.h&quot;
<span class="lineNum">      28 </span>            : #endif
<span class="lineNum">      29 </span>            : #include &quot;av1/encoder/av1_quantize.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;av1/encoder/context_tree.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;av1/encoder/encodemb.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;av1/encoder/firstpass.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;av1/encoder/lookahead.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;av1/encoder/mbgraph.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;av1/encoder/mcomp.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;av1/encoder/ratectrl.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;av1/encoder/rd.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;av1/encoder/speed_features.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;av1/encoder/tokenize.h&quot;
<span class="lineNum">      40 </span>            : #if CONFIG_XIPHRC
<span class="lineNum">      41 </span>            : #include &quot;av1/encoder/ratectrl_xiph.h&quot;
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #if CONFIG_INTERNAL_STATS
<span class="lineNum">      45 </span>            : #include &quot;aom_dsp/ssim.h&quot;
<span class="lineNum">      46 </span>            : #endif
<span class="lineNum">      47 </span>            : #include &quot;aom_dsp/variance.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;aom/internal/aom_codec_internal.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;aom_util/aom_thread.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #ifdef __cplusplus
<span class="lineNum">      52 </span>            : extern &quot;C&quot; {
<span class="lineNum">      53 </span>            : #endif
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : typedef struct {
<span class="lineNum">      56 </span>            :   int nmv_vec_cost[NMV_CONTEXTS][MV_JOINTS];
<span class="lineNum">      57 </span>            :   int nmv_costs[NMV_CONTEXTS][2][MV_VALS];
<span class="lineNum">      58 </span>            :   int nmv_costs_hp[NMV_CONTEXTS][2][MV_VALS];
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :   // 0 = Intra, Last, GF, ARF
<span class="lineNum">      61 </span>            :   signed char last_ref_lf_deltas[TOTAL_REFS_PER_FRAME];
<span class="lineNum">      62 </span>            :   // 0 = ZERO_MV, MV
<span class="lineNum">      63 </span>            :   signed char last_mode_lf_deltas[MAX_MODE_LF_DELTAS];
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :   FRAME_CONTEXT fc;
<span class="lineNum">      66 </span>            : } CODING_CONTEXT;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : typedef enum {
<span class="lineNum">      69 </span>            :   // regular inter frame
<span class="lineNum">      70 </span>            :   REGULAR_FRAME = 0,
<span class="lineNum">      71 </span>            :   // alternate reference frame
<span class="lineNum">      72 </span>            :   ARF_FRAME = 1,
<span class="lineNum">      73 </span>            :   // overlay frame
<span class="lineNum">      74 </span>            :   OVERLAY_FRAME = 2,
<span class="lineNum">      75 </span>            :   // golden frame
<span class="lineNum">      76 </span>            :   GLD_FRAME = 3,
<span class="lineNum">      77 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">      78 </span>            :   // backward reference frame
<span class="lineNum">      79 </span>            :   BRF_FRAME = 4,
<span class="lineNum">      80 </span>            :   // extra alternate reference frame
<span class="lineNum">      81 </span>            :   EXT_ARF_FRAME = 5
<span class="lineNum">      82 </span>            : #endif
<span class="lineNum">      83 </span>            : } FRAME_CONTEXT_INDEX;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : typedef enum {
<span class="lineNum">      86 </span>            :   NORMAL = 0,
<span class="lineNum">      87 </span>            :   FOURFIVE = 1,
<span class="lineNum">      88 </span>            :   THREEFIVE = 2,
<span class="lineNum">      89 </span>            :   ONETWO = 3
<span class="lineNum">      90 </span>            : } AOM_SCALING;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : typedef enum {
<span class="lineNum">      93 </span>            :   // Good Quality Fast Encoding. The encoder balances quality with the amount of
<span class="lineNum">      94 </span>            :   // time it takes to encode the output. Speed setting controls how fast.
<span class="lineNum">      95 </span>            :   GOOD
<span class="lineNum">      96 </span>            : } MODE;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : typedef enum {
<span class="lineNum">      99 </span>            :   FRAMEFLAGS_KEY = 1 &lt;&lt; 0,
<span class="lineNum">     100 </span>            :   FRAMEFLAGS_GOLDEN = 1 &lt;&lt; 1,
<span class="lineNum">     101 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     102 </span>            :   FRAMEFLAGS_BWDREF = 1 &lt;&lt; 2,
<span class="lineNum">     103 </span>            :   FRAMEFLAGS_ALTREF = 1 &lt;&lt; 3,
<span class="lineNum">     104 </span>            : #else
<span class="lineNum">     105 </span>            :   FRAMEFLAGS_ALTREF = 1 &lt;&lt; 2,
<span class="lineNum">     106 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     107 </span>            : } FRAMETYPE_FLAGS;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : typedef enum {
<span class="lineNum">     110 </span>            :   NO_AQ = 0,
<span class="lineNum">     111 </span>            :   VARIANCE_AQ = 1,
<span class="lineNum">     112 </span>            :   COMPLEXITY_AQ = 2,
<span class="lineNum">     113 </span>            :   CYCLIC_REFRESH_AQ = 3,
<span class="lineNum">     114 </span>            : #if CONFIG_DELTA_Q &amp;&amp; !CONFIG_EXT_DELTA_Q
<span class="lineNum">     115 </span>            :   DELTA_AQ = 4,
<span class="lineNum">     116 </span>            : #endif
<span class="lineNum">     117 </span>            :   AQ_MODE_COUNT  // This should always be the last member of the enum
<span class="lineNum">     118 </span>            : } AQ_MODE;
<span class="lineNum">     119 </span>            : #if CONFIG_EXT_DELTA_Q
<span class="lineNum">     120 </span>            : typedef enum {
<span class="lineNum">     121 </span>            :   NO_DELTA_Q = 0,
<span class="lineNum">     122 </span>            :   DELTA_Q_ONLY = 1,
<span class="lineNum">     123 </span>            :   DELTA_Q_LF = 2,
<span class="lineNum">     124 </span>            :   DELTAQ_MODE_COUNT  // This should always be the last member of the enum
<span class="lineNum">     125 </span>            : } DELTAQ_MODE;
<span class="lineNum">     126 </span>            : #endif
<span class="lineNum">     127 </span>            : typedef enum {
<span class="lineNum">     128 </span>            :   RESIZE_NONE = 0,    // No frame resizing allowed.
<span class="lineNum">     129 </span>            :   RESIZE_FIXED = 1,   // All frames are coded at the specified dimension.
<span class="lineNum">     130 </span>            :   RESIZE_DYNAMIC = 2  // Coded size of each frame is determined by the codec.
<span class="lineNum">     131 </span>            : } RESIZE_TYPE;
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : typedef struct AV1EncoderConfig {
<span class="lineNum">     134 </span>            :   BITSTREAM_PROFILE profile;
<span class="lineNum">     135 </span>            :   aom_bit_depth_t bit_depth;     // Codec bit-depth.
<span class="lineNum">     136 </span>            :   int width;                     // width of data passed to the compressor
<span class="lineNum">     137 </span>            :   int height;                    // height of data passed to the compressor
<span class="lineNum">     138 </span>            :   unsigned int input_bit_depth;  // Input bit depth.
<span class="lineNum">     139 </span>            :   double init_framerate;         // set to passed in framerate
<span class="lineNum">     140 </span>            :   int64_t target_bandwidth;      // bandwidth to be used in bits per second
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :   int noise_sensitivity;  // pre processing blur: recommendation 0
<span class="lineNum">     143 </span>            :   int sharpness;          // sharpening output: recommendation 0:
<span class="lineNum">     144 </span>            :   int speed;
<span class="lineNum">     145 </span>            :   // maximum allowed bitrate for any intra frame in % of bitrate target.
<span class="lineNum">     146 </span>            :   unsigned int rc_max_intra_bitrate_pct;
<span class="lineNum">     147 </span>            :   // maximum allowed bitrate for any inter frame in % of bitrate target.
<span class="lineNum">     148 </span>            :   unsigned int rc_max_inter_bitrate_pct;
<span class="lineNum">     149 </span>            :   // percent of rate boost for golden frame in CBR mode.
<span class="lineNum">     150 </span>            :   unsigned int gf_cbr_boost_pct;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   MODE mode;
<span class="lineNum">     153 </span>            :   int pass;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :   // Key Framing Operations
<span class="lineNum">     156 </span>            :   int auto_key;  // autodetect cut scenes and set the keyframes
<span class="lineNum">     157 </span>            :   int key_freq;  // maximum distance to key frame.
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :   int lag_in_frames;  // how many frames lag before we start encoding
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   // ----------------------------------------------------------------
<span class="lineNum">     162 </span>            :   // DATARATE CONTROL OPTIONS
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   // vbr, cbr, constrained quality or constant quality
<span class="lineNum">     165 </span>            :   enum aom_rc_mode rc_mode;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :   // buffer targeting aggressiveness
<span class="lineNum">     168 </span>            :   int under_shoot_pct;
<span class="lineNum">     169 </span>            :   int over_shoot_pct;
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :   // buffering parameters
<span class="lineNum">     172 </span>            :   int64_t starting_buffer_level_ms;
<span class="lineNum">     173 </span>            :   int64_t optimal_buffer_level_ms;
<span class="lineNum">     174 </span>            :   int64_t maximum_buffer_size_ms;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :   // Frame drop threshold.
<span class="lineNum">     177 </span>            :   int drop_frames_water_mark;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   // controlling quality
<span class="lineNum">     180 </span>            :   int fixed_q;
<span class="lineNum">     181 </span>            :   int worst_allowed_q;
<span class="lineNum">     182 </span>            :   int best_allowed_q;
<span class="lineNum">     183 </span>            :   int cq_level;
<span class="lineNum">     184 </span>            :   AQ_MODE aq_mode;  // Adaptive Quantization mode
<span class="lineNum">     185 </span>            : #if CONFIG_EXT_DELTA_Q
<span class="lineNum">     186 </span>            :   DELTAQ_MODE deltaq_mode;
<span class="lineNum">     187 </span>            : #endif
<span class="lineNum">     188 </span>            : #if CONFIG_AOM_QM
<span class="lineNum">     189 </span>            :   int using_qm;
<span class="lineNum">     190 </span>            :   int qm_minlevel;
<span class="lineNum">     191 </span>            :   int qm_maxlevel;
<span class="lineNum">     192 </span>            : #endif
<span class="lineNum">     193 </span>            : #if CONFIG_TILE_GROUPS
<span class="lineNum">     194 </span>            :   unsigned int num_tile_groups;
<span class="lineNum">     195 </span>            :   unsigned int mtu;
<span class="lineNum">     196 </span>            : #endif
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : #if CONFIG_TEMPMV_SIGNALING
<span class="lineNum">     199 </span>            :   unsigned int disable_tempmv;
<span class="lineNum">     200 </span>            : #endif
<span class="lineNum">     201 </span>            :   // Internal frame size scaling.
<span class="lineNum">     202 </span>            :   RESIZE_TYPE resize_mode;
<span class="lineNum">     203 </span>            :   int scaled_frame_width;
<span class="lineNum">     204 </span>            :   int scaled_frame_height;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : #if CONFIG_FRAME_SUPERRES
<span class="lineNum">     207 </span>            :   // Frame Super-Resolution size scaling
<span class="lineNum">     208 </span>            :   int superres_enabled;
<span class="lineNum">     209 </span>            : #endif  // CONFIG_FRAME_SUPERRES
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :   // Enable feature to reduce the frame quantization every x frames.
<span class="lineNum">     212 </span>            :   int frame_periodic_boost;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :   // two pass datarate control
<span class="lineNum">     215 </span>            :   int two_pass_vbrbias;  // two pass datarate control tweaks
<span class="lineNum">     216 </span>            :   int two_pass_vbrmin_section;
<span class="lineNum">     217 </span>            :   int two_pass_vbrmax_section;
<span class="lineNum">     218 </span>            :   // END DATARATE CONTROL OPTIONS
<span class="lineNum">     219 </span>            :   // ----------------------------------------------------------------
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   int enable_auto_arf;
<span class="lineNum">     222 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     223 </span>            :   int enable_auto_brf;  // (b)ackward (r)ef (f)rame
<span class="lineNum">     224 </span>            : #endif                  // CONFIG_EXT_REFS
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   /* Bitfield defining the error resiliency features to enable.
<span class="lineNum">     227 </span>            :    * Can provide decodable frames after losses in previous
<span class="lineNum">     228 </span>            :    * frames and decodable partitions after losses in the same frame.
<span class="lineNum">     229 </span>            :    */
<span class="lineNum">     230 </span>            :   unsigned int error_resilient_mode;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /* Bitfield defining the parallel decoding mode where the
<span class="lineNum">     233 </span>            :    * decoding in successive frames may be conducted in parallel
<span class="lineNum">     234 </span>            :    * just by decoding the frame headers.
<span class="lineNum">     235 </span>            :    */
<span class="lineNum">     236 </span>            :   unsigned int frame_parallel_decoding_mode;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   int arnr_max_frames;
<span class="lineNum">     239 </span>            :   int arnr_strength;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   int min_gf_interval;
<span class="lineNum">     242 </span>            :   int max_gf_interval;
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   int tile_columns;
<span class="lineNum">     245 </span>            :   int tile_rows;
<span class="lineNum">     246 </span>            : #if CONFIG_DEPENDENT_HORZTILES
<span class="lineNum">     247 </span>            :   int dependent_horz_tiles;
<span class="lineNum">     248 </span>            : #endif
<span class="lineNum">     249 </span>            : #if CONFIG_LOOPFILTERING_ACROSS_TILES
<span class="lineNum">     250 </span>            :   int loop_filter_across_tiles_enabled;
<span class="lineNum">     251 </span>            : #endif  // CONFIG_LOOPFILTERING_ACROSS_TILES
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :   int max_threads;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   aom_fixed_buf_t two_pass_stats_in;
<span class="lineNum">     256 </span>            :   struct aom_codec_pkt_list *output_pkt_list;
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : #if CONFIG_FP_MB_STATS
<span class="lineNum">     259 </span>            :   aom_fixed_buf_t firstpass_mb_stats_in;
<span class="lineNum">     260 </span>            : #endif
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   aom_tune_metric tuning;
<span class="lineNum">     263 </span>            :   aom_tune_content content;
<span class="lineNum">     264 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">     265 </span>            :   int use_highbitdepth;
<span class="lineNum">     266 </span>            : #endif
<span class="lineNum">     267 </span>            :   aom_color_space_t color_space;
<span class="lineNum">     268 </span>            :   int color_range;
<span class="lineNum">     269 </span>            :   int render_width;
<span class="lineNum">     270 </span>            :   int render_height;
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : #if CONFIG_EXT_PARTITION
<span class="lineNum">     273 </span>            :   aom_superblock_size_t superblock_size;
<span class="lineNum">     274 </span>            : #endif  // CONFIG_EXT_PARTITION
<span class="lineNum">     275 </span>            : #if CONFIG_ANS &amp;&amp; ANS_MAX_SYMBOLS
<span class="lineNum">     276 </span>            :   int ans_window_size_log2;
<span class="lineNum">     277 </span>            : #endif  // CONFIG_ANS &amp;&amp; ANS_MAX_SYMBOLS
<span class="lineNum">     278 </span>            : #if CONFIG_EXT_TILE
<span class="lineNum">     279 </span>            :   unsigned int tile_encoding_mode;
<span class="lineNum">     280 </span>            : #endif  // CONFIG_EXT_TILE
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :   unsigned int motion_vector_unit_test;
<a name="283"><span class="lineNum">     283 </span>            : } AV1EncoderConfig;</a>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : static INLINE int is_lossless_requested(const AV1EncoderConfig *cfg) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   return cfg-&gt;best_allowed_q == 0 &amp;&amp; cfg-&gt;worst_allowed_q == 0;</span>
<span class="lineNum">     287 </span>            : }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : // TODO(jingning) All spatially adaptive variables should go to TileDataEnc.
<span class="lineNum">     290 </span>            : typedef struct TileDataEnc {
<span class="lineNum">     291 </span>            :   TileInfo tile_info;
<span class="lineNum">     292 </span>            :   int thresh_freq_fact[BLOCK_SIZES][MAX_MODES];
<span class="lineNum">     293 </span>            :   int mode_map[BLOCK_SIZES][MAX_MODES];
<span class="lineNum">     294 </span>            :   int m_search_count;
<span class="lineNum">     295 </span>            :   int ex_search_count;
<span class="lineNum">     296 </span>            : #if CONFIG_PVQ
<span class="lineNum">     297 </span>            :   PVQ_QUEUE pvq_q;
<span class="lineNum">     298 </span>            : #endif
<span class="lineNum">     299 </span>            : #if CONFIG_CFL
<span class="lineNum">     300 </span>            :   CFL_CTX cfl;
<span class="lineNum">     301 </span>            : #endif
<span class="lineNum">     302 </span>            : #if CONFIG_EC_ADAPT
<span class="lineNum">     303 </span>            :   DECLARE_ALIGNED(16, FRAME_CONTEXT, tctx);
<span class="lineNum">     304 </span>            : #endif
<span class="lineNum">     305 </span>            : } TileDataEnc;
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : typedef struct RD_COUNTS {
<span class="lineNum">     308 </span>            :   av1_coeff_count coef_counts[TX_SIZES][PLANE_TYPES];
<span class="lineNum">     309 </span>            :   int64_t comp_pred_diff[REFERENCE_MODES];
<span class="lineNum">     310 </span>            : #if CONFIG_GLOBAL_MOTION
<span class="lineNum">     311 </span>            :   // Stores number of 4x4 blocks using global motion per reference frame.
<span class="lineNum">     312 </span>            :   int global_motion_used[TOTAL_REFS_PER_FRAME];
<span class="lineNum">     313 </span>            : #endif  // CONFIG_GLOBAL_MOTION
<span class="lineNum">     314 </span>            : } RD_COUNTS;
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : typedef struct ThreadData {
<span class="lineNum">     317 </span>            :   MACROBLOCK mb;
<span class="lineNum">     318 </span>            :   RD_COUNTS rd_counts;
<span class="lineNum">     319 </span>            :   FRAME_COUNTS *counts;
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   PICK_MODE_CONTEXT *leaf_tree;
<span class="lineNum">     322 </span>            :   PC_TREE *pc_tree;
<span class="lineNum">     323 </span>            :   PC_TREE *pc_root[MAX_MIB_SIZE_LOG2 - MIN_MIB_SIZE_LOG2 + 1];
<span class="lineNum">     324 </span>            : #if CONFIG_MOTION_VAR
<span class="lineNum">     325 </span>            :   int32_t *wsrc_buf;
<span class="lineNum">     326 </span>            :   int32_t *mask_buf;
<span class="lineNum">     327 </span>            :   uint8_t *above_pred_buf;
<span class="lineNum">     328 </span>            :   uint8_t *left_pred_buf;
<span class="lineNum">     329 </span>            : #endif
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : #if CONFIG_PALETTE
<span class="lineNum">     332 </span>            :   PALETTE_BUFFER *palette_buffer;
<span class="lineNum">     333 </span>            : #endif  // CONFIG_PALETTE
<span class="lineNum">     334 </span>            : } ThreadData;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : struct EncWorkerData;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : typedef struct ActiveMap {
<span class="lineNum">     339 </span>            :   int enabled;
<span class="lineNum">     340 </span>            :   int update;
<span class="lineNum">     341 </span>            :   unsigned char *map;
<span class="lineNum">     342 </span>            : } ActiveMap;
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : #define NUM_STAT_TYPES 4  // types of stats: Y, U, V and ALL
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : typedef struct IMAGE_STAT {
<span class="lineNum">     347 </span>            :   double stat[NUM_STAT_TYPES];
<span class="lineNum">     348 </span>            :   double worst;
<span class="lineNum">     349 </span>            : } ImageStat;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : #undef NUM_STAT_TYPES
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : typedef struct {
<span class="lineNum">     354 </span>            :   int ref_count;
<span class="lineNum">     355 </span>            :   YV12_BUFFER_CONFIG buf;
<span class="lineNum">     356 </span>            : } EncRefCntBuffer;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : typedef struct TileBufferEnc {
<span class="lineNum">     359 </span>            :   uint8_t *data;
<span class="lineNum">     360 </span>            :   size_t size;
<span class="lineNum">     361 </span>            : } TileBufferEnc;
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : typedef struct AV1_COMP {
<span class="lineNum">     364 </span>            :   QUANTS quants;
<span class="lineNum">     365 </span>            :   ThreadData td;
<span class="lineNum">     366 </span>            :   MB_MODE_INFO_EXT *mbmi_ext_base;
<span class="lineNum">     367 </span>            :   Dequants dequants;
<span class="lineNum">     368 </span>            :   AV1_COMMON common;
<span class="lineNum">     369 </span>            :   AV1EncoderConfig oxcf;
<span class="lineNum">     370 </span>            :   struct lookahead_ctx *lookahead;
<span class="lineNum">     371 </span>            :   struct lookahead_entry *alt_ref_source;
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   YV12_BUFFER_CONFIG *source;
<span class="lineNum">     374 </span>            :   YV12_BUFFER_CONFIG *last_source;  // NULL for first frame and alt_ref frames
<span class="lineNum">     375 </span>            :   YV12_BUFFER_CONFIG *un_scaled_source;
<span class="lineNum">     376 </span>            :   YV12_BUFFER_CONFIG scaled_source;
<span class="lineNum">     377 </span>            :   YV12_BUFFER_CONFIG *unscaled_last_source;
<span class="lineNum">     378 </span>            :   YV12_BUFFER_CONFIG scaled_last_source;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :   // Up-sampled reference buffers
<span class="lineNum">     381 </span>            :   // NOTE(zoeliu): It is needed to allocate sufficient space to the up-sampled
<span class="lineNum">     382 </span>            :   // reference buffers, which should include the up-sampled version of all the
<span class="lineNum">     383 </span>            :   // possibly stored references plus the currently coded frame itself.
<span class="lineNum">     384 </span>            :   EncRefCntBuffer upsampled_ref_bufs[REF_FRAMES + 1];
<span class="lineNum">     385 </span>            :   int upsampled_ref_idx[REF_FRAMES + 1];
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :   // For a still frame, this flag is set to 1 to skip partition search.
<span class="lineNum">     388 </span>            :   int partition_search_skippable_frame;
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   int scaled_ref_idx[TOTAL_REFS_PER_FRAME];
<span class="lineNum">     391 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     392 </span>            :   int lst_fb_idxes[LAST_REF_FRAMES];
<span class="lineNum">     393 </span>            : #else
<span class="lineNum">     394 </span>            :   int lst_fb_idx;
<span class="lineNum">     395 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     396 </span>            :   int gld_fb_idx;
<span class="lineNum">     397 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     398 </span>            :   int bwd_fb_idx;  // BWD_REF_FRAME
<span class="lineNum">     399 </span>            : #endif             // CONFIG_EXT_REFS
<span class="lineNum">     400 </span>            :   int alt_fb_idx;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   int last_show_frame_buf_idx;  // last show frame buffer index
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   int refresh_last_frame;
<span class="lineNum">     405 </span>            :   int refresh_golden_frame;
<span class="lineNum">     406 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     407 </span>            :   int refresh_bwd_ref_frame;
<span class="lineNum">     408 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     409 </span>            :   int refresh_alt_ref_frame;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   int ext_refresh_frame_flags_pending;
<span class="lineNum">     412 </span>            :   int ext_refresh_last_frame;
<span class="lineNum">     413 </span>            :   int ext_refresh_golden_frame;
<span class="lineNum">     414 </span>            :   int ext_refresh_alt_ref_frame;
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   int ext_refresh_frame_context_pending;
<span class="lineNum">     417 </span>            :   int ext_refresh_frame_context;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   YV12_BUFFER_CONFIG last_frame_uf;
<span class="lineNum">     420 </span>            : #if CONFIG_LOOP_RESTORATION
<span class="lineNum">     421 </span>            :   YV12_BUFFER_CONFIG last_frame_db;
<span class="lineNum">     422 </span>            :   YV12_BUFFER_CONFIG trial_frame_rst;
<span class="lineNum">     423 </span>            :   uint8_t *extra_rstbuf;  // Extra buffers used in restoration search
<span class="lineNum">     424 </span>            :   RestorationInfo rst_search[MAX_MB_PLANE];  // Used for encoder side search
<span class="lineNum">     425 </span>            : #endif                                       // CONFIG_LOOP_RESTORATION
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   // Ambient reconstruction err target for force key frames
<span class="lineNum">     428 </span>            :   int64_t ambient_err;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   RD_OPT rd;
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :   CODING_CONTEXT coding_context;
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span>            :   int nmv_costs[NMV_CONTEXTS][2][MV_VALS];
<span class="lineNum">     435 </span>            :   int nmv_costs_hp[NMV_CONTEXTS][2][MV_VALS];
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :   int64_t last_time_stamp_seen;
<span class="lineNum">     438 </span>            :   int64_t last_end_time_stamp_seen;
<span class="lineNum">     439 </span>            :   int64_t first_time_stamp_ever;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :   RATE_CONTROL rc;
<span class="lineNum">     442 </span>            : #if CONFIG_XIPHRC
<span class="lineNum">     443 </span>            :   od_rc_state od_rc;
<span class="lineNum">     444 </span>            : #endif
<span class="lineNum">     445 </span>            :   double framerate;
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            :   // NOTE(zoeliu): Any inter frame allows maximum of REF_FRAMES inter
<span class="lineNum">     448 </span>            :   // references; Plus the currently coded frame itself, it is needed to allocate
<span class="lineNum">     449 </span>            :   // sufficient space to the size of the maximum possible number of frames.
<span class="lineNum">     450 </span>            :   int interp_filter_selected[REF_FRAMES + 1][SWITCHABLE];
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   struct aom_codec_pkt_list *output_pkt_list;
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   MBGRAPH_FRAME_STATS mbgraph_stats[MAX_LAG_BUFFERS];
<span class="lineNum">     455 </span>            :   int mbgraph_n_frames;  // number of frames filled in the above
<span class="lineNum">     456 </span>            :   int static_mb_pct;     // % forced skip mbs by segmentation
<span class="lineNum">     457 </span>            :   int ref_frame_flags;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   SPEED_FEATURES sf;
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :   unsigned int max_mv_magnitude;
<span class="lineNum">     462 </span>            :   int mv_step_param;
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   int allow_comp_inter_inter;
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   uint8_t *segmentation_map;
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :   CYCLIC_REFRESH *cyclic_refresh;
<span class="lineNum">     469 </span>            :   ActiveMap active_map;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   fractional_mv_step_fp *find_fractional_mv_step;
<span class="lineNum">     472 </span>            :   av1_full_search_fn_t full_search_sad;  // It is currently unused.
<span class="lineNum">     473 </span>            :   av1_diamond_search_fn_t diamond_search_sad;
<span class="lineNum">     474 </span>            :   aom_variance_fn_ptr_t fn_ptr[BLOCK_SIZES];
<span class="lineNum">     475 </span>            :   uint64_t time_receive_data;
<span class="lineNum">     476 </span>            :   uint64_t time_compress_data;
<span class="lineNum">     477 </span>            :   uint64_t time_pick_lpf;
<span class="lineNum">     478 </span>            :   uint64_t time_encode_sb_row;
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : #if CONFIG_FP_MB_STATS
<span class="lineNum">     481 </span>            :   int use_fp_mb_stats;
<span class="lineNum">     482 </span>            : #endif
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   TWO_PASS twopass;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   YV12_BUFFER_CONFIG alt_ref_buffer;
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : #if CONFIG_INTERNAL_STATS
<span class="lineNum">     489 </span>            :   unsigned int mode_chosen_counts[MAX_MODES];
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   int count;
<span class="lineNum">     492 </span>            :   uint64_t total_sq_error;
<span class="lineNum">     493 </span>            :   uint64_t total_samples;
<span class="lineNum">     494 </span>            :   ImageStat psnr;
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :   double total_blockiness;
<span class="lineNum">     497 </span>            :   double worst_blockiness;
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   int bytes;
<span class="lineNum">     500 </span>            :   double summed_quality;
<span class="lineNum">     501 </span>            :   double summed_weights;
<span class="lineNum">     502 </span>            :   unsigned int tot_recode_hits;
<span class="lineNum">     503 </span>            :   double worst_ssim;
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   ImageStat fastssim;
<span class="lineNum">     506 </span>            :   ImageStat psnrhvs;
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :   int b_calculate_blockiness;
<span class="lineNum">     509 </span>            :   int b_calculate_consistency;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   double total_inconsistency;
<span class="lineNum">     512 </span>            :   double worst_consistency;
<span class="lineNum">     513 </span>            :   Ssimv *ssim_vars;
<span class="lineNum">     514 </span>            :   Metrics metrics;
<span class="lineNum">     515 </span>            : #endif
<span class="lineNum">     516 </span>            :   int b_calculate_psnr;
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :   int droppable;
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   int initial_width;
<span class="lineNum">     521 </span>            :   int initial_height;
<span class="lineNum">     522 </span>            :   int initial_mbs;  // Number of MBs in the full-size frame; to be used to
<span class="lineNum">     523 </span>            :                     // normalize the firstpass stats. This will differ from the
<span class="lineNum">     524 </span>            :                     // number of MBs in the current frame when the frame is
<span class="lineNum">     525 </span>            :                     // scaled.
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   int frame_flags;
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   search_site_config ss_cfg;
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :   int mbmode_cost[BLOCK_SIZE_GROUPS][INTRA_MODES];
<span class="lineNum">     532 </span>            :   int newmv_mode_cost[NEWMV_MODE_CONTEXTS][2];
<span class="lineNum">     533 </span>            :   int zeromv_mode_cost[ZEROMV_MODE_CONTEXTS][2];
<span class="lineNum">     534 </span>            :   int refmv_mode_cost[REFMV_MODE_CONTEXTS][2];
<span class="lineNum">     535 </span>            :   int drl_mode_cost0[DRL_MODE_CONTEXTS][2];
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :   unsigned int inter_mode_cost[INTER_MODE_CONTEXTS][INTER_MODES];
<span class="lineNum">     538 </span>            : #if CONFIG_EXT_INTER
<span class="lineNum">     539 </span>            :   unsigned int inter_compound_mode_cost[INTER_MODE_CONTEXTS]
<span class="lineNum">     540 </span>            :                                        [INTER_COMPOUND_MODES];
<span class="lineNum">     541 </span>            : #if CONFIG_INTERINTRA
<span class="lineNum">     542 </span>            :   unsigned int interintra_mode_cost[BLOCK_SIZE_GROUPS][INTERINTRA_MODES];
<span class="lineNum">     543 </span>            : #endif  // CONFIG_INTERINTRA
<span class="lineNum">     544 </span>            : #endif  // CONFIG_EXT_INTER
<span class="lineNum">     545 </span>            : #if CONFIG_MOTION_VAR || CONFIG_WARPED_MOTION
<span class="lineNum">     546 </span>            :   int motion_mode_cost[BLOCK_SIZES][MOTION_MODES];
<span class="lineNum">     547 </span>            : #if CONFIG_MOTION_VAR &amp;&amp; CONFIG_WARPED_MOTION
<span class="lineNum">     548 </span>            :   int motion_mode_cost1[BLOCK_SIZES][2];
<span class="lineNum">     549 </span>            : #endif  // CONFIG_MOTION_VAR &amp;&amp; CONFIG_WARPED_MOTION
<span class="lineNum">     550 </span>            : #endif  // CONFIG_MOTION_VAR || CONFIG_WARPED_MOTION
<span class="lineNum">     551 </span>            :   int intra_uv_mode_cost[INTRA_MODES][INTRA_MODES];
<span class="lineNum">     552 </span>            :   int y_mode_costs[INTRA_MODES][INTRA_MODES][INTRA_MODES];
<span class="lineNum">     553 </span>            :   int switchable_interp_costs[SWITCHABLE_FILTER_CONTEXTS][SWITCHABLE_FILTERS];
<span class="lineNum">     554 </span>            : #if CONFIG_EXT_PARTITION_TYPES
<span class="lineNum">     555 </span>            :   int partition_cost[PARTITION_CONTEXTS + CONFIG_UNPOISON_PARTITION_CTX]
<span class="lineNum">     556 </span>            :                     [EXT_PARTITION_TYPES];
<span class="lineNum">     557 </span>            : #else
<span class="lineNum">     558 </span>            :   int partition_cost[PARTITION_CONTEXTS + CONFIG_UNPOISON_PARTITION_CTX]
<span class="lineNum">     559 </span>            :                     [PARTITION_TYPES];
<span class="lineNum">     560 </span>            : #endif
<span class="lineNum">     561 </span>            : #if CONFIG_PALETTE
<span class="lineNum">     562 </span>            :   int palette_y_size_cost[PALETTE_BLOCK_SIZES][PALETTE_SIZES];
<span class="lineNum">     563 </span>            :   int palette_uv_size_cost[PALETTE_BLOCK_SIZES][PALETTE_SIZES];
<span class="lineNum">     564 </span>            :   int palette_y_color_cost[PALETTE_SIZES][PALETTE_COLOR_INDEX_CONTEXTS]
<span class="lineNum">     565 </span>            :                           [PALETTE_COLORS];
<span class="lineNum">     566 </span>            :   int palette_uv_color_cost[PALETTE_SIZES][PALETTE_COLOR_INDEX_CONTEXTS]
<span class="lineNum">     567 </span>            :                            [PALETTE_COLORS];
<span class="lineNum">     568 </span>            : #endif  // CONFIG_PALETTE
<span class="lineNum">     569 </span>            :   int tx_size_cost[TX_SIZES - 1][TX_SIZE_CONTEXTS][TX_SIZES];
<span class="lineNum">     570 </span>            : #if CONFIG_EXT_TX
<span class="lineNum">     571 </span>            :   int inter_tx_type_costs[EXT_TX_SETS_INTER][EXT_TX_SIZES][TX_TYPES];
<span class="lineNum">     572 </span>            :   int intra_tx_type_costs[EXT_TX_SETS_INTRA][EXT_TX_SIZES][INTRA_MODES]
<span class="lineNum">     573 </span>            :                          [TX_TYPES];
<span class="lineNum">     574 </span>            : #else
<span class="lineNum">     575 </span>            :   int intra_tx_type_costs[EXT_TX_SIZES][TX_TYPES][TX_TYPES];
<span class="lineNum">     576 </span>            :   int inter_tx_type_costs[EXT_TX_SIZES][TX_TYPES];
<span class="lineNum">     577 </span>            : #endif  // CONFIG_EXT_TX
<span class="lineNum">     578 </span>            : #if CONFIG_EXT_INTRA
<span class="lineNum">     579 </span>            : #if CONFIG_INTRA_INTERP
<span class="lineNum">     580 </span>            :   int intra_filter_cost[INTRA_FILTERS + 1][INTRA_FILTERS];
<span class="lineNum">     581 </span>            : #endif  // CONFIG_INTRA_INTERP
<span class="lineNum">     582 </span>            : #endif  // CONFIG_EXT_INTRA
<span class="lineNum">     583 </span>            : #if CONFIG_LOOP_RESTORATION
<span class="lineNum">     584 </span>            :   int switchable_restore_cost[RESTORE_SWITCHABLE_TYPES];
<span class="lineNum">     585 </span>            : #endif  // CONFIG_LOOP_RESTORATION
<span class="lineNum">     586 </span>            : #if CONFIG_GLOBAL_MOTION
<span class="lineNum">     587 </span>            :   int gmtype_cost[TRANS_TYPES];
<span class="lineNum">     588 </span>            :   int gmparams_cost[TOTAL_REFS_PER_FRAME];
<span class="lineNum">     589 </span>            : #endif  // CONFIG_GLOBAL_MOTION
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   int multi_arf_allowed;
<span class="lineNum">     592 </span>            :   int multi_arf_enabled;
<span class="lineNum">     593 </span>            :   int multi_arf_last_grp_enabled;
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   TileDataEnc *tile_data;
<span class="lineNum">     596 </span>            :   int allocated_tiles;  // Keep track of memory allocated for tiles.
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   TOKENEXTRA *tile_tok[MAX_TILE_ROWS][MAX_TILE_COLS];
<span class="lineNum">     599 </span>            :   unsigned int tok_count[MAX_TILE_ROWS][MAX_TILE_COLS];
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   TileBufferEnc tile_buffers[MAX_TILE_ROWS][MAX_TILE_COLS];
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :   int resize_state;
<span class="lineNum">     604 </span>            :   int resize_scale_num;
<span class="lineNum">     605 </span>            :   int resize_scale_den;
<span class="lineNum">     606 </span>            :   int resize_next_scale_num;
<span class="lineNum">     607 </span>            :   int resize_next_scale_den;
<span class="lineNum">     608 </span>            :   int resize_avg_qp;
<span class="lineNum">     609 </span>            :   int resize_buffer_underflow;
<span class="lineNum">     610 </span>            :   int resize_count;
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : #if CONFIG_FRAME_SUPERRES
<span class="lineNum">     613 </span>            :   int superres_pending;
<span class="lineNum">     614 </span>            : #endif  // CONFIG_FRAME_SUPERRES
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :   // VARIANCE_AQ segment map refresh
<span class="lineNum">     617 </span>            :   int vaq_refresh;
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   // Multi-threading
<span class="lineNum">     620 </span>            :   int num_workers;
<span class="lineNum">     621 </span>            :   AVxWorker *workers;
<span class="lineNum">     622 </span>            :   struct EncWorkerData *tile_thr_data;
<span class="lineNum">     623 </span>            :   AV1LfSync lf_row_sync;
<span class="lineNum">     624 </span>            : #if CONFIG_ANS
<span class="lineNum">     625 </span>            :   struct BufAnsCoder buf_ans;
<span class="lineNum">     626 </span>            : #endif
<span class="lineNum">     627 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     628 </span>            :   int refresh_frame_mask;
<span class="lineNum">     629 </span>            :   int existing_fb_idx_to_show;
<span class="lineNum">     630 </span>            :   int is_arf_filter_off[MAX_EXT_ARFS + 1];
<span class="lineNum">     631 </span>            :   int num_extra_arfs;
<span class="lineNum">     632 </span>            :   int arf_map[MAX_EXT_ARFS + 1];
<span class="lineNum">     633 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     634 </span>            : #if CONFIG_GLOBAL_MOTION
<span class="lineNum">     635 </span>            :   int global_motion_search_done;
<span class="lineNum">     636 </span>            : #endif
<span class="lineNum">     637 </span>            : #if CONFIG_REFERENCE_BUFFER
<span class="lineNum">     638 </span>            :   SequenceHeader seq_params;
<span class="lineNum">     639 </span>            : #endif
<span class="lineNum">     640 </span>            : #if CONFIG_LV_MAP
<span class="lineNum">     641 </span>            :   tran_low_t *tcoeff_buf[MAX_MB_PLANE];
<span class="lineNum">     642 </span>            : #endif
<span class="lineNum">     643 </span>            : } AV1_COMP;
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : void av1_initialize_enc(void);
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : struct AV1_COMP *av1_create_compressor(AV1EncoderConfig *oxcf,
<span class="lineNum">     648 </span>            :                                        BufferPool *const pool);
<span class="lineNum">     649 </span>            : void av1_remove_compressor(AV1_COMP *cpi);
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : void av1_change_config(AV1_COMP *cpi, const AV1EncoderConfig *oxcf);
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            : // receive a frames worth of data. caller can assume that a copy of this
<span class="lineNum">     654 </span>            : // frame is made and not just a copy of the pointer..
<span class="lineNum">     655 </span>            : int av1_receive_raw_frame(AV1_COMP *cpi, aom_enc_frame_flags_t frame_flags,
<span class="lineNum">     656 </span>            :                           YV12_BUFFER_CONFIG *sd, int64_t time_stamp,
<span class="lineNum">     657 </span>            :                           int64_t end_time_stamp);
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : int av1_get_compressed_data(AV1_COMP *cpi, unsigned int *frame_flags,
<span class="lineNum">     660 </span>            :                             size_t *size, uint8_t *dest, int64_t *time_stamp,
<span class="lineNum">     661 </span>            :                             int64_t *time_end, int flush);
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            : int av1_get_preview_raw_frame(AV1_COMP *cpi, YV12_BUFFER_CONFIG *dest);
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : int av1_get_last_show_frame(AV1_COMP *cpi, YV12_BUFFER_CONFIG *frame);
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : int av1_use_as_reference(AV1_COMP *cpi, int ref_frame_flags);
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            : void av1_update_reference(AV1_COMP *cpi, int ref_frame_flags);
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : int av1_copy_reference_enc(AV1_COMP *cpi, AOM_REFFRAME ref_frame_flag,
<span class="lineNum">     672 </span>            :                            YV12_BUFFER_CONFIG *sd);
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : int av1_set_reference_enc(AV1_COMP *cpi, AOM_REFFRAME ref_frame_flag,
<span class="lineNum">     675 </span>            :                           YV12_BUFFER_CONFIG *sd);
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : int av1_update_entropy(AV1_COMP *cpi, int update);
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : int av1_set_active_map(AV1_COMP *cpi, unsigned char *map, int rows, int cols);
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : int av1_get_active_map(AV1_COMP *cpi, unsigned char *map, int rows, int cols);
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : int av1_set_internal_size(AV1_COMP *cpi, AOM_SCALING horiz_mode,
<span class="lineNum">     684 </span>            :                           AOM_SCALING vert_mode);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : // Returns 1 if the assigned width or height was &lt;= 0.
<span class="lineNum">     687 </span>            : int av1_set_size_literal(AV1_COMP *cpi, int width, int height);
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            : int av1_get_quantizer(struct AV1_COMP *cpi);
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : void av1_full_to_model_counts(av1_coeff_count_model *model_count,
<a name="692"><span class="lineNum">     692 </span>            :                               av1_coeff_count *full_count);</a>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 : static INLINE int frame_is_kf_gf_arf(const AV1_COMP *cpi) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :   return frame_is_intra_only(&amp;cpi-&gt;common) || cpi-&gt;refresh_alt_ref_frame ||</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :          (cpi-&gt;refresh_golden_frame &amp;&amp; !cpi-&gt;rc.is_src_frame_alt_ref);</span>
<a name="697"><span class="lineNum">     697 </span>            : }</a>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 : static INLINE int get_ref_frame_map_idx(const AV1_COMP *cpi,</span>
<span class="lineNum">     700 </span>            :                                         MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     701 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   if (ref_frame &gt;= LAST_FRAME &amp;&amp; ref_frame &lt;= LAST3_FRAME)</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     return cpi-&gt;lst_fb_idxes[ref_frame - 1];</span>
<span class="lineNum">     704 </span>            : #else
<span class="lineNum">     705 </span>            :   if (ref_frame == LAST_FRAME) return cpi-&gt;lst_fb_idx;
<span class="lineNum">     706 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :   else if (ref_frame == GOLDEN_FRAME)</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :     return cpi-&gt;gld_fb_idx;</span>
<span class="lineNum">     709 </span>            : #if CONFIG_EXT_REFS
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   else if (ref_frame == BWDREF_FRAME)</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     return cpi-&gt;bwd_fb_idx;</span>
<span class="lineNum">     712 </span>            : #endif  // CONFIG_EXT_REFS
<span class="lineNum">     713 </span>            :   else
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :     return cpi-&gt;alt_fb_idx;</span>
<a name="715"><span class="lineNum">     715 </span>            : }</a>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span><span class="lineNoCov">          0 : static INLINE int get_ref_frame_buf_idx(const AV1_COMP *cpi,</span>
<span class="lineNum">     718 </span>            :                                         MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   const AV1_COMMON *const cm = &amp;cpi-&gt;common;</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   const int map_idx = get_ref_frame_map_idx(cpi, ref_frame);</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   return (map_idx != INVALID_IDX) ? cm-&gt;ref_frame_map[map_idx] : INVALID_IDX;</span>
<a name="722"><span class="lineNum">     722 </span>            : }</a>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineNoCov">          0 : static INLINE YV12_BUFFER_CONFIG *get_ref_frame_buffer(</span>
<span class="lineNum">     725 </span>            :     const AV1_COMP *cpi, MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :   const AV1_COMMON *const cm = &amp;cpi-&gt;common;</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   return buf_idx != INVALID_IDX ? &amp;cm-&gt;buffer_pool-&gt;frame_bufs[buf_idx].buf</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :                                 : NULL;</span>
<a name="730"><span class="lineNum">     730 </span>            : }</a>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineNoCov">          0 : static INLINE const YV12_BUFFER_CONFIG *get_upsampled_ref(</span>
<span class="lineNum">     733 </span>            :     const AV1_COMP *cpi, const MV_REFERENCE_FRAME ref_frame) {
<span class="lineNum">     734 </span>            :   // Use up-sampled reference frames.
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   const int buf_idx =</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       cpi-&gt;upsampled_ref_idx[get_ref_frame_map_idx(cpi, ref_frame)];</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   return &amp;cpi-&gt;upsampled_ref_bufs[buf_idx].buf;</span>
<span class="lineNum">     738 </span>            : }
<a name="739"><span class="lineNum">     739 </span>            : </a>
<span class="lineNum">     740 </span>            : #if CONFIG_EXT_REFS || CONFIG_TEMPMV_SIGNALING
<span class="lineNum">     741 </span><span class="lineNoCov">          0 : static INLINE int enc_is_ref_frame_buf(AV1_COMP *cpi, RefCntBuffer *frame_buf) {</span>
<span class="lineNum">     742 </span>            :   MV_REFERENCE_FRAME ref_frame;
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :   AV1_COMMON *const cm = &amp;cpi-&gt;common;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   for (ref_frame = LAST_FRAME; ref_frame &lt;= ALTREF_FRAME; ++ref_frame) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     const int buf_idx = get_ref_frame_buf_idx(cpi, ref_frame);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     if (buf_idx == INVALID_IDX) continue;</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if (frame_buf == &amp;cm-&gt;buffer_pool-&gt;frame_bufs[buf_idx]) break;</span>
<span class="lineNum">     748 </span>            :   }
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   return (ref_frame &lt;= ALTREF_FRAME);</span>
<span class="lineNum">     750 </span>            : }
<a name="751"><span class="lineNum">     751 </span>            : #endif  // CONFIG_EXT_REFS</a>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 : static INLINE unsigned int get_token_alloc(int mb_rows, int mb_cols) {</span>
<span class="lineNum">     754 </span>            :   // We assume 3 planes all at full resolution. We assume up to 1 token per
<span class="lineNum">     755 </span>            :   // pixel, and then allow a head room of 1 EOSB token per 4x4 block per plane,
<span class="lineNum">     756 </span>            :   // plus EOSB_TOKEN per plane.
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   return mb_rows * mb_cols * (16 * 16 + 17) * 3;</span>
<span class="lineNum">     758 </span>            : }
<span class="lineNum">     759 </span>            : 
<a name="760"><span class="lineNum">     760 </span>            : // Get the allocated token size for a tile. It does the same calculation as in</a>
<span class="lineNum">     761 </span>            : // the frame token allocation.
<span class="lineNum">     762 </span><span class="lineNoCov">          0 : static INLINE unsigned int allocated_tokens(TileInfo tile) {</span>
<span class="lineNum">     763 </span>            : #if CONFIG_CB4X4
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   int tile_mb_rows = (tile.mi_row_end - tile.mi_row_start + 2) &gt;&gt; 2;</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   int tile_mb_cols = (tile.mi_col_end - tile.mi_col_start + 2) &gt;&gt; 2;</span>
<span class="lineNum">     766 </span>            : #else
<span class="lineNum">     767 </span>            :   int tile_mb_rows = (tile.mi_row_end - tile.mi_row_start + 1) &gt;&gt; 1;
<span class="lineNum">     768 </span>            :   int tile_mb_cols = (tile.mi_col_end - tile.mi_col_start + 1) &gt;&gt; 1;
<span class="lineNum">     769 </span>            : #endif
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   return get_token_alloc(tile_mb_rows, tile_mb_cols);</span>
<span class="lineNum">     772 </span>            : }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : void av1_alloc_compressor_data(AV1_COMP *cpi);
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            : void av1_scale_references(AV1_COMP *cpi);
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : void av1_update_reference_frames(AV1_COMP *cpi);
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            : void av1_set_high_precision_mv(AV1_COMP *cpi, int allow_high_precision_mv);
<span class="lineNum">     781 </span>            : #if CONFIG_TEMPMV_SIGNALING
<span class="lineNum">     782 </span>            : void av1_set_temporal_mv_prediction(AV1_COMP *cpi, int allow_tempmv_prediction);
<span class="lineNum">     783 </span>            : #endif
<span class="lineNum">     784 </span>            : 
<a name="785"><span class="lineNum">     785 </span>            : void av1_apply_encoding_flags(AV1_COMP *cpi, aom_enc_frame_flags_t flags);</a>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : static INLINE int is_altref_enabled(const AV1_COMP *const cpi) {</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :   return cpi-&gt;oxcf.lag_in_frames &gt; 0 &amp;&amp; cpi-&gt;oxcf.enable_auto_arf;</span>
<span class="lineNum">     789 </span>            : }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : // TODO(zoeliu): To set up cpi-&gt;oxcf.enable_auto_brf
<span class="lineNum">     792 </span>            : #if 0 &amp;&amp; CONFIG_EXT_REFS
<span class="lineNum">     793 </span>            : static INLINE int is_bwdref_enabled(const AV1_COMP *const cpi) {
<span class="lineNum">     794 </span>            :   // NOTE(zoeliu): The enabling of bi-predictive frames depends on the use of
<span class="lineNum">     795 </span>            :   //               alt_ref, and now will be off when the alt_ref interval is
<span class="lineNum">     796 </span>            :   //               not sufficiently large.
<span class="lineNum">     797 </span>            :   return is_altref_enabled(cpi) &amp;&amp; cpi-&gt;oxcf.enable_auto_brf;
<span class="lineNum">     798 </span>            : }
<a name="799"><span class="lineNum">     799 </span>            : #endif  // CONFIG_EXT_REFS</a>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 : static INLINE void set_ref_ptrs(const AV1_COMMON *cm, MACROBLOCKD *xd,</span>
<span class="lineNum">     802 </span>            :                                 MV_REFERENCE_FRAME ref0,
<span class="lineNum">     803 </span>            :                                 MV_REFERENCE_FRAME ref1) {
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   xd-&gt;block_refs[0] =</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :       &amp;cm-&gt;frame_refs[ref0 &gt;= LAST_FRAME ? ref0 - LAST_FRAME : 0];</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   xd-&gt;block_refs[1] =</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :       &amp;cm-&gt;frame_refs[ref1 &gt;= LAST_FRAME ? ref1 - LAST_FRAME : 0];</span>
<a name="808"><span class="lineNum">     808 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 : static INLINE int get_chessboard_index(int frame_index) {</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   return frame_index &amp; 0x1;</span>
<a name="812"><span class="lineNum">     812 </span>            : }</a>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 : static INLINE int *cond_cost_list(const struct AV1_COMP *cpi, int *cost_list) {</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   return cpi-&gt;sf.mv.subpel_search_method != SUBPEL_TREE ? cost_list : NULL;</span>
<span class="lineNum">     816 </span>            : }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : void av1_new_framerate(AV1_COMP *cpi, double framerate);
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : #define LAYER_IDS_TO_IDX(sl, tl, num_tl) ((sl) * (num_tl) + (tl))
<a name="821"><span class="lineNum">     821 </span>            : </a>
<span class="lineNum">     822 </span>            : // Update up-sampled reference frame index.
<span class="lineNum">     823 </span><span class="lineNoCov">          0 : static INLINE void uref_cnt_fb(EncRefCntBuffer *ubufs, int *uidx,</span>
<span class="lineNum">     824 </span>            :                                int new_uidx) {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   const int ref_index = *uidx;</span>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   if (ref_index &gt;= 0 &amp;&amp; ubufs[ref_index].ref_count &gt; 0)</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     ubufs[ref_index].ref_count--;</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   *uidx = new_uidx;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   ubufs[new_uidx].ref_count++;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 : }</span>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<span class="lineNum">     834 </span>            : // Returns 1 if a resize is pending and 0 otherwise.
<span class="lineNum">     835 </span><span class="lineNoCov">          0 : static INLINE int av1_resize_pending(const struct AV1_COMP *cpi) {</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   return cpi-&gt;resize_scale_num != cpi-&gt;resize_next_scale_num ||</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :          cpi-&gt;resize_scale_den != cpi-&gt;resize_next_scale_den;</span>
<span class="lineNum">     838 </span>            : }
<a name="839"><span class="lineNum">     839 </span>            : </a>
<span class="lineNum">     840 </span>            : // Returns 1 if a frame is unscaled and 0 otherwise.
<span class="lineNum">     841 </span><span class="lineNoCov">          0 : static INLINE int av1_resize_unscaled(const struct AV1_COMP *cpi) {</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   return cpi-&gt;resize_scale_num == cpi-&gt;resize_scale_den;</span>
<span class="lineNum">     843 </span>            : }
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            : // Moves resizing to the next state. This is just setting the numerator and
<a name="846"><span class="lineNum">     846 </span>            : // denominator to the next numerator and denominator, causing</a>
<span class="lineNum">     847 </span>            : // av1_resize_pending to subsequently return false.
<span class="lineNum">     848 </span><span class="lineNoCov">          0 : static INLINE void av1_resize_step(struct AV1_COMP *cpi) {</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :   cpi-&gt;resize_scale_num = cpi-&gt;resize_next_scale_num;</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   cpi-&gt;resize_scale_den = cpi-&gt;resize_next_scale_den;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : #ifdef __cplusplus
<span class="lineNum">     854 </span>            : }  // extern &quot;C&quot;
<span class="lineNum">     855 </span>            : #endif
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : #endif  // AV1_ENCODER_ENCODER_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

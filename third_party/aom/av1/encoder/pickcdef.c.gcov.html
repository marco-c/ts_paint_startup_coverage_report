<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - third_party/aom/av1/encoder/pickcdef.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">third_party/aom/av1/encoder</a> - pickcdef.c<span style="font-size: 80%;"> (source / <a href="pickcdef.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">280</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2016, Alliance for Open Media. All rights reserved
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * This source code is subject to the terms of the BSD 2 Clause License and
<span class="lineNum">       5 </span>            :  * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
<span class="lineNum">       6 </span>            :  * was not distributed with this source code in the LICENSE file, you can
<span class="lineNum">       7 </span>            :  * obtain it at www.aomedia.org/license/software. If the Alliance for Open
<span class="lineNum">       8 </span>            :  * Media Patent License 1.0 was not distributed with this source code in the
<span class="lineNum">       9 </span>            :  * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      13 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;./aom_scale_rtcd.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;aom/aom_integer.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;av1/common/cdef.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;av1/common/onyxc_int.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;av1/common/reconinter.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;av1/encoder/encoder.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #define TOTAL_STRENGTHS (DERING_STRENGTHS * CLPF_STRENGTHS)
<span class="lineNum">      23 </span>            : 
<a name="24"><span class="lineNum">      24 </span>            : /* Search for the best strength to add as an option, knowing we</a>
<span class="lineNum">      25 </span>            :    already selected nb_strengths options. */
<span class="lineNum">      26 </span><span class="lineNoCov">          0 : static uint64_t search_one(int *lev, int nb_strengths,</span>
<span class="lineNum">      27 </span>            :                            uint64_t mse[][TOTAL_STRENGTHS], int sb_count) {
<span class="lineNum">      28 </span>            :   uint64_t tot_mse[TOTAL_STRENGTHS];
<span class="lineNum">      29 </span>            :   int i, j;
<span class="lineNum">      30 </span><span class="lineNoCov">          0 :   uint64_t best_tot_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">      31 </span><span class="lineNoCov">          0 :   int best_id = 0;</span>
<span class="lineNum">      32 </span><span class="lineNoCov">          0 :   memset(tot_mse, 0, sizeof(tot_mse));</span>
<span class="lineNum">      33 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; sb_count; i++) {</span>
<span class="lineNum">      34 </span>            :     int gi;
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :     uint64_t best_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">      36 </span>            :     /* Find best mse among already selected options. */
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :     for (gi = 0; gi &lt; nb_strengths; gi++) {</span>
<span class="lineNum">      38 </span><span class="lineNoCov">          0 :       if (mse[i][lev[gi]] &lt; best_mse) {</span>
<span class="lineNum">      39 </span><span class="lineNoCov">          0 :         best_mse = mse[i][lev[gi]];</span>
<span class="lineNum">      40 </span>            :       }
<span class="lineNum">      41 </span>            :     }
<span class="lineNum">      42 </span>            :     /* Find best mse when adding each possible new option. */
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; TOTAL_STRENGTHS; j++) {</span>
<span class="lineNum">      44 </span><span class="lineNoCov">          0 :       uint64_t best = best_mse;</span>
<span class="lineNum">      45 </span><span class="lineNoCov">          0 :       if (mse[i][j] &lt; best) best = mse[i][j];</span>
<span class="lineNum">      46 </span><span class="lineNoCov">          0 :       tot_mse[j] += best;</span>
<span class="lineNum">      47 </span>            :     }
<span class="lineNum">      48 </span>            :   }
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   for (j = 0; j &lt; TOTAL_STRENGTHS; j++) {</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :     if (tot_mse[j] &lt; best_tot_mse) {</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :       best_tot_mse = tot_mse[j];</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :       best_id = j;</span>
<span class="lineNum">      53 </span>            :     }
<span class="lineNum">      54 </span>            :   }
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   lev[nb_strengths] = best_id;</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :   return best_tot_mse;</span>
<span class="lineNum">      57 </span>            : }
<span class="lineNum">      58 </span>            : 
<a name="59"><span class="lineNum">      59 </span>            : /* Search for the best luma+chroma strength to add as an option, knowing we</a>
<span class="lineNum">      60 </span>            :    already selected nb_strengths options. */
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : static uint64_t search_one_dual(int *lev0, int *lev1, int nb_strengths,</span>
<span class="lineNum">      62 </span>            :                                 uint64_t (**mse)[TOTAL_STRENGTHS],
<span class="lineNum">      63 </span>            :                                 int sb_count) {
<span class="lineNum">      64 </span>            :   uint64_t tot_mse[TOTAL_STRENGTHS][TOTAL_STRENGTHS];
<span class="lineNum">      65 </span>            :   int i, j;
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :   uint64_t best_tot_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   int best_id0 = 0;</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   int best_id1 = 0;</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :   memset(tot_mse, 0, sizeof(tot_mse));</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; sb_count; i++) {</span>
<span class="lineNum">      71 </span>            :     int gi;
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     uint64_t best_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">      73 </span>            :     /* Find best mse among already selected options. */
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     for (gi = 0; gi &lt; nb_strengths; gi++) {</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :       uint64_t curr = mse[0][i][lev0[gi]];</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :       curr += mse[1][i][lev1[gi]];</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :       if (curr &lt; best_mse) {</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :         best_mse = curr;</span>
<span class="lineNum">      79 </span>            :       }
<span class="lineNum">      80 </span>            :     }
<span class="lineNum">      81 </span>            :     /* Find best mse when adding each possible new option. */
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; TOTAL_STRENGTHS; j++) {</span>
<span class="lineNum">      83 </span>            :       int k;
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :       for (k = 0; k &lt; TOTAL_STRENGTHS; k++) {</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :         uint64_t best = best_mse;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         uint64_t curr = mse[0][i][j];</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :         curr += mse[1][i][k];</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         if (curr &lt; best) best = curr;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         tot_mse[j][k] += best;</span>
<span class="lineNum">      90 </span>            :       }
<span class="lineNum">      91 </span>            :     }
<span class="lineNum">      92 </span>            :   }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   for (j = 0; j &lt; TOTAL_STRENGTHS; j++) {</span>
<span class="lineNum">      94 </span>            :     int k;
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     for (k = 0; k &lt; TOTAL_STRENGTHS; k++) {</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :       if (tot_mse[j][k] &lt; best_tot_mse) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :         best_tot_mse = tot_mse[j][k];</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :         best_id0 = j;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :         best_id1 = k;</span>
<span class="lineNum">     100 </span>            :       }
<span class="lineNum">     101 </span>            :     }
<span class="lineNum">     102 </span>            :   }
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   lev0[nb_strengths] = best_id0;</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :   lev1[nb_strengths] = best_id1;</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   return best_tot_mse;</span>
<span class="lineNum">     106 </span>            : }
<a name="107"><span class="lineNum">     107 </span>            : </a>
<span class="lineNum">     108 </span>            : /* Search for the set of strengths that minimizes mse. */
<span class="lineNum">     109 </span><span class="lineNoCov">          0 : static uint64_t joint_strength_search(int *best_lev, int nb_strengths,</span>
<span class="lineNum">     110 </span>            :                                       uint64_t mse[][TOTAL_STRENGTHS],
<span class="lineNum">     111 </span>            :                                       int sb_count) {
<span class="lineNum">     112 </span>            :   uint64_t best_tot_mse;
<span class="lineNum">     113 </span>            :   int i;
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   best_tot_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">     115 </span>            :   /* Greedy search: add one strength options at a time. */
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; nb_strengths; i++) {</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     best_tot_mse = search_one(best_lev, i, mse, sb_count);</span>
<span class="lineNum">     118 </span>            :   }
<span class="lineNum">     119 </span>            :   /* Trying to refine the greedy search by reconsidering each
<span class="lineNum">     120 </span>            :      already-selected option. */
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4 * nb_strengths; i++) {</span>
<span class="lineNum">     122 </span>            :     int j;
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; nb_strengths - 1; j++) best_lev[j] = best_lev[j + 1];</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     best_tot_mse = search_one(best_lev, nb_strengths - 1, mse, sb_count);</span>
<span class="lineNum">     125 </span>            :   }
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   return best_tot_mse;</span>
<span class="lineNum">     127 </span>            : }
<a name="128"><span class="lineNum">     128 </span>            : </a>
<span class="lineNum">     129 </span>            : /* Search for the set of luma+chroma strengths that minimizes mse. */
<span class="lineNum">     130 </span><span class="lineNoCov">          0 : static uint64_t joint_strength_search_dual(int *best_lev0, int *best_lev1,</span>
<span class="lineNum">     131 </span>            :                                            int nb_strengths,
<span class="lineNum">     132 </span>            :                                            uint64_t (**mse)[TOTAL_STRENGTHS],
<span class="lineNum">     133 </span>            :                                            int sb_count) {
<span class="lineNum">     134 </span>            :   uint64_t best_tot_mse;
<span class="lineNum">     135 </span>            :   int i;
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   best_tot_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">     137 </span>            :   /* Greedy search: add one strength options at a time. */
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; nb_strengths; i++) {</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     best_tot_mse = search_one_dual(best_lev0, best_lev1, i, mse, sb_count);</span>
<span class="lineNum">     140 </span>            :   }
<span class="lineNum">     141 </span>            :   /* Trying to refine the greedy search by reconsidering each
<span class="lineNum">     142 </span>            :      already-selected option. */
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4 * nb_strengths; i++) {</span>
<span class="lineNum">     144 </span>            :     int j;
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; nb_strengths - 1; j++) {</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :       best_lev0[j] = best_lev0[j + 1];</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :       best_lev1[j] = best_lev1[j + 1];</span>
<span class="lineNum">     148 </span>            :     }
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     best_tot_mse =</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         search_one_dual(best_lev0, best_lev1, nb_strengths - 1, mse, sb_count);</span>
<span class="lineNum">     151 </span>            :   }
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   return best_tot_mse;</span>
<span class="lineNum">     153 </span>            : }
<a name="154"><span class="lineNum">     154 </span>            : </a>
<span class="lineNum">     155 </span>            : /* FIXME: SSE-optimize this. */
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : static void copy_sb16_16(uint16_t *dst, int dstride, const uint16_t *src,</span>
<span class="lineNum">     157 </span>            :                          int src_voffset, int src_hoffset, int sstride,
<span class="lineNum">     158 </span>            :                          int vsize, int hsize) {
<span class="lineNum">     159 </span>            :   int r, c;
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   const uint16_t *base = &amp;src[src_voffset * sstride + src_hoffset];</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   for (r = 0; r &lt; vsize; r++) {</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     for (c = 0; c &lt; hsize; c++) {</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       dst[r * dstride + c] = base[r * sstride + c];</span>
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span>            :   }
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineNoCov">          0 : static INLINE uint64_t dist_8x8_16bit(uint16_t *dst, int dstride, uint16_t *src,</span>
<span class="lineNum">     169 </span>            :                                       int sstride, int coeff_shift) {
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   uint64_t svar = 0;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   uint64_t dvar = 0;</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   uint64_t sum_s = 0;</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   uint64_t sum_d = 0;</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   uint64_t sum_s2 = 0;</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   uint64_t sum_d2 = 0;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   uint64_t sum_sd = 0;</span>
<span class="lineNum">     177 </span>            :   int i, j;
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :       sum_s += src[i * sstride + j];</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       sum_d += dst[i * dstride + j];</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       sum_s2 += src[i * sstride + j] * src[i * sstride + j];</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       sum_d2 += dst[i * dstride + j] * dst[i * dstride + j];</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :       sum_sd += src[i * sstride + j] * dst[i * dstride + j];</span>
<span class="lineNum">     185 </span>            :     }
<span class="lineNum">     186 </span>            :   }
<span class="lineNum">     187 </span>            :   /* Compute the variance -- the calculation cannot go negative. */
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   svar = sum_s2 - ((sum_s * sum_s + 32) &gt;&gt; 6);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   dvar = sum_d2 - ((sum_d * sum_d + 32) &gt;&gt; 6);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   return (uint64_t)floor(</span>
<span class="lineNum">     191 </span>            :       .5 +
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :       (sum_d2 + sum_s2 - 2 * sum_sd) * .5 *</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :           (svar + dvar + (400 &lt;&lt; 2 * coeff_shift)) /</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :           (sqrt((20000 &lt;&lt; 4 * coeff_shift) + svar * (double)dvar)));</span>
<a name="195"><span class="lineNum">     195 </span>            : }</a>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 : static INLINE uint64_t mse_8x8_16bit(uint16_t *dst, int dstride, uint16_t *src,</span>
<span class="lineNum">     198 </span>            :                                      int sstride) {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   uint64_t sum = 0;</span>
<span class="lineNum">     200 </span>            :   int i, j;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 8; i++) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 8; j++) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       int e = dst[i * dstride + j] - src[i * sstride + j];</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :       sum += e * e;</span>
<span class="lineNum">     205 </span>            :     }
<span class="lineNum">     206 </span>            :   }
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   return sum;</span>
<a name="208"><span class="lineNum">     208 </span>            : }</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : static INLINE uint64_t mse_4x4_16bit(uint16_t *dst, int dstride, uint16_t *src,</span>
<span class="lineNum">     211 </span>            :                                      int sstride) {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :   uint64_t sum = 0;</span>
<span class="lineNum">     213 </span>            :   int i, j;
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 4; i++) {</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; 4; j++) {</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :       int e = dst[i * dstride + j] - src[i * sstride + j];</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :       sum += e * e;</span>
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span>            :   }
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   return sum;</span>
<span class="lineNum">     221 </span>            : }
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : /* Compute MSE only on the blocks we filtered. */
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : uint64_t compute_dering_dist(uint16_t *dst, int dstride, uint16_t *src,</span>
<span class="lineNum">     225 </span>            :                              dering_list *dlist, int dering_count,
<span class="lineNum">     226 </span>            :                              BLOCK_SIZE bsize, int coeff_shift, int pli) {
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   uint64_t sum = 0;</span>
<span class="lineNum">     228 </span>            :   int bi, bx, by;
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   if (bsize == BLOCK_8X8) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       if (pli == 0) {</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         sum += dist_8x8_16bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                               &amp;src[bi &lt;&lt; (3 + 3)], 8, coeff_shift);</span>
<span class="lineNum">     236 </span>            :       } else {
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         sum += mse_8x8_16bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                              &amp;src[bi &lt;&lt; (3 + 3)], 8);</span>
<span class="lineNum">     239 </span>            :       }
<span class="lineNum">     240 </span>            :     }
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_4X8) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :       sum += mse_4x4_16bit(&amp;dst[(by &lt;&lt; 3) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                            &amp;src[bi &lt;&lt; (3 + 2)], 4);</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       sum += mse_4x4_16bit(&amp;dst[((by &lt;&lt; 3) + 4) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                            &amp;src[(bi &lt;&lt; (3 + 2)) + 4 * 4], 4);</span>
<span class="lineNum">     249 </span>            :     }
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   } else if (bsize == BLOCK_8X4) {</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       sum += mse_4x4_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3)], dstride,</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                            &amp;src[bi &lt;&lt; (2 + 3)], 8);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       sum += mse_4x4_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 3) + 4], dstride,</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                            &amp;src[(bi &lt;&lt; (2 + 3)) + 4], 8);</span>
<span class="lineNum">     258 </span>            :     }
<span class="lineNum">     259 </span>            :   } else {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     assert(bsize == BLOCK_4X4);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :     for (bi = 0; bi &lt; dering_count; bi++) {</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :       by = dlist[bi].by;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :       bx = dlist[bi].bx;</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       sum += mse_4x4_16bit(&amp;dst[(by &lt;&lt; 2) * dstride + (bx &lt;&lt; 2)], dstride,</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                            &amp;src[bi &lt;&lt; (2 + 2)], 4);</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   return sum &gt;&gt; 2 * coeff_shift;</span>
<a name="269"><span class="lineNum">     269 </span>            : }</a>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineNoCov">          0 : void av1_cdef_search(YV12_BUFFER_CONFIG *frame, const YV12_BUFFER_CONFIG *ref,</span>
<span class="lineNum">     272 </span>            :                      AV1_COMMON *cm, MACROBLOCKD *xd) {
<span class="lineNum">     273 </span>            :   int r, c;
<span class="lineNum">     274 </span>            :   int sbr, sbc;
<span class="lineNum">     275 </span>            :   uint16_t *src[3];
<span class="lineNum">     276 </span>            :   uint16_t *ref_coeff[3];
<span class="lineNum">     277 </span>            :   dering_list dlist[MAX_MIB_SIZE * MAX_MIB_SIZE];
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   int dir[OD_DERING_NBLOCKS][OD_DERING_NBLOCKS] = { { 0 } };</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   int var[OD_DERING_NBLOCKS][OD_DERING_NBLOCKS] = { { 0 } };</span>
<span class="lineNum">     280 </span>            :   int stride[3];
<span class="lineNum">     281 </span>            :   int bsize[3];
<span class="lineNum">     282 </span>            :   int mi_wide_l2[3];
<span class="lineNum">     283 </span>            :   int mi_high_l2[3];
<span class="lineNum">     284 </span>            :   int xdec[3];
<span class="lineNum">     285 </span>            :   int ydec[3];
<span class="lineNum">     286 </span>            :   int pli;
<span class="lineNum">     287 </span>            :   int dering_count;
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   int coeff_shift = AOMMAX(cm-&gt;bit_depth - 8, 0);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   uint64_t best_tot_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">     290 </span>            :   uint64_t tot_mse;
<span class="lineNum">     291 </span>            :   int sb_count;
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   int nvsb = (cm-&gt;mi_rows + MAX_MIB_SIZE - 1) / MAX_MIB_SIZE;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   int nhsb = (cm-&gt;mi_cols + MAX_MIB_SIZE - 1) / MAX_MIB_SIZE;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   int *sb_index = aom_malloc(nvsb * nhsb * sizeof(*sb_index));</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   int *selected_strength = aom_malloc(nvsb * nhsb * sizeof(*sb_index));</span>
<span class="lineNum">     296 </span>            :   uint64_t(*mse[2])[TOTAL_STRENGTHS];
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   int clpf_damping = 3 + (cm-&gt;base_qindex &gt;&gt; 6);</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   int dering_damping = 6;</span>
<span class="lineNum">     299 </span>            :   int i;
<span class="lineNum">     300 </span>            :   int nb_strengths;
<span class="lineNum">     301 </span>            :   int nb_strength_bits;
<span class="lineNum">     302 </span>            :   int quantizer;
<span class="lineNum">     303 </span>            :   double lambda;
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   int nplanes = 3;</span>
<span class="lineNum">     305 </span>            :   DECLARE_ALIGNED(32, uint16_t, inbuf[OD_DERING_INBUF_SIZE]);
<span class="lineNum">     306 </span>            :   uint16_t *in;
<span class="lineNum">     307 </span>            :   DECLARE_ALIGNED(32, uint16_t, tmp_dst[MAX_SB_SQUARE]);
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   int chroma_dering =</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       xd-&gt;plane[1].subsampling_x == xd-&gt;plane[1].subsampling_y &amp;&amp;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       xd-&gt;plane[2].subsampling_x == xd-&gt;plane[2].subsampling_y;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   quantizer =</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :       av1_ac_quant(cm-&gt;base_qindex, 0, cm-&gt;bit_depth) &gt;&gt; (cm-&gt;bit_depth - 8);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   lambda = .12 * quantizer * quantizer / 256.;</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   av1_setup_dst_planes(xd-&gt;plane, cm-&gt;sb_size, frame, 0, 0);</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   mse[0] = aom_malloc(sizeof(**mse) * nvsb * nhsb);</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :   mse[1] = aom_malloc(sizeof(**mse) * nvsb * nhsb);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   for (pli = 0; pli &lt; nplanes; pli++) {</span>
<span class="lineNum">     319 </span>            :     uint8_t *ref_buffer;
<span class="lineNum">     320 </span>            :     int ref_stride;
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     switch (pli) {</span>
<span class="lineNum">     322 </span>            :       case 0:
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         ref_buffer = ref-&gt;y_buffer;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         ref_stride = ref-&gt;y_stride;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     326 </span>            :       case 1:
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         ref_buffer = ref-&gt;u_buffer;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         ref_stride = ref-&gt;uv_stride;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     330 </span>            :       case 2:
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         ref_buffer = ref-&gt;v_buffer;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         ref_stride = ref-&gt;uv_stride;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     334 </span>            :     }
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     src[pli] = aom_memalign(</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         32, sizeof(*src) * cm-&gt;mi_rows * cm-&gt;mi_cols * MI_SIZE * MI_SIZE);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     ref_coeff[pli] = aom_memalign(</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         32, sizeof(*ref_coeff) * cm-&gt;mi_rows * cm-&gt;mi_cols * MI_SIZE * MI_SIZE);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     xdec[pli] = xd-&gt;plane[pli].subsampling_x;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     ydec[pli] = xd-&gt;plane[pli].subsampling_y;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     bsize[pli] = ydec[pli] ? (xdec[pli] ? BLOCK_4X4 : BLOCK_8X4)</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                            : (xdec[pli] ? BLOCK_4X8 : BLOCK_8X8);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :     stride[pli] = cm-&gt;mi_cols &lt;&lt; MI_SIZE_LOG2;</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     mi_wide_l2[pli] = MI_SIZE_LOG2 - xd-&gt;plane[pli].subsampling_x;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     mi_high_l2[pli] = MI_SIZE_LOG2 - xd-&gt;plane[pli].subsampling_y;</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     const int frame_height =</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :         (cm-&gt;mi_rows * MI_SIZE) &gt;&gt; xd-&gt;plane[pli].subsampling_y;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     const int frame_width =</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         (cm-&gt;mi_cols * MI_SIZE) &gt;&gt; xd-&gt;plane[pli].subsampling_x;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     for (r = 0; r &lt; frame_height; ++r) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :       for (c = 0; c &lt; frame_width; ++c) {</span>
<span class="lineNum">     354 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         if (cm-&gt;use_highbitdepth) {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :           src[pli][r * stride[pli] + c] = CONVERT_TO_SHORTPTR(</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :               xd-&gt;plane[pli].dst.buf)[r * xd-&gt;plane[pli].dst.stride + c];</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :           ref_coeff[pli][r * stride[pli] + c] =</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :               CONVERT_TO_SHORTPTR(ref_buffer)[r * ref_stride + c];</span>
<span class="lineNum">     360 </span>            :         } else {
<span class="lineNum">     361 </span>            : #endif
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :           src[pli][r * stride[pli] + c] =</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :               xd-&gt;plane[pli].dst.buf[r * xd-&gt;plane[pli].dst.stride + c];</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :           ref_coeff[pli][r * stride[pli] + c] = ref_buffer[r * ref_stride + c];</span>
<span class="lineNum">     365 </span>            : #if CONFIG_HIGHBITDEPTH
<span class="lineNum">     366 </span>            :         }
<span class="lineNum">     367 </span>            : #endif
<span class="lineNum">     368 </span>            :       }
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            :   }
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   in = inbuf + OD_FILT_VBORDER * OD_FILT_BSTRIDE + OD_FILT_HBORDER;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   sb_count = 0;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   for (sbr = 0; sbr &lt; nvsb; ++sbr) {</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     for (sbc = 0; sbc &lt; nhsb; ++sbc) {</span>
<span class="lineNum">     375 </span>            :       int nvb, nhb;
<span class="lineNum">     376 </span>            :       int gi;
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       int dirinit = 0;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :       nhb = AOMMIN(MAX_MIB_SIZE, cm-&gt;mi_cols - MAX_MIB_SIZE * sbc);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :       nvb = AOMMIN(MAX_MIB_SIZE, cm-&gt;mi_rows - MAX_MIB_SIZE * sbr);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :       cm-&gt;mi_grid_visible[MAX_MIB_SIZE * sbr * cm-&gt;mi_stride +</span>
<span class="lineNum">     381 </span>            :                           MAX_MIB_SIZE * sbc]
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :           -&gt;mbmi.cdef_strength = -1;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :       if (sb_all_skip(cm, sbr * MAX_MIB_SIZE, sbc * MAX_MIB_SIZE)) continue;</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       dering_count = sb_compute_dering_list(cm, sbr * MAX_MIB_SIZE,</span>
<span class="lineNum">     385 </span>            :                                             sbc * MAX_MIB_SIZE, dlist, 1);
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       for (pli = 0; pli &lt; nplanes; pli++) {</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; OD_DERING_INBUF_SIZE; i++)</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :           inbuf[i] = OD_DERING_VERY_LARGE;</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         for (gi = 0; gi &lt; TOTAL_STRENGTHS; gi++) {</span>
<span class="lineNum">     390 </span>            :           int threshold;
<span class="lineNum">     391 </span>            :           uint64_t curr_mse;
<span class="lineNum">     392 </span>            :           int clpf_strength;
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :           threshold = gi / CLPF_STRENGTHS;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           if (pli &gt; 0 &amp;&amp; !chroma_dering) threshold = 0;</span>
<span class="lineNum">     395 </span>            :           /* We avoid filtering the pixels for which some of the pixels to
<span class="lineNum">     396 </span>            :              average
<span class="lineNum">     397 </span>            :              are outside the frame. We could change the filter instead, but it
<span class="lineNum">     398 </span>            :              would add special cases for any future vectorization. */
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :           int yoff = OD_FILT_VBORDER * (sbr != 0);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :           int xoff = OD_FILT_HBORDER * (sbc != 0);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :           int ysize = (nvb &lt;&lt; mi_high_l2[pli]) +</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                       OD_FILT_VBORDER * (sbr != nvsb - 1) + yoff;</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :           int xsize = (nhb &lt;&lt; mi_wide_l2[pli]) +</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                       OD_FILT_HBORDER * (sbc != nhsb - 1) + xoff;</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :           clpf_strength = gi % CLPF_STRENGTHS;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :           if (clpf_strength == 0)</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :             copy_sb16_16(&amp;in[(-yoff * OD_FILT_BSTRIDE - xoff)], OD_FILT_BSTRIDE,</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                          src[pli],</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :                          (sbr * MAX_MIB_SIZE &lt;&lt; mi_high_l2[pli]) - yoff,</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                          (sbc * MAX_MIB_SIZE &lt;&lt; mi_wide_l2[pli]) - xoff,</span>
<span class="lineNum">     411 </span>            :                          stride[pli], ysize, xsize);
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :           od_dering(clpf_strength ? NULL : (uint8_t *)in, OD_FILT_BSTRIDE,</span>
<span class="lineNum">     413 </span>            :                     tmp_dst, in, xdec[pli], ydec[pli], dir, &amp;dirinit, var, pli,
<span class="lineNum">     414 </span>            :                     dlist, dering_count, threshold,
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :                     clpf_strength + (clpf_strength == 3), clpf_damping,</span>
<span class="lineNum">     416 </span>            :                     dering_damping, coeff_shift, clpf_strength != 0, 1);
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :           curr_mse = compute_dering_dist(</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :               ref_coeff[pli] +</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :                   (sbr * MAX_MIB_SIZE &lt;&lt; mi_high_l2[pli]) * stride[pli] +</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :                   (sbc * MAX_MIB_SIZE &lt;&lt; mi_wide_l2[pli]),</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :               stride[pli], tmp_dst, dlist, dering_count, bsize[pli],</span>
<span class="lineNum">     422 </span>            :               coeff_shift, pli);
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :           if (pli &lt; 2)</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :             mse[pli][sb_count][gi] = curr_mse;</span>
<span class="lineNum">     425 </span>            :           else
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             mse[1][sb_count][gi] += curr_mse;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :           sb_index[sb_count] =</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :               MAX_MIB_SIZE * sbr * cm-&gt;mi_stride + MAX_MIB_SIZE * sbc;</span>
<span class="lineNum">     429 </span>            :         }
<span class="lineNum">     430 </span>            :       }
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       sb_count++;</span>
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            :   }
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :   nb_strength_bits = 0;</span>
<span class="lineNum">     435 </span>            :   /* Search for different number of signalling bits. */
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt;= 3; i++) {</span>
<span class="lineNum">     437 </span>            :     int j;
<span class="lineNum">     438 </span>            :     int best_lev0[CDEF_MAX_STRENGTHS];
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     int best_lev1[CDEF_MAX_STRENGTHS] = { 0 };</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     nb_strengths = 1 &lt;&lt; i;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :     if (nplanes &gt;= 3)</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :       tot_mse = joint_strength_search_dual(best_lev0, best_lev1, nb_strengths,</span>
<span class="lineNum">     443 </span>            :                                            mse, sb_count);
<span class="lineNum">     444 </span>            :     else
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :       tot_mse =</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :           joint_strength_search(best_lev0, nb_strengths, mse[0], sb_count);</span>
<span class="lineNum">     447 </span>            :     /* Count superblock signalling cost. */
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     tot_mse += (uint64_t)(sb_count * lambda * i);</span>
<span class="lineNum">     449 </span>            :     /* Count header signalling cost. */
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :     tot_mse += (uint64_t)(nb_strengths * lambda * CDEF_STRENGTH_BITS);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     if (tot_mse &lt; best_tot_mse) {</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :       best_tot_mse = tot_mse;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :       nb_strength_bits = i;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :       for (j = 0; j &lt; 1 &lt;&lt; nb_strength_bits; j++) {</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :         cm-&gt;cdef_strengths[j] = best_lev0[j];</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         cm-&gt;cdef_uv_strengths[j] = best_lev1[j];</span>
<span class="lineNum">     457 </span>            :       }
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span>            :   }
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :   nb_strengths = 1 &lt;&lt; nb_strength_bits;</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :   cm-&gt;cdef_bits = nb_strength_bits;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :   cm-&gt;nb_cdef_strengths = nb_strengths;</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; sb_count; i++) {</span>
<span class="lineNum">     465 </span>            :     int gi;
<span class="lineNum">     466 </span>            :     int best_gi;
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     uint64_t best_mse = (uint64_t)1 &lt;&lt; 63;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     best_gi = 0;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     for (gi = 0; gi &lt; cm-&gt;nb_cdef_strengths; gi++) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       uint64_t curr = mse[0][i][cm-&gt;cdef_strengths[gi]];</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       if (nplanes &gt;= 3) curr += mse[1][i][cm-&gt;cdef_uv_strengths[gi]];</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       if (curr &lt; best_mse) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         best_gi = gi;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :         best_mse = curr;</span>
<span class="lineNum">     475 </span>            :       }
<span class="lineNum">     476 </span>            :     }
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     selected_strength[i] = best_gi;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     cm-&gt;mi_grid_visible[sb_index[i]]-&gt;mbmi.cdef_strength = best_gi;</span>
<span class="lineNum">     479 </span>            :   }
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   cm-&gt;cdef_dering_damping = dering_damping;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   cm-&gt;cdef_clpf_damping = clpf_damping;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   aom_free(mse[0]);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   aom_free(mse[1]);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   for (pli = 0; pli &lt; nplanes; pli++) {</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     aom_free(src[pli]);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     aom_free(ref_coeff[pli]);</span>
<span class="lineNum">     487 </span>            :   }
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :   aom_free(sb_index);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   aom_free(selected_strength);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

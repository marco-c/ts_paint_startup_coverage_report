<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - accessible/generic/HyperTextAccessible.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">accessible/generic</a> - HyperTextAccessible.cpp<span style="font-size: 80%;"> (source / <a href="HyperTextAccessible.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1144</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">56</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=2 sw=2 et tw=78: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;HyperTextAccessible-inl.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;Accessible-inl.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsAccessibilityService.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsIAccessibleTypes.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;DocAccessible.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;HTMLListAccessible.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;Role.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;States.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;TextAttrs.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;TextRange.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;TreeWalker.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;nsCaret.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsFocusManager.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIDOMRange.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIEditingSession.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsContainerFrame.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsFrameSelection.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsILineIterator.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsIInterfaceRequestorUtils.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsIPersistentProperties2.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsIScrollableFrame.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsITextControlElement.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsIMathMLFrame.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsTextFragment.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;mozilla/BinarySearch.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;mozilla/dom/Element.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;mozilla/EventStates.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;mozilla/dom/Selection.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;gfxSkipChars.h&quot;
<span class="lineNum">      41 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : using namespace mozilla;
<span class="lineNum">      44 </span>            : using namespace mozilla::a11y;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      47 </span>            : // HyperTextAccessible
<a name="48"><span class="lineNum">      48 </span>            : ////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span><span class="lineNoCov">          0 : HyperTextAccessible::</span>
<span class="lineNum">      51 </span><span class="lineNoCov">          0 :   HyperTextAccessible(nsIContent* aNode, DocAccessible* aDoc) :</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :   AccessibleWrap(aNode, aDoc)</span>
<span class="lineNum">      53 </span>            : {
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   mType = eHyperTextType;</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   mGenericTypes |= eHyperText;</span>
<a name="56"><span class="lineNum">      56 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : NS_IMPL_ISUPPORTS_INHERITED0(HyperTextAccessible, Accessible)</span>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<span class="lineNum">      60 </span>            : role
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : HyperTextAccessible::NativeRole()</span>
<span class="lineNum">      62 </span>            : {
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :   a11y::role r = GetAccService()-&gt;MarkupRole(mContent);</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :   if (r != roles::NOTHING)</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :   nsIFrame* frame = GetFrame();</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   if (frame &amp;&amp; frame-&gt;IsInlineFrame())</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :     return roles::TEXT;</span>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   return roles::TEXT_CONTAINER;</span>
<span class="lineNum">      72 </span>            : }
<a name="73"><span class="lineNum">      73 </span>            : </a>
<span class="lineNum">      74 </span>            : uint64_t
<span class="lineNum">      75 </span><span class="lineNoCov">          0 : HyperTextAccessible::NativeState()</span>
<span class="lineNum">      76 </span>            : {
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   uint64_t states = AccessibleWrap::NativeState();</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   if (mContent-&gt;AsElement()-&gt;State().HasState(NS_EVENT_STATE_MOZ_READWRITE)) {</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     states |= states::EDITABLE;</span>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :   } else if (mContent-&gt;IsHTMLElement(nsGkAtoms::article)) {</span>
<span class="lineNum">      83 </span>            :     // We want &lt;article&gt; to behave like a document in terms of readonly state.
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     states |= states::READONLY;</span>
<span class="lineNum">      85 </span>            :   }
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :   if (HasChildren())</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     states |= states::SELECTABLE_TEXT;</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   return states;</span>
<span class="lineNum">      91 </span>            : }
<a name="92"><span class="lineNum">      92 </span>            : </a>
<span class="lineNum">      93 </span>            : nsIntRect
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetBoundsInFrame(nsIFrame* aFrame,</span>
<span class="lineNum">      95 </span>            :                                       uint32_t aStartRenderedOffset,
<span class="lineNum">      96 </span>            :                                       uint32_t aEndRenderedOffset)
<span class="lineNum">      97 </span>            : {
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mDoc-&gt;PresContext();</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   if (!aFrame-&gt;IsTextFrame()) {</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     return aFrame-&gt;GetScreenRectInAppUnits().</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :       ToNearestPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">     102 </span>            :   }
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :   // Substring must be entirely within the same text node.
<span class="lineNum">     105 </span>            :   int32_t startContentOffset, endContentOffset;
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   nsresult rv = RenderedToContentOffset(aFrame, aStartRenderedOffset, &amp;startContentOffset);</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, nsIntRect());</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   rv = RenderedToContentOffset(aFrame, aEndRenderedOffset, &amp;endContentOffset);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, nsIntRect());</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   nsIFrame *frame;
<span class="lineNum">     112 </span>            :   int32_t startContentOffsetInFrame;
<span class="lineNum">     113 </span>            :   // Get the right frame continuation -- not really a child, but a sibling of
<span class="lineNum">     114 </span>            :   // the primary frame passed in
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   rv = aFrame-&gt;GetChildFrameContainingOffset(startContentOffset, false,</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                                              &amp;startContentOffsetInFrame, &amp;frame);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS(rv, nsIntRect());</span>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   nsRect screenRect;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   while (frame &amp;&amp; startContentOffset &lt; endContentOffset) {</span>
<span class="lineNum">     121 </span>            :     // Start with this frame's screen rect, which we will shrink based on
<span class="lineNum">     122 </span>            :     // the substring we care about within it. We will then add that frame to
<span class="lineNum">     123 </span>            :     // the total screenRect we are returning.
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     nsRect frameScreenRect = frame-&gt;GetScreenRectInAppUnits();</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :     // Get the length of the substring in this frame that we want the bounds for
<span class="lineNum">     127 </span>            :     int32_t startFrameTextOffset, endFrameTextOffset;
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     frame-&gt;GetOffsets(startFrameTextOffset, endFrameTextOffset);</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     int32_t frameTotalTextLength = endFrameTextOffset - startFrameTextOffset;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     int32_t seekLength = endContentOffset - startContentOffset;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     int32_t frameSubStringLength = std::min(frameTotalTextLength - startContentOffsetInFrame, seekLength);</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     // Add the point where the string starts to the frameScreenRect
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     nsPoint frameTextStartPoint;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     rv = frame-&gt;GetPointFromOffset(startContentOffset, &amp;frameTextStartPoint);</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, nsIntRect());</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     // Use the point for the end offset to calculate the width
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     nsPoint frameTextEndPoint;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :     rv = frame-&gt;GetPointFromOffset(startContentOffset + frameSubStringLength, &amp;frameTextEndPoint);</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, nsIntRect());</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     frameScreenRect.x += std::min(frameTextStartPoint.x, frameTextEndPoint.x);</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     frameScreenRect.width = mozilla::Abs(frameTextStartPoint.x - frameTextEndPoint.x);</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     screenRect.UnionRect(frameScreenRect, screenRect);</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     // Get ready to loop back for next frame continuation
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     startContentOffset += frameSubStringLength;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     startContentOffsetInFrame = 0;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     frame = frame-&gt;GetNextContinuation();</span>
<span class="lineNum">     152 </span>            :   }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   return screenRect.ToNearestPixels(presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">     155 </span>            : }
<a name="156"><span class="lineNum">     156 </span>            : </a>
<span class="lineNum">     157 </span>            : void
<span class="lineNum">     158 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextSubstring(int32_t aStartOffset, int32_t aEndOffset,</span>
<span class="lineNum">     159 </span>            :                                    nsAString&amp; aText)
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :   aText.Truncate();</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   index_t startOffset = ConvertMagicOffset(aStartOffset);</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   index_t endOffset = ConvertMagicOffset(aEndOffset);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   if (!startOffset.IsValid() || !endOffset.IsValid() ||</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :       startOffset &gt; endOffset || endOffset &gt; CharacterCount()) {</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset&quot;);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     169 </span>            :   }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   int32_t startChildIdx = GetChildIndexAtOffset(startOffset);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   if (startChildIdx == -1)</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   int32_t endChildIdx = GetChildIndexAtOffset(endOffset);</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   if (endChildIdx == -1)</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :   if (startChildIdx == endChildIdx) {</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     int32_t childOffset =  GetChildOffset(startChildIdx);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     if (childOffset == -1)</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     Accessible* child = GetChildAt(startChildIdx);</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :     child-&gt;AppendTextTo(aText, startOffset - childOffset,</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                         endOffset - startOffset);</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     188 </span>            :   }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   int32_t startChildOffset =  GetChildOffset(startChildIdx);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   if (startChildOffset == -1)</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :   Accessible* startChild = GetChildAt(startChildIdx);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   startChild-&gt;AppendTextTo(aText, startOffset - startChildOffset);</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   for (int32_t childIdx = startChildIdx + 1; childIdx &lt; endChildIdx; childIdx++) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     Accessible* child = GetChildAt(childIdx);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     child-&gt;AppendTextTo(aText);</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   int32_t endChildOffset =  GetChildOffset(endChildIdx);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   if (endChildOffset == -1)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   Accessible* endChild = GetChildAt(endChildIdx);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   endChild-&gt;AppendTextTo(aText, 0, endOffset - endChildOffset);</span>
<span class="lineNum">     208 </span>            : }
<a name="209"><span class="lineNum">     209 </span>            : </a>
<span class="lineNum">     210 </span>            : uint32_t
<span class="lineNum">     211 </span><span class="lineNoCov">          0 : HyperTextAccessible::DOMPointToOffset(nsINode* aNode, int32_t aNodeOffset,</span>
<span class="lineNum">     212 </span>            :                                       bool aIsEndOffset) const
<span class="lineNum">     213 </span>            : {
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   if (!aNode)</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   uint32_t offset = 0;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   nsINode* findNode = nullptr;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   if (aNodeOffset == -1) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     findNode = aNode;</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   } else if (aNode-&gt;IsNodeOfType(nsINode::eTEXT)) {</span>
<span class="lineNum">     224 </span>            :     // For text nodes, aNodeOffset comes in as a character offset
<span class="lineNum">     225 </span>            :     // Text offset will be added at the end, if we find the offset in this hypertext
<span class="lineNum">     226 </span>            :     // We want the &quot;skipped&quot; offset into the text (rendered text without the extra whitespace)
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     nsIFrame* frame = aNode-&gt;AsContent()-&gt;GetPrimaryFrame();</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(frame, 0);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     nsresult rv = ContentToRenderedOffset(frame, aNodeOffset, &amp;offset);</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, 0);</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     findNode = aNode;</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   } else {
<span class="lineNum">     236 </span>            :     // findNode could be null if aNodeOffset == # of child nodes, which means
<span class="lineNum">     237 </span>            :     // one of two things:
<span class="lineNum">     238 </span>            :     // 1) there are no children, and the passed-in node is not mContent -- use
<span class="lineNum">     239 </span>            :     //    parentContent for the node to find
<span class="lineNum">     240 </span>            :     // 2) there are no children and the passed-in node is mContent, which means
<span class="lineNum">     241 </span>            :     //    we're an empty nsIAccessibleText
<span class="lineNum">     242 </span>            :     // 3) there are children and we're at the end of the children
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     findNode = aNode-&gt;GetChildAt(aNodeOffset);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (!findNode) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       if (aNodeOffset == 0) {</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         if (aNode == GetNode()) {</span>
<span class="lineNum">     248 </span>            :           // Case #1: this accessible has no children and thus has empty text,
<span class="lineNum">     249 </span>            :           // we can only be at hypertext offset 0.
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     251 </span>            :         }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            :         // Case #2: there are no children, we're at this node.
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         findNode = aNode;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       } else if (aNodeOffset == static_cast&lt;int32_t&gt;(aNode-&gt;GetChildCount())) {</span>
<span class="lineNum">     256 </span>            :         // Case #3: we're after the last child, get next node to this one.
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :         for (nsINode* tmpNode = aNode;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :              !findNode &amp;&amp; tmpNode &amp;&amp; tmpNode != mContent;</span>
<span class="lineNum">     259 </span>            :              tmpNode = tmpNode-&gt;GetParent()) {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :           findNode = tmpNode-&gt;GetNextSibling();</span>
<span class="lineNum">     261 </span>            :         }
<span class="lineNum">     262 </span>            :       }
<span class="lineNum">     263 </span>            :     }
<span class="lineNum">     264 </span>            :   }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   // Get accessible for this findNode, or if that node isn't accessible, use the
<span class="lineNum">     267 </span>            :   // accessible for the next DOM node which has one (based on forward depth first search)
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   Accessible* descendant = nullptr;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   if (findNode) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIContent&gt; findContent(do_QueryInterface(findNode));</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     if (findContent &amp;&amp; findContent-&gt;IsHTMLElement() &amp;&amp;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         findContent-&gt;NodeInfo()-&gt;Equals(nsGkAtoms::br) &amp;&amp;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         findContent-&gt;AttrValueIs(kNameSpaceID_None,</span>
<span class="lineNum">     274 </span>            :                                  nsGkAtoms::mozeditorbogusnode,
<span class="lineNum">     275 </span>            :                                  nsGkAtoms::_true,
<span class="lineNum">     276 </span>            :                                  eIgnoreCase)) {
<span class="lineNum">     277 </span>            :       // This &lt;br&gt; is the hacky &quot;bogus node&quot; used when there is no text in a control
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     279 </span>            :     }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     descendant = mDoc-&gt;GetAccessible(findNode);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     if (!descendant &amp;&amp; findNode-&gt;IsContent()) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :       Accessible* container = mDoc-&gt;GetContainerAccessible(findNode);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :       if (container) {</span>
<span class="lineNum">     285 </span>            :         TreeWalker walker(container, findNode-&gt;AsContent(),
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                           TreeWalker::eWalkContextTree);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         descendant = walker.Next();</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         if (!descendant)</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :           descendant = container;</span>
<span class="lineNum">     290 </span>            :       }
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   return TransformOffset(descendant, offset, aIsEndOffset);</span>
<span class="lineNum">     295 </span>            : }
<a name="296"><span class="lineNum">     296 </span>            : </a>
<span class="lineNum">     297 </span>            : uint32_t
<span class="lineNum">     298 </span><span class="lineNoCov">          0 : HyperTextAccessible::TransformOffset(Accessible* aDescendant,</span>
<span class="lineNum">     299 </span>            :                                      uint32_t aOffset, bool aIsEndOffset) const
<span class="lineNum">     300 </span>            : {
<span class="lineNum">     301 </span>            :   // From the descendant, go up and get the immediate child of this hypertext.
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   uint32_t offset = aOffset;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   Accessible* descendant = aDescendant;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   while (descendant) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     Accessible* parent = descendant-&gt;Parent();</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     if (parent == this)</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :       return GetChildOffset(descendant) + offset;</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :     // This offset no longer applies because the passed-in text object is not
<span class="lineNum">     310 </span>            :     // a child of the hypertext. This happens when there are nested hypertexts,
<span class="lineNum">     311 </span>            :     // e.g. &lt;div&gt;abc&lt;h1&gt;def&lt;/h1&gt;ghi&lt;/div&gt;. Thus we need to adjust the offset
<span class="lineNum">     312 </span>            :     // to make it relative the hypertext.
<span class="lineNum">     313 </span>            :     // If the end offset is not supposed to be inclusive and the original point
<span class="lineNum">     314 </span>            :     // is not at 0 offset then the returned offset should be after an embedded
<span class="lineNum">     315 </span>            :     // character the original point belongs to.
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     if (aIsEndOffset)</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :       offset = (offset &gt; 0 || descendant-&gt;IndexInParent() &gt; 0) ? 1 : 0;</span>
<span class="lineNum">     318 </span>            :     else
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       offset = 0;</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     descendant = parent;</span>
<span class="lineNum">     322 </span>            :   }
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :   // If the given a11y point cannot be mapped into offset relative this hypertext
<span class="lineNum">     325 </span>            :   // offset then return length as fallback value.
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   return CharacterCount();</span>
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /**
<span class="lineNum">     330 </span>            :  * GetElementAsContentOf() returns a content representing an element which is
<span class="lineNum">     331 </span>            :  * or includes aNode.
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  * XXX This method is enough to retrieve ::before or ::after pseudo element.
<span class="lineNum">     334 </span>            :  *     So, if you want to use this for other purpose, you might need to check
<a name="335"><span class="lineNum">     335 </span>            :  *     ancestors too.</a>
<span class="lineNum">     336 </span>            :  */
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : static nsIContent* GetElementAsContentOf(nsINode* aNode)</span>
<span class="lineNum">     338 </span>            : {
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   if (aNode-&gt;IsElement()) {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     return aNode-&gt;AsContent();</span>
<span class="lineNum">     341 </span>            :   }
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   nsIContent* parent = aNode-&gt;GetParent();</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   return parent &amp;&amp; parent-&gt;IsElement() ? parent : nullptr;</span>
<span class="lineNum">     344 </span>            : }
<a name="345"><span class="lineNum">     345 </span>            : </a>
<span class="lineNum">     346 </span>            : bool
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : HyperTextAccessible::OffsetsToDOMRange(int32_t aStartOffset, int32_t aEndOffset,</span>
<span class="lineNum">     348 </span>            :                                        nsRange* aRange)
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :   DOMPoint startPoint = OffsetToDOMPoint(aStartOffset);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   if (!startPoint.node)</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :   // HyperTextAccessible manages pseudo elements generated by ::before or
<span class="lineNum">     355 </span>            :   // ::after.  However, contents of them are not in the DOM tree normally.
<span class="lineNum">     356 </span>            :   // Therefore, they are not selectable and editable.  So, when this creates
<span class="lineNum">     357 </span>            :   // a DOM range, it should not start from nor end in any pseudo contents.
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   nsIContent* container = GetElementAsContentOf(startPoint.node);</span>
<span class="lineNum">     360 </span>            :   DOMPoint startPointForDOMRange =
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :     ClosestNotGeneratedDOMPoint(startPoint, container);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   aRange-&gt;SetStart(startPointForDOMRange.node, startPointForDOMRange.idx);</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   // If the caller wants collapsed range, let's collapse the range to its start.
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (aStartOffset == aEndOffset) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     aRange-&gt;Collapse(true);</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :   DOMPoint endPoint = OffsetToDOMPoint(aEndOffset);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   if (!endPoint.node)</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   if (startPoint.node != endPoint.node) {</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     container = GetElementAsContentOf(endPoint.node);</span>
<span class="lineNum">     376 </span>            :   }
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            :   DOMPoint endPointForDOMRange =
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     ClosestNotGeneratedDOMPoint(endPoint, container);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   aRange-&gt;SetEnd(endPointForDOMRange.node, endPointForDOMRange.idx);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     382 </span>            : }
<a name="383"><span class="lineNum">     383 </span>            : </a>
<span class="lineNum">     384 </span>            : DOMPoint
<span class="lineNum">     385 </span><span class="lineNoCov">          0 : HyperTextAccessible::OffsetToDOMPoint(int32_t aOffset)</span>
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span>            :   // 0 offset is valid even if no children. In this case the associated editor
<span class="lineNum">     388 </span>            :   // is empty so return a DOM point for editor root element.
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   if (aOffset == 0) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIEditor&gt; editor = GetEditor();</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     if (editor) {</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :       bool isEmpty = false;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       editor-&gt;GetDocumentIsEmpty(&amp;isEmpty);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       if (isEmpty) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsIDOMElement&gt; editorRootElm;</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         editor-&gt;GetRootElement(getter_AddRefs(editorRootElm));</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsINode&gt; editorRoot(do_QueryInterface(editorRootElm));</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         return DOMPoint(editorRoot, 0);</span>
<span class="lineNum">     400 </span>            :       }
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   int32_t childIdx = GetChildIndexAtOffset(aOffset);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if (childIdx == -1)</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     return DOMPoint();</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :   Accessible* child = GetChildAt(childIdx);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   int32_t innerOffset = aOffset - GetChildOffset(childIdx);</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   // A text leaf case.
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   if (child-&gt;IsTextLeaf()) {</span>
<span class="lineNum">     413 </span>            :     // The point is inside the text node. This is always true for any text leaf
<span class="lineNum">     414 </span>            :     // except a last child one. See assertion below.
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :     if (aOffset &lt; GetChildOffset(childIdx + 1)) {</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       nsIContent* content = child-&gt;GetContent();</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       int32_t idx = 0;</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       if (NS_FAILED(RenderedToContentOffset(content-&gt;GetPrimaryFrame(),</span>
<span class="lineNum">     419 </span>            :                                             innerOffset, &amp;idx)))
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         return DOMPoint();</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       return DOMPoint(content, idx);</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     // Set the DOM point right after the text node.
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(static_cast&lt;uint32_t&gt;(aOffset) == CharacterCount());</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     innerOffset = 1;</span>
<span class="lineNum">     428 </span>            :   }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :   // Case of embedded object. The point is either before or after the element.
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   NS_ASSERTION(innerOffset == 0 || innerOffset == 1, &quot;A wrong inner offset!&quot;);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   nsINode* node = child-&gt;GetNode();</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :   nsINode* parentNode = node-&gt;GetParentNode();</span>
<span class="lineNum">     434 </span>            :   return parentNode ?
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     DOMPoint(parentNode, parentNode-&gt;IndexOf(node) + innerOffset) :</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     DOMPoint();</span>
<span class="lineNum">     437 </span>            : }
<a name="438"><span class="lineNum">     438 </span>            : </a>
<span class="lineNum">     439 </span>            : DOMPoint
<span class="lineNum">     440 </span><span class="lineNoCov">          0 : HyperTextAccessible::ClosestNotGeneratedDOMPoint(const DOMPoint&amp; aDOMPoint,</span>
<span class="lineNum">     441 </span>            :                                                  nsIContent* aElementContent)
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aDOMPoint.node, &quot;The node must not be null&quot;);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // ::before pseudo element
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if (aElementContent &amp;&amp;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       aElementContent-&gt;IsGeneratedContentContainerForBefore()) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aElementContent-&gt;GetParent(),</span>
<span class="lineNum">     449 </span>            :                &quot;::before must have parent element&quot;);
<span class="lineNum">     450 </span>            :     // The first child of its parent (i.e., immediately after the ::before) is
<span class="lineNum">     451 </span>            :     // good point for a DOM range.
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     return DOMPoint(aElementContent-&gt;GetParent(), 0);</span>
<span class="lineNum">     453 </span>            :   }
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            :   // ::after pseudo element
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   if (aElementContent &amp;&amp;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       aElementContent-&gt;IsGeneratedContentContainerForAfter()) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aElementContent-&gt;GetParent(),</span>
<span class="lineNum">     459 </span>            :                &quot;::after must have parent element&quot;);
<span class="lineNum">     460 </span>            :     // The end of its parent (i.e., immediately before the ::after) is good
<span class="lineNum">     461 </span>            :     // point for a DOM range.
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     return DOMPoint(aElementContent-&gt;GetParent(),</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :                     aElementContent-&gt;GetParent()-&gt;GetChildCount());</span>
<span class="lineNum">     464 </span>            :   }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   return aDOMPoint;</span>
<span class="lineNum">     467 </span>            : }
<a name="468"><span class="lineNum">     468 </span>            : </a>
<span class="lineNum">     469 </span>            : uint32_t
<span class="lineNum">     470 </span><span class="lineNoCov">          0 : HyperTextAccessible::FindOffset(uint32_t aOffset, nsDirection aDirection,</span>
<span class="lineNum">     471 </span>            :                                 nsSelectionAmount aAmount,
<span class="lineNum">     472 </span>            :                                 EWordMovementType aWordMovementType)
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aDirection == eDirPrevious || aAmount != eSelectBeginLine,</span>
<span class="lineNum">     475 </span>            :                &quot;eSelectBeginLine should only be used with eDirPrevious&quot;);
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   // Find a leaf accessible frame to start with. PeekOffset wants this.
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   HyperTextAccessible* text = this;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   Accessible* child = nullptr;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   int32_t innerOffset = aOffset;</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   do {</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     int32_t childIdx = text-&gt;GetChildIndexAtOffset(innerOffset);</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :     // We can have an empty text leaf as our only child. Since empty text
<span class="lineNum">     486 </span>            :     // leaves are not accessible we then have no children, but 0 is a valid
<span class="lineNum">     487 </span>            :     // innerOffset.
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     if (childIdx == -1) {</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       NS_ASSERTION(innerOffset == 0 &amp;&amp; !text-&gt;ChildCount(), &quot;No childIdx?&quot;);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       return DOMPointToOffset(text-&gt;GetNode(), 0, aDirection == eDirNext);</span>
<span class="lineNum">     491 </span>            :     }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     child = text-&gt;GetChildAt(childIdx);</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :     // HTML list items may need special processing because PeekOffset doesn't
<span class="lineNum">     496 </span>            :     // work with list bullets.
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     if (text-&gt;IsHTMLListItem()) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       HTMLLIAccessible* li = text-&gt;AsHTMLListItem();</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       if (child == li-&gt;Bullet()) {</span>
<span class="lineNum">     500 </span>            :         // XXX: the logic is broken for multichar bullets in moving by
<span class="lineNum">     501 </span>            :         // char/cluster/word cases.
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         if (text != this) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           return aDirection == eDirPrevious ?</span>
<span class="lineNum">     504 </span>            :             TransformOffset(text, 0, false) :
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :             TransformOffset(text, 1, true);</span>
<span class="lineNum">     506 </span>            :         }
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         if (aDirection == eDirPrevious)</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         uint32_t nextOffset = GetChildOffset(1);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         if (nextOffset == 0)</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         switch (aAmount) {</span>
<span class="lineNum">     515 </span>            :           case eSelectLine:
<span class="lineNum">     516 </span>            :           case eSelectEndLine:
<span class="lineNum">     517 </span>            :             // Ask a text leaf next (if not empty) to the bullet for an offset
<span class="lineNum">     518 </span>            :             // since list item may be multiline.
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :             return nextOffset &lt; CharacterCount() ?</span>
<span class="lineNum">     520 </span>            :               FindOffset(nextOffset, aDirection, aAmount, aWordMovementType) :
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :               nextOffset;</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :           default:
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :             return nextOffset;</span>
<span class="lineNum">     525 </span>            :         }
<span class="lineNum">     526 </span>            :       }
<span class="lineNum">     527 </span>            :     }
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     innerOffset -= text-&gt;GetChildOffset(childIdx);</span>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :     text = child-&gt;AsHyperText();</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   } while (text);</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   nsIFrame* childFrame = child-&gt;GetFrame();</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   if (!childFrame) {</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;No child frame&quot;);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     538 </span>            :   }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   int32_t innerContentOffset = innerOffset;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   if (child-&gt;IsTextLeaf()) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     NS_ASSERTION(childFrame-&gt;IsTextFrame(), &quot;Wrong frame!&quot;);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     RenderedToContentOffset(childFrame, innerOffset, &amp;innerContentOffset);</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   nsIFrame* frameAtOffset = childFrame;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   int32_t unusedOffsetInFrame = 0;</span>
<span class="lineNum">     548 </span>            :   childFrame-&gt;GetChildFrameContainingOffset(innerContentOffset, true,
<span class="lineNum">     549 </span>            :                                             &amp;unusedOffsetInFrame,
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                                             &amp;frameAtOffset);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   const bool kIsJumpLinesOk = true; // okay to jump lines</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   const bool kIsScrollViewAStop = false; // do not stop at scroll views</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :   const bool kIsKeyboardSelect = true; // is keyboard selection</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :   const bool kIsVisualBidi = false; // use visual order for bidi text</span>
<span class="lineNum">     556 </span>            :   nsPeekOffsetStruct pos(aAmount, aDirection, innerContentOffset,
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                          nsPoint(0, 0), kIsJumpLinesOk, kIsScrollViewAStop,</span>
<span class="lineNum">     558 </span>            :                          kIsKeyboardSelect, kIsVisualBidi,
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :                          false, aWordMovementType);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   nsresult rv = frameAtOffset-&gt;PeekOffset(&amp;pos);</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :   // PeekOffset fails on last/first lines of the text in certain cases.
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   if (NS_FAILED(rv) &amp;&amp; aAmount == eSelectLine) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     pos.mAmount = (aDirection == eDirNext) ? eSelectEndLine : eSelectBeginLine;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     frameAtOffset-&gt;PeekOffset(&amp;pos);</span>
<span class="lineNum">     566 </span>            :   }
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   if (!pos.mResultContent) {</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;No result content!&quot;);</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     570 </span>            :   }
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :   // Turn the resulting DOM point into an offset.
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   uint32_t hyperTextOffset = DOMPointToOffset(pos.mResultContent,</span>
<span class="lineNum">     574 </span>            :                                               pos.mContentOffset,
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                                               aDirection == eDirNext);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :   if (aDirection == eDirPrevious) {</span>
<span class="lineNum">     578 </span>            :     // If we reached the end during search, this means we didn't find the DOM point
<span class="lineNum">     579 </span>            :     // and we're actually at the start of the paragraph
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     if (hyperTextOffset == CharacterCount())</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :     // PeekOffset stops right before bullet so return 0 to workaround it.
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     if (IsHTMLListItem() &amp;&amp; aAmount == eSelectBeginLine &amp;&amp;</span>
<span class="lineNum">     585 </span>            :         hyperTextOffset &gt; 0) {
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       Accessible* prevOffsetChild = GetChildAtOffset(hyperTextOffset - 1);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       if (prevOffsetChild == AsHTMLListItem()-&gt;Bullet())</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     589 </span>            :     }
<span class="lineNum">     590 </span>            :   }
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   return hyperTextOffset;</span>
<span class="lineNum">     593 </span>            : }
<a name="594"><span class="lineNum">     594 </span>            : </a>
<span class="lineNum">     595 </span>            : uint32_t
<span class="lineNum">     596 </span><span class="lineNoCov">          0 : HyperTextAccessible::FindLineBoundary(uint32_t aOffset,</span>
<span class="lineNum">     597 </span>            :                                       EWhichLineBoundary aWhichLineBoundary)
<span class="lineNum">     598 </span>            : {
<span class="lineNum">     599 </span>            :   // Note: empty last line doesn't have own frame (a previous line contains '\n'
<span class="lineNum">     600 </span>            :   // character instead) thus when it makes a difference we need to process this
<span class="lineNum">     601 </span>            :   // case separately (otherwise operations are performed on previous line).
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   switch (aWhichLineBoundary) {</span>
<span class="lineNum">     603 </span>            :     case ePrevLineBegin: {
<span class="lineNum">     604 </span>            :       // Fetch a previous line and move to its start (as arrow up and home keys
<span class="lineNum">     605 </span>            :       // were pressed).
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :         return FindOffset(aOffset, eDirPrevious, eSelectBeginLine);</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       uint32_t tmpOffset = FindOffset(aOffset, eDirPrevious, eSelectLine);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       return FindOffset(tmpOffset, eDirPrevious, eSelectBeginLine);</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     case ePrevLineEnd: {
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         return aOffset - 1;</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :       // If offset is at first line then return 0 (first line start).
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :       uint32_t tmpOffset = FindOffset(aOffset, eDirPrevious, eSelectBeginLine);</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       if (tmpOffset == 0)</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :       // Otherwise move to end of previous line (as arrow up and end keys were
<span class="lineNum">     623 </span>            :       // pressed).
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       tmpOffset = FindOffset(aOffset, eDirPrevious, eSelectLine);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       return FindOffset(tmpOffset, eDirNext, eSelectEndLine);</span>
<span class="lineNum">     626 </span>            :     }
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     case eThisLineBegin:
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         return aOffset;</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :       // Move to begin of the current line (as home key was pressed).
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :       return FindOffset(aOffset, eDirPrevious, eSelectBeginLine);</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :     case eThisLineEnd:
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         return aOffset;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :       // Move to end of the current line (as end key was pressed).
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       return FindOffset(aOffset, eDirNext, eSelectEndLine);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :     case eNextLineBegin: {
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         return aOffset;</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :       // Move to begin of the next line if any (arrow down and home keys),
<span class="lineNum">     647 </span>            :       // otherwise end of the current line (arrow down only).
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       uint32_t tmpOffset = FindOffset(aOffset, eDirNext, eSelectLine);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       if (tmpOffset == CharacterCount())</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         return tmpOffset;</span>
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :       return FindOffset(tmpOffset, eDirPrevious, eSelectBeginLine);</span>
<span class="lineNum">     653 </span>            :     }
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :     case eNextLineEnd: {
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       if (IsEmptyLastLineOffset(aOffset))</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         return aOffset;</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :       // Move to next line end (as down arrow and end key were pressed).
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :       uint32_t tmpOffset = FindOffset(aOffset, eDirNext, eSelectLine);</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :       if (tmpOffset == CharacterCount())</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         return tmpOffset;</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       return FindOffset(tmpOffset, eDirNext, eSelectEndLine);</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            :   }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     669 </span>            : }
<a name="670"><span class="lineNum">     670 </span>            : </a>
<span class="lineNum">     671 </span>            : void
<span class="lineNum">     672 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextBeforeOffset(int32_t aOffset,</span>
<span class="lineNum">     673 </span>            :                                       AccessibleTextBoundary aBoundaryType,
<span class="lineNum">     674 </span>            :                                       int32_t* aStartOffset, int32_t* aEndOffset,
<span class="lineNum">     675 </span>            :                                       nsAString&amp; aText)
<span class="lineNum">     676 </span>            : {
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   *aStartOffset = *aEndOffset = 0;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :   aText.Truncate();</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :   index_t convertedOffset = ConvertMagicOffset(aOffset);</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   if (!convertedOffset.IsValid() || convertedOffset &gt; CharacterCount()) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset!&quot;);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     684 </span>            :   }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   uint32_t adjustedOffset = convertedOffset;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET)</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     adjustedOffset = AdjustCaretOffset(adjustedOffset);</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   switch (aBoundaryType) {</span>
<span class="lineNum">     691 </span>            :     case nsIAccessibleText::BOUNDARY_CHAR:
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :       if (convertedOffset != 0)</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :         CharAt(convertedOffset - 1, aText, aStartOffset, aEndOffset);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_START: {
<span class="lineNum">     697 </span>            :       // If the offset is a word start (except text length offset) then move
<span class="lineNum">     698 </span>            :       // backward to find a start offset (end offset is the given offset).
<span class="lineNum">     699 </span>            :       // Otherwise move backward twice to find both start and end offsets.
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       if (adjustedOffset == CharacterCount()) {</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         *aEndOffset = FindWordBoundary(adjustedOffset, eDirPrevious, eStartWord);</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eStartWord);</span>
<span class="lineNum">     703 </span>            :       } else {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :         *aStartOffset = FindWordBoundary(adjustedOffset, eDirPrevious, eStartWord);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         *aEndOffset = FindWordBoundary(*aStartOffset, eDirNext, eStartWord);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :         if (*aEndOffset != static_cast&lt;int32_t&gt;(adjustedOffset)) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :           *aEndOffset = *aStartOffset;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :           *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eStartWord);</span>
<span class="lineNum">     709 </span>            :         }
<span class="lineNum">     710 </span>            :       }
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     713 </span>            :     }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_END: {
<span class="lineNum">     716 </span>            :       // Move word backward twice to find start and end offsets.
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       *aEndOffset = FindWordBoundary(convertedOffset, eDirPrevious, eEndWord);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :       *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eEndWord);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     721 </span>            :     }
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_START:
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(adjustedOffset, ePrevLineBegin);</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(adjustedOffset, eThisLineBegin);</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_END: {
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(adjustedOffset, ePrevLineEnd);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :       int32_t tmpOffset = *aEndOffset;</span>
<span class="lineNum">     732 </span>            :       // Adjust offset if line is wrapped.
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :       if (*aEndOffset != 0 &amp;&amp; !IsLineEndCharAt(*aEndOffset))</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :         tmpOffset--;</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(tmpOffset, ePrevLineEnd);</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     739 </span>            :     }
<span class="lineNum">     740 </span>            :   }
<span class="lineNum">     741 </span>            : }
<a name="742"><span class="lineNum">     742 </span>            : </a>
<span class="lineNum">     743 </span>            : void
<span class="lineNum">     744 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextAtOffset(int32_t aOffset,</span>
<span class="lineNum">     745 </span>            :                                   AccessibleTextBoundary aBoundaryType,
<span class="lineNum">     746 </span>            :                                   int32_t* aStartOffset, int32_t* aEndOffset,
<span class="lineNum">     747 </span>            :                                   nsAString&amp; aText)
<span class="lineNum">     748 </span>            : {
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   *aStartOffset = *aEndOffset = 0;</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   aText.Truncate();</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   uint32_t adjustedOffset = ConvertMagicOffset(aOffset);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :   if (adjustedOffset == std::numeric_limits&lt;uint32_t&gt;::max()) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong given offset!&quot;);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     756 </span>            :   }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   switch (aBoundaryType) {</span>
<span class="lineNum">     759 </span>            :     case nsIAccessibleText::BOUNDARY_CHAR:
<span class="lineNum">     760 </span>            :       // Return no char if caret is at the end of wrapped line (case of no line
<span class="lineNum">     761 </span>            :       // end character). Returning a next line char is confusing for AT.
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :       if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET &amp;&amp; IsCaretAtEndOfLine())</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         *aStartOffset = *aEndOffset = adjustedOffset;</span>
<span class="lineNum">     764 </span>            :       else
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         CharAt(adjustedOffset, aText, aStartOffset, aEndOffset);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_START:
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :       if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET)</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         adjustedOffset = AdjustCaretOffset(adjustedOffset);</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       *aEndOffset = FindWordBoundary(adjustedOffset, eDirNext, eStartWord);</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :       *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eStartWord);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_END:
<span class="lineNum">     778 </span>            :       // Ignore the spec and follow what WebKitGtk does because Orca expects it,
<span class="lineNum">     779 </span>            :       // i.e. return a next word at word end offset of the current word
<span class="lineNum">     780 </span>            :       // (WebKitGtk behavior) instead the current word (AKT spec).
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       *aEndOffset = FindWordBoundary(adjustedOffset, eDirNext, eEndWord);</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eEndWord);</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_START:
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         adjustedOffset = AdjustCaretOffset(adjustedOffset);</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(adjustedOffset, eThisLineBegin);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(adjustedOffset, eNextLineBegin);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_END:
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :       if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET)</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         adjustedOffset = AdjustCaretOffset(adjustedOffset);</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :       // In contrast to word end boundary we follow the spec here.
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(adjustedOffset, ePrevLineEnd);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(adjustedOffset, eThisLineEnd);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     804 </span>            :   }
<span class="lineNum">     805 </span>            : }
<a name="806"><span class="lineNum">     806 </span>            : </a>
<span class="lineNum">     807 </span>            : void
<span class="lineNum">     808 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextAfterOffset(int32_t aOffset,</span>
<span class="lineNum">     809 </span>            :                                      AccessibleTextBoundary aBoundaryType,
<span class="lineNum">     810 </span>            :                                      int32_t* aStartOffset, int32_t* aEndOffset,
<span class="lineNum">     811 </span>            :                                      nsAString&amp; aText)
<span class="lineNum">     812 </span>            : {
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :   *aStartOffset = *aEndOffset = 0;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   aText.Truncate();</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   index_t convertedOffset = ConvertMagicOffset(aOffset);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :   if (!convertedOffset.IsValid() || convertedOffset &gt; CharacterCount()) {</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset!&quot;);</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     820 </span>            :   }
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   uint32_t adjustedOffset = convertedOffset;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :   if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET)</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     adjustedOffset = AdjustCaretOffset(adjustedOffset);</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   switch (aBoundaryType) {</span>
<span class="lineNum">     827 </span>            :     case nsIAccessibleText::BOUNDARY_CHAR:
<span class="lineNum">     828 </span>            :       // If caret is at the end of wrapped line (case of no line end character)
<span class="lineNum">     829 </span>            :       // then char after the offset is a first char at next line.
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       if (adjustedOffset &gt;= CharacterCount())</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :         *aStartOffset = *aEndOffset = CharacterCount();</span>
<span class="lineNum">     832 </span>            :       else
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         CharAt(adjustedOffset + 1, aText, aStartOffset, aEndOffset);</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_START:
<span class="lineNum">     837 </span>            :       // Move word forward twice to find start and end offsets.
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :       *aStartOffset = FindWordBoundary(adjustedOffset, eDirNext, eStartWord);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       *aEndOffset = FindWordBoundary(*aStartOffset, eDirNext, eStartWord);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :     case nsIAccessibleText::BOUNDARY_WORD_END:
<span class="lineNum">     844 </span>            :       // If the offset is a word end (except 0 offset) then move forward to find
<span class="lineNum">     845 </span>            :       // end offset (start offset is the given offset). Otherwise move forward
<span class="lineNum">     846 </span>            :       // twice to find both start and end offsets.
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :       if (convertedOffset == 0) {</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         *aStartOffset = FindWordBoundary(convertedOffset, eDirNext, eEndWord);</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :         *aEndOffset = FindWordBoundary(*aStartOffset, eDirNext, eEndWord);</span>
<span class="lineNum">     850 </span>            :       } else {
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         *aEndOffset = FindWordBoundary(convertedOffset, eDirNext, eEndWord);</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         *aStartOffset = FindWordBoundary(*aEndOffset, eDirPrevious, eEndWord);</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         if (*aStartOffset != static_cast&lt;int32_t&gt;(convertedOffset)) {</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :           *aStartOffset = *aEndOffset;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :           *aEndOffset = FindWordBoundary(*aStartOffset, eDirNext, eEndWord);</span>
<span class="lineNum">     856 </span>            :         }
<span class="lineNum">     857 </span>            :       }
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_START:
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(adjustedOffset, eNextLineBegin);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(*aStartOffset, eNextLineBegin);</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :     case nsIAccessibleText::BOUNDARY_LINE_END:
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       *aStartOffset = FindLineBoundary(adjustedOffset, eThisLineEnd);</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :       *aEndOffset = FindLineBoundary(adjustedOffset, eNextLineEnd);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :       TextSubstring(*aStartOffset, *aEndOffset, aText);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     872 </span>            :   }
<span class="lineNum">     873 </span>            : }
<a name="874"><span class="lineNum">     874 </span>            : </a>
<span class="lineNum">     875 </span>            : already_AddRefed&lt;nsIPersistentProperties&gt;
<span class="lineNum">     876 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextAttributes(bool aIncludeDefAttrs, int32_t aOffset,</span>
<span class="lineNum">     877 </span>            :                                        int32_t* aStartOffset,
<span class="lineNum">     878 </span>            :                                        int32_t* aEndOffset)
<span class="lineNum">     879 </span>            : {
<span class="lineNum">     880 </span>            :   // 1. Get each attribute and its ranges one after another.
<span class="lineNum">     881 </span>            :   // 2. As we get each new attribute, we pass the current start and end offsets
<span class="lineNum">     882 </span>            :   //    as in/out parameters. In other words, as attributes are collected,
<span class="lineNum">     883 </span>            :   //    the attribute range itself can only stay the same or get smaller.
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   *aStartOffset = *aEndOffset = 0;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   index_t offset = ConvertMagicOffset(aOffset);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   if (!offset.IsValid() || offset &gt; CharacterCount()) {</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset!&quot;);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   nsCOMPtr&lt;nsIPersistentProperties&gt; attributes =
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   Accessible* accAtOffset = GetChildAtOffset(offset);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   if (!accAtOffset) {</span>
<span class="lineNum">     897 </span>            :     // Offset 0 is correct offset when accessible has empty text. Include
<span class="lineNum">     898 </span>            :     // default attributes if they were requested, otherwise return empty set.
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     if (offset == 0) {</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       if (aIncludeDefAttrs) {</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         TextAttrsMgr textAttrsMgr(this);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :         textAttrsMgr.GetAttributes(attributes);</span>
<span class="lineNum">     903 </span>            :       }
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       return attributes.forget();</span>
<span class="lineNum">     905 </span>            :     }
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     907 </span>            :   }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   int32_t accAtOffsetIdx = accAtOffset-&gt;IndexInParent();</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   uint32_t startOffset = GetChildOffset(accAtOffsetIdx);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :   uint32_t endOffset = GetChildOffset(accAtOffsetIdx + 1);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :   int32_t offsetInAcc = offset - startOffset;</span>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            :   TextAttrsMgr textAttrsMgr(this, aIncludeDefAttrs, accAtOffset,
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                             accAtOffsetIdx);</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :   textAttrsMgr.GetAttributes(attributes, &amp;startOffset, &amp;endOffset);</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :   // Compute spelling attributes on text accessible only.
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   nsIFrame *offsetFrame = accAtOffset-&gt;GetFrame();</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   if (offsetFrame &amp;&amp; offsetFrame-&gt;IsTextFrame()) {</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     int32_t nodeOffset = 0;</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     RenderedToContentOffset(offsetFrame, offsetInAcc, &amp;nodeOffset);</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :     // Set 'misspelled' text attribute.
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     GetSpellTextAttr(accAtOffset-&gt;GetNode(), nodeOffset,</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                      &amp;startOffset, &amp;endOffset, attributes);</span>
<span class="lineNum">     927 </span>            :   }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :   *aStartOffset = startOffset;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   *aEndOffset = endOffset;</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   return attributes.forget();</span>
<span class="lineNum">     932 </span>            : }
<a name="933"><span class="lineNum">     933 </span>            : </a>
<span class="lineNum">     934 </span>            : already_AddRefed&lt;nsIPersistentProperties&gt;
<span class="lineNum">     935 </span><span class="lineNoCov">          0 : HyperTextAccessible::DefaultTextAttributes()</span>
<span class="lineNum">     936 </span>            : {
<span class="lineNum">     937 </span>            :   nsCOMPtr&lt;nsIPersistentProperties&gt; attributes =
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   TextAttrsMgr textAttrsMgr(this);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   textAttrsMgr.GetAttributes(attributes);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   return attributes.forget();</span>
<span class="lineNum">     943 </span>            : }
<a name="944"><span class="lineNum">     944 </span>            : </a>
<span class="lineNum">     945 </span>            : int32_t
<span class="lineNum">     946 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetLevelInternal()</span>
<span class="lineNum">     947 </span>            : {
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h1))</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h2))</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     return 2;</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h3))</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     return 3;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h4))</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     return 4;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h5))</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :     return 5;</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::h6))</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     return 6;</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :   return AccessibleWrap::GetLevelInternal();</span>
<span class="lineNum">     962 </span>            : }
<a name="963"><span class="lineNum">     963 </span>            : </a>
<span class="lineNum">     964 </span>            : void
<span class="lineNum">     965 </span><span class="lineNoCov">          0 : HyperTextAccessible::SetMathMLXMLRoles(nsIPersistentProperties* aAttributes)</span>
<span class="lineNum">     966 </span>            : {
<span class="lineNum">     967 </span>            :   // Add MathML xmlroles based on the position inside the parent.
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   Accessible* parent = Parent();</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   if (parent) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     switch (parent-&gt;Role()) {</span>
<span class="lineNum">     971 </span>            :     case roles::MATHML_CELL:
<span class="lineNum">     972 </span>            :     case roles::MATHML_ENCLOSED:
<span class="lineNum">     973 </span>            :     case roles::MATHML_ERROR:
<span class="lineNum">     974 </span>            :     case roles::MATHML_MATH:
<span class="lineNum">     975 </span>            :     case roles::MATHML_ROW:
<span class="lineNum">     976 </span>            :     case roles::MATHML_SQUARE_ROOT:
<span class="lineNum">     977 </span>            :     case roles::MATHML_STYLE:
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       if (Role() == roles::MATHML_OPERATOR) {</span>
<span class="lineNum">     979 </span>            :         // This is an operator inside an &lt;mrow&gt; (or an inferred &lt;mrow&gt;).
<span class="lineNum">     980 </span>            :         // See http://www.w3.org/TR/MathML3/chapter3.html#presm.inferredmrow
<span class="lineNum">     981 </span>            :         // XXX We should probably do something similar for MATHML_FENCED, but
<span class="lineNum">     982 </span>            :         // operators do not appear in the accessible tree. See bug 1175747.
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         nsIMathMLFrame* mathMLFrame = do_QueryFrame(GetFrame());</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         if (mathMLFrame) {</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :           nsEmbellishData embellishData;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :           mathMLFrame-&gt;GetEmbellishData(embellishData);</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :           if (NS_MATHML_EMBELLISH_IS_FENCE(embellishData.flags)) {</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :             if (!PrevSibling()) {</span>
<span class="lineNum">     989 </span>            :               nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :                                      nsGkAtoms::open_fence);</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :             } else if (!NextSibling()) {</span>
<span class="lineNum">     992 </span>            :               nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :                                      nsGkAtoms::close_fence);</span>
<span class="lineNum">     994 </span>            :             }
<span class="lineNum">     995 </span>            :           }
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :           if (NS_MATHML_EMBELLISH_IS_SEPARATOR(embellishData.flags)) {</span>
<span class="lineNum">     997 </span>            :             nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                                    nsGkAtoms::separator_);</span>
<span class="lineNum">     999 </span>            :           }
<span class="lineNum">    1000 </span>            :         }
<span class="lineNum">    1001 </span>            :       }
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1003 </span>            :     case roles::MATHML_FRACTION:
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ?</span>
<span class="lineNum">    1006 </span>            :                              nsGkAtoms::numerator :
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                              nsGkAtoms::denominator);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1009 </span>            :     case roles::MATHML_ROOT:
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ? nsGkAtoms::base :</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                              nsGkAtoms::root_index);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1014 </span>            :     case roles::MATHML_SUB:
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ? nsGkAtoms::base :</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                              nsGkAtoms::subscript);</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1019 </span>            :     case roles::MATHML_SUP:
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ? nsGkAtoms::base :</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                              nsGkAtoms::superscript);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1024 </span>            :     case roles::MATHML_SUB_SUP: {
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :       int32_t index = IndexInParent();</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1027 </span>            :                              index == 0 ? nsGkAtoms::base :
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                              (index == 1 ? nsGkAtoms::subscript :</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                               nsGkAtoms::superscript));</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     } break;</span>
<span class="lineNum">    1031 </span>            :     case roles::MATHML_UNDER:
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ? nsGkAtoms::base :</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                              nsGkAtoms::underscript);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1036 </span>            :     case roles::MATHML_OVER:
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                              IndexInParent() == 0 ? nsGkAtoms::base :</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                              nsGkAtoms::overscript);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1041 </span>            :     case roles::MATHML_UNDER_OVER: {
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :       int32_t index = IndexInParent();</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1044 </span>            :                              index == 0 ? nsGkAtoms::base :
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                              (index == 1 ? nsGkAtoms::underscript :</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                               nsGkAtoms::overscript));</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     } break;</span>
<span class="lineNum">    1048 </span>            :     case roles::MATHML_MULTISCRIPTS: {
<span class="lineNum">    1049 </span>            :       // Get the &lt;multiscripts&gt; base.
<span class="lineNum">    1050 </span>            :       nsIContent* child;
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       bool baseFound = false;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :       for (child = parent-&gt;GetContent()-&gt;GetFirstChild(); child;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :            child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :         if (child-&gt;IsMathMLElement()) {</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :           baseFound = true;</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1057 </span>            :         }
<span class="lineNum">    1058 </span>            :       }
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :       if (baseFound) {</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         nsIContent* content = GetContent();</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         if (child == content) {</span>
<span class="lineNum">    1062 </span>            :           // We are the base.
<span class="lineNum">    1063 </span>            :           nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                                  nsGkAtoms::base);</span>
<span class="lineNum">    1065 </span>            :         } else {
<span class="lineNum">    1066 </span>            :           // Browse the list of scripts to find us and determine our type.
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :           bool postscript = true;</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :           bool subscript = true;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :           for (child = child-&gt;GetNextSibling(); child;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :             if (!child-&gt;IsMathMLElement())</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :             if (child-&gt;IsMathMLElement(nsGkAtoms::mprescripts_)) {</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :               postscript = false;</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :               subscript = true;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">    1077 </span>            :             }
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             if (child == content) {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :               if (postscript) {</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                 nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1081 </span>            :                                        subscript ?
<span class="lineNum">    1082 </span>            :                                        nsGkAtoms::subscript :
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                                        nsGkAtoms::superscript);</span>
<span class="lineNum">    1084 </span>            :               } else {
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                 nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::xmlroles,</span>
<span class="lineNum">    1086 </span>            :                                        subscript ?
<span class="lineNum">    1087 </span>            :                                        nsGkAtoms::presubscript :
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                                        nsGkAtoms::presuperscript);</span>
<span class="lineNum">    1089 </span>            :               }
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1091 </span>            :             }
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :             subscript = !subscript;</span>
<span class="lineNum">    1093 </span>            :           }
<span class="lineNum">    1094 </span>            :         }
<span class="lineNum">    1095 </span>            :       }
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :     } break;</span>
<span class="lineNum">    1097 </span>            :     default:
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1099 </span>            :     }
<span class="lineNum">    1100 </span>            :   }
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 : }</span>
<a name="1102"><span class="lineNum">    1102 </span>            : </a>
<span class="lineNum">    1103 </span>            : already_AddRefed&lt;nsIPersistentProperties&gt;
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 : HyperTextAccessible::NativeAttributes()</span>
<span class="lineNum">    1105 </span>            : {
<span class="lineNum">    1106 </span>            :   nsCOMPtr&lt;nsIPersistentProperties&gt; attributes =
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :     AccessibleWrap::NativeAttributes();</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :   // 'formatting' attribute is deprecated, 'display' attribute should be
<span class="lineNum">    1110 </span>            :   // instead.
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   nsIFrame *frame = GetFrame();</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :   if (frame &amp;&amp; frame-&gt;IsBlockFrame()) {</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     nsAutoString unused;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     attributes-&gt;SetStringProperty(NS_LITERAL_CSTRING(&quot;formatting&quot;),</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :                                   NS_LITERAL_STRING(&quot;block&quot;), unused);</span>
<span class="lineNum">    1116 </span>            :   }
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   if (FocusMgr()-&gt;IsFocused(this)) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     int32_t lineNumber = CaretLineNumber();</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     if (lineNumber &gt;= 1) {</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :       nsAutoString strLineNumber;</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :       strLineNumber.AppendInt(lineNumber);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :       nsAccUtils::SetAccAttr(attributes, nsGkAtoms::lineNumber, strLineNumber);</span>
<span class="lineNum">    1124 </span>            :     }
<span class="lineNum">    1125 </span>            :   }
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :   if (HasOwnContent()) {</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     GetAccService()-&gt;MarkupAttributes(mContent, attributes);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :     if (mContent-&gt;IsMathMLElement())</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :       SetMathMLXMLRoles(attributes);</span>
<span class="lineNum">    1131 </span>            :   }
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   return attributes.forget();</span>
<span class="lineNum">    1134 </span>            : }
<a name="1135"><span class="lineNum">    1135 </span>            : </a>
<span class="lineNum">    1136 </span>            : nsIAtom*
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 : HyperTextAccessible::LandmarkRole() const</span>
<span class="lineNum">    1138 </span>            : {
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :   if (!HasOwnContent())</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :   // For the html landmark elements we expose them like we do ARIA landmarks to
<span class="lineNum">    1143 </span>            :   // make AT navigation schemes &quot;just work&quot;.
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::nav)) {</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     return nsGkAtoms::navigation;</span>
<span class="lineNum">    1146 </span>            :   }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsAnyOfHTMLElements(nsGkAtoms::header,</span>
<span class="lineNum">    1149 </span>            :                                     nsGkAtoms::footer)) {
<span class="lineNum">    1150 </span>            :     // Only map header and footer if they are not descendants of an article
<span class="lineNum">    1151 </span>            :     // or section tag.
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :     nsIContent* parent = mContent-&gt;GetParent();</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :     while (parent) {</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :       if (parent-&gt;IsAnyOfHTMLElements(nsGkAtoms::article, nsGkAtoms::section)) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1156 </span>            :       }
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       parent = parent-&gt;GetParent();</span>
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :     // No article or section elements found.
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     if (!parent) {</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :       if (mContent-&gt;IsHTMLElement(nsGkAtoms::header)) {</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :         return nsGkAtoms::banner;</span>
<span class="lineNum">    1164 </span>            :       }
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :       if (mContent-&gt;IsHTMLElement(nsGkAtoms::footer)) {</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         return nsGkAtoms::contentinfo;</span>
<span class="lineNum">    1168 </span>            :       }
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1171 </span>            :   }
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::aside)) {</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     return nsGkAtoms::complementary;</span>
<span class="lineNum">    1175 </span>            :   }
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::main)) {</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     return nsGkAtoms::main;</span>
<span class="lineNum">    1179 </span>            :   }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">    1182 </span>            : }
<a name="1183"><span class="lineNum">    1183 </span>            : </a>
<span class="lineNum">    1184 </span>            : int32_t
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 : HyperTextAccessible::OffsetAtPoint(int32_t aX, int32_t aY, uint32_t aCoordType)</span>
<span class="lineNum">    1186 </span>            : {
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :   nsIFrame* hyperFrame = GetFrame();</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   if (!hyperFrame)</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            :   nsIntPoint coords = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordType,
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :                                                         this);</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mDoc-&gt;PresContext();</span>
<span class="lineNum">    1195 </span>            :   nsPoint coordsInAppUnits =
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :     ToAppUnits(coords, presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :   nsRect frameScreenRect = hyperFrame-&gt;GetScreenRectInAppUnits();</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   if (!frameScreenRect.Contains(coordsInAppUnits.x, coordsInAppUnits.y))</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     return -1; // Not found</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   nsPoint pointInHyperText(coordsInAppUnits.x - frameScreenRect.x,</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                            coordsInAppUnits.y - frameScreenRect.y);</span>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :   // Go through the frames to check if each one has the point.
<span class="lineNum">    1206 </span>            :   // When one does, add up the character offsets until we have a match
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :   // We have an point in an accessible child of this, now we need to add up the
<span class="lineNum">    1209 </span>            :   // offsets before it to what we already have
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   int32_t offset = 0;</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   uint32_t childCount = ChildCount();</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   for (uint32_t childIdx = 0; childIdx &lt; childCount; childIdx++) {</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     Accessible* childAcc = mChildren[childIdx];</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     nsIFrame *primaryFrame = childAcc-&gt;GetFrame();</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(primaryFrame, -1);</span>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     nsIFrame *frame = primaryFrame;</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     while (frame) {</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :       nsIContent *content = frame-&gt;GetContent();</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :       NS_ENSURE_TRUE(content, -1);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :       nsPoint pointInFrame = pointInHyperText - frame-&gt;GetOffsetTo(hyperFrame);</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :       nsSize frameSize = frame-&gt;GetSize();</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :       if (pointInFrame.x &lt; frameSize.width &amp;&amp; pointInFrame.y &lt; frameSize.height) {</span>
<span class="lineNum">    1225 </span>            :         // Finished
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :         if (frame-&gt;IsTextFrame()) {</span>
<span class="lineNum">    1227 </span>            :           nsIFrame::ContentOffsets contentOffsets =
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :             frame-&gt;GetContentOffsetsFromPointExternal(pointInFrame, nsIFrame::IGNORE_SELECTION_STYLE);</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :           if (contentOffsets.IsNull() || contentOffsets.content != content) {</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :             return -1; // Not found</span>
<span class="lineNum">    1231 </span>            :           }
<span class="lineNum">    1232 </span>            :           uint32_t addToOffset;
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :           nsresult rv = ContentToRenderedOffset(primaryFrame,</span>
<span class="lineNum">    1234 </span>            :                                                 contentOffsets.offset,
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                                                 &amp;addToOffset);</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :           NS_ENSURE_SUCCESS(rv, -1);</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :           offset += addToOffset;</span>
<span class="lineNum">    1238 </span>            :         }
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :         return offset;</span>
<span class="lineNum">    1240 </span>            :       }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :       frame = frame-&gt;GetNextContinuation();</span>
<span class="lineNum">    1242 </span>            :     }
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :     offset += nsAccUtils::TextLength(childAcc);</span>
<span class="lineNum">    1245 </span>            :   }
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :   return -1; // Not found</span>
<span class="lineNum">    1248 </span>            : }
<a name="1249"><span class="lineNum">    1249 </span>            : </a>
<span class="lineNum">    1250 </span>            : nsIntRect
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 : HyperTextAccessible::TextBounds(int32_t aStartOffset, int32_t aEndOffset,</span>
<span class="lineNum">    1252 </span>            :                                 uint32_t aCoordType)
<span class="lineNum">    1253 </span>            : {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   index_t startOffset = ConvertMagicOffset(aStartOffset);</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   index_t endOffset = ConvertMagicOffset(aEndOffset);</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   if (!startOffset.IsValid() || !endOffset.IsValid() ||</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :       startOffset &gt; endOffset || endOffset &gt; CharacterCount()) {</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset&quot;);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     return nsIntRect();</span>
<span class="lineNum">    1260 </span>            :   }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   int32_t childIdx = GetChildIndexAtOffset(startOffset);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :   if (childIdx == -1)</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     return nsIntRect();</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   nsIntRect bounds;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   int32_t prevOffset = GetChildOffset(childIdx);</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   int32_t offset1 = startOffset - prevOffset;</span>
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :   while (childIdx &lt; static_cast&lt;int32_t&gt;(ChildCount())) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     nsIFrame* frame = GetChildAt(childIdx++)-&gt;GetFrame();</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :     if (!frame) {</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :       NS_NOTREACHED(&quot;No frame for a child!&quot;);</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1276 </span>            :     }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     int32_t nextOffset = GetChildOffset(childIdx);</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     if (nextOffset &gt;= static_cast&lt;int32_t&gt;(endOffset)) {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :       bounds.UnionRect(bounds, GetBoundsInFrame(frame, offset1,</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                                                 endOffset - prevOffset));</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1283 </span>            :     }
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     bounds.UnionRect(bounds, GetBoundsInFrame(frame, offset1,</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :                                               nextOffset - prevOffset));</span>
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :     prevOffset = nextOffset;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :     offset1 = 0;</span>
<span class="lineNum">    1290 </span>            :   }
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   nsAccUtils::ConvertScreenCoordsTo(&amp;bounds.x, &amp;bounds.y, aCoordType, this);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   return bounds;</span>
<span class="lineNum">    1294 </span>            : }
<a name="1295"><span class="lineNum">    1295 </span>            : </a>
<span class="lineNum">    1296 </span>            : already_AddRefed&lt;nsIEditor&gt;
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetEditor() const</span>
<span class="lineNum">    1298 </span>            : {
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :   if (!mContent-&gt;HasFlag(NODE_IS_EDITABLE)) {</span>
<span class="lineNum">    1300 </span>            :     // If we're inside an editable container, then return that container's editor
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     Accessible* ancestor = Parent();</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     while (ancestor) {</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :       HyperTextAccessible* hyperText = ancestor-&gt;AsHyperText();</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :       if (hyperText) {</span>
<span class="lineNum">    1305 </span>            :         // Recursion will stop at container doc because it has its own impl
<span class="lineNum">    1306 </span>            :         // of GetEditor()
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :         return hyperText-&gt;GetEditor();</span>
<span class="lineNum">    1308 </span>            :       }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :       ancestor = ancestor-&gt;Parent();</span>
<span class="lineNum">    1311 </span>            :     }
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">    1314 </span>            :   }
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIDocShell&gt; docShell = nsCoreUtils::GetDocShellFor(mContent);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIEditingSession&gt; editingSession;</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   docShell-&gt;GetEditingSession(getter_AddRefs(editingSession));</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :   if (!editingSession)</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     return nullptr; // No editing session interface</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIEditor&gt; editor;</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   nsIDocument* docNode = mDoc-&gt;DocumentNode();</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :   editingSession-&gt;GetEditorForWindow(docNode-&gt;GetWindow(),</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                                      getter_AddRefs(editor));</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   return editor.forget();</span>
<span class="lineNum">    1327 </span>            : }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            : /**
<span class="lineNum">    1330 </span>            :   * =================== Caret &amp; Selection ======================
<span class="lineNum">    1331 </span>            :   */
<a name="1332"><span class="lineNum">    1332 </span>            : </a>
<span class="lineNum">    1333 </span>            : nsresult
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 : HyperTextAccessible::SetSelectionRange(int32_t aStartPos, int32_t aEndPos)</span>
<span class="lineNum">    1335 </span>            : {
<span class="lineNum">    1336 </span>            :   // Before setting the selection range, we need to ensure that the editor
<span class="lineNum">    1337 </span>            :   // is initialized. (See bug 804927.)
<span class="lineNum">    1338 </span>            :   // Otherwise, it's possible that lazy editor initialization will override
<span class="lineNum">    1339 </span>            :   // the selection we set here and leave the caret at the end of the text.
<span class="lineNum">    1340 </span>            :   // By calling GetEditor here, we ensure that editor initialization is
<span class="lineNum">    1341 </span>            :   // completed before we set the selection.
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIEditor&gt; editor = GetEditor();</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :   bool isFocusable = InteractiveState() &amp; states::FOCUSABLE;</span>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :   // If accessible is focusable then focus it before setting the selection to
<span class="lineNum">    1347 </span>            :   // neglect control's selection changes on focus if any (for example, inputs
<span class="lineNum">    1348 </span>            :   // that do select all on focus).
<span class="lineNum">    1349 </span>            :   // some input controls
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   if (isFocusable)</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :     TakeFocus();</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = DOMSelection();</span>
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   NS_ENSURE_STATE(domSel);</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            :   // Set up the selection.
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :   for (int32_t idx = domSel-&gt;RangeCount() - 1; idx &gt; 0; idx--)</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :     domSel-&gt;RemoveRange(domSel-&gt;GetRangeAt(idx));</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :   SetSelectionBoundsAt(0, aStartPos, aEndPos);</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :   // When selection is done, move the focus to the selection if accessible is
<span class="lineNum">    1362 </span>            :   // not focusable. That happens when selection is set within hypertext
<span class="lineNum">    1363 </span>            :   // accessible.
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   if (isFocusable)</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   nsFocusManager* DOMFocusManager = nsFocusManager::GetFocusManager();</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   if (DOMFocusManager) {</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(mDoc, NS_ERROR_FAILURE);</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :     nsIDocument* docNode = mDoc-&gt;DocumentNode();</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(docNode, NS_ERROR_FAILURE);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsPIDOMWindowOuter&gt; window = docNode-&gt;GetWindow();</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIDOMElement&gt; result;</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     DOMFocusManager-&gt;MoveFocus(window, nullptr, nsIFocusManager::MOVEFOCUS_CARET,</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                                nsIFocusManager::FLAG_BYMOVEFOCUS, getter_AddRefs(result));</span>
<span class="lineNum">    1376 </span>            :   }
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1379 </span>            : }
<a name="1380"><span class="lineNum">    1380 </span>            : </a>
<span class="lineNum">    1381 </span>            : int32_t
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 : HyperTextAccessible::CaretOffset() const</span>
<span class="lineNum">    1383 </span>            : {
<span class="lineNum">    1384 </span>            :   // Not focused focusable accessible except document accessible doesn't have
<span class="lineNum">    1385 </span>            :   // a caret.
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :   if (!IsDoc() &amp;&amp; !FocusMgr()-&gt;IsFocused(this) &amp;&amp;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :       (InteractiveState() &amp; states::FOCUSABLE)) {</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1389 </span>            :   }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            :   // Check cached value.
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   int32_t caretOffset = -1;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   HyperTextAccessible* text = SelectionMgr()-&gt;AccessibleWithCaret(&amp;caretOffset);</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :   // Use cached value if it corresponds to this accessible.
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   if (caretOffset != -1) {</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     if (text == this)</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :       return caretOffset;</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :     nsINode* textNode = text-&gt;GetNode();</span>
<span class="lineNum">    1401 </span>            :     // Ignore offset if cached accessible isn't a text leaf.
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :     if (nsCoreUtils::IsAncestorOf(GetNode(), textNode))</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :       return TransformOffset(text,</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         textNode-&gt;IsNodeOfType(nsINode::eTEXT) ? caretOffset : 0, false);</span>
<span class="lineNum">    1405 </span>            :   }
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :   // No caret if the focused node is not inside this DOM node and this DOM node
<span class="lineNum">    1408 </span>            :   // is not inside of focused node.
<span class="lineNum">    1409 </span>            :   FocusManager::FocusDisposition focusDisp =
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     FocusMgr()-&gt;IsInOrContainsFocus(this);</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   if (focusDisp == FocusManager::eNone)</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :   // Turn the focus node and offset of the selection into caret hypretext
<span class="lineNum">    1415 </span>            :   // offset.
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = DOMSelection();</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(domSel, -1);</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :   nsINode* focusNode = domSel-&gt;GetFocusNode();</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :   uint32_t focusOffset = domSel-&gt;FocusOffset();</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            :   // No caret if this DOM node is inside of focused node but the selection's
<span class="lineNum">    1423 </span>            :   // focus point is not inside of this DOM node.
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :   if (focusDisp == FocusManager::eContainedByFocus) {</span>
<span class="lineNum">    1425 </span>            :     nsINode* resultNode =
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       nsCoreUtils::GetDOMNodeFromDOMPoint(focusNode, focusOffset);</span>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     nsINode* thisNode = GetNode();</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     if (resultNode != thisNode &amp;&amp;</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         !nsCoreUtils::IsAncestorOf(thisNode, resultNode))</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    1432 </span>            :   }
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   return DOMPointToOffset(focusNode, focusOffset);</span>
<span class="lineNum">    1435 </span>            : }
<a name="1436"><span class="lineNum">    1436 </span>            : </a>
<span class="lineNum">    1437 </span>            : int32_t
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 : HyperTextAccessible::CaretLineNumber()</span>
<span class="lineNum">    1439 </span>            : {
<span class="lineNum">    1440 </span>            :   // Provide the line number for the caret, relative to the
<span class="lineNum">    1441 </span>            :   // currently focused node. Use a 1-based index
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsFrameSelection&gt; frameSelection = FrameSelection();</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   if (!frameSelection)</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = frameSelection-&gt;GetSelection(SelectionType::eNormal);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :   if (!domSel)</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     return - 1;</span>
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :   nsINode* caretNode = domSel-&gt;GetFocusNode();</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   if (!caretNode || !caretNode-&gt;IsContent())</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :   nsIContent* caretContent = caretNode-&gt;AsContent();</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   if (!nsCoreUtils::IsAncestorOf(GetNode(), caretContent))</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :   int32_t returnOffsetUnused;
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   uint32_t caretOffset = domSel-&gt;FocusOffset();</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   CaretAssociationHint hint = frameSelection-&gt;GetHint();</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   nsIFrame *caretFrame = frameSelection-&gt;GetFrameForNodeOffset(caretContent, caretOffset,</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                                                                hint, &amp;returnOffsetUnused);</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(caretFrame, -1);</span>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   int32_t lineNumber = 1;</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :   nsAutoLineIterator lineIterForCaret;</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   nsIContent *hyperTextContent = IsContent() ? mContent.get() : nullptr;</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :   while (caretFrame) {</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     if (hyperTextContent == caretFrame-&gt;GetContent()) {</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :       return lineNumber; // Must be in a single line hyper text, there is no line iterator</span>
<span class="lineNum">    1471 </span>            :     }
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     nsContainerFrame *parentFrame = caretFrame-&gt;GetParent();</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     if (!parentFrame)</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :     // Add lines for the sibling frames before the caret
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :     nsIFrame *sibling = parentFrame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     while (sibling &amp;&amp; sibling != caretFrame) {</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :       nsAutoLineIterator lineIterForSibling = sibling-&gt;GetLineIterator();</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :       if (lineIterForSibling) {</span>
<span class="lineNum">    1481 </span>            :         // For the frames before that grab all the lines
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         int32_t addLines = lineIterForSibling-&gt;GetNumLines();</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :         lineNumber += addLines;</span>
<span class="lineNum">    1484 </span>            :       }
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       sibling = sibling-&gt;GetNextSibling();</span>
<span class="lineNum">    1486 </span>            :     }
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            :     // Get the line number relative to the container with lines
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     if (!lineIterForCaret) {   // Add the caret line just once</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :       lineIterForCaret = parentFrame-&gt;GetLineIterator();</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :       if (lineIterForCaret) {</span>
<span class="lineNum">    1492 </span>            :         // Ancestor of caret
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         int32_t addLines = lineIterForCaret-&gt;FindLineContaining(caretFrame);</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         lineNumber += addLines;</span>
<span class="lineNum">    1495 </span>            :       }
<span class="lineNum">    1496 </span>            :     }
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     caretFrame = parentFrame;</span>
<span class="lineNum">    1499 </span>            :   }
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   NS_NOTREACHED(&quot;DOM ancestry had this hypertext but frame ancestry didn't&quot;);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :   return lineNumber;</span>
<span class="lineNum">    1503 </span>            : }
<a name="1504"><span class="lineNum">    1504 </span>            : </a>
<span class="lineNum">    1505 </span>            : LayoutDeviceIntRect
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetCaretRect(nsIWidget** aWidget)</span>
<span class="lineNum">    1507 </span>            : {
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   *aWidget = nullptr;</span>
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsCaret&gt; caret = mDoc-&gt;PresShell()-&gt;GetCaret();</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(caret, LayoutDeviceIntRect());</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   bool isVisible = caret-&gt;IsVisible();</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   if (!isVisible)</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     return LayoutDeviceIntRect();</span>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :   nsRect rect;</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   nsIFrame* frame = caret-&gt;GetGeometry(&amp;rect);</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   if (!frame || rect.IsEmpty())</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     return LayoutDeviceIntRect();</span>
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :   nsPoint offset;</span>
<span class="lineNum">    1523 </span>            :   // Offset from widget origin to the frame origin, which includes chrome
<span class="lineNum">    1524 </span>            :   // on the widget.
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   *aWidget = frame-&gt;GetNearestWidget(offset);</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(*aWidget, LayoutDeviceIntRect());</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :   rect.MoveBy(offset);</span>
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span>            :   LayoutDeviceIntRect caretRect = LayoutDeviceIntRect::FromUnknownRect(
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :     rect.ToOutsidePixels(frame-&gt;PresContext()-&gt;AppUnitsPerDevPixel()));</span>
<span class="lineNum">    1531 </span>            :   // ((content screen origin) - (content offset in the widget)) = widget origin on the screen
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   caretRect.MoveBy((*aWidget)-&gt;WidgetToScreenOffset() - (*aWidget)-&gt;GetClientOffset());</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span>            :   // Correct for character size, so that caret always matches the size of
<span class="lineNum">    1535 </span>            :   // the character. This is important for font size transitions, and is
<span class="lineNum">    1536 </span>            :   // necessary because the Gecko caret uses the previous character's size as
<span class="lineNum">    1537 </span>            :   // the user moves forward in the text by character.
<span class="lineNum">    1538 </span>            :   nsIntRect charRect = CharBounds(CaretOffset(),
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :                                   nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE);</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   if (!charRect.IsEmpty()) {</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     caretRect.height -= charRect.y - caretRect.y;</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :     caretRect.y = charRect.y;</span>
<span class="lineNum">    1543 </span>            :   }
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   return caretRect;</span>
<span class="lineNum">    1545 </span>            : }
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<span class="lineNum">    1547 </span>            : void
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetSelectionDOMRanges(SelectionType aSelectionType,</span>
<span class="lineNum">    1549 </span>            :                                            nsTArray&lt;nsRange*&gt;* aRanges)
<span class="lineNum">    1550 </span>            : {
<span class="lineNum">    1551 </span>            :   // Ignore selection if it is not visible.
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsFrameSelection&gt; frameSelection = FrameSelection();</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   if (!frameSelection ||</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :       frameSelection-&gt;GetDisplaySelection() &lt;= nsISelectionController::SELECTION_HIDDEN)</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = frameSelection-&gt;GetSelection(aSelectionType);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   if (!domSel)</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsINode&gt; startNode = GetNode();</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIEditor&gt; editor = GetEditor();</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   if (editor) {</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIDOMElement&gt; editorRoot;</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     editor-&gt;GetRootElement(getter_AddRefs(editorRoot));</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :     startNode = do_QueryInterface(editorRoot);</span>
<span class="lineNum">    1568 </span>            :   }
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   if (!startNode)</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :   uint32_t childCount = startNode-&gt;GetChildCount();</span>
<span class="lineNum">    1574 </span>            :   nsresult rv = domSel-&gt;
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     GetRangesForIntervalArray(startNode, 0, startNode, childCount, true, aRanges);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :   NS_ENSURE_SUCCESS_VOID(rv);</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            :   // Remove collapsed ranges
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :   uint32_t numRanges = aRanges-&gt;Length();</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :   for (uint32_t idx = 0; idx &lt; numRanges; idx ++) {</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     if ((*aRanges)[idx]-&gt;Collapsed()) {</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :       aRanges-&gt;RemoveElementAt(idx);</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :       --numRanges;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :       --idx;</span>
<span class="lineNum">    1585 </span>            :     }
<span class="lineNum">    1586 </span>            :   }
<span class="lineNum">    1587 </span>            : }
<a name="1588"><span class="lineNum">    1588 </span>            : </a>
<span class="lineNum">    1589 </span>            : int32_t
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 : HyperTextAccessible::SelectionCount()</span>
<span class="lineNum">    1591 </span>            : {
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   nsTArray&lt;nsRange*&gt; ranges;</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   GetSelectionDOMRanges(SelectionType::eNormal, &amp;ranges);</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :   return ranges.Length();</span>
<span class="lineNum">    1595 </span>            : }
<a name="1596"><span class="lineNum">    1596 </span>            : </a>
<span class="lineNum">    1597 </span>            : bool
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 : HyperTextAccessible::SelectionBoundsAt(int32_t aSelectionNum,</span>
<span class="lineNum">    1599 </span>            :                                        int32_t* aStartOffset,
<span class="lineNum">    1600 </span>            :                                        int32_t* aEndOffset)
<span class="lineNum">    1601 </span>            : {
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :   *aStartOffset = *aEndOffset = 0;</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :   nsTArray&lt;nsRange*&gt; ranges;</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :   GetSelectionDOMRanges(SelectionType::eNormal, &amp;ranges);</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   uint32_t rangeCount = ranges.Length();</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   if (aSelectionNum &lt; 0 || aSelectionNum &gt;= static_cast&lt;int32_t&gt;(rangeCount))</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :   nsRange* range = ranges[aSelectionNum];</span>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :   // Get start and end points.
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :   nsINode* startNode = range-&gt;GetStartContainer();</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :   nsINode* endNode = range-&gt;GetEndContainer();</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :   int32_t startOffset = range-&gt;StartOffset(), endOffset = range-&gt;EndOffset();</span>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span>            :   // Make sure start is before end, by swapping DOM points.  This occurs when
<span class="lineNum">    1619 </span>            :   // the user selects backwards in the text.
<span class="lineNum">    1620 </span>            :   int32_t rangeCompare = nsContentUtils::ComparePoints(endNode, endOffset,
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :                                                        startNode, startOffset);</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :   if (rangeCompare &lt; 0) {</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :     nsINode* tempNode = startNode;</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     startNode = endNode;</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     endNode = tempNode;</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     int32_t tempOffset = startOffset;</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :     startOffset = endOffset;</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :     endOffset = tempOffset;</span>
<span class="lineNum">    1629 </span>            :   }
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :   if (!nsContentUtils::ContentIsDescendantOf(startNode, mContent))</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     *aStartOffset = 0;</span>
<span class="lineNum">    1633 </span>            :   else
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     *aStartOffset = DOMPointToOffset(startNode, startOffset);</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   if (!nsContentUtils::ContentIsDescendantOf(endNode, mContent))</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     *aEndOffset = CharacterCount();</span>
<span class="lineNum">    1638 </span>            :   else
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :     *aEndOffset = DOMPointToOffset(endNode, endOffset, true);</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1641 </span>            : }
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<span class="lineNum">    1643 </span>            : bool
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 : HyperTextAccessible::SetSelectionBoundsAt(int32_t aSelectionNum,</span>
<span class="lineNum">    1645 </span>            :                                           int32_t aStartOffset,
<span class="lineNum">    1646 </span>            :                                           int32_t aEndOffset)
<span class="lineNum">    1647 </span>            : {
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   index_t startOffset = ConvertMagicOffset(aStartOffset);</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   index_t endOffset = ConvertMagicOffset(aEndOffset);</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :   if (!startOffset.IsValid() || !endOffset.IsValid() ||</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       startOffset &gt; endOffset || endOffset &gt; CharacterCount()) {</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Wrong in offset&quot;);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1654 </span>            :   }
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = DOMSelection();</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   if (!domSel)</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsRange&gt; range;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   uint32_t rangeCount = domSel-&gt;RangeCount();</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :   if (aSelectionNum == static_cast&lt;int32_t&gt;(rangeCount))</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :     range = new nsRange(mContent);</span>
<span class="lineNum">    1664 </span>            :   else
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :     range = domSel-&gt;GetRangeAt(aSelectionNum);</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :   if (!range)</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :   if (!OffsetsToDOMRange(startOffset, endOffset, range))</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :   // If new range was created then add it, otherwise notify selection listeners
<span class="lineNum">    1674 </span>            :   // that existing selection range was changed.
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :   if (aSelectionNum == static_cast&lt;int32_t&gt;(rangeCount))</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :     return NS_SUCCEEDED(domSel-&gt;AddRange(range));</span>
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :   domSel-&gt;RemoveRange(range);</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :   return NS_SUCCEEDED(domSel-&gt;AddRange(range));</span>
<span class="lineNum">    1680 </span>            : }
<a name="1681"><span class="lineNum">    1681 </span>            : </a>
<span class="lineNum">    1682 </span>            : bool
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 : HyperTextAccessible::RemoveFromSelection(int32_t aSelectionNum)</span>
<span class="lineNum">    1684 </span>            : {
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = DOMSelection();</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :   if (!domSel)</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :   if (aSelectionNum &lt; 0 || aSelectionNum &gt;= static_cast&lt;int32_t&gt;(domSel-&gt;RangeCount()))</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :   domSel-&gt;RemoveRange(domSel-&gt;GetRangeAt(aSelectionNum));</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    1694 </span>            : }
<a name="1695"><span class="lineNum">    1695 </span>            : </a>
<span class="lineNum">    1696 </span>            : void
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 : HyperTextAccessible::ScrollSubstringTo(int32_t aStartOffset, int32_t aEndOffset,</span>
<span class="lineNum">    1698 </span>            :                                        uint32_t aScrollType)
<span class="lineNum">    1699 </span>            : {
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsRange&gt; range = new nsRange(mContent);</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :   if (OffsetsToDOMRange(aStartOffset, aEndOffset, range))</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :     nsCoreUtils::ScrollSubstringTo(GetFrame(), range, aScrollType);</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 : }</span>
<a name="1704"><span class="lineNum">    1704 </span>            : </a>
<span class="lineNum">    1705 </span>            : void
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 : HyperTextAccessible::ScrollSubstringToPoint(int32_t aStartOffset,</span>
<span class="lineNum">    1707 </span>            :                                             int32_t aEndOffset,
<span class="lineNum">    1708 </span>            :                                             uint32_t aCoordinateType,
<span class="lineNum">    1709 </span>            :                                             int32_t aX, int32_t aY)
<span class="lineNum">    1710 </span>            : {
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :   nsIFrame *frame = GetFrame();</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :   if (!frame)</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :   nsIntPoint coords = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :                                                         this);</span>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsRange&gt; range = new nsRange(mContent);</span>
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :   if (!OffsetsToDOMRange(aStartOffset, aEndOffset, range))</span>
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = frame-&gt;PresContext();</span>
<span class="lineNum">    1723 </span>            :   nsPoint coordsInAppUnits =
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :     ToAppUnits(coords, presContext-&gt;AppUnitsPerDevPixel());</span>
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :   bool initialScrolled = false;</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   nsIFrame *parentFrame = frame;</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   while ((parentFrame = parentFrame-&gt;GetParent())) {</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     nsIScrollableFrame *scrollableFrame = do_QueryFrame(parentFrame);</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :     if (scrollableFrame) {</span>
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :       if (!initialScrolled) {</span>
<span class="lineNum">    1732 </span>            :         // Scroll substring to the given point. Turn the point into percents
<span class="lineNum">    1733 </span>            :         // relative scrollable area to use nsCoreUtils::ScrollSubstringTo.
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :         nsRect frameRect = parentFrame-&gt;GetScreenRectInAppUnits();</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :         nscoord offsetPointX = coordsInAppUnits.x - frameRect.x;</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :         nscoord offsetPointY = coordsInAppUnits.y - frameRect.y;</span>
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :         nsSize size(parentFrame-&gt;GetSize());</span>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :         // avoid divide by zero
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :         size.width = size.width ? size.width : 1;</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :         size.height = size.height ? size.height : 1;</span>
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :         int16_t hPercent = offsetPointX * 100 / size.width;</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :         int16_t vPercent = offsetPointY * 100 / size.height;</span>
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :         nsresult rv = nsCoreUtils::ScrollSubstringTo(frame, range,</span>
<span class="lineNum">    1748 </span>            :                                                      nsIPresShell::ScrollAxis(vPercent),
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :                                                      nsIPresShell::ScrollAxis(hPercent));</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv))</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :         initialScrolled = true;</span>
<span class="lineNum">    1754 </span>            :       } else {
<span class="lineNum">    1755 </span>            :         // Substring was scrolled to the given point already inside its closest
<span class="lineNum">    1756 </span>            :         // scrollable area. If there are nested scrollable areas then make
<span class="lineNum">    1757 </span>            :         // sure we scroll lower areas to the given point inside currently
<span class="lineNum">    1758 </span>            :         // traversed scrollable area.
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :         nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);</span>
<span class="lineNum">    1760 </span>            :       }
<span class="lineNum">    1761 </span>            :     }
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :     frame = parentFrame;</span>
<span class="lineNum">    1763 </span>            :   }
<span class="lineNum">    1764 </span>            : }
<a name="1765"><span class="lineNum">    1765 </span>            : </a>
<span class="lineNum">    1766 </span>            : void
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 : HyperTextAccessible::EnclosingRange(a11y::TextRange&amp; aRange) const</span>
<span class="lineNum">    1768 </span>            : {
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :   if (IsTextField()) {</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     aRange.Set(mDoc, const_cast&lt;HyperTextAccessible*&gt;(this), 0,</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :                const_cast&lt;HyperTextAccessible*&gt;(this), CharacterCount());</span>
<span class="lineNum">    1772 </span>            :   } else {
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :     aRange.Set(mDoc, mDoc, 0, mDoc, mDoc-&gt;CharacterCount());</span>
<span class="lineNum">    1774 </span>            :   }
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 : }</span>
<a name="1776"><span class="lineNum">    1776 </span>            : </a>
<span class="lineNum">    1777 </span>            : void
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 : HyperTextAccessible::SelectionRanges(nsTArray&lt;a11y::TextRange&gt;* aRanges) const</span>
<span class="lineNum">    1779 </span>            : {
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aRanges-&gt;Length() == 0, &quot;TextRange array supposed to be empty&quot;);</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   dom::Selection* sel = DOMSelection();</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :   if (!sel)</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :   aRanges-&gt;SetCapacity(sel-&gt;RangeCount());</span>
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :   for (uint32_t idx = 0; idx &lt; sel-&gt;RangeCount(); idx++) {</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     nsRange* DOMRange = sel-&gt;GetRangeAt(idx);</span>
<span class="lineNum">    1790 </span>            :     HyperTextAccessible* startContainer =
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :       nsAccUtils::GetTextContainer(DOMRange-&gt;GetStartContainer());</span>
<span class="lineNum">    1792 </span>            :     HyperTextAccessible* endContainer =
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :       nsAccUtils::GetTextContainer(DOMRange-&gt;GetEndContainer());</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :     if (!startContainer || !endContainer) {</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    1796 </span>            :     }
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            :     int32_t startOffset =
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :       startContainer-&gt;DOMPointToOffset(DOMRange-&gt;GetStartContainer(),</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :                                        DOMRange-&gt;StartOffset(), false);</span>
<span class="lineNum">    1801 </span>            :     int32_t endOffset =
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :       endContainer-&gt;DOMPointToOffset(DOMRange-&gt;GetEndContainer(),</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :                                      DOMRange-&gt;EndOffset(), true);</span>
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :     TextRange tr(IsTextField() ? const_cast&lt;HyperTextAccessible*&gt;(this) : mDoc,</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :                     startContainer, startOffset, endContainer, endOffset);</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :     *(aRanges-&gt;AppendElement()) = Move(tr);</span>
<span class="lineNum">    1808 </span>            :   }
<span class="lineNum">    1809 </span>            : }
<a name="1810"><span class="lineNum">    1810 </span>            : </a>
<span class="lineNum">    1811 </span>            : void
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 : HyperTextAccessible::VisibleRanges(nsTArray&lt;a11y::TextRange&gt;* aRanges) const</span>
<span class="lineNum">    1813 </span>            : {
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 : }</span>
<a name="1815"><span class="lineNum">    1815 </span>            : </a>
<span class="lineNum">    1816 </span>            : void
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 : HyperTextAccessible::RangeByChild(Accessible* aChild,</span>
<span class="lineNum">    1818 </span>            :                                   a11y::TextRange&amp; aRange) const
<span class="lineNum">    1819 </span>            : {
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :   HyperTextAccessible* ht = aChild-&gt;AsHyperText();</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :   if (ht) {</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     aRange.Set(mDoc, ht, 0, ht, ht-&gt;CharacterCount());</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1824 </span>            :   }
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :   Accessible* child = aChild;</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   Accessible* parent = nullptr;</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   while ((parent = child-&gt;Parent()) &amp;&amp; !(ht = parent-&gt;AsHyperText()))</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :     child = parent;</span>
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :   // If no text then return collapsed text range, otherwise return a range
<span class="lineNum">    1832 </span>            :   // containing the text enclosed by the given child.
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :   if (ht) {</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :     int32_t childIdx = child-&gt;IndexInParent();</span>
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :     int32_t startOffset = ht-&gt;GetChildOffset(childIdx);</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     int32_t endOffset = child-&gt;IsTextLeaf() ?</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :       ht-&gt;GetChildOffset(childIdx + 1) : startOffset;</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :     aRange.Set(mDoc, ht, startOffset, ht, endOffset);</span>
<span class="lineNum">    1839 </span>            :   }
<span class="lineNum">    1840 </span>            : }
<a name="1841"><span class="lineNum">    1841 </span>            : </a>
<span class="lineNum">    1842 </span>            : void
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 : HyperTextAccessible::RangeAtPoint(int32_t aX, int32_t aY,</span>
<span class="lineNum">    1844 </span>            :                                   a11y::TextRange&amp; aRange) const
<span class="lineNum">    1845 </span>            : {
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :   Accessible* child = mDoc-&gt;ChildAtPoint(aX, aY, eDeepestChild);</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :   if (!child)</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1849 </span>            : 
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   Accessible* parent = nullptr;</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :   while ((parent = child-&gt;Parent()) &amp;&amp; !parent-&gt;IsHyperText())</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     child = parent;</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :   // Return collapsed text range for the point.
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   if (parent) {</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :     HyperTextAccessible* ht = parent-&gt;AsHyperText();</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :     int32_t offset = ht-&gt;GetChildOffset(child);</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :     aRange.Set(mDoc, ht, offset, ht, offset);</span>
<span class="lineNum">    1859 </span>            :   }
<span class="lineNum">    1860 </span>            : }
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1863 </span>            : // Accessible public
<span class="lineNum">    1864 </span>            : 
<a name="1865"><span class="lineNum">    1865 </span>            : // Accessible protected</a>
<span class="lineNum">    1866 </span>            : ENameValueFlag
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 : HyperTextAccessible::NativeName(nsString&amp; aName)</span>
<span class="lineNum">    1868 </span>            : {
<span class="lineNum">    1869 </span>            :   // Check @alt attribute for invalid img elements.
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :   bool hasImgAlt = false;</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsHTMLElement(nsGkAtoms::img)) {</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     hasImgAlt = mContent-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aName);</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     if (!aName.IsEmpty())</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :       return eNameOK;</span>
<span class="lineNum">    1875 </span>            :   }
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :   ENameValueFlag nameFlag = AccessibleWrap::NativeName(aName);</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :   if (!aName.IsEmpty())</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     return nameFlag;</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            :   // Get name from title attribute for HTML abbr and acronym elements making it
<span class="lineNum">    1882 </span>            :   // a valid name from markup. Otherwise their name isn't picked up by recursive
<span class="lineNum">    1883 </span>            :   // name computation algorithm. See NS_OK_NAME_FROM_TOOLTIP.
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :   if (IsAbbreviation() &amp;&amp;</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :       mContent-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::title, aName))</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     aName.CompressWhitespace();</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :   return hasImgAlt ? eNoNameOnPurpose : eNameOK;</span>
<span class="lineNum">    1889 </span>            : }
<a name="1890"><span class="lineNum">    1890 </span>            : </a>
<span class="lineNum">    1891 </span>            : void
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 : HyperTextAccessible::Shutdown()</span>
<span class="lineNum">    1893 </span>            : {
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :   mOffsets.Clear();</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   AccessibleWrap::Shutdown();</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 : }</span>
<a name="1897"><span class="lineNum">    1897 </span>            : </a>
<span class="lineNum">    1898 </span>            : bool
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 : HyperTextAccessible::RemoveChild(Accessible* aAccessible)</span>
<span class="lineNum">    1900 </span>            : {
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   int32_t childIndex = aAccessible-&gt;IndexInParent();</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :   int32_t count = mOffsets.Length() - childIndex;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :   if (count &gt; 0)</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :     mOffsets.RemoveElementsAt(childIndex, count);</span>
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :   return AccessibleWrap::RemoveChild(aAccessible);</span>
<span class="lineNum">    1907 </span>            : }
<a name="1908"><span class="lineNum">    1908 </span>            : </a>
<span class="lineNum">    1909 </span>            : bool
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 : HyperTextAccessible::InsertChildAt(uint32_t aIndex, Accessible* aChild)</span>
<span class="lineNum">    1911 </span>            : {
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :   int32_t count = mOffsets.Length() - aIndex;</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :   if (count &gt; 0 ) {</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :     mOffsets.RemoveElementsAt(aIndex, count);</span>
<span class="lineNum">    1915 </span>            :   }
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :   return AccessibleWrap::InsertChildAt(aIndex, aChild);</span>
<span class="lineNum">    1917 </span>            : }
<a name="1918"><span class="lineNum">    1918 </span>            : </a>
<span class="lineNum">    1919 </span>            : Relation
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 : HyperTextAccessible::RelationByType(RelationType aType)</span>
<span class="lineNum">    1921 </span>            : {
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :   Relation rel = Accessible::RelationByType(aType);</span>
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :   switch (aType) {</span>
<span class="lineNum">    1925 </span>            :     case RelationType::NODE_CHILD_OF:
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :       if (HasOwnContent() &amp;&amp; mContent-&gt;IsMathMLElement()) {</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :         Accessible* parent = Parent();</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :         if (parent) {</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :           nsIContent* parentContent = parent-&gt;GetContent();</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :           if (parentContent &amp;&amp;</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :               parentContent-&gt;IsMathMLElement(nsGkAtoms::mroot_)) {</span>
<span class="lineNum">    1932 </span>            :             // Add a relation pointing to the parent &lt;mroot&gt;.
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :             rel.AppendTarget(parent);</span>
<span class="lineNum">    1934 </span>            :           }
<span class="lineNum">    1935 </span>            :         }
<span class="lineNum">    1936 </span>            :       }
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1938 </span>            :     case RelationType::NODE_PARENT_OF:
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :       if (HasOwnContent() &amp;&amp; mContent-&gt;IsMathMLElement(nsGkAtoms::mroot_)) {</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :         Accessible* base = GetChildAt(0);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :         Accessible* index = GetChildAt(1);</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :         if (base &amp;&amp; index) {</span>
<span class="lineNum">    1943 </span>            :           // Append the &lt;mroot&gt; children in the order index, base.
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :           rel.AppendTarget(index);</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :           rel.AppendTarget(base);</span>
<span class="lineNum">    1946 </span>            :         }
<span class="lineNum">    1947 </span>            :       }
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1949 </span>            :     default:
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1951 </span>            :   }
<span class="lineNum">    1952 </span>            : 
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :   return rel;</span>
<span class="lineNum">    1954 </span>            : }
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1957 </span>            : // HyperTextAccessible public static
<a name="1958"><span class="lineNum">    1958 </span>            : </a>
<span class="lineNum">    1959 </span>            : nsresult
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 : HyperTextAccessible::ContentToRenderedOffset(nsIFrame* aFrame, int32_t aContentOffset,</span>
<span class="lineNum">    1961 </span>            :                                              uint32_t* aRenderedOffset) const
<span class="lineNum">    1962 </span>            : {
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :   if (!aFrame) {</span>
<span class="lineNum">    1964 </span>            :     // Current frame not rendered -- this can happen if text is set on
<span class="lineNum">    1965 </span>            :     // something with display: none
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :     *aRenderedOffset = 0;</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1968 </span>            :   }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :   if (IsTextField()) {</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     *aRenderedOffset = aContentOffset;</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1973 </span>            :   }
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aFrame-&gt;IsTextFrame(), &quot;Need text frame for offset conversion&quot;);</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aFrame-&gt;GetPrevContinuation() == nullptr,</span>
<span class="lineNum">    1977 </span>            :                &quot;Call on primary frame only&quot;);
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            :   nsIFrame::RenderedText text = aFrame-&gt;GetRenderedText(aContentOffset,
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :       aContentOffset + 1, nsIFrame::TextOffsetType::OFFSETS_IN_CONTENT_TEXT,</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :       nsIFrame::TrailingWhitespace::DONT_TRIM_TRAILING_WHITESPACE);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :   *aRenderedOffset = text.mOffsetWithinNodeRenderedText;</span>
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    1985 </span>            : }
<a name="1986"><span class="lineNum">    1986 </span>            : </a>
<span class="lineNum">    1987 </span>            : nsresult
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 : HyperTextAccessible::RenderedToContentOffset(nsIFrame* aFrame, uint32_t aRenderedOffset,</span>
<span class="lineNum">    1989 </span>            :                                              int32_t* aContentOffset) const
<span class="lineNum">    1990 </span>            : {
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :   if (IsTextField()) {</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     *aContentOffset = aRenderedOffset;</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    1994 </span>            :   }
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :   *aContentOffset = 0;</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(aFrame, NS_ERROR_FAILURE);</span>
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aFrame-&gt;IsTextFrame(), &quot;Need text frame for offset conversion&quot;);</span>
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aFrame-&gt;GetPrevContinuation() == nullptr,</span>
<span class="lineNum">    2001 </span>            :                &quot;Call on primary frame only&quot;);
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span>            :   nsIFrame::RenderedText text = aFrame-&gt;GetRenderedText(aRenderedOffset,
<span class="lineNum">    2004 </span>            :       aRenderedOffset + 1, nsIFrame::TextOffsetType::OFFSETS_IN_RENDERED_TEXT,
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :       nsIFrame::TrailingWhitespace::DONT_TRIM_TRAILING_WHITESPACE);</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :   *aContentOffset = text.mOffsetWithinNodeText;</span>
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    2009 </span>            : }
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2012 </span>            : // HyperTextAccessible public
<a name="2013"><span class="lineNum">    2013 </span>            : </a>
<span class="lineNum">    2014 </span>            : int32_t
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetChildOffset(uint32_t aChildIndex,</span>
<span class="lineNum">    2016 </span>            :                                     bool aInvalidateAfter) const
<span class="lineNum">    2017 </span>            : {
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :   if (aChildIndex == 0) {</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :     if (aInvalidateAfter)</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :       mOffsets.Clear();</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :     return aChildIndex;</span>
<span class="lineNum">    2023 </span>            :   }
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :   int32_t count = mOffsets.Length() - aChildIndex;</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :   if (count &gt; 0) {</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     if (aInvalidateAfter)</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :       mOffsets.RemoveElementsAt(aChildIndex, count);</span>
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :     return mOffsets[aChildIndex - 1];</span>
<span class="lineNum">    2031 </span>            :   }
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :   uint32_t lastOffset = mOffsets.IsEmpty() ?</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :     0 : mOffsets[mOffsets.Length() - 1];</span>
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :   while (mOffsets.Length() &lt; aChildIndex) {</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :     Accessible* child = mChildren[mOffsets.Length()];</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :     lastOffset += nsAccUtils::TextLength(child);</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     mOffsets.AppendElement(lastOffset);</span>
<span class="lineNum">    2040 </span>            :   }
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :   return mOffsets[aChildIndex - 1];</span>
<span class="lineNum">    2043 </span>            : }
<a name="2044"><span class="lineNum">    2044 </span>            : </a>
<span class="lineNum">    2045 </span>            : int32_t
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetChildIndexAtOffset(uint32_t aOffset) const</span>
<span class="lineNum">    2047 </span>            : {
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :   uint32_t lastOffset = 0;</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :   const uint32_t offsetCount = mOffsets.Length();</span>
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :   if (offsetCount &gt; 0) {</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :     lastOffset = mOffsets[offsetCount - 1];</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :     if (aOffset &lt; lastOffset) {</span>
<span class="lineNum">    2054 </span>            :       size_t index;
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :       if (BinarySearch(mOffsets, 0, offsetCount, aOffset, &amp;index)) {</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         return (index &lt; (offsetCount - 1)) ? index + 1 : index;</span>
<span class="lineNum">    2057 </span>            :       }
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :       return (index == offsetCount) ? -1 : index;</span>
<span class="lineNum">    2060 </span>            :     }
<span class="lineNum">    2061 </span>            :   }
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :   uint32_t childCount = ChildCount();</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :   while (mOffsets.Length() &lt; childCount) {</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :     Accessible* child = GetChildAt(mOffsets.Length());</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :     lastOffset += nsAccUtils::TextLength(child);</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :     mOffsets.AppendElement(lastOffset);</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :     if (aOffset &lt; lastOffset)</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :       return mOffsets.Length() - 1;</span>
<span class="lineNum">    2070 </span>            :   }
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :   if (aOffset == lastOffset)</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :     return mOffsets.Length() - 1;</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :   return -1;</span>
<span class="lineNum">    2076 </span>            : }
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    2079 </span>            : // HyperTextAccessible protected
<a name="2080"><span class="lineNum">    2080 </span>            : </a>
<span class="lineNum">    2081 </span>            : nsresult
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetDOMPointByFrameOffset(nsIFrame* aFrame, int32_t aOffset,</span>
<span class="lineNum">    2083 </span>            :                                               Accessible* aAccessible,
<span class="lineNum">    2084 </span>            :                                               DOMPoint* aPoint)
<span class="lineNum">    2085 </span>            : {
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aAccessible);</span>
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :   if (!aFrame) {</span>
<span class="lineNum">    2089 </span>            :     // If the given frame is null then set offset after the DOM node of the
<span class="lineNum">    2090 </span>            :     // given accessible.
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!aAccessible-&gt;IsDoc(),</span>
<span class="lineNum">    2092 </span>            :                  &quot;Shouldn't be called on document accessible!&quot;);
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :     nsIContent* content = aAccessible-&gt;GetContent();</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :     NS_ASSERTION(content, &quot;Shouldn't operate on defunct accessible!&quot;);</span>
<span class="lineNum">    2096 </span>            : 
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :     nsIContent* parent = content-&gt;GetParent();</span>
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :     aPoint-&gt;idx = parent-&gt;IndexOf(content) + 1;</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :     aPoint-&gt;node = parent;</span>
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :   } else if (aFrame-&gt;IsTextFrame()) {</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :     nsIContent* content = aFrame-&gt;GetContent();</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :     NS_ENSURE_STATE(content);</span>
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :     nsIFrame *primaryFrame = content-&gt;GetPrimaryFrame();</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :     nsresult rv = RenderedToContentOffset(primaryFrame, aOffset, &amp;(aPoint-&gt;idx));</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :     aPoint-&gt;node = content;</span>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span>            :   } else {
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :     nsIContent* content = aFrame-&gt;GetContent();</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :     NS_ENSURE_STATE(content);</span>
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     nsIContent* parent = content-&gt;GetParent();</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     NS_ENSURE_STATE(parent);</span>
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :     aPoint-&gt;idx = parent-&gt;IndexOf(content);</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :     aPoint-&gt;node = parent;</span>
<span class="lineNum">    2121 </span>            :   }
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    2124 </span>            : }
<span class="lineNum">    2125 </span>            : 
<a name="2126"><span class="lineNum">    2126 </span>            : // HyperTextAccessible</a>
<span class="lineNum">    2127 </span>            : void
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 : HyperTextAccessible::GetSpellTextAttr(nsINode* aNode,</span>
<span class="lineNum">    2129 </span>            :                                       int32_t aNodeOffset,
<span class="lineNum">    2130 </span>            :                                       uint32_t* aStartOffset,
<span class="lineNum">    2131 </span>            :                                       uint32_t* aEndOffset,
<span class="lineNum">    2132 </span>            :                                       nsIPersistentProperties* aAttributes)
<span class="lineNum">    2133 </span>            : {
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsFrameSelection&gt; fs = FrameSelection();</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :   if (!fs)</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :   dom::Selection* domSel = fs-&gt;GetSelection(SelectionType::eSpellCheck);</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :   if (!domSel)</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :   int32_t rangeCount = domSel-&gt;RangeCount();</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   if (rangeCount &lt;= 0)</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :   uint32_t startOffset = 0, endOffset = 0;</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 :   for (int32_t idx = 0; idx &lt; rangeCount; idx++) {</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     nsRange* range = domSel-&gt;GetRangeAt(idx);</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :     if (range-&gt;Collapsed())</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            :     // See if the point comes after the range in which case we must continue in
<span class="lineNum">    2153 </span>            :     // case there is another range after this one.
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :     nsINode* endNode = range-&gt;GetEndContainer();</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :     int32_t endNodeOffset = range-&gt;EndOffset();</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :     if (nsContentUtils::ComparePoints(aNode, aNodeOffset,</span>
<span class="lineNum">    2157 </span>            :                                       endNode, endNodeOffset) &gt;= 0)
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    2159 </span>            : 
<span class="lineNum">    2160 </span>            :     // At this point our point is either in this range or before it but after
<span class="lineNum">    2161 </span>            :     // the previous range.  So we check to see if the range starts before the
<span class="lineNum">    2162 </span>            :     // point in which case the point is in the missspelled range, otherwise it
<span class="lineNum">    2163 </span>            :     // must be before the range and after the previous one if any.
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :     nsINode* startNode = range-&gt;GetStartContainer();</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :     int32_t startNodeOffset = range-&gt;StartOffset();</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :     if (nsContentUtils::ComparePoints(startNode, startNodeOffset, aNode,</span>
<span class="lineNum">    2167 </span>            :                                       aNodeOffset) &lt;= 0) {
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :       startOffset = DOMPointToOffset(startNode, startNodeOffset);</span>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :       endOffset = DOMPointToOffset(endNode, endNodeOffset);</span>
<span class="lineNum">    2171 </span>            : 
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :       if (startOffset &gt; *aStartOffset)</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :         *aStartOffset = startOffset;</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :       if (endOffset &lt; *aEndOffset)</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :         *aEndOffset = endOffset;</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :       if (aAttributes) {</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :         nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::invalid,</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :                                NS_LITERAL_STRING(&quot;spelling&quot;));</span>
<span class="lineNum">    2181 </span>            :       }
<span class="lineNum">    2182 </span>            : 
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    2184 </span>            :     }
<span class="lineNum">    2185 </span>            : 
<span class="lineNum">    2186 </span>            :     // This range came after the point.
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :     endOffset = DOMPointToOffset(startNode, startNodeOffset);</span>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :     if (idx &gt; 0) {</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :       nsRange* prevRange = domSel-&gt;GetRangeAt(idx - 1);</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :       startOffset = DOMPointToOffset(prevRange-&gt;GetEndContainer(),</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :                                      prevRange-&gt;EndOffset());</span>
<span class="lineNum">    2193 </span>            :     }
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :     if (startOffset &gt; *aStartOffset)</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :       *aStartOffset = startOffset;</span>
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :     if (endOffset &lt; *aEndOffset)</span>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :       *aEndOffset = endOffset;</span>
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2202 </span>            :   }
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            :   // We never found a range that ended after the point, therefore we know that
<span class="lineNum">    2205 </span>            :   // the point is not in a range, that we do not need to compute an end offset,
<span class="lineNum">    2206 </span>            :   // and that we should use the end offset of the last range to compute the
<span class="lineNum">    2207 </span>            :   // start offset of the text attribute range.
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :   nsRange* prevRange = domSel-&gt;GetRangeAt(rangeCount - 1);</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :   startOffset = DOMPointToOffset(prevRange-&gt;GetEndContainer(),</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :                                  prevRange-&gt;EndOffset());</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   if (startOffset &gt; *aStartOffset)</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :     *aStartOffset = startOffset;</span>
<span class="lineNum">    2214 </span>            : }
<a name="2215"><span class="lineNum">    2215 </span>            : </a>
<span class="lineNum">    2216 </span>            : bool
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 : HyperTextAccessible::IsTextRole()</span>
<span class="lineNum">    2218 </span>            : {
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :   const nsRoleMapEntry* roleMapEntry = ARIARoleMap();</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :   if (roleMapEntry &amp;&amp;</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :       (roleMapEntry-&gt;role == roles::GRAPHIC ||</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :        roleMapEntry-&gt;role == roles::IMAGE_MAP ||</span>
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :        roleMapEntry-&gt;role == roles::SLIDER ||</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :        roleMapEntry-&gt;role == roles::PROGRESSBAR ||</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :        roleMapEntry-&gt;role == roles::SEPARATOR))</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2229 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

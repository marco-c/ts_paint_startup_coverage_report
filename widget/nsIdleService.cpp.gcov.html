<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - widget/nsIdleService.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">widget</a> - nsIdleService.cpp<span style="font-size: 80%;"> (source / <a href="nsIdleService.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">88</td>
            <td class="headerCovTableEntry">263</td>
            <td class="headerCovTableEntryLo">33.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryLo">56.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim:expandtab:shiftwidth=2:tabstop=2:
<span class="lineNum">       3 </span>            :  */
<span class="lineNum">       4 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       5 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       6 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;nsIdleService.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;nsString.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;nsIObserverService.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;nsIServiceManager.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;nsDebug.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;nsCOMArray.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsXULAppAPI.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;prinrval.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/Logging.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;prtime.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/dom/ContentChild.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mozilla/Services.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      22 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">      25 </span>            : #include &lt;android/log.h&gt;
<span class="lineNum">      26 </span>            : #endif
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : using namespace mozilla;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : // interval in milliseconds between internal idle time requests.
<span class="lineNum">      31 </span>            : #define MIN_IDLE_POLL_INTERVAL_MSEC (5 * PR_MSEC_PER_SEC) /* 5 sec */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : // After the twenty four hour period expires for an idle daily, this is the
<span class="lineNum">      34 </span>            : // amount of idle time we wait for before actually firing the idle-daily
<span class="lineNum">      35 </span>            : // event.
<span class="lineNum">      36 </span>            : #define DAILY_SIGNIFICANT_IDLE_SERVICE_SEC (3 * 60)
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : // In cases where it's been longer than twenty four hours since the last
<span class="lineNum">      39 </span>            : // idle-daily, this is the shortend amount of idle time we wait for before
<span class="lineNum">      40 </span>            : // firing the idle-daily event.
<span class="lineNum">      41 </span>            : #define DAILY_SHORTENED_IDLE_SERVICE_SEC 60
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : // Pref for last time (seconds since epoch) daily notification was sent.
<span class="lineNum">      44 </span>            : #define PREF_LAST_DAILY &quot;idle.lastDailyNotification&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : // Number of seconds in a day.
<span class="lineNum">      47 </span>            : #define SECONDS_PER_DAY 86400
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : static LazyLogModule sLog(&quot;idleService&quot;);
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #define LOG_TAG &quot;GeckoIdleService&quot;
<span class="lineNum">      52 </span>            : #define LOG_LEVEL ANDROID_LOG_DEBUG
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : // Use this to find previously added observers in our array:
<span class="lineNum">      55 </span>            : class IdleListenerComparator
<a name="56"><span class="lineNum">      56 </span>            : {</a>
<span class="lineNum">      57 </span>            : public:
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   bool Equals(IdleListener a, IdleListener b) const</span>
<span class="lineNum">      59 </span>            :   {
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     return (a.observer == b.observer) &amp;&amp;</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :            (a.reqIdleTime == b.reqIdleTime);</span>
<span class="lineNum">      62 </span>            :   }
<span class="lineNum">      63 </span>            : };
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : ////////////////////////////////////////////////////////////////////////////////
<a name="66"><span class="lineNum">      66 </span>            : //// nsIdleServiceDaily</a>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineCov">         16 : NS_IMPL_ISUPPORTS(nsIdleServiceDaily, nsIObserver, nsISupportsWeakReference)</span>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<span class="lineNum">      70 </span>            : NS_IMETHODIMP
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : nsIdleServiceDaily::Observe(nsISupports *,</span>
<span class="lineNum">      72 </span>            :                             const char *aTopic,
<span class="lineNum">      73 </span>            :                             const char16_t *)
<span class="lineNum">      74 </span>            : {
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">      76 </span>            :          (&quot;nsIdleServiceDaily: Observe '%s' (%d)&quot;,
<span class="lineNum">      77 </span>            :           aTopic, mShutdownInProgress));
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   if (strcmp(aTopic, &quot;profile-after-change&quot;) == 0) {</span>
<span class="lineNum">      80 </span>            :     // We are back. Start sending notifications again.
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     mShutdownInProgress = false;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">      83 </span>            :   }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :   if (strcmp(aTopic, &quot;xpcom-will-shutdown&quot;) == 0 ||</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :       strcmp(aTopic, &quot;profile-change-teardown&quot;) == 0) {</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     mShutdownInProgress = true;</span>
<span class="lineNum">      88 </span>            :   }
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :   if (mShutdownInProgress || strcmp(aTopic, OBSERVER_TOPIC_ACTIVE) == 0) {</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">      92 </span>            :   }
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(strcmp(aTopic, OBSERVER_TOPIC_IDLE) == 0);</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">      96 </span>            :          (&quot;nsIdleServiceDaily: Notifying idle-daily observers&quot;));
<span class="lineNum">      97 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">      98 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">      99 </span>            :                       &quot;Notifying idle-daily observers&quot;);
<span class="lineNum">     100 </span>            : #endif
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   // Send the idle-daily observer event
<span class="lineNum">     103 </span>            :   nsCOMPtr&lt;nsIObserverService&gt; observerService =
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     mozilla::services::GetObserverService();</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   NS_ENSURE_STATE(observerService);</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   (void)observerService-&gt;NotifyObservers(nullptr,</span>
<span class="lineNum">     107 </span>            :                                          OBSERVER_TOPIC_IDLE_DAILY,
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                                          nullptr);</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :   // Notify the category observers.
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   nsCOMArray&lt;nsIObserver&gt; entries;</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   mCategoryObservers.GetEntries(entries);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   for (int32_t i = 0; i &lt; entries.Count(); ++i) {</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     (void)entries[i]-&gt;Observe(nullptr, OBSERVER_TOPIC_IDLE_DAILY, nullptr);</span>
<span class="lineNum">     115 </span>            :   }
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   // Stop observing idle for today.
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   (void)mIdleService-&gt;RemoveIdleObserver(this, mIdleDailyTriggerWait);</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :   // Set the last idle-daily time pref.
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   int32_t nowSec = static_cast&lt;int32_t&gt;(PR_Now() / PR_USEC_PER_SEC);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   Preferences::SetInt(PREF_LAST_DAILY, nowSec);</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :   // Force that to be stored so we don't retrigger twice a day under
<span class="lineNum">     125 </span>            :   // any circumstances.
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   nsIPrefService* prefs = Preferences::GetService();</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   if (prefs) {</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     prefs-&gt;SavePrefFile(nullptr);</span>
<span class="lineNum">     129 </span>            :   }
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     132 </span>            :          (&quot;nsIdleServiceDaily: Storing last idle time as %d sec.&quot;, nowSec));
<span class="lineNum">     133 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     134 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     135 </span>            :                       &quot;Storing last idle time as %d&quot;, nowSec);
<span class="lineNum">     136 </span>            : #endif
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :   // Note the moment we expect to get the next timer callback
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   mExpectedTriggerTime  = PR_Now() + ((PRTime)SECONDS_PER_DAY *</span>
<span class="lineNum">     140 </span>            :                                       (PRTime)PR_USEC_PER_SEC);
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     143 </span>            :          (&quot;nsIdleServiceDaily: Restarting daily timer&quot;));
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   // Start timer for the next check in one day.
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   (void)mTimer-&gt;InitWithNamedFuncCallback(DailyCallback,</span>
<span class="lineNum">     147 </span>            :                                           this,
<span class="lineNum">     148 </span>            :                                           SECONDS_PER_DAY * PR_MSEC_PER_SEC,
<span class="lineNum">     149 </span>            :                                           nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                                           &quot;nsIdleServiceDaily::Observe&quot;);</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<a name="153"><span class="lineNum">     153 </span>            : }</a>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineCov">          1 : nsIdleServiceDaily::nsIdleServiceDaily(nsIIdleService* aIdleService)</span>
<span class="lineNum">     156 </span>            :   : mIdleService(aIdleService)
<span class="lineNum">     157 </span><span class="lineCov">          2 :   , mTimer(do_CreateInstance(NS_TIMER_CONTRACTID))</span>
<span class="lineNum">     158 </span>            :   , mCategoryObservers(OBSERVER_TOPIC_IDLE_DAILY)
<span class="lineNum">     159 </span>            :   , mShutdownInProgress(false)
<span class="lineNum">     160 </span>            :   , mExpectedTriggerTime(0)
<span class="lineNum">     161 </span><span class="lineCov">          3 :   , mIdleDailyTriggerWait(DAILY_SIGNIFICANT_IDLE_SERVICE_SEC)</span>
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span><span class="lineCov">          1 : }</span>
<a name="164"><span class="lineNum">     164 </span>            : </a>
<span class="lineNum">     165 </span>            : void
<span class="lineNum">     166 </span><span class="lineCov">          1 : nsIdleServiceDaily::Init()</span>
<span class="lineNum">     167 </span>            : {
<span class="lineNum">     168 </span>            :   // First check the time of the last idle-daily event notification. If it
<span class="lineNum">     169 </span>            :   // has been 24 hours or higher, or if we have never sent an idle-daily,
<span class="lineNum">     170 </span>            :   // get ready to send an idle-daily event. Otherwise set a timer targeted
<span class="lineNum">     171 </span>            :   // at 24 hours past the last idle-daily we sent.
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineCov">          1 :   int32_t nowSec = static_cast&lt;int32_t&gt;(PR_Now() / PR_USEC_PER_SEC);</span>
<span class="lineNum">     174 </span><span class="lineCov">          1 :   int32_t lastDaily = Preferences::GetInt(PREF_LAST_DAILY, 0);</span>
<span class="lineNum">     175 </span><span class="lineCov">          1 :   if (lastDaily &lt; 0 || lastDaily &gt; nowSec) {</span>
<span class="lineNum">     176 </span>            :     // The time is bogus, use default.
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     lastDaily = 0;</span>
<span class="lineNum">     178 </span>            :   }
<span class="lineNum">     179 </span><span class="lineCov">          1 :   int32_t secondsSinceLastDaily = nowSec - lastDaily;</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineCov">          1 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     182 </span>            :          (&quot;nsIdleServiceDaily: Init: seconds since last daily: %d&quot;,
<span class="lineNum">     183 </span>            :           secondsSinceLastDaily));
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :   // If it has been twenty four hours or more or if we have never sent an
<span class="lineNum">     186 </span>            :   // idle-daily event get ready to send it during the next idle period.
<span class="lineNum">     187 </span><span class="lineCov">          1 :   if (secondsSinceLastDaily &gt; SECONDS_PER_DAY) {</span>
<span class="lineNum">     188 </span>            :     // Check for a &quot;long wait&quot;, e.g. 48-hours or more.
<span class="lineNum">     189 </span><span class="lineCov">          1 :     bool hasBeenLongWait = (lastDaily &amp;&amp;</span>
<span class="lineNum">     190 </span><span class="lineCov">          1 :                             (secondsSinceLastDaily &gt; (SECONDS_PER_DAY * 2)));</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineCov">          1 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     193 </span>            :            (&quot;nsIdleServiceDaily: has been long wait? %d&quot;,
<span class="lineNum">     194 </span>            :             hasBeenLongWait));
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :     // StageIdleDaily sets up a wait for the user to become idle and then
<span class="lineNum">     197 </span>            :     // sends the idle-daily event.
<span class="lineNum">     198 </span><span class="lineCov">          1 :     StageIdleDaily(hasBeenLongWait);</span>
<span class="lineNum">     199 </span>            :   } else {
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     201 </span>            :            (&quot;nsIdleServiceDaily: Setting timer a day from now&quot;));
<span class="lineNum">     202 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     203 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     204 </span>            :                         &quot;Setting timer a day from now&quot;);
<span class="lineNum">     205 </span>            : #endif
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     // According to our last idle-daily pref, the last idle-daily was fired
<span class="lineNum">     208 </span>            :     // less then 24 hours ago. Set a wait for the amount of time remaining.
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     int32_t milliSecLeftUntilDaily = (SECONDS_PER_DAY - secondsSinceLastDaily)</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :       * PR_MSEC_PER_SEC;</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     213 </span>            :            (&quot;nsIdleServiceDaily: Seconds till next timeout: %d&quot;,
<span class="lineNum">     214 </span>            :             (SECONDS_PER_DAY - secondsSinceLastDaily)));
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     // Mark the time at which we expect this to fire. On systems with faulty
<span class="lineNum">     217 </span>            :     // timers, we need to be able to cross check that the timer fired at the
<span class="lineNum">     218 </span>            :     // expected time.
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     mExpectedTriggerTime  = PR_Now() +</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :       (milliSecLeftUntilDaily * PR_USEC_PER_MSEC);</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     (void)mTimer-&gt;InitWithNamedFuncCallback(DailyCallback,</span>
<span class="lineNum">     223 </span>            :                                             this,
<span class="lineNum">     224 </span>            :                                             milliSecLeftUntilDaily,
<span class="lineNum">     225 </span>            :                                             nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                                             &quot;nsIdleServiceDaily::Init&quot;);</span>
<span class="lineNum">     227 </span>            :   }
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   // Register for when we should terminate/pause
<span class="lineNum">     230 </span><span class="lineCov">          2 :   nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     231 </span><span class="lineCov">          1 :   if (obs) {</span>
<span class="lineNum">     232 </span><span class="lineCov">          1 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     233 </span>            :            (&quot;nsIdleServiceDaily: Registering for system event observers.&quot;));
<span class="lineNum">     234 </span><span class="lineCov">          1 :     obs-&gt;AddObserver(this, &quot;xpcom-will-shutdown&quot;, true);</span>
<span class="lineNum">     235 </span><span class="lineCov">          1 :     obs-&gt;AddObserver(this, &quot;profile-change-teardown&quot;, true);</span>
<span class="lineNum">     236 </span><span class="lineCov">          1 :     obs-&gt;AddObserver(this, &quot;profile-after-change&quot;, true);</span>
<span class="lineNum">     237 </span>            :   }
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 : nsIdleServiceDaily::~nsIdleServiceDaily()</span>
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   if (mTimer) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     mTimer-&gt;Cancel();</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     mTimer = nullptr;</span>
<span class="lineNum">     245 </span>            :   }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     247 </span>            : 
<a name="248"><span class="lineNum">     248 </span>            : </a>
<span class="lineNum">     249 </span>            : void
<span class="lineNum">     250 </span><span class="lineCov">          1 : nsIdleServiceDaily::StageIdleDaily(bool aHasBeenLongWait)</span>
<span class="lineNum">     251 </span>            : {
<span class="lineNum">     252 </span><span class="lineCov">          1 :   NS_ASSERTION(mIdleService, &quot;No idle service available?&quot;);</span>
<span class="lineNum">     253 </span><span class="lineCov">          1 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     254 </span>            :           (&quot;nsIdleServiceDaily: Registering Idle observer callback &quot;
<span class="lineNum">     255 </span>            :            &quot;(short wait requested? %d)&quot;, aHasBeenLongWait));
<span class="lineNum">     256 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     257 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     258 </span>            :                       &quot;Registering Idle observer callback&quot;);
<span class="lineNum">     259 </span>            : #endif
<span class="lineNum">     260 </span><span class="lineCov">          1 :   mIdleDailyTriggerWait = (aHasBeenLongWait ?</span>
<span class="lineNum">     261 </span>            :                              DAILY_SHORTENED_IDLE_SERVICE_SEC :
<span class="lineNum">     262 </span>            :                              DAILY_SIGNIFICANT_IDLE_SERVICE_SEC);
<span class="lineNum">     263 </span><span class="lineCov">          1 :   (void)mIdleService-&gt;AddIdleObserver(this, mIdleDailyTriggerWait);</span>
<span class="lineNum">     264 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     265 </span>            : 
<a name="266"><span class="lineNum">     266 </span>            : // static</a>
<span class="lineNum">     267 </span>            : void
<span class="lineNum">     268 </span><span class="lineNoCov">          0 : nsIdleServiceDaily::DailyCallback(nsITimer* aTimer, void* aClosure)</span>
<span class="lineNum">     269 </span>            : {
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     271 </span>            :           (&quot;nsIdleServiceDaily: DailyCallback running&quot;));
<span class="lineNum">     272 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     273 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     274 </span>            :                       &quot;DailyCallback running&quot;);
<span class="lineNum">     275 </span>            : #endif
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   nsIdleServiceDaily* self = static_cast&lt;nsIdleServiceDaily*&gt;(aClosure);</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :   // Check to be sure the timer didn't fire early. This currently only
<span class="lineNum">     280 </span>            :   // happens on android.
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   PRTime now = PR_Now();</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   if (self-&gt;mExpectedTriggerTime &amp;&amp; now &lt; self-&gt;mExpectedTriggerTime) {</span>
<span class="lineNum">     283 </span>            :     // Timer returned early, reschedule to the appropriate time.
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     PRTime delayTime = self-&gt;mExpectedTriggerTime - now;</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     // Add 10 ms to ensure we don't undershoot, and never get a &quot;0&quot; timer.
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     delayTime += 10 * PR_USEC_PER_MSEC;</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug, (&quot;nsIdleServiceDaily: DailyCallback resetting timer to %&quot; PRId64 &quot; msec&quot;,</span>
<span class="lineNum">     290 </span>            :                         delayTime / PR_USEC_PER_MSEC));
<span class="lineNum">     291 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     292 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     293 </span>            :                         &quot;DailyCallback resetting timer to %&quot; PRId64 &quot; msec&quot;,
<span class="lineNum">     294 </span>            :                         delayTime / PR_USEC_PER_MSEC);
<span class="lineNum">     295 </span>            : #endif
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     (void)self-&gt;mTimer-&gt;InitWithNamedFuncCallback(</span>
<span class="lineNum">     298 </span>            :       DailyCallback,
<span class="lineNum">     299 </span>            :       self,
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :       delayTime / PR_USEC_PER_MSEC,</span>
<span class="lineNum">     301 </span>            :       nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :       &quot;nsIdleServiceDaily::DailyCallback&quot;);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     304 </span>            :   }
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   // Register for a short term wait for idle event. When this fires we fire
<span class="lineNum">     307 </span>            :   // our idle-daily event.
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   self-&gt;StageIdleDaily(false);</span>
<span class="lineNum">     309 </span>            : }
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /**
<span class="lineNum">     313 </span>            :  * The idle services goal is to notify subscribers when a certain time has
<span class="lineNum">     314 </span>            :  * passed since the last user interaction with the system.
<span class="lineNum">     315 </span>            :  *
<span class="lineNum">     316 </span>            :  * On some platforms this is defined as the last time user events reached this
<span class="lineNum">     317 </span>            :  * application, on other platforms it is a system wide thing - the preferred
<span class="lineNum">     318 </span>            :  * implementation is to use the system idle time, rather than the application
<span class="lineNum">     319 </span>            :  * idle time, as the things depending on the idle service are likely to use
<span class="lineNum">     320 </span>            :  * significant resources (network, disk, memory, cpu, etc.).
<span class="lineNum">     321 </span>            :  *
<span class="lineNum">     322 </span>            :  * When the idle service needs to use the system wide idle timer, it typically
<span class="lineNum">     323 </span>            :  * needs to poll the idle time value by the means of a timer.  It needs to
<span class="lineNum">     324 </span>            :  * poll fast when it is in active idle mode (when it has a listener in the idle
<span class="lineNum">     325 </span>            :  * mode) as it needs to detect if the user is active in other applications.
<span class="lineNum">     326 </span>            :  *
<span class="lineNum">     327 </span>            :  * When the service is waiting for the first listener to become idle, or when
<span class="lineNum">     328 </span>            :  * it is only monitoring application idle time, it only needs to have the timer
<span class="lineNum">     329 </span>            :  * expire at the time the next listener goes idle.
<span class="lineNum">     330 </span>            :  *
<span class="lineNum">     331 </span>            :  * The core state of the service is determined by:
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  * - A list of listeners.
<span class="lineNum">     334 </span>            :  *
<span class="lineNum">     335 </span>            :  * - A boolean that tells if any listeners are in idle mode.
<span class="lineNum">     336 </span>            :  *
<span class="lineNum">     337 </span>            :  * - A delta value that indicates when, measured from the last non-idle time,
<span class="lineNum">     338 </span>            :  *   the next listener should switch to idle mode.
<span class="lineNum">     339 </span>            :  *
<span class="lineNum">     340 </span>            :  * - An absolute time of the last time idle mode was detected (this is used to
<span class="lineNum">     341 </span>            :  *   judge if we have been out of idle mode since the last invocation of the
<span class="lineNum">     342 </span>            :  *   service.
<span class="lineNum">     343 </span>            :  *
<span class="lineNum">     344 </span>            :  * There are four entry points into the system:
<span class="lineNum">     345 </span>            :  *
<span class="lineNum">     346 </span>            :  * - A new listener is registered.
<span class="lineNum">     347 </span>            :  *
<span class="lineNum">     348 </span>            :  * - An existing listener is deregistered.
<span class="lineNum">     349 </span>            :  *
<span class="lineNum">     350 </span>            :  * - User interaction is detected.
<span class="lineNum">     351 </span>            :  *
<span class="lineNum">     352 </span>            :  * - The timer expires.
<span class="lineNum">     353 </span>            :  *
<span class="lineNum">     354 </span>            :  * When a new listener is added its idle timeout, is compared with the next idle
<span class="lineNum">     355 </span>            :  * timeout, and if lower, that time is stored as the new timeout, and the timer
<span class="lineNum">     356 </span>            :  * is reconfigured to ensure a timeout around the time the new listener should
<span class="lineNum">     357 </span>            :  * timeout.
<span class="lineNum">     358 </span>            :  *
<span class="lineNum">     359 </span>            :  * If the next idle time is above the idle time requested by the new listener
<span class="lineNum">     360 </span>            :  * it won't be informed until the timer expires, this is to avoid recursive
<span class="lineNum">     361 </span>            :  * behavior and to simplify the code.  In this case the timer will be set to
<span class="lineNum">     362 </span>            :  * about 10 ms.
<span class="lineNum">     363 </span>            :  *
<span class="lineNum">     364 </span>            :  * When an existing listener is deregistered, it is just removed from the list
<span class="lineNum">     365 </span>            :  * of active listeners, we don't stop the timer, we just let it expire.
<span class="lineNum">     366 </span>            :  *
<span class="lineNum">     367 </span>            :  * When user interaction is detected, either because it was directly detected or
<span class="lineNum">     368 </span>            :  * because we polled the system timer and found it to be unexpected low, then we
<span class="lineNum">     369 </span>            :  * check the flag that tells us if any listeners are in idle mode, if there are
<span class="lineNum">     370 </span>            :  * they are removed from idle mode and told so, and we reset our state
<span class="lineNum">     371 </span>            :  * caculating the next timeout and restart the timer if needed.
<span class="lineNum">     372 </span>            :  *
<span class="lineNum">     373 </span>            :  * ---- Build in logic
<span class="lineNum">     374 </span>            :  *
<span class="lineNum">     375 </span>            :  * In order to avoid restarting the timer endlessly, the timer function has
<span class="lineNum">     376 </span>            :  * logic that will only restart the timer, if the requested timeout is before
<span class="lineNum">     377 </span>            :  * the current timeout.
<span class="lineNum">     378 </span>            :  *
<span class="lineNum">     379 </span>            :  */
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     383 </span>            : //// nsIdleService
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : namespace { 
<span class="lineNum">     386 </span>            : nsIdleService* gIdleService;
<span class="lineNum">     387 </span>            : } // namespace
<a name="388"><span class="lineNum">     388 </span>            : </a>
<span class="lineNum">     389 </span>            : already_AddRefed&lt;nsIdleService&gt;
<span class="lineNum">     390 </span><span class="lineCov">          1 : nsIdleService::GetInstance()</span>
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span><span class="lineCov">          2 :   RefPtr&lt;nsIdleService&gt; instance(gIdleService);</span>
<span class="lineNum">     393 </span><span class="lineCov">          2 :   return instance.forget();</span>
<a name="394"><span class="lineNum">     394 </span>            : }</a>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">          1 : nsIdleService::nsIdleService() : mCurrentlySetToTimeoutAt(TimeStamp()),</span>
<span class="lineNum">     397 </span>            :                                  mIdleObserverCount(0),
<span class="lineNum">     398 </span>            :                                  mDeltaToNextIdleSwitchInS(UINT32_MAX),
<span class="lineNum">     399 </span><span class="lineCov">          1 :                                  mLastUserInteraction(TimeStamp::Now())</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineCov">          1 :   MOZ_ASSERT(!gIdleService);</span>
<span class="lineNum">     402 </span><span class="lineCov">          1 :   gIdleService = this;</span>
<span class="lineNum">     403 </span><span class="lineCov">          1 :   if (XRE_IsParentProcess()) {</span>
<span class="lineNum">     404 </span><span class="lineCov">          1 :     mDailyIdle = new nsIdleServiceDaily(this);</span>
<span class="lineNum">     405 </span><span class="lineCov">          1 :     mDailyIdle-&gt;Init();</span>
<span class="lineNum">     406 </span>            :   }
<a name="407"><span class="lineNum">     407 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 : nsIdleService::~nsIdleService()</span>
<span class="lineNum">     410 </span>            : {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   if(mTimer) {</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     mTimer-&gt;Cancel();</span>
<span class="lineNum">     413 </span>            :   }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(gIdleService == this);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   gIdleService = nullptr;</span>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineCov">         69 : NS_IMPL_ISUPPORTS(nsIdleService, nsIIdleService, nsIIdleServiceInternal)</span>
<a name="421"><span class="lineNum">     421 </span>            : </a>
<span class="lineNum">     422 </span>            : NS_IMETHODIMP
<span class="lineNum">     423 </span><span class="lineCov">          3 : nsIdleService::AddIdleObserver(nsIObserver* aObserver, uint32_t aIdleTimeInS)</span>
<span class="lineNum">     424 </span>            : {
<span class="lineNum">     425 </span><span class="lineCov">          3 :   NS_ENSURE_ARG_POINTER(aObserver);</span>
<span class="lineNum">     426 </span>            :   // We don't accept idle time at 0, and we can't handle idle time that are too
<span class="lineNum">     427 </span>            :   // high either - no more than ~136 years.
<span class="lineNum">     428 </span><span class="lineCov">          3 :   NS_ENSURE_ARG_RANGE(aIdleTimeInS, 1, (UINT32_MAX / 10) - 1);</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">          3 :   if (XRE_IsContentProcess()) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     dom::ContentChild* cpc = dom::ContentChild::GetSingleton();</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :     cpc-&gt;AddIdleObserver(aObserver, aIdleTimeInS);</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     434 </span>            :   }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">          3 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     437 </span>            :        (&quot;idleService: Register idle observer %p for %d seconds&quot;,
<span class="lineNum">     438 </span>            :         aObserver, aIdleTimeInS));
<span class="lineNum">     439 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     440 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     441 </span>            :                       &quot;Register idle observer %p for %d seconds&quot;,
<span class="lineNum">     442 </span>            :                       aObserver, aIdleTimeInS);
<span class="lineNum">     443 </span>            : #endif
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :   // Put the time + observer in a struct we can keep:
<span class="lineNum">     446 </span><span class="lineCov">          6 :   IdleListener listener(aObserver, aIdleTimeInS);</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">          3 :   if (!mArrayListeners.AppendElement(listener)) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     450 </span>            :   }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :   // Create our timer callback if it's not there already.
<span class="lineNum">     453 </span><span class="lineCov">          3 :   if (!mTimer) {</span>
<span class="lineNum">     454 </span>            :     nsresult rv;
<span class="lineNum">     455 </span><span class="lineCov">          1 :     mTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &amp;rv);</span>
<span class="lineNum">     456 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">     457 </span>            :   }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   // Check if the newly added observer has a smaller wait time than what we
<span class="lineNum">     460 </span>            :   // are waiting for now.
<span class="lineNum">     461 </span><span class="lineCov">          3 :   if (mDeltaToNextIdleSwitchInS &gt; aIdleTimeInS) {</span>
<span class="lineNum">     462 </span>            :     // If it is, then this is the next to move to idle (at this point we
<span class="lineNum">     463 </span>            :     // don't care if it should have switched already).
<span class="lineNum">     464 </span><span class="lineCov">          2 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     465 </span>            :           (&quot;idleService: Register: adjusting next switch from %d to %d seconds&quot;,
<span class="lineNum">     466 </span>            :            mDeltaToNextIdleSwitchInS, aIdleTimeInS));
<span class="lineNum">     467 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     468 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     469 </span>            :                         &quot;Register: adjusting next switch from %d to %d seconds&quot;,
<span class="lineNum">     470 </span>            :                         mDeltaToNextIdleSwitchInS, aIdleTimeInS);
<span class="lineNum">     471 </span>            : #endif
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">          2 :     mDeltaToNextIdleSwitchInS = aIdleTimeInS;</span>
<span class="lineNum">     474 </span>            :   }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :   // Ensure timer is running.
<span class="lineNum">     477 </span><span class="lineCov">          3 :   ReconfigureTimer();</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">          3 :   return NS_OK;</span>
<span class="lineNum">     480 </span>            : }
<a name="481"><span class="lineNum">     481 </span>            : </a>
<span class="lineNum">     482 </span>            : NS_IMETHODIMP
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : nsIdleService::RemoveIdleObserver(nsIObserver* aObserver, uint32_t aTimeInS)</span>
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG_POINTER(aObserver);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :   NS_ENSURE_ARG(aTimeInS);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   if (XRE_IsContentProcess()) {</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :     dom::ContentChild* cpc = dom::ContentChild::GetSingleton();</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :     cpc-&gt;RemoveIdleObserver(aObserver, aTimeInS);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     493 </span>            :   }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   IdleListener listener(aObserver, aTimeInS);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   // Find the entry and remove it, if it was the last entry, we just let the
<span class="lineNum">     498 </span>            :   // existing timer run to completion (there might be a new registration in a
<span class="lineNum">     499 </span>            :   // little while.
<span class="lineNum">     500 </span>            :   IdleListenerComparator c;
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   nsTArray&lt;IdleListener&gt;::index_type listenerIndex = mArrayListeners.IndexOf(listener, 0, c);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   if (listenerIndex != mArrayListeners.NoIndex) {</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     if (mArrayListeners.ElementAt(listenerIndex).isIdle)</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :       mIdleObserverCount--;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     mArrayListeners.RemoveElementAt(listenerIndex);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     507 </span>            :            (&quot;idleService: Remove observer %p (%d seconds), %d remain idle&quot;,
<span class="lineNum">     508 </span>            :             aObserver, aTimeInS, mIdleObserverCount));
<span class="lineNum">     509 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     510 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     511 </span>            :                         &quot;Remove observer %p (%d seconds), %d remain idle&quot;,
<span class="lineNum">     512 </span>            :                         aObserver, aTimeInS, mIdleObserverCount);
<span class="lineNum">     513 </span>            : #endif
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     515 </span>            :   }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :   // If we get here, we haven't removed anything:
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Warning, </span>
<span class="lineNum">     519 </span>            :          (&quot;idleService: Failed to remove idle observer %p (%d seconds)&quot;,
<span class="lineNum">     520 </span>            :           aObserver, aTimeInS));
<span class="lineNum">     521 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     522 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     523 </span>            :                       &quot;Failed to remove idle observer %p (%d seconds)&quot;,
<span class="lineNum">     524 </span>            :                       aObserver, aTimeInS);
<span class="lineNum">     525 </span>            : #endif
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">     527 </span>            : }
<a name="528"><span class="lineNum">     528 </span>            : </a>
<span class="lineNum">     529 </span>            : NS_IMETHODIMP
<span class="lineNum">     530 </span><span class="lineCov">          4 : nsIdleService::ResetIdleTimeOut(uint32_t idleDeltaInMS)</span>
<span class="lineNum">     531 </span>            : {
<span class="lineNum">     532 </span><span class="lineCov">          4 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     533 </span>            :          (&quot;idleService: Reset idle timeout (last interaction %u msec)&quot;,
<span class="lineNum">     534 </span>            :           idleDeltaInMS));
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            :   // Store the time
<span class="lineNum">     537 </span><span class="lineCov">          8 :   mLastUserInteraction = TimeStamp::Now() -</span>
<span class="lineNum">     538 </span><span class="lineCov">         12 :                          TimeDuration::FromMilliseconds(idleDeltaInMS);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   // If no one is idle, then we are done, any existing timers can keep running.
<span class="lineNum">     541 </span><span class="lineCov">          4 :   if (mIdleObserverCount == 0) {</span>
<span class="lineNum">     542 </span><span class="lineCov">          4 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     543 </span>            :            (&quot;idleService: Reset idle timeout: no idle observers&quot;));
<span class="lineNum">     544 </span><span class="lineCov">          4 :     return NS_OK;</span>
<span class="lineNum">     545 </span>            :   }
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :   // Mark all idle services as non-idle, and calculate the next idle timeout.
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   nsCOMArray&lt;nsIObserver&gt; notifyList;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   mDeltaToNextIdleSwitchInS = UINT32_MAX;</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :   // Loop through all listeners, and find any that have detected idle.
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mArrayListeners.Length(); i++) {</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     IdleListener&amp; curListener = mArrayListeners.ElementAt(i);</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            :     // If the listener was idle, then he shouldn't be any longer.
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     if (curListener.isIdle) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       notifyList.AppendObject(curListener.observer);</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       curListener.isIdle = false;</span>
<span class="lineNum">     559 </span>            :     }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :     // Check if the listener is the next one to timeout.
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     mDeltaToNextIdleSwitchInS = std::min(mDeltaToNextIdleSwitchInS,</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                                        curListener.reqIdleTime);</span>
<span class="lineNum">     564 </span>            :   }
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :   // When we are done, then we wont have anyone idle.
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   mIdleObserverCount = 0;</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :   // Restart the idle timer, and do so before anyone can delay us.
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   ReconfigureTimer();</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   int32_t numberOfPendingNotifications = notifyList.Count();</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :   // Bail if nothing to do.
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   if (!numberOfPendingNotifications) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     577 </span>            :   }
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :   // Now send &quot;active&quot; events to all, if any should have timed out already,
<span class="lineNum">     580 </span>            :   // then they will be reawaken by the timer that is already running.
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :   // We need a text string to send with any state change events.
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   nsAutoString timeStr;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   timeStr.AppendInt((int32_t)(idleDeltaInMS / PR_MSEC_PER_SEC));</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   // Send the &quot;non-idle&quot; events.
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   while (numberOfPendingNotifications--) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     590 </span>            :            (&quot;idleService: Reset idle timeout: tell observer %p user is back&quot;,
<span class="lineNum">     591 </span>            :             notifyList[numberOfPendingNotifications]));
<span class="lineNum">     592 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     593 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     594 </span>            :                         &quot;Reset idle timeout: tell observer %p user is back&quot;,
<span class="lineNum">     595 </span>            :                         notifyList[numberOfPendingNotifications]);
<span class="lineNum">     596 </span>            : #endif
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     notifyList[numberOfPendingNotifications]-&gt;Observe(this,</span>
<span class="lineNum">     598 </span>            :                                                       OBSERVER_TOPIC_ACTIVE,
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                                                       timeStr.get());</span>
<span class="lineNum">     600 </span>            :   }
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     602 </span>            : }
<a name="603"><span class="lineNum">     603 </span>            : </a>
<span class="lineNum">     604 </span>            : NS_IMETHODIMP
<span class="lineNum">     605 </span><span class="lineNoCov">          0 : nsIdleService::GetIdleTime(uint32_t* idleTime)</span>
<span class="lineNum">     606 </span>            : {
<span class="lineNum">     607 </span>            :   // Check sanity of in parameter.
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   if (!idleTime) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     return NS_ERROR_NULL_POINTER;</span>
<span class="lineNum">     610 </span>            :   }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :   // Polled idle time in ms.
<span class="lineNum">     613 </span>            :   uint32_t polledIdleTimeMS;
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   bool polledIdleTimeIsValid = PollIdleTime(&amp;polledIdleTimeMS);</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     618 </span>            :          (&quot;idleService: Get idle time: polled %u msec, valid = %d&quot;,
<span class="lineNum">     619 </span>            :           polledIdleTimeMS, polledIdleTimeIsValid));
<span class="lineNum">     620 </span>            :   
<span class="lineNum">     621 </span>            :   // timeSinceReset is in milliseconds.
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   TimeDuration timeSinceReset = TimeStamp::Now() - mLastUserInteraction;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   uint32_t timeSinceResetInMS = timeSinceReset.ToMilliseconds();</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     626 </span>            :          (&quot;idleService: Get idle time: time since reset %u msec&quot;,
<span class="lineNum">     627 </span>            :           timeSinceResetInMS));
<span class="lineNum">     628 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     629 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     630 </span>            :                       &quot;Get idle time: time since reset %u msec&quot;,
<span class="lineNum">     631 </span>            :                       timeSinceResetInMS);
<span class="lineNum">     632 </span>            : #endif
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   // If we did't get pulled data, return the time since last idle reset.
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   if (!polledIdleTimeIsValid) {</span>
<span class="lineNum">     636 </span>            :     // We need to convert to ms before returning the time.
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     *idleTime = timeSinceResetInMS;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">     639 </span>            :   }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :   // Otherwise return the shortest time detected (in ms).
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :   *idleTime = std::min(timeSinceResetInMS, polledIdleTimeMS);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     645 </span>            : }
<span class="lineNum">     646 </span>            : 
<a name="647"><span class="lineNum">     647 </span>            : </a>
<span class="lineNum">     648 </span>            : bool
<span class="lineNum">     649 </span><span class="lineNoCov">          0 : nsIdleService::PollIdleTime(uint32_t* /*aIdleTime*/)</span>
<span class="lineNum">     650 </span>            : {
<span class="lineNum">     651 </span>            :   // Default behavior is not to have the ability to poll an idle time.
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     653 </span>            : }
<a name="654"><span class="lineNum">     654 </span>            : </a>
<span class="lineNum">     655 </span>            : bool
<span class="lineNum">     656 </span><span class="lineNoCov">          0 : nsIdleService::UsePollMode()</span>
<span class="lineNum">     657 </span>            : {
<span class="lineNum">     658 </span>            :   uint32_t dummy;
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :   return PollIdleTime(&amp;dummy);</span>
<span class="lineNum">     660 </span>            : }
<a name="661"><span class="lineNum">     661 </span>            : </a>
<span class="lineNum">     662 </span>            : void
<span class="lineNum">     663 </span><span class="lineNoCov">          0 : nsIdleService::StaticIdleTimerCallback(nsITimer* aTimer, void* aClosure)</span>
<span class="lineNum">     664 </span>            : {
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :   static_cast&lt;nsIdleService*&gt;(aClosure)-&gt;IdleTimerCallback();</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 : }</span>
<a name="667"><span class="lineNum">     667 </span>            : </a>
<span class="lineNum">     668 </span>            : void
<span class="lineNum">     669 </span><span class="lineNoCov">          0 : nsIdleService::IdleTimerCallback(void)</span>
<span class="lineNum">     670 </span>            : {
<span class="lineNum">     671 </span>            :   // Remember that we no longer have a timer running.
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   mCurrentlySetToTimeoutAt = TimeStamp();</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :   // Find the last detected idle time.
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   uint32_t lastIdleTimeInMS = static_cast&lt;uint32_t&gt;((TimeStamp::Now() -</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :                               mLastUserInteraction).ToMilliseconds());</span>
<span class="lineNum">     677 </span>            :   // Get the current idle time.
<span class="lineNum">     678 </span>            :   uint32_t currentIdleTimeInMS;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :   if (NS_FAILED(GetIdleTime(&amp;currentIdleTimeInMS))) {</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Info,</span>
<span class="lineNum">     682 </span>            :            (&quot;idleService: Idle timer callback: failed to get idle time&quot;));
<span class="lineNum">     683 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     684 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     685 </span>            :                         &quot;Idle timer callback: failed to get idle time&quot;);
<span class="lineNum">     686 </span>            : #endif
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     691 </span>            :          (&quot;idleService: Idle timer callback: current idle time %u msec&quot;,
<span class="lineNum">     692 </span>            :           currentIdleTimeInMS));
<span class="lineNum">     693 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     694 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     695 </span>            :                       &quot;Idle timer callback: current idle time %u msec&quot;,
<span class="lineNum">     696 </span>            :                       currentIdleTimeInMS);
<span class="lineNum">     697 </span>            : #endif
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :   // Check if we have had some user interaction we didn't handle previously
<span class="lineNum">     700 </span>            :   // we do the calculation in ms to lessen the chance for rounding errors to
<span class="lineNum">     701 </span>            :   // trigger wrong results.
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   if (lastIdleTimeInMS &gt; currentIdleTimeInMS)</span>
<span class="lineNum">     703 </span>            :   {
<span class="lineNum">     704 </span>            :     // We had user activity, so handle that part first (to ensure the listeners
<span class="lineNum">     705 </span>            :     // don't risk getting an non-idle after they get a new idle indication.
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     ResetIdleTimeOut(currentIdleTimeInMS);</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :     // NOTE: We can't bail here, as we might have something already timed out.
<span class="lineNum">     709 </span>            :   }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :   // Find the idle time in S.
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   uint32_t currentIdleTimeInS = currentIdleTimeInMS / PR_MSEC_PER_SEC;</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   // Restart timer and bail if no-one are expected to be in idle
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   if (mDeltaToNextIdleSwitchInS &gt; currentIdleTimeInS) {</span>
<span class="lineNum">     716 </span>            :     // If we didn't expect anyone to be idle, then just re-start the timer.
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :     ReconfigureTimer();</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     719 </span>            :   }
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            :   // Tell expired listeners they are expired,and find the next timeout
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   Telemetry::AutoTimer&lt;Telemetry::IDLE_NOTIFY_IDLE_MS&gt; timer;</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :   // We need to initialise the time to the next idle switch.
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   mDeltaToNextIdleSwitchInS = UINT32_MAX;</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :   // Create list of observers that should be notified.
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   nsCOMArray&lt;nsIObserver&gt; notifyList;</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mArrayListeners.Length(); i++) {</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     IdleListener&amp; curListener = mArrayListeners.ElementAt(i);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :     // We are only interested in items, that are not in the idle state.
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     if (!curListener.isIdle) {</span>
<span class="lineNum">     735 </span>            :       // If they have an idle time smaller than the actual idle time.
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       if (curListener.reqIdleTime &lt;= currentIdleTimeInS) {</span>
<span class="lineNum">     737 </span>            :         // Then add the listener to the list of listeners that should be
<span class="lineNum">     738 </span>            :         // notified.
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :         notifyList.AppendObject(curListener.observer);</span>
<span class="lineNum">     740 </span>            :         // This listener is now idle.
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         curListener.isIdle = true;</span>
<span class="lineNum">     742 </span>            :         // Remember we have someone idle.
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         mIdleObserverCount++;</span>
<span class="lineNum">     744 </span>            :       } else {
<span class="lineNum">     745 </span>            :         // Listeners that are not timed out yet are candidates for timing out.
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         mDeltaToNextIdleSwitchInS = std::min(mDeltaToNextIdleSwitchInS,</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                                            curListener.reqIdleTime);</span>
<span class="lineNum">     748 </span>            :       }
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            :   }
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :   // Restart the timer before any notifications that could slow us down are
<span class="lineNum">     753 </span>            :   // done.
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   ReconfigureTimer();</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   int32_t numberOfPendingNotifications = notifyList.Count();</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   // Bail if nothing to do.
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   if (!numberOfPendingNotifications) {</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     761 </span>            :            (&quot;idleService: **** Idle timer callback: no observers to message.&quot;));
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     763 </span>            :   }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :   // We need a text string to send with any state change events.
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   nsAutoString timeStr;</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   timeStr.AppendInt(currentIdleTimeInS);</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :   // Notify all listeners that just timed out.
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   while (numberOfPendingNotifications--) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     772 </span>            :            (&quot;idleService: **** Idle timer callback: tell observer %p user is idle&quot;,
<span class="lineNum">     773 </span>            :             notifyList[numberOfPendingNotifications]));
<span class="lineNum">     774 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     775 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     776 </span>            :                       &quot;Idle timer callback: tell observer %p user is idle&quot;,
<span class="lineNum">     777 </span>            :                       notifyList[numberOfPendingNotifications]);
<span class="lineNum">     778 </span>            : #endif
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     notifyList[numberOfPendingNotifications]-&gt;Observe(this,</span>
<span class="lineNum">     780 </span>            :                                                       OBSERVER_TOPIC_IDLE,
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                                                       timeStr.get());</span>
<span class="lineNum">     782 </span>            :   }
<span class="lineNum">     783 </span>            : }
<a name="784"><span class="lineNum">     784 </span>            : </a>
<span class="lineNum">     785 </span>            : void
<span class="lineNum">     786 </span><span class="lineCov">          3 : nsIdleService::SetTimerExpiryIfBefore(TimeStamp aNextTimeout)</span>
<span class="lineNum">     787 </span>            : {
<span class="lineNum">     788 </span><span class="lineCov">          3 :   TimeDuration nextTimeoutDuration = aNextTimeout - TimeStamp::Now();</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineCov">          3 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     791 </span>            :          (&quot;idleService: SetTimerExpiryIfBefore: next timeout %0.f msec from now&quot;,
<span class="lineNum">     792 </span>            :           nextTimeoutDuration.ToMilliseconds()));
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     795 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     796 </span>            :                       &quot;SetTimerExpiryIfBefore: next timeout %0.f msec from now&quot;,
<span class="lineNum">     797 </span>            :                       nextTimeoutDuration.ToMilliseconds());
<span class="lineNum">     798 </span>            : #endif
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :   // Bail if we don't have a timer service.
<span class="lineNum">     801 </span><span class="lineCov">          3 :   if (!mTimer) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     803 </span>            :   }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :   // If the new timeout is before the old one or we don't have a timer running,
<span class="lineNum">     806 </span>            :   // then restart the timer.
<span class="lineNum">     807 </span><span class="lineCov">          5 :   if (mCurrentlySetToTimeoutAt.IsNull() ||</span>
<span class="lineNum">     808 </span><span class="lineCov">          2 :       mCurrentlySetToTimeoutAt &gt; aNextTimeout) {</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineCov">          2 :     mCurrentlySetToTimeoutAt = aNextTimeout;</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :     // Stop the current timer (it's ok to try'n stop it, even it isn't running).
<span class="lineNum">     813 </span><span class="lineCov">          2 :     mTimer-&gt;Cancel();</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :     // Check that the timeout is actually in the future, otherwise make it so.
<span class="lineNum">     816 </span><span class="lineCov">          2 :     TimeStamp currentTime = TimeStamp::Now();</span>
<span class="lineNum">     817 </span><span class="lineCov">          2 :     if (currentTime &gt; mCurrentlySetToTimeoutAt) {</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :       mCurrentlySetToTimeoutAt = currentTime;</span>
<span class="lineNum">     819 </span>            :     }
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :     // Add 10 ms to ensure we don't undershoot, and never get a &quot;0&quot; timer.
<span class="lineNum">     822 </span><span class="lineCov">          2 :     mCurrentlySetToTimeoutAt += TimeDuration::FromMilliseconds(10);</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineCov">          2 :     TimeDuration deltaTime = mCurrentlySetToTimeoutAt - currentTime;</span>
<span class="lineNum">     825 </span><span class="lineCov">          2 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     826 </span>            :            (&quot;idleService: IdleService reset timer expiry to %0.f msec from now&quot;,
<span class="lineNum">     827 </span>            :             deltaTime.ToMilliseconds()));
<span class="lineNum">     828 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     829 </span>            :     __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     830 </span>            :                         &quot;reset timer expiry to %0.f msec from now&quot;,
<span class="lineNum">     831 </span>            :                         deltaTime.ToMilliseconds());
<span class="lineNum">     832 </span>            : #endif
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     // Start the timer
<span class="lineNum">     835 </span><span class="lineCov">          4 :     mTimer-&gt;InitWithNamedFuncCallback(StaticIdleTimerCallback,</span>
<span class="lineNum">     836 </span>            :                                       this,
<span class="lineNum">     837 </span><span class="lineCov">          2 :                                       deltaTime.ToMilliseconds(),</span>
<span class="lineNum">     838 </span>            :                                       nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">     839 </span><span class="lineCov">          4 :                                       &quot;nsIdleService::SetTimerExpiryIfBefore&quot;);</span>
<span class="lineNum">     840 </span>            :   }
<span class="lineNum">     841 </span>            : }
<a name="842"><span class="lineNum">     842 </span>            : </a>
<span class="lineNum">     843 </span>            : void
<span class="lineNum">     844 </span><span class="lineCov">          3 : nsIdleService::ReconfigureTimer(void)</span>
<span class="lineNum">     845 </span>            : {
<span class="lineNum">     846 </span>            :   // Check if either someone is idle, or someone will become idle.
<span class="lineNum">     847 </span><span class="lineCov">          3 :   if ((mIdleObserverCount == 0) &amp;&amp; UINT32_MAX == mDeltaToNextIdleSwitchInS) {</span>
<span class="lineNum">     848 </span>            :     // If not, just let any existing timers run to completion
<span class="lineNum">     849 </span>            :     // And bail out.
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     851 </span>            :            (&quot;idleService: ReconfigureTimer: no idle or waiting observers&quot;));
<span class="lineNum">     852 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     853 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     854 </span>            :                       &quot;ReconfigureTimer: no idle or waiting observers&quot;);
<span class="lineNum">     855 </span>            : #endif
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     857 </span>            :   }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :   // Find the next timeout value, assuming we are not polling.
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :   // We need to store the current time, so we don't get artifacts from the time
<span class="lineNum">     862 </span>            :   // ticking while we are processing.
<span class="lineNum">     863 </span><span class="lineCov">          3 :   TimeStamp curTime = TimeStamp::Now();</span>
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :   TimeStamp nextTimeoutAt = mLastUserInteraction +
<span class="lineNum">     866 </span><span class="lineCov">          3 :                             TimeDuration::FromSeconds(mDeltaToNextIdleSwitchInS);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">          3 :   TimeDuration nextTimeoutDuration = nextTimeoutAt - curTime;</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">          3 :   MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     871 </span>            :          (&quot;idleService: next timeout %0.f msec from now&quot;,
<span class="lineNum">     872 </span>            :           nextTimeoutDuration.ToMilliseconds()));
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     875 </span>            :   __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     876 </span>            :                       &quot;next timeout %0.f msec from now&quot;,
<span class="lineNum">     877 </span>            :                       nextTimeoutDuration.ToMilliseconds());
<span class="lineNum">     878 </span>            : #endif
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            :   // Check if we should correct the timeout time because we should poll before.
<span class="lineNum">     881 </span><span class="lineCov">          3 :   if ((mIdleObserverCount &gt; 0) &amp;&amp; UsePollMode()) {</span>
<span class="lineNum">     882 </span>            :     TimeStamp pollTimeout =
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :         curTime + TimeDuration::FromMilliseconds(MIN_IDLE_POLL_INTERVAL_MSEC);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     if (nextTimeoutAt &gt; pollTimeout) {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       MOZ_LOG(sLog, LogLevel::Debug,</span>
<span class="lineNum">     887 </span>            :            (&quot;idleService: idle observers, reducing timeout to %lu msec from now&quot;,
<span class="lineNum">     888 </span>            :             MIN_IDLE_POLL_INTERVAL_MSEC));
<span class="lineNum">     889 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     890 </span>            :       __android_log_print(LOG_LEVEL, LOG_TAG,
<span class="lineNum">     891 </span>            :                           &quot;idle observers, reducing timeout to %lu msec from now&quot;,
<span class="lineNum">     892 </span>            :                           MIN_IDLE_POLL_INTERVAL_MSEC);
<span class="lineNum">     893 </span>            : #endif
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :       nextTimeoutAt = pollTimeout;</span>
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span>            :   }
<a name="897"><span class="lineNum">     897 </span>            : </a>
<span class="lineNum">     898 </span><span class="lineCov">          3 :   SetTimerExpiryIfBefore(nextTimeoutAt);</span>
<span class="lineNum">     899 </span><span class="lineCov">          9 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

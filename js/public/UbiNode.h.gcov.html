<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/public/UbiNode.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">js/public</a> - UbiNode.h<span style="font-size: 80%;"> (source / <a href="UbiNode.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">196</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">169</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef js_UbiNode_h
<span class="lineNum">       8 </span>            : #define js_UbiNode_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;mozilla/Alignment.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/Move.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/RangedPtr.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/TypeTraits.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/Variant.h&quot;
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;jspubtd.h&quot;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;js/GCAPI.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;js/HashTable.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;js/RootingAPI.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;js/TracingAPI.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;js/TypeDecls.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;js/UniquePtr.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;js/Value.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;js/Vector.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : // JS::ubi::Node
<span class="lineNum">      32 </span>            : //
<span class="lineNum">      33 </span>            : // JS::ubi::Node is a pointer-like type designed for internal use by heap
<span class="lineNum">      34 </span>            : // analysis tools. A ubi::Node can refer to:
<span class="lineNum">      35 </span>            : //
<span class="lineNum">      36 </span>            : // - a JS value, like a string, object, or symbol;
<span class="lineNum">      37 </span>            : // - an internal SpiderMonkey structure, like a shape or a scope chain object
<span class="lineNum">      38 </span>            : // - an instance of some embedding-provided type: in Firefox, an XPCOM
<span class="lineNum">      39 </span>            : //   object, or an internal DOM node class instance
<span class="lineNum">      40 </span>            : //
<span class="lineNum">      41 </span>            : // A ubi::Node instance provides metadata about its referent, and can
<span class="lineNum">      42 </span>            : // enumerate its referent's outgoing edges, so you can implement heap analysis
<span class="lineNum">      43 </span>            : // algorithms that walk the graph - finding paths between objects, or
<span class="lineNum">      44 </span>            : // computing heap dominator trees, say - using ubi::Node, while remaining
<span class="lineNum">      45 </span>            : // ignorant of the details of the types you're operating on.
<span class="lineNum">      46 </span>            : //
<span class="lineNum">      47 </span>            : // Of course, when it comes to presenting the results in a developer-facing
<span class="lineNum">      48 </span>            : // tool, you'll need to stop being ignorant of those details, because you have
<span class="lineNum">      49 </span>            : // to discuss the ubi::Nodes' referents with the developer. Here, ubi::Node
<span class="lineNum">      50 </span>            : // can hand you dynamically checked, properly typed pointers to the original
<span class="lineNum">      51 </span>            : // objects via the as&lt;T&gt; method, or generate descriptions of the referent
<span class="lineNum">      52 </span>            : // itself.
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : // ubi::Node instances are lightweight (two-word) value types. Instances:
<span class="lineNum">      55 </span>            : // - compare equal if and only if they refer to the same object;
<span class="lineNum">      56 </span>            : // - have hash values that respect their equality relation; and
<span class="lineNum">      57 </span>            : // - have serializations that are only equal if the ubi::Nodes are equal.
<span class="lineNum">      58 </span>            : //
<span class="lineNum">      59 </span>            : // A ubi::Node is only valid for as long as its referent is alive; if its
<span class="lineNum">      60 </span>            : // referent goes away, the ubi::Node becomes a dangling pointer. A ubi::Node
<span class="lineNum">      61 </span>            : // that refers to a GC-managed object is not automatically a GC root; if the
<span class="lineNum">      62 </span>            : // GC frees or relocates its referent, the ubi::Node becomes invalid. A
<span class="lineNum">      63 </span>            : // ubi::Node that refers to a reference-counted object does not bump the
<span class="lineNum">      64 </span>            : // reference count.
<span class="lineNum">      65 </span>            : //
<span class="lineNum">      66 </span>            : // ubi::Node values require no supporting data structures, making them
<span class="lineNum">      67 </span>            : // feasible for use in memory-constrained devices --- ideally, the memory
<span class="lineNum">      68 </span>            : // requirements of the algorithm which uses them will be the limiting factor,
<span class="lineNum">      69 </span>            : // not the demands of ubi::Node itself.
<span class="lineNum">      70 </span>            : //
<span class="lineNum">      71 </span>            : // One can construct a ubi::Node value given a pointer to a type that ubi::Node
<span class="lineNum">      72 </span>            : // supports. In the other direction, one can convert a ubi::Node back to a
<span class="lineNum">      73 </span>            : // pointer; these downcasts are checked dynamically. In particular, one can
<span class="lineNum">      74 </span>            : // convert a 'JSContext*' to a ubi::Node, yielding a node with an outgoing edge
<span class="lineNum">      75 </span>            : // for every root registered with the runtime; starting from this, one can walk
<span class="lineNum">      76 </span>            : // the entire heap. (Of course, one could also start traversal at any other kind
<span class="lineNum">      77 </span>            : // of type to which one has a pointer.)
<span class="lineNum">      78 </span>            : //
<span class="lineNum">      79 </span>            : //
<span class="lineNum">      80 </span>            : // Extending ubi::Node To Handle Your Embedding's Types
<span class="lineNum">      81 </span>            : //
<span class="lineNum">      82 </span>            : // To add support for a new ubi::Node referent type R, you must define a
<span class="lineNum">      83 </span>            : // specialization of the ubi::Concrete template, ubi::Concrete&lt;R&gt;, which
<span class="lineNum">      84 </span>            : // inherits from ubi::Base. ubi::Node itself uses the specialization for
<span class="lineNum">      85 </span>            : // compile-time information (i.e. the checked conversions between R * and
<span class="lineNum">      86 </span>            : // ubi::Node), and the inheritance for run-time dispatching.
<span class="lineNum">      87 </span>            : //
<span class="lineNum">      88 </span>            : //
<span class="lineNum">      89 </span>            : // ubi::Node Exposes Implementation Details
<span class="lineNum">      90 </span>            : //
<span class="lineNum">      91 </span>            : // In many cases, a JavaScript developer's view of their data differs
<span class="lineNum">      92 </span>            : // substantially from its actual implementation. For example, while the
<span class="lineNum">      93 </span>            : // ECMAScript specification describes objects as maps from property names to
<span class="lineNum">      94 </span>            : // sets of attributes (like ECMAScript's [[Value]]), in practice many objects
<span class="lineNum">      95 </span>            : // have only a pointer to a shape, shared with other similar objects, and
<span class="lineNum">      96 </span>            : // indexed slots that contain the [[Value]] attributes. As another example, a
<span class="lineNum">      97 </span>            : // string produced by concatenating two other strings may sometimes be
<span class="lineNum">      98 </span>            : // represented by a &quot;rope&quot;, a structure that points to the two original
<span class="lineNum">      99 </span>            : // strings.
<span class="lineNum">     100 </span>            : //
<span class="lineNum">     101 </span>            : // We intend to use ubi::Node to write tools that report memory usage, so it's
<span class="lineNum">     102 </span>            : // important that ubi::Node accurately portray how much memory nodes consume.
<span class="lineNum">     103 </span>            : // Thus, for example, when data that apparently belongs to multiple nodes is
<span class="lineNum">     104 </span>            : // in fact shared in a common structure, ubi::Node's graph uses a separate
<span class="lineNum">     105 </span>            : // node for that shared structure, and presents edges to it from the data's
<span class="lineNum">     106 </span>            : // apparent owners. For example, ubi::Node exposes SpiderMonkey objects'
<span class="lineNum">     107 </span>            : // shapes and base shapes, and exposes rope string and substring structure,
<span class="lineNum">     108 </span>            : // because these optimizations become visible when a tool reports how much
<span class="lineNum">     109 </span>            : // memory a structure consumes.
<span class="lineNum">     110 </span>            : //
<span class="lineNum">     111 </span>            : // However, fine granularity is not a goal. When a particular object is the
<span class="lineNum">     112 </span>            : // exclusive owner of a separate block of memory, ubi::Node may present the
<span class="lineNum">     113 </span>            : // object and its block as a single node, and add their sizes together when
<span class="lineNum">     114 </span>            : // reporting the node's size, as there is no meaningful loss of data in this
<span class="lineNum">     115 </span>            : // case. Thus, for example, a ubi::Node referring to a JavaScript object, when
<span class="lineNum">     116 </span>            : // asked for the object's size in bytes, includes the object's slot and
<span class="lineNum">     117 </span>            : // element arrays' sizes in the total. There is no separate ubi::Node value
<span class="lineNum">     118 </span>            : // representing the slot and element arrays, since they are owned exclusively
<span class="lineNum">     119 </span>            : // by the object.
<span class="lineNum">     120 </span>            : //
<span class="lineNum">     121 </span>            : //
<span class="lineNum">     122 </span>            : // Presenting Analysis Results To JavaScript Developers
<span class="lineNum">     123 </span>            : //
<span class="lineNum">     124 </span>            : // If an analysis provides its results in terms of ubi::Node values, a user
<span class="lineNum">     125 </span>            : // interface presenting those results will generally need to clean them up
<span class="lineNum">     126 </span>            : // before they can be understood by JavaScript developers. For example,
<span class="lineNum">     127 </span>            : // JavaScript developers should not need to understand shapes, only JavaScript
<span class="lineNum">     128 </span>            : // objects. Similarly, they should not need to understand the distinction
<span class="lineNum">     129 </span>            : // between DOM nodes and the JavaScript shadow objects that represent them.
<span class="lineNum">     130 </span>            : //
<span class="lineNum">     131 </span>            : //
<span class="lineNum">     132 </span>            : // Rooting Restrictions
<span class="lineNum">     133 </span>            : //
<span class="lineNum">     134 </span>            : // At present there is no way to root ubi::Node instances, so instances can't be
<span class="lineNum">     135 </span>            : // live across any operation that might GC. Analyses using ubi::Node must either
<span class="lineNum">     136 </span>            : // run to completion and convert their results to some other rootable type, or
<span class="lineNum">     137 </span>            : // save their intermediate state in some rooted structure if they must GC before
<span class="lineNum">     138 </span>            : // they complete. (For algorithms like path-finding and dominator tree
<span class="lineNum">     139 </span>            : // computation, we implement the algorithm avoiding any operation that could
<span class="lineNum">     140 </span>            : // cause a GC --- and use AutoCheckCannotGC to verify this.)
<span class="lineNum">     141 </span>            : //
<span class="lineNum">     142 </span>            : // If this restriction prevents us from implementing interesting tools, we may
<span class="lineNum">     143 </span>            : // teach the GC how to root ubi::Nodes, fix up hash tables that use them as
<span class="lineNum">     144 </span>            : // keys, etc.
<span class="lineNum">     145 </span>            : //
<span class="lineNum">     146 </span>            : //
<span class="lineNum">     147 </span>            : // Hostile Graph Structure
<span class="lineNum">     148 </span>            : //
<span class="lineNum">     149 </span>            : // Analyses consuming ubi::Node graphs must be robust when presented with graphs
<span class="lineNum">     150 </span>            : // that are deliberately constructed to exploit their weaknesses. When operating
<span class="lineNum">     151 </span>            : // on live graphs, web content has control over the object graph, and less
<span class="lineNum">     152 </span>            : // direct control over shape and string structure, and analyses should be
<span class="lineNum">     153 </span>            : // prepared to handle extreme cases gracefully. For example, if an analysis were
<span class="lineNum">     154 </span>            : // to use the C++ stack in a depth-first traversal, carefully constructed
<span class="lineNum">     155 </span>            : // content could cause the analysis to overflow the stack.
<span class="lineNum">     156 </span>            : //
<span class="lineNum">     157 </span>            : // When ubi::Nodes refer to nodes deserialized from a heap snapshot, analyses
<span class="lineNum">     158 </span>            : // must be even more careful: since snapshots often come from potentially
<span class="lineNum">     159 </span>            : // compromised e10s content processes, even properties normally guaranteed by
<span class="lineNum">     160 </span>            : // the platform (the proper linking of DOM nodes, for example) might be
<span class="lineNum">     161 </span>            : // corrupted. While it is the deserializer's responsibility to check the basic
<span class="lineNum">     162 </span>            : // structure of the snapshot file, the analyses should be prepared for ubi::Node
<span class="lineNum">     163 </span>            : // graphs constructed from snapshots to be even more bizarre.
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : class JSAtom;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : namespace JS {
<span class="lineNum">     168 </span>            : namespace ubi {
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : class Edge;
<span class="lineNum">     171 </span>            : class EdgeRange;
<span class="lineNum">     172 </span>            : class StackFrame;
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : } // namespace ubi
<span class="lineNum">     175 </span>            : } // namespace JS
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : namespace JS {
<span class="lineNum">     178 </span>            : namespace ubi {
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : using mozilla::Forward;
<span class="lineNum">     181 </span>            : using mozilla::Maybe;
<span class="lineNum">     182 </span>            : using mozilla::Move;
<span class="lineNum">     183 </span>            : using mozilla::RangedPtr;
<span class="lineNum">     184 </span>            : using mozilla::Variant;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : template &lt;typename T&gt;
<span class="lineNum">     187 </span>            : using Vector = mozilla::Vector&lt;T, 0, js::SystemAllocPolicy&gt;;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /*** ubi::StackFrame ******************************************************************************/
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : // Concrete JS::ubi::StackFrame instances backed by a live SavedFrame object
<span class="lineNum">     192 </span>            : // store their strings as JSAtom*, while deserialized stack frames from offline
<span class="lineNum">     193 </span>            : // heap snapshots store their strings as const char16_t*. In order to provide
<a name="194"><span class="lineNum">     194 </span>            : // zero-cost accessors to these strings in a single interface that works with</a>
<span class="lineNum">     195 </span>            : // both cases, we use this variant type.
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : class JS_PUBLIC_API(AtomOrTwoByteChars) : public Variant&lt;JSAtom*, const char16_t*&gt; {</span>
<span class="lineNum">     197 </span>            :     using Base = Variant&lt;JSAtom*, const char16_t*&gt;;
<span class="lineNum">     198 </span>            : 
<a name="199"><span class="lineNum">     199 </span>            :   public:</a>
<span class="lineNum">     200 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     MOZ_IMPLICIT AtomOrTwoByteChars(T&amp;&amp; rhs) : Base(Forward&lt;T&gt;(rhs)) { }</span>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     204 </span>            :     AtomOrTwoByteChars&amp; operator=(T&amp;&amp; rhs) {
<span class="lineNum">     205 </span>            :         MOZ_ASSERT(this != &amp;rhs, &quot;self-move disallowed&quot;);
<span class="lineNum">     206 </span>            :         this-&gt;~AtomOrTwoByteChars();
<span class="lineNum">     207 </span>            :         new (this) AtomOrTwoByteChars(Forward&lt;T&gt;(rhs));
<span class="lineNum">     208 </span>            :         return *this;
<span class="lineNum">     209 </span>            :     }
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :     // Return the length of the given AtomOrTwoByteChars string.
<span class="lineNum">     212 </span>            :     size_t length();
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :     // Copy the given AtomOrTwoByteChars string into the destination buffer,
<span class="lineNum">     215 </span>            :     // inflating if necessary. Does NOT null terminate. Returns the number of
<span class="lineNum">     216 </span>            :     // characters written to destination.
<span class="lineNum">     217 </span>            :     size_t copyToBuffer(RangedPtr&lt;char16_t&gt; destination, size_t length);
<span class="lineNum">     218 </span>            : };
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : // The base class implemented by each ConcreteStackFrame&lt;T&gt; type. Subclasses
<span class="lineNum">     221 </span>            : // must not add data members to this class.
<span class="lineNum">     222 </span>            : class BaseStackFrame {
<span class="lineNum">     223 </span>            :     friend class StackFrame;
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     BaseStackFrame(const StackFrame&amp;) = delete;
<span class="lineNum">     226 </span>            :     BaseStackFrame&amp; operator=(const StackFrame&amp;) = delete;
<span class="lineNum">     227 </span>            : 
<a name="228"><span class="lineNum">     228 </span>            :   protected:</a>
<span class="lineNum">     229 </span>            :     void* ptr;
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     explicit BaseStackFrame(void* ptr) : ptr(ptr) { }</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   public:
<span class="lineNum">     233 </span>            :     // This is a value type that should not have a virtual destructor. Don't add
<span class="lineNum">     234 </span>            :     // destructors in subclasses!
<span class="lineNum">     235 </span>            : 
<a name="236"><span class="lineNum">     236 </span>            :     // Get a unique identifier for this StackFrame. The identifier is not valid</a>
<span class="lineNum">     237 </span>            :     // across garbage collections.
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     virtual uint64_t identifier() const { return uint64_t(uintptr_t(ptr)); }</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     // Get this frame's parent frame.
<span class="lineNum">     241 </span>            :     virtual StackFrame parent() const = 0;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     // Get this frame's line number.
<span class="lineNum">     244 </span>            :     virtual uint32_t line() const = 0;
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :     // Get this frame's column number.
<span class="lineNum">     247 </span>            :     virtual uint32_t column() const = 0;
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :     // Get this frame's source name. Never null.
<span class="lineNum">     250 </span>            :     virtual AtomOrTwoByteChars source() const = 0;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :     // Return this frame's function name if named, otherwise the inferred
<span class="lineNum">     253 </span>            :     // display name. Can be null.
<span class="lineNum">     254 </span>            :     virtual AtomOrTwoByteChars functionDisplayName() const = 0;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :     // Returns true if this frame's function is system JavaScript running with
<span class="lineNum">     257 </span>            :     // trusted principals, false otherwise.
<span class="lineNum">     258 </span>            :     virtual bool isSystem() const = 0;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     // Return true if this frame's function is a self-hosted JavaScript builtin,
<span class="lineNum">     261 </span>            :     // false otherwise.
<span class="lineNum">     262 </span>            :     virtual bool isSelfHosted(JSContext* cx) const = 0;
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :     // Construct a SavedFrame stack for the stack starting with this frame and
<span class="lineNum">     265 </span>            :     // containing all of its parents. The SavedFrame objects will be placed into
<span class="lineNum">     266 </span>            :     // cx's current compartment.
<span class="lineNum">     267 </span>            :     //
<span class="lineNum">     268 </span>            :     // Note that the process of
<span class="lineNum">     269 </span>            :     //
<span class="lineNum">     270 </span>            :     //     SavedFrame
<span class="lineNum">     271 </span>            :     //         |
<span class="lineNum">     272 </span>            :     //         V
<span class="lineNum">     273 </span>            :     //     JS::ubi::StackFrame
<span class="lineNum">     274 </span>            :     //         |
<span class="lineNum">     275 </span>            :     //         V
<span class="lineNum">     276 </span>            :     //     offline heap snapshot
<span class="lineNum">     277 </span>            :     //         |
<span class="lineNum">     278 </span>            :     //         V
<span class="lineNum">     279 </span>            :     //     JS::ubi::StackFrame
<span class="lineNum">     280 </span>            :     //         |
<span class="lineNum">     281 </span>            :     //         V
<span class="lineNum">     282 </span>            :     //     SavedFrame
<span class="lineNum">     283 </span>            :     //
<span class="lineNum">     284 </span>            :     // is lossy because we cannot serialize and deserialize the SavedFrame's
<span class="lineNum">     285 </span>            :     // principals in the offline heap snapshot, so JS::ubi::StackFrame
<span class="lineNum">     286 </span>            :     // simplifies the principals check into the boolean isSystem() state. This
<span class="lineNum">     287 </span>            :     // is fine because we only expose JS::ubi::Stack to devtools and chrome
<span class="lineNum">     288 </span>            :     // code, and not to the web platform.
<span class="lineNum">     289 </span>            :     virtual MOZ_MUST_USE bool constructSavedFrameStack(JSContext* cx,
<span class="lineNum">     290 </span>            :                                                        MutableHandleObject outSavedFrameStack)
<span class="lineNum">     291 </span>            :         const = 0;
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :     // Trace the concrete implementation of JS::ubi::StackFrame.
<span class="lineNum">     294 </span>            :     virtual void trace(JSTracer* trc) = 0;
<span class="lineNum">     295 </span>            : };
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : // A traits template with a specialization for each backing type that implements
<span class="lineNum">     298 </span>            : // the ubi::BaseStackFrame interface. Each specialization must be the a subclass
<span class="lineNum">     299 </span>            : // of ubi::BaseStackFrame.
<span class="lineNum">     300 </span>            : template&lt;typename T&gt; class ConcreteStackFrame;
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : // A JS::ubi::StackFrame represents a frame in a recorded stack. It can be
<span class="lineNum">     303 </span>            : // backed either by a live SavedFrame object or by a structure deserialized from
<span class="lineNum">     304 </span>            : // an offline heap snapshot.
<span class="lineNum">     305 </span>            : //
<span class="lineNum">     306 </span>            : // It is a value type that may be memcpy'd hither and thither without worrying
<span class="lineNum">     307 </span>            : // about constructors or destructors, similar to POD types.
<span class="lineNum">     308 </span>            : //
<span class="lineNum">     309 </span>            : // Its lifetime is the same as the lifetime of the graph that is being analyzed
<span class="lineNum">     310 </span>            : // by the JS::ubi::Node that the JS::ubi::StackFrame came from. That is, if the
<span class="lineNum">     311 </span>            : // graph being analyzed is the live heap graph, the JS::ubi::StackFrame is only
<span class="lineNum">     312 </span>            : // valid within the scope of an AutoCheckCannotGC; if the graph being analyzed
<span class="lineNum">     313 </span>            : // is an offline heap snapshot, the JS::ubi::StackFrame is valid as long as the
<span class="lineNum">     314 </span>            : // offline heap snapshot is alive.
<span class="lineNum">     315 </span>            : class StackFrame {
<span class="lineNum">     316 </span>            :     // Storage in which we allocate BaseStackFrame subclasses.
<a name="317"><span class="lineNum">     317 </span>            :     mozilla::AlignedStorage2&lt;BaseStackFrame&gt; storage;</a>
<a name="318"><span class="lineNum">     318 </span>            : </a>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     BaseStackFrame* base() { return storage.addr(); }</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     const BaseStackFrame* base() const { return storage.addr(); }</span>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<span class="lineNum">     322 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     void construct(T* ptr) {</span>
<span class="lineNum">     324 </span>            :         static_assert(mozilla::IsBaseOf&lt;BaseStackFrame, ConcreteStackFrame&lt;T&gt;&gt;::value,
<span class="lineNum">     325 </span>            :                       &quot;ConcreteStackFrame&lt;T&gt; must inherit from BaseStackFrame&quot;);
<span class="lineNum">     326 </span>            :         static_assert(sizeof(ConcreteStackFrame&lt;T&gt;) == sizeof(*base()),
<span class="lineNum">     327 </span>            :                       &quot;ubi::ConcreteStackFrame&lt;T&gt; specializations must be the same size as &quot;
<span class="lineNum">     328 </span>            :                       &quot;ubi::BaseStackFrame&quot;);
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         ConcreteStackFrame&lt;T&gt;::construct(base(), ptr);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     331 </span>            :     struct ConstructFunctor;
<a name="332"><span class="lineNum">     332 </span>            : </a>
<span class="lineNum">     333 </span>            :   public:
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     StackFrame() { construct&lt;void&gt;(nullptr); }</span>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<span class="lineNum">     336 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     MOZ_IMPLICIT StackFrame(T* ptr) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         construct(ptr);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     342 </span>            :     StackFrame&amp; operator=(T* ptr) {
<span class="lineNum">     343 </span>            :         construct(ptr);
<span class="lineNum">     344 </span>            :         return *this;
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     // Constructors accepting SpiderMonkey's generic-pointer-ish types.
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     350 </span>            :     explicit StackFrame(const JS::Handle&lt;T*&gt;&amp; handle) {
<span class="lineNum">     351 </span>            :         construct(handle.get());
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     355 </span>            :     StackFrame&amp; operator=(const JS::Handle&lt;T*&gt;&amp; handle) {
<span class="lineNum">     356 </span>            :         construct(handle.get());
<span class="lineNum">     357 </span>            :         return *this;
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     361 </span>            :     explicit StackFrame(const JS::Rooted&lt;T*&gt;&amp; root) {
<span class="lineNum">     362 </span>            :         construct(root.get());
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     366 </span>            :     StackFrame&amp; operator=(const JS::Rooted&lt;T*&gt;&amp; root) {
<span class="lineNum">     367 </span>            :         construct(root.get());
<span class="lineNum">     368 </span>            :         return *this;
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :     // Because StackFrame is just a vtable pointer and an instance pointer, we
<span class="lineNum">     372 </span>            :     // can memcpy everything around instead of making concrete classes define
<a name="373"><span class="lineNum">     373 </span>            :     // virtual constructors. See the comment above Node's copy constructor for</a>
<span class="lineNum">     374 </span>            :     // more details; that comment applies here as well.
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     StackFrame(const StackFrame&amp; rhs) {</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         memcpy(storage.u.mBytes, rhs.storage.u.mBytes, sizeof(storage.u));</span>
<a name="377"><span class="lineNum">     377 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     StackFrame&amp; operator=(const StackFrame&amp; rhs) {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         memcpy(storage.u.mBytes, rhs.storage.u.mBytes, sizeof(storage.u));</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         return *this;</span>
<a name="382"><span class="lineNum">     382 </span>            :     }</a>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :     bool operator==(const StackFrame&amp; rhs) const { return base()-&gt;ptr == rhs.base()-&gt;ptr; }</span>
<a name="385"><span class="lineNum">     385 </span>            :     bool operator!=(const StackFrame&amp; rhs) const { return !(*this == rhs); }</a>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :     explicit operator bool() const {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         return base()-&gt;ptr != nullptr;</span>
<span class="lineNum">     389 </span>            :     }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :     // Copy this StackFrame's source name into the given |destination|
<span class="lineNum">     392 </span>            :     // buffer. Copy no more than |length| characters. The result is *not* null
<span class="lineNum">     393 </span>            :     // terminated. Returns how many characters were written into the buffer.
<span class="lineNum">     394 </span>            :     size_t source(RangedPtr&lt;char16_t&gt; destination, size_t length) const;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :     // Copy this StackFrame's function display name into the given |destination|
<span class="lineNum">     397 </span>            :     // buffer. Copy no more than |length| characters. The result is *not* null
<span class="lineNum">     398 </span>            :     // terminated. Returns how many characters were written into the buffer.
<span class="lineNum">     399 </span>            :     size_t functionDisplayName(RangedPtr&lt;char16_t&gt; destination, size_t length) const;
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :     // Get the size of the respective strings. 0 is returned for null strings.
<span class="lineNum">     402 </span>            :     size_t sourceLength();
<span class="lineNum">     403 </span>            :     size_t functionDisplayNameLength();
<span class="lineNum">     404 </span>            : 
<a name="405"><span class="lineNum">     405 </span>            :     // Methods that forward to virtual calls through BaseStackFrame.</a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     void trace(JSTracer* trc) { base()-&gt;trace(trc); }</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :     uint64_t identifier() const {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         auto id = base()-&gt;identifier();</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(JS::Value::isNumberRepresentable(id));</span>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :         return id;</span></a>
<a name="412"><span class="lineNum">     412 </span>            :     }</a>
<a name="413"><span class="lineNum">     413 </span><span class="lineNoCov">          0 :     uint32_t line() const { return base()-&gt;line(); }</span></a>
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 :     uint32_t column() const { return base()-&gt;column(); }</span></a>
<a name="415"><span class="lineNum">     415 </span><span class="lineNoCov">          0 :     AtomOrTwoByteChars source() const { return base()-&gt;source(); }</span></a>
<a name="416"><span class="lineNum">     416 </span><span class="lineNoCov">          0 :     AtomOrTwoByteChars functionDisplayName() const { return base()-&gt;functionDisplayName(); }</span></a>
<a name="417"><span class="lineNum">     417 </span><span class="lineNoCov">          0 :     StackFrame parent() const { return base()-&gt;parent(); }</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :     bool isSystem() const { return base()-&gt;isSystem(); }</span></a>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     bool isSelfHosted(JSContext* cx) const { return base()-&gt;isSelfHosted(cx); }</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     MOZ_MUST_USE bool constructSavedFrameStack(JSContext* cx,</span>
<span class="lineNum">     421 </span>            :                                                MutableHandleObject outSavedFrameStack) const {
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         return base()-&gt;constructSavedFrameStack(cx, outSavedFrameStack);</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     struct HashPolicy {
<a name="426"><span class="lineNum">     426 </span>            :         using Lookup = JS::ubi::StackFrame;</a>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         static js::HashNumber hash(const Lookup&amp; lookup) {</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             return lookup.identifier();</span>
<a name="430"><span class="lineNum">     430 </span>            :         }</a>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         static bool match(const StackFrame&amp; key, const Lookup&amp; lookup) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             return key == lookup;</span>
<span class="lineNum">     434 </span>            :         }
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :         static void rekey(StackFrame&amp; k, const StackFrame&amp; newKey) {
<span class="lineNum">     437 </span>            :             k = newKey;
<span class="lineNum">     438 </span>            :         }
<span class="lineNum">     439 </span>            :     };
<span class="lineNum">     440 </span>            : };
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            : // The ubi::StackFrame null pointer. Any attempt to operate on a null
<span class="lineNum">     443 </span>            : // ubi::StackFrame crashes.
<a name="444"><span class="lineNum">     444 </span>            : template&lt;&gt;</a>
<span class="lineNum">     445 </span>            : class ConcreteStackFrame&lt;void&gt; : public BaseStackFrame {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     explicit ConcreteStackFrame(void* ptr) : BaseStackFrame(ptr) { }</span>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<span class="lineNum">     448 </span>            :   public:
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :     static void construct(void* storage, void*) { new (storage) ConcreteStackFrame(nullptr); }</span></a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 :     uint64_t identifier() const override { return 0; }</span></a>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :     void trace(JSTracer* trc) override { }</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     MOZ_MUST_USE bool constructSavedFrameStack(JSContext* cx, MutableHandleObject out)</span>
<span class="lineNum">     454 </span>            :         const override
<span class="lineNum">     455 </span>            :     {
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         out.set(nullptr);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :         return true;</span>
<a name="458"><span class="lineNum">     458 </span>            :     }</a>
<a name="459"><span class="lineNum">     459 </span>            : </a>
<a name="460"><span class="lineNum">     460 </span><span class="lineNoCov">          0 :     uint32_t line() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span></a>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 :     uint32_t column() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span></a>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 :     AtomOrTwoByteChars source() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span></a>
<a name="463"><span class="lineNum">     463 </span><span class="lineNoCov">          0 :     AtomOrTwoByteChars functionDisplayName() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :     StackFrame parent() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span></a>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     bool isSystem() const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     bool isSelfHosted(JSContext* cx) const override { MOZ_CRASH(&quot;null JS::ubi::StackFrame&quot;); }</span>
<span class="lineNum">     467 </span>            : };
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : MOZ_MUST_USE JS_PUBLIC_API(bool)
<span class="lineNum">     470 </span>            : ConstructSavedFrameStackSlow(JSContext* cx,
<span class="lineNum">     471 </span>            :                              JS::ubi::StackFrame&amp; frame,
<span class="lineNum">     472 </span>            :                              MutableHandleObject outSavedFrameStack);
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : /*** ubi::Node ************************************************************************************/
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            : // A concrete node specialization can claim its referent is a member of a
<span class="lineNum">     478 </span>            : // particular &quot;coarse type&quot; which is less specific than the actual
<span class="lineNum">     479 </span>            : // implementation type but generally more palatable for web developers. For
<span class="lineNum">     480 </span>            : // example, JitCode can be considered to have a coarse type of &quot;Script&quot;. This is
<span class="lineNum">     481 </span>            : // used by some analyses for putting nodes into different buckets. The default,
<span class="lineNum">     482 </span>            : // if a concrete specialization does not provide its own mapping to a CoarseType
<span class="lineNum">     483 </span>            : // variant, is &quot;Other&quot;.
<span class="lineNum">     484 </span>            : //
<span class="lineNum">     485 </span>            : // NB: the values associated with a particular enum variant must not change or
<span class="lineNum">     486 </span>            : // be reused for new variants. Doing so will cause inspecting ubi::Nodes backed
<span class="lineNum">     487 </span>            : // by an offline heap snapshot from an older SpiderMonkey/Firefox version to
<span class="lineNum">     488 </span>            : // break. Consider this enum append only.
<span class="lineNum">     489 </span>            : enum class CoarseType: uint32_t {
<span class="lineNum">     490 </span>            :     Other  = 0,
<span class="lineNum">     491 </span>            :     Object = 1,
<span class="lineNum">     492 </span>            :     Script = 2,
<span class="lineNum">     493 </span>            :     String = 3,
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :     FIRST  = Other,
<span class="lineNum">     496 </span>            :     LAST   = String
<span class="lineNum">     497 </span>            : };
<a name="498"><span class="lineNum">     498 </span>            : </a>
<span class="lineNum">     499 </span>            : inline uint32_t
<span class="lineNum">     500 </span><span class="lineNoCov">          0 : CoarseTypeToUint32(CoarseType type)</span>
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     return static_cast&lt;uint32_t&gt;(type);</span>
<span class="lineNum">     503 </span>            : }
<a name="504"><span class="lineNum">     504 </span>            : </a>
<span class="lineNum">     505 </span>            : inline bool
<span class="lineNum">     506 </span><span class="lineNoCov">          0 : Uint32IsValidCoarseType(uint32_t n)</span>
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     auto first = static_cast&lt;uint32_t&gt;(CoarseType::FIRST);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     auto last = static_cast&lt;uint32_t&gt;(CoarseType::LAST);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(first &lt; last);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     return first &lt;= n &amp;&amp; n &lt;= last;</span>
<span class="lineNum">     512 </span>            : }
<a name="513"><span class="lineNum">     513 </span>            : </a>
<span class="lineNum">     514 </span>            : inline CoarseType
<span class="lineNum">     515 </span><span class="lineNoCov">          0 : Uint32ToCoarseType(uint32_t n)</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(Uint32IsValidCoarseType(n));</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     return static_cast&lt;CoarseType&gt;(n);</span>
<span class="lineNum">     519 </span>            : }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : // The base class implemented by each ubi::Node referent type. Subclasses must
<span class="lineNum">     522 </span>            : // not add data members to this class.
<span class="lineNum">     523 </span>            : class JS_PUBLIC_API(Base) {
<span class="lineNum">     524 </span>            :     friend class Node;
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :     // For performance's sake, we'd prefer to avoid a virtual destructor; and
<span class="lineNum">     527 </span>            :     // an empty constructor seems consistent with the 'lightweight value type'
<span class="lineNum">     528 </span>            :     // visible behavior we're trying to achieve. But if the destructor isn't
<span class="lineNum">     529 </span>            :     // virtual, and a subclass overrides it, the subclass's destructor will be
<span class="lineNum">     530 </span>            :     // ignored. Is there a way to make the compiler catch that error?
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :   protected:
<span class="lineNum">     533 </span>            :     // Space for the actual pointer. Concrete subclasses should define a
<span class="lineNum">     534 </span>            :     // properly typed 'get' member function to access this.
<a name="535"><span class="lineNum">     535 </span>            :     void* ptr;</a>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     explicit Base(void* ptr) : ptr(ptr) { }</span>
<a name="538"><span class="lineNum">     538 </span>            : </a>
<span class="lineNum">     539 </span>            :   public:
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     bool operator==(const Base&amp; rhs) const {</span>
<span class="lineNum">     541 </span>            :         // Some compilers will indeed place objects of different types at
<span class="lineNum">     542 </span>            :         // the same address, so technically, we should include the vtable
<span class="lineNum">     543 </span>            :         // in this comparison. But it seems unlikely to cause problems in
<span class="lineNum">     544 </span>            :         // practice.
<a name="545"><span class="lineNum">     545 </span><span class="lineNoCov">          0 :         return ptr == rhs.ptr;</span></a>
<span class="lineNum">     546 </span>            :     }
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     bool operator!=(const Base&amp; rhs) const { return !(*this == rhs); }</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :     // An identifier for this node, guaranteed to be stable and unique for as
<span class="lineNum">     550 </span>            :     // long as this ubi::Node's referent is alive and at the same address.
<span class="lineNum">     551 </span>            :     //
<span class="lineNum">     552 </span>            :     // This is probably suitable for use in serializations, as it is an integral
<span class="lineNum">     553 </span>            :     // type. It may also help save memory when constructing HashSets of
<span class="lineNum">     554 </span>            :     // ubi::Nodes: since a uint64_t will always be smaller-or-equal-to the size
<span class="lineNum">     555 </span>            :     // of a ubi::Node, a HashSet&lt;ubi::Node::Id&gt; may use less space per element
<span class="lineNum">     556 </span>            :     // than a HashSet&lt;ubi::Node&gt;.
<span class="lineNum">     557 </span>            :     //
<span class="lineNum">     558 </span>            :     // (Note that 'unique' only means 'up to equality on ubi::Node'; see the
<span class="lineNum">     559 </span>            :     // caveats about multiple objects allocated at the same address for
<a name="560"><span class="lineNum">     560 </span>            :     // 'ubi::Node::operator=='.)</a>
<span class="lineNum">     561 </span>            :     using Id = uint64_t;
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     virtual Id identifier() const { return Id(uintptr_t(ptr)); }</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     // Returns true if this node is pointing to something on the live heap, as
<a name="565"><span class="lineNum">     565 </span>            :     // opposed to something from a deserialized core dump. Returns false,</a>
<span class="lineNum">     566 </span>            :     // otherwise.
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     virtual bool isLive() const { return true; };</span>
<a name="568"><span class="lineNum">     568 </span>            : </a>
<span class="lineNum">     569 </span>            :     // Return the coarse-grained type-of-thing that this node represents.
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     virtual CoarseType coarseType() const { return CoarseType::Other; }</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :     // Return a human-readable name for the referent's type. The result should
<span class="lineNum">     573 </span>            :     // be statically allocated. (You can use u&quot;strings&quot; for this.)
<span class="lineNum">     574 </span>            :     //
<span class="lineNum">     575 </span>            :     // This must always return Concrete&lt;T&gt;::concreteTypeName; we use that
<span class="lineNum">     576 </span>            :     // pointer as a tag for this particular referent type.
<span class="lineNum">     577 </span>            :     virtual const char16_t* typeName() const = 0;
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :     // Return the size of this node, in bytes. Include any structures that this
<span class="lineNum">     580 </span>            :     // node owns exclusively that are not exposed as their own ubi::Nodes.
<span class="lineNum">     581 </span>            :     // |mallocSizeOf| should be a malloc block sizing function; see
<span class="lineNum">     582 </span>            :     // |mfbt/MemoryReporting.h|.
<span class="lineNum">     583 </span>            :     //
<span class="lineNum">     584 </span>            :     // Because we can use |JS::ubi::Node|s backed by a snapshot that was taken
<span class="lineNum">     585 </span>            :     // on a 64-bit platform when we are currently on a 32-bit platform, we
<span class="lineNum">     586 </span>            :     // cannot rely on |size_t| for node sizes. Instead, |Size| is uint64_t on
<a name="587"><span class="lineNum">     587 </span>            :     // all platforms.</a>
<span class="lineNum">     588 </span>            :     using Size = uint64_t;
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :     virtual Size size(mozilla::MallocSizeOf mallocSizeof) const { return 1; }</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :     // Return an EdgeRange that initially contains all the referent's outgoing
<span class="lineNum">     592 </span>            :     // edges. The caller takes ownership of the EdgeRange.
<span class="lineNum">     593 </span>            :     //
<span class="lineNum">     594 </span>            :     // If wantNames is true, compute names for edges. Doing so can be expensive
<span class="lineNum">     595 </span>            :     // in time and memory.
<span class="lineNum">     596 </span>            :     virtual js::UniquePtr&lt;EdgeRange&gt; edges(JSContext* cx, bool wantNames) const = 0;
<span class="lineNum">     597 </span>            : 
<a name="598"><span class="lineNum">     598 </span>            :     // Return the Zone to which this node's referent belongs, or nullptr if the</a>
<span class="lineNum">     599 </span>            :     // referent is not of a type allocated in SpiderMonkey Zones.
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     virtual JS::Zone* zone() const { return nullptr; }</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :     // Return the compartment for this node. Some ubi::Node referents are not
<span class="lineNum">     603 </span>            :     // associated with JSCompartments, such as JSStrings (which are associated
<a name="604"><span class="lineNum">     604 </span>            :     // with Zones). When the referent is not associated with a compartment,</a>
<span class="lineNum">     605 </span>            :     // nullptr is returned.
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     virtual JSCompartment* compartment() const { return nullptr; }</span>
<a name="607"><span class="lineNum">     607 </span>            : </a>
<span class="lineNum">     608 </span>            :     // Return whether this node's referent's allocation stack was captured.
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     virtual bool hasAllocationStack() const { return false; }</span>
<span class="lineNum">     610 </span>            : 
<a name="611"><span class="lineNum">     611 </span>            :     // Get the stack recorded at the time this node's referent was</a>
<span class="lineNum">     612 </span>            :     // allocated. This must only be called when hasAllocationStack() is true.
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     virtual StackFrame allocationStack() const {</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;Concrete classes that have an allocation stack must override both &quot;</span>
<span class="lineNum">     615 </span>            :                   &quot;hasAllocationStack and allocationStack.&quot;);
<span class="lineNum">     616 </span>            :     }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :     // Methods for JSObject Referents
<span class="lineNum">     619 </span>            :     //
<span class="lineNum">     620 </span>            :     // These methods are only semantically valid if the referent is either a
<span class="lineNum">     621 </span>            :     // JSObject in the live heap, or represents a previously existing JSObject
<span class="lineNum">     622 </span>            :     // from some deserialized heap snapshot.
<a name="623"><span class="lineNum">     623 </span>            : </a>
<span class="lineNum">     624 </span>            :     // Return the object's [[Class]]'s name.
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     virtual const char* jsObjectClassName() const { return nullptr; }</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            :     // If this object was constructed with `new` and we have the data available,
<span class="lineNum">     628 </span>            :     // place the contructor function's display name in the out parameter.
<span class="lineNum">     629 </span>            :     // Otherwise, place nullptr in the out parameter. Caller maintains ownership
<a name="630"><span class="lineNum">     630 </span>            :     // of the out parameter. True is returned on success, false is returned on</a>
<span class="lineNum">     631 </span>            :     // OOM.
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     virtual MOZ_MUST_USE bool jsObjectConstructorName(JSContext* cx, UniqueTwoByteChars&amp; outName)</span>
<span class="lineNum">     633 </span>            :         const
<span class="lineNum">     634 </span>            :     {
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         outName.reset(nullptr);</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     637 </span>            :     }
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            :     // Methods for CoarseType::Script referents
<span class="lineNum">     640 </span>            : 
<a name="641"><span class="lineNum">     641 </span>            :     // Return the script's source's filename if available. If unavailable,</a>
<span class="lineNum">     642 </span>            :     // return nullptr.
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     virtual const char* scriptFilename() const { return nullptr; }</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            :   private:
<span class="lineNum">     646 </span>            :     Base(const Base&amp; rhs) = delete;
<span class="lineNum">     647 </span>            :     Base&amp; operator=(const Base&amp; rhs) = delete;
<span class="lineNum">     648 </span>            : };
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : // A traits template with a specialization for each referent type that
<span class="lineNum">     651 </span>            : // ubi::Node supports. The specialization must be the concrete subclass of Base
<span class="lineNum">     652 </span>            : // that represents a pointer to the referent type. It must include these
<span class="lineNum">     653 </span>            : // members:
<span class="lineNum">     654 </span>            : //
<span class="lineNum">     655 </span>            : //    // The specific char16_t array returned by Concrete&lt;T&gt;::typeName().
<span class="lineNum">     656 </span>            : //    static const char16_t concreteTypeName[];
<span class="lineNum">     657 </span>            : //
<span class="lineNum">     658 </span>            : //    // Construct an instance of this concrete class in |storage| referring
<span class="lineNum">     659 </span>            : //    // to |referent|. Implementations typically use a placement 'new'.
<span class="lineNum">     660 </span>            : //    //
<span class="lineNum">     661 </span>            : //    // In some cases, |referent| will contain dynamic type information that
<span class="lineNum">     662 </span>            : //    // identifies it a some more specific subclass of |Referent|. For
<span class="lineNum">     663 </span>            : //    // example, when |Referent| is |JSObject|, then |referent-&gt;getClass()|
<span class="lineNum">     664 </span>            : //    // could tell us that it's actually a JSFunction. Similarly, if
<span class="lineNum">     665 </span>            : //    // |Referent| is |nsISupports|, we would like a ubi::Node that knows its
<span class="lineNum">     666 </span>            : //    // final implementation type.
<span class="lineNum">     667 </span>            : //    //
<span class="lineNum">     668 </span>            : //    // So we delegate the actual construction to this specialization, which
<span class="lineNum">     669 </span>            : //    // knows Referent's details.
<span class="lineNum">     670 </span>            : //    static void construct(void* storage, Referent* referent);
<span class="lineNum">     671 </span>            : template&lt;typename Referent&gt;
<span class="lineNum">     672 </span>            : class Concrete;
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : // A container for a Base instance; all members simply forward to the contained
<span class="lineNum">     675 </span>            : // instance.  This container allows us to pass ubi::Node instances by value.
<span class="lineNum">     676 </span>            : class Node {
<a name="677"><span class="lineNum">     677 </span>            :     // Storage in which we allocate Base subclasses.</a>
<a name="678"><span class="lineNum">     678 </span>            :     mozilla::AlignedStorage2&lt;Base&gt; storage;</a>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     Base* base() { return storage.addr(); }</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     const Base* base() const { return storage.addr(); }</span>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<span class="lineNum">     682 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     void construct(T* ptr) {</span>
<span class="lineNum">     684 </span>            :         static_assert(sizeof(Concrete&lt;T&gt;) == sizeof(*base()),
<span class="lineNum">     685 </span>            :                       &quot;ubi::Base specializations must be the same size as ubi::Base&quot;);
<span class="lineNum">     686 </span>            :         static_assert(mozilla::IsBaseOf&lt;Base, Concrete&lt;T&gt;&gt;::value,
<span class="lineNum">     687 </span>            :                       &quot;ubi::Concrete&lt;T&gt; must inherit from ubi::Base&quot;);
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         Concrete&lt;T&gt;::construct(base(), ptr);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     690 </span>            :     struct ConstructFunctor;
<a name="691"><span class="lineNum">     691 </span>            : </a>
<span class="lineNum">     692 </span>            :   public:
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     Node() { construct&lt;void&gt;(nullptr); }</span>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<span class="lineNum">     695 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     MOZ_IMPLICIT Node(T* ptr) {</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         construct(ptr);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     699 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     700 </span>            :     Node&amp; operator=(T* ptr) {
<span class="lineNum">     701 </span>            :         construct(ptr);
<span class="lineNum">     702 </span>            :         return *this;
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span>            : 
<a name="705"><span class="lineNum">     705 </span>            :     // We can construct and assign from rooted forms of pointers.</a>
<span class="lineNum">     706 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     MOZ_IMPLICIT Node(const Rooted&lt;T*&gt;&amp; root) {</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         construct(root.get());</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     710 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     711 </span>            :     Node&amp; operator=(const Rooted&lt;T*&gt;&amp; root) {
<span class="lineNum">     712 </span>            :         construct(root.get());
<span class="lineNum">     713 </span>            :         return *this;
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :     // Constructors accepting SpiderMonkey's other generic-pointer-ish types.
<span class="lineNum">     717 </span>            :     // Note that we *do* want an implicit constructor here: JS::Value and
<span class="lineNum">     718 </span>            :     // JS::ubi::Node are both essentially tagged references to other sorts of
<span class="lineNum">     719 </span>            :     // objects, so letting conversions happen automatically is appropriate.
<span class="lineNum">     720 </span>            :     MOZ_IMPLICIT Node(JS::HandleValue value);
<span class="lineNum">     721 </span>            :     explicit Node(const JS::GCCellPtr&amp; thing);
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :     // copy construction and copy assignment just use memcpy, since we know
<span class="lineNum">     724 </span>            :     // instances contain nothing but a vtable pointer and a data pointer.
<span class="lineNum">     725 </span>            :     //
<span class="lineNum">     726 </span>            :     // To be completely correct, concrete classes could provide a virtual
<span class="lineNum">     727 </span>            :     // 'construct' member function, which we could invoke on rhs to construct an
<span class="lineNum">     728 </span>            :     // instance in our storage. But this is good enough; there's no need to jump
<a name="729"><span class="lineNum">     729 </span>            :     // through vtables for copying and assignment that are just going to move</a>
<span class="lineNum">     730 </span>            :     // two words around. The compiler knows how to optimize memcpy.
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     Node(const Node&amp; rhs) {</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :         memcpy(storage.u.mBytes, rhs.storage.u.mBytes, sizeof(storage.u));</span>
<a name="733"><span class="lineNum">     733 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     Node&amp; operator=(const Node&amp; rhs) {</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         memcpy(storage.u.mBytes, rhs.storage.u.mBytes, sizeof(storage.u));</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         return *this;</span>
<a name="738"><span class="lineNum">     738 </span>            :     }</a>
<a name="739"><span class="lineNum">     739 </span>            : </a>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     bool operator==(const Node&amp; rhs) const { return *base() == *rhs.base(); }</span>
<a name="741"><span class="lineNum">     741 </span><span class="lineNoCov">          0 :     bool operator!=(const Node&amp; rhs) const { return *base() != *rhs.base(); }</span></a>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     explicit operator bool() const {</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :         return base()-&gt;ptr != nullptr;</span>
<a name="745"><span class="lineNum">     745 </span>            :     }</a>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     bool isLive() const { return base()-&gt;isLive(); }</span>
<span class="lineNum">     748 </span>            : 
<a name="749"><span class="lineNum">     749 </span>            :     // Get the canonical type name for the given type T.</a>
<span class="lineNum">     750 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     static const char16_t* canonicalTypeName() { return Concrete&lt;T&gt;::concreteTypeName; }</span>
<a name="752"><span class="lineNum">     752 </span>            : </a>
<span class="lineNum">     753 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     bool is() const {</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         return base()-&gt;typeName() == canonicalTypeName&lt;T&gt;();</span>
<span class="lineNum">     756 </span>            :     }
<a name="757"><span class="lineNum">     757 </span>            : </a>
<span class="lineNum">     758 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     T* as() const {</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(isLive());</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(is&lt;T&gt;());</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         return static_cast&lt;T*&gt;(base()-&gt;ptr);</span>
<span class="lineNum">     763 </span>            :     }
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     template&lt;typename T&gt;
<span class="lineNum">     766 </span>            :     T* asOrNull() const {
<span class="lineNum">     767 </span>            :         MOZ_ASSERT(isLive());
<span class="lineNum">     768 </span>            :         return is&lt;T&gt;() ? static_cast&lt;T*&gt;(base()-&gt;ptr) : nullptr;
<span class="lineNum">     769 </span>            :     }
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            :     // If this node refers to something that can be represented as a JavaScript
<span class="lineNum">     772 </span>            :     // value that is safe to expose to JavaScript code, return that value.
<span class="lineNum">     773 </span>            :     // Otherwise return UndefinedValue(). JSStrings, JS::Symbols, and some (but
<span class="lineNum">     774 </span>            :     // not all!) JSObjects can be exposed.
<a name="775"><span class="lineNum">     775 </span>            :     JS::Value exposeToJS() const;</a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :     CoarseType coarseType()         const { return base()-&gt;coarseType(); }</span></a>
<a name="778"><span class="lineNum">     778 </span><span class="lineNoCov">          0 :     const char16_t* typeName()      const { return base()-&gt;typeName(); }</span></a>
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :     JS::Zone* zone()                const { return base()-&gt;zone(); }</span></a>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     JSCompartment* compartment()    const { return base()-&gt;compartment(); }</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     const char* jsObjectClassName() const { return base()-&gt;jsObjectClassName(); }</span>
<span class="lineNum">     782 </span>            :     MOZ_MUST_USE bool jsObjectConstructorName(JSContext* cx, UniqueTwoByteChars&amp; outName) const {
<span class="lineNum">     783 </span>            :         return base()-&gt;jsObjectConstructorName(cx, outName);
<a name="784"><span class="lineNum">     784 </span>            :     }</a>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     const char* scriptFilename() const { return base()-&gt;scriptFilename(); }</span>
<a name="787"><span class="lineNum">     787 </span>            : </a>
<span class="lineNum">     788 </span>            :     using Size = Base::Size;
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     Size size(mozilla::MallocSizeOf mallocSizeof) const {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         auto size =  base()-&gt;size(mallocSizeof);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(size &gt; 0,</span>
<span class="lineNum">     792 </span>            :                    &quot;C++ does not have zero-sized types! Choose 1 if you just need a &quot;
<span class="lineNum">     793 </span>            :                    &quot;conservative default.&quot;);
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         return size;</span>
<a name="795"><span class="lineNum">     795 </span>            :     }</a>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     js::UniquePtr&lt;EdgeRange&gt; edges(JSContext* cx, bool wantNames = true) const {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         return base()-&gt;edges(cx, wantNames);</span>
<a name="799"><span class="lineNum">     799 </span>            :     }</a>
<a name="800"><span class="lineNum">     800 </span>            : </a>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     bool hasAllocationStack() const { return base()-&gt;hasAllocationStack(); }</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     StackFrame allocationStack() const {</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         return base()-&gt;allocationStack();</span>
<span class="lineNum">     804 </span>            :     }
<a name="805"><span class="lineNum">     805 </span>            : </a>
<span class="lineNum">     806 </span>            :     using Id = Base::Id;
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     Id identifier() const {</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         auto id = base()-&gt;identifier();</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(JS::Value::isNumberRepresentable(id));</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         return id;</span>
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :     // A hash policy for ubi::Nodes.
<span class="lineNum">     814 </span>            :     // This simply uses the stock PointerHasher on the ubi::Node's pointer.
<span class="lineNum">     815 </span>            :     // We specialize DefaultHasher below to make this the default.
<span class="lineNum">     816 </span>            :     class HashPolicy {
<span class="lineNum">     817 </span>            :         typedef js::PointerHasher&lt;void*, mozilla::tl::FloorLog2&lt;sizeof(void*)&gt;::value&gt; PtrHash;
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :       public:
<a name="820"><span class="lineNum">     820 </span>            :         typedef Node Lookup;</a>
<a name="821"><span class="lineNum">     821 </span>            : </a>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         static js::HashNumber hash(const Lookup&amp; l) { return PtrHash::hash(l.base()-&gt;ptr); }</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         static bool match(const Node&amp; k, const Lookup&amp; l) { return k == l; }</span>
<span class="lineNum">     824 </span>            :         static void rekey(Node&amp; k, const Node&amp; newKey) { k = newKey; }
<span class="lineNum">     825 </span>            :     };
<span class="lineNum">     826 </span>            : };
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : using NodeSet = js::HashSet&lt;Node, js::DefaultHasher&lt;Node&gt;, js::SystemAllocPolicy&gt;;
<span class="lineNum">     829 </span>            : using NodeSetPtr = mozilla::UniquePtr&lt;NodeSet, JS::DeletePolicy&lt;NodeSet&gt;&gt;;
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            : /*** Edge and EdgeRange ***************************************************************************/
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : using EdgeName = UniqueTwoByteChars;
<a name="834"><span class="lineNum">     834 </span>            : </a>
<span class="lineNum">     835 </span>            : // An outgoing edge to a referent node.
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 : class Edge {</span></a>
<span class="lineNum">     837 </span>            :   public:
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     Edge() : name(nullptr), referent() { }</span>
<a name="839"><span class="lineNum">     839 </span>            : </a>
<span class="lineNum">     840 </span>            :     // Construct an initialized Edge, taking ownership of |name|.
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     Edge(char16_t* name, const Node&amp; referent)</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :         : name(name)</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         , referent(referent)</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     { }</span>
<a name="845"><span class="lineNum">     845 </span>            : </a>
<span class="lineNum">     846 </span>            :     // Move construction and assignment.
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :     Edge(Edge&amp;&amp; rhs)</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :         : name(mozilla::Move(rhs.name))</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :         , referent(rhs.referent)</span>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :     { }</span></a>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     Edge&amp; operator=(Edge&amp;&amp; rhs) {</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(&amp;rhs != this);</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         this-&gt;~Edge();</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :         new (this) Edge(mozilla::Move(rhs));</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :         return *this;</span>
<span class="lineNum">     857 </span>            :     }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :     Edge(const Edge&amp;) = delete;
<span class="lineNum">     860 </span>            :     Edge&amp; operator=(const Edge&amp;) = delete;
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            :     // This edge's name. This may be nullptr, if Node::edges was called with
<span class="lineNum">     863 </span>            :     // false as the wantNames parameter.
<span class="lineNum">     864 </span>            :     //
<span class="lineNum">     865 </span>            :     // The storage is owned by this Edge, and will be freed when this Edge is
<span class="lineNum">     866 </span>            :     // destructed. You may take ownership of the name by `mozilla::Move`ing it
<span class="lineNum">     867 </span>            :     // out of the edge; it is just a UniquePtr.
<span class="lineNum">     868 </span>            :     //
<span class="lineNum">     869 </span>            :     // (In real life we'll want a better representation for names, to avoid
<span class="lineNum">     870 </span>            :     // creating tons of strings when the names follow a pattern; and we'll need
<span class="lineNum">     871 </span>            :     // to think about lifetimes carefully to ensure traversal stays cheap.)
<span class="lineNum">     872 </span>            :     EdgeName name;
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :     // This edge's referent.
<span class="lineNum">     875 </span>            :     Node referent;
<span class="lineNum">     876 </span>            : };
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : // EdgeRange is an abstract base class for iterating over a node's outgoing
<span class="lineNum">     879 </span>            : // edges. (This is modeled after js::HashTable&lt;K,V&gt;::Range.)
<span class="lineNum">     880 </span>            : //
<span class="lineNum">     881 </span>            : // Concrete instances of this class need not be as lightweight as Node itself,
<span class="lineNum">     882 </span>            : // since they're usually only instantiated while iterating over a particular
<span class="lineNum">     883 </span>            : // object's edges. For example, a dumb implementation for JS Cells might use
<span class="lineNum">     884 </span>            : // JS::TraceChildren to to get the outgoing edges, and then store them in an
<span class="lineNum">     885 </span>            : // array internal to the EdgeRange.
<span class="lineNum">     886 </span>            : class EdgeRange {
<span class="lineNum">     887 </span>            :   protected:
<span class="lineNum">     888 </span>            :     // The current front edge of this range, or nullptr if this range is empty.
<a name="889"><span class="lineNum">     889 </span>            :     Edge* front_;</a>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     EdgeRange() : front_(nullptr) { }</span>
<a name="892"><span class="lineNum">     892 </span>            : </a>
<span class="lineNum">     893 </span>            :   public:
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     virtual ~EdgeRange() { }</span>
<a name="895"><span class="lineNum">     895 </span>            : </a>
<span class="lineNum">     896 </span>            :     // True if there are no more edges in this range.
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     bool empty() const { return !front_; }</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :     // The front edge of this range. This is owned by the EdgeRange, and is
<span class="lineNum">     900 </span>            :     // only guaranteed to live until the next call to popFront, or until
<a name="901"><span class="lineNum">     901 </span>            :     // the EdgeRange is destructed.</a>
<span class="lineNum">     902 </span>            :     const Edge&amp; front() const { return *front_; }
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     Edge&amp; front() { return *front_; }</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :     // Remove the front edge from this range. This should only be called if
<span class="lineNum">     906 </span>            :     // !empty().
<span class="lineNum">     907 </span>            :     virtual void popFront() = 0;
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :   private:
<span class="lineNum">     910 </span>            :     EdgeRange(const EdgeRange&amp;) = delete;
<span class="lineNum">     911 </span>            :     EdgeRange&amp; operator=(const EdgeRange&amp;) = delete;
<span class="lineNum">     912 </span>            : };
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : typedef mozilla::Vector&lt;Edge, 8, js::SystemAllocPolicy&gt; EdgeVector;
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            : // An EdgeRange concrete class that holds a pre-existing vector of
<span class="lineNum">     918 </span>            : // Edges. A PreComputedEdgeRange does not take ownership of its
<a name="919"><span class="lineNum">     919 </span>            : // EdgeVector; it is up to the PreComputedEdgeRange's consumer to manage</a>
<span class="lineNum">     920 </span>            : // that lifetime.
<span class="lineNum">     921 </span><span class="lineNoCov">          0 : class PreComputedEdgeRange : public EdgeRange {</span>
<span class="lineNum">     922 </span>            :     EdgeVector&amp; edges;
<a name="923"><span class="lineNum">     923 </span>            :     size_t      i;</a>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     void settle() {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :         front_ = i &lt; edges.length() ? &amp;edges[i] : nullptr;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :     }</span>
<a name="928"><span class="lineNum">     928 </span>            : </a>
<span class="lineNum">     929 </span>            :   public:
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     explicit PreComputedEdgeRange(EdgeVector&amp; edges)</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :       : edges(edges),</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :         i(0)</span>
<span class="lineNum">     933 </span>            :     {
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         settle();</span>
<a name="935"><span class="lineNum">     935 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     void popFront() override {</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!empty());</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         i++;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         settle();</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     942 </span>            : };
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            : /*** RootList *************************************************************************************/
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : // RootList is a class that can be pointed to by a |ubi::Node|, creating a
<span class="lineNum">     947 </span>            : // fictional root-of-roots which has edges to every GC root in the JS
<span class="lineNum">     948 </span>            : // runtime. Having a single root |ubi::Node| is useful for algorithms written
<span class="lineNum">     949 </span>            : // with the assumption that there aren't multiple roots (such as computing
<span class="lineNum">     950 </span>            : // dominator trees) and you want a single point of entry. It also ensures that
<span class="lineNum">     951 </span>            : // the roots themselves get visited by |ubi::BreadthFirst| (they would otherwise
<span class="lineNum">     952 </span>            : // only be used as starting points).
<span class="lineNum">     953 </span>            : //
<span class="lineNum">     954 </span>            : // RootList::init itself causes a minor collection, but once the list of roots
<span class="lineNum">     955 </span>            : // has been created, GC must not occur, as the referent ubi::Nodes are not
<span class="lineNum">     956 </span>            : // stable across GC. The init calls emplace on |noGC|'s AutoCheckCannotGC, whose
<span class="lineNum">     957 </span>            : // lifetime must extend at least as long as the RootList itself.
<span class="lineNum">     958 </span>            : //
<span class="lineNum">     959 </span>            : // Example usage:
<span class="lineNum">     960 </span>            : //
<span class="lineNum">     961 </span>            : //    {
<span class="lineNum">     962 </span>            : //        mozilla::Maybe&lt;JS::AutoCheckCannotGC&gt; maybeNoGC;
<span class="lineNum">     963 </span>            : //        JS::ubi::RootList rootList(cx, maybeNoGC);
<span class="lineNum">     964 </span>            : //        if (!rootList.init())
<span class="lineNum">     965 </span>            : //            return false;
<span class="lineNum">     966 </span>            : //
<span class="lineNum">     967 </span>            : //        // The AutoCheckCannotGC is guaranteed to exist if init returned true.
<span class="lineNum">     968 </span>            : //        MOZ_ASSERT(maybeNoGC.isSome());
<span class="lineNum">     969 </span>            : //
<span class="lineNum">     970 </span>            : //        JS::ubi::Node root(&amp;rootList);
<span class="lineNum">     971 </span>            : //
<a name="972"><span class="lineNum">     972 </span>            : //        ...</a>
<span class="lineNum">     973 </span>            : //    }
<span class="lineNum">     974 </span><span class="lineNoCov">          0 : class MOZ_STACK_CLASS JS_PUBLIC_API(RootList) {</span>
<span class="lineNum">     975 </span>            :     Maybe&lt;AutoCheckCannotGC&gt;&amp; noGC;
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :   public:
<span class="lineNum">     978 </span>            :     JSContext* cx;
<span class="lineNum">     979 </span>            :     EdgeVector edges;
<span class="lineNum">     980 </span>            :     bool       wantNames;
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :     RootList(JSContext* cx, Maybe&lt;AutoCheckCannotGC&gt;&amp; noGC, bool wantNames = false);
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :     // Find all GC roots.
<span class="lineNum">     985 </span>            :     MOZ_MUST_USE bool init();
<span class="lineNum">     986 </span>            :     // Find only GC roots in the provided set of |JSCompartment|s.
<span class="lineNum">     987 </span>            :     MOZ_MUST_USE bool init(CompartmentSet&amp; debuggees);
<span class="lineNum">     988 </span>            :     // Find only GC roots in the given Debugger object's set of debuggee
<span class="lineNum">     989 </span>            :     // compartments.
<span class="lineNum">     990 </span>            :     MOZ_MUST_USE bool init(HandleObject debuggees);
<span class="lineNum">     991 </span>            : 
<a name="992"><span class="lineNum">     992 </span>            :     // Returns true if the RootList has been initialized successfully, false</a>
<span class="lineNum">     993 </span>            :     // otherwise.
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     bool initialized() { return noGC.isSome(); }</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     // Explicitly add the given Node as a root in this RootList. If wantNames is
<span class="lineNum">     997 </span>            :     // true, you must pass an edgeName. The RootList does not take ownership of
<span class="lineNum">     998 </span>            :     // edgeName.
<span class="lineNum">     999 </span>            :     MOZ_MUST_USE bool addRoot(Node node, const char16_t* edgeName = nullptr);
<span class="lineNum">    1000 </span>            : };
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            : /*** Concrete classes for ubi::Node referent types ************************************************/
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            : template&lt;&gt;
<a name="1006"><span class="lineNum">    1006 </span>            : class JS_PUBLIC_API(Concrete&lt;RootList&gt;) : public Base {</a>
<a name="1007"><span class="lineNum">    1007 </span>            :   protected:</a>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     explicit Concrete(RootList* ptr) : Base(ptr) { }</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     RootList&amp; get() const { return *static_cast&lt;RootList*&gt;(ptr); }</span>
<a name="1010"><span class="lineNum">    1010 </span>            : </a>
<span class="lineNum">    1011 </span>            :   public:
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     static void construct(void* storage, RootList* ptr) { new (storage) Concrete(ptr); }</span>
<span class="lineNum">    1013 </span>            : 
<a name="1014"><span class="lineNum">    1014 </span>            :     js::UniquePtr&lt;EdgeRange&gt; edges(JSContext* cx, bool wantNames) const override;</a>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1017 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1018 </span>            : };
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            : // A reusable ubi::Concrete specialization base class for types supported by
<span class="lineNum">    1021 </span>            : // JS::TraceChildren.
<span class="lineNum">    1022 </span>            : template&lt;typename Referent&gt;
<span class="lineNum">    1023 </span>            : class JS_PUBLIC_API(TracerConcrete) : public Base {
<span class="lineNum">    1024 </span>            :     js::UniquePtr&lt;EdgeRange&gt; edges(JSContext* cx, bool wantNames) const override;
<span class="lineNum">    1025 </span>            :     JS::Zone* zone() const override;
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<a name="1027"><span class="lineNum">    1027 </span>            :   protected:</a>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :     explicit TracerConcrete(Referent* ptr) : Base(ptr) { }</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     Referent&amp; get() const { return *static_cast&lt;Referent*&gt;(ptr); }</span>
<span class="lineNum">    1030 </span>            : };
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            : // For JS::TraceChildren-based types that have a 'compartment' method.
<span class="lineNum">    1033 </span>            : template&lt;typename Referent&gt;
<span class="lineNum">    1034 </span>            : class JS_PUBLIC_API(TracerConcreteWithCompartment) : public TracerConcrete&lt;Referent&gt; {
<span class="lineNum">    1035 </span>            :     typedef TracerConcrete&lt;Referent&gt; TracerBase;
<span class="lineNum">    1036 </span>            :     JSCompartment* compartment() const override;
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<span class="lineNum">    1038 </span>            :   protected:
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     explicit TracerConcreteWithCompartment(Referent* ptr) : TracerBase(ptr) { }</span>
<span class="lineNum">    1040 </span>            : };
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            : // Define specializations for some commonly-used public JSAPI types.
<span class="lineNum">    1043 </span>            : // These can use the generic templates above.
<span class="lineNum">    1044 </span>            : template&lt;&gt;
<a name="1045"><span class="lineNum">    1045 </span>            : class JS_PUBLIC_API(Concrete&lt;JS::Symbol&gt;) : TracerConcrete&lt;JS::Symbol&gt; {</a>
<span class="lineNum">    1046 </span>            :   protected:
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     explicit Concrete(JS::Symbol* ptr) : TracerConcrete(ptr) { }</span>
<a name="1048"><span class="lineNum">    1048 </span>            : </a>
<span class="lineNum">    1049 </span>            :   public:
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     static void construct(void* storage, JS::Symbol* ptr) {</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :         new (storage) Concrete(ptr);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1053 </span>            : 
<a name="1054"><span class="lineNum">    1054 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;</a>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1057 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1058 </span>            : };
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : template&lt;&gt;
<a name="1061"><span class="lineNum">    1061 </span>            : class JS_PUBLIC_API(Concrete&lt;JSScript&gt;) : TracerConcreteWithCompartment&lt;JSScript&gt; {</a>
<span class="lineNum">    1062 </span>            :   protected:
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     explicit Concrete(JSScript *ptr) : TracerConcreteWithCompartment&lt;JSScript&gt;(ptr) { }</span>
<a name="1064"><span class="lineNum">    1064 </span>            : </a>
<span class="lineNum">    1065 </span>            :   public:
<a name="1066"><span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     static void construct(void *storage, JSScript *ptr) { new (storage) Concrete(ptr); }</span></a>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     CoarseType coarseType() const final { return CoarseType::Script; }</span>
<span class="lineNum">    1069 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;
<a name="1070"><span class="lineNum">    1070 </span>            :     const char* scriptFilename() const final;</a>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1073 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1074 </span>            : };
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : // The JSObject specialization.
<span class="lineNum">    1077 </span>            : template&lt;&gt;
<a name="1078"><span class="lineNum">    1078 </span>            : class JS_PUBLIC_API(Concrete&lt;JSObject&gt;) : public TracerConcreteWithCompartment&lt;JSObject&gt; {</a>
<span class="lineNum">    1079 </span>            :   protected:
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :     explicit Concrete(JSObject* ptr) : TracerConcreteWithCompartment(ptr) { }</span>
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<span class="lineNum">    1082 </span>            :   public:
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     static void construct(void* storage, JSObject* ptr) {</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         new (storage) Concrete(ptr);</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :     const char* jsObjectClassName() const override;
<span class="lineNum">    1088 </span>            :     MOZ_MUST_USE bool jsObjectConstructorName(JSContext* cx, UniqueTwoByteChars&amp; outName)
<span class="lineNum">    1089 </span>            :         const override;
<span class="lineNum">    1090 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :     bool hasAllocationStack() const override;
<a name="1093"><span class="lineNum">    1093 </span>            :     StackFrame allocationStack() const override;</a>
<span class="lineNum">    1094 </span>            : 
<a name="1095"><span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     CoarseType coarseType() const final { return CoarseType::Object; }</span></a>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1098 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1099 </span>            : };
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            : // For JSString, we extend the generic template with a 'size' implementation.
<span class="lineNum">    1102 </span>            : template&lt;&gt;
<a name="1103"><span class="lineNum">    1103 </span>            : class JS_PUBLIC_API(Concrete&lt;JSString&gt;) : TracerConcrete&lt;JSString&gt; {</a>
<span class="lineNum">    1104 </span>            :   protected:
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     explicit Concrete(JSString *ptr) : TracerConcrete&lt;JSString&gt;(ptr) { }</span>
<a name="1106"><span class="lineNum">    1106 </span>            : </a>
<span class="lineNum">    1107 </span>            :   public:
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     static void construct(void *storage, JSString *ptr) { new (storage) Concrete(ptr); }</span>
<span class="lineNum">    1109 </span>            : 
<a name="1110"><span class="lineNum">    1110 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;</a>
<span class="lineNum">    1111 </span>            : 
<a name="1112"><span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     CoarseType coarseType() const final { return CoarseType::String; }</span></a>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     const char16_t* typeName() const override { return concreteTypeName; }</span>
<span class="lineNum">    1115 </span>            :     static const char16_t concreteTypeName[];
<span class="lineNum">    1116 </span>            : };
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            : // The ubi::Node null pointer. Any attempt to operate on a null ubi::Node asserts.
<span class="lineNum">    1119 </span>            : template&lt;&gt;
<span class="lineNum">    1120 </span>            : class JS_PUBLIC_API(Concrete&lt;void&gt;) : public Base {
<span class="lineNum">    1121 </span>            :     const char16_t* typeName() const override;
<span class="lineNum">    1122 </span>            :     Size size(mozilla::MallocSizeOf mallocSizeOf) const override;
<span class="lineNum">    1123 </span>            :     js::UniquePtr&lt;EdgeRange&gt; edges(JSContext* cx, bool wantNames) const override;
<span class="lineNum">    1124 </span>            :     JS::Zone* zone() const override;
<span class="lineNum">    1125 </span>            :     JSCompartment* compartment() const override;
<a name="1126"><span class="lineNum">    1126 </span>            :     CoarseType coarseType() const final;</a>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     explicit Concrete(void* ptr) : Base(ptr) { }</span>
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<span class="lineNum">    1130 </span>            :   public:
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     static void construct(void* storage, void* ptr) { new (storage) Concrete(ptr); }</span>
<span class="lineNum">    1132 </span>            : };
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            : } // namespace ubi
<span class="lineNum">    1136 </span>            : } // namespace JS
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : namespace js {
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            : // Make ubi::Node::HashPolicy the default hash policy for ubi::Node.
<span class="lineNum">    1141 </span>            : template&lt;&gt; struct DefaultHasher&lt;JS::ubi::Node&gt; : JS::ubi::Node::HashPolicy { };
<span class="lineNum">    1142 </span>            : template&lt;&gt; struct DefaultHasher&lt;JS::ubi::StackFrame&gt; : JS::ubi::StackFrame::HashPolicy { };
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            : } // namespace js
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            : #endif // js_UbiNode_h
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/xpconnect/src/XPCJSRuntime.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/xpconnect/src</a> - XPCJSRuntime.cpp<span style="font-size: 80%;"> (source / <a href="XPCJSRuntime.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">322</td>
            <td class="headerCovTableEntry">1232</td>
            <td class="headerCovTableEntryLo">26.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntry">128</td>
            <td class="headerCovTableEntryLo">36.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=4 et sw=4 tw=99: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* Per JSRuntime object */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;xpcprivate.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;xpcpublic.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;XPCWrapper.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;XPCJSMemoryReporter.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;WrapperFactory.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozJSComponentLoader.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsAutoPtr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsNetUtil.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;nsIMemoryInfoDumper.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIMemoryReporter.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsIObserverService.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsIDebug2.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nsIDocShell.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsIRunnable.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;amIAddonManager.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsPIDOMWindow.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsPrintfCString.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/Services.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;mozilla/dom/ScriptLoader.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;mozilla/dom/ScriptSettings.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsCCUncollectableMarker.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;nsCycleCollectionNoteRootCallback.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;nsCycleCollector.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;jsapi.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;jsprf.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;js/MemoryMetrics.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;mozilla/dom/GeneratedAtomList.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;mozilla/dom/BindingUtils.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;mozilla/dom/Element.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;mozilla/dom/WindowBinding.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mozilla/jsipc/CrossProcessObjectWrappers.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;mozilla/ProcessHangMonitor.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;mozilla/Sprintf.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;mozilla/UniquePtrExtensions.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;AccessCheck.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;nsGlobalWindow.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;nsAboutProtocolUtils.h&quot;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;nsIInputStream.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;nsIXULRuntime.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nsJSPrincipals.h&quot;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #ifdef MOZ_CRASHREPORTER
<span class="lineNum">      64 </span>            : #include &quot;nsExceptionHandler.h&quot;
<span class="lineNum">      65 </span>            : #endif
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #ifdef XP_WIN
<span class="lineNum">      68 </span>            : #include &lt;windows.h&gt;
<span class="lineNum">      69 </span>            : #endif
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : using namespace mozilla;
<span class="lineNum">      72 </span>            : using namespace xpc;
<span class="lineNum">      73 </span>            : using namespace JS;
<span class="lineNum">      74 </span>            : using mozilla::dom::PerThreadAtomCache;
<span class="lineNum">      75 </span>            : using mozilla::dom::AutoEntryScript;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /***************************************************************************/
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : const char* const XPCJSRuntime::mStrings[] = {
<span class="lineNum">      80 </span>            :     &quot;constructor&quot;,          // IDX_CONSTRUCTOR
<span class="lineNum">      81 </span>            :     &quot;toString&quot;,             // IDX_TO_STRING
<span class="lineNum">      82 </span>            :     &quot;toSource&quot;,             // IDX_TO_SOURCE
<span class="lineNum">      83 </span>            :     &quot;lastResult&quot;,           // IDX_LAST_RESULT
<span class="lineNum">      84 </span>            :     &quot;returnCode&quot;,           // IDX_RETURN_CODE
<span class="lineNum">      85 </span>            :     &quot;value&quot;,                // IDX_VALUE
<span class="lineNum">      86 </span>            :     &quot;QueryInterface&quot;,       // IDX_QUERY_INTERFACE
<span class="lineNum">      87 </span>            :     &quot;Components&quot;,           // IDX_COMPONENTS
<span class="lineNum">      88 </span>            :     &quot;wrappedJSObject&quot;,      // IDX_WRAPPED_JSOBJECT
<span class="lineNum">      89 </span>            :     &quot;Object&quot;,               // IDX_OBJECT
<span class="lineNum">      90 </span>            :     &quot;Function&quot;,             // IDX_FUNCTION
<span class="lineNum">      91 </span>            :     &quot;prototype&quot;,            // IDX_PROTOTYPE
<span class="lineNum">      92 </span>            :     &quot;createInstance&quot;,       // IDX_CREATE_INSTANCE
<span class="lineNum">      93 </span>            :     &quot;item&quot;,                 // IDX_ITEM
<span class="lineNum">      94 </span>            :     &quot;__proto__&quot;,            // IDX_PROTO
<span class="lineNum">      95 </span>            :     &quot;__iterator__&quot;,         // IDX_ITERATOR
<span class="lineNum">      96 </span>            :     &quot;__exposedProps__&quot;,     // IDX_EXPOSEDPROPS
<span class="lineNum">      97 </span>            :     &quot;eval&quot;,                 // IDX_EVAL
<span class="lineNum">      98 </span>            :     &quot;controllers&quot;,          // IDX_CONTROLLERS
<span class="lineNum">      99 </span>            :     &quot;Controllers&quot;,          // IDX_CONTROLLERS_CLASS
<span class="lineNum">     100 </span>            :     &quot;realFrameElement&quot;,     // IDX_REALFRAMEELEMENT
<span class="lineNum">     101 </span>            :     &quot;length&quot;,               // IDX_LENGTH
<span class="lineNum">     102 </span>            :     &quot;name&quot;,                 // IDX_NAME
<span class="lineNum">     103 </span>            :     &quot;undefined&quot;,            // IDX_UNDEFINED
<span class="lineNum">     104 </span>            :     &quot;&quot;,                     // IDX_EMPTYSTRING
<span class="lineNum">     105 </span>            :     &quot;fileName&quot;,             // IDX_FILENAME
<span class="lineNum">     106 </span>            :     &quot;lineNumber&quot;,           // IDX_LINENUMBER
<span class="lineNum">     107 </span>            :     &quot;columnNumber&quot;,         // IDX_COLUMNNUMBER
<span class="lineNum">     108 </span>            :     &quot;stack&quot;,                // IDX_STACK
<span class="lineNum">     109 </span>            :     &quot;message&quot;,              // IDX_MESSAGE
<span class="lineNum">     110 </span>            :     &quot;lastIndex&quot;             // IDX_LASTINDEX
<span class="lineNum">     111 </span>            : };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /***************************************************************************/
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : // *Some* NativeSets are referenced from mClassInfo2NativeSetMap.
<span class="lineNum">     116 </span>            : // *All* NativeSets are referenced from mNativeSetMap.
<span class="lineNum">     117 </span>            : // So, in mClassInfo2NativeSetMap we just clear references to the unmarked.
<a name="118"><span class="lineNum">     118 </span>            : // In mNativeSetMap we clear the references to the unmarked *and* delete them.</a>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 : class AsyncFreeSnowWhite : public Runnable</span>
<a name="121"><span class="lineNum">     121 </span>            : {</a>
<span class="lineNum">     122 </span>            : public:
<span class="lineNum">     123 </span><span class="lineCov">          1 :   NS_IMETHOD Run() override</span>
<span class="lineNum">     124 </span>            :   {
<span class="lineNum">     125 </span><span class="lineCov">          1 :       TimeStamp start = TimeStamp::Now();</span>
<span class="lineNum">     126 </span><span class="lineCov">          1 :       bool hadSnowWhiteObjects = nsCycleCollector_doDeferredDeletion();</span>
<span class="lineNum">     127 </span><span class="lineCov">          1 :       Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_ASYNC_SNOW_WHITE_FREEING,</span>
<span class="lineNum">     128 </span><span class="lineCov">          2 :                             uint32_t((TimeStamp::Now() - start).ToMilliseconds()));</span>
<span class="lineNum">     129 </span><span class="lineCov">          1 :       if (hadSnowWhiteObjects &amp;&amp; !mContinuation) {</span>
<span class="lineNum">     130 </span><span class="lineCov">          1 :           mContinuation = true;</span>
<span class="lineNum">     131 </span><span class="lineCov">          2 :           if (NS_FAILED(Dispatch())) {</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :               mActive = false;</span>
<span class="lineNum">     133 </span>            :           }
<span class="lineNum">     134 </span>            :       } else {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :           mActive = false;</span>
<span class="lineNum">     136 </span>            :       }
<span class="lineNum">     137 </span><span class="lineCov">          1 :       return NS_OK;</span>
<a name="138"><span class="lineNum">     138 </span>            :   }</a>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">          2 :   nsresult Dispatch()</span>
<span class="lineNum">     141 </span>            :   {
<span class="lineNum">     142 </span><span class="lineCov">          4 :       nsCOMPtr&lt;nsIRunnable&gt; self(this);</span>
<span class="lineNum">     143 </span><span class="lineCov">          4 :       return NS_IdleDispatchToCurrentThread(self.forget(), 1000);</span>
<a name="144"><span class="lineNum">     144 </span>            :   }</a>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineCov">          3 :   void Start(bool aContinuation = false, bool aPurge = false)</span>
<span class="lineNum">     147 </span>            :   {
<span class="lineNum">     148 </span><span class="lineCov">          3 :       if (mContinuation) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :           mContinuation = aContinuation;</span>
<span class="lineNum">     150 </span>            :       }
<span class="lineNum">     151 </span><span class="lineCov">          3 :       mPurge = aPurge;</span>
<span class="lineNum">     152 </span><span class="lineCov">          3 :       if (!mActive &amp;&amp; NS_SUCCEEDED(Dispatch())) {</span>
<span class="lineNum">     153 </span><span class="lineCov">          1 :           mActive = true;</span>
<span class="lineNum">     154 </span>            :       }
<a name="155"><span class="lineNum">     155 </span><span class="lineCov">          3 :   }</span></a>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineCov">          3 :   AsyncFreeSnowWhite()</span>
<span class="lineNum">     158 </span><span class="lineCov">          3 :     : Runnable(&quot;AsyncFreeSnowWhite&quot;)</span>
<span class="lineNum">     159 </span>            :     , mContinuation(false)
<span class="lineNum">     160 </span>            :     , mActive(false)
<span class="lineNum">     161 </span><span class="lineCov">          3 :     , mPurge(false) {}</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : public:
<span class="lineNum">     164 </span>            :   bool mContinuation;
<span class="lineNum">     165 </span>            :   bool mActive;
<span class="lineNum">     166 </span>            :   bool mPurge;
<span class="lineNum">     167 </span>            : };
<span class="lineNum">     168 </span>            : 
<a name="169"><span class="lineNum">     169 </span>            : namespace xpc {</a>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineCov">        293 : CompartmentPrivate::CompartmentPrivate(JSCompartment* c)</span>
<span class="lineNum">     172 </span>            :     : wantXrays(false)
<span class="lineNum">     173 </span>            :     , allowWaivers(true)
<span class="lineNum">     174 </span>            :     , writeToGlobalPrototype(false)
<span class="lineNum">     175 </span>            :     , skipWriteToGlobalPrototype(false)
<span class="lineNum">     176 </span>            :     , isWebExtensionContentScript(false)
<span class="lineNum">     177 </span>            :     , waiveInterposition(false)
<span class="lineNum">     178 </span>            :     , allowCPOWs(false)
<span class="lineNum">     179 </span>            :     , universalXPConnectEnabled(false)
<span class="lineNum">     180 </span>            :     , forcePermissiveCOWs(false)
<span class="lineNum">     181 </span>            :     , wasNuked(false)
<span class="lineNum">     182 </span>            :     , scriptability(c)
<span class="lineNum">     183 </span>            :     , scope(nullptr)
<span class="lineNum">     184 </span><span class="lineCov">        293 :     , mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_LENGTH))</span>
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineCov">        293 :     MOZ_COUNT_CTOR(xpc::CompartmentPrivate);</span>
<span class="lineNum">     187 </span><span class="lineCov">        293 :     mozilla::PodArrayZero(wrapperDenialWarnings);</span>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">        293 : }</span></a>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 : CompartmentPrivate::~CompartmentPrivate()</span>
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR(xpc::CompartmentPrivate);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     mWrappedJSMap-&gt;ShutdownMarker();</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     delete mWrappedJSMap;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 : }</span>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<span class="lineNum">     197 </span>            : static bool
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : TryParseLocationURICandidate(const nsACString&amp; uristr,</span>
<span class="lineNum">     199 </span>            :                              CompartmentPrivate::LocationHint aLocationHint,
<span class="lineNum">     200 </span>            :                              nsIURI** aURI)
<span class="lineNum">     201 </span>            : {
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kGRE, &quot;resource://gre/&quot;);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kToolkit, &quot;chrome://global/&quot;);</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     static NS_NAMED_LITERAL_CSTRING(kBrowser, &quot;chrome://browser/&quot;);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :     if (aLocationHint == CompartmentPrivate::LocationHintAddon) {</span>
<span class="lineNum">     207 </span>            :         // Blacklist some known locations which are clearly not add-on related.
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         if (StringBeginsWith(uristr, kGRE) ||</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             StringBeginsWith(uristr, kToolkit) ||</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :             StringBeginsWith(uristr, kBrowser))</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :         // -- GROSS HACK ALERT --
<span class="lineNum">     214 </span>            :         // The Yandex Elements 8.10.2 extension implements its own &quot;xb://&quot; URL
<span class="lineNum">     215 </span>            :         // scheme. If we call NS_NewURI() on an &quot;xb://...&quot; URL, we'll end up
<span class="lineNum">     216 </span>            :         // calling into the extension's own JS-implemented nsIProtocolHandler
<span class="lineNum">     217 </span>            :         // object, which we can't allow while we're iterating over the JS heap.
<span class="lineNum">     218 </span>            :         // So just skip any such URL.
<span class="lineNum">     219 </span>            :         // -- GROSS HACK ALERT --
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         if (StringBeginsWith(uristr, NS_LITERAL_CSTRING(&quot;xb&quot;)))</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     222 </span>            :     }
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), uristr)))</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     nsAutoCString scheme;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     if (NS_FAILED(uri-&gt;GetScheme(scheme)))</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :     // Cannot really map data: and blob:.
<span class="lineNum">     233 </span>            :     // Also, data: URIs are pretty memory hungry, which is kinda bad
<span class="lineNum">     234 </span>            :     // for memory reporter use.
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     if (scheme.EqualsLiteral(&quot;data&quot;) || scheme.EqualsLiteral(&quot;blob&quot;))</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     uri.forget(aURI);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="240"><span class="lineNum">     240 </span>            : }</a>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 : bool CompartmentPrivate::TryParseLocationURI(CompartmentPrivate::LocationHint aLocationHint,</span>
<span class="lineNum">     243 </span>            :                                              nsIURI** aURI)
<span class="lineNum">     244 </span>            : {
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (!aURI)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :     // Need to parse the URI.
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if (location.IsEmpty())</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :     // Handle Sandbox location strings.
<span class="lineNum">     253 </span>            :     // A sandbox string looks like this:
<span class="lineNum">     254 </span>            :     // &lt;sandboxName&gt; (from: &lt;js-stack-frame-filename&gt;:&lt;lineno&gt;)
<span class="lineNum">     255 </span>            :     // where &lt;sandboxName&gt; is user-provided via Cu.Sandbox()
<span class="lineNum">     256 </span>            :     // and &lt;js-stack-frame-filename&gt; and &lt;lineno&gt; is the stack frame location
<span class="lineNum">     257 </span>            :     // from where Cu.Sandbox was called.
<span class="lineNum">     258 </span>            :     // &lt;js-stack-frame-filename&gt; furthermore is &quot;free form&quot;, often using a
<span class="lineNum">     259 </span>            :     // &quot;uri -&gt; uri -&gt; ...&quot; chain. The following code will and must handle this
<span class="lineNum">     260 </span>            :     // common case.
<span class="lineNum">     261 </span>            :     // It should be noted that other parts of the code may already rely on the
<span class="lineNum">     262 </span>            :     // &quot;format&quot; of these strings, such as the add-on SDK.
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     static const nsDependentCString from(&quot;(from: &quot;);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     static const nsDependentCString arrow(&quot; -&gt; &quot;);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     static const size_t fromLength = from.Length();</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     static const size_t arrowLength = arrow.Length();</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :     // See: XPCComponents.cpp#AssembleSandboxMemoryReporterName
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     int32_t idx = location.Find(from);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :     if (idx &lt; 0)</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         return TryParseLocationURICandidate(location, aLocationHint, aURI);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     // When parsing we're looking for the right-most URI. This URI may be in
<span class="lineNum">     276 </span>            :     // &lt;sandboxName&gt;, so we try this first.
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if (TryParseLocationURICandidate(Substring(location, 0, idx), aLocationHint,</span>
<span class="lineNum">     278 </span>            :                                      aURI))
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :     // Not in &lt;sandboxName&gt; so we need to inspect &lt;js-stack-frame-filename&gt; and
<span class="lineNum">     282 </span>            :     // the chain that is potentially contained within and grab the rightmost
<span class="lineNum">     283 </span>            :     // item that is actually a URI.
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :     // First, hack off the :&lt;lineno&gt;) part as well
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     int32_t ridx = location.RFind(NS_LITERAL_CSTRING(&quot;:&quot;));</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     nsAutoCString chain(Substring(location, idx + fromLength,</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                                   ridx - idx - fromLength));</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     // Loop over the &quot;-&gt;&quot; chain. This loop also works for non-chains, or more
<span class="lineNum">     291 </span>            :     // correctly chains with only one item.
<span class="lineNum">     292 </span>            :     for (;;) {
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         idx = chain.RFind(arrow);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         if (idx &lt; 0) {</span>
<span class="lineNum">     295 </span>            :             // This is the last chain item. Try to parse what is left.
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             return TryParseLocationURICandidate(chain, aLocationHint, aURI);</span>
<span class="lineNum">     297 </span>            :         }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :         // Try to parse current chain item
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         if (TryParseLocationURICandidate(Substring(chain, idx + arrowLength),</span>
<span class="lineNum">     301 </span>            :                                          aLocationHint, aURI))
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :         // Current chain item couldn't be parsed.
<span class="lineNum">     305 </span>            :         // Strip current item and continue.
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         chain = Substring(chain, 0, idx);</span>
<span class="lineNum">     307 </span>            :     }
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :     MOZ_CRASH(&quot;Chain parser loop does not terminate&quot;);
<span class="lineNum">     310 </span>            : }
<a name="311"><span class="lineNum">     311 </span>            : </a>
<span class="lineNum">     312 </span>            : static bool
<span class="lineNum">     313 </span><span class="lineCov">        293 : PrincipalImmuneToScriptPolicy(nsIPrincipal* aPrincipal)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :     // System principal gets a free pass.
<span class="lineNum">     316 </span><span class="lineCov">        293 :     if (nsXPConnect::SecurityManager()-&gt;IsSystemPrincipal(aPrincipal))</span>
<span class="lineNum">     317 </span><span class="lineCov">        282 :         return true;</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     // ExpandedPrincipal gets a free pass.
<span class="lineNum">     320 </span><span class="lineCov">         22 :     nsCOMPtr&lt;nsIExpandedPrincipal&gt; ep = do_QueryInterface(aPrincipal);</span>
<span class="lineNum">     321 </span><span class="lineCov">         11 :     if (ep)</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :     // Check whether our URI is an &quot;about:&quot; URI that allows scripts.  If it is,
<span class="lineNum">     325 </span>            :     // we need to allow JS to run.
<span class="lineNum">     326 </span><span class="lineCov">         22 :     nsCOMPtr&lt;nsIURI&gt; principalURI;</span>
<span class="lineNum">     327 </span><span class="lineCov">         11 :     aPrincipal-&gt;GetURI(getter_AddRefs(principalURI));</span>
<span class="lineNum">     328 </span><span class="lineCov">         11 :     MOZ_ASSERT(principalURI);</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :     // WebExtension principals gets a free pass.
<span class="lineNum">     331 </span><span class="lineCov">         22 :     nsString addonId;</span>
<span class="lineNum">     332 </span><span class="lineCov">         11 :     aPrincipal-&gt;GetAddonId(addonId);</span>
<span class="lineNum">     333 </span><span class="lineCov">         11 :     bool isWebExtension = !addonId.IsEmpty();</span>
<span class="lineNum">     334 </span><span class="lineCov">         11 :     if (isWebExtension) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     bool isAbout;
<span class="lineNum">     339 </span><span class="lineCov">         11 :     nsresult rv = principalURI-&gt;SchemeIs(&quot;about&quot;, &amp;isAbout);</span>
<span class="lineNum">     340 </span><span class="lineCov">         11 :     if (NS_SUCCEEDED(rv) &amp;&amp; isAbout) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsIAboutModule&gt; module;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :         rv = NS_GetAboutModule(principalURI, getter_AddRefs(module));</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(rv)) {</span>
<span class="lineNum">     344 </span>            :             uint32_t flags;
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :             rv = module-&gt;GetURIFlags(principalURI, &amp;flags);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             if (NS_SUCCEEDED(rv) &amp;&amp;</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                 (flags &amp; nsIAboutModule::ALLOW_SCRIPT)) {</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     349 </span>            :             }
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span>            :     }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineCov">         11 :     return false;</span>
<a name="354"><span class="lineNum">     354 </span>            : }</a>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineCov">        293 : Scriptability::Scriptability(JSCompartment* c) : mScriptBlocks(0)</span>
<span class="lineNum">     357 </span>            :                                                , mDocShellAllowsScript(true)
<span class="lineNum">     358 </span><span class="lineCov">        293 :                                                , mScriptBlockedByPolicy(false)</span>
<span class="lineNum">     359 </span>            : {
<span class="lineNum">     360 </span><span class="lineCov">        293 :     nsIPrincipal* prin = nsJSPrincipals::get(JS_GetCompartmentPrincipals(c));</span>
<span class="lineNum">     361 </span><span class="lineCov">        293 :     mImmuneToScriptPolicy = PrincipalImmuneToScriptPolicy(prin);</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :     // If we're not immune, we should have a real principal with a codebase URI.
<span class="lineNum">     364 </span>            :     // Check the URI against the new-style domain policy.
<span class="lineNum">     365 </span><span class="lineCov">        293 :     if (!mImmuneToScriptPolicy) {</span>
<span class="lineNum">     366 </span><span class="lineCov">         22 :         nsCOMPtr&lt;nsIURI&gt; codebase;</span>
<span class="lineNum">     367 </span><span class="lineCov">         11 :         nsresult rv = prin-&gt;GetURI(getter_AddRefs(codebase));</span>
<span class="lineNum">     368 </span>            :         bool policyAllows;
<span class="lineNum">     369 </span><span class="lineCov">         22 :         if (NS_SUCCEEDED(rv) &amp;&amp; codebase &amp;&amp;</span>
<span class="lineNum">     370 </span><span class="lineCov">         11 :             NS_SUCCEEDED(nsXPConnect::SecurityManager()-&gt;PolicyAllowsScript(codebase, &amp;policyAllows)))</span>
<span class="lineNum">     371 </span>            :         {
<span class="lineNum">     372 </span><span class="lineCov">         11 :             mScriptBlockedByPolicy = !policyAllows;</span>
<span class="lineNum">     373 </span>            :         } else {
<span class="lineNum">     374 </span>            :             // Something went wrong - be safe and block script.
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :             mScriptBlockedByPolicy = true;</span>
<span class="lineNum">     376 </span>            :         }
<span class="lineNum">     377 </span>            :     }
<span class="lineNum">     378 </span><span class="lineCov">        293 : }</span>
<a name="379"><span class="lineNum">     379 </span>            : </a>
<span class="lineNum">     380 </span>            : bool
<span class="lineNum">     381 </span><span class="lineCov">        516 : Scriptability::Allowed()</span>
<span class="lineNum">     382 </span>            : {
<span class="lineNum">     383 </span><span class="lineCov">       1032 :     return mDocShellAllowsScript &amp;&amp; !mScriptBlockedByPolicy &amp;&amp;</span>
<span class="lineNum">     384 </span><span class="lineCov">       1032 :            mScriptBlocks == 0;</span>
<span class="lineNum">     385 </span>            : }
<a name="386"><span class="lineNum">     386 </span>            : </a>
<span class="lineNum">     387 </span>            : bool
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : Scriptability::IsImmuneToScriptPolicy()</span>
<span class="lineNum">     389 </span>            : {
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     return mImmuneToScriptPolicy;</span>
<span class="lineNum">     391 </span>            : }
<a name="392"><span class="lineNum">     392 </span>            : </a>
<span class="lineNum">     393 </span>            : void
<span class="lineNum">     394 </span><span class="lineNoCov">          0 : Scriptability::Block()</span>
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     ++mScriptBlocks;</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 : }</span>
<a name="398"><span class="lineNum">     398 </span>            : </a>
<span class="lineNum">     399 </span>            : void
<span class="lineNum">     400 </span><span class="lineNoCov">          0 : Scriptability::Unblock()</span>
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mScriptBlocks &gt; 0);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :     --mScriptBlocks;</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 : }</span>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<span class="lineNum">     406 </span>            : void
<span class="lineNum">     407 </span><span class="lineCov">         11 : Scriptability::SetDocShellAllowsScript(bool aAllowed)</span>
<span class="lineNum">     408 </span>            : {
<span class="lineNum">     409 </span><span class="lineCov">         11 :     mDocShellAllowsScript = aAllowed || mImmuneToScriptPolicy;</span>
<span class="lineNum">     410 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     411 </span>            : 
<a name="412"><span class="lineNum">     412 </span>            : /* static */</a>
<span class="lineNum">     413 </span>            : Scriptability&amp;
<span class="lineNum">     414 </span><span class="lineCov">        527 : Scriptability::Get(JSObject* aScope)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineCov">        527 :     return CompartmentPrivate::Get(aScope)-&gt;scriptability;</span>
<span class="lineNum">     417 </span>            : }
<a name="418"><span class="lineNum">     418 </span>            : </a>
<span class="lineNum">     419 </span>            : bool
<span class="lineNum">     420 </span><span class="lineCov">       3499 : IsContentXBLScope(JSCompartment* compartment)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span>            :     // We always eagerly create compartment privates for XBL scopes.
<span class="lineNum">     423 </span><span class="lineCov">       3499 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     424 </span><span class="lineCov">       3499 :     if (!priv || !priv-&gt;scope)</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     426 </span><span class="lineCov">       3499 :     return priv-&gt;scope-&gt;IsContentXBLScope();</span>
<span class="lineNum">     427 </span>            : }
<a name="428"><span class="lineNum">     428 </span>            : </a>
<span class="lineNum">     429 </span>            : bool
<span class="lineNum">     430 </span><span class="lineCov">       3456 : IsInContentXBLScope(JSObject* obj)</span>
<span class="lineNum">     431 </span>            : {
<span class="lineNum">     432 </span><span class="lineCov">       3456 :     return IsContentXBLScope(js::GetObjectCompartment(obj));</span>
<span class="lineNum">     433 </span>            : }
<a name="434"><span class="lineNum">     434 </span>            : </a>
<span class="lineNum">     435 </span>            : bool
<span class="lineNum">     436 </span><span class="lineCov">       3716 : IsInAddonScope(JSObject* obj)</span>
<span class="lineNum">     437 </span>            : {
<span class="lineNum">     438 </span><span class="lineCov">       3716 :     return ObjectScope(obj)-&gt;IsAddonScope();</span>
<span class="lineNum">     439 </span>            : }
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            : bool
<span class="lineNum">     442 </span><span class="lineCov">         15 : IsUniversalXPConnectEnabled(JSCompartment* compartment)</span>
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span><span class="lineCov">         15 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     445 </span><span class="lineCov">         15 :     if (!priv)</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     447 </span><span class="lineCov">         15 :     return priv-&gt;universalXPConnectEnabled;</span>
<span class="lineNum">     448 </span>            : }
<a name="449"><span class="lineNum">     449 </span>            : </a>
<span class="lineNum">     450 </span>            : bool
<span class="lineNum">     451 </span><span class="lineCov">         57 : IsUniversalXPConnectEnabled(JSContext* cx)</span>
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span><span class="lineCov">         57 :     JSCompartment* compartment = js::GetContextCompartment(cx);</span>
<span class="lineNum">     454 </span><span class="lineCov">         57 :     if (!compartment)</span>
<span class="lineNum">     455 </span><span class="lineCov">         45 :         return false;</span>
<span class="lineNum">     456 </span><span class="lineCov">         12 :     return IsUniversalXPConnectEnabled(compartment);</span>
<span class="lineNum">     457 </span>            : }
<a name="458"><span class="lineNum">     458 </span>            : </a>
<span class="lineNum">     459 </span>            : bool
<span class="lineNum">     460 </span><span class="lineCov">          3 : EnableUniversalXPConnect(JSContext* cx)</span>
<span class="lineNum">     461 </span>            : {
<span class="lineNum">     462 </span><span class="lineCov">          3 :     JSCompartment* compartment = js::GetContextCompartment(cx);</span>
<span class="lineNum">     463 </span><span class="lineCov">          3 :     if (!compartment)</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     465 </span>            :     // Never set universalXPConnectEnabled on a chrome compartment - it confuses
<span class="lineNum">     466 </span>            :     // the security wrapping code.
<span class="lineNum">     467 </span><span class="lineCov">          3 :     if (AccessCheck::isChrome(compartment))</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     469 </span><span class="lineCov">          3 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     470 </span><span class="lineCov">          3 :     if (!priv)</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     472 </span><span class="lineCov">          3 :     if (priv-&gt;universalXPConnectEnabled)</span>
<span class="lineNum">     473 </span><span class="lineCov">          2 :         return true;</span>
<span class="lineNum">     474 </span><span class="lineCov">          1 :     priv-&gt;universalXPConnectEnabled = true;</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :     // Recompute all the cross-compartment wrappers leaving the newly-privileged
<span class="lineNum">     477 </span>            :     // compartment.
<span class="lineNum">     478 </span><span class="lineCov">          2 :     bool ok = js::RecomputeWrappers(cx, js::SingleCompartment(compartment),</span>
<span class="lineNum">     479 </span><span class="lineCov">          3 :                                     js::AllCompartments());</span>
<span class="lineNum">     480 </span><span class="lineCov">          1 :     NS_ENSURE_TRUE(ok, false);</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     // The Components object normally isn't defined for unprivileged web content,
<span class="lineNum">     483 </span>            :     // but we define it when UniversalXPConnect is enabled to support legacy
<span class="lineNum">     484 </span>            :     // tests.
<span class="lineNum">     485 </span><span class="lineCov">          1 :     XPCWrappedNativeScope* scope = priv-&gt;scope;</span>
<span class="lineNum">     486 </span><span class="lineCov">          1 :     if (!scope)</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">     488 </span><span class="lineCov">          1 :     scope-&gt;ForcePrivilegedComponents();</span>
<span class="lineNum">     489 </span><span class="lineCov">          1 :     return scope-&gt;AttachComponentsObject(cx);</span>
<span class="lineNum">     490 </span>            : }
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : JSObject*
<span class="lineNum">     493 </span><span class="lineCov">        284 : UnprivilegedJunkScope()</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineCov">        284 :     return XPCJSRuntime::Get()-&gt;UnprivilegedJunkScope();</span>
<span class="lineNum">     496 </span>            : }
<a name="497"><span class="lineNum">     497 </span>            : </a>
<span class="lineNum">     498 </span>            : JSObject*
<span class="lineNum">     499 </span><span class="lineCov">         66 : PrivilegedJunkScope()</span>
<span class="lineNum">     500 </span>            : {
<span class="lineNum">     501 </span><span class="lineCov">         66 :     return XPCJSRuntime::Get()-&gt;PrivilegedJunkScope();</span>
<span class="lineNum">     502 </span>            : }
<a name="503"><span class="lineNum">     503 </span>            : </a>
<span class="lineNum">     504 </span>            : JSObject*
<span class="lineNum">     505 </span><span class="lineCov">       3774 : CompilationScope()</span>
<span class="lineNum">     506 </span>            : {
<span class="lineNum">     507 </span><span class="lineCov">       3774 :     return XPCJSRuntime::Get()-&gt;CompilationScope();</span>
<span class="lineNum">     508 </span>            : }
<a name="509"><span class="lineNum">     509 </span>            : </a>
<span class="lineNum">     510 </span>            : nsGlobalWindow*
<span class="lineNum">     511 </span><span class="lineCov">       1453 : WindowOrNull(JSObject* aObj)</span>
<span class="lineNum">     512 </span>            : {
<span class="lineNum">     513 </span><span class="lineCov">       1453 :     MOZ_ASSERT(aObj);</span>
<span class="lineNum">     514 </span><span class="lineCov">       1453 :     MOZ_ASSERT(!js::IsWrapper(aObj));</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">       1453 :     nsGlobalWindow* win = nullptr;</span>
<span class="lineNum">     517 </span><span class="lineCov">       1453 :     UNWRAP_NON_WRAPPER_OBJECT(Window, aObj, win);</span>
<span class="lineNum">     518 </span><span class="lineCov">       1453 :     return win;</span>
<span class="lineNum">     519 </span>            : }
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            : nsGlobalWindow*
<span class="lineNum">     522 </span><span class="lineCov">       1011 : WindowGlobalOrNull(JSObject* aObj)</span>
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span><span class="lineCov">       1011 :     MOZ_ASSERT(aObj);</span>
<span class="lineNum">     525 </span><span class="lineCov">       1011 :     JSObject* glob = js::GetGlobalForObjectCrossCompartment(aObj);</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">       1011 :     return WindowOrNull(glob);</span>
<span class="lineNum">     528 </span>            : }
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            : nsGlobalWindow*
<span class="lineNum">     531 </span><span class="lineCov">          2 : AddonWindowOrNull(JSObject* aObj)</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span><span class="lineCov">          2 :     if (!IsInAddonScope(aObj))</span>
<span class="lineNum">     534 </span><span class="lineCov">          2 :         return nullptr;</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     JSObject* global = js::GetGlobalForObjectCrossCompartment(aObj);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     JSObject* proto = js::GetPrototypeNoProxy(global);</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :     // Addons could theoretically change the prototype of the addon scope, but
<span class="lineNum">     540 </span>            :     // we pretty much just want to crash if that happens so that we find out
<span class="lineNum">     541 </span>            :     // about it and get them to change their code.
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(js::IsCrossCompartmentWrapper(proto) ||</span>
<span class="lineNum">     543 </span>            :                        xpc::IsSandboxPrototypeProxy(proto));
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     JSObject* mainGlobal = js::UncheckedUnwrap(proto, /* stopAtWindowProxy = */ false);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(JS_IsGlobalObject(mainGlobal));</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     return WindowOrNull(mainGlobal);</span>
<span class="lineNum">     548 </span>            : }
<a name="549"><span class="lineNum">     549 </span>            : </a>
<span class="lineNum">     550 </span>            : nsGlobalWindow*
<span class="lineNum">     551 </span><span class="lineNoCov">          0 : CurrentWindowOrNull(JSContext* cx)</span>
<span class="lineNum">     552 </span>            : {
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     JSObject* glob = JS::CurrentGlobalOrNull(cx);</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :     return glob ? WindowOrNull(glob) : nullptr;</span>
<span class="lineNum">     555 </span>            : }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : // Nukes all wrappers into or out of the given compartment, and prevents new
<span class="lineNum">     558 </span>            : // wrappers from being created. Additionally marks the compartment as
<span class="lineNum">     559 </span>            : // unscriptable after wrappers have been nuked.
<span class="lineNum">     560 </span>            : //
<span class="lineNum">     561 </span>            : // Note: This should *only* be called for browser or extension compartments.
<span class="lineNum">     562 </span>            : // Wrappers between web compartments must never be cut in web-observable
<a name="563"><span class="lineNum">     563 </span>            : // ways.</a>
<span class="lineNum">     564 </span>            : void
<span class="lineNum">     565 </span><span class="lineNoCov">          0 : NukeAllWrappersForCompartment(JSContext* cx, JSCompartment* compartment,</span>
<span class="lineNum">     566 </span>            :                               js::NukeReferencesToWindow nukeReferencesToWindow)
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span>            :     // First, nuke all wrappers into or out of the target compartment. Once
<span class="lineNum">     569 </span>            :     // the compartment is marked as nuked, WrapperFactory will refuse to
<span class="lineNum">     570 </span>            :     // create new live wrappers for it, in either direction. This means that
<span class="lineNum">     571 </span>            :     // we need to be sure that we don't have any existing cross-compartment
<span class="lineNum">     572 </span>            :     // wrappers which may be replaced with dead wrappers during unrelated
<span class="lineNum">     573 </span>            :     // wrapper recomputation *before* we set that bit.
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     js::NukeCrossCompartmentWrappers(cx, js::AllCompartments(), compartment,</span>
<span class="lineNum">     575 </span>            :                                      nukeReferencesToWindow,
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :                                      js::NukeAllReferences);</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :     // At this point, we should cross-compartment wrappers for the nuked
<span class="lineNum">     579 </span>            :     // compartment. Set the wasNuked bit so WrapperFactory will return a
<span class="lineNum">     580 </span>            :     // DeadObjectProxy when asked to create a new wrapper for it, and mark as
<span class="lineNum">     581 </span>            :     // unscriptable.
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :     auto compartmentPrivate = xpc::CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :     compartmentPrivate-&gt;wasNuked = true;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :     compartmentPrivate-&gt;scriptability.Block();</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : } // namespace xpc
<a name="588"><span class="lineNum">     588 </span>            : </a>
<span class="lineNum">     589 </span>            : static void
<span class="lineNum">     590 </span><span class="lineNoCov">          0 : CompartmentDestroyedCallback(JSFreeOp* fop, JSCompartment* compartment)</span>
<span class="lineNum">     591 </span>            : {
<span class="lineNum">     592 </span>            :     // NB - This callback may be called in JS_DestroyContext, which happens
<span class="lineNum">     593 </span>            :     // after the XPCJSRuntime has been torn down.
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :     // Get the current compartment private into an AutoPtr (which will do the
<span class="lineNum">     596 </span>            :     // cleanup for us), and null out the private (which may already be null).
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     nsAutoPtr&lt;CompartmentPrivate&gt; priv(CompartmentPrivate::Get(compartment));</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :     JS_SetCompartmentPrivate(compartment, nullptr);</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : }</span>
<a name="600"><span class="lineNum">     600 </span>            : </a>
<span class="lineNum">     601 </span>            : static size_t
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : CompartmentSizeOfIncludingThisCallback(MallocSizeOf mallocSizeOf, JSCompartment* compartment)</span>
<span class="lineNum">     603 </span>            : {
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     CompartmentPrivate* priv = CompartmentPrivate::Get(compartment);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     return priv ? priv-&gt;SizeOfIncludingThis(mallocSizeOf) : 0;</span>
<span class="lineNum">     606 </span>            : }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : /*
<span class="lineNum">     609 </span>            :  * Return true if there exists a non-system inner window which is a current
<span class="lineNum">     610 </span>            :  * inner window and whose reflector is gray.  We don't merge system
<a name="611"><span class="lineNum">     611 </span>            :  * compartments, so we don't use them to trigger merging CCs.</a>
<span class="lineNum">     612 </span>            :  */
<span class="lineNum">     613 </span><span class="lineNoCov">          0 : bool XPCJSRuntime::UsefulToMergeZones() const</span>
<span class="lineNum">     614 </span>            : {
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(NS_IsMainThread());</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :     // Turns out, actually making this return true often enough makes Windows
<span class="lineNum">     618 </span>            :     // mochitest-gl OOM a lot.  Need to figure out what's going on there; see
<span class="lineNum">     619 </span>            :     // bug 1277036.
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     return false;</span>
<a name="622"><span class="lineNum">     622 </span>            : }</a>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineCov">          1 : void XPCJSRuntime::TraceNativeBlackRoots(JSTracer* trc)</span>
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span><span class="lineCov">          2 :     for (CycleCollectedJSContext* ccx : Contexts()) {</span>
<span class="lineNum">     627 </span><span class="lineCov">          1 :         auto* cx = static_cast&lt;const XPCJSContext*&gt;(ccx);</span>
<span class="lineNum">     628 </span><span class="lineCov">          1 :         if (AutoMarkingPtr* roots = cx-&gt;mAutoRoots)</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             roots-&gt;TraceJSAll(trc);</span>
<span class="lineNum">     630 </span>            :     }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">          1 :     JSContext* cx = XPCJSContext::Get()-&gt;Context();</span>
<span class="lineNum">     633 </span><span class="lineCov">          1 :     dom::TraceBlackJS(trc, JS_GetGCParameter(cx, JSGC_NUMBER),</span>
<span class="lineNum">     634 </span><span class="lineCov">          2 :                       nsXPConnect::XPConnect()-&gt;IsShuttingDown());</span>
<a name="635"><span class="lineNum">     635 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">          1 : void XPCJSRuntime::TraceAdditionalNativeGrayRoots(JSTracer* trc)</span>
<span class="lineNum">     638 </span>            : {
<span class="lineNum">     639 </span><span class="lineCov">          1 :     XPCWrappedNativeScope::TraceWrappedNativesInAllScopes(trc);</span>
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineCov">          3 :     for (XPCRootSetElem* e = mVariantRoots; e ; e = e-&gt;GetNextRoot())</span>
<span class="lineNum">     642 </span><span class="lineCov">          2 :         static_cast&lt;XPCTraceableVariant*&gt;(e)-&gt;TraceJS(trc);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineCov">        480 :     for (XPCRootSetElem* e = mWrappedJSRoots; e ; e = e-&gt;GetNextRoot())</span>
<span class="lineNum">     645 </span><span class="lineCov">        479 :         static_cast&lt;nsXPCWrappedJS*&gt;(e)-&gt;TraceJS(trc);</span>
<span class="lineNum">     646 </span><span class="lineCov">          1 : }</span>
<a name="647"><span class="lineNum">     647 </span>            : </a>
<span class="lineNum">     648 </span>            : void
<span class="lineNum">     649 </span><span class="lineNoCov">          0 : XPCJSRuntime::TraverseAdditionalNativeRoots(nsCycleCollectionNoteRootCallback&amp; cb)</span>
<span class="lineNum">     650 </span>            : {
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::SuspectAllWrappers(cb);</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     for (XPCRootSetElem* e = mVariantRoots; e ; e = e-&gt;GetNextRoot()) {</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :         XPCTraceableVariant* v = static_cast&lt;XPCTraceableVariant*&gt;(e);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :         if (nsCCUncollectableMarker::InGeneration(cb,</span>
<span class="lineNum">     656 </span>            :                                                   v-&gt;CCGeneration())) {
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :            JS::Value val = v-&gt;GetJSValPreserveColor();</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :            if (val.isObject() &amp;&amp; !JS::ObjectIsMarkedGray(&amp;val.toObject()))</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                continue;</span>
<span class="lineNum">     660 </span>            :         }
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         cb.NoteXPCOMRoot(v);</span>
<span class="lineNum">     662 </span>            :     }
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     for (XPCRootSetElem* e = mWrappedJSRoots; e ; e = e-&gt;GetNextRoot()) {</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         cb.NoteXPCOMRoot(ToSupports(static_cast&lt;nsXPCWrappedJS*&gt;(e)));</span>
<span class="lineNum">     666 </span>            :     }
<span class="lineNum">     667 </span><span class="lineNoCov">          0 : }</span>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<span class="lineNum">     669 </span>            : void
<span class="lineNum">     670 </span><span class="lineNoCov">          0 : XPCJSRuntime::UnmarkSkippableJSHolders()</span>
<span class="lineNum">     671 </span>            : {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :     CycleCollectedJSRuntime::UnmarkSkippableJSHolders();</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 : }</span>
<a name="674"><span class="lineNum">     674 </span>            : </a>
<span class="lineNum">     675 </span>            : void
<span class="lineNum">     676 </span><span class="lineNoCov">          0 : XPCJSRuntime::PrepareForForgetSkippable()</span>
<span class="lineNum">     677 </span>            : {
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-forget-skippable&quot;, nullptr);</span>
<span class="lineNum">     681 </span>            :     }
<span class="lineNum">     682 </span><span class="lineNoCov">          0 : }</span>
<a name="683"><span class="lineNum">     683 </span>            : </a>
<span class="lineNum">     684 </span>            : void
<span class="lineNum">     685 </span><span class="lineNoCov">          0 : XPCJSRuntime::BeginCycleCollectionCallback()</span>
<span class="lineNum">     686 </span>            : {
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     nsJSContext::BeginCycleCollectionCallback();</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-begin&quot;, nullptr);</span>
<span class="lineNum">     692 </span>            :     }
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : }</span>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<span class="lineNum">     695 </span>            : void
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : XPCJSRuntime::EndCycleCollectionCallback(CycleCollectorResults&amp; aResults)</span>
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     nsJSContext::EndCycleCollectionCallback(aResults);</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; obs = mozilla::services::GetObserverService();</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     if (obs) {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         obs-&gt;NotifyObservers(nullptr, &quot;cycle-collector-end&quot;, nullptr);</span>
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span><span class="lineNoCov">          0 : }</span>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<span class="lineNum">     706 </span>            : void
<span class="lineNum">     707 </span><span class="lineCov">          3 : XPCJSRuntime::DispatchDeferredDeletion(bool aContinuation, bool aPurge)</span>
<span class="lineNum">     708 </span>            : {
<span class="lineNum">     709 </span><span class="lineCov">          3 :     mAsyncSnowWhiteFreer-&gt;Start(aContinuation, aPurge);</span>
<span class="lineNum">     710 </span><span class="lineCov">          3 : }</span>
<a name="711"><span class="lineNum">     711 </span>            : </a>
<span class="lineNum">     712 </span>            : void
<span class="lineNum">     713 </span><span class="lineNoCov">          0 : xpc_UnmarkSkippableJSHolders()</span>
<span class="lineNum">     714 </span>            : {
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :     if (nsXPConnect::GetRuntimeInstance()) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :         nsXPConnect::GetRuntimeInstance()-&gt;UnmarkSkippableJSHolders();</span>
<span class="lineNum">     717 </span>            :     }
<span class="lineNum">     718 </span><span class="lineNoCov">          0 : }</span>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<span class="lineNum">     720 </span>            : /* static */ void
<span class="lineNum">     721 </span><span class="lineCov">          7 : XPCJSRuntime::GCSliceCallback(JSContext* cx,</span>
<span class="lineNum">     722 </span>            :                               JS::GCProgress progress,
<span class="lineNum">     723 </span>            :                               const JS::GCDescription&amp; desc)
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineCov">          7 :     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();</span>
<span class="lineNum">     726 </span><span class="lineCov">          7 :     if (!self)</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : #ifdef MOZ_CRASHREPORTER
<span class="lineNum">     730 </span><span class="lineCov">          7 :     CrashReporter::SetGarbageCollecting(progress == JS::GC_CYCLE_BEGIN);</span>
<span class="lineNum">     731 </span>            : #endif
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">          7 :     if (self-&gt;mPrevGCSliceCallback)</span>
<span class="lineNum">     734 </span><span class="lineCov">          7 :         (*self-&gt;mPrevGCSliceCallback)(cx, progress, desc);</span>
<span class="lineNum">     735 </span>            : }
<a name="736"><span class="lineNum">     736 </span>            : </a>
<span class="lineNum">     737 </span>            : /* static */ void
<span class="lineNum">     738 </span><span class="lineNoCov">          0 : XPCJSRuntime::DoCycleCollectionCallback(JSContext* cx)</span>
<span class="lineNum">     739 </span>            : {
<span class="lineNum">     740 </span>            :     // The GC has detected that a CC at this point would collect a tremendous
<span class="lineNum">     741 </span>            :     // amount of garbage that is being revivified unnecessarily.
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 :     NS_DispatchToCurrentThread(</span></a>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :       NS_NewRunnableFunction(&quot;XPCJSRuntime::DoCycleCollectionCallback&quot;,</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                              []() { nsJSContext::CycleCollectNow(nullptr); }));</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if (!self)</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     if (self-&gt;mPrevDoCycleCollectionCallback)</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         (*self-&gt;mPrevDoCycleCollectionCallback)(cx);</span>
<span class="lineNum">     752 </span>            : }
<a name="753"><span class="lineNum">     753 </span>            : </a>
<span class="lineNum">     754 </span>            : void
<span class="lineNum">     755 </span><span class="lineCov">          1 : XPCJSRuntime::CustomGCCallback(JSGCStatus status)</span>
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span><span class="lineCov">          2 :     nsTArray&lt;xpcGCCallback&gt; callbacks(extraGCCallbacks);</span>
<span class="lineNum">     758 </span><span class="lineCov">          1 :     for (uint32_t i = 0; i &lt; callbacks.Length(); ++i)</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         callbacks[i](status);</span>
<span class="lineNum">     760 </span><span class="lineCov">          1 : }</span>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<span class="lineNum">     762 </span>            : /* static */ void
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : XPCJSRuntime::FinalizeCallback(JSFreeOp* fop,</span>
<span class="lineNum">     764 </span>            :                                JSFinalizeStatus status,
<span class="lineNum">     765 </span>            :                                bool isZoneGC,
<span class="lineNum">     766 </span>            :                                void* data)
<span class="lineNum">     767 </span>            : {
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :     if (!self)</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     switch (status) {</span>
<span class="lineNum">     773 </span>            :         case JSFINALIZE_GROUP_PREPARE:
<span class="lineNum">     774 </span>            :         {
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(!self-&gt;mDoingFinalization, &quot;bad state&quot;);</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(!self-&gt;mGCIsRunning, &quot;bad state&quot;);</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :             self-&gt;mGCIsRunning = true;</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :             self-&gt;mDoingFinalization = true;</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     783 </span>            :         }
<span class="lineNum">     784 </span>            :         case JSFINALIZE_GROUP_START:
<span class="lineNum">     785 </span>            :         {
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(self-&gt;mDoingFinalization, &quot;bad state&quot;);</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(self-&gt;mGCIsRunning, &quot;bad state&quot;);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :             self-&gt;mGCIsRunning = false;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     792 </span>            :         }
<span class="lineNum">     793 </span>            :         case JSFINALIZE_GROUP_END:
<span class="lineNum">     794 </span>            :         {
<span class="lineNum">     795 </span>            :             // Sweep scopes needing cleanup
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :             XPCWrappedNativeScope::KillDyingScopes();</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(self-&gt;mDoingFinalization, &quot;bad state&quot;);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :             self-&gt;mDoingFinalization = false;</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span>            :         case JSFINALIZE_COLLECTION_END:
<span class="lineNum">     804 </span>            :         {
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(!self-&gt;mGCIsRunning, &quot;bad state&quot;);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :             self-&gt;mGCIsRunning = true;</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :             for (CycleCollectedJSContext* ccx : self-&gt;Contexts()) {</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                 auto* cx = static_cast&lt;const XPCJSContext*&gt;(ccx);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :                 if (AutoMarkingPtr* roots = cx-&gt;mAutoRoots)</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                     roots-&gt;MarkAfterJSFinalizeAll();</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :                 // Now we are going to recycle any unused WrappedNativeTearoffs.
<span class="lineNum">     814 </span>            :                 // We do this by iterating all the live callcontexts
<span class="lineNum">     815 </span>            :                 // and marking the tearoffs in use. And then we
<span class="lineNum">     816 </span>            :                 // iterate over all the WrappedNative wrappers and sweep their
<span class="lineNum">     817 </span>            :                 // tearoffs.
<span class="lineNum">     818 </span>            :                 //
<span class="lineNum">     819 </span>            :                 // This allows us to perhaps minimize the growth of the
<span class="lineNum">     820 </span>            :                 // tearoffs. And also makes us not hold references to interfaces
<span class="lineNum">     821 </span>            :                 // on our wrapped natives that we are not actually using.
<span class="lineNum">     822 </span>            :                 //
<span class="lineNum">     823 </span>            :                 // XXX We may decide to not do this on *every* gc cycle.
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                 XPCCallContext* ccxp = cx-&gt;GetCallContext();</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 while (ccxp) {</span>
<span class="lineNum">     827 </span>            :                     // Deal with the strictness of callcontext that
<span class="lineNum">     828 </span>            :                     // complains if you ask for a tearoff when
<span class="lineNum">     829 </span>            :                     // it is in a state where the tearoff could not
<span class="lineNum">     830 </span>            :                     // possibly be valid.
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                     if (ccxp-&gt;CanGetTearOff()) {</span>
<span class="lineNum">     832 </span>            :                         XPCWrappedNativeTearOff* to =
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :                             ccxp-&gt;GetTearOff();</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                         if (to)</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                             to-&gt;Mark();</span>
<span class="lineNum">     836 </span>            :                     }
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :                     ccxp = ccxp-&gt;GetPrevCallContext();</span>
<span class="lineNum">     838 </span>            :                 }
<span class="lineNum">     839 </span>            :             }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :             XPCWrappedNativeScope::SweepAllWrappedNativeTearOffs();</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :             // Now we need to kill the 'Dying' XPCWrappedNativeProtos.
<span class="lineNum">     844 </span>            :             // We transfered these native objects to this table when their
<span class="lineNum">     845 </span>            :             // JSObject's were finalized. We did not destroy them immediately
<span class="lineNum">     846 </span>            :             // at that point because the ordering of JS finalization is not
<span class="lineNum">     847 </span>            :             // deterministic and we did not yet know if any wrappers that
<span class="lineNum">     848 </span>            :             // might still be referencing the protos where still yet to be
<span class="lineNum">     849 </span>            :             // finalized and destroyed. We *do* know that the protos'
<span class="lineNum">     850 </span>            :             // JSObjects would not have been finalized if there were any
<span class="lineNum">     851 </span>            :             // wrappers that referenced the proto but where not themselves
<span class="lineNum">     852 </span>            :             // slated for finalization in this gc cycle. So... at this point
<span class="lineNum">     853 </span>            :             // we know that any and all wrappers that might have been
<span class="lineNum">     854 </span>            :             // referencing the protos in the dying list are themselves dead.
<span class="lineNum">     855 </span>            :             // So, we can safely delete all the protos in the list.
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :             for (auto i = self-&gt;mDyingWrappedNativeProtoMap-&gt;Iter(); !i.Done(); i.Next()) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                 auto entry = static_cast&lt;XPCWrappedNativeProtoMap::Entry*&gt;(i.Get());</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                 delete static_cast&lt;const XPCWrappedNativeProto*&gt;(entry-&gt;key);</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :                 i.Remove();</span>
<span class="lineNum">     861 </span>            :             }
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(self-&gt;mGCIsRunning, &quot;bad state&quot;);</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :             self-&gt;mGCIsRunning = false;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     867 </span>            :         }
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            : }
<a name="870"><span class="lineNum">     870 </span>            : </a>
<span class="lineNum">     871 </span>            : /* static */ void
<span class="lineNum">     872 </span><span class="lineNoCov">          0 : XPCJSRuntime::WeakPointerZonesCallback(JSContext* cx, void* data)</span>
<span class="lineNum">     873 </span>            : {
<span class="lineNum">     874 </span>            :     // Called before each sweeping slice -- after processing any final marking
<span class="lineNum">     875 </span>            :     // triggered by barriers -- to clear out any references to things that are
<span class="lineNum">     876 </span>            :     // about to be finalized and update any pointers to moved GC things.
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     XPCJSRuntime* self = static_cast&lt;XPCJSRuntime*&gt;(data);</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     self-&gt;mWrappedJSMap-&gt;UpdateWeakPointersAfterGC();</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::UpdateWeakPointersInAllScopesAfterGC();</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : }</span>
<a name="883"><span class="lineNum">     883 </span>            : </a>
<span class="lineNum">     884 </span>            : /* static */ void
<span class="lineNum">     885 </span><span class="lineNoCov">          0 : XPCJSRuntime::WeakPointerCompartmentCallback(JSContext* cx, JSCompartment* comp, void* data)</span>
<span class="lineNum">     886 </span>            : {
<span class="lineNum">     887 </span>            :     // Called immediately after the ZoneGroup weak pointer callback, but only
<span class="lineNum">     888 </span>            :     // once for each compartment that is being swept.
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     CompartmentPrivate* xpcComp = CompartmentPrivate::Get(comp);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     if (xpcComp)</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         xpcComp-&gt;UpdateWeakPointersAfterGC();</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 : }</span>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<span class="lineNum">     894 </span>            : void
<span class="lineNum">     895 </span><span class="lineNoCov">          0 : CompartmentPrivate::UpdateWeakPointersAfterGC()</span>
<span class="lineNum">     896 </span>            : {
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     mWrappedJSMap-&gt;UpdateWeakPointersAfterGC();</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 : }</span>
<a name="899"><span class="lineNum">     899 </span>            : </a>
<span class="lineNum">     900 </span>            : void
<span class="lineNum">     901 </span><span class="lineNoCov">          0 : XPCJSRuntime::CustomOutOfMemoryCallback()</span>
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     if (!Preferences::GetBool(&quot;memory.dump_reports_on_oom&quot;)) {</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     905 </span>            :     }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :     nsCOMPtr&lt;nsIMemoryInfoDumper&gt; dumper =
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :         do_GetService(&quot;@mozilla.org/memory-info-dumper;1&quot;);</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     if (!dumper) {</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     911 </span>            :     }
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     // If this fails, it fails silently.
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     dumper-&gt;DumpMemoryInfoToTempDir(NS_LITERAL_STRING(&quot;due-to-JS-OOM&quot;),</span>
<span class="lineNum">     915 </span>            :                                     /* anonymize = */ false,
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                                     /* minimizeMemoryUsage = */ false);</span>
<span class="lineNum">     917 </span>            : }
<a name="918"><span class="lineNum">     918 </span>            : </a>
<span class="lineNum">     919 </span>            : void
<span class="lineNum">     920 </span><span class="lineNoCov">          0 : XPCJSRuntime::OnLargeAllocationFailure()</span>
<span class="lineNum">     921 </span>            : {
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     CycleCollectedJSRuntime::SetLargeAllocationFailure(OOMState::Reporting);</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIObserverService&gt; os = mozilla::services::GetObserverService();</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     if (os) {</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :         os-&gt;NotifyObservers(nullptr, &quot;memory-pressure&quot;, u&quot;heap-minimize&quot;);</span>
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     CycleCollectedJSRuntime::SetLargeAllocationFailure(OOMState::Reported);</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : class LargeAllocationFailureRunnable final : public Runnable
<span class="lineNum">     933 </span>            : {
<span class="lineNum">     934 </span>            :     Mutex mMutex;
<span class="lineNum">     935 </span>            :     CondVar mCondVar;
<a name="936"><span class="lineNum">     936 </span>            :     bool mWaiting;</a>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     virtual ~LargeAllocationFailureRunnable()</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!mWaiting);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     }</span>
<a name="942"><span class="lineNum">     942 </span>            : </a>
<span class="lineNum">     943 </span>            :   protected:
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     NS_IMETHOD Run() override</span>
<span class="lineNum">     945 </span>            :     {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(NS_IsMainThread());</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         XPCJSRuntime::Get()-&gt;OnLargeAllocationFailure();</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :         MutexAutoLock lock(mMutex);</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(mWaiting);</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :         mWaiting = false;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         mCondVar.Notify();</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">     956 </span>            :     }
<a name="957"><span class="lineNum">     957 </span>            : </a>
<span class="lineNum">     958 </span>            :   public:
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     LargeAllocationFailureRunnable()</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :       : mozilla::Runnable(&quot;LargeAllocationFailureRunnable&quot;)</span>
<span class="lineNum">     961 </span>            :       , mMutex(&quot;LargeAllocationFailureRunnable::mMutex&quot;)
<span class="lineNum">     962 </span>            :       , mCondVar(mMutex, &quot;LargeAllocationFailureRunnable::mCondVar&quot;)
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :       , mWaiting(true)</span>
<span class="lineNum">     964 </span>            :     {
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!NS_IsMainThread());</span>
<a name="966"><span class="lineNum">     966 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     void BlockUntilDone()</span>
<span class="lineNum">     969 </span>            :     {
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!NS_IsMainThread());</span>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         MutexAutoLock lock(mMutex);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         while (mWaiting) {</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :             mCondVar.Wait();</span>
<span class="lineNum">     975 </span>            :         }
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     977 </span>            : };
<a name="978"><span class="lineNum">     978 </span>            : </a>
<span class="lineNum">     979 </span>            : static void
<span class="lineNum">     980 </span><span class="lineNoCov">          0 : OnLargeAllocationFailureCallback()</span>
<span class="lineNum">     981 </span>            : {
<span class="lineNum">     982 </span>            :     // This callback can be called from any thread, including internal JS helper
<span class="lineNum">     983 </span>            :     // and DOM worker threads. We need to send the low-memory event via the
<span class="lineNum">     984 </span>            :     // observer service which can only be called on the main thread, so proxy to
<span class="lineNum">     985 </span>            :     // the main thread if we're not there already. The purpose of this callback
<span class="lineNum">     986 </span>            :     // is to synchronously free some memory so the caller can retry a failed
<span class="lineNum">     987 </span>            :     // allocation, so block on the completion.
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :     if (NS_IsMainThread()) {</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :         XPCJSRuntime::Get()-&gt;OnLargeAllocationFailure();</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     992 </span>            :     }
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     RefPtr&lt;LargeAllocationFailureRunnable&gt; r = new LargeAllocationFailureRunnable;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     if (NS_WARN_IF(NS_FAILED(NS_DispatchToMainThread(r)))) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     997 </span>            :     }
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     r-&gt;BlockUntilDone();</span>
<span class="lineNum">    1000 </span>            : }
<a name="1001"><span class="lineNum">    1001 </span>            : </a>
<span class="lineNum">    1002 </span>            : size_t
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 : XPCJSRuntime::SizeOfIncludingThis(MallocSizeOf mallocSizeOf)</span>
<span class="lineNum">    1004 </span>            : {
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     size_t n = 0;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :     n += mallocSizeOf(this);</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     n += mIID2NativeInterfaceMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     n += mClassInfo2NativeSetMap-&gt;ShallowSizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     n += mNativeSetMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     n += CycleCollectedJSRuntime::SizeOfExcludingThis(mallocSizeOf);</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     // There are other XPCJSRuntime members that could be measured; the above
<span class="lineNum">    1015 </span>            :     // ones have been seen by DMD to be worth measuring.  More stuff may be
<span class="lineNum">    1016 </span>            :     // added later.
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :     return n;</span>
<span class="lineNum">    1019 </span>            : }
<a name="1020"><span class="lineNum">    1020 </span>            : </a>
<span class="lineNum">    1021 </span>            : size_t
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 : CompartmentPrivate::SizeOfIncludingThis(MallocSizeOf mallocSizeOf)</span>
<span class="lineNum">    1023 </span>            : {
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :     size_t n = mallocSizeOf(this);</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfIncludingThis(mallocSizeOf);</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :     n += mWrappedJSMap-&gt;SizeOfWrappedJS(mallocSizeOf);</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     return n;</span>
<span class="lineNum">    1028 </span>            : }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : /***************************************************************************/
<a name="1031"><span class="lineNum">    1031 </span>            : </a>
<span class="lineNum">    1032 </span>            : void
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 : XPCJSRuntime::Shutdown(JSContext* cx)</span>
<span class="lineNum">    1034 </span>            : {
<span class="lineNum">    1035 </span>            :     // This destructor runs before ~CycleCollectedJSContext, which does the
<span class="lineNum">    1036 </span>            :     // actual JS_DestroyContext() call. But destroying the context triggers
<span class="lineNum">    1037 </span>            :     // one final GC, which can call back into the context with various
<span class="lineNum">    1038 </span>            :     // callbacks if we aren't careful. Null out the relevant callbacks.
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     JS_RemoveFinalizeCallback(cx, FinalizeCallback);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     JS_RemoveWeakPointerZonesCallback(cx, WeakPointerZonesCallback);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     JS_RemoveWeakPointerCompartmentCallback(cx, WeakPointerCompartmentCallback);</span>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     JS::SetGCSliceCallback(cx, mPrevGCSliceCallback);</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     // We don't want to track wrapped JS roots after this point since we're
<span class="lineNum">    1046 </span>            :     // making them !IsValid anyway through SystemIsBeingShutDown.
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     mWrappedJSRoots = nullptr;</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span>            :     // clean up and destroy maps...
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     mWrappedJSMap-&gt;ShutdownMarker();</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :     delete mWrappedJSMap;</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     mWrappedJSMap = nullptr;</span>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     delete mWrappedJSClassMap;</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     mWrappedJSClassMap = nullptr;</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     delete mIID2NativeInterfaceMap;</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     mIID2NativeInterfaceMap = nullptr;</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :     delete mClassInfo2NativeSetMap;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :     mClassInfo2NativeSetMap = nullptr;</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :     delete mNativeSetMap;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     mNativeSetMap = nullptr;</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :     delete mThisTranslatorMap;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     mThisTranslatorMap = nullptr;</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     delete mDyingWrappedNativeProtoMap;</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     mDyingWrappedNativeProtoMap = nullptr;</span>
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     CycleCollectedJSRuntime::Shutdown(cx);</span>
<a name="1073"><span class="lineNum">    1073 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 : XPCJSRuntime::~XPCJSRuntime()</span>
<span class="lineNum">    1076 </span>            : {
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :     MOZ_COUNT_DTOR_INHERITED(XPCJSRuntime, CycleCollectedJSRuntime);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            : // If |*anonymizeID| is non-zero and this is a user compartment, the name will
<a name="1081"><span class="lineNum">    1081 </span>            : // be anonymized.</a>
<span class="lineNum">    1082 </span>            : static void
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 : GetCompartmentName(JSCompartment* c, nsCString&amp; name, int* anonymizeID,</span>
<span class="lineNum">    1084 </span>            :                    bool replaceSlashes)
<span class="lineNum">    1085 </span>            : {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :     if (js::IsAtomsCompartment(c)) {</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;atoms&quot;);</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     } else if (*anonymizeID &amp;&amp; !js::IsSystemCompartment(c)) {</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         name.AppendPrintf(&quot;&lt;anonymized-%d&gt;&quot;, *anonymizeID);</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :         *anonymizeID += 1;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     } else if (JSPrincipals* principals = JS_GetCompartmentPrincipals(c)) {</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         nsresult rv = nsJSPrincipals::get(principals)-&gt;GetScriptLocation(name);</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :             name.AssignLiteral(&quot;(unknown)&quot;);</span>
<span class="lineNum">    1095 </span>            :         }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            :         // If the compartment's location (name) differs from the principal's
<span class="lineNum">    1098 </span>            :         // script location, append the compartment's location to allow
<span class="lineNum">    1099 </span>            :         // differentiation of multiple compartments owned by the same principal
<span class="lineNum">    1100 </span>            :         // (e.g. components owned by the system or null principal).
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         CompartmentPrivate* compartmentPrivate = CompartmentPrivate::Get(c);</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :         if (compartmentPrivate) {</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :             const nsACString&amp; location = compartmentPrivate-&gt;GetLocation();</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :             if (!location.IsEmpty() &amp;&amp; !location.Equals(name)) {</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                 name.AppendLiteral(&quot;, &quot;);</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                 name.Append(location);</span>
<span class="lineNum">    1107 </span>            :             }
<span class="lineNum">    1108 </span>            :         }
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :         if (*anonymizeID) {</span>
<span class="lineNum">    1111 </span>            :             // We might have a file:// URL that includes a path from the local
<span class="lineNum">    1112 </span>            :             // filesystem, which should be omitted if we're anonymizing.
<span class="lineNum">    1113 </span>            :             static const char* filePrefix = &quot;file://&quot;;
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :             int filePos = name.Find(filePrefix);</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :             if (filePos &gt;= 0) {</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                 int pathPos = filePos + strlen(filePrefix);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                 int lastSlashPos = -1;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :                 for (int i = pathPos; i &lt; int(name.Length()); i++) {</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :                     if (name[i] == '/' || name[i] == '\\') {</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                         lastSlashPos = i;</span>
<span class="lineNum">    1121 </span>            :                     }
<span class="lineNum">    1122 </span>            :                 }
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                 if (lastSlashPos != -1) {</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                     name.ReplaceASCII(pathPos, lastSlashPos - pathPos,</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                                       &quot;&lt;anonymized&gt;&quot;);</span>
<span class="lineNum">    1126 </span>            :                 } else {
<span class="lineNum">    1127 </span>            :                     // Something went wrong. Anonymize the entire path to be
<span class="lineNum">    1128 </span>            :                     // safe.
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                     name.Truncate(pathPos);</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                     name += &quot;&lt;anonymized?!&gt;&quot;;</span>
<span class="lineNum">    1131 </span>            :                 }
<span class="lineNum">    1132 </span>            :             }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :             // We might have a location like this:
<span class="lineNum">    1135 </span>            :             //   inProcessTabChildGlobal?ownedBy=http://www.example.com/
<span class="lineNum">    1136 </span>            :             // The owner should be omitted if it's not a chrome: URI and we're
<span class="lineNum">    1137 </span>            :             // anonymizing.
<span class="lineNum">    1138 </span>            :             static const char* ownedByPrefix =
<span class="lineNum">    1139 </span>            :                 &quot;inProcessTabChildGlobal?ownedBy=&quot;;
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :             int ownedByPos = name.Find(ownedByPrefix);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :             if (ownedByPos &gt;= 0) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 const char* chrome = &quot;chrome:&quot;;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 int ownerPos = ownedByPos + strlen(ownedByPrefix);</span>
<span class="lineNum">    1144 </span>            :                 const nsDependentCSubstring&amp; ownerFirstPart =
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                     Substring(name, ownerPos, strlen(chrome));</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                 if (!ownerFirstPart.EqualsASCII(chrome)) {</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                     name.Truncate(ownerPos);</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                     name += &quot;&lt;anonymized&gt;&quot;;</span>
<span class="lineNum">    1149 </span>            :                 }
<span class="lineNum">    1150 </span>            :             }
<span class="lineNum">    1151 </span>            :         }
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :         // A hack: replace forward slashes with '\\' so they aren't
<span class="lineNum">    1154 </span>            :         // treated as path separators.  Users of the reporters
<span class="lineNum">    1155 </span>            :         // (such as about:memory) have to undo this change.
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         if (replaceSlashes)</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :             name.ReplaceChar('/', '\\');</span>
<span class="lineNum">    1158 </span>            :     } else {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;null-principal&quot;);</span>
<span class="lineNum">    1160 </span>            :     }
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 : }</span>
<a name="1162"><span class="lineNum">    1162 </span>            : </a>
<span class="lineNum">    1163 </span>            : extern void
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 : xpc::GetCurrentCompartmentName(JSContext* cx, nsCString&amp; name)</span>
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :     RootedObject global(cx, JS::CurrentGlobalOrNull(cx));</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     if (!global) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         name.AssignLiteral(&quot;no global&quot;);</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1170 </span>            :     }
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     JSCompartment* compartment = GetObjectCompartment(global);</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     int anonymizeID = 0;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     GetCompartmentName(compartment, name, &amp;anonymizeID, false);</span>
<span class="lineNum">    1175 </span>            : }
<a name="1176"><span class="lineNum">    1176 </span>            : </a>
<span class="lineNum">    1177 </span>            : void
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 : xpc::AddGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    1179 </span>            : {
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     XPCJSRuntime::Get()-&gt;AddGCCallback(cb);</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : }</span>
<a name="1182"><span class="lineNum">    1182 </span>            : </a>
<span class="lineNum">    1183 </span>            : void
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 : xpc::RemoveGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    1185 </span>            : {
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     XPCJSRuntime::Get()-&gt;RemoveGCCallback(cb);</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 : }</span>
<a name="1188"><span class="lineNum">    1188 </span>            : </a>
<span class="lineNum">    1189 </span>            : static int64_t
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 : JSMainRuntimeGCHeapDistinguishedAmount()</span>
<span class="lineNum">    1191 </span>            : {
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :     return int64_t(JS_GetGCParameter(cx, JSGC_TOTAL_CHUNKS)) *</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :            js::gc::ChunkSize;</span>
<span class="lineNum">    1195 </span>            : }
<a name="1196"><span class="lineNum">    1196 </span>            : </a>
<span class="lineNum">    1197 </span>            : static int64_t
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 : JSMainRuntimeTemporaryPeakDistinguishedAmount()</span>
<span class="lineNum">    1199 </span>            : {
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :     return JS::PeakSizeOfTemporary(cx);</span>
<span class="lineNum">    1202 </span>            : }
<a name="1203"><span class="lineNum">    1203 </span>            : </a>
<span class="lineNum">    1204 </span>            : static int64_t
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 : JSMainRuntimeCompartmentsSystemDistinguishedAmount()</span>
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     JSContext* cx = danger::GetJSContext();</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     return JS::SystemCompartmentCount(cx);</span>
<span class="lineNum">    1209 </span>            : }
<a name="1210"><span class="lineNum">    1210 </span>            : </a>
<span class="lineNum">    1211 </span>            : static int64_t
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 : JSMainRuntimeCompartmentsUserDistinguishedAmount()</span>
<span class="lineNum">    1213 </span>            : {
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     JSContext* cx = XPCJSContext::Get()-&gt;Context();</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     return JS::UserCompartmentCount(cx);</span>
<a name="1216"><span class="lineNum">    1216 </span>            : }</a>
<span class="lineNum">    1217 </span>            : 
<a name="1218"><span class="lineNum">    1218 </span><span class="lineCov">          3 : class JSMainRuntimeTemporaryPeakReporter final : public nsIMemoryReporter</span></a>
<span class="lineNum">    1219 </span>            : {
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     ~JSMainRuntimeTemporaryPeakReporter() {}</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :   public:
<a name="1223"><span class="lineNum">    1223 </span>            :     NS_DECL_ISUPPORTS</a>
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     NS_IMETHOD CollectReports(nsIHandleReportCallback* aHandleReport,</span>
<span class="lineNum">    1226 </span>            :                               nsISupports* aData, bool aAnonymize) override
<span class="lineNum">    1227 </span>            :     {
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :         MOZ_COLLECT_REPORT(</span>
<span class="lineNum">    1229 </span>            :             &quot;js-main-runtime-temporary-peak&quot;, KIND_OTHER, UNITS_BYTES,
<span class="lineNum">    1230 </span>            :             JSMainRuntimeTemporaryPeakDistinguishedAmount(),
<span class="lineNum">    1231 </span>            :             &quot;Peak transient data size in the main JSRuntime (the current size &quot;
<span class="lineNum">    1232 </span>            :             &quot;of which is reported as &quot;
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             &quot;'explicit/js-non-window/runtime/temporary').&quot;);</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    1236 </span>            :     }
<a name="1237"><span class="lineNum">    1237 </span>            : };</a>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineCov">         39 : NS_IMPL_ISUPPORTS(JSMainRuntimeTemporaryPeakReporter, nsIMemoryReporter)</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : // The REPORT* macros do an unconditional report.  The ZCREPORT* macros are for
<span class="lineNum">    1242 </span>            : // compartments and zones; they aggregate any entries smaller than
<span class="lineNum">    1243 </span>            : // SUNDRIES_THRESHOLD into the &quot;sundries/gc-heap&quot; and &quot;sundries/malloc-heap&quot;
<span class="lineNum">    1244 </span>            : // entries for the compartment.
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            : #define SUNDRIES_THRESHOLD js::MemoryReportingSundriesThreshold()
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            : #define REPORT(_path, _kind, _units, _amount, _desc) \
<span class="lineNum">    1249 </span>            :     handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1250 </span>            :                            nsIMemoryReporter::_kind, \
<span class="lineNum">    1251 </span>            :                            nsIMemoryReporter::_units, _amount, \
<span class="lineNum">    1252 </span>            :                            NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span>            : #define REPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1255 </span>            :     REPORT(_path, _kind, UNITS_BYTES, _amount, _desc);
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            : #define REPORT_GC_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1258 </span>            :     do { \
<span class="lineNum">    1259 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1260 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1261 </span>            :                                nsIMemoryReporter::KIND_NONHEAP, \
<span class="lineNum">    1262 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1263 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1264 </span>            :         gcTotal += amount; \
<span class="lineNum">    1265 </span>            :     } while (0)
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            : // Report compartment/zone non-GC (KIND_HEAP) bytes.
<span class="lineNum">    1268 </span>            : #define ZCREPORT_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1269 </span>            :     do { \
<span class="lineNum">    1270 </span>            :         /* Assign _descLiteral plus &quot;&quot; into a char* to prove that it's */ \
<span class="lineNum">    1271 </span>            :         /* actually a literal. */ \
<span class="lineNum">    1272 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1273 </span>            :         if (amount &gt;= SUNDRIES_THRESHOLD) { \
<span class="lineNum">    1274 </span>            :             handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1275 </span>            :                                    nsIMemoryReporter::KIND_HEAP, \
<span class="lineNum">    1276 </span>            :                                    nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1277 </span>            :                                    NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1278 </span>            :         } else { \
<span class="lineNum">    1279 </span>            :             sundriesMallocHeap += amount; \
<span class="lineNum">    1280 </span>            :         } \
<span class="lineNum">    1281 </span>            :     } while (0)
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            : // Report compartment/zone GC bytes.
<span class="lineNum">    1284 </span>            : #define ZCREPORT_GC_BYTES(_path, _amount, _desc) \
<span class="lineNum">    1285 </span>            :     do { \
<span class="lineNum">    1286 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1287 </span>            :         if (amount &gt;= SUNDRIES_THRESHOLD) { \
<span class="lineNum">    1288 </span>            :             handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1289 </span>            :                                    nsIMemoryReporter::KIND_NONHEAP, \
<span class="lineNum">    1290 </span>            :                                    nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1291 </span>            :                                    NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1292 </span>            :             gcTotal += amount; \
<span class="lineNum">    1293 </span>            :         } else { \
<span class="lineNum">    1294 </span>            :             sundriesGCHeap += amount; \
<span class="lineNum">    1295 </span>            :         } \
<span class="lineNum">    1296 </span>            :     } while (0)
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : // Report runtime bytes.
<span class="lineNum">    1299 </span>            : #define RREPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1300 </span>            :     do { \
<span class="lineNum">    1301 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1302 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1303 </span>            :                                nsIMemoryReporter::_kind, \
<span class="lineNum">    1304 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1305 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1306 </span>            :         rtTotal += amount; \
<span class="lineNum">    1307 </span>            :     } while (0)
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : // Report GC thing bytes.
<span class="lineNum">    1310 </span>            : #define MREPORT_BYTES(_path, _kind, _amount, _desc) \
<span class="lineNum">    1311 </span>            :     do { \
<span class="lineNum">    1312 </span>            :         size_t amount = _amount;  /* evaluate _amount only once */ \
<span class="lineNum">    1313 </span>            :         handleReport-&gt;Callback(EmptyCString(), _path, \
<span class="lineNum">    1314 </span>            :                                nsIMemoryReporter::_kind, \
<span class="lineNum">    1315 </span>            :                                nsIMemoryReporter::UNITS_BYTES, amount, \
<span class="lineNum">    1316 </span>            :                                NS_LITERAL_CSTRING(_desc), data); \
<span class="lineNum">    1317 </span>            :         gcThingTotal += amount; \
<a name="1318"><span class="lineNum">    1318 </span>            :     } while (0)</a>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 : MOZ_DEFINE_MALLOC_SIZE_OF(JSMallocSizeOf)</span>
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            : namespace xpc {
<a name="1323"><span class="lineNum">    1323 </span>            : </a>
<span class="lineNum">    1324 </span>            : static void
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 : ReportZoneStats(const JS::ZoneStats&amp; zStats,</span>
<span class="lineNum">    1326 </span>            :                 const xpc::ZoneStatsExtras&amp; extras,
<span class="lineNum">    1327 </span>            :                 nsIHandleReportCallback* handleReport,
<span class="lineNum">    1328 </span>            :                 nsISupports* data,
<span class="lineNum">    1329 </span>            :                 bool anonymize,
<span class="lineNum">    1330 </span>            :                 size_t* gcTotalOut = nullptr)
<span class="lineNum">    1331 </span>            : {
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :     const nsCString&amp; pathPrefix = extras.pathPrefix;</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0, sundriesGCHeap = 0, sundriesMallocHeap = 0;</span>
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!gcTotalOut == zStats.isTotals);</span>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;symbols/gc-heap&quot;),</span>
<span class="lineNum">    1338 </span>            :         zStats.symbolsGCHeap,
<span class="lineNum">    1339 </span>            :         &quot;Symbols.&quot;);
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;gc-heap-arena-admin&quot;),</span>
<span class="lineNum">    1342 </span>            :         zStats.gcHeapArenaAdmin,
<span class="lineNum">    1343 </span>            :         &quot;Bookkeeping information and alignment padding within GC arenas.&quot;);
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;unused-gc-things&quot;),</span>
<span class="lineNum">    1346 </span>            :         zStats.unusedGCThings.totalSize(),
<span class="lineNum">    1347 </span>            :         &quot;Unused GC thing cells within non-empty arenas.&quot;);
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;unique-id-map&quot;),</span>
<span class="lineNum">    1350 </span>            :         zStats.uniqueIdMap,
<span class="lineNum">    1351 </span>            :         &quot;Address-independent cell identities.&quot;);
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shape-tables&quot;),</span>
<span class="lineNum">    1354 </span>            :         zStats.shapeTables,
<span class="lineNum">    1355 </span>            :         &quot;Tables storing shape information.&quot;);
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;lazy-scripts/gc-heap&quot;),</span>
<span class="lineNum">    1358 </span>            :         zStats.lazyScriptsGCHeap,
<span class="lineNum">    1359 </span>            :         &quot;Scripts that haven't executed yet.&quot;);
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;lazy-scripts/malloc-heap&quot;),</span>
<span class="lineNum">    1362 </span>            :         zStats.lazyScriptsMallocHeap,
<span class="lineNum">    1363 </span>            :         &quot;Lazy script tables containing closed-over bindings or inner functions.&quot;);
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;jit-codes-gc-heap&quot;),</span>
<span class="lineNum">    1366 </span>            :         zStats.jitCodesGCHeap,
<span class="lineNum">    1367 </span>            :         &quot;References to executable code pools used by the JITs.&quot;);
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;object-groups/gc-heap&quot;),</span>
<span class="lineNum">    1370 </span>            :         zStats.objectGroupsGCHeap,
<span class="lineNum">    1371 </span>            :         &quot;Classification and type inference information about objects.&quot;);
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;object-groups/malloc-heap&quot;),</span>
<span class="lineNum">    1374 </span>            :         zStats.objectGroupsMallocHeap,
<span class="lineNum">    1375 </span>            :         &quot;Object group addenda.&quot;);
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;scopes/gc-heap&quot;),</span>
<span class="lineNum">    1378 </span>            :         zStats.scopesGCHeap,
<span class="lineNum">    1379 </span>            :         &quot;Scope information for scripts.&quot;);
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;scopes/malloc-heap&quot;),</span>
<span class="lineNum">    1382 </span>            :         zStats.scopesMallocHeap,
<span class="lineNum">    1383 </span>            :         &quot;Arrays of binding names and other binding-related data.&quot;);
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;regexp-shareds/gc-heap&quot;),</span>
<span class="lineNum">    1386 </span>            :         zStats.regExpSharedsGCHeap,
<span class="lineNum">    1387 </span>            :         &quot;Shared compiled regexp data.&quot;);
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;regexp-shareds/malloc-heap&quot;),</span>
<span class="lineNum">    1390 </span>            :         zStats.regExpSharedsMallocHeap,
<span class="lineNum">    1391 </span>            :         &quot;Shared compiled regexp data.&quot;);
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;type-pool&quot;),</span>
<span class="lineNum">    1394 </span>            :         zStats.typePool,
<span class="lineNum">    1395 </span>            :         &quot;Type sets and related data.&quot;);
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;regexp-zone&quot;),</span>
<span class="lineNum">    1398 </span>            :         zStats.regexpZone,
<span class="lineNum">    1399 </span>            :         &quot;The regexp zone and regexp data.&quot;);
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;jit-zone&quot;),</span>
<span class="lineNum">    1402 </span>            :         zStats.jitZone,
<span class="lineNum">    1403 </span>            :         &quot;The JIT zone.&quot;);
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;baseline/optimized-stubs&quot;),</span>
<span class="lineNum">    1406 </span>            :         zStats.baselineStubsOptimized,
<span class="lineNum">    1407 </span>            :         &quot;The Baseline JIT's optimized IC stubs (excluding code).&quot;);
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;jit-cached-cfg&quot;),</span>
<span class="lineNum">    1410 </span>            :         zStats.cachedCFG,
<span class="lineNum">    1411 </span>            :         &quot;The cached CFG to construct Ion code out of it.&quot;);
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     size_t stringsNotableAboutMemoryGCHeap = 0;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     size_t stringsNotableAboutMemoryMallocHeap = 0;</span>
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span>            :     #define MAYBE_INLINE \
<span class="lineNum">    1417 </span>            :         &quot;The characters may be inline or on the malloc heap.&quot;
<span class="lineNum">    1418 </span>            :     #define MAYBE_OVERALLOCATED \
<span class="lineNum">    1419 </span>            :         &quot;Sometimes over-allocated to simplify string concatenation.&quot;
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; zStats.notableStrings.length(); i++) {</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         const JS::NotableStringInfo&amp; info = zStats.notableStrings[i];</span>
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!zStats.isTotals);</span>
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :         // We don't do notable string detection when anonymizing, because
<span class="lineNum">    1427 </span>            :         // there's a good chance its for crash submission, and the memory
<span class="lineNum">    1428 </span>            :         // required for notable string detection is high.
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!anonymize);</span>
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :         nsDependentCString notableString(info.buffer);</span>
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :         // Viewing about:memory generates many notable strings which contain
<span class="lineNum">    1434 </span>            :         // &quot;string(length=&quot;.  If we report these as notable, then we'll create
<span class="lineNum">    1435 </span>            :         // even more notable strings the next time we open about:memory (unless
<span class="lineNum">    1436 </span>            :         // there's a GC in the meantime), and so on ad infinitum.
<span class="lineNum">    1437 </span>            :         //
<span class="lineNum">    1438 </span>            :         // To avoid cluttering up about:memory like this, we stick notable
<span class="lineNum">    1439 </span>            :         // strings which contain &quot;string(length=&quot; into their own bucket.
<span class="lineNum">    1440 </span>            : #       define STRING_LENGTH &quot;string(length=&quot;
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :         if (FindInReadable(NS_LITERAL_CSTRING(STRING_LENGTH), notableString)) {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryGCHeap += info.gcHeapLatin1;</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryGCHeap += info.gcHeapTwoByte;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryMallocHeap += info.mallocHeapLatin1;</span>
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :             stringsNotableAboutMemoryMallocHeap += info.mallocHeapTwoByte;</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1447 </span>            :         }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            :         // Escape / to \ before we put notableString into the memory reporter
<span class="lineNum">    1450 </span>            :         // path, because we don't want any forward slashes in the string to
<span class="lineNum">    1451 </span>            :         // count as path separators.
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :         nsCString escapedString(notableString);</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :         escapedString.ReplaceSubstring(&quot;/&quot;, &quot;\\&quot;);</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :         bool truncated = notableString.Length() &lt; info.length;</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :         nsCString path = pathPrefix +</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :             nsPrintfCString(&quot;strings/&quot; STRING_LENGTH &quot;%&quot; PRIuSIZE &quot;, copies=%d, \&quot;%s\&quot;%s)/&quot;,</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                             info.length, info.numCopies, escapedString.get(),</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :                             truncated ? &quot; (truncated)&quot; : &quot;&quot;);</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         if (info.gcHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :             REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;gc-heap/latin1&quot;),</span>
<span class="lineNum">    1464 </span>            :                 info.gcHeapLatin1,
<span class="lineNum">    1465 </span>            :                 &quot;Latin1 strings. &quot; MAYBE_INLINE);
<span class="lineNum">    1466 </span>            :         }
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :         if (info.gcHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :             REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;gc-heap/two-byte&quot;),</span>
<span class="lineNum">    1470 </span>            :                 info.gcHeapTwoByte,
<span class="lineNum">    1471 </span>            :                 &quot;TwoByte strings. &quot; MAYBE_INLINE);
<span class="lineNum">    1472 </span>            :         }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         if (info.mallocHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :             REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;malloc-heap/latin1&quot;),</span>
<span class="lineNum">    1476 </span>            :                 KIND_HEAP, info.mallocHeapLatin1,
<span class="lineNum">    1477 </span>            :                 &quot;Non-inline Latin1 string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    1478 </span>            :         }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         if (info.mallocHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :             REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;malloc-heap/two-byte&quot;),</span>
<span class="lineNum">    1482 </span>            :                 KIND_HEAP, info.mallocHeapTwoByte,
<span class="lineNum">    1483 </span>            :                 &quot;Non-inline TwoByte string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    1484 </span>            :         }
<span class="lineNum">    1485 </span>            :     }
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :     nsCString nonNotablePath = pathPrefix;</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     nonNotablePath += (zStats.isTotals || anonymize)</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :                     ? NS_LITERAL_CSTRING(&quot;strings/&quot;)</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :                     : NS_LITERAL_CSTRING(&quot;strings/string(&lt;non-notable strings&gt;)/&quot;);</span>
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.gcHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;gc-heap/latin1&quot;),</span>
<span class="lineNum">    1494 </span>            :             zStats.stringInfo.gcHeapLatin1,
<span class="lineNum">    1495 </span>            :             &quot;Latin1 strings. &quot; MAYBE_INLINE);
<span class="lineNum">    1496 </span>            :     }
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.gcHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;gc-heap/two-byte&quot;),</span>
<span class="lineNum">    1500 </span>            :             zStats.stringInfo.gcHeapTwoByte,
<span class="lineNum">    1501 </span>            :             &quot;TwoByte strings. &quot; MAYBE_INLINE);
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.mallocHeapLatin1 &gt; 0) {</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :         REPORT_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;malloc-heap/latin1&quot;),</span>
<span class="lineNum">    1506 </span>            :             KIND_HEAP, zStats.stringInfo.mallocHeapLatin1,
<span class="lineNum">    1507 </span>            :             &quot;Non-inline Latin1 string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    1508 </span>            :     }
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :     if (zStats.stringInfo.mallocHeapTwoByte &gt; 0) {</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :         REPORT_BYTES(nonNotablePath + NS_LITERAL_CSTRING(&quot;malloc-heap/two-byte&quot;),</span>
<span class="lineNum">    1512 </span>            :             KIND_HEAP, zStats.stringInfo.mallocHeapTwoByte,
<span class="lineNum">    1513 </span>            :             &quot;Non-inline TwoByte string characters. &quot; MAYBE_OVERALLOCATED);
<span class="lineNum">    1514 </span>            :     }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :     if (stringsNotableAboutMemoryGCHeap &gt; 0) {</span>
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!zStats.isTotals);</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;strings/string(&lt;about-memory&gt;)/gc-heap&quot;),</span>
<span class="lineNum">    1519 </span>            :             stringsNotableAboutMemoryGCHeap,
<span class="lineNum">    1520 </span>            :             &quot;Strings that contain the characters '&quot; STRING_LENGTH &quot;', which &quot;
<span class="lineNum">    1521 </span>            :             &quot;are probably from about:memory itself.&quot; MAYBE_INLINE
<span class="lineNum">    1522 </span>            :             &quot; We filter them out rather than display them, because displaying &quot;
<span class="lineNum">    1523 </span>            :             &quot;them would create even more such strings every time about:memory &quot;
<span class="lineNum">    1524 </span>            :             &quot;is refreshed.&quot;);
<span class="lineNum">    1525 </span>            :     }
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     if (stringsNotableAboutMemoryMallocHeap &gt; 0) {</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!zStats.isTotals);</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;strings/string(&lt;about-memory&gt;)/malloc-heap&quot;),</span>
<span class="lineNum">    1530 </span>            :             KIND_HEAP, stringsNotableAboutMemoryMallocHeap,
<span class="lineNum">    1531 </span>            :             &quot;Non-inline string characters of strings that contain the &quot;
<span class="lineNum">    1532 </span>            :             &quot;characters '&quot; STRING_LENGTH &quot;', which are probably from &quot;
<span class="lineNum">    1533 </span>            :             &quot;about:memory itself. &quot; MAYBE_OVERALLOCATED
<span class="lineNum">    1534 </span>            :             &quot; We filter them out rather than display them, because displaying &quot;
<span class="lineNum">    1535 </span>            :             &quot;them would create even more such strings every time about:memory &quot;
<span class="lineNum">    1536 </span>            :             &quot;is refreshed.&quot;);
<span class="lineNum">    1537 </span>            :     }
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     const JS::ShapeInfo&amp; shapeInfo = zStats.shapeInfo;</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapTree &gt; 0) {</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/tree&quot;),</span>
<span class="lineNum">    1542 </span>            :             shapeInfo.shapesGCHeapTree,
<span class="lineNum">    1543 </span>            :         &quot;Shapes in a property tree.&quot;);
<span class="lineNum">    1544 </span>            :     }
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapDict &gt; 0) {</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/dict&quot;),</span>
<span class="lineNum">    1548 </span>            :             shapeInfo.shapesGCHeapDict,
<span class="lineNum">    1549 </span>            :         &quot;Shapes in dictionary mode.&quot;);
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesGCHeapBase &gt; 0) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/gc-heap/base&quot;),</span>
<span class="lineNum">    1554 </span>            :             shapeInfo.shapesGCHeapBase,
<span class="lineNum">    1555 </span>            :             &quot;Base shapes, which collate data common to many shapes.&quot;);
<span class="lineNum">    1556 </span>            :     }
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapTreeTables &gt; 0) {</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/tree-tables&quot;),</span>
<span class="lineNum">    1560 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapTreeTables,
<span class="lineNum">    1561 </span>            :             &quot;Property tables of shapes in a property tree.&quot;);
<span class="lineNum">    1562 </span>            :     }
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapDictTables &gt; 0) {</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/dict-tables&quot;),</span>
<span class="lineNum">    1566 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapDictTables,
<span class="lineNum">    1567 </span>            :             &quot;Property tables of shapes in dictionary mode.&quot;);
<span class="lineNum">    1568 </span>            :     }
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     if (shapeInfo.shapesMallocHeapTreeKids &gt; 0) {</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;shapes/malloc-heap/tree-kids&quot;),</span>
<span class="lineNum">    1572 </span>            :             KIND_HEAP, shapeInfo.shapesMallocHeapTreeKids,
<span class="lineNum">    1573 </span>            :             &quot;Kid hashes of shapes in a property tree.&quot;);
<span class="lineNum">    1574 </span>            :     }
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     if (sundriesGCHeap &gt; 0) {</span>
<span class="lineNum">    1577 </span>            :         // We deliberately don't use ZCREPORT_GC_BYTES here.
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;sundries/gc-heap&quot;),</span>
<span class="lineNum">    1579 </span>            :             sundriesGCHeap,
<span class="lineNum">    1580 </span>            :             &quot;The sum of all 'gc-heap' measurements that are too small to be &quot;
<span class="lineNum">    1581 </span>            :             &quot;worth showing individually.&quot;);
<span class="lineNum">    1582 </span>            :     }
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     if (sundriesMallocHeap &gt; 0) {</span>
<span class="lineNum">    1585 </span>            :         // We deliberately don't use ZCREPORT_BYTES here.
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :         REPORT_BYTES(pathPrefix + NS_LITERAL_CSTRING(&quot;sundries/malloc-heap&quot;),</span>
<span class="lineNum">    1587 </span>            :             KIND_HEAP, sundriesMallocHeap,
<span class="lineNum">    1588 </span>            :             &quot;The sum of all 'malloc-heap' measurements that are too small to &quot;
<span class="lineNum">    1589 </span>            :             &quot;be worth showing individually.&quot;);
<span class="lineNum">    1590 </span>            :     }
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     if (gcTotalOut)</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :         *gcTotalOut += gcTotal;</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            : #   undef STRING_LENGTH
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 : }</span>
<a name="1597"><span class="lineNum">    1597 </span>            : </a>
<span class="lineNum">    1598 </span>            : static void
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 : ReportClassStats(const ClassInfo&amp; classInfo, const nsACString&amp; path,</span>
<span class="lineNum">    1600 </span>            :                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    1601 </span>            :                  nsISupports* data, size_t&amp; gcTotal)
<span class="lineNum">    1602 </span>            : {
<span class="lineNum">    1603 </span>            :     // We deliberately don't use ZCREPORT_BYTES, so that these per-class values
<span class="lineNum">    1604 </span>            :     // don't go into sundries.
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :     if (classInfo.objectsGCHeap &gt; 0) {</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/gc-heap&quot;),</span>
<span class="lineNum">    1608 </span>            :             classInfo.objectsGCHeap,
<span class="lineNum">    1609 </span>            :             &quot;Objects, including fixed slots.&quot;);
<span class="lineNum">    1610 </span>            :     }
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapSlots &gt; 0) {</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/slots&quot;),</span>
<span class="lineNum">    1614 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapSlots,
<span class="lineNum">    1615 </span>            :             &quot;Non-fixed object slots.&quot;);
<span class="lineNum">    1616 </span>            :     }
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapElementsNormal &gt; 0) {</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/elements/normal&quot;),</span>
<span class="lineNum">    1620 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapElementsNormal,
<span class="lineNum">    1621 </span>            :             &quot;Normal (non-wasm) indexed elements.&quot;);
<span class="lineNum">    1622 </span>            :     }
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapElementsAsmJS &gt; 0) {</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/elements/asm.js&quot;),</span>
<span class="lineNum">    1626 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapElementsAsmJS,
<span class="lineNum">    1627 </span>            :             &quot;asm.js array buffer elements allocated in the malloc heap.&quot;);
<span class="lineNum">    1628 </span>            :     }
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     if (classInfo.objectsMallocHeapMisc &gt; 0) {</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/malloc-heap/misc&quot;),</span>
<span class="lineNum">    1632 </span>            :             KIND_HEAP, classInfo.objectsMallocHeapMisc,
<span class="lineNum">    1633 </span>            :             &quot;Miscellaneous object data.&quot;);
<span class="lineNum">    1634 </span>            :     }
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsNormal &gt; 0) {</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/normal&quot;),</span>
<span class="lineNum">    1638 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsNormal,
<span class="lineNum">    1639 </span>            :             &quot;Memory-mapped non-shared array buffer elements.&quot;);
<span class="lineNum">    1640 </span>            :     }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsShared &gt; 0) {</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/shared&quot;),</span>
<span class="lineNum">    1644 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsShared,
<span class="lineNum">    1645 </span>            :             &quot;Memory-mapped shared array buffer elements. These elements are &quot;
<span class="lineNum">    1646 </span>            :             &quot;shared between one or more runtimes; the reported size is divided &quot;
<span class="lineNum">    1647 </span>            :             &quot;by the buffer's refcount.&quot;);
<span class="lineNum">    1648 </span>            :     }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            :     // WebAssembly memories are always non-heap-allocated (mmap). We never put
<span class="lineNum">    1651 </span>            :     // these under sundries, because (a) in practice they're almost always
<span class="lineNum">    1652 </span>            :     // larger than the sundries threshold, and (b) we'd need a third category of
<span class="lineNum">    1653 </span>            :     // sundries (&quot;non-heap&quot;), which would be a pain.
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapElementsWasm &gt; 0) {</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/elements/wasm&quot;),</span>
<span class="lineNum">    1656 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapElementsWasm,
<span class="lineNum">    1657 </span>            :             &quot;wasm/asm.js array buffer elements allocated outside both the &quot;
<span class="lineNum">    1658 </span>            :             &quot;malloc heap and the GC heap.&quot;);
<span class="lineNum">    1659 </span>            :     }
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     if (classInfo.objectsNonHeapCodeWasm &gt; 0) {</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :         REPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;objects/non-heap/code/wasm&quot;),</span>
<span class="lineNum">    1663 </span>            :             KIND_NONHEAP, classInfo.objectsNonHeapCodeWasm,
<span class="lineNum">    1664 </span>            :             &quot;AOT-compiled wasm/asm.js code.&quot;);
<span class="lineNum">    1665 </span>            :     }
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :     // Although wasm guard pages aren't committed in memory they can be very
<span class="lineNum">    1668 </span>            :     // large and contribute greatly to vsize and so are worth reporting.
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     if (classInfo.wasmGuardPages &gt; 0) {</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :         REPORT_BYTES(NS_LITERAL_CSTRING(&quot;wasm-guard-pages&quot;),</span>
<span class="lineNum">    1671 </span>            :             KIND_OTHER, classInfo.wasmGuardPages,
<span class="lineNum">    1672 </span>            :             &quot;Guard pages mapped after the end of wasm memories, reserved for &quot;
<span class="lineNum">    1673 </span>            :             &quot;optimization tricks, but not committed and thus never contributing&quot;
<span class="lineNum">    1674 </span>            :             &quot; to RSS, only vsize.&quot;);
<span class="lineNum">    1675 </span>            :     }
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 : }</span>
<a name="1677"><span class="lineNum">    1677 </span>            : </a>
<span class="lineNum">    1678 </span>            : static void
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 : ReportCompartmentStats(const JS::CompartmentStats&amp; cStats,</span>
<span class="lineNum">    1680 </span>            :                        const xpc::CompartmentStatsExtras&amp; extras,
<span class="lineNum">    1681 </span>            :                        amIAddonManager* addonManager,
<span class="lineNum">    1682 </span>            :                        nsIHandleReportCallback* handleReport,
<span class="lineNum">    1683 </span>            :                        nsISupports* data, size_t* gcTotalOut = nullptr)
<span class="lineNum">    1684 </span>            : {
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :     static const nsDependentCString addonPrefix(&quot;explicit/add-ons/&quot;);</span>
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0, sundriesGCHeap = 0, sundriesMallocHeap = 0;</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     nsAutoCString cJSPathPrefix(extras.jsPathPrefix);</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :     nsAutoCString cDOMPathPrefix(extras.domPathPrefix);</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!gcTotalOut == cStats.isTotals);</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            :     // Only attempt to prefix if we got a location and the path wasn't already
<span class="lineNum">    1694 </span>            :     // prefixed.
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     if (extras.location &amp;&amp; addonManager &amp;&amp;</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :         cJSPathPrefix.Find(addonPrefix, false, 0, 0) != 0) {</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :         nsAutoCString addonId;</span>
<span class="lineNum">    1698 </span>            :         bool ok;
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :         if (NS_SUCCEEDED(addonManager-&gt;MapURIToAddonID(extras.location,</span>
<span class="lineNum">    1700 </span>            :                                                         addonId, &amp;ok))
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :             &amp;&amp; ok) {</span>
<span class="lineNum">    1702 </span>            :             // Insert the add-on id as &quot;add-ons/@id@/&quot; after &quot;explicit/&quot; to
<span class="lineNum">    1703 </span>            :             // aggregate add-on compartments.
<span class="lineNum">    1704 </span>            :             static const size_t explicitLength = strlen(&quot;explicit/&quot;);
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :             addonId.Insert(NS_LITERAL_CSTRING(&quot;add-ons/&quot;), 0);</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :             addonId += &quot;/&quot;;</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :             cJSPathPrefix.Insert(addonId, explicitLength);</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :             cDOMPathPrefix.Insert(addonId, explicitLength);</span>
<span class="lineNum">    1709 </span>            :         }
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     nsCString nonNotablePath = cJSPathPrefix;</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :     nonNotablePath += cStats.isTotals</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                     ? NS_LITERAL_CSTRING(&quot;classes/&quot;)</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                     : NS_LITERAL_CSTRING(&quot;classes/class(&lt;non-notable classes&gt;)/&quot;);</span>
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :     ReportClassStats(cStats.classInfo, nonNotablePath, handleReport, data,</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :                      gcTotal);</span>
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; cStats.notableClasses.length(); i++) {</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!cStats.isTotals);</span>
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :         const JS::NotableClassInfo&amp; classInfo = cStats.notableClasses[i];</span>
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :         nsCString classPath = cJSPathPrefix +</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :             nsPrintfCString(&quot;classes/class(%s)/&quot;, classInfo.className_);</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :         ReportClassStats(classInfo, classPath, handleReport, data, gcTotal);</span>
<span class="lineNum">    1728 </span>            :     }
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span>            :     // Note that we use cDOMPathPrefix here.  This is because we measure orphan
<span class="lineNum">    1731 </span>            :     // DOM nodes in the JS reporter, but we want to report them in a &quot;dom&quot;
<span class="lineNum">    1732 </span>            :     // sub-tree rather than a &quot;js&quot; sub-tree.
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cDOMPathPrefix + NS_LITERAL_CSTRING(&quot;orphan-nodes&quot;),</span>
<span class="lineNum">    1734 </span>            :         cStats.objectsPrivate,
<span class="lineNum">    1735 </span>            :         &quot;Orphan DOM nodes, i.e. those that are only reachable from JavaScript &quot;
<span class="lineNum">    1736 </span>            :         &quot;objects.&quot;);
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     ZCREPORT_GC_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;scripts/gc-heap&quot;),</span>
<span class="lineNum">    1739 </span>            :         cStats.scriptsGCHeap,
<span class="lineNum">    1740 </span>            :         &quot;JSScript instances. There is one per user-defined function in a &quot;
<span class="lineNum">    1741 </span>            :         &quot;script, and one for the top-level code in a script.&quot;);
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;scripts/malloc-heap/data&quot;),</span>
<span class="lineNum">    1744 </span>            :         cStats.scriptsMallocHeapData,
<span class="lineNum">    1745 </span>            :         &quot;Various variable-length tables in JSScripts.&quot;);
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;baseline/data&quot;),</span>
<span class="lineNum">    1748 </span>            :         cStats.baselineData,
<span class="lineNum">    1749 </span>            :         &quot;The Baseline JIT's compilation data (BaselineScripts).&quot;);
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;baseline/fallback-stubs&quot;),</span>
<span class="lineNum">    1752 </span>            :         cStats.baselineStubsFallback,
<span class="lineNum">    1753 </span>            :         &quot;The Baseline JIT's fallback IC stubs (excluding code).&quot;);
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;ion-data&quot;),</span>
<span class="lineNum">    1756 </span>            :         cStats.ionData,
<span class="lineNum">    1757 </span>            :         &quot;The IonMonkey JIT's compilation data (IonScripts).&quot;);
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/type-scripts&quot;),</span>
<span class="lineNum">    1760 </span>            :         cStats.typeInferenceTypeScripts,
<span class="lineNum">    1761 </span>            :         &quot;Type sets associated with scripts.&quot;);
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/allocation-site-tables&quot;),</span>
<span class="lineNum">    1764 </span>            :         cStats.typeInferenceAllocationSiteTables,
<span class="lineNum">    1765 </span>            :         &quot;Tables of type objects associated with allocation sites.&quot;);
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/array-type-tables&quot;),</span>
<span class="lineNum">    1768 </span>            :         cStats.typeInferenceArrayTypeTables,
<span class="lineNum">    1769 </span>            :         &quot;Tables of type objects associated with array literals.&quot;);
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;type-inference/object-type-tables&quot;),</span>
<span class="lineNum">    1772 </span>            :         cStats.typeInferenceObjectTypeTables,
<span class="lineNum">    1773 </span>            :         &quot;Tables of type objects associated with object literals.&quot;);
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;compartment-object&quot;),</span>
<span class="lineNum">    1776 </span>            :         cStats.compartmentObject,
<span class="lineNum">    1777 </span>            :         &quot;The JSCompartment object itself.&quot;);
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;compartment-tables&quot;),</span>
<span class="lineNum">    1780 </span>            :         cStats.compartmentTables,
<span class="lineNum">    1781 </span>            :         &quot;Compartment-wide tables storing object group information and wasm instances.&quot;);
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;inner-views&quot;),</span>
<span class="lineNum">    1784 </span>            :         cStats.innerViewsTable,
<span class="lineNum">    1785 </span>            :         &quot;The table for array buffer inner views.&quot;);
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;lazy-array-buffers&quot;),</span>
<span class="lineNum">    1788 </span>            :         cStats.lazyArrayBuffersTable,
<span class="lineNum">    1789 </span>            :         &quot;The table for typed object lazy array buffers.&quot;);
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;object-metadata&quot;),</span>
<span class="lineNum">    1792 </span>            :         cStats.objectMetadataTable,
<span class="lineNum">    1793 </span>            :         &quot;The table used by debugging tools for tracking object metadata&quot;);
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;cross-compartment-wrapper-table&quot;),</span>
<span class="lineNum">    1796 </span>            :         cStats.crossCompartmentWrappersTable,
<span class="lineNum">    1797 </span>            :         &quot;The cross-compartment wrapper table.&quot;);
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;saved-stacks-set&quot;),</span>
<span class="lineNum">    1800 </span>            :         cStats.savedStacksSet,
<span class="lineNum">    1801 </span>            :         &quot;The saved stacks set.&quot;);
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;non-syntactic-lexical-scopes-table&quot;),</span>
<span class="lineNum">    1804 </span>            :         cStats.nonSyntacticLexicalScopesTable,
<span class="lineNum">    1805 </span>            :         &quot;The non-syntactic lexical scopes table.&quot;);
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;template-literal-map&quot;),</span>
<span class="lineNum">    1808 </span>            :         cStats.templateLiteralMap,
<span class="lineNum">    1809 </span>            :         &quot;The template literal registry.&quot;);
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;jit-compartment&quot;),</span>
<span class="lineNum">    1812 </span>            :         cStats.jitCompartment,
<span class="lineNum">    1813 </span>            :         &quot;The JIT compartment.&quot;);
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :     ZCREPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;private-data&quot;),</span>
<span class="lineNum">    1816 </span>            :         cStats.privateData,
<span class="lineNum">    1817 </span>            :         &quot;Extra data attached to the compartment by XPConnect, including &quot;
<span class="lineNum">    1818 </span>            :         &quot;its wrapped-js.&quot;);
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :     if (sundriesGCHeap &gt; 0) {</span>
<span class="lineNum">    1821 </span>            :         // We deliberately don't use ZCREPORT_GC_BYTES here.
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :         REPORT_GC_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;sundries/gc-heap&quot;),</span>
<span class="lineNum">    1823 </span>            :             sundriesGCHeap,
<span class="lineNum">    1824 </span>            :             &quot;The sum of all 'gc-heap' measurements that are too small to be &quot;
<span class="lineNum">    1825 </span>            :             &quot;worth showing individually.&quot;);
<span class="lineNum">    1826 </span>            :     }
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     if (sundriesMallocHeap &gt; 0) {</span>
<span class="lineNum">    1829 </span>            :         // We deliberately don't use ZCREPORT_BYTES here.
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :         REPORT_BYTES(cJSPathPrefix + NS_LITERAL_CSTRING(&quot;sundries/malloc-heap&quot;),</span>
<span class="lineNum">    1831 </span>            :             KIND_HEAP, sundriesMallocHeap,
<span class="lineNum">    1832 </span>            :             &quot;The sum of all 'malloc-heap' measurements that are too small to &quot;
<span class="lineNum">    1833 </span>            :             &quot;be worth showing individually.&quot;);
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     if (gcTotalOut)</span>
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :         *gcTotalOut += gcTotal;</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 : }</span>
<a name="1839"><span class="lineNum">    1839 </span>            : </a>
<span class="lineNum">    1840 </span>            : static void
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 : ReportScriptSourceStats(const ScriptSourceInfo&amp; scriptSourceInfo,</span>
<span class="lineNum">    1842 </span>            :                         const nsACString&amp; path,
<span class="lineNum">    1843 </span>            :                         nsIHandleReportCallback* handleReport,
<span class="lineNum">    1844 </span>            :                         nsISupports* data, size_t&amp; rtTotal)
<span class="lineNum">    1845 </span>            : {
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     if (scriptSourceInfo.misc &gt; 0) {</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :         RREPORT_BYTES(path + NS_LITERAL_CSTRING(&quot;misc&quot;),</span>
<span class="lineNum">    1848 </span>            :             KIND_HEAP, scriptSourceInfo.misc,
<span class="lineNum">    1849 </span>            :             &quot;Miscellaneous data relating to JavaScript source code.&quot;);
<span class="lineNum">    1850 </span>            :     }
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 : }</span>
<a name="1852"><span class="lineNum">    1852 </span>            : </a>
<span class="lineNum">    1853 </span>            : static void
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 : ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats&amp; rtStats,</span>
<span class="lineNum">    1855 </span>            :                                  const nsACString&amp; rtPath,
<span class="lineNum">    1856 </span>            :                                  amIAddonManager* addonManager,
<span class="lineNum">    1857 </span>            :                                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    1858 </span>            :                                  nsISupports* data,
<span class="lineNum">    1859 </span>            :                                  bool anonymize,
<span class="lineNum">    1860 </span>            :                                  size_t* rtTotalOut)
<span class="lineNum">    1861 </span>            : {
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :     size_t gcTotal = 0;</span>
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.zoneStatsVector.length(); i++) {</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :         const JS::ZoneStats&amp; zStats = rtStats.zoneStatsVector[i];</span>
<span class="lineNum">    1866 </span>            :         const xpc::ZoneStatsExtras* extras =
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :           static_cast&lt;const xpc::ZoneStatsExtras*&gt;(zStats.extra);</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :         ReportZoneStats(zStats, *extras, handleReport, data, anonymize,</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :                         &amp;gcTotal);</span>
<span class="lineNum">    1870 </span>            :     }
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.compartmentStatsVector.length(); i++) {</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         const JS::CompartmentStats&amp; cStats = rtStats.compartmentStatsVector[i];</span>
<span class="lineNum">    1874 </span>            :         const xpc::CompartmentStatsExtras* extras =
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :             static_cast&lt;const xpc::CompartmentStatsExtras*&gt;(cStats.extra);</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            :         ReportCompartmentStats(cStats, *extras, addonManager, handleReport,
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                                data, &amp;gcTotal);</span>
<span class="lineNum">    1879 </span>            :     }
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            :     // Report the rtStats.runtime numbers under &quot;runtime/&quot;, and compute their
<span class="lineNum">    1882 </span>            :     // total for later.
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     size_t rtTotal = 0;</span>
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/runtime-object&quot;),</span>
<span class="lineNum">    1887 </span>            :         KIND_HEAP, rtStats.runtime.object,
<span class="lineNum">    1888 </span>            :         &quot;The JSRuntime object.&quot;);
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/atoms-table&quot;),</span>
<span class="lineNum">    1891 </span>            :         KIND_HEAP, rtStats.runtime.atomsTable,
<span class="lineNum">    1892 </span>            :         &quot;The atoms table.&quot;);
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/atoms-mark-bitmaps&quot;),</span>
<span class="lineNum">    1895 </span>            :         KIND_HEAP, rtStats.runtime.atomsMarkBitmaps,
<span class="lineNum">    1896 </span>            :         &quot;Mark bitmaps for atoms held by each zone.&quot;);
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/contexts&quot;),</span>
<span class="lineNum">    1899 </span>            :         KIND_HEAP, rtStats.runtime.contexts,
<span class="lineNum">    1900 </span>            :         &quot;JSContext objects and structures that belong to them.&quot;);
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/temporary&quot;),</span>
<span class="lineNum">    1903 </span>            :         KIND_HEAP, rtStats.runtime.temporary,
<span class="lineNum">    1904 </span>            :         &quot;Transient data (mostly parse nodes) held by the JSRuntime during &quot;
<span class="lineNum">    1905 </span>            :         &quot;compilation.&quot;);
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/interpreter-stack&quot;),</span>
<span class="lineNum">    1908 </span>            :         KIND_HEAP, rtStats.runtime.interpreterStack,
<span class="lineNum">    1909 </span>            :         &quot;JS interpreter frames.&quot;);
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/math-cache&quot;),</span>
<span class="lineNum">    1912 </span>            :         KIND_HEAP, rtStats.runtime.mathCache,
<span class="lineNum">    1913 </span>            :         &quot;The math cache.&quot;);
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/shared-immutable-strings-cache&quot;),</span>
<span class="lineNum">    1916 </span>            :         KIND_HEAP, rtStats.runtime.sharedImmutableStringsCache,
<span class="lineNum">    1917 </span>            :         &quot;Immutable strings (such as JS scripts' source text) shared across all JSRuntimes.&quot;);
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/shared-intl-data&quot;),</span>
<span class="lineNum">    1920 </span>            :         KIND_HEAP, rtStats.runtime.sharedIntlData,
<span class="lineNum">    1921 </span>            :         &quot;Shared internationalization data.&quot;);
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/uncompressed-source-cache&quot;),</span>
<span class="lineNum">    1924 </span>            :         KIND_HEAP, rtStats.runtime.uncompressedSourceCache,
<span class="lineNum">    1925 </span>            :         &quot;The uncompressed source code cache.&quot;);
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/script-data&quot;),</span>
<span class="lineNum">    1928 </span>            :         KIND_HEAP, rtStats.runtime.scriptData,
<span class="lineNum">    1929 </span>            :         &quot;The table holding script data shared in the runtime.&quot;);
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span>            :     nsCString nonNotablePath =
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         rtPath + nsPrintfCString(&quot;runtime/script-sources/source(scripts=%d, &lt;non-notable files&gt;)/&quot;,</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :                                  rtStats.runtime.scriptSourceInfo.numScripts);</span>
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :     ReportScriptSourceStats(rtStats.runtime.scriptSourceInfo,</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :                             nonNotablePath, handleReport, data, rtTotal);</span>
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; rtStats.runtime.notableScriptSources.length(); i++) {</span>
<span class="lineNum">    1939 </span>            :         const JS::NotableScriptSourceInfo&amp; scriptSourceInfo =
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :             rtStats.runtime.notableScriptSources[i];</span>
<span class="lineNum">    1941 </span>            : 
<span class="lineNum">    1942 </span>            :         // Escape / to \ before we put the filename into the memory reporter
<span class="lineNum">    1943 </span>            :         // path, because we don't want any forward slashes in the string to
<span class="lineNum">    1944 </span>            :         // count as path separators. Consumers of memory reporters (e.g.
<span class="lineNum">    1945 </span>            :         // about:memory) will convert them back to / after doing path
<span class="lineNum">    1946 </span>            :         // splitting.
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :         nsCString escapedFilename;</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :         if (anonymize) {</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :             escapedFilename.AppendPrintf(&quot;&lt;anonymized-source-%d&gt;&quot;, int(i));</span>
<span class="lineNum">    1950 </span>            :         } else {
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :             nsDependentCString filename(scriptSourceInfo.filename_);</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :             escapedFilename.Append(filename);</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :             escapedFilename.ReplaceSubstring(&quot;/&quot;, &quot;\\&quot;);</span>
<span class="lineNum">    1954 </span>            :         }
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :         nsCString notablePath = rtPath +</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :             nsPrintfCString(&quot;runtime/script-sources/source(scripts=%d, %s)/&quot;,</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                             scriptSourceInfo.numScripts, escapedFilename.get());</span>
<span class="lineNum">    1959 </span>            : 
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :         ReportScriptSourceStats(scriptSourceInfo, notablePath,</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :                                 handleReport, data, rtTotal);</span>
<span class="lineNum">    1962 </span>            :     }
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/ion&quot;),</span>
<span class="lineNum">    1965 </span>            :         KIND_NONHEAP, rtStats.runtime.code.ion,
<span class="lineNum">    1966 </span>            :         &quot;Code generated by the IonMonkey JIT.&quot;);
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/baseline&quot;),</span>
<span class="lineNum">    1969 </span>            :         KIND_NONHEAP, rtStats.runtime.code.baseline,
<span class="lineNum">    1970 </span>            :         &quot;Code generated by the Baseline JIT.&quot;);
<span class="lineNum">    1971 </span>            : 
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/regexp&quot;),</span>
<span class="lineNum">    1973 </span>            :         KIND_NONHEAP, rtStats.runtime.code.regexp,
<span class="lineNum">    1974 </span>            :         &quot;Code generated by the regexp JIT.&quot;);
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/other&quot;),</span>
<span class="lineNum">    1977 </span>            :         KIND_NONHEAP, rtStats.runtime.code.other,
<span class="lineNum">    1978 </span>            :         &quot;Code generated by the JITs for wrappers and trampolines.&quot;);
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/code/unused&quot;),</span>
<span class="lineNum">    1981 </span>            :         KIND_NONHEAP, rtStats.runtime.code.unused,
<span class="lineNum">    1982 </span>            :         &quot;Memory allocated by one of the JITs to hold code, but which is &quot;
<span class="lineNum">    1983 </span>            :         &quot;currently unused.&quot;);
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/marker&quot;),</span>
<span class="lineNum">    1986 </span>            :         KIND_HEAP, rtStats.runtime.gc.marker,
<span class="lineNum">    1987 </span>            :         &quot;The GC mark stack and gray roots.&quot;);
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/nursery-committed&quot;),</span>
<span class="lineNum">    1990 </span>            :         KIND_NONHEAP, rtStats.runtime.gc.nurseryCommitted,
<span class="lineNum">    1991 </span>            :         &quot;Memory being used by the GC's nursery.&quot;);
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/nursery-malloced-buffers&quot;),</span>
<span class="lineNum">    1994 </span>            :         KIND_HEAP, rtStats.runtime.gc.nurseryMallocedBuffers,
<span class="lineNum">    1995 </span>            :         &quot;Out-of-line slots and elements belonging to objects in the nursery.&quot;);
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/vals&quot;),</span>
<span class="lineNum">    1998 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferVals,
<span class="lineNum">    1999 </span>            :         &quot;Values in the store buffer.&quot;);
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/cells&quot;),</span>
<span class="lineNum">    2002 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferCells,
<span class="lineNum">    2003 </span>            :         &quot;Cells in the store buffer.&quot;);
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/slots&quot;),</span>
<span class="lineNum">    2006 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferSlots,
<span class="lineNum">    2007 </span>            :         &quot;Slots in the store buffer.&quot;);
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/whole-cells&quot;),</span>
<span class="lineNum">    2010 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferWholeCells,
<span class="lineNum">    2011 </span>            :         &quot;Whole cells in the store buffer.&quot;);
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :     RREPORT_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;runtime/gc/store-buffer/generics&quot;),</span>
<span class="lineNum">    2014 </span>            :         KIND_HEAP, rtStats.runtime.gc.storeBufferGenerics,
<span class="lineNum">    2015 </span>            :         &quot;Generic things in the store buffer.&quot;);
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     if (rtTotalOut)</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         *rtTotalOut = rtTotal;</span>
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span>            :     // Report GC numbers that don't belong to a compartment.
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            :     // We don't want to report decommitted memory in &quot;explicit&quot;, so we just
<span class="lineNum">    2023 </span>            :     // change the leading &quot;explicit/&quot; to &quot;decommitted/&quot;.
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :     nsCString rtPath2(rtPath);</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :     rtPath2.Replace(0, strlen(&quot;explicit&quot;), NS_LITERAL_CSTRING(&quot;decommitted&quot;));</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath2 + NS_LITERAL_CSTRING(&quot;gc-heap/decommitted-arenas&quot;),</span>
<span class="lineNum">    2027 </span>            :         rtStats.gcHeapDecommittedArenas,
<span class="lineNum">    2028 </span>            :         &quot;GC arenas in non-empty chunks that is decommitted, i.e. it takes up &quot;
<span class="lineNum">    2029 </span>            :         &quot;address space but no physical memory or swap space.&quot;);
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/unused-chunks&quot;),</span>
<span class="lineNum">    2032 </span>            :         rtStats.gcHeapUnusedChunks,
<span class="lineNum">    2033 </span>            :         &quot;Empty GC chunks which will soon be released unless claimed for new &quot;
<span class="lineNum">    2034 </span>            :         &quot;allocations.&quot;);
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/unused-arenas&quot;),</span>
<span class="lineNum">    2037 </span>            :         rtStats.gcHeapUnusedArenas,
<span class="lineNum">    2038 </span>            :         &quot;Empty GC arenas within non-empty chunks.&quot;);
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     REPORT_GC_BYTES(rtPath + NS_LITERAL_CSTRING(&quot;gc-heap/chunk-admin&quot;),</span>
<span class="lineNum">    2041 </span>            :         rtStats.gcHeapChunkAdmin,
<span class="lineNum">    2042 </span>            :         &quot;Bookkeeping information within GC chunks.&quot;);
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            :     // gcTotal is the sum of everything we've reported for the GC heap.  It
<span class="lineNum">    2045 </span>            :     // should equal rtStats.gcHeapChunkTotal.
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(gcTotal == rtStats.gcHeapChunkTotal);</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 : }</span>
<a name="2048"><span class="lineNum">    2048 </span>            : </a>
<span class="lineNum">    2049 </span>            : void
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 : ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats&amp; rtStats,</span>
<span class="lineNum">    2051 </span>            :                                  const nsACString&amp; rtPath,
<span class="lineNum">    2052 </span>            :                                  nsIHandleReportCallback* handleReport,
<span class="lineNum">    2053 </span>            :                                  nsISupports* data,
<span class="lineNum">    2054 </span>            :                                  bool anonymize,
<span class="lineNum">    2055 </span>            :                                  size_t* rtTotalOut)
<span class="lineNum">    2056 </span>            : {
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;amIAddonManager&gt; am;</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :     if (XRE_IsParentProcess()) {</span>
<span class="lineNum">    2059 </span>            :         // Only try to access the service from the main process.
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         am = do_GetService(&quot;@mozilla.org/addons/integration;1&quot;);</span>
<span class="lineNum">    2061 </span>            :     }
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :     ReportJSRuntimeExplicitTreeStats(rtStats, rtPath, am.get(), handleReport,</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :                                      data, anonymize, rtTotalOut);</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span>            : 
<a name="2067"><span class="lineNum">    2067 </span>            : } // namespace xpc</a>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span><span class="lineCov">          3 : class JSMainRuntimeCompartmentsReporter final : public nsIMemoryReporter</span>
<a name="2070"><span class="lineNum">    2070 </span>            : {</a>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     ~JSMainRuntimeCompartmentsReporter() {}</span>
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            :   public:
<a name="2075"><span class="lineNum">    2075 </span>            :     NS_DECL_ISUPPORTS</a>
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     struct Data {</span>
<span class="lineNum">    2078 </span>            :         int anonymizeID;
<span class="lineNum">    2079 </span>            :         js::Vector&lt;nsCString, 0, js::SystemAllocPolicy&gt; paths;
<a name="2080"><span class="lineNum">    2080 </span>            :     };</a>
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :     static void CompartmentCallback(JSContext* cx, void* vdata, JSCompartment* c) {</span>
<span class="lineNum">    2083 </span>            :         // silently ignore OOM errors
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         Data* data = static_cast&lt;Data*&gt;(vdata);</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :         nsCString path;</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         GetCompartmentName(c, path, &amp;data-&gt;anonymizeID, /* replaceSlashes = */ true);</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :         path.Insert(js::IsSystemCompartment(c)</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :                     ? NS_LITERAL_CSTRING(&quot;js-main-runtime-compartments/system/&quot;)</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :                     : NS_LITERAL_CSTRING(&quot;js-main-runtime-compartments/user/&quot;),</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :                     0);</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :         mozilla::Unused &lt;&lt; data-&gt;paths.append(path);</span>
<a name="2092"><span class="lineNum">    2092 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :     NS_IMETHOD CollectReports(nsIHandleReportCallback* handleReport,</span>
<span class="lineNum">    2095 </span>            :                               nsISupports* data, bool anonymize) override
<span class="lineNum">    2096 </span>            :     {
<span class="lineNum">    2097 </span>            :         // First we collect the compartment paths.  Then we report them.  Doing
<span class="lineNum">    2098 </span>            :         // the two steps interleaved is a bad idea, because calling
<span class="lineNum">    2099 </span>            :         // |handleReport| from within CompartmentCallback() leads to all manner
<span class="lineNum">    2100 </span>            :         // of assertions.
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         Data d;</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         d.anonymizeID = anonymize ? 1 : 0;</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :         JS_IterateCompartments(XPCJSContext::Get()-&gt;Context(),</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :                                &amp;d, CompartmentCallback);</span>
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; d.paths.length(); i++)</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :             REPORT(nsCString(d.paths[i]), KIND_OTHER, UNITS_COUNT, 1,</span>
<span class="lineNum">    2109 </span>            :                 &quot;A live compartment in the main JSRuntime.&quot;);
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    2112 </span>            :     }
<a name="2113"><span class="lineNum">    2113 </span>            : };</a>
<span class="lineNum">    2114 </span>            : 
<a name="2115"><span class="lineNum">    2115 </span><span class="lineCov">         39 : NS_IMPL_ISUPPORTS(JSMainRuntimeCompartmentsReporter, nsIMemoryReporter)</span></a>
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 : MOZ_DEFINE_MALLOC_SIZE_OF(OrphanMallocSizeOf)</span>
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span>            : namespace xpc {
<a name="2120"><span class="lineNum">    2120 </span>            : </a>
<span class="lineNum">    2121 </span>            : static size_t
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 : SizeOfTreeIncludingThis(nsINode* tree)</span>
<span class="lineNum">    2123 </span>            : {
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :     size_t n = tree-&gt;SizeOfIncludingThis(OrphanMallocSizeOf);</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     for (nsIContent* child = tree-&gt;GetFirstChild(); child; child = child-&gt;GetNextNode(tree))</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :         n += child-&gt;SizeOfIncludingThis(OrphanMallocSizeOf);</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :     return n;</span>
<a name="2129"><span class="lineNum">    2129 </span>            : }</a>
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 : class OrphanReporter : public JS::ObjectPrivateVisitor</span>
<a name="2132"><span class="lineNum">    2132 </span>            : {</a>
<span class="lineNum">    2133 </span>            :   public:
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :     explicit OrphanReporter(GetISupportsFun aGetISupports)</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :       : JS::ObjectPrivateVisitor(aGetISupports)</span>
<span class="lineNum">    2136 </span>            :     {
<a name="2137"><span class="lineNum">    2137 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :     virtual size_t sizeOfIncludingThis(nsISupports* aSupports) override {</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :         size_t n = 0;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :         nsCOMPtr&lt;nsINode&gt; node = do_QueryInterface(aSupports);</span>
<span class="lineNum">    2142 </span>            :         // https://bugzilla.mozilla.org/show_bug.cgi?id=773533#c11 explains
<span class="lineNum">    2143 </span>            :         // that we have to skip XBL elements because they violate certain
<span class="lineNum">    2144 </span>            :         // assumptions.  Yuk.
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :         if (node &amp;&amp; !node-&gt;IsInUncomposedDoc() &amp;&amp;</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :             !(node-&gt;IsElement() &amp;&amp; node-&gt;AsElement()-&gt;IsInNamespace(kNameSpaceID_XBL)))</span>
<span class="lineNum">    2147 </span>            :         {
<span class="lineNum">    2148 </span>            :             // This is an orphan node.  If we haven't already handled the
<span class="lineNum">    2149 </span>            :             // sub-tree that this node belongs to, measure the sub-tree's size
<span class="lineNum">    2150 </span>            :             // and then record its root so we don't measure it again.
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :             nsCOMPtr&lt;nsINode&gt; orphanTree = node-&gt;SubtreeRoot();</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :             if (orphanTree &amp;&amp;</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :                 !mAlreadyMeasuredOrphanTrees.Contains(orphanTree)) {</span>
<span class="lineNum">    2154 </span>            :                 // If PutEntry() fails we don't measure this tree, which could
<span class="lineNum">    2155 </span>            :                 // lead to under-measurement. But that's better than the
<span class="lineNum">    2156 </span>            :                 // alternatives, which are over-measurement or an OOM abort.
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :                 if (mAlreadyMeasuredOrphanTrees.PutEntry(orphanTree, fallible)) {</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :                     n += SizeOfTreeIncludingThis(orphanTree);</span>
<span class="lineNum">    2159 </span>            :                 }
<span class="lineNum">    2160 </span>            :             }
<span class="lineNum">    2161 </span>            :         }
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :         return n;</span>
<span class="lineNum">    2163 </span>            :     }
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            :   private:
<span class="lineNum">    2166 </span>            :     nsTHashtable &lt;nsISupportsHashKey&gt; mAlreadyMeasuredOrphanTrees;
<span class="lineNum">    2167 </span>            : };
<span class="lineNum">    2168 </span>            : 
<a name="2169"><span class="lineNum">    2169 </span>            : #ifdef DEBUG</a>
<span class="lineNum">    2170 </span>            : static bool
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 : StartsWithExplicit(nsACString&amp; s)</span>
<span class="lineNum">    2172 </span>            : {
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :     return StringBeginsWith(s, NS_LITERAL_CSTRING(&quot;explicit/&quot;));</span>
<span class="lineNum">    2174 </span>            : }
<span class="lineNum">    2175 </span>            : #endif
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            : class XPCJSRuntimeStats : public JS::RuntimeStats
<span class="lineNum">    2178 </span>            : {
<span class="lineNum">    2179 </span>            :     WindowPaths* mWindowPaths;
<span class="lineNum">    2180 </span>            :     WindowPaths* mTopWindowPaths;
<span class="lineNum">    2181 </span>            :     bool mGetLocations;
<span class="lineNum">    2182 </span>            :     int mAnonymizeID;
<a name="2183"><span class="lineNum">    2183 </span>            : </a>
<span class="lineNum">    2184 </span>            :   public:
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :     XPCJSRuntimeStats(WindowPaths* windowPaths, WindowPaths* topWindowPaths,</span>
<span class="lineNum">    2186 </span>            :                       bool getLocations, bool anonymize)
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :       : JS::RuntimeStats(JSMallocSizeOf),</span>
<span class="lineNum">    2188 </span>            :         mWindowPaths(windowPaths),
<span class="lineNum">    2189 </span>            :         mTopWindowPaths(topWindowPaths),
<span class="lineNum">    2190 </span>            :         mGetLocations(getLocations),
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :         mAnonymizeID(anonymize ? 1 : 0)</span>
<a name="2192"><span class="lineNum">    2192 </span><span class="lineNoCov">          0 :     {}</span></a>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     ~XPCJSRuntimeStats() {</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i != compartmentStatsVector.length(); ++i)</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :             delete static_cast&lt;xpc::CompartmentStatsExtras*&gt;(compartmentStatsVector[i].extra);</span>
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i != zoneStatsVector.length(); ++i)</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :             delete static_cast&lt;xpc::ZoneStatsExtras*&gt;(zoneStatsVector[i].extra);</span>
<a name="2201"><span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :     virtual void initExtraZoneStats(JS::Zone* zone, JS::ZoneStats* zStats) override {</span>
<span class="lineNum">    2204 </span>            :         // Get the compartment's global.
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :         AutoSafeJSContext cx;</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :         JSCompartment* comp = js::GetAnyCompartmentInZone(zone);</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :         xpc::ZoneStatsExtras* extras = new xpc::ZoneStatsExtras;</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :         extras-&gt;pathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :         RootedObject global(cx, JS_GetGlobalForCompartmentOrNull(cx, comp));</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :         if (global) {</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :             RefPtr&lt;nsGlobalWindow&gt; window;</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :             if (NS_SUCCEEDED(UNWRAP_OBJECT(Window, global, window))) {</span>
<span class="lineNum">    2213 </span>            :                 // The global is a |window| object.  Use the path prefix that
<span class="lineNum">    2214 </span>            :                 // we should have already created for it.
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                 if (mTopWindowPaths-&gt;Get(window-&gt;WindowID(),</span>
<span class="lineNum">    2216 </span>            :                                          &amp;extras-&gt;pathPrefix))
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :                     extras-&gt;pathPrefix.AppendLiteral(&quot;/js-&quot;);</span>
<span class="lineNum">    2218 </span>            :             }
<span class="lineNum">    2219 </span>            :         }
<span class="lineNum">    2220 </span>            : 
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :         extras-&gt;pathPrefix += nsPrintfCString(&quot;zone(0x%p)/&quot;, (void*)zone);</span>
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;pathPrefix));</span>
<span class="lineNum">    2224 </span>            : 
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :         zStats-&gt;extra = extras;</span>
<a name="2226"><span class="lineNum">    2226 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :     virtual void initExtraCompartmentStats(JSCompartment* c,</span>
<span class="lineNum">    2229 </span>            :                                            JS::CompartmentStats* cstats) override
<span class="lineNum">    2230 </span>            :     {
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :         xpc::CompartmentStatsExtras* extras = new xpc::CompartmentStatsExtras;</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :         nsCString cName;</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :         GetCompartmentName(c, cName, &amp;mAnonymizeID, /* replaceSlashes = */ true);</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :         CompartmentPrivate* cp = CompartmentPrivate::Get(c);</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :         if (cp) {</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :             if (mGetLocations) {</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :                 cp-&gt;GetLocationURI(CompartmentPrivate::LocationHintAddon,</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :                                    getter_AddRefs(extras-&gt;location));</span>
<span class="lineNum">    2239 </span>            :             }
<span class="lineNum">    2240 </span>            :             // Note: cannot use amIAddonManager implementation at this point,
<span class="lineNum">    2241 </span>            :             // as it is a JS service and the JS heap is currently not idle.
<span class="lineNum">    2242 </span>            :             // Otherwise, we could have computed the add-on id at this point.
<span class="lineNum">    2243 </span>            :         }
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span>            :         // Get the compartment's global.
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :         AutoSafeJSContext cx;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :         bool needZone = true;</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :         RootedObject global(cx, JS_GetGlobalForCompartmentOrNull(cx, c));</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :         if (global) {</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :             RefPtr&lt;nsGlobalWindow&gt; window;</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :             if (NS_SUCCEEDED(UNWRAP_OBJECT(Window, global, window))) {</span>
<span class="lineNum">    2252 </span>            :                 // The global is a |window| object.  Use the path prefix that
<span class="lineNum">    2253 </span>            :                 // we should have already created for it.
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :                 if (mWindowPaths-&gt;Get(window-&gt;WindowID(),</span>
<span class="lineNum">    2255 </span>            :                                       &amp;extras-&gt;jsPathPrefix)) {
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.Assign(extras-&gt;jsPathPrefix);</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.AppendLiteral(&quot;/dom/&quot;);</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                     extras-&gt;jsPathPrefix.AppendLiteral(&quot;/js-&quot;);</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :                     needZone = false;</span>
<span class="lineNum">    2260 </span>            :                 } else {
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :                     extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :                     extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/unknown-window-global?!/&quot;);</span>
<span class="lineNum">    2263 </span>            :                 }
<span class="lineNum">    2264 </span>            :             } else {
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                 extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                 extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/non-window-global?!/&quot;);</span>
<span class="lineNum">    2267 </span>            :             }
<span class="lineNum">    2268 </span>            :         } else {
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :             extras-&gt;jsPathPrefix.AssignLiteral(&quot;explicit/js-non-window/zones/&quot;);</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :             extras-&gt;domPathPrefix.AssignLiteral(&quot;explicit/dom/no-global?!/&quot;);</span>
<span class="lineNum">    2271 </span>            :         }
<span class="lineNum">    2272 </span>            : 
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         if (needZone)</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :             extras-&gt;jsPathPrefix += nsPrintfCString(&quot;zone(0x%p)/&quot;, (void*)js::GetCompartmentZone(c));</span>
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :         extras-&gt;jsPathPrefix += NS_LITERAL_CSTRING(&quot;compartment(&quot;) + cName + NS_LITERAL_CSTRING(&quot;)/&quot;);</span>
<span class="lineNum">    2277 </span>            : 
<span class="lineNum">    2278 </span>            :         // extras-&gt;jsPathPrefix is used for almost all the compartment-specific
<span class="lineNum">    2279 </span>            :         // reports. At this point it has the form
<span class="lineNum">    2280 </span>            :         // &quot;&lt;something&gt;compartment(&lt;cname&gt;)/&quot;.
<span class="lineNum">    2281 </span>            :         //
<span class="lineNum">    2282 </span>            :         // extras-&gt;domPathPrefix is used for DOM orphan nodes, which are
<span class="lineNum">    2283 </span>            :         // counted by the JS reporter but reported as part of the DOM
<span class="lineNum">    2284 </span>            :         // measurements. At this point it has the form &quot;&lt;something&gt;/dom/&quot; if
<span class="lineNum">    2285 </span>            :         // this compartment belongs to an nsGlobalWindow, and
<span class="lineNum">    2286 </span>            :         // &quot;explicit/dom/&lt;something&gt;?!/&quot; otherwise (in which case it shouldn't
<span class="lineNum">    2287 </span>            :         // be used, because non-nsGlobalWindow compartments shouldn't have
<span class="lineNum">    2288 </span>            :         // orphan DOM nodes).
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;jsPathPrefix));</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(StartsWithExplicit(extras-&gt;domPathPrefix));</span>
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :         cstats-&gt;extra = extras;</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2295 </span>            : };
<a name="2296"><span class="lineNum">    2296 </span>            : </a>
<span class="lineNum">    2297 </span>            : void
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 : JSReporter::CollectReports(WindowPaths* windowPaths,</span>
<span class="lineNum">    2299 </span>            :                            WindowPaths* topWindowPaths,
<span class="lineNum">    2300 </span>            :                            nsIHandleReportCallback* handleReport,
<span class="lineNum">    2301 </span>            :                            nsISupports* data,
<span class="lineNum">    2302 </span>            :                            bool anonymize)
<span class="lineNum">    2303 </span>            : {
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :     XPCJSRuntime* xpcrt = nsXPConnect::GetRuntimeInstance();</span>
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            :     // In the first step we get all the stats and stash them in a local
<span class="lineNum">    2307 </span>            :     // data structure.  In the second step we pass all the stashed stats to
<span class="lineNum">    2308 </span>            :     // the callback.  Separating these steps is important because the
<span class="lineNum">    2309 </span>            :     // callback may be a JS function, and executing JS while getting these
<span class="lineNum">    2310 </span>            :     // stats seems like a bad idea.
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;amIAddonManager&gt; addonManager;</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :     if (XRE_IsParentProcess()) {</span>
<span class="lineNum">    2314 </span>            :         // Only try to access the service from the main process.
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :         addonManager = do_GetService(&quot;@mozilla.org/addons/integration;1&quot;);</span>
<span class="lineNum">    2316 </span>            :     }
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :     bool getLocations = !!addonManager;</span>
<span class="lineNum">    2318 </span>            :     XPCJSRuntimeStats rtStats(windowPaths, topWindowPaths, getLocations,
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :                               anonymize);</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :     OrphanReporter orphanReporter(XPCConvert::GetISupportsFromJSObject);</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :     JSContext* cx = XPCJSContext::Get()-&gt;Context();</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     if (!JS::CollectRuntimeStats(cx, &amp;rtStats, &amp;orphanReporter,</span>
<span class="lineNum">    2323 </span>            :                                  anonymize))
<span class="lineNum">    2324 </span>            :     {
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2326 </span>            :     }
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :     JS::CollectTraceLoggerStateStats(&amp;rtStats);</span>
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     size_t xpcJSRuntimeSize = xpcrt-&gt;SizeOfIncludingThis(JSMallocSizeOf);</span>
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :     size_t wrappedJSSize = xpcrt-&gt;GetMultiCompartmentWrappedJSMap()-&gt;SizeOfWrappedJS(JSMallocSizeOf);</span>
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::ScopeSizeInfo sizeInfo(JSMallocSizeOf);</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :     XPCWrappedNativeScope::AddSizeOfAllScopesIncludingThis(&amp;sizeInfo);</span>
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :     mozJSComponentLoader* loader = mozJSComponentLoader::Get();</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :     size_t jsComponentLoaderSize = loader ? loader-&gt;SizeOfIncludingThis(JSMallocSizeOf) : 0;</span>
<span class="lineNum">    2339 </span>            : 
<span class="lineNum">    2340 </span>            :     // This is the second step (see above).  First we report stuff in the
<span class="lineNum">    2341 </span>            :     // &quot;explicit&quot; tree, then we report other stuff.
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :     size_t rtTotal = 0;</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :     xpc::ReportJSRuntimeExplicitTreeStats(rtStats,</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :                                           NS_LITERAL_CSTRING(&quot;explicit/js-non-window/&quot;),</span>
<span class="lineNum">    2346 </span>            :                                           addonManager, handleReport, data,
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :                                           anonymize, &amp;rtTotal);</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            :     // Report the sums of the compartment numbers.
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :     xpc::CompartmentStatsExtras cExtrasTotal;</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :     cExtrasTotal.jsPathPrefix.AssignLiteral(&quot;js-main-runtime/compartments/&quot;);</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :     cExtrasTotal.domPathPrefix.AssignLiteral(&quot;window-objects/dom/&quot;);</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :     ReportCompartmentStats(rtStats.cTotals, cExtrasTotal, addonManager,</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :                            handleReport, data);</span>
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :     xpc::ZoneStatsExtras zExtrasTotal;</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :     zExtrasTotal.pathPrefix.AssignLiteral(&quot;js-main-runtime/zones/&quot;);</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :     ReportZoneStats(rtStats.zTotals, zExtrasTotal, handleReport, data,</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :                     anonymize);</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span>            :     // Report the sum of the runtime/ numbers.
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/runtime&quot;),</span>
<span class="lineNum">    2363 </span>            :         KIND_OTHER, rtTotal,
<span class="lineNum">    2364 </span>            :         &quot;The sum of all measurements under 'explicit/js-non-window/runtime/'.&quot;);
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span>            :     // Report the numbers for memory used by tracelogger.
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;tracelogger&quot;),</span>
<span class="lineNum">    2368 </span>            :         KIND_OTHER, rtStats.runtime.tracelogger,
<span class="lineNum">    2369 </span>            :         &quot;The memory used for the tracelogger, including the graph and events.&quot;);
<span class="lineNum">    2370 </span>            : 
<span class="lineNum">    2371 </span>            :     // Report the numbers for memory outside of compartments.
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/unused-chunks&quot;),</span>
<span class="lineNum">    2374 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedChunks,
<span class="lineNum">    2375 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-chunks'.&quot;);
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/unused-arenas&quot;),</span>
<span class="lineNum">    2378 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedArenas,
<span class="lineNum">    2379 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-arenas'.&quot;);
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime/gc-heap/chunk-admin&quot;),</span>
<span class="lineNum">    2382 </span>            :         KIND_OTHER, rtStats.gcHeapChunkAdmin,
<span class="lineNum">    2383 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/chunk-admin'.&quot;);
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :     // Report a breakdown of the committed GC space.
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/chunks&quot;),</span>
<span class="lineNum">    2388 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedChunks,
<span class="lineNum">    2389 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-chunks'.&quot;);
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/arenas&quot;),</span>
<span class="lineNum">    2392 </span>            :         KIND_OTHER, rtStats.gcHeapUnusedArenas,
<span class="lineNum">    2393 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/unused-arenas'.&quot;);
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/objects&quot;),</span>
<span class="lineNum">    2396 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.object,
<span class="lineNum">    2397 </span>            :         &quot;Unused object cells within non-empty arenas.&quot;);
<span class="lineNum">    2398 </span>            : 
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/strings&quot;),</span>
<span class="lineNum">    2400 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.string,
<span class="lineNum">    2401 </span>            :         &quot;Unused string cells within non-empty arenas.&quot;);
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/symbols&quot;),</span>
<span class="lineNum">    2404 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.symbol,
<span class="lineNum">    2405 </span>            :         &quot;Unused symbol cells within non-empty arenas.&quot;);
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/shapes&quot;),</span>
<span class="lineNum">    2408 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.shape,
<span class="lineNum">    2409 </span>            :         &quot;Unused shape cells within non-empty arenas.&quot;);
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/base-shapes&quot;),</span>
<span class="lineNum">    2412 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.baseShape,
<span class="lineNum">    2413 </span>            :         &quot;Unused base shape cells within non-empty arenas.&quot;);
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/object-groups&quot;),</span>
<span class="lineNum">    2416 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.objectGroup,
<span class="lineNum">    2417 </span>            :         &quot;Unused object group cells within non-empty arenas.&quot;);
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/scopes&quot;),</span>
<span class="lineNum">    2420 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.scope,
<span class="lineNum">    2421 </span>            :         &quot;Unused scope cells within non-empty arenas.&quot;);
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/scripts&quot;),</span>
<span class="lineNum">    2424 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.script,
<span class="lineNum">    2425 </span>            :         &quot;Unused script cells within non-empty arenas.&quot;);
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/lazy-scripts&quot;),</span>
<span class="lineNum">    2428 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.lazyScript,
<span class="lineNum">    2429 </span>            :         &quot;Unused lazy script cells within non-empty arenas.&quot;);
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/jitcode&quot;),</span>
<span class="lineNum">    2432 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.jitcode,
<span class="lineNum">    2433 </span>            :         &quot;Unused jitcode cells within non-empty arenas.&quot;);
<span class="lineNum">    2434 </span>            : 
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/unused/gc-things/regexp-shareds&quot;),</span>
<span class="lineNum">    2436 </span>            :         KIND_OTHER, rtStats.zTotals.unusedGCThings.regExpShared,
<span class="lineNum">    2437 </span>            :         &quot;Unused regexpshared cells within non-empty arenas.&quot;);
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/chunk-admin&quot;),</span>
<span class="lineNum">    2440 </span>            :         KIND_OTHER, rtStats.gcHeapChunkAdmin,
<span class="lineNum">    2441 </span>            :         &quot;The same as 'explicit/js-non-window/gc-heap/chunk-admin'.&quot;);
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/arena-admin&quot;),</span>
<span class="lineNum">    2444 </span>            :         KIND_OTHER, rtStats.zTotals.gcHeapArenaAdmin,
<span class="lineNum">    2445 </span>            :         &quot;The same as 'js-main-runtime/zones/gc-heap-arena-admin'.&quot;);
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     size_t gcThingTotal = 0;</span>
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/objects&quot;),</span>
<span class="lineNum">    2450 </span>            :         KIND_OTHER, rtStats.cTotals.classInfo.objectsGCHeap,
<span class="lineNum">    2451 </span>            :         &quot;Used object cells.&quot;);
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/strings&quot;),</span>
<span class="lineNum">    2454 </span>            :         KIND_OTHER, rtStats.zTotals.stringInfo.sizeOfLiveGCThings(),
<span class="lineNum">    2455 </span>            :         &quot;Used string cells.&quot;);
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/symbols&quot;),</span>
<span class="lineNum">    2458 </span>            :         KIND_OTHER, rtStats.zTotals.symbolsGCHeap,
<span class="lineNum">    2459 </span>            :         &quot;Used symbol cells.&quot;);
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/shapes&quot;),</span>
<span class="lineNum">    2462 </span>            :         KIND_OTHER,
<span class="lineNum">    2463 </span>            :         rtStats.zTotals.shapeInfo.shapesGCHeapTree + rtStats.zTotals.shapeInfo.shapesGCHeapDict,
<span class="lineNum">    2464 </span>            :         &quot;Used shape cells.&quot;);
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/base-shapes&quot;),</span>
<span class="lineNum">    2467 </span>            :         KIND_OTHER, rtStats.zTotals.shapeInfo.shapesGCHeapBase,
<span class="lineNum">    2468 </span>            :         &quot;Used base shape cells.&quot;);
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/object-groups&quot;),</span>
<span class="lineNum">    2471 </span>            :         KIND_OTHER, rtStats.zTotals.objectGroupsGCHeap,
<span class="lineNum">    2472 </span>            :         &quot;Used object group cells.&quot;);
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/scopes&quot;),</span>
<span class="lineNum">    2475 </span>            :         KIND_OTHER, rtStats.zTotals.scopesGCHeap,
<span class="lineNum">    2476 </span>            :         &quot;Used scope cells.&quot;);
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/scripts&quot;),</span>
<span class="lineNum">    2479 </span>            :         KIND_OTHER, rtStats.cTotals.scriptsGCHeap,
<span class="lineNum">    2480 </span>            :         &quot;Used script cells.&quot;);
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/lazy-scripts&quot;),</span>
<span class="lineNum">    2483 </span>            :         KIND_OTHER, rtStats.zTotals.lazyScriptsGCHeap,
<span class="lineNum">    2484 </span>            :         &quot;Used lazy script cells.&quot;);
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/jitcode&quot;),</span>
<span class="lineNum">    2487 </span>            :         KIND_OTHER, rtStats.zTotals.jitCodesGCHeap,
<span class="lineNum">    2488 </span>            :         &quot;Used jitcode cells.&quot;);
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :     MREPORT_BYTES(NS_LITERAL_CSTRING(&quot;js-main-runtime-gc-heap-committed/used/gc-things/regexp-shareds&quot;),</span>
<span class="lineNum">    2491 </span>            :         KIND_OTHER, rtStats.zTotals.regExpSharedsGCHeap,
<span class="lineNum">    2492 </span>            :         &quot;Used regexpshared cells.&quot;);
<span class="lineNum">    2493 </span>            : 
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(gcThingTotal == rtStats.gcHeapGCThings);</span>
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span>            :     // Report xpconnect.
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/runtime&quot;),</span>
<span class="lineNum">    2499 </span>            :         KIND_HEAP, xpcJSRuntimeSize,
<span class="lineNum">    2500 </span>            :         &quot;The XPConnect runtime.&quot;);
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/wrappedjs&quot;),</span>
<span class="lineNum">    2503 </span>            :         KIND_HEAP, wrappedJSSize,
<span class="lineNum">    2504 </span>            :         &quot;Wrappers used to implement XPIDL interfaces with JS.&quot;);
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/scopes&quot;),</span>
<span class="lineNum">    2507 </span>            :         KIND_HEAP, sizeInfo.mScopeAndMapSize,
<span class="lineNum">    2508 </span>            :         &quot;XPConnect scopes.&quot;);
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/proto-iface-cache&quot;),</span>
<span class="lineNum">    2511 </span>            :         KIND_HEAP, sizeInfo.mProtoAndIfaceCacheSize,
<span class="lineNum">    2512 </span>            :         &quot;Prototype and interface binding caches.&quot;);
<span class="lineNum">    2513 </span>            : 
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :     REPORT_BYTES(NS_LITERAL_CSTRING(&quot;explicit/xpconnect/js-component-loader&quot;),</span>
<span class="lineNum">    2515 </span>            :         KIND_HEAP, jsComponentLoaderSize,
<span class="lineNum">    2516 </span>            :         &quot;XPConnect's JS component loader.&quot;);
<span class="lineNum">    2517 </span>            : }
<a name="2518"><span class="lineNum">    2518 </span>            : </a>
<span class="lineNum">    2519 </span>            : static nsresult
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 : JSSizeOfTab(JSObject* objArg, size_t* jsObjectsSize, size_t* jsStringsSize,</span>
<span class="lineNum">    2521 </span>            :             size_t* jsPrivateSize, size_t* jsOtherSize)
<span class="lineNum">    2522 </span>            : {
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :     JSContext* cx = XPCJSContext::Get()-&gt;Context();</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :     JS::RootedObject obj(cx, objArg);</span>
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :     TabSizes sizes;</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :     OrphanReporter orphanReporter(XPCConvert::GetISupportsFromJSObject);</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(JS::AddSizeOfTab(cx, obj, moz_malloc_size_of,</span>
<span class="lineNum">    2529 </span>            :                                     &amp;orphanReporter, &amp;sizes),
<span class="lineNum">    2530 </span>            :                    NS_ERROR_OUT_OF_MEMORY);
<span class="lineNum">    2531 </span>            : 
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :     *jsObjectsSize = sizes.objects;</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :     *jsStringsSize = sizes.strings;</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :     *jsPrivateSize = sizes.private_;</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :     *jsOtherSize   = sizes.other;</span>
<span class="lineNum">    2536 </span><span class="lineNoCov">          0 :     return NS_OK;</span>
<span class="lineNum">    2537 </span>            : }
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            : } // namespace xpc
<a name="2540"><span class="lineNum">    2540 </span>            : </a>
<span class="lineNum">    2541 </span>            : static void
<span class="lineNum">    2542 </span><span class="lineCov">        767 : AccumulateTelemetryCallback(int id, uint32_t sample, const char* key)</span>
<span class="lineNum">    2543 </span>            : {
<span class="lineNum">    2544 </span><span class="lineCov">        767 :     switch (id) {</span>
<span class="lineNum">    2545 </span>            :       case JS_TELEMETRY_GC_REASON:
<span class="lineNum">    2546 </span><span class="lineCov">          3 :         Telemetry::Accumulate(Telemetry::GC_REASON_2, sample);</span>
<span class="lineNum">    2547 </span><span class="lineCov">          3 :         break;</span>
<span class="lineNum">    2548 </span>            :       case JS_TELEMETRY_GC_IS_ZONE_GC:
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_IS_COMPARTMENTAL, sample);</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2551 </span>            :       case JS_TELEMETRY_GC_MS:
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MS, sample);</span>
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2554 </span>            :       case JS_TELEMETRY_GC_BUDGET_MS:
<span class="lineNum">    2555 </span><span class="lineCov">          3 :         Telemetry::Accumulate(Telemetry::GC_BUDGET_MS, sample);</span>
<span class="lineNum">    2556 </span><span class="lineCov">          3 :         break;</span>
<span class="lineNum">    2557 </span>            :       case JS_TELEMETRY_GC_ANIMATION_MS:
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_ANIMATION_MS, sample);</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2560 </span>            :       case JS_TELEMETRY_GC_MAX_PAUSE_MS:
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MAX_PAUSE_MS, sample);</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2563 </span>            :       case JS_TELEMETRY_GC_MAX_PAUSE_MS_2:
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MAX_PAUSE_MS_2, sample);</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2566 </span>            :       case JS_TELEMETRY_GC_MARK_MS:
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MARK_MS, sample);</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2569 </span>            :       case JS_TELEMETRY_GC_SWEEP_MS:
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_SWEEP_MS, sample);</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2572 </span>            :       case JS_TELEMETRY_GC_COMPACT_MS:
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_COMPACT_MS, sample);</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2575 </span>            :       case JS_TELEMETRY_GC_MARK_ROOTS_MS:
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MARK_ROOTS_MS, sample);</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2578 </span>            :       case JS_TELEMETRY_GC_MARK_GRAY_MS:
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MARK_GRAY_MS, sample);</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2581 </span>            :       case JS_TELEMETRY_GC_SLICE_MS:
<span class="lineNum">    2582 </span><span class="lineCov">          3 :         Telemetry::Accumulate(Telemetry::GC_SLICE_MS, sample);</span>
<span class="lineNum">    2583 </span><span class="lineCov">          3 :         break;</span>
<span class="lineNum">    2584 </span>            :       case JS_TELEMETRY_GC_SLOW_PHASE:
<span class="lineNum">    2585 </span><span class="lineCov">          1 :         Telemetry::Accumulate(Telemetry::GC_SLOW_PHASE, sample);</span>
<span class="lineNum">    2586 </span><span class="lineCov">          1 :         break;</span>
<span class="lineNum">    2587 </span>            :       case JS_TELEMETRY_GC_SLOW_TASK:
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_SLOW_TASK, sample);</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2590 </span>            :       case JS_TELEMETRY_GC_MMU_50:
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_MMU_50, sample);</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2593 </span>            :       case JS_TELEMETRY_GC_RESET:
<span class="lineNum">    2594 </span><span class="lineCov">          3 :         Telemetry::Accumulate(Telemetry::GC_RESET, sample);</span>
<span class="lineNum">    2595 </span><span class="lineCov">          3 :         break;</span>
<span class="lineNum">    2596 </span>            :       case JS_TELEMETRY_GC_RESET_REASON:
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_RESET_REASON, sample);</span>
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2599 </span>            :       case JS_TELEMETRY_GC_INCREMENTAL_DISABLED:
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_INCREMENTAL_DISABLED, sample);</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2602 </span>            :       case JS_TELEMETRY_GC_NON_INCREMENTAL:
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_NON_INCREMENTAL, sample);</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2605 </span>            :       case JS_TELEMETRY_GC_NON_INCREMENTAL_REASON:
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_NON_INCREMENTAL_REASON, sample);</span>
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2608 </span>            :       case JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS:
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_TOTAL_MS, sample);</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2611 </span>            :       case JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS:
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::GC_SCC_SWEEP_MAX_PAUSE_MS, sample);</span>
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2614 </span>            :       case JS_TELEMETRY_GC_MINOR_REASON:
<span class="lineNum">    2615 </span><span class="lineCov">         24 :         Telemetry::Accumulate(Telemetry::GC_MINOR_REASON, sample);</span>
<span class="lineNum">    2616 </span><span class="lineCov">         24 :         break;</span>
<span class="lineNum">    2617 </span>            :       case JS_TELEMETRY_GC_MINOR_REASON_LONG:
<span class="lineNum">    2618 </span><span class="lineCov">         21 :         Telemetry::Accumulate(Telemetry::GC_MINOR_REASON_LONG, sample);</span>
<span class="lineNum">    2619 </span><span class="lineCov">         21 :         break;</span>
<span class="lineNum">    2620 </span>            :       case JS_TELEMETRY_GC_MINOR_US:
<span class="lineNum">    2621 </span><span class="lineCov">         24 :         Telemetry::Accumulate(Telemetry::GC_MINOR_US, sample);</span>
<span class="lineNum">    2622 </span><span class="lineCov">         24 :         break;</span>
<span class="lineNum">    2623 </span>            :       case JS_TELEMETRY_GC_NURSERY_BYTES:
<span class="lineNum">    2624 </span><span class="lineCov">         24 :         Telemetry::Accumulate(Telemetry::GC_NURSERY_BYTES, sample);</span>
<span class="lineNum">    2625 </span><span class="lineCov">         24 :         break;</span>
<span class="lineNum">    2626 </span>            :       case JS_TELEMETRY_GC_PRETENURE_COUNT:
<span class="lineNum">    2627 </span><span class="lineCov">         24 :         Telemetry::Accumulate(Telemetry::GC_PRETENURE_COUNT, sample);</span>
<span class="lineNum">    2628 </span><span class="lineCov">         24 :         break;</span>
<span class="lineNum">    2629 </span>            :       case JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT:
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_DEPRECATED_LANGUAGE_EXTENSIONS_IN_CONTENT, sample);</span>
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2632 </span>            :       case JS_TELEMETRY_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS:
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_DEPRECATED_LANGUAGE_EXTENSIONS_IN_ADDONS, sample);</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2635 </span>            :       case JS_TELEMETRY_ADDON_EXCEPTIONS:
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_TELEMETRY_ADDON_EXCEPTIONS, nsDependentCString(key), sample);</span>
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2638 </span>            :       case JS_TELEMETRY_AOT_USAGE:
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :         Telemetry::Accumulate(Telemetry::JS_AOT_USAGE, sample);</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2641 </span>            :       case JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS:
<span class="lineNum">    2642 </span><span class="lineCov">        273 :         Telemetry::Accumulate(Telemetry::JS_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS, sample);</span>
<span class="lineNum">    2643 </span><span class="lineCov">        273 :         break;</span>
<span class="lineNum">    2644 </span>            :       case JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS:
<span class="lineNum">    2645 </span><span class="lineCov">        364 :         Telemetry::Accumulate(Telemetry::JS_WEB_PARSER_COMPILE_LAZY_AFTER_MS, sample);</span>
<span class="lineNum">    2646 </span><span class="lineCov">        364 :         break;</span>
<span class="lineNum">    2647 </span>            :       default:
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :         MOZ_ASSERT_UNREACHABLE(&quot;Unexpected JS_TELEMETRY id&quot;);</span>
<span class="lineNum">    2649 </span>            :     }
<span class="lineNum">    2650 </span><span class="lineCov">        767 : }</span>
<a name="2651"><span class="lineNum">    2651 </span>            : </a>
<span class="lineNum">    2652 </span>            : static void
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 : CompartmentNameCallback(JSContext* cx, JSCompartment* comp,</span>
<span class="lineNum">    2654 </span>            :                         char* buf, size_t bufsize)
<span class="lineNum">    2655 </span>            : {
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :     nsCString name;</span>
<span class="lineNum">    2657 </span>            :     // This is called via the JSAPI and isn't involved in memory reporting, so
<span class="lineNum">    2658 </span>            :     // we don't need to anonymize compartment names.
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :     int anonymizeID = 0;</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :     GetCompartmentName(comp, name, &amp;anonymizeID, /* replaceSlashes = */ false);</span>
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :     if (name.Length() &gt;= bufsize)</span>
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :         name.Truncate(bufsize - 1);</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :     memcpy(buf, name.get(), name.Length() + 1);</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 : }</span>
<a name="2665"><span class="lineNum">    2665 </span>            : </a>
<span class="lineNum">    2666 </span>            : static bool
<span class="lineNum">    2667 </span><span class="lineCov">         13 : PreserveWrapper(JSContext* cx, JSObject* obj)</span>
<span class="lineNum">    2668 </span>            : {
<span class="lineNum">    2669 </span><span class="lineCov">         13 :     MOZ_ASSERT(cx);</span>
<span class="lineNum">    2670 </span><span class="lineCov">         13 :     MOZ_ASSERT(obj);</span>
<span class="lineNum">    2671 </span><span class="lineCov">         13 :     MOZ_ASSERT(IS_WN_REFLECTOR(obj) || mozilla::dom::IsDOMObject(obj));</span>
<span class="lineNum">    2672 </span>            : 
<span class="lineNum">    2673 </span><span class="lineCov">         13 :     return mozilla::dom::IsDOMObject(obj) &amp;&amp; mozilla::dom::TryPreserveWrapper(obj);</span>
<span class="lineNum">    2674 </span>            : }
<a name="2675"><span class="lineNum">    2675 </span>            : </a>
<span class="lineNum">    2676 </span>            : static nsresult
<span class="lineNum">    2677 </span><span class="lineCov">          2 : ReadSourceFromFilename(JSContext* cx, const char* filename, char16_t** src, size_t* len)</span>
<span class="lineNum">    2678 </span>            : {
<span class="lineNum">    2679 </span>            :     nsresult rv;
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span>            :     // mozJSSubScriptLoader prefixes the filenames of the scripts it loads with
<span class="lineNum">    2682 </span>            :     // the filename of its caller. Axe that if present.
<span class="lineNum">    2683 </span>            :     const char* arrow;
<span class="lineNum">    2684 </span><span class="lineCov">          3 :     while ((arrow = strstr(filename, &quot; -&gt; &quot;)))</span>
<span class="lineNum">    2685 </span><span class="lineCov">          1 :         filename = arrow + strlen(&quot; -&gt; &quot;);</span>
<span class="lineNum">    2686 </span>            : 
<span class="lineNum">    2687 </span>            :     // Get the URI.
<span class="lineNum">    2688 </span><span class="lineCov">          2 :     nsCOMPtr&lt;nsIURI&gt; uri;</span>
<span class="lineNum">    2689 </span><span class="lineCov">          1 :     rv = NS_NewURI(getter_AddRefs(uri), filename);</span>
<span class="lineNum">    2690 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2691 </span>            : 
<span class="lineNum">    2692 </span><span class="lineCov">          2 :     nsCOMPtr&lt;nsIChannel&gt; scriptChannel;</span>
<span class="lineNum">    2693 </span><span class="lineCov">          2 :     rv = NS_NewChannel(getter_AddRefs(scriptChannel),</span>
<span class="lineNum">    2694 </span>            :                        uri,
<span class="lineNum">    2695 </span>            :                        nsContentUtils::GetSystemPrincipal(),
<span class="lineNum">    2696 </span>            :                        nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL,
<span class="lineNum">    2697 </span><span class="lineCov">          1 :                        nsIContentPolicy::TYPE_OTHER);</span>
<span class="lineNum">    2698 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2699 </span>            : 
<span class="lineNum">    2700 </span>            :     // Only allow local reading.
<span class="lineNum">    2701 </span><span class="lineCov">          2 :     nsCOMPtr&lt;nsIURI&gt; actualUri;</span>
<span class="lineNum">    2702 </span><span class="lineCov">          1 :     rv = scriptChannel-&gt;GetURI(getter_AddRefs(actualUri));</span>
<span class="lineNum">    2703 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2704 </span><span class="lineCov">          2 :     nsCString scheme;</span>
<span class="lineNum">    2705 </span><span class="lineCov">          1 :     rv = actualUri-&gt;GetScheme(scheme);</span>
<span class="lineNum">    2706 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2707 </span><span class="lineCov">          1 :     if (!scheme.EqualsLiteral(&quot;file&quot;) &amp;&amp; !scheme.EqualsLiteral(&quot;jar&quot;))</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :         return NS_OK;</span>
<span class="lineNum">    2709 </span>            : 
<span class="lineNum">    2710 </span>            :     // Explicitly set the content type so that we don't load the
<span class="lineNum">    2711 </span>            :     // exthandler to guess it.
<span class="lineNum">    2712 </span><span class="lineCov">          1 :     scriptChannel-&gt;SetContentType(NS_LITERAL_CSTRING(&quot;text/plain&quot;));</span>
<span class="lineNum">    2713 </span>            : 
<span class="lineNum">    2714 </span><span class="lineCov">          2 :     nsCOMPtr&lt;nsIInputStream&gt; scriptStream;</span>
<span class="lineNum">    2715 </span><span class="lineCov">          1 :     rv = scriptChannel-&gt;Open2(getter_AddRefs(scriptStream));</span>
<span class="lineNum">    2716 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2717 </span>            : 
<span class="lineNum">    2718 </span>            :     uint64_t rawLen;
<span class="lineNum">    2719 </span><span class="lineCov">          1 :     rv = scriptStream-&gt;Available(&amp;rawLen);</span>
<span class="lineNum">    2720 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2721 </span><span class="lineCov">          1 :     if (!rawLen)</span>
<span class="lineNum">    2722 </span><span class="lineNoCov">          0 :         return NS_ERROR_FAILURE;</span>
<span class="lineNum">    2723 </span>            : 
<span class="lineNum">    2724 </span>            :     // Technically, this should be SIZE_MAX, but we don't run on machines
<span class="lineNum">    2725 </span>            :     // where that would be less than UINT32_MAX, and the latter is already
<span class="lineNum">    2726 </span>            :     // well beyond a reasonable limit.
<span class="lineNum">    2727 </span><span class="lineCov">          1 :     if (rawLen &gt; UINT32_MAX)</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :         return NS_ERROR_FILE_TOO_BIG;</span>
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span>            :     // Allocate an internal buf the size of the file.
<span class="lineNum">    2731 </span><span class="lineCov">          2 :     auto buf = MakeUniqueFallible&lt;unsigned char[]&gt;(rawLen);</span>
<span class="lineNum">    2732 </span><span class="lineCov">          1 :     if (!buf)</span>
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :         return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span><span class="lineCov">          1 :     unsigned char* ptr = buf.get();</span>
<span class="lineNum">    2736 </span><span class="lineCov">          1 :     unsigned char* end = ptr + rawLen;</span>
<span class="lineNum">    2737 </span><span class="lineCov">          3 :     while (ptr &lt; end) {</span>
<span class="lineNum">    2738 </span>            :         uint32_t bytesRead;
<span class="lineNum">    2739 </span><span class="lineCov">          1 :         rv = scriptStream-&gt;Read(reinterpret_cast&lt;char*&gt;(ptr), end - ptr, &amp;bytesRead);</span>
<span class="lineNum">    2740 </span><span class="lineCov">          1 :         if (NS_FAILED(rv))</span>
<span class="lineNum">    2741 </span><span class="lineNoCov">          0 :             return rv;</span>
<span class="lineNum">    2742 </span><span class="lineCov">          1 :         MOZ_ASSERT(bytesRead &gt; 0, &quot;stream promised more bytes before EOF&quot;);</span>
<span class="lineNum">    2743 </span><span class="lineCov">          1 :         ptr += bytesRead;</span>
<span class="lineNum">    2744 </span>            :     }
<span class="lineNum">    2745 </span>            : 
<span class="lineNum">    2746 </span><span class="lineCov">          1 :     rv = ScriptLoader::ConvertToUTF16(scriptChannel, buf.get(), rawLen,</span>
<span class="lineNum">    2747 </span><span class="lineCov">          2 :                                       EmptyString(), nullptr, *src, *len);</span>
<span class="lineNum">    2748 </span><span class="lineCov">          1 :     NS_ENSURE_SUCCESS(rv, rv);</span>
<span class="lineNum">    2749 </span>            : 
<span class="lineNum">    2750 </span><span class="lineCov">          1 :     if (!*src)</span>
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :         return NS_ERROR_FAILURE;</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span>            :     // Historically this method used JS_malloc() which updates the GC memory
<span class="lineNum">    2754 </span>            :     // accounting.  Since ConvertToUTF16() now uses js_malloc() instead we
<span class="lineNum">    2755 </span>            :     // update the accounting manually after the fact.
<span class="lineNum">    2756 </span><span class="lineCov">          1 :     JS_updateMallocCounter(cx, *len);</span>
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span><span class="lineCov">          1 :     return NS_OK;</span>
<span class="lineNum">    2759 </span>            : }
<span class="lineNum">    2760 </span>            : 
<span class="lineNum">    2761 </span>            : // The JS engine calls this object's 'load' member function when it needs
<a name="2762"><span class="lineNum">    2762 </span>            : // the source for a chrome JS function. See the comment in the XPCJSRuntime</a>
<a name="2763"><span class="lineNum">    2763 </span>            : // constructor.</a>
<span class="lineNum">    2764 </span><span class="lineCov">          3 : class XPCJSSourceHook: public js::SourceHook {</span>
<span class="lineNum">    2765 </span><span class="lineCov">          1 :     bool load(JSContext* cx, const char* filename, char16_t** src, size_t* length) {</span>
<span class="lineNum">    2766 </span><span class="lineCov">          1 :         *src = nullptr;</span>
<span class="lineNum">    2767 </span><span class="lineCov">          1 :         *length = 0;</span>
<span class="lineNum">    2768 </span>            : 
<span class="lineNum">    2769 </span><span class="lineCov">          1 :         if (!nsContentUtils::IsSystemCaller(cx))</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span><span class="lineCov">          1 :         if (!filename)</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span><span class="lineCov">          1 :         nsresult rv = ReadSourceFromFilename(cx, filename, src, length);</span>
<span class="lineNum">    2776 </span><span class="lineCov">          1 :         if (NS_FAILED(rv)) {</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :             xpc::Throw(cx, rv);</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2779 </span>            :         }
<span class="lineNum">    2780 </span>            : 
<span class="lineNum">    2781 </span><span class="lineCov">          1 :         return true;</span>
<span class="lineNum">    2782 </span>            :     }
<span class="lineNum">    2783 </span>            : };
<span class="lineNum">    2784 </span>            : 
<span class="lineNum">    2785 </span>            : static const JSWrapObjectCallbacks WrapObjectCallbacks = {
<span class="lineNum">    2786 </span>            :     xpc::WrapperFactory::Rewrap,
<span class="lineNum">    2787 </span>            :     xpc::WrapperFactory::PrepareForWrapping
<a name="2788"><span class="lineNum">    2788 </span>            : };</a>
<span class="lineNum">    2789 </span>            : 
<span class="lineNum">    2790 </span><span class="lineCov">          3 : XPCJSRuntime::XPCJSRuntime(JSContext* aCx)</span>
<span class="lineNum">    2791 </span>            :  : CycleCollectedJSRuntime(aCx),
<span class="lineNum">    2792 </span><span class="lineCov">          3 :    mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_LENGTH)),</span>
<span class="lineNum">    2793 </span><span class="lineCov">          3 :    mWrappedJSClassMap(IID2WrappedJSClassMap::newMap(XPC_JS_CLASS_MAP_LENGTH)),</span>
<span class="lineNum">    2794 </span><span class="lineCov">          3 :    mIID2NativeInterfaceMap(IID2NativeInterfaceMap::newMap(XPC_NATIVE_INTERFACE_MAP_LENGTH)),</span>
<span class="lineNum">    2795 </span><span class="lineCov">          3 :    mClassInfo2NativeSetMap(ClassInfo2NativeSetMap::newMap(XPC_NATIVE_SET_MAP_LENGTH)),</span>
<span class="lineNum">    2796 </span><span class="lineCov">          3 :    mNativeSetMap(NativeSetMap::newMap(XPC_NATIVE_SET_MAP_LENGTH)),</span>
<span class="lineNum">    2797 </span><span class="lineCov">          3 :    mThisTranslatorMap(IID2ThisTranslatorMap::newMap(XPC_THIS_TRANSLATOR_MAP_LENGTH)),</span>
<span class="lineNum">    2798 </span><span class="lineCov">          3 :    mDyingWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DYING_NATIVE_PROTO_MAP_LENGTH)),</span>
<span class="lineNum">    2799 </span>            :    mGCIsRunning(false),
<span class="lineNum">    2800 </span>            :    mNativesToReleaseArray(),
<span class="lineNum">    2801 </span>            :    mDoingFinalization(false),
<span class="lineNum">    2802 </span>            :    mVariantRoots(nullptr),
<span class="lineNum">    2803 </span>            :    mWrappedJSRoots(nullptr),
<span class="lineNum">    2804 </span><span class="lineCov">         27 :    mAsyncSnowWhiteFreer(new AsyncFreeSnowWhite())</span>
<span class="lineNum">    2805 </span>            : {
<span class="lineNum">    2806 </span><span class="lineCov">          3 :     MOZ_COUNT_CTOR_INHERITED(XPCJSRuntime, CycleCollectedJSRuntime);</span>
<span class="lineNum">    2807 </span><span class="lineCov">          3 : }</span>
<span class="lineNum">    2808 </span>            : 
<a name="2809"><span class="lineNum">    2809 </span>            : /* static */</a>
<span class="lineNum">    2810 </span>            : XPCJSRuntime*
<span class="lineNum">    2811 </span><span class="lineCov">      36382 : XPCJSRuntime::Get()</span>
<span class="lineNum">    2812 </span>            : {
<span class="lineNum">    2813 </span><span class="lineCov">      36382 :     return nsXPConnect::GetRuntimeInstance();</span>
<span class="lineNum">    2814 </span>            : }
<a name="2815"><span class="lineNum">    2815 </span>            : </a>
<span class="lineNum">    2816 </span>            : void
<span class="lineNum">    2817 </span><span class="lineCov">          3 : XPCJSRuntime::Initialize(JSContext* cx)</span>
<span class="lineNum">    2818 </span>            : {
<span class="lineNum">    2819 </span><span class="lineCov">          3 :     mUnprivilegedJunkScope.init(cx, nullptr);</span>
<span class="lineNum">    2820 </span><span class="lineCov">          3 :     mPrivilegedJunkScope.init(cx, nullptr);</span>
<span class="lineNum">    2821 </span><span class="lineCov">          3 :     mCompilationScope.init(cx, nullptr);</span>
<span class="lineNum">    2822 </span>            : 
<span class="lineNum">    2823 </span>            :     // these jsids filled in later when we have a JSContext to work with.
<span class="lineNum">    2824 </span><span class="lineCov">          3 :     mStrIDs[0] = JSID_VOID;</span>
<span class="lineNum">    2825 </span>            : 
<span class="lineNum">    2826 </span>            :     // Unconstrain the runtime's threshold on nominal heap size, to avoid
<span class="lineNum">    2827 </span>            :     // triggering GC too often if operating continuously near an arbitrary
<span class="lineNum">    2828 </span>            :     // finite threshold (0xffffffff is infinity for uint32_t parameters).
<span class="lineNum">    2829 </span>            :     // This leaves the maximum-JS_malloc-bytes threshold still in effect
<span class="lineNum">    2830 </span>            :     // to cause period, and we hope hygienic, last-ditch GCs from within
<span class="lineNum">    2831 </span>            :     // the GC's allocator.
<span class="lineNum">    2832 </span><span class="lineCov">          3 :     JS_SetGCParameter(cx, JSGC_MAX_BYTES, 0xffffffff);</span>
<span class="lineNum">    2833 </span>            : 
<span class="lineNum">    2834 </span><span class="lineCov">          3 :     JS_SetDestroyCompartmentCallback(cx, CompartmentDestroyedCallback);</span>
<span class="lineNum">    2835 </span><span class="lineCov">          3 :     JS_SetSizeOfIncludingThisCompartmentCallback(cx, CompartmentSizeOfIncludingThisCallback);</span>
<span class="lineNum">    2836 </span><span class="lineCov">          3 :     JS_SetCompartmentNameCallback(cx, CompartmentNameCallback);</span>
<span class="lineNum">    2837 </span><span class="lineCov">          3 :     mPrevGCSliceCallback = JS::SetGCSliceCallback(cx, GCSliceCallback);</span>
<span class="lineNum">    2838 </span><span class="lineCov">          3 :     mPrevDoCycleCollectionCallback = JS::SetDoCycleCollectionCallback(cx,</span>
<span class="lineNum">    2839 </span>            :             DoCycleCollectionCallback);
<span class="lineNum">    2840 </span><span class="lineCov">          3 :     JS_AddFinalizeCallback(cx, FinalizeCallback, nullptr);</span>
<span class="lineNum">    2841 </span><span class="lineCov">          3 :     JS_AddWeakPointerZonesCallback(cx, WeakPointerZonesCallback, this);</span>
<span class="lineNum">    2842 </span><span class="lineCov">          3 :     JS_AddWeakPointerCompartmentCallback(cx, WeakPointerCompartmentCallback, this);</span>
<span class="lineNum">    2843 </span><span class="lineCov">          3 :     JS_SetWrapObjectCallbacks(cx, &amp;WrapObjectCallbacks);</span>
<span class="lineNum">    2844 </span><span class="lineCov">          3 :     js::SetPreserveWrapperCallback(cx, PreserveWrapper);</span>
<span class="lineNum">    2845 </span><span class="lineCov">          3 :     JS_SetAccumulateTelemetryCallback(cx, AccumulateTelemetryCallback);</span>
<span class="lineNum">    2846 </span><span class="lineCov">          3 :     js::SetWindowProxyClass(cx, &amp;OuterWindowProxyClass);</span>
<span class="lineNum">    2847 </span><span class="lineCov">          3 :     JS::SetProcessLargeAllocationFailureCallback(OnLargeAllocationFailureCallback);</span>
<span class="lineNum">    2848 </span>            : 
<span class="lineNum">    2849 </span>            :     // The JS engine needs to keep the source code around in order to implement
<span class="lineNum">    2850 </span>            :     // Function.prototype.toSource(). It'd be nice to not have to do this for
<span class="lineNum">    2851 </span>            :     // chrome code and simply stub out requests for source on it. Life is not so
<span class="lineNum">    2852 </span>            :     // easy, unfortunately. Nobody relies on chrome toSource() working in core
<span class="lineNum">    2853 </span>            :     // browser code, but chrome tests use it. The worst offenders are addons,
<span class="lineNum">    2854 </span>            :     // which like to monkeypatch chrome functions by calling toSource() on them
<span class="lineNum">    2855 </span>            :     // and using regular expressions to modify them. We avoid keeping most browser
<span class="lineNum">    2856 </span>            :     // JS source code in memory by setting LAZY_SOURCE on JS::CompileOptions when
<span class="lineNum">    2857 </span>            :     // compiling some chrome code. This causes the JS engine not save the source
<span class="lineNum">    2858 </span>            :     // code in memory. When the JS engine is asked to provide the source for a
<span class="lineNum">    2859 </span>            :     // function compiled with LAZY_SOURCE, it calls SourceHook to load it.
<span class="lineNum">    2860 </span>            :     ///
<span class="lineNum">    2861 </span>            :     // Note we do have to retain the source code in memory for scripts compiled in
<span class="lineNum">    2862 </span>            :     // isRunOnce mode and compiled function bodies (from
<span class="lineNum">    2863 </span>            :     // JS::CompileFunction). In practice, this means content scripts and event
<span class="lineNum">    2864 </span>            :     // handlers.
<span class="lineNum">    2865 </span><span class="lineCov">          6 :     mozilla::UniquePtr&lt;XPCJSSourceHook&gt; hook(new XPCJSSourceHook);</span>
<span class="lineNum">    2866 </span><span class="lineCov">          3 :     js::SetSourceHook(cx, Move(hook));</span>
<span class="lineNum">    2867 </span>            : 
<span class="lineNum">    2868 </span>            :     // Register memory reporters and distinguished amount functions.
<span class="lineNum">    2869 </span><span class="lineCov">          3 :     RegisterStrongMemoryReporter(new JSMainRuntimeCompartmentsReporter());</span>
<span class="lineNum">    2870 </span><span class="lineCov">          3 :     RegisterStrongMemoryReporter(new JSMainRuntimeTemporaryPeakReporter());</span>
<span class="lineNum">    2871 </span><span class="lineCov">          3 :     RegisterJSMainRuntimeGCHeapDistinguishedAmount(JSMainRuntimeGCHeapDistinguishedAmount);</span>
<span class="lineNum">    2872 </span><span class="lineCov">          3 :     RegisterJSMainRuntimeTemporaryPeakDistinguishedAmount(JSMainRuntimeTemporaryPeakDistinguishedAmount);</span>
<span class="lineNum">    2873 </span><span class="lineCov">          3 :     RegisterJSMainRuntimeCompartmentsSystemDistinguishedAmount(JSMainRuntimeCompartmentsSystemDistinguishedAmount);</span>
<span class="lineNum">    2874 </span><span class="lineCov">          3 :     RegisterJSMainRuntimeCompartmentsUserDistinguishedAmount(JSMainRuntimeCompartmentsUserDistinguishedAmount);</span>
<span class="lineNum">    2875 </span><span class="lineCov">          3 :     mozilla::RegisterJSSizeOfTab(JSSizeOfTab);</span>
<span class="lineNum">    2876 </span><span class="lineCov">          3 : }</span>
<a name="2877"><span class="lineNum">    2877 </span>            : </a>
<span class="lineNum">    2878 </span>            : bool
<span class="lineNum">    2879 </span><span class="lineCov">          3 : XPCJSRuntime::InitializeStrings(JSContext* cx)</span>
<span class="lineNum">    2880 </span>            : {
<span class="lineNum">    2881 </span><span class="lineCov">          6 :     JSAutoRequest ar(cx);</span>
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span>            :     // if it is our first context then we need to generate our string ids
<span class="lineNum">    2884 </span><span class="lineCov">          3 :     if (JSID_IS_VOID(mStrIDs[0])) {</span>
<span class="lineNum">    2885 </span><span class="lineCov">          6 :         RootedString str(cx);</span>
<span class="lineNum">    2886 </span><span class="lineCov">         96 :         for (unsigned i = 0; i &lt; XPCJSContext::IDX_TOTAL_COUNT; i++) {</span>
<span class="lineNum">    2887 </span><span class="lineCov">         93 :             str = JS_AtomizeAndPinString(cx, mStrings[i]);</span>
<span class="lineNum">    2888 </span><span class="lineCov">         93 :             if (!str) {</span>
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :                 mStrIDs[0] = JSID_VOID;</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    2891 </span>            :             }
<span class="lineNum">    2892 </span><span class="lineCov">         93 :             mStrIDs[i] = INTERNED_STRING_TO_JSID(cx, str);</span>
<span class="lineNum">    2893 </span><span class="lineCov">         93 :             mStrJSVals[i].setString(str);</span>
<span class="lineNum">    2894 </span>            :         }
<span class="lineNum">    2895 </span>            : 
<span class="lineNum">    2896 </span><span class="lineCov">          3 :         if (!mozilla::dom::DefineStaticJSVals(cx)) {</span>
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    2898 </span>            :         }
<span class="lineNum">    2899 </span>            :     }
<span class="lineNum">    2900 </span>            : 
<span class="lineNum">    2901 </span><span class="lineCov">          3 :     return true;</span>
<span class="lineNum">    2902 </span>            : }
<a name="2903"><span class="lineNum">    2903 </span>            : </a>
<span class="lineNum">    2904 </span>            : bool
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 : XPCJSRuntime::DescribeCustomObjects(JSObject* obj, const js::Class* clasp,</span>
<span class="lineNum">    2906 </span>            :                                     char (&amp;name)[72]) const
<span class="lineNum">    2907 </span>            : {
<span class="lineNum">    2908 </span>            : 
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :     if (!IS_PROTO_CLASS(clasp)) {</span>
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2911 </span>            :     }
<span class="lineNum">    2912 </span>            : 
<span class="lineNum">    2913 </span>            :     XPCWrappedNativeProto* p =
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCWrappedNativeProto*&gt;(xpc_GetJSPrivate(obj));</span>
<span class="lineNum">    2915 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIXPCScriptable&gt; scr = p-&gt;GetScriptable();</span>
<span class="lineNum">    2916 </span><span class="lineNoCov">          0 :     if (!scr) {</span>
<span class="lineNum">    2917 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2918 </span>            :     }
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span>            :     SprintfLiteral(name, &quot;JS Object (%s - %s)&quot;,
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :                    clasp-&gt;name, scr-&gt;GetJSClass()-&gt;name);</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2923 </span>            : }
<a name="2924"><span class="lineNum">    2924 </span>            : </a>
<span class="lineNum">    2925 </span>            : bool
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 : XPCJSRuntime::NoteCustomGCThingXPCOMChildren(const js::Class* clasp, JSObject* obj,</span>
<span class="lineNum">    2927 </span>            :                                              nsCycleCollectionTraversalCallback&amp; cb) const
<span class="lineNum">    2928 </span>            : {
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :     if (clasp != &amp;XPC_WN_Tearoff_JSClass) {</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2931 </span>            :     }
<span class="lineNum">    2932 </span>            : 
<span class="lineNum">    2933 </span>            :     // A tearoff holds a strong reference to its native object
<span class="lineNum">    2934 </span>            :     // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
<span class="lineNum">    2935 </span>            :     // will be held alive through the parent of the JSObject of the tearoff.
<span class="lineNum">    2936 </span>            :     XPCWrappedNativeTearOff* to =
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :         static_cast&lt;XPCWrappedNativeTearOff*&gt;(xpc_GetJSPrivate(obj));</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, &quot;xpc_GetJSPrivate(obj)-&gt;mNative&quot;);</span>
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :     cb.NoteXPCOMChild(to-&gt;GetNative());</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    2941 </span>            : }
<span class="lineNum">    2942 </span>            : 
<span class="lineNum">    2943 </span>            : /***************************************************************************/
<a name="2944"><span class="lineNum">    2944 </span>            : </a>
<span class="lineNum">    2945 </span>            : void
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 : XPCJSRuntime::DebugDump(int16_t depth)</span>
<span class="lineNum">    2947 </span>            : {
<span class="lineNum">    2948 </span>            : #ifdef DEBUG
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :     depth--;</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :     XPC_LOG_ALWAYS((&quot;XPCJSRuntime @ %p&quot;, this));</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :         XPC_LOG_INDENT();</span>
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mWrappedJSClassMap @ %p with %d wrapperclasses(s)&quot;,</span>
<span class="lineNum">    2954 </span>            :                         mWrappedJSClassMap, mWrappedJSClassMap-&gt;Count()));
<span class="lineNum">    2955 </span>            :         // iterate wrappersclasses...
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :         if (depth &amp;&amp; mWrappedJSClassMap-&gt;Count()) {</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :             XPC_LOG_INDENT();</span>
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :             for (auto i = mWrappedJSClassMap-&gt;Iter(); !i.Done(); i.Next()) {</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                 auto entry = static_cast&lt;IID2WrappedJSClassMap::Entry*&gt;(i.Get());</span>
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :                 entry-&gt;value-&gt;DebugDump(depth);</span>
<span class="lineNum">    2961 </span>            :             }
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :             XPC_LOG_OUTDENT();</span>
<span class="lineNum">    2963 </span>            :         }
<span class="lineNum">    2964 </span>            : 
<span class="lineNum">    2965 </span>            :         // iterate wrappers...
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mWrappedJSMap @ %p with %d wrappers(s)&quot;,</span>
<span class="lineNum">    2967 </span>            :                         mWrappedJSMap, mWrappedJSMap-&gt;Count()));
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :         if (depth &amp;&amp; mWrappedJSMap-&gt;Count()) {</span>
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :             XPC_LOG_INDENT();</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :             mWrappedJSMap-&gt;Dump(depth);</span>
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :             XPC_LOG_OUTDENT();</span>
<span class="lineNum">    2972 </span>            :         }
<span class="lineNum">    2973 </span>            : 
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mIID2NativeInterfaceMap @ %p with %d interface(s)&quot;,</span>
<span class="lineNum">    2975 </span>            :                         mIID2NativeInterfaceMap,
<span class="lineNum">    2976 </span>            :                         mIID2NativeInterfaceMap-&gt;Count()));
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mClassInfo2NativeSetMap @ %p with %d sets(s)&quot;,</span>
<span class="lineNum">    2979 </span>            :                         mClassInfo2NativeSetMap,
<span class="lineNum">    2980 </span>            :                         mClassInfo2NativeSetMap-&gt;Count()));
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mThisTranslatorMap @ %p with %d translator(s)&quot;,</span>
<span class="lineNum">    2983 </span>            :                         mThisTranslatorMap, mThisTranslatorMap-&gt;Count()));
<span class="lineNum">    2984 </span>            : 
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :         XPC_LOG_ALWAYS((&quot;mNativeSetMap @ %p with %d sets(s)&quot;,</span>
<span class="lineNum">    2986 </span>            :                         mNativeSetMap, mNativeSetMap-&gt;Count()));
<span class="lineNum">    2987 </span>            : 
<span class="lineNum">    2988 </span>            :         // iterate sets...
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :         if (depth &amp;&amp; mNativeSetMap-&gt;Count()) {</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :             XPC_LOG_INDENT();</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :             for (auto i = mNativeSetMap-&gt;Iter(); !i.Done(); i.Next()) {</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :                 auto entry = static_cast&lt;NativeSetMap::Entry*&gt;(i.Get());</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :                 entry-&gt;key_value-&gt;DebugDump(depth);</span>
<span class="lineNum">    2994 </span>            :             }
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :             XPC_LOG_OUTDENT();</span>
<span class="lineNum">    2996 </span>            :         }
<span class="lineNum">    2997 </span>            : 
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :         XPC_LOG_OUTDENT();</span>
<span class="lineNum">    2999 </span>            : #endif
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3001 </span>            : 
<span class="lineNum">    3002 </span>            : /***************************************************************************/
<a name="3003"><span class="lineNum">    3003 </span>            : </a>
<span class="lineNum">    3004 </span>            : void
<span class="lineNum">    3005 </span><span class="lineCov">        978 : XPCRootSetElem::AddToRootSet(XPCRootSetElem** listHead)</span>
<span class="lineNum">    3006 </span>            : {
<span class="lineNum">    3007 </span><span class="lineCov">        978 :     MOZ_ASSERT(!mSelfp, &quot;Must be not linked&quot;);</span>
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span><span class="lineCov">        978 :     mSelfp = listHead;</span>
<span class="lineNum">    3010 </span><span class="lineCov">        978 :     mNext = *listHead;</span>
<span class="lineNum">    3011 </span><span class="lineCov">        978 :     if (mNext) {</span>
<span class="lineNum">    3012 </span><span class="lineCov">        974 :         MOZ_ASSERT(mNext-&gt;mSelfp == listHead, &quot;Must be list start&quot;);</span>
<span class="lineNum">    3013 </span><span class="lineCov">        974 :         mNext-&gt;mSelfp = &amp;mNext;</span>
<span class="lineNum">    3014 </span>            :     }
<span class="lineNum">    3015 </span><span class="lineCov">        978 :     *listHead = this;</span>
<span class="lineNum">    3016 </span><span class="lineCov">        978 : }</span>
<a name="3017"><span class="lineNum">    3017 </span>            : </a>
<span class="lineNum">    3018 </span>            : void
<span class="lineNum">    3019 </span><span class="lineCov">        218 : XPCRootSetElem::RemoveFromRootSet()</span>
<span class="lineNum">    3020 </span>            : {
<span class="lineNum">    3021 </span><span class="lineCov">        218 :     JS::NotifyGCRootsRemoved(XPCJSContext::Get()-&gt;Context());</span>
<span class="lineNum">    3022 </span>            : 
<span class="lineNum">    3023 </span><span class="lineCov">        218 :     MOZ_ASSERT(mSelfp, &quot;Must be linked&quot;);</span>
<span class="lineNum">    3024 </span>            : 
<span class="lineNum">    3025 </span><span class="lineCov">        218 :     MOZ_ASSERT(*mSelfp == this, &quot;Link invariant&quot;);</span>
<span class="lineNum">    3026 </span><span class="lineCov">        218 :     *mSelfp = mNext;</span>
<span class="lineNum">    3027 </span><span class="lineCov">        218 :     if (mNext)</span>
<span class="lineNum">    3028 </span><span class="lineCov">        217 :         mNext-&gt;mSelfp = mSelfp;</span>
<span class="lineNum">    3029 </span>            : #ifdef DEBUG
<span class="lineNum">    3030 </span><span class="lineCov">        218 :     mSelfp = nullptr;</span>
<span class="lineNum">    3031 </span><span class="lineCov">        218 :     mNext = nullptr;</span>
<span class="lineNum">    3032 </span>            : #endif
<span class="lineNum">    3033 </span><span class="lineCov">        218 : }</span>
<a name="3034"><span class="lineNum">    3034 </span>            : </a>
<span class="lineNum">    3035 </span>            : void
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 : XPCJSRuntime::AddGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    3037 </span>            : {
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(cb, &quot;null callback&quot;);</span>
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :     extraGCCallbacks.AppendElement(cb);</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 : }</span>
<a name="3041"><span class="lineNum">    3041 </span>            : </a>
<span class="lineNum">    3042 </span>            : void
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 : XPCJSRuntime::RemoveGCCallback(xpcGCCallback cb)</span>
<span class="lineNum">    3044 </span>            : {
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(cb, &quot;null callback&quot;);</span>
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :     bool found = extraGCCallbacks.RemoveElement(cb);</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :     if (!found) {</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :         NS_ERROR(&quot;Removing a callback which was never added.&quot;);</span>
<span class="lineNum">    3049 </span>            :     }
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 : }</span>
<a name="3051"><span class="lineNum">    3051 </span>            : </a>
<span class="lineNum">    3052 </span>            : void
<span class="lineNum">    3053 </span><span class="lineCov">          3 : XPCJSRuntime::InitSingletonScopes()</span>
<span class="lineNum">    3054 </span>            : {
<span class="lineNum">    3055 </span>            :     // This all happens very early, so we don't bother with cx pushing.
<span class="lineNum">    3056 </span><span class="lineCov">          3 :     JSContext* cx = XPCJSContext::Get()-&gt;Context();</span>
<span class="lineNum">    3057 </span><span class="lineCov">          6 :     JSAutoRequest ar(cx);</span>
<span class="lineNum">    3058 </span><span class="lineCov">          6 :     RootedValue v(cx);</span>
<span class="lineNum">    3059 </span>            :     nsresult rv;
<span class="lineNum">    3060 </span>            : 
<span class="lineNum">    3061 </span>            :     // Create the Unprivileged Junk Scope.
<span class="lineNum">    3062 </span><span class="lineCov">          6 :     SandboxOptions unprivilegedJunkScopeOptions;</span>
<span class="lineNum">    3063 </span><span class="lineCov">          3 :     unprivilegedJunkScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Junk Compartment&quot;);</span>
<span class="lineNum">    3064 </span><span class="lineCov">          3 :     unprivilegedJunkScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3065 </span><span class="lineCov">          3 :     rv = CreateSandboxObject(cx, &amp;v, nullptr, unprivilegedJunkScopeOptions);</span>
<span class="lineNum">    3066 </span><span class="lineCov">          3 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3067 </span><span class="lineCov">          3 :     mUnprivilegedJunkScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3068 </span>            : 
<span class="lineNum">    3069 </span>            :     // Create the Privileged Junk Scope.
<span class="lineNum">    3070 </span><span class="lineCov">          6 :     SandboxOptions privilegedJunkScopeOptions;</span>
<span class="lineNum">    3071 </span><span class="lineCov">          3 :     privilegedJunkScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Privileged Junk Compartment&quot;);</span>
<span class="lineNum">    3072 </span><span class="lineCov">          3 :     privilegedJunkScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3073 </span><span class="lineCov">          3 :     privilegedJunkScopeOptions.wantComponents = false;</span>
<span class="lineNum">    3074 </span><span class="lineCov">          3 :     rv = CreateSandboxObject(cx, &amp;v, nsXPConnect::SystemPrincipal(), privilegedJunkScopeOptions);</span>
<span class="lineNum">    3075 </span><span class="lineCov">          3 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3076 </span><span class="lineCov">          3 :     mPrivilegedJunkScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3077 </span>            : 
<span class="lineNum">    3078 </span>            :     // Create the Compilation Scope.
<span class="lineNum">    3079 </span><span class="lineCov">          6 :     SandboxOptions compilationScopeOptions;</span>
<span class="lineNum">    3080 </span><span class="lineCov">          3 :     compilationScopeOptions.sandboxName.AssignLiteral(&quot;XPConnect Compilation Compartment&quot;);</span>
<span class="lineNum">    3081 </span><span class="lineCov">          3 :     compilationScopeOptions.invisibleToDebugger = true;</span>
<span class="lineNum">    3082 </span><span class="lineCov">          3 :     compilationScopeOptions.discardSource = ShouldDiscardSystemSource();</span>
<span class="lineNum">    3083 </span><span class="lineCov">          3 :     rv = CreateSandboxObject(cx, &amp;v, /* principal = */ nullptr, compilationScopeOptions);</span>
<span class="lineNum">    3084 </span><span class="lineCov">          3 :     MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));</span>
<span class="lineNum">    3085 </span><span class="lineCov">          3 :     mCompilationScope = js::UncheckedUnwrap(&amp;v.toObject());</span>
<span class="lineNum">    3086 </span><span class="lineCov">          3 : }</span>
<a name="3087"><span class="lineNum">    3087 </span>            : </a>
<span class="lineNum">    3088 </span>            : void
<span class="lineNum">    3089 </span><span class="lineNoCov">          0 : XPCJSRuntime::DeleteSingletonScopes()</span>
<span class="lineNum">    3090 </span>            : {
<span class="lineNum">    3091 </span><span class="lineNoCov">          0 :     mUnprivilegedJunkScope = nullptr;</span>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :     mPrivilegedJunkScope = nullptr;</span>
<span class="lineNum">    3093 </span><span class="lineNoCov">          0 :     mCompilationScope = nullptr;</span>
<span class="lineNum">    3094 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

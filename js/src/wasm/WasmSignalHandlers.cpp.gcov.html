<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/wasm/WasmSignalHandlers.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/wasm</a> - WasmSignalHandlers.cpp<span style="font-size: 80%;"> (source / <a href="WasmSignalHandlers.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">51</td>
            <td class="headerCovTableEntry">309</td>
            <td class="headerCovTableEntryLo">16.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntryLo">27.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright 2014 Mozilla Foundation
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       7 </span>            :  * you may not use this file except in compliance with the License.
<span class="lineNum">       8 </span>            :  * You may obtain a copy of the License at
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *     http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      13 </span>            :  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      14 </span>            :  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      15 </span>            :  * See the License for the specific language governing permissions and
<span class="lineNum">      16 </span>            :  * limitations under the License.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;wasm/WasmSignalHandlers.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/PodOperations.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/ScopeExit.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #include &quot;jit/AtomicOperations.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;jit/Disassembler.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;vm/Runtime.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;wasm/WasmBuiltins.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;wasm/WasmInstance.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : using namespace js;
<span class="lineNum">      32 </span>            : using namespace js::jit;
<span class="lineNum">      33 </span>            : using namespace js::wasm;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : using JS::GenericNaN;
<span class="lineNum">      36 </span>            : using mozilla::DebugOnly;
<span class="lineNum">      37 </span>            : using mozilla::PodArrayZero;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #if defined(ANDROID)
<span class="lineNum">      40 </span>            : # include &lt;sys/system_properties.h&gt;
<span class="lineNum">      41 </span>            : # if defined(MOZ_LINKER)
<span class="lineNum">      42 </span>            : extern &quot;C&quot; MFBT_API bool IsSignalHandlingBroken();
<span class="lineNum">      43 </span>            : # endif
<span class="lineNum">      44 </span>            : #endif
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : // Crashing inside the signal handler can cause the handler to be recursively
<span class="lineNum">      47 </span>            : // invoked, eventually blowing the stack without actually showing a crash
<span class="lineNum">      48 </span>            : // report dialog via Breakpad. To guard against this we watch for such
<span class="lineNum">      49 </span>            : // recursion and fall through to the next handler immediately rather than
<span class="lineNum">      50 </span>            : // trying to handle it.
<span class="lineNum">      51 </span>            : class AutoSetHandlingSegFault
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            :     JSContext* cx;
<a name="54"><span class="lineNum">      54 </span>            : </a>
<span class="lineNum">      55 </span>            :   public:
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :     explicit AutoSetHandlingSegFault(JSContext* cx)</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :       : cx(cx)</span>
<span class="lineNum">      58 </span>            :     {
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!cx-&gt;handlingSegFault);</span>
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :         cx-&gt;handlingSegFault = true;</span>
<a name="61"><span class="lineNum">      61 </span><span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     ~AutoSetHandlingSegFault()</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(cx-&gt;handlingSegFault);</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :         cx-&gt;handlingSegFault = false;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      68 </span>            : };
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #if defined(XP_WIN)
<span class="lineNum">      71 </span>            : # define XMM_sig(p,i) ((p)-&gt;Xmm##i)
<span class="lineNum">      72 </span>            : # define EIP_sig(p) ((p)-&gt;Eip)
<span class="lineNum">      73 </span>            : # define EBP_sig(p) ((p)-&gt;Ebp)
<span class="lineNum">      74 </span>            : # define ESP_sig(p) ((p)-&gt;Esp)
<span class="lineNum">      75 </span>            : # define RIP_sig(p) ((p)-&gt;Rip)
<span class="lineNum">      76 </span>            : # define RAX_sig(p) ((p)-&gt;Rax)
<span class="lineNum">      77 </span>            : # define RCX_sig(p) ((p)-&gt;Rcx)
<span class="lineNum">      78 </span>            : # define RDX_sig(p) ((p)-&gt;Rdx)
<span class="lineNum">      79 </span>            : # define RBX_sig(p) ((p)-&gt;Rbx)
<span class="lineNum">      80 </span>            : # define RSP_sig(p) ((p)-&gt;Rsp)
<span class="lineNum">      81 </span>            : # define RBP_sig(p) ((p)-&gt;Rbp)
<span class="lineNum">      82 </span>            : # define RSI_sig(p) ((p)-&gt;Rsi)
<span class="lineNum">      83 </span>            : # define RDI_sig(p) ((p)-&gt;Rdi)
<span class="lineNum">      84 </span>            : # define R8_sig(p) ((p)-&gt;R8)
<span class="lineNum">      85 </span>            : # define R9_sig(p) ((p)-&gt;R9)
<span class="lineNum">      86 </span>            : # define R10_sig(p) ((p)-&gt;R10)
<span class="lineNum">      87 </span>            : # define R11_sig(p) ((p)-&gt;R11)
<span class="lineNum">      88 </span>            : # define R12_sig(p) ((p)-&gt;R12)
<span class="lineNum">      89 </span>            : # define R13_sig(p) ((p)-&gt;R13)
<span class="lineNum">      90 </span>            : # define R14_sig(p) ((p)-&gt;R14)
<span class="lineNum">      91 </span>            : # define R15_sig(p) ((p)-&gt;R15)
<span class="lineNum">      92 </span>            : #elif defined(__OpenBSD__)
<span class="lineNum">      93 </span>            : # define XMM_sig(p,i) ((p)-&gt;sc_fpstate-&gt;fx_xmm[i])
<span class="lineNum">      94 </span>            : # define EIP_sig(p) ((p)-&gt;sc_eip)
<span class="lineNum">      95 </span>            : # define EBP_sig(p) ((p)-&gt;sc_ebp)
<span class="lineNum">      96 </span>            : # define ESP_sig(p) ((p)-&gt;sc_esp)
<span class="lineNum">      97 </span>            : # define RIP_sig(p) ((p)-&gt;sc_rip)
<span class="lineNum">      98 </span>            : # define RAX_sig(p) ((p)-&gt;sc_rax)
<span class="lineNum">      99 </span>            : # define RCX_sig(p) ((p)-&gt;sc_rcx)
<span class="lineNum">     100 </span>            : # define RDX_sig(p) ((p)-&gt;sc_rdx)
<span class="lineNum">     101 </span>            : # define RBX_sig(p) ((p)-&gt;sc_rbx)
<span class="lineNum">     102 </span>            : # define RSP_sig(p) ((p)-&gt;sc_rsp)
<span class="lineNum">     103 </span>            : # define RBP_sig(p) ((p)-&gt;sc_rbp)
<span class="lineNum">     104 </span>            : # define RSI_sig(p) ((p)-&gt;sc_rsi)
<span class="lineNum">     105 </span>            : # define RDI_sig(p) ((p)-&gt;sc_rdi)
<span class="lineNum">     106 </span>            : # define R8_sig(p) ((p)-&gt;sc_r8)
<span class="lineNum">     107 </span>            : # define R9_sig(p) ((p)-&gt;sc_r9)
<span class="lineNum">     108 </span>            : # define R10_sig(p) ((p)-&gt;sc_r10)
<span class="lineNum">     109 </span>            : # define R11_sig(p) ((p)-&gt;sc_r11)
<span class="lineNum">     110 </span>            : # define R12_sig(p) ((p)-&gt;sc_r12)
<span class="lineNum">     111 </span>            : # if defined(__arm__)
<span class="lineNum">     112 </span>            : #  define R13_sig(p) ((p)-&gt;sc_usr_sp)
<span class="lineNum">     113 </span>            : #  define R14_sig(p) ((p)-&gt;sc_usr_lr)
<span class="lineNum">     114 </span>            : #  define R15_sig(p) ((p)-&gt;sc_pc)
<span class="lineNum">     115 </span>            : # else
<span class="lineNum">     116 </span>            : #  define R13_sig(p) ((p)-&gt;sc_r13)
<span class="lineNum">     117 </span>            : #  define R14_sig(p) ((p)-&gt;sc_r14)
<span class="lineNum">     118 </span>            : #  define R15_sig(p) ((p)-&gt;sc_r15)
<span class="lineNum">     119 </span>            : # endif
<span class="lineNum">     120 </span>            : # if defined(__aarch64__)
<span class="lineNum">     121 </span>            : #  define EPC_sig(p) ((p)-&gt;sc_elr)
<span class="lineNum">     122 </span>            : #  define RFP_sig(p) ((p)-&gt;sc_x[29])
<span class="lineNum">     123 </span>            : #  define RLR_sig(p) ((p)-&gt;sc_lr)
<span class="lineNum">     124 </span>            : #  define R31_sig(p) ((p)-&gt;sc_sp)
<span class="lineNum">     125 </span>            : # endif
<span class="lineNum">     126 </span>            : # if defined(__mips__)
<span class="lineNum">     127 </span>            : #  define EPC_sig(p) ((p)-&gt;sc_pc)
<span class="lineNum">     128 </span>            : #  define RFP_sig(p) ((p)-&gt;sc_regs[30])
<span class="lineNum">     129 </span>            : # endif
<span class="lineNum">     130 </span>            : #elif defined(__linux__) || defined(__sun)
<span class="lineNum">     131 </span>            : # if defined(__linux__)
<span class="lineNum">     132 </span>            : #  define XMM_sig(p,i) ((p)-&gt;uc_mcontext.fpregs-&gt;_xmm[i])
<span class="lineNum">     133 </span>            : #  define EIP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_EIP])
<span class="lineNum">     134 </span>            : #  define EBP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_EBP])
<span class="lineNum">     135 </span>            : #  define ESP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_ESP])
<span class="lineNum">     136 </span>            : # else
<span class="lineNum">     137 </span>            : #  define XMM_sig(p,i) ((p)-&gt;uc_mcontext.fpregs.fp_reg_set.fpchip_state.xmm[i])
<span class="lineNum">     138 </span>            : #  define EIP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_PC])
<span class="lineNum">     139 </span>            : #  define EBP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_EBP])
<span class="lineNum">     140 </span>            : #  define ESP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_ESP])
<span class="lineNum">     141 </span>            : # endif
<span class="lineNum">     142 </span>            : # define RIP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RIP])
<span class="lineNum">     143 </span>            : # define RAX_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RAX])
<span class="lineNum">     144 </span>            : # define RCX_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RCX])
<span class="lineNum">     145 </span>            : # define RDX_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RDX])
<span class="lineNum">     146 </span>            : # define RBX_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RBX])
<span class="lineNum">     147 </span>            : # define RSP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RSP])
<span class="lineNum">     148 </span>            : # define RBP_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RBP])
<span class="lineNum">     149 </span>            : # define RSI_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RSI])
<span class="lineNum">     150 </span>            : # define RDI_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_RDI])
<span class="lineNum">     151 </span>            : # define R8_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R8])
<span class="lineNum">     152 </span>            : # define R9_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R9])
<span class="lineNum">     153 </span>            : # define R10_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R10])
<span class="lineNum">     154 </span>            : # define R12_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R12])
<span class="lineNum">     155 </span>            : # if defined(__linux__) &amp;&amp; defined(__arm__)
<span class="lineNum">     156 </span>            : #  define R11_sig(p) ((p)-&gt;uc_mcontext.arm_fp)
<span class="lineNum">     157 </span>            : #  define R13_sig(p) ((p)-&gt;uc_mcontext.arm_sp)
<span class="lineNum">     158 </span>            : #  define R14_sig(p) ((p)-&gt;uc_mcontext.arm_lr)
<span class="lineNum">     159 </span>            : #  define R15_sig(p) ((p)-&gt;uc_mcontext.arm_pc)
<span class="lineNum">     160 </span>            : # else
<span class="lineNum">     161 </span>            : #  define R11_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R11])
<span class="lineNum">     162 </span>            : #  define R13_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R13])
<span class="lineNum">     163 </span>            : #  define R14_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R14])
<span class="lineNum">     164 </span>            : #  define R15_sig(p) ((p)-&gt;uc_mcontext.gregs[REG_R15])
<span class="lineNum">     165 </span>            : # endif
<span class="lineNum">     166 </span>            : # if defined(__linux__) &amp;&amp; defined(__aarch64__)
<span class="lineNum">     167 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.pc)
<span class="lineNum">     168 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.regs[29])
<span class="lineNum">     169 </span>            : #  define RLR_sig(p) ((p)-&gt;uc_mcontext.regs[30])
<span class="lineNum">     170 </span>            : #  define R31_sig(p) ((p)-&gt;uc_mcontext.regs[31])
<span class="lineNum">     171 </span>            : # endif
<span class="lineNum">     172 </span>            : # if defined(__linux__) &amp;&amp; defined(__mips__)
<span class="lineNum">     173 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.pc)
<span class="lineNum">     174 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.gregs[30])
<span class="lineNum">     175 </span>            : # endif
<span class="lineNum">     176 </span>            : #elif defined(__NetBSD__)
<span class="lineNum">     177 </span>            : # define XMM_sig(p,i) (((struct fxsave64*)(p)-&gt;uc_mcontext.__fpregs)-&gt;fx_xmm[i])
<span class="lineNum">     178 </span>            : # define EIP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_EIP])
<span class="lineNum">     179 </span>            : # define EBP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_EBP])
<span class="lineNum">     180 </span>            : # define ESP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_ESP])
<span class="lineNum">     181 </span>            : # define RIP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RIP])
<span class="lineNum">     182 </span>            : # define RAX_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RAX])
<span class="lineNum">     183 </span>            : # define RCX_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RCX])
<span class="lineNum">     184 </span>            : # define RDX_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RDX])
<span class="lineNum">     185 </span>            : # define RBX_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RBX])
<span class="lineNum">     186 </span>            : # define RSP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RSP])
<span class="lineNum">     187 </span>            : # define RBP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RBP])
<span class="lineNum">     188 </span>            : # define RSI_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RSI])
<span class="lineNum">     189 </span>            : # define RDI_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_RDI])
<span class="lineNum">     190 </span>            : # define R8_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R8])
<span class="lineNum">     191 </span>            : # define R9_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R9])
<span class="lineNum">     192 </span>            : # define R10_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R10])
<span class="lineNum">     193 </span>            : # define R11_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R11])
<span class="lineNum">     194 </span>            : # define R12_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R12])
<span class="lineNum">     195 </span>            : # define R13_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R13])
<span class="lineNum">     196 </span>            : # define R14_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R14])
<span class="lineNum">     197 </span>            : # define R15_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R15])
<span class="lineNum">     198 </span>            : # if defined(__aarch64__)
<span class="lineNum">     199 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_PC])
<span class="lineNum">     200 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_X29])
<span class="lineNum">     201 </span>            : #  define RLR_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_X30])
<span class="lineNum">     202 </span>            : #  define R31_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_SP])
<span class="lineNum">     203 </span>            : # endif
<span class="lineNum">     204 </span>            : # if defined(__mips__)
<span class="lineNum">     205 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_EPC])
<span class="lineNum">     206 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_S8])
<span class="lineNum">     207 </span>            : # endif
<span class="lineNum">     208 </span>            : #elif defined(__DragonFly__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
<span class="lineNum">     209 </span>            : # if defined(__DragonFly__)
<span class="lineNum">     210 </span>            : #  define XMM_sig(p,i) (((union savefpu*)(p)-&gt;uc_mcontext.mc_fpregs)-&gt;sv_xmm.sv_xmm[i])
<span class="lineNum">     211 </span>            : # else
<span class="lineNum">     212 </span>            : #  define XMM_sig(p,i) (((struct savefpu*)(p)-&gt;uc_mcontext.mc_fpstate)-&gt;sv_xmm[i])
<span class="lineNum">     213 </span>            : # endif
<span class="lineNum">     214 </span>            : # define EIP_sig(p) ((p)-&gt;uc_mcontext.mc_eip)
<span class="lineNum">     215 </span>            : # define EBP_sig(p) ((p)-&gt;uc_mcontext.mc_ebp)
<span class="lineNum">     216 </span>            : # define ESP_sig(p) ((p)-&gt;uc_mcontext.mc_esp)
<span class="lineNum">     217 </span>            : # define RIP_sig(p) ((p)-&gt;uc_mcontext.mc_rip)
<span class="lineNum">     218 </span>            : # define RAX_sig(p) ((p)-&gt;uc_mcontext.mc_rax)
<span class="lineNum">     219 </span>            : # define RCX_sig(p) ((p)-&gt;uc_mcontext.mc_rcx)
<span class="lineNum">     220 </span>            : # define RDX_sig(p) ((p)-&gt;uc_mcontext.mc_rdx)
<span class="lineNum">     221 </span>            : # define RBX_sig(p) ((p)-&gt;uc_mcontext.mc_rbx)
<span class="lineNum">     222 </span>            : # define RSP_sig(p) ((p)-&gt;uc_mcontext.mc_rsp)
<span class="lineNum">     223 </span>            : # define RBP_sig(p) ((p)-&gt;uc_mcontext.mc_rbp)
<span class="lineNum">     224 </span>            : # define RSI_sig(p) ((p)-&gt;uc_mcontext.mc_rsi)
<span class="lineNum">     225 </span>            : # define RDI_sig(p) ((p)-&gt;uc_mcontext.mc_rdi)
<span class="lineNum">     226 </span>            : # define R8_sig(p) ((p)-&gt;uc_mcontext.mc_r8)
<span class="lineNum">     227 </span>            : # define R9_sig(p) ((p)-&gt;uc_mcontext.mc_r9)
<span class="lineNum">     228 </span>            : # define R10_sig(p) ((p)-&gt;uc_mcontext.mc_r10)
<span class="lineNum">     229 </span>            : # define R12_sig(p) ((p)-&gt;uc_mcontext.mc_r12)
<span class="lineNum">     230 </span>            : # if defined(__FreeBSD__) &amp;&amp; defined(__arm__)
<span class="lineNum">     231 </span>            : #  define R11_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R11])
<span class="lineNum">     232 </span>            : #  define R13_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R13])
<span class="lineNum">     233 </span>            : #  define R14_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R14])
<span class="lineNum">     234 </span>            : #  define R15_sig(p) ((p)-&gt;uc_mcontext.__gregs[_REG_R15])
<span class="lineNum">     235 </span>            : # else
<span class="lineNum">     236 </span>            : #  define R11_sig(p) ((p)-&gt;uc_mcontext.mc_r11)
<span class="lineNum">     237 </span>            : #  define R13_sig(p) ((p)-&gt;uc_mcontext.mc_r13)
<span class="lineNum">     238 </span>            : #  define R14_sig(p) ((p)-&gt;uc_mcontext.mc_r14)
<span class="lineNum">     239 </span>            : #  define R15_sig(p) ((p)-&gt;uc_mcontext.mc_r15)
<span class="lineNum">     240 </span>            : # endif
<span class="lineNum">     241 </span>            : # if defined(__FreeBSD__) &amp;&amp; defined(__aarch64__)
<span class="lineNum">     242 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.mc_gpregs.gp_elr)
<span class="lineNum">     243 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.mc_gpregs.gp_x[29])
<span class="lineNum">     244 </span>            : #  define RLR_sig(p) ((p)-&gt;uc_mcontext.mc_gpregs.gp_lr)
<span class="lineNum">     245 </span>            : #  define R31_sig(p) ((p)-&gt;uc_mcontext.mc_gpregs.gp_sp)
<span class="lineNum">     246 </span>            : # endif
<span class="lineNum">     247 </span>            : # if defined(__FreeBSD__) &amp;&amp; defined(__mips__)
<span class="lineNum">     248 </span>            : #  define EPC_sig(p) ((p)-&gt;uc_mcontext.mc_pc)
<span class="lineNum">     249 </span>            : #  define RFP_sig(p) ((p)-&gt;uc_mcontext.mc_regs[30])
<span class="lineNum">     250 </span>            : # endif
<span class="lineNum">     251 </span>            : #elif defined(XP_DARWIN)
<span class="lineNum">     252 </span>            : # define EIP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__eip)
<span class="lineNum">     253 </span>            : # define EBP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__ebp)
<span class="lineNum">     254 </span>            : # define ESP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__esp)
<span class="lineNum">     255 </span>            : # define RIP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__rip)
<span class="lineNum">     256 </span>            : # define RBP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__rbp)
<span class="lineNum">     257 </span>            : # define RSP_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__rsp)
<span class="lineNum">     258 </span>            : # define R15_sig(p) ((p)-&gt;uc_mcontext-&gt;__ss.__pc)
<span class="lineNum">     259 </span>            : #else
<span class="lineNum">     260 </span>            : # error &quot;Don't know how to read/write to the thread state via the mcontext_t.&quot;
<span class="lineNum">     261 </span>            : #endif
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : #if defined(XP_WIN)
<span class="lineNum">     264 </span>            : # include &quot;jswin.h&quot;
<span class="lineNum">     265 </span>            : #else
<span class="lineNum">     266 </span>            : # include &lt;signal.h&gt;
<span class="lineNum">     267 </span>            : # include &lt;sys/mman.h&gt;
<span class="lineNum">     268 </span>            : #endif
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
<span class="lineNum">     271 </span>            : # include &lt;sys/ucontext.h&gt; // for ucontext_t, mcontext_t
<span class="lineNum">     272 </span>            : #endif
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : #if defined(__x86_64__)
<span class="lineNum">     275 </span>            : # if defined(__DragonFly__)
<span class="lineNum">     276 </span>            : #  include &lt;machine/npx.h&gt; // for union savefpu
<span class="lineNum">     277 </span>            : # elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
<span class="lineNum">     278 </span>            :        defined(__NetBSD__) || defined(__OpenBSD__)
<span class="lineNum">     279 </span>            : #  include &lt;machine/fpu.h&gt; // for struct savefpu/fxsave64
<span class="lineNum">     280 </span>            : # endif
<span class="lineNum">     281 </span>            : #endif
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : #if defined(ANDROID)
<span class="lineNum">     284 </span>            : // Not all versions of the Android NDK define ucontext_t or mcontext_t.
<span class="lineNum">     285 </span>            : // Detect this and provide custom but compatible definitions. Note that these
<span class="lineNum">     286 </span>            : // follow the GLibc naming convention to access register values from
<span class="lineNum">     287 </span>            : // mcontext_t.
<span class="lineNum">     288 </span>            : //
<span class="lineNum">     289 </span>            : // See: https://chromiumcodereview.appspot.com/10829122/
<span class="lineNum">     290 </span>            : // See: http://code.google.com/p/android/issues/detail?id=34784
<span class="lineNum">     291 </span>            : # if !defined(__BIONIC_HAVE_UCONTEXT_T)
<span class="lineNum">     292 </span>            : #  if defined(__arm__)
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : // GLibc on ARM defines mcontext_t has a typedef for 'struct sigcontext'.
<span class="lineNum">     295 </span>            : // Old versions of the C library &lt;signal.h&gt; didn't define the type.
<span class="lineNum">     296 </span>            : #   if !defined(__BIONIC_HAVE_STRUCT_SIGCONTEXT)
<span class="lineNum">     297 </span>            : #    include &lt;asm/sigcontext.h&gt;
<span class="lineNum">     298 </span>            : #   endif
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : typedef struct sigcontext mcontext_t;
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : typedef struct ucontext {
<span class="lineNum">     303 </span>            :     uint32_t uc_flags;
<span class="lineNum">     304 </span>            :     struct ucontext* uc_link;
<span class="lineNum">     305 </span>            :     stack_t uc_stack;
<span class="lineNum">     306 </span>            :     mcontext_t uc_mcontext;
<span class="lineNum">     307 </span>            :     // Other fields are not used so don't define them here.
<span class="lineNum">     308 </span>            : } ucontext_t;
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : #  elif defined(__mips__)
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : typedef struct {
<span class="lineNum">     313 </span>            :     uint32_t regmask;
<span class="lineNum">     314 </span>            :     uint32_t status;
<span class="lineNum">     315 </span>            :     uint64_t pc;
<span class="lineNum">     316 </span>            :     uint64_t gregs[32];
<span class="lineNum">     317 </span>            :     uint64_t fpregs[32];
<span class="lineNum">     318 </span>            :     uint32_t acx;
<span class="lineNum">     319 </span>            :     uint32_t fpc_csr;
<span class="lineNum">     320 </span>            :     uint32_t fpc_eir;
<span class="lineNum">     321 </span>            :     uint32_t used_math;
<span class="lineNum">     322 </span>            :     uint32_t dsp;
<span class="lineNum">     323 </span>            :     uint64_t mdhi;
<span class="lineNum">     324 </span>            :     uint64_t mdlo;
<span class="lineNum">     325 </span>            :     uint32_t hi1;
<span class="lineNum">     326 </span>            :     uint32_t lo1;
<span class="lineNum">     327 </span>            :     uint32_t hi2;
<span class="lineNum">     328 </span>            :     uint32_t lo2;
<span class="lineNum">     329 </span>            :     uint32_t hi3;
<span class="lineNum">     330 </span>            :     uint32_t lo3;
<span class="lineNum">     331 </span>            : } mcontext_t;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : typedef struct ucontext {
<span class="lineNum">     334 </span>            :     uint32_t uc_flags;
<span class="lineNum">     335 </span>            :     struct ucontext* uc_link;
<span class="lineNum">     336 </span>            :     stack_t uc_stack;
<span class="lineNum">     337 </span>            :     mcontext_t uc_mcontext;
<span class="lineNum">     338 </span>            :     // Other fields are not used so don't define them here.
<span class="lineNum">     339 </span>            : } ucontext_t;
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : #  elif defined(__i386__)
<span class="lineNum">     342 </span>            : // x86 version for Android.
<span class="lineNum">     343 </span>            : typedef struct {
<span class="lineNum">     344 </span>            :     uint32_t gregs[19];
<span class="lineNum">     345 </span>            :     void* fpregs;
<span class="lineNum">     346 </span>            :     uint32_t oldmask;
<span class="lineNum">     347 </span>            :     uint32_t cr2;
<span class="lineNum">     348 </span>            : } mcontext_t;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : typedef uint32_t kernel_sigset_t[2];  // x86 kernel uses 64-bit signal masks
<span class="lineNum">     351 </span>            : typedef struct ucontext {
<span class="lineNum">     352 </span>            :     uint32_t uc_flags;
<span class="lineNum">     353 </span>            :     struct ucontext* uc_link;
<span class="lineNum">     354 </span>            :     stack_t uc_stack;
<span class="lineNum">     355 </span>            :     mcontext_t uc_mcontext;
<span class="lineNum">     356 </span>            :     // Other fields are not used by V8, don't define them here.
<span class="lineNum">     357 </span>            : } ucontext_t;
<span class="lineNum">     358 </span>            : enum { REG_EIP = 14 };
<span class="lineNum">     359 </span>            : #  endif  // defined(__i386__)
<span class="lineNum">     360 </span>            : # endif  // !defined(__BIONIC_HAVE_UCONTEXT_T)
<span class="lineNum">     361 </span>            : #endif // defined(ANDROID)
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : #if !defined(XP_WIN)
<span class="lineNum">     364 </span>            : # define CONTEXT ucontext_t
<span class="lineNum">     365 </span>            : #endif
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : // Define a context type for use in the emulator code. This is usually just
<span class="lineNum">     368 </span>            : // the same as CONTEXT, but on Mac we use a different structure since we call
<span class="lineNum">     369 </span>            : // into the emulator code from a Mach exception handler rather than a
<span class="lineNum">     370 </span>            : // sigaction-style signal handler.
<span class="lineNum">     371 </span>            : #if defined(XP_DARWIN)
<span class="lineNum">     372 </span>            : # if defined(__x86_64__)
<span class="lineNum">     373 </span>            : struct macos_x64_context {
<span class="lineNum">     374 </span>            :     x86_thread_state64_t thread;
<span class="lineNum">     375 </span>            :     x86_float_state64_t float_;
<span class="lineNum">     376 </span>            : };
<span class="lineNum">     377 </span>            : #  define EMULATOR_CONTEXT macos_x64_context
<span class="lineNum">     378 </span>            : # elif defined(__i386__)
<span class="lineNum">     379 </span>            : struct macos_x86_context {
<span class="lineNum">     380 </span>            :     x86_thread_state_t thread;
<span class="lineNum">     381 </span>            :     x86_float_state_t float_;
<span class="lineNum">     382 </span>            : };
<span class="lineNum">     383 </span>            : #  define EMULATOR_CONTEXT macos_x86_context
<span class="lineNum">     384 </span>            : # elif defined(__arm__)
<span class="lineNum">     385 </span>            : struct macos_arm_context {
<span class="lineNum">     386 </span>            :     arm_thread_state_t thread;
<span class="lineNum">     387 </span>            :     arm_neon_state_t float_;
<span class="lineNum">     388 </span>            : };
<span class="lineNum">     389 </span>            : #  define EMULATOR_CONTEXT macos_arm_context
<span class="lineNum">     390 </span>            : # else
<span class="lineNum">     391 </span>            : #  error Unsupported architecture
<span class="lineNum">     392 </span>            : # endif
<span class="lineNum">     393 </span>            : #else
<span class="lineNum">     394 </span>            : # define EMULATOR_CONTEXT CONTEXT
<span class="lineNum">     395 </span>            : #endif
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : #if defined(_M_X64) || defined(__x86_64__)
<span class="lineNum">     398 </span>            : # define PC_sig(p) RIP_sig(p)
<span class="lineNum">     399 </span>            : # define FP_sig(p) RBP_sig(p)
<span class="lineNum">     400 </span>            : # define SP_sig(p) RSP_sig(p)
<span class="lineNum">     401 </span>            : #elif defined(_M_IX86) || defined(__i386__)
<span class="lineNum">     402 </span>            : # define PC_sig(p) EIP_sig(p)
<span class="lineNum">     403 </span>            : # define FP_sig(p) EBP_sig(p)
<span class="lineNum">     404 </span>            : # define SP_sig(p) ESP_sig(p)
<span class="lineNum">     405 </span>            : #elif defined(__arm__)
<span class="lineNum">     406 </span>            : # define FP_sig(p) R11_sig(p)
<span class="lineNum">     407 </span>            : # define SP_sig(p) R13_sig(p)
<span class="lineNum">     408 </span>            : # define LR_sig(p) R14_sig(p)
<span class="lineNum">     409 </span>            : # define PC_sig(p) R15_sig(p)
<span class="lineNum">     410 </span>            : #elif defined(__aarch64__)
<span class="lineNum">     411 </span>            : # define PC_sig(p) EPC_sig(p)
<span class="lineNum">     412 </span>            : # define FP_sig(p) RFP_sig(p)
<span class="lineNum">     413 </span>            : # define SP_sig(p) R31_sig(p)
<span class="lineNum">     414 </span>            : # define LR_sig(p) RLR_sig(p)
<span class="lineNum">     415 </span>            : #elif defined(__mips__)
<span class="lineNum">     416 </span>            : # define PC_sig(p) EPC_sig(p)
<span class="lineNum">     417 </span>            : # define FP_sig(p) RFP_sig(p)
<span class="lineNum">     418 </span>            : #endif
<a name="419"><span class="lineNum">     419 </span>            : </a>
<span class="lineNum">     420 </span>            : static uint8_t**
<span class="lineNum">     421 </span><span class="lineCov">          2 : ContextToPC(CONTEXT* context)</span>
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span>            : #ifdef JS_CODEGEN_NONE
<span class="lineNum">     424 </span>            :     MOZ_CRASH();
<span class="lineNum">     425 </span>            : #else
<span class="lineNum">     426 </span><span class="lineCov">          2 :     return reinterpret_cast&lt;uint8_t**&gt;(&amp;PC_sig(context));</span>
<span class="lineNum">     427 </span>            : #endif
<span class="lineNum">     428 </span>            : }
<a name="429"><span class="lineNum">     429 </span>            : </a>
<span class="lineNum">     430 </span>            : static uint8_t*
<span class="lineNum">     431 </span><span class="lineNoCov">          0 : ContextToFP(CONTEXT* context)</span>
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span>            : #ifdef JS_CODEGEN_NONE
<span class="lineNum">     434 </span>            :     MOZ_CRASH();
<span class="lineNum">     435 </span>            : #else
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;uint8_t*&gt;(FP_sig(context));</span>
<span class="lineNum">     437 </span>            : #endif
<span class="lineNum">     438 </span>            : }
<a name="439"><span class="lineNum">     439 </span>            : </a>
<span class="lineNum">     440 </span>            : static uint8_t*
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : ContextToSP(CONTEXT* context)</span>
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span>            : #ifdef JS_CODEGEN_NONE
<span class="lineNum">     444 </span>            :     MOZ_CRASH();
<span class="lineNum">     445 </span>            : #else
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;uint8_t*&gt;(SP_sig(context));</span>
<span class="lineNum">     447 </span>            : #endif
<span class="lineNum">     448 </span>            : }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : #if defined(__arm__) || defined(__aarch64__)
<span class="lineNum">     451 </span>            : static uint8_t*
<span class="lineNum">     452 </span>            : ContextToLR(CONTEXT* context)
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span>            :     return reinterpret_cast&lt;uint8_t*&gt;(LR_sig(context));
<span class="lineNum">     455 </span>            : }
<span class="lineNum">     456 </span>            : #endif
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : #if defined(XP_DARWIN)
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : static uint8_t**
<span class="lineNum">     461 </span>            : ContextToPC(EMULATOR_CONTEXT* context)
<span class="lineNum">     462 </span>            : {
<span class="lineNum">     463 </span>            : # if defined(__x86_64__)
<span class="lineNum">     464 </span>            :     static_assert(sizeof(context-&gt;thread.__rip) == sizeof(void*),
<span class="lineNum">     465 </span>            :                   &quot;stored IP should be compile-time pointer-sized&quot;);
<span class="lineNum">     466 </span>            :     return reinterpret_cast&lt;uint8_t**&gt;(&amp;context-&gt;thread.__rip);
<span class="lineNum">     467 </span>            : # elif defined(__i386__)
<span class="lineNum">     468 </span>            :     static_assert(sizeof(context-&gt;thread.uts.ts32.__eip) == sizeof(void*),
<span class="lineNum">     469 </span>            :                   &quot;stored IP should be compile-time pointer-sized&quot;);
<span class="lineNum">     470 </span>            :     return reinterpret_cast&lt;uint8_t**&gt;(&amp;context-&gt;thread.uts.ts32.__eip);
<span class="lineNum">     471 </span>            : # elif defined(__arm__)
<span class="lineNum">     472 </span>            :     static_assert(sizeof(context-&gt;thread.__pc) == sizeof(void*),
<span class="lineNum">     473 </span>            :                   &quot;stored IP should be compile-time pointer-sized&quot;);
<span class="lineNum">     474 </span>            :     return reinterpret_cast&lt;uint8_t**&gt;(&amp;context-&gt;thread.__pc);
<span class="lineNum">     475 </span>            : # else
<span class="lineNum">     476 </span>            : #  error Unsupported architecture
<span class="lineNum">     477 </span>            : # endif
<span class="lineNum">     478 </span>            : }
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : static uint8_t*
<span class="lineNum">     481 </span>            : ContextToFP(EMULATOR_CONTEXT* context)
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span>            : # if defined(__x86_64__)
<span class="lineNum">     484 </span>            :     return (uint8_t*)context-&gt;thread.__rbp;
<span class="lineNum">     485 </span>            : # elif defined(__i386__)
<span class="lineNum">     486 </span>            :     return (uint8_t*)context-&gt;thread.uts.ts32.__ebp;
<span class="lineNum">     487 </span>            : # elif defined(__arm__)
<span class="lineNum">     488 </span>            :     return (uint8_t*)context-&gt;thread.__fp;
<span class="lineNum">     489 </span>            : # else
<span class="lineNum">     490 </span>            : #  error Unsupported architecture
<span class="lineNum">     491 </span>            : # endif
<span class="lineNum">     492 </span>            : }
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            : static uint8_t*
<span class="lineNum">     495 </span>            : ContextToSP(EMULATOR_CONTEXT* context)
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span>            : # if defined(__x86_64__)
<span class="lineNum">     498 </span>            :     return (uint8_t*)context-&gt;thread.__rsp;
<span class="lineNum">     499 </span>            : # elif defined(__i386__)
<span class="lineNum">     500 </span>            :     return (uint8_t*)context-&gt;thread.uts.ts32.__esp;
<span class="lineNum">     501 </span>            : # elif defined(__arm__)
<span class="lineNum">     502 </span>            :     return (uint8_t*)context-&gt;thread.__sp;
<span class="lineNum">     503 </span>            : # else
<span class="lineNum">     504 </span>            : #  error Unsupported architecture
<span class="lineNum">     505 </span>            : # endif
<span class="lineNum">     506 </span>            : }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : static JS::ProfilingFrameIterator::RegisterState
<span class="lineNum">     509 </span>            : ToRegisterState(EMULATOR_CONTEXT* context)
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span>            :     JS::ProfilingFrameIterator::RegisterState state;
<span class="lineNum">     512 </span>            :     state.fp = ContextToFP(context);
<span class="lineNum">     513 </span>            :     state.pc = *ContextToPC(context);
<span class="lineNum">     514 </span>            :     state.sp = ContextToSP(context);
<span class="lineNum">     515 </span>            :     // no ARM on Darwin =&gt; don't fill state.lr.
<span class="lineNum">     516 </span>            :     return state;
<span class="lineNum">     517 </span>            : }
<span class="lineNum">     518 </span>            : #endif // XP_DARWIN
<a name="519"><span class="lineNum">     519 </span>            : </a>
<span class="lineNum">     520 </span>            : static JS::ProfilingFrameIterator::RegisterState
<span class="lineNum">     521 </span><span class="lineNoCov">          0 : ToRegisterState(CONTEXT* context)</span>
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span>            : #ifdef JS_CODEGEN_NONE
<span class="lineNum">     524 </span>            :     MOZ_CRASH();
<span class="lineNum">     525 </span>            : #else
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     JS::ProfilingFrameIterator::RegisterState state;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     state.fp = ContextToFP(context);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     state.pc = *ContextToPC(context);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :     state.sp = ContextToSP(context);</span>
<span class="lineNum">     530 </span>            : # if defined(__arm__) || defined(__aarch64__)
<span class="lineNum">     531 </span>            :     state.lr = ContextToLR(context);
<span class="lineNum">     532 </span>            : # endif
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     return state;</span>
<span class="lineNum">     534 </span>            : #endif
<span class="lineNum">     535 </span>            : }
<span class="lineNum">     536 </span>            : 
<a name="537"><span class="lineNum">     537 </span>            : #if defined(WASM_HUGE_MEMORY)</a>
<span class="lineNum">     538 </span>            : MOZ_COLD static void
<span class="lineNum">     539 </span><span class="lineNoCov">          0 : SetFPRegToNaN(size_t size, void* fp_reg)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= Simd128DataSize);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :     memset(fp_reg, 0, Simd128DataSize);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     switch (size) {</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :       case 4: *static_cast&lt;float*&gt;(fp_reg) = GenericNaN(); break;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :       case 8: *static_cast&lt;double*&gt;(fp_reg) = GenericNaN(); break;</span>
<span class="lineNum">     546 </span>            :       default:
<span class="lineNum">     547 </span>            :         // All SIMD accesses throw on OOB.
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;unexpected size in SetFPRegToNaN&quot;);</span>
<span class="lineNum">     549 </span>            :     }
<span class="lineNum">     550 </span><span class="lineNoCov">          0 : }</span>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<span class="lineNum">     552 </span>            : MOZ_COLD static void
<span class="lineNum">     553 </span><span class="lineNoCov">          0 : SetGPRegToZero(void* gp_reg)</span>
<span class="lineNum">     554 </span>            : {
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     memset(gp_reg, 0, sizeof(intptr_t));</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 : }</span>
<a name="557"><span class="lineNum">     557 </span>            : </a>
<span class="lineNum">     558 </span>            : MOZ_COLD static void
<span class="lineNum">     559 </span><span class="lineNoCov">          0 : SetFPRegToLoadedValue(SharedMem&lt;void*&gt; addr, size_t size, void* fp_reg)</span>
<span class="lineNum">     560 </span>            : {
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= Simd128DataSize);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :     memset(fp_reg, 0, Simd128DataSize);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(fp_reg, addr, size);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 : }</span>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<span class="lineNum">     566 </span>            : MOZ_COLD static void
<span class="lineNum">     567 </span><span class="lineNoCov">          0 : SetGPRegToLoadedValue(SharedMem&lt;void*&gt; addr, size_t size, void* gp_reg)</span>
<span class="lineNum">     568 </span>            : {
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= sizeof(void*));</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :     memset(gp_reg, 0, sizeof(void*));</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(gp_reg, addr, size);</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 : }</span>
<a name="573"><span class="lineNum">     573 </span>            : </a>
<span class="lineNum">     574 </span>            : MOZ_COLD static void
<span class="lineNum">     575 </span><span class="lineNoCov">          0 : SetGPRegToLoadedValueSext32(SharedMem&lt;void*&gt; addr, size_t size, void* gp_reg)</span>
<span class="lineNum">     576 </span>            : {
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= sizeof(int32_t));</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     int8_t msb = AtomicOperations::loadSafeWhenRacy(addr.cast&lt;uint8_t*&gt;() + (size - 1));</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     memset(gp_reg, 0, sizeof(void*));</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     memset(gp_reg, msb &gt;&gt; 7, sizeof(int32_t));</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(gp_reg, addr, size);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 : }</span>
<a name="583"><span class="lineNum">     583 </span>            : </a>
<span class="lineNum">     584 </span>            : MOZ_COLD static void
<span class="lineNum">     585 </span><span class="lineNoCov">          0 : StoreValueFromFPReg(SharedMem&lt;void*&gt; addr, size_t size, const void* fp_reg)</span>
<span class="lineNum">     586 </span>            : {
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= Simd128DataSize);</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(addr, const_cast&lt;void*&gt;(fp_reg), size);</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 : }</span>
<a name="590"><span class="lineNum">     590 </span>            : </a>
<span class="lineNum">     591 </span>            : MOZ_COLD static void
<span class="lineNum">     592 </span><span class="lineNoCov">          0 : StoreValueFromGPReg(SharedMem&lt;void*&gt; addr, size_t size, const void* gp_reg)</span>
<span class="lineNum">     593 </span>            : {
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= sizeof(void*));</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(addr, const_cast&lt;void*&gt;(gp_reg), size);</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 : }</span>
<a name="597"><span class="lineNum">     597 </span>            : </a>
<span class="lineNum">     598 </span>            : MOZ_COLD static void
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : StoreValueFromGPImm(SharedMem&lt;void*&gt; addr, size_t size, int32_t imm)</span>
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size &lt;= sizeof(imm));</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     AtomicOperations::memcpySafeWhenRacy(addr, static_cast&lt;void*&gt;(&amp;imm), size);</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     604 </span>            : 
<a name="605"><span class="lineNum">     605 </span>            : # if !defined(XP_DARWIN)</a>
<span class="lineNum">     606 </span>            : MOZ_COLD static void*
<span class="lineNum">     607 </span><span class="lineNoCov">          0 : AddressOfFPRegisterSlot(CONTEXT* context, FloatRegisters::Encoding encoding)</span>
<span class="lineNum">     608 </span>            : {
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     switch (encoding) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm0:  return &amp;XMM_sig(context, 0);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm1:  return &amp;XMM_sig(context, 1);</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm2:  return &amp;XMM_sig(context, 2);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm3:  return &amp;XMM_sig(context, 3);</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm4:  return &amp;XMM_sig(context, 4);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm5:  return &amp;XMM_sig(context, 5);</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm6:  return &amp;XMM_sig(context, 6);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm7:  return &amp;XMM_sig(context, 7);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm8:  return &amp;XMM_sig(context, 8);</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm9:  return &amp;XMM_sig(context, 9);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm10: return &amp;XMM_sig(context, 10);</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm11: return &amp;XMM_sig(context, 11);</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm12: return &amp;XMM_sig(context, 12);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm13: return &amp;XMM_sig(context, 13);</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm14: return &amp;XMM_sig(context, 14);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       case X86Encoding::xmm15: return &amp;XMM_sig(context, 15);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       default: break;</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     MOZ_CRASH();</span>
<span class="lineNum">     629 </span>            : }
<a name="630"><span class="lineNum">     630 </span>            : </a>
<span class="lineNum">     631 </span>            : MOZ_COLD static void*
<span class="lineNum">     632 </span><span class="lineNoCov">          0 : AddressOfGPRegisterSlot(EMULATOR_CONTEXT* context, Registers::Code code)</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     switch (code) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       case X86Encoding::rax: return &amp;RAX_sig(context);</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       case X86Encoding::rcx: return &amp;RCX_sig(context);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       case X86Encoding::rdx: return &amp;RDX_sig(context);</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       case X86Encoding::rbx: return &amp;RBX_sig(context);</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       case X86Encoding::rsp: return &amp;RSP_sig(context);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       case X86Encoding::rbp: return &amp;RBP_sig(context);</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       case X86Encoding::rsi: return &amp;RSI_sig(context);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :       case X86Encoding::rdi: return &amp;RDI_sig(context);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :       case X86Encoding::r8:  return &amp;R8_sig(context);</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :       case X86Encoding::r9:  return &amp;R9_sig(context);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :       case X86Encoding::r10: return &amp;R10_sig(context);</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :       case X86Encoding::r11: return &amp;R11_sig(context);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :       case X86Encoding::r12: return &amp;R12_sig(context);</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       case X86Encoding::r13: return &amp;R13_sig(context);</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :       case X86Encoding::r14: return &amp;R14_sig(context);</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :       case X86Encoding::r15: return &amp;R15_sig(context);</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       default: break;</span>
<span class="lineNum">     652 </span>            :     }
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     MOZ_CRASH();</span>
<span class="lineNum">     654 </span>            : }
<span class="lineNum">     655 </span>            : # else
<span class="lineNum">     656 </span>            : MOZ_COLD static void*
<span class="lineNum">     657 </span>            : AddressOfFPRegisterSlot(EMULATOR_CONTEXT* context, FloatRegisters::Encoding encoding)
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span>            :     switch (encoding) {
<span class="lineNum">     660 </span>            :       case X86Encoding::xmm0:  return &amp;context-&gt;float_.__fpu_xmm0;
<span class="lineNum">     661 </span>            :       case X86Encoding::xmm1:  return &amp;context-&gt;float_.__fpu_xmm1;
<span class="lineNum">     662 </span>            :       case X86Encoding::xmm2:  return &amp;context-&gt;float_.__fpu_xmm2;
<span class="lineNum">     663 </span>            :       case X86Encoding::xmm3:  return &amp;context-&gt;float_.__fpu_xmm3;
<span class="lineNum">     664 </span>            :       case X86Encoding::xmm4:  return &amp;context-&gt;float_.__fpu_xmm4;
<span class="lineNum">     665 </span>            :       case X86Encoding::xmm5:  return &amp;context-&gt;float_.__fpu_xmm5;
<span class="lineNum">     666 </span>            :       case X86Encoding::xmm6:  return &amp;context-&gt;float_.__fpu_xmm6;
<span class="lineNum">     667 </span>            :       case X86Encoding::xmm7:  return &amp;context-&gt;float_.__fpu_xmm7;
<span class="lineNum">     668 </span>            :       case X86Encoding::xmm8:  return &amp;context-&gt;float_.__fpu_xmm8;
<span class="lineNum">     669 </span>            :       case X86Encoding::xmm9:  return &amp;context-&gt;float_.__fpu_xmm9;
<span class="lineNum">     670 </span>            :       case X86Encoding::xmm10: return &amp;context-&gt;float_.__fpu_xmm10;
<span class="lineNum">     671 </span>            :       case X86Encoding::xmm11: return &amp;context-&gt;float_.__fpu_xmm11;
<span class="lineNum">     672 </span>            :       case X86Encoding::xmm12: return &amp;context-&gt;float_.__fpu_xmm12;
<span class="lineNum">     673 </span>            :       case X86Encoding::xmm13: return &amp;context-&gt;float_.__fpu_xmm13;
<span class="lineNum">     674 </span>            :       case X86Encoding::xmm14: return &amp;context-&gt;float_.__fpu_xmm14;
<span class="lineNum">     675 </span>            :       case X86Encoding::xmm15: return &amp;context-&gt;float_.__fpu_xmm15;
<span class="lineNum">     676 </span>            :       default: break;
<span class="lineNum">     677 </span>            :     }
<span class="lineNum">     678 </span>            :     MOZ_CRASH();
<span class="lineNum">     679 </span>            : }
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : MOZ_COLD static void*
<span class="lineNum">     682 </span>            : AddressOfGPRegisterSlot(EMULATOR_CONTEXT* context, Registers::Code code)
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span>            :     switch (code) {
<span class="lineNum">     685 </span>            :       case X86Encoding::rax: return &amp;context-&gt;thread.__rax;
<span class="lineNum">     686 </span>            :       case X86Encoding::rcx: return &amp;context-&gt;thread.__rcx;
<span class="lineNum">     687 </span>            :       case X86Encoding::rdx: return &amp;context-&gt;thread.__rdx;
<span class="lineNum">     688 </span>            :       case X86Encoding::rbx: return &amp;context-&gt;thread.__rbx;
<span class="lineNum">     689 </span>            :       case X86Encoding::rsp: return &amp;context-&gt;thread.__rsp;
<span class="lineNum">     690 </span>            :       case X86Encoding::rbp: return &amp;context-&gt;thread.__rbp;
<span class="lineNum">     691 </span>            :       case X86Encoding::rsi: return &amp;context-&gt;thread.__rsi;
<span class="lineNum">     692 </span>            :       case X86Encoding::rdi: return &amp;context-&gt;thread.__rdi;
<span class="lineNum">     693 </span>            :       case X86Encoding::r8:  return &amp;context-&gt;thread.__r8;
<span class="lineNum">     694 </span>            :       case X86Encoding::r9:  return &amp;context-&gt;thread.__r9;
<span class="lineNum">     695 </span>            :       case X86Encoding::r10: return &amp;context-&gt;thread.__r10;
<span class="lineNum">     696 </span>            :       case X86Encoding::r11: return &amp;context-&gt;thread.__r11;
<span class="lineNum">     697 </span>            :       case X86Encoding::r12: return &amp;context-&gt;thread.__r12;
<span class="lineNum">     698 </span>            :       case X86Encoding::r13: return &amp;context-&gt;thread.__r13;
<span class="lineNum">     699 </span>            :       case X86Encoding::r14: return &amp;context-&gt;thread.__r14;
<span class="lineNum">     700 </span>            :       case X86Encoding::r15: return &amp;context-&gt;thread.__r15;
<span class="lineNum">     701 </span>            :       default: break;
<span class="lineNum">     702 </span>            :     }
<span class="lineNum">     703 </span>            :     MOZ_CRASH();
<span class="lineNum">     704 </span>            : }
<span class="lineNum">     705 </span>            : # endif  // !XP_DARWIN
<a name="706"><span class="lineNum">     706 </span>            : </a>
<span class="lineNum">     707 </span>            : MOZ_COLD static void
<span class="lineNum">     708 </span><span class="lineNoCov">          0 : SetRegisterToCoercedUndefined(EMULATOR_CONTEXT* context, size_t size,</span>
<span class="lineNum">     709 </span>            :                               const Disassembler::OtherOperand&amp; value)
<span class="lineNum">     710 </span>            : {
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     if (value.kind() == Disassembler::OtherOperand::FPR)</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :         SetFPRegToNaN(size, AddressOfFPRegisterSlot(context, value.fpr()));</span>
<span class="lineNum">     713 </span>            :     else
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         SetGPRegToZero(AddressOfGPRegisterSlot(context, value.gpr()));</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 : }</span>
<a name="716"><span class="lineNum">     716 </span>            : </a>
<span class="lineNum">     717 </span>            : MOZ_COLD static void
<span class="lineNum">     718 </span><span class="lineNoCov">          0 : SetRegisterToLoadedValue(EMULATOR_CONTEXT* context, SharedMem&lt;void*&gt; addr, size_t size,</span>
<span class="lineNum">     719 </span>            :                          const Disassembler::OtherOperand&amp; value)
<span class="lineNum">     720 </span>            : {
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     if (value.kind() == Disassembler::OtherOperand::FPR)</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         SetFPRegToLoadedValue(addr, size, AddressOfFPRegisterSlot(context, value.fpr()));</span>
<span class="lineNum">     723 </span>            :     else
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :         SetGPRegToLoadedValue(addr, size, AddressOfGPRegisterSlot(context, value.gpr()));</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 : }</span>
<a name="726"><span class="lineNum">     726 </span>            : </a>
<span class="lineNum">     727 </span>            : MOZ_COLD static void
<span class="lineNum">     728 </span><span class="lineNoCov">          0 : SetRegisterToLoadedValueSext32(EMULATOR_CONTEXT* context, SharedMem&lt;void*&gt; addr, size_t size,</span>
<span class="lineNum">     729 </span>            :                                const Disassembler::OtherOperand&amp; value)
<span class="lineNum">     730 </span>            : {
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     SetGPRegToLoadedValueSext32(addr, size, AddressOfGPRegisterSlot(context, value.gpr()));</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 : }</span>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<span class="lineNum">     734 </span>            : MOZ_COLD static void
<span class="lineNum">     735 </span><span class="lineNoCov">          0 : StoreValueFromRegister(EMULATOR_CONTEXT* context, SharedMem&lt;void*&gt; addr, size_t size,</span>
<span class="lineNum">     736 </span>            :                        const Disassembler::OtherOperand&amp; value)
<span class="lineNum">     737 </span>            : {
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     if (value.kind() == Disassembler::OtherOperand::FPR)</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :         StoreValueFromFPReg(addr, size, AddressOfFPRegisterSlot(context, value.fpr()));</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     else if (value.kind() == Disassembler::OtherOperand::GPR)</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         StoreValueFromGPReg(addr, size, AddressOfGPRegisterSlot(context, value.gpr()));</span>
<span class="lineNum">     742 </span>            :     else
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         StoreValueFromGPImm(addr, size, value.imm());</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 : }</span>
<a name="745"><span class="lineNum">     745 </span>            : </a>
<span class="lineNum">     746 </span>            : MOZ_COLD static uint8_t*
<span class="lineNum">     747 </span><span class="lineNoCov">          0 : ComputeAccessAddress(EMULATOR_CONTEXT* context, const Disassembler::ComplexAddress&amp; address)</span>
<span class="lineNum">     748 </span>            : {
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(!address.isPCRelative(), &quot;PC-relative addresses not supported yet&quot;);</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     uintptr_t result = address.disp();</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     if (address.hasBase()) {</span>
<span class="lineNum">     754 </span>            :         uintptr_t base;
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         StoreValueFromGPReg(SharedMem&lt;void*&gt;::unshared(&amp;base), sizeof(uintptr_t),</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :                             AddressOfGPRegisterSlot(context, address.base()));</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         result += base;</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     if (address.hasIndex()) {</span>
<span class="lineNum">     761 </span>            :         uintptr_t index;
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         StoreValueFromGPReg(SharedMem&lt;void*&gt;::unshared(&amp;index), sizeof(uintptr_t),</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                             AddressOfGPRegisterSlot(context, address.index()));</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(address.scale() &lt; 32, &quot;address shift overflow&quot;);</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         result += index * (uintptr_t(1) &lt;&lt; address.scale());</span>
<span class="lineNum">     766 </span>            :     }
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;uint8_t*&gt;(result);</span>
<span class="lineNum">     769 </span>            : }
<a name="770"><span class="lineNum">     770 </span>            : </a>
<span class="lineNum">     771 </span>            : MOZ_COLD static void
<span class="lineNum">     772 </span><span class="lineNoCov">          0 : HandleMemoryAccess(EMULATOR_CONTEXT* context, uint8_t* pc, uint8_t* faultingAddress,</span>
<span class="lineNum">     773 </span>            :                    const Instance&amp; instance, WasmActivation* activation, uint8_t** ppc)
<span class="lineNum">     774 </span>            : {
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(instance.code().containsFunctionPC(pc));</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :     const CodeSegment* segment;
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     const MemoryAccess* memoryAccess = instance.code().lookupMemoryAccess(pc, &amp;segment);</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     if (!memoryAccess) {</span>
<span class="lineNum">     780 </span>            :         // If there is no associated MemoryAccess for the faulting PC, this must be
<span class="lineNum">     781 </span>            :         // experimental SIMD.js or Atomics. When these are converted to
<span class="lineNum">     782 </span>            :         // non-experimental wasm features, this case, as well as outOfBoundsCode,
<span class="lineNum">     783 </span>            :         // can be removed.
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :         activation-&gt;startInterrupt(ToRegisterState(context));</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :         if (!instance.code().containsCodePC(pc, &amp;segment))</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :             MOZ_CRASH(&quot;Cannot map PC to trap handler&quot;);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :         *ppc = segment-&gt;outOfBoundsCode();</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(memoryAccess-&gt;insnOffset() == (pc - segment-&gt;base()));</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :     // On WASM_HUGE_MEMORY platforms, asm.js code may fault. asm.js does not
<span class="lineNum">     794 </span>            :     // trap on fault and so has no trap out-of-line path. Instead, stores are
<span class="lineNum">     795 </span>            :     // silently ignored (by advancing the pc past the store and resuming) and
<span class="lineNum">     796 </span>            :     // loads silently succeed with a JS-semantics-determined value.
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     if (memoryAccess-&gt;hasTrapOutOfLineCode()) {</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         *ppc = memoryAccess-&gt;trapOutOfLineCode(segment-&gt;base());</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     801 </span>            :     }
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(instance.isAsmJS());</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :     // Disassemble the instruction which caused the trap so that we can extract
<span class="lineNum">     806 </span>            :     // information about it and decide what to do.
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     Disassembler::HeapAccess access;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     uint8_t* end = Disassembler::DisassembleHeapAccess(pc, &amp;access);</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     const Disassembler::ComplexAddress&amp; address = access.address();</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(end &gt; pc);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(segment-&gt;containsFunctionPC(end));</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :     // Check x64 asm.js heap access invariants.
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(address.disp() &gt;= 0);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(address.base() == HeapReg.code());</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(!address.hasIndex() || address.index() != HeapReg.code());</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(address.scale() == 0);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     if (address.hasBase()) {</span>
<span class="lineNum">     819 </span>            :         uintptr_t base;
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         StoreValueFromGPReg(SharedMem&lt;void*&gt;::unshared(&amp;base), sizeof(uintptr_t),</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :                             AddressOfGPRegisterSlot(context, address.base()));</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(reinterpret_cast&lt;uint8_t*&gt;(base) == instance.memoryBase());</span>
<span class="lineNum">     823 </span>            :     }
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     if (address.hasIndex()) {</span>
<span class="lineNum">     825 </span>            :         uintptr_t index;
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         StoreValueFromGPReg(SharedMem&lt;void*&gt;::unshared(&amp;index), sizeof(uintptr_t),</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                             AddressOfGPRegisterSlot(context, address.index()));</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(uint32_t(index) == index);</span>
<span class="lineNum">     829 </span>            :     }
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :     // Determine the actual effective address of the faulting access. We can't
<span class="lineNum">     832 </span>            :     // rely on the faultingAddress given to us by the OS, because we need the
<span class="lineNum">     833 </span>            :     // address of the start of the access, and the OS may sometimes give us an
<span class="lineNum">     834 </span>            :     // address somewhere in the middle of the heap access.
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     uint8_t* accessAddress = ComputeAccessAddress(context, address);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(size_t(faultingAddress - accessAddress) &lt; access.size(),</span>
<span class="lineNum">     837 </span>            :                        &quot;Given faulting address does not appear to be within computed &quot;
<span class="lineNum">     838 </span>            :                        &quot;faulting address range&quot;);
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(accessAddress &gt;= instance.memoryBase(),</span>
<span class="lineNum">     840 </span>            :                        &quot;Access begins outside the asm.js heap&quot;);
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(accessAddress + access.size() &lt;= instance.memoryBase() +</span>
<span class="lineNum">     842 </span>            :                        instance.memoryMappedSize(),
<span class="lineNum">     843 </span>            :                        &quot;Access extends beyond the asm.js heap guard region&quot;);
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(accessAddress + access.size() &gt; instance.memoryBase() +</span>
<span class="lineNum">     845 </span>            :                        instance.memoryLength(),
<span class="lineNum">     846 </span>            :                        &quot;Computed access address is not actually out of bounds&quot;);
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     // The basic sandbox model is that all heap accesses are a heap base
<span class="lineNum">     849 </span>            :     // register plus an index, and the index is always computed with 32-bit
<span class="lineNum">     850 </span>            :     // operations, so we know it can only be 4 GiB off of the heap base.
<span class="lineNum">     851 </span>            :     //
<span class="lineNum">     852 </span>            :     // However, we wish to support the optimization of folding immediates
<span class="lineNum">     853 </span>            :     // and scaled indices into addresses, and any address arithmetic we fold
<span class="lineNum">     854 </span>            :     // gets done at full pointer width, so it doesn't get properly wrapped.
<span class="lineNum">     855 </span>            :     // We support this by extending HugeMappedSize to the greatest size that
<span class="lineNum">     856 </span>            :     // could be reached by such an unwrapped address, and then when we arrive
<span class="lineNum">     857 </span>            :     // here in the signal handler for such an access, we compute the fully
<span class="lineNum">     858 </span>            :     // wrapped address, and perform the load or store on it.
<span class="lineNum">     859 </span>            :     //
<span class="lineNum">     860 </span>            :     // Taking a signal is really slow, but in theory programs really shouldn't
<span class="lineNum">     861 </span>            :     // be hitting this anyway.
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     intptr_t unwrappedOffset = accessAddress - instance.memoryBase().unwrap(/* for value */);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     uint32_t wrappedOffset = uint32_t(unwrappedOffset);</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :     size_t size = access.size();</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(wrappedOffset + size &gt; wrappedOffset);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     bool inBounds = wrappedOffset + size &lt; instance.memoryLength();</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     if (inBounds) {</span>
<span class="lineNum">     869 </span>            :         // We now know that this is an access that is actually in bounds when
<span class="lineNum">     870 </span>            :         // properly wrapped. Complete the load or store with the wrapped
<span class="lineNum">     871 </span>            :         // address.
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         SharedMem&lt;uint8_t*&gt; wrappedAddress = instance.memoryBase() + wrappedOffset;</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(wrappedAddress &gt;= instance.memoryBase());</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(wrappedAddress + size &gt; wrappedAddress);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(wrappedAddress + size &lt;= instance.memoryBase() + instance.memoryLength());</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :         switch (access.kind()) {</span>
<span class="lineNum">     877 </span>            :           case Disassembler::HeapAccess::Load:
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :             SetRegisterToLoadedValue(context, wrappedAddress.cast&lt;void*&gt;(), size, access.otherOperand());</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     880 </span>            :           case Disassembler::HeapAccess::LoadSext32:
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :             SetRegisterToLoadedValueSext32(context, wrappedAddress.cast&lt;void*&gt;(), size, access.otherOperand());</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     883 </span>            :           case Disassembler::HeapAccess::Store:
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :             StoreValueFromRegister(context, wrappedAddress.cast&lt;void*&gt;(), size, access.otherOperand());</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     886 </span>            :           case Disassembler::HeapAccess::LoadSext64:
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :             MOZ_CRASH(&quot;no int64 accesses in asm.js&quot;);</span>
<span class="lineNum">     888 </span>            :           case Disassembler::HeapAccess::Unknown:
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :             MOZ_CRASH(&quot;Failed to disassemble instruction&quot;);</span>
<span class="lineNum">     890 </span>            :         }
<span class="lineNum">     891 </span>            :     } else {
<span class="lineNum">     892 </span>            :         // We now know that this is an out-of-bounds access made by an asm.js
<span class="lineNum">     893 </span>            :         // load/store that we should handle.
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         switch (access.kind()) {</span>
<span class="lineNum">     895 </span>            :           case Disassembler::HeapAccess::Load:
<span class="lineNum">     896 </span>            :           case Disassembler::HeapAccess::LoadSext32:
<span class="lineNum">     897 </span>            :             // Assign the JS-defined result value to the destination register
<span class="lineNum">     898 </span>            :             // (ToInt32(undefined) or ToNumber(undefined), determined by the
<span class="lineNum">     899 </span>            :             // type of the destination register). Very conveniently, we can
<span class="lineNum">     900 </span>            :             // infer the type from the register class, since all SIMD accesses
<span class="lineNum">     901 </span>            :             // throw on out of bounds (see above), so the only types using FP
<span class="lineNum">     902 </span>            :             // registers are float32 and double.
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :             SetRegisterToCoercedUndefined(context, access.size(), access.otherOperand());</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     905 </span>            :           case Disassembler::HeapAccess::Store:
<span class="lineNum">     906 </span>            :             // Do nothing.
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     908 </span>            :           case Disassembler::HeapAccess::LoadSext64:
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :             MOZ_CRASH(&quot;no int64 accesses in asm.js&quot;);</span>
<span class="lineNum">     910 </span>            :           case Disassembler::HeapAccess::Unknown:
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :             MOZ_CRASH(&quot;Failed to disassemble instruction&quot;);</span>
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     *ppc = end;</span>
<span class="lineNum">     916 </span>            : }
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            : #else // WASM_HUGE_MEMORY
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            : MOZ_COLD static void
<span class="lineNum">     921 </span>            : HandleMemoryAccess(EMULATOR_CONTEXT* context, uint8_t* pc, uint8_t* faultingAddress,
<span class="lineNum">     922 </span>            :                    const Instance&amp; instance, WasmActivation* activation, uint8_t** ppc)
<span class="lineNum">     923 </span>            : {
<span class="lineNum">     924 </span>            :     MOZ_RELEASE_ASSERT(instance.code().containsFunctionPC(pc));
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     const CodeSegment* segment;
<span class="lineNum">     927 </span>            :     const MemoryAccess* memoryAccess = instance.code().lookupMemoryAccess(pc, &amp;segment);
<span class="lineNum">     928 </span>            :     if (!memoryAccess) {
<span class="lineNum">     929 </span>            :         // See explanation in the WASM_HUGE_MEMORY HandleMemoryAccess.
<span class="lineNum">     930 </span>            :         activation-&gt;startInterrupt(ToRegisterState(context));
<span class="lineNum">     931 </span>            :         if (!instance.code().containsCodePC(pc, &amp;segment))
<span class="lineNum">     932 </span>            :             MOZ_CRASH(&quot;Cannot map PC to trap handler&quot;);
<span class="lineNum">     933 </span>            :         *ppc = segment-&gt;outOfBoundsCode();
<span class="lineNum">     934 </span>            :         return;
<span class="lineNum">     935 </span>            :     }
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :     MOZ_RELEASE_ASSERT(memoryAccess-&gt;hasTrapOutOfLineCode());
<span class="lineNum">     938 </span>            :     *ppc = memoryAccess-&gt;trapOutOfLineCode(segment-&gt;base());
<span class="lineNum">     939 </span>            : }
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : #endif // WASM_HUGE_MEMORY
<a name="942"><span class="lineNum">     942 </span>            : </a>
<span class="lineNum">     943 </span>            : MOZ_COLD static bool
<span class="lineNum">     944 </span><span class="lineNoCov">          0 : IsHeapAccessAddress(const Instance &amp;instance, uint8_t* faultingAddress)</span>
<span class="lineNum">     945 </span>            : {
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :     size_t accessLimit = instance.memoryMappedSize();</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     return instance.metadata().usesMemory() &amp;&amp;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :            faultingAddress &gt;= instance.memoryBase() &amp;&amp;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :            faultingAddress &lt; instance.memoryBase() + accessLimit;</span>
<span class="lineNum">     951 </span>            : }
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            : #if defined(XP_WIN)
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            : static bool
<span class="lineNum">     956 </span>            : HandleFault(PEXCEPTION_POINTERS exception)
<span class="lineNum">     957 </span>            : {
<span class="lineNum">     958 </span>            :     EXCEPTION_RECORD* record = exception-&gt;ExceptionRecord;
<span class="lineNum">     959 </span>            :     CONTEXT* context = exception-&gt;ContextRecord;
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :     if (record-&gt;ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
<span class="lineNum">     962 </span>            :         return false;
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :     uint8_t** ppc = ContextToPC(context);
<span class="lineNum">     965 </span>            :     uint8_t* pc = *ppc;
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     if (record-&gt;NumberParameters &lt; 2)
<span class="lineNum">     968 </span>            :         return false;
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :     // Don't allow recursive handling of signals, see AutoSetHandlingSegFault.
<span class="lineNum">     971 </span>            :     JSContext* cx = TlsContext.get();
<span class="lineNum">     972 </span>            :     if (!cx || cx-&gt;handlingSegFault)
<span class="lineNum">     973 </span>            :         return false;
<span class="lineNum">     974 </span>            :     AutoSetHandlingSegFault handling(cx);
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span>            :     WasmActivation* activation = ActivationIfInnermost(cx);
<span class="lineNum">     977 </span>            :     if (!activation)
<span class="lineNum">     978 </span>            :         return false;
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :     const CodeSegment* codeSegment;
<span class="lineNum">     981 </span>            :     const Code* code = activation-&gt;compartment()-&gt;wasm.lookupCode(pc, &amp;codeSegment);
<span class="lineNum">     982 </span>            :     if (!code)
<span class="lineNum">     983 </span>            :         return false;
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :     if (!codeSegment-&gt;containsFunctionPC(pc)) {
<span class="lineNum">     986 </span>            :         // On Windows, it is possible for InterruptRunningJitCode to execute
<span class="lineNum">     987 </span>            :         // between a faulting heap access and the handling of the fault due
<span class="lineNum">     988 </span>            :         // to InterruptRunningJitCode's use of SuspendThread. When this happens,
<span class="lineNum">     989 </span>            :         // after ResumeThread, the exception handler is called with pc equal to
<span class="lineNum">     990 </span>            :         // CodeSegment.interrupt, which is logically wrong. The Right Thing would
<span class="lineNum">     991 </span>            :         // be for the OS to make fault-handling atomic (so that CONTEXT.pc was
<span class="lineNum">     992 </span>            :         // always the logically-faulting pc). Fortunately, we can detect this
<span class="lineNum">     993 </span>            :         // case and silence the exception ourselves (the exception will
<span class="lineNum">     994 </span>            :         // retrigger after the interrupt jumps back to resumePC).
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :         for (auto t : code-&gt;tiers()) {
<span class="lineNum">     997 </span>            :             if (pc == code-&gt;segment(t).interruptCode() &amp;&amp;
<span class="lineNum">     998 </span>            :                 activation-&gt;interrupted() &amp;&amp;
<span class="lineNum">     999 </span>            :                 code-&gt;segment(t).containsFunctionPC(activation-&gt;resumePC()))
<span class="lineNum">    1000 </span>            :             {
<span class="lineNum">    1001 </span>            :                 return true;
<span class="lineNum">    1002 </span>            :             }
<span class="lineNum">    1003 </span>            :         }
<span class="lineNum">    1004 </span>            :         return false;
<span class="lineNum">    1005 </span>            :     }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :     const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(context));
<span class="lineNum">    1008 </span>            :     if (!instance)
<span class="lineNum">    1009 </span>            :         return false;
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :     uint8_t* faultingAddress = reinterpret_cast&lt;uint8_t*&gt;(record-&gt;ExceptionInformation[1]);
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :     // This check isn't necessary, but, since we can, check anyway to make
<span class="lineNum">    1014 </span>            :     // sure we aren't covering up a real bug.
<span class="lineNum">    1015 </span>            :     if (!IsHeapAccessAddress(*instance, faultingAddress))
<span class="lineNum">    1016 </span>            :         return false;
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            :     // Similar to the non-atomic situation above, on Windows, an OOB fault at a
<span class="lineNum">    1019 </span>            :     // PC can trigger *after* an async interrupt observed that PC and attempted
<span class="lineNum">    1020 </span>            :     // to redirect to the async stub. In this unique case, interrupted() is
<span class="lineNum">    1021 </span>            :     // already true when the OOB handler is called. Since the point of the async
<span class="lineNum">    1022 </span>            :     // interrupt is to get out of an iloop and the OOB trap will do just that,
<span class="lineNum">    1023 </span>            :     // we can simply clear the interrupt. (The update to CONTEXT.pc made by
<span class="lineNum">    1024 </span>            :     // HandleMemoryAccess will clobber the interrupt's previous update.)
<span class="lineNum">    1025 </span>            :     if (activation-&gt;interrupted()) {
<span class="lineNum">    1026 </span>            :         MOZ_ASSERT(activation-&gt;resumePC() == pc);
<span class="lineNum">    1027 </span>            :         activation-&gt;finishInterrupt();
<span class="lineNum">    1028 </span>            :     }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :     HandleMemoryAccess(context, pc, faultingAddress, *instance, activation, ppc);
<span class="lineNum">    1031 </span>            :     return true;
<span class="lineNum">    1032 </span>            : }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : static LONG WINAPI
<span class="lineNum">    1035 </span>            : WasmFaultHandler(LPEXCEPTION_POINTERS exception)
<span class="lineNum">    1036 </span>            : {
<span class="lineNum">    1037 </span>            :     if (HandleFault(exception))
<span class="lineNum">    1038 </span>            :         return EXCEPTION_CONTINUE_EXECUTION;
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :     // No need to worry about calling other handlers, the OS does this for us.
<span class="lineNum">    1041 </span>            :     return EXCEPTION_CONTINUE_SEARCH;
<span class="lineNum">    1042 </span>            : }
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : #elif defined(XP_DARWIN)
<span class="lineNum">    1045 </span>            : # include &lt;mach/exc.h&gt;
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            : // This definition was generated by mig (the Mach Interface Generator) for the
<span class="lineNum">    1048 </span>            : // routine 'exception_raise' (exc.defs).
<span class="lineNum">    1049 </span>            : #pragma pack(4)
<span class="lineNum">    1050 </span>            : typedef struct {
<span class="lineNum">    1051 </span>            :     mach_msg_header_t Head;
<span class="lineNum">    1052 </span>            :     /* start of the kernel processed data */
<span class="lineNum">    1053 </span>            :     mach_msg_body_t msgh_body;
<span class="lineNum">    1054 </span>            :     mach_msg_port_descriptor_t thread;
<span class="lineNum">    1055 </span>            :     mach_msg_port_descriptor_t task;
<span class="lineNum">    1056 </span>            :     /* end of the kernel processed data */
<span class="lineNum">    1057 </span>            :     NDR_record_t NDR;
<span class="lineNum">    1058 </span>            :     exception_type_t exception;
<span class="lineNum">    1059 </span>            :     mach_msg_type_number_t codeCnt;
<span class="lineNum">    1060 </span>            :     int64_t code[2];
<span class="lineNum">    1061 </span>            : } Request__mach_exception_raise_t;
<span class="lineNum">    1062 </span>            : #pragma pack()
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            : // The full Mach message also includes a trailer.
<span class="lineNum">    1065 </span>            : struct ExceptionRequest
<span class="lineNum">    1066 </span>            : {
<span class="lineNum">    1067 </span>            :     Request__mach_exception_raise_t body;
<span class="lineNum">    1068 </span>            :     mach_msg_trailer_t trailer;
<span class="lineNum">    1069 </span>            : };
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            : static bool
<span class="lineNum">    1072 </span>            : HandleMachException(JSContext* cx, const ExceptionRequest&amp; request)
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span>            :     // Don't allow recursive handling of signals, see AutoSetHandlingSegFault.
<span class="lineNum">    1075 </span>            :     if (cx-&gt;handlingSegFault)
<span class="lineNum">    1076 </span>            :         return false;
<span class="lineNum">    1077 </span>            :     AutoSetHandlingSegFault handling(cx);
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :     // Get the port of the JSContext's thread from the message.
<span class="lineNum">    1080 </span>            :     mach_port_t cxThread = request.body.thread.name;
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            :     // Read out the JSRuntime thread's register state.
<span class="lineNum">    1083 </span>            :     EMULATOR_CONTEXT context;
<span class="lineNum">    1084 </span>            : # if defined(__x86_64__)
<span class="lineNum">    1085 </span>            :     unsigned int thread_state_count = x86_THREAD_STATE64_COUNT;
<span class="lineNum">    1086 </span>            :     unsigned int float_state_count = x86_FLOAT_STATE64_COUNT;
<span class="lineNum">    1087 </span>            :     int thread_state = x86_THREAD_STATE64;
<span class="lineNum">    1088 </span>            :     int float_state = x86_FLOAT_STATE64;
<span class="lineNum">    1089 </span>            : # elif defined(__i386__)
<span class="lineNum">    1090 </span>            :     unsigned int thread_state_count = x86_THREAD_STATE_COUNT;
<span class="lineNum">    1091 </span>            :     unsigned int float_state_count = x86_FLOAT_STATE_COUNT;
<span class="lineNum">    1092 </span>            :     int thread_state = x86_THREAD_STATE;
<span class="lineNum">    1093 </span>            :     int float_state = x86_FLOAT_STATE;
<span class="lineNum">    1094 </span>            : # elif defined(__arm__)
<span class="lineNum">    1095 </span>            :     unsigned int thread_state_count = ARM_THREAD_STATE_COUNT;
<span class="lineNum">    1096 </span>            :     unsigned int float_state_count = ARM_NEON_STATE_COUNT;
<span class="lineNum">    1097 </span>            :     int thread_state = ARM_THREAD_STATE;
<span class="lineNum">    1098 </span>            :     int float_state = ARM_NEON_STATE;
<span class="lineNum">    1099 </span>            : # else
<span class="lineNum">    1100 </span>            : #  error Unsupported architecture
<span class="lineNum">    1101 </span>            : # endif
<span class="lineNum">    1102 </span>            :     kern_return_t kret;
<span class="lineNum">    1103 </span>            :     kret = thread_get_state(cxThread, thread_state,
<span class="lineNum">    1104 </span>            :                             (thread_state_t)&amp;context.thread, &amp;thread_state_count);
<span class="lineNum">    1105 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1106 </span>            :         return false;
<span class="lineNum">    1107 </span>            :     kret = thread_get_state(cxThread, float_state,
<span class="lineNum">    1108 </span>            :                             (thread_state_t)&amp;context.float_, &amp;float_state_count);
<span class="lineNum">    1109 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1110 </span>            :         return false;
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            :     uint8_t** ppc = ContextToPC(&amp;context);
<span class="lineNum">    1113 </span>            :     uint8_t* pc = *ppc;
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :     if (request.body.exception != EXC_BAD_ACCESS || request.body.codeCnt != 2)
<span class="lineNum">    1116 </span>            :         return false;
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span>            :     // The faulting thread is suspended so we can access cx fields that can
<span class="lineNum">    1119 </span>            :     // normally only be accessed by the cx's active thread.
<span class="lineNum">    1120 </span>            :     AutoNoteSingleThreadedRegion anstr;
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            :     WasmActivation* activation = ActivationIfInnermost(cx);
<span class="lineNum">    1123 </span>            :     if (!activation)
<span class="lineNum">    1124 </span>            :         return false;
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :     const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(&amp;context));
<span class="lineNum">    1127 </span>            :     if (!instance || !instance-&gt;code().containsFunctionPC(pc))
<span class="lineNum">    1128 </span>            :         return false;
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :     uint8_t* faultingAddress = reinterpret_cast&lt;uint8_t*&gt;(request.body.code[1]);
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :     // This check isn't necessary, but, since we can, check anyway to make
<span class="lineNum">    1133 </span>            :     // sure we aren't covering up a real bug.
<span class="lineNum">    1134 </span>            :     if (!IsHeapAccessAddress(*instance, faultingAddress))
<span class="lineNum">    1135 </span>            :         return false;
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            :     HandleMemoryAccess(&amp;context, pc, faultingAddress, *instance, activation, ppc);
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :     // Update the thread state with the new pc and register values.
<span class="lineNum">    1140 </span>            :     kret = thread_set_state(cxThread, float_state, (thread_state_t)&amp;context.float_, float_state_count);
<span class="lineNum">    1141 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1142 </span>            :         return false;
<span class="lineNum">    1143 </span>            :     kret = thread_set_state(cxThread, thread_state, (thread_state_t)&amp;context.thread, thread_state_count);
<span class="lineNum">    1144 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1145 </span>            :         return false;
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :     return true;
<span class="lineNum">    1148 </span>            : }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            : // Taken from mach_exc in /usr/include/mach/mach_exc.defs.
<span class="lineNum">    1151 </span>            : static const mach_msg_id_t sExceptionId = 2405;
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            : // The choice of id here is arbitrary, the only constraint is that sQuitId != sExceptionId.
<span class="lineNum">    1154 </span>            : static const mach_msg_id_t sQuitId = 42;
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            : static void
<span class="lineNum">    1157 </span>            : MachExceptionHandlerThread(JSContext* cx)
<span class="lineNum">    1158 </span>            : {
<span class="lineNum">    1159 </span>            :     mach_port_t port = cx-&gt;wasmMachExceptionHandler.port();
<span class="lineNum">    1160 </span>            :     kern_return_t kret;
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span>            :     while(true) {
<span class="lineNum">    1163 </span>            :         ExceptionRequest request;
<span class="lineNum">    1164 </span>            :         kret = mach_msg(&amp;request.body.Head, MACH_RCV_MSG, 0, sizeof(request),
<span class="lineNum">    1165 </span>            :                         port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span>            :         // If we fail even receiving the message, we can't even send a reply!
<span class="lineNum">    1168 </span>            :         // Rather than hanging the faulting thread (hanging the browser), crash.
<span class="lineNum">    1169 </span>            :         if (kret != KERN_SUCCESS) {
<span class="lineNum">    1170 </span>            :             fprintf(stderr, &quot;MachExceptionHandlerThread: mach_msg failed with %d\n&quot;, (int)kret);
<span class="lineNum">    1171 </span>            :             MOZ_CRASH();
<span class="lineNum">    1172 </span>            :         }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :         // There are only two messages we should be receiving: an exception
<span class="lineNum">    1175 </span>            :         // message that occurs when the runtime's thread faults and the quit
<span class="lineNum">    1176 </span>            :         // message sent when the runtime is shutting down.
<span class="lineNum">    1177 </span>            :         if (request.body.Head.msgh_id == sQuitId)
<span class="lineNum">    1178 </span>            :             break;
<span class="lineNum">    1179 </span>            :         if (request.body.Head.msgh_id != sExceptionId) {
<span class="lineNum">    1180 </span>            :             fprintf(stderr, &quot;Unexpected msg header id %d\n&quot;, (int)request.body.Head.msgh_bits);
<span class="lineNum">    1181 </span>            :             MOZ_CRASH();
<span class="lineNum">    1182 </span>            :         }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            :         // Some thread just commited an EXC_BAD_ACCESS and has been suspended by
<span class="lineNum">    1185 </span>            :         // the kernel. The kernel is waiting for us to reply with instructions.
<span class="lineNum">    1186 </span>            :         // Our default is the &quot;not handled&quot; reply (by setting the RetCode field
<span class="lineNum">    1187 </span>            :         // of the reply to KERN_FAILURE) which tells the kernel to continue
<span class="lineNum">    1188 </span>            :         // searching at the process and system level. If this is an asm.js
<span class="lineNum">    1189 </span>            :         // expected exception, we handle it and return KERN_SUCCESS.
<span class="lineNum">    1190 </span>            :         bool handled = HandleMachException(cx, request);
<span class="lineNum">    1191 </span>            :         kern_return_t replyCode = handled ? KERN_SUCCESS : KERN_FAILURE;
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            :         // This magic incantation to send a reply back to the kernel was derived
<span class="lineNum">    1194 </span>            :         // from the exc_server generated by 'mig -v /usr/include/mach/mach_exc.defs'.
<span class="lineNum">    1195 </span>            :         __Reply__exception_raise_t reply;
<span class="lineNum">    1196 </span>            :         reply.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(request.body.Head.msgh_bits), 0);
<span class="lineNum">    1197 </span>            :         reply.Head.msgh_size = sizeof(reply);
<span class="lineNum">    1198 </span>            :         reply.Head.msgh_remote_port = request.body.Head.msgh_remote_port;
<span class="lineNum">    1199 </span>            :         reply.Head.msgh_local_port = MACH_PORT_NULL;
<span class="lineNum">    1200 </span>            :         reply.Head.msgh_id = request.body.Head.msgh_id + 100;
<span class="lineNum">    1201 </span>            :         reply.NDR = NDR_record;
<span class="lineNum">    1202 </span>            :         reply.RetCode = replyCode;
<span class="lineNum">    1203 </span>            :         mach_msg(&amp;reply.Head, MACH_SEND_MSG, sizeof(reply), 0, MACH_PORT_NULL,
<span class="lineNum">    1204 </span>            :                  MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
<span class="lineNum">    1205 </span>            :     }
<span class="lineNum">    1206 </span>            : }
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            : MachExceptionHandler::MachExceptionHandler()
<span class="lineNum">    1209 </span>            :   : installed_(false),
<span class="lineNum">    1210 </span>            :     thread_(),
<span class="lineNum">    1211 </span>            :     port_(MACH_PORT_NULL)
<span class="lineNum">    1212 </span>            : {}
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            : void
<span class="lineNum">    1215 </span>            : MachExceptionHandler::uninstall()
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span>            :     if (installed_) {
<span class="lineNum">    1218 </span>            :         thread_port_t thread = mach_thread_self();
<span class="lineNum">    1219 </span>            :         kern_return_t kret = thread_set_exception_ports(thread,
<span class="lineNum">    1220 </span>            :                                                         EXC_MASK_BAD_ACCESS,
<span class="lineNum">    1221 </span>            :                                                         MACH_PORT_NULL,
<span class="lineNum">    1222 </span>            :                                                         EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES,
<span class="lineNum">    1223 </span>            :                                                         THREAD_STATE_NONE);
<span class="lineNum">    1224 </span>            :         mach_port_deallocate(mach_task_self(), thread);
<span class="lineNum">    1225 </span>            :         if (kret != KERN_SUCCESS)
<span class="lineNum">    1226 </span>            :             MOZ_CRASH();
<span class="lineNum">    1227 </span>            :         installed_ = false;
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span>            :     if (thread_.joinable()) {
<span class="lineNum">    1230 </span>            :         // Break the handler thread out of the mach_msg loop.
<span class="lineNum">    1231 </span>            :         mach_msg_header_t msg;
<span class="lineNum">    1232 </span>            :         msg.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
<span class="lineNum">    1233 </span>            :         msg.msgh_size = sizeof(msg);
<span class="lineNum">    1234 </span>            :         msg.msgh_remote_port = port_;
<span class="lineNum">    1235 </span>            :         msg.msgh_local_port = MACH_PORT_NULL;
<span class="lineNum">    1236 </span>            :         msg.msgh_reserved = 0;
<span class="lineNum">    1237 </span>            :         msg.msgh_id = sQuitId;
<span class="lineNum">    1238 </span>            :         kern_return_t kret = mach_msg(&amp;msg, MACH_SEND_MSG, sizeof(msg), 0, MACH_PORT_NULL,
<span class="lineNum">    1239 </span>            :                                       MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
<span class="lineNum">    1240 </span>            :         if (kret != KERN_SUCCESS) {
<span class="lineNum">    1241 </span>            :             fprintf(stderr, &quot;MachExceptionHandler: failed to send quit message: %d\n&quot;, (int)kret);
<span class="lineNum">    1242 </span>            :             MOZ_CRASH();
<span class="lineNum">    1243 </span>            :         }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :         // Wait for the handler thread to complete before deallocating the port.
<span class="lineNum">    1246 </span>            :         thread_.join();
<span class="lineNum">    1247 </span>            :     }
<span class="lineNum">    1248 </span>            :     if (port_ != MACH_PORT_NULL) {
<span class="lineNum">    1249 </span>            :         DebugOnly&lt;kern_return_t&gt; kret = mach_port_destroy(mach_task_self(), port_);
<span class="lineNum">    1250 </span>            :         MOZ_ASSERT(kret == KERN_SUCCESS);
<span class="lineNum">    1251 </span>            :         port_ = MACH_PORT_NULL;
<span class="lineNum">    1252 </span>            :     }
<span class="lineNum">    1253 </span>            : }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            : bool
<span class="lineNum">    1256 </span>            : MachExceptionHandler::install(JSContext* cx)
<span class="lineNum">    1257 </span>            : {
<span class="lineNum">    1258 </span>            :     MOZ_ASSERT(!installed());
<span class="lineNum">    1259 </span>            :     kern_return_t kret;
<span class="lineNum">    1260 </span>            :     mach_port_t thread;
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :     auto onFailure = mozilla::MakeScopeExit([&amp;] {
<span class="lineNum">    1263 </span>            :         uninstall();
<span class="lineNum">    1264 </span>            :     });
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     // Get a port which can send and receive data.
<span class="lineNum">    1267 </span>            :     kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port_);
<span class="lineNum">    1268 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1269 </span>            :         return false;
<span class="lineNum">    1270 </span>            :     kret = mach_port_insert_right(mach_task_self(), port_, port_, MACH_MSG_TYPE_MAKE_SEND);
<span class="lineNum">    1271 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1272 </span>            :         return false;
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            :     // Create a thread to block on reading port_.
<span class="lineNum">    1275 </span>            :     if (!thread_.init(MachExceptionHandlerThread, cx))
<span class="lineNum">    1276 </span>            :         return false;
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :     // Direct exceptions on this thread to port_ (and thus our handler thread).
<span class="lineNum">    1279 </span>            :     // Note: we are totally clobbering any existing *thread* exception ports and
<span class="lineNum">    1280 </span>            :     // not even attempting to forward. Breakpad and gdb both use the *process*
<span class="lineNum">    1281 </span>            :     // exception ports which are only called if the thread doesn't handle the
<span class="lineNum">    1282 </span>            :     // exception, so we should be fine.
<span class="lineNum">    1283 </span>            :     thread = mach_thread_self();
<span class="lineNum">    1284 </span>            :     kret = thread_set_exception_ports(thread,
<span class="lineNum">    1285 </span>            :                                       EXC_MASK_BAD_ACCESS,
<span class="lineNum">    1286 </span>            :                                       port_,
<span class="lineNum">    1287 </span>            :                                       EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES,
<span class="lineNum">    1288 </span>            :                                       THREAD_STATE_NONE);
<span class="lineNum">    1289 </span>            :     mach_port_deallocate(mach_task_self(), thread);
<span class="lineNum">    1290 </span>            :     if (kret != KERN_SUCCESS)
<span class="lineNum">    1291 </span>            :         return false;
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :     installed_ = true;
<span class="lineNum">    1294 </span>            :     onFailure.release();
<span class="lineNum">    1295 </span>            :     return true;
<span class="lineNum">    1296 </span>            : }
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : #else  // If not Windows or Mac, assume Unix
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            : enum class Signal {
<span class="lineNum">    1301 </span>            :     SegFault,
<span class="lineNum">    1302 </span>            :     BusError
<span class="lineNum">    1303 </span>            : };
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : // Be very cautious and default to not handling; we don't want to accidentally
<span class="lineNum">    1306 </span>            : // silence real crashes from real bugs.
<a name="1307"><span class="lineNum">    1307 </span>            : template&lt;Signal signal&gt;</a>
<span class="lineNum">    1308 </span>            : static bool
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 : HandleFault(int signum, siginfo_t* info, void* ctx)</span>
<span class="lineNum">    1310 </span>            : {
<span class="lineNum">    1311 </span>            :     // The signals we're expecting come from access violations, accessing
<span class="lineNum">    1312 </span>            :     // mprotected memory. If the signal originates anywhere else, don't try
<span class="lineNum">    1313 </span>            :     // to handle it.
<span class="lineNum">    1314 </span>            :     if (signal == Signal::SegFault)
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(signum == SIGSEGV);</span>
<span class="lineNum">    1316 </span>            :     else
<span class="lineNum">    1317 </span>            :         MOZ_RELEASE_ASSERT(signum == SIGBUS);
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :     CONTEXT* context = (CONTEXT*)ctx;</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     uint8_t** ppc = ContextToPC(context);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :     uint8_t* pc = *ppc;</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :     // Don't allow recursive handling of signals, see AutoSetHandlingSegFault.
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     JSContext* cx = TlsContext.get();</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     if (!cx || cx-&gt;handlingSegFault)</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :     AutoSetHandlingSegFault handling(cx);</span>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :     WasmActivation* activation = ActivationIfInnermost(cx);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :     if (!activation)</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :     const CodeSegment* segment;
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(context));</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     if (!instance || !instance-&gt;code().containsFunctionPC(pc, &amp;segment))</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     uint8_t* faultingAddress = reinterpret_cast&lt;uint8_t*&gt;(info-&gt;si_addr);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            :     // Although it's not strictly necessary, to make sure we're not covering up
<span class="lineNum">    1341 </span>            :     // any real bugs, check that the faulting address is indeed in the
<span class="lineNum">    1342 </span>            :     // instance's memory.
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :     if (!faultingAddress) {</span>
<span class="lineNum">    1344 </span>            :         // On some Linux systems, the kernel apparently sometimes &quot;gives up&quot; and
<span class="lineNum">    1345 </span>            :         // passes a null faultingAddress with si_code set to SI_KERNEL.
<span class="lineNum">    1346 </span>            :         // This is observed on some automation machines for some out-of-bounds
<span class="lineNum">    1347 </span>            :         // atomic accesses on x86/64.
<span class="lineNum">    1348 </span>            : #ifdef SI_KERNEL
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :         if (info-&gt;si_code != SI_KERNEL)</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1351 </span>            : #else
<span class="lineNum">    1352 </span>            :         return false;
<span class="lineNum">    1353 </span>            : #endif
<span class="lineNum">    1354 </span>            :     } else {
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :         if (!IsHeapAccessAddress(*instance, faultingAddress))</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    1357 </span>            :     }
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : #ifdef JS_CODEGEN_ARM
<span class="lineNum">    1360 </span>            :     if (signal == Signal::BusError) {
<span class="lineNum">    1361 </span>            :         // TODO: We may see a bus error for something that is an unaligned access that
<span class="lineNum">    1362 </span>            :         // partly overlaps the end of the heap.  In this case, it is an out-of-bounds
<span class="lineNum">    1363 </span>            :         // error and we should signal that properly, but to do so we must inspect
<span class="lineNum">    1364 </span>            :         // the operand of the failed access.
<span class="lineNum">    1365 </span>            :         activation-&gt;startInterrupt(ToRegisterState(context));
<span class="lineNum">    1366 </span>            :         *ppc = segment-&gt;unalignedAccessCode();
<span class="lineNum">    1367 </span>            :         return true;
<span class="lineNum">    1368 </span>            :     }
<span class="lineNum">    1369 </span>            : #endif
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     HandleMemoryAccess(context, pc, faultingAddress, *instance, activation, ppc);</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1373 </span>            : }
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            : static struct sigaction sPrevSEGVHandler;
<span class="lineNum">    1376 </span>            : static struct sigaction sPrevSIGBUSHandler;
<span class="lineNum">    1377 </span>            : 
<a name="1378"><span class="lineNum">    1378 </span>            : template&lt;Signal signal&gt;</a>
<span class="lineNum">    1379 </span>            : static void
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 : WasmFaultHandler(int signum, siginfo_t* info, void* context)</span>
<span class="lineNum">    1381 </span>            : {
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :     if (HandleFault&lt;signal&gt;(signum, info, context))</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :     struct sigaction* previousSignal = signum == SIGSEGV
<span class="lineNum">    1386 </span>            :                                        ? &amp;sPrevSEGVHandler
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                                        : &amp;sPrevSIGBUSHandler;</span>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :     // This signal is not for any asm.js code we expect, so we need to forward
<span class="lineNum">    1390 </span>            :     // the signal to the next handler. If there is no next handler (SIG_IGN or
<span class="lineNum">    1391 </span>            :     // SIG_DFL), then it's time to crash. To do this, we set the signal back to
<span class="lineNum">    1392 </span>            :     // its original disposition and return. This will cause the faulting op to
<span class="lineNum">    1393 </span>            :     // be re-executed which will crash in the normal way. The advantage of
<span class="lineNum">    1394 </span>            :     // doing this to calling _exit() is that we remove ourselves from the crash
<span class="lineNum">    1395 </span>            :     // stack which improves crash reports. If there is a next handler, call it.
<span class="lineNum">    1396 </span>            :     // It will either crash synchronously, fix up the instruction so that
<span class="lineNum">    1397 </span>            :     // execution can continue and return, or trigger a crash by returning the
<span class="lineNum">    1398 </span>            :     // signal to it's original disposition and returning.
<span class="lineNum">    1399 </span>            :     //
<span class="lineNum">    1400 </span>            :     // Note: the order of these tests matter.
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :     if (previousSignal-&gt;sa_flags &amp; SA_SIGINFO)</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         previousSignal-&gt;sa_sigaction(signum, info, context);</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :     else if (previousSignal-&gt;sa_handler == SIG_DFL || previousSignal-&gt;sa_handler == SIG_IGN)</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :         sigaction(signum, previousSignal, nullptr);</span>
<span class="lineNum">    1405 </span>            :     else
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :         previousSignal-&gt;sa_handler(signum);</span>
<span class="lineNum">    1407 </span>            : }
<span class="lineNum">    1408 </span>            : # endif // XP_WIN || XP_DARWIN || assume unix
<a name="1409"><span class="lineNum">    1409 </span>            : </a>
<span class="lineNum">    1410 </span>            : static void
<span class="lineNum">    1411 </span><span class="lineCov">          2 : RedirectIonBackedgesToInterruptCheck(JSContext* cx)</span>
<span class="lineNum">    1412 </span>            : {
<span class="lineNum">    1413 </span><span class="lineCov">          2 :     if (!cx-&gt;runtime()-&gt;hasJitRuntime())</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1415 </span><span class="lineCov">          2 :     jit::JitRuntime* jitRuntime = cx-&gt;runtime()-&gt;jitRuntime();</span>
<span class="lineNum">    1416 </span><span class="lineCov">          2 :     Zone* zone = cx-&gt;zoneRaw();</span>
<span class="lineNum">    1417 </span><span class="lineCov">          2 :     if (zone &amp;&amp; !zone-&gt;isAtomsZone()) {</span>
<span class="lineNum">    1418 </span>            :         // If the backedge list is being mutated, the pc must be in C++ code and
<span class="lineNum">    1419 </span>            :         // thus not in a JIT iloop. We assume that the interrupt flag will be
<span class="lineNum">    1420 </span>            :         // checked at least once before entering JIT code (if not, no big deal;
<span class="lineNum">    1421 </span>            :         // the browser will just request another interrupt in a second).
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         if (!jitRuntime-&gt;preventBackedgePatching()) {</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :             jit::JitZoneGroup* jzg = zone-&gt;group()-&gt;jitZoneGroup;</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :             jzg-&gt;patchIonBackedges(cx, jit::JitZoneGroup::BackedgeInterruptCheck);</span>
<span class="lineNum">    1425 </span>            :         }
<span class="lineNum">    1426 </span>            :     }
<span class="lineNum">    1427 </span>            : }
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<span class="lineNum">    1429 </span>            : bool
<span class="lineNum">    1430 </span><span class="lineCov">          2 : wasm::InInterruptibleCode(JSContext* cx, uint8_t* pc, const CodeSegment** cs)</span>
<span class="lineNum">    1431 </span>            : {
<span class="lineNum">    1432 </span>            :     // Only interrupt in function code so that the frame iterators have the
<span class="lineNum">    1433 </span>            :     // invariant that resumePC always has a function CodeRange and we can't
<span class="lineNum">    1434 </span>            :     // get into any weird interrupt-during-interrupt-stub cases.
<span class="lineNum">    1435 </span><span class="lineCov">          2 :     if (!cx-&gt;compartment())</span>
<span class="lineNum">    1436 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     const Code* code = cx-&gt;compartment()-&gt;wasm.lookupCode(pc, cs);</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     return code &amp;&amp; (*cs)-&gt;containsFunctionPC(pc);</span>
<span class="lineNum">    1440 </span>            : }
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            : // The return value indicates whether the PC was changed, not whether there was
<a name="1443"><span class="lineNum">    1443 </span>            : // a failure.</a>
<span class="lineNum">    1444 </span>            : static bool
<span class="lineNum">    1445 </span><span class="lineCov">          2 : RedirectJitCodeToInterruptCheck(JSContext* cx, CONTEXT* context)</span>
<span class="lineNum">    1446 </span>            : {
<span class="lineNum">    1447 </span>            :     // Jitcode may only be modified on the runtime's active thread.
<span class="lineNum">    1448 </span><span class="lineCov">          2 :     if (cx != cx-&gt;runtime()-&gt;activeContext())</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :     // The faulting thread is suspended so we can access cx fields that can
<span class="lineNum">    1452 </span>            :     // normally only be accessed by the cx's active thread.
<span class="lineNum">    1453 </span><span class="lineCov">          4 :     AutoNoteSingleThreadedRegion anstr;</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineCov">          2 :     RedirectIonBackedgesToInterruptCheck(cx);</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : #ifdef JS_SIMULATOR
<span class="lineNum">    1458 </span>            :     uint8_t* pc = cx-&gt;simulator()-&gt;get_pc_as&lt;uint8_t*&gt;();
<span class="lineNum">    1459 </span>            : #else
<span class="lineNum">    1460 </span><span class="lineCov">          2 :     uint8_t* pc = *ContextToPC(context);</span>
<span class="lineNum">    1461 </span>            : #endif
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span><span class="lineCov">          2 :     const CodeSegment* codeSegment = nullptr;</span>
<span class="lineNum">    1464 </span><span class="lineCov">          2 :     if (!InInterruptibleCode(cx, pc, &amp;codeSegment))</span>
<span class="lineNum">    1465 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            :     // Only probe cx-&gt;activation() via ActivationIfInnermost after we know the
<span class="lineNum">    1468 </span>            :     // pc is in wasm code. This way we don't depend on signal-safe update of
<span class="lineNum">    1469 </span>            :     // cx-&gt;activation().
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     WasmActivation* activation = ActivationIfInnermost(cx);</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(activation);</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span>            : #ifdef JS_SIMULATOR
<span class="lineNum">    1474 </span>            :     // The checks performed by the !JS_SIMULATOR path happen in
<span class="lineNum">    1475 </span>            :     // Simulator::handleWasmInterrupt.
<span class="lineNum">    1476 </span>            :     cx-&gt;simulator()-&gt;trigger_wasm_interrupt();
<span class="lineNum">    1477 </span>            : #else
<span class="lineNum">    1478 </span>            :     // fp may be null when first entering wasm code from an entry stub.
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     uint8_t* fp = ContextToFP(context);</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :     if (!fp)</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :     // The out-of-bounds/unaligned trap paths which call startInterrupt() go
<span class="lineNum">    1484 </span>            :     // through function code, so test if already interrupted. These paths are
<span class="lineNum">    1485 </span>            :     // temporary though, so this case can be removed later.
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :     if (activation-&gt;interrupted())</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :     activation-&gt;startInterrupt(ToRegisterState(context));</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :     *ContextToPC(context) = codeSegment-&gt;interruptCode();</span>
<span class="lineNum">    1491 </span>            : #endif
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1494 </span>            : }
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            : #if !defined(XP_WIN)
<span class="lineNum">    1497 </span>            : // For the interrupt signal, pick a signal number that:
<span class="lineNum">    1498 </span>            : //  - is not otherwise used by mozilla or standard libraries
<span class="lineNum">    1499 </span>            : //  - defaults to nostop and noprint on gdb/lldb so that noone is bothered
<span class="lineNum">    1500 </span>            : // SIGVTALRM a relative of SIGALRM, so intended for user code, but, unlike
<span class="lineNum">    1501 </span>            : // SIGALRM, not used anywhere else in Mozilla.
<span class="lineNum">    1502 </span>            : static const int sInterruptSignal = SIGVTALRM;
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<span class="lineNum">    1504 </span>            : static void
<span class="lineNum">    1505 </span><span class="lineCov">          2 : JitInterruptHandler(int signum, siginfo_t* info, void* context)</span>
<span class="lineNum">    1506 </span>            : {
<span class="lineNum">    1507 </span><span class="lineCov">          2 :     if (JSContext* cx = TlsContext.get()) {</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            : #if defined(JS_SIMULATOR_ARM) || defined(JS_SIMULATOR_MIPS32) || defined(JS_SIMULATOR_MIPS64)
<span class="lineNum">    1510 </span>            :         SimulatorProcess::ICacheCheckingDisableCount++;
<span class="lineNum">    1511 </span>            : #endif
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineCov">          2 :         RedirectJitCodeToInterruptCheck(cx, (CONTEXT*)context);</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            : #if defined(JS_SIMULATOR_ARM) || defined(JS_SIMULATOR_MIPS32) || defined(JS_SIMULATOR_MIPS64)
<span class="lineNum">    1516 </span>            :         SimulatorProcess::cacheInvalidatedBySignalHandler_ = true;
<span class="lineNum">    1517 </span>            :         SimulatorProcess::ICacheCheckingDisableCount--;
<span class="lineNum">    1518 </span>            : #endif
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">          2 :         cx-&gt;finishHandlingJitInterrupt();</span>
<span class="lineNum">    1521 </span>            :     }
<span class="lineNum">    1522 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1523 </span>            : #endif
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            : static bool sTriedInstallSignalHandlers = false;
<span class="lineNum">    1526 </span>            : static bool sHaveSignalHandlers = false;
<a name="1527"><span class="lineNum">    1527 </span>            : </a>
<span class="lineNum">    1528 </span>            : static bool
<span class="lineNum">    1529 </span><span class="lineCov">          4 : ProcessHasSignalHandlers()</span>
<span class="lineNum">    1530 </span>            : {
<span class="lineNum">    1531 </span>            :     // We assume that there are no races creating the first JSRuntime of the process.
<span class="lineNum">    1532 </span><span class="lineCov">          4 :     if (sTriedInstallSignalHandlers)</span>
<span class="lineNum">    1533 </span><span class="lineCov">          1 :         return sHaveSignalHandlers;</span>
<span class="lineNum">    1534 </span><span class="lineCov">          3 :     sTriedInstallSignalHandlers = true;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : #if defined(ANDROID)
<span class="lineNum">    1537 </span>            : # if !defined(__aarch64__)
<span class="lineNum">    1538 </span>            :     // Before Android 4.4 (SDK version 19), there is a bug
<span class="lineNum">    1539 </span>            :     //   https://android-review.googlesource.com/#/c/52333
<span class="lineNum">    1540 </span>            :     // in Bionic's pthread_join which causes pthread_join to return early when
<span class="lineNum">    1541 </span>            :     // pthread_kill is used (on any thread). Nobody expects the pthread_cond_wait
<span class="lineNum">    1542 </span>            :     // EINTRquisition.
<span class="lineNum">    1543 </span>            :     char version_string[PROP_VALUE_MAX];
<span class="lineNum">    1544 </span>            :     PodArrayZero(version_string);
<span class="lineNum">    1545 </span>            :     if (__system_property_get(&quot;ro.build.version.sdk&quot;, version_string) &gt; 0) {
<span class="lineNum">    1546 </span>            :         if (atol(version_string) &lt; 19)
<span class="lineNum">    1547 </span>            :             return false;
<span class="lineNum">    1548 </span>            :     }
<span class="lineNum">    1549 </span>            : # endif
<span class="lineNum">    1550 </span>            : # if defined(MOZ_LINKER)
<span class="lineNum">    1551 </span>            :     // Signal handling is broken on some android systems.
<span class="lineNum">    1552 </span>            :     if (IsSignalHandlingBroken())
<span class="lineNum">    1553 </span>            :         return false;
<span class="lineNum">    1554 </span>            : # endif
<span class="lineNum">    1555 </span>            : #endif
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            :     // The interrupt handler allows the active thread to be paused from another
<span class="lineNum">    1558 </span>            :     // thread (see InterruptRunningJitCode).
<span class="lineNum">    1559 </span>            : #if defined(XP_WIN)
<span class="lineNum">    1560 </span>            :     // Windows uses SuspendThread to stop the active thread from another thread.
<span class="lineNum">    1561 </span>            : #else
<span class="lineNum">    1562 </span>            :     struct sigaction interruptHandler;
<span class="lineNum">    1563 </span><span class="lineCov">          3 :     interruptHandler.sa_flags = SA_SIGINFO;</span>
<span class="lineNum">    1564 </span><span class="lineCov">          3 :     interruptHandler.sa_sigaction = &amp;JitInterruptHandler;</span>
<span class="lineNum">    1565 </span><span class="lineCov">          3 :     sigemptyset(&amp;interruptHandler.sa_mask);</span>
<span class="lineNum">    1566 </span>            :     struct sigaction prev;
<span class="lineNum">    1567 </span><span class="lineCov">          3 :     if (sigaction(sInterruptSignal, &amp;interruptHandler, &amp;prev))</span>
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;unable to install interrupt handler&quot;);</span>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span>            :     // There shouldn't be any other handlers installed for sInterruptSignal. If
<span class="lineNum">    1571 </span>            :     // there are, we could always forward, but we need to understand what we're
<span class="lineNum">    1572 </span>            :     // doing to avoid problematic interference.
<span class="lineNum">    1573 </span><span class="lineCov">          6 :     if ((prev.sa_flags &amp; SA_SIGINFO &amp;&amp; prev.sa_sigaction) ||</span>
<span class="lineNum">    1574 </span><span class="lineCov">          3 :         (prev.sa_handler != SIG_DFL &amp;&amp; prev.sa_handler != SIG_IGN))</span>
<span class="lineNum">    1575 </span>            :     {
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;contention for interrupt signal&quot;);</span>
<span class="lineNum">    1577 </span>            :     }
<span class="lineNum">    1578 </span>            : #endif // defined(XP_WIN)
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :     // Install a SIGSEGV handler to handle safely-out-of-bounds asm.js heap
<span class="lineNum">    1581 </span>            :     // access and/or unaligned accesses.
<span class="lineNum">    1582 </span>            : # if defined(XP_WIN)
<span class="lineNum">    1583 </span>            : #  if defined(MOZ_ASAN)
<span class="lineNum">    1584 </span>            :     // Under ASan we need to let the ASan runtime's ShadowExceptionHandler stay
<span class="lineNum">    1585 </span>            :     // in the first handler position. This requires some coordination with
<span class="lineNum">    1586 </span>            :     // MemoryProtectionExceptionHandler::isDisabled().
<span class="lineNum">    1587 </span>            :     const bool firstHandler = false;
<span class="lineNum">    1588 </span>            : #  else
<span class="lineNum">    1589 </span>            :     // Otherwise, WasmFaultHandler needs to go first, so that we can recover
<span class="lineNum">    1590 </span>            :     // from wasm faults and continue execution without triggering handlers
<span class="lineNum">    1591 </span>            :     // such as MemoryProtectionExceptionHandler that assume we are crashing.
<span class="lineNum">    1592 </span>            :     const bool firstHandler = true;
<span class="lineNum">    1593 </span>            : #  endif
<span class="lineNum">    1594 </span>            :     if (!AddVectoredExceptionHandler(firstHandler, WasmFaultHandler))
<span class="lineNum">    1595 </span>            :         return false;
<span class="lineNum">    1596 </span>            : # elif defined(XP_DARWIN)
<span class="lineNum">    1597 </span>            :     // OSX handles seg faults via the Mach exception handler above, so don't
<span class="lineNum">    1598 </span>            :     // install WasmFaultHandler.
<span class="lineNum">    1599 </span>            : # else
<span class="lineNum">    1600 </span>            :     // SA_NODEFER allows us to reenter the signal handler if we crash while
<span class="lineNum">    1601 </span>            :     // handling the signal, and fall through to the Breakpad handler by testing
<span class="lineNum">    1602 </span>            :     // handlingSegFault.
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            :     // Allow handling OOB with signals on all architectures
<span class="lineNum">    1605 </span>            :     struct sigaction faultHandler;
<span class="lineNum">    1606 </span><span class="lineCov">          3 :     faultHandler.sa_flags = SA_SIGINFO | SA_NODEFER;</span>
<span class="lineNum">    1607 </span><span class="lineCov">          3 :     faultHandler.sa_sigaction = WasmFaultHandler&lt;Signal::SegFault&gt;;</span>
<span class="lineNum">    1608 </span><span class="lineCov">          3 :     sigemptyset(&amp;faultHandler.sa_mask);</span>
<span class="lineNum">    1609 </span><span class="lineCov">          3 :     if (sigaction(SIGSEGV, &amp;faultHandler, &amp;sPrevSEGVHandler))</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;unable to install segv handler&quot;);</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            : #  if defined(JS_CODEGEN_ARM)
<span class="lineNum">    1613 </span>            :     // On Arm Handle Unaligned Accesses
<span class="lineNum">    1614 </span>            :     struct sigaction busHandler;
<span class="lineNum">    1615 </span>            :     busHandler.sa_flags = SA_SIGINFO | SA_NODEFER;
<span class="lineNum">    1616 </span>            :     busHandler.sa_sigaction = WasmFaultHandler&lt;Signal::BusError&gt;;
<span class="lineNum">    1617 </span>            :     sigemptyset(&amp;busHandler.sa_mask);
<span class="lineNum">    1618 </span>            :     if (sigaction(SIGBUS, &amp;busHandler, &amp;sPrevSIGBUSHandler))
<span class="lineNum">    1619 </span>            :         MOZ_CRASH(&quot;unable to install sigbus handler&quot;);
<span class="lineNum">    1620 </span>            : #  endif
<span class="lineNum">    1621 </span>            : # endif
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineCov">          3 :     sHaveSignalHandlers = true;</span>
<span class="lineNum">    1624 </span><span class="lineCov">          3 :     return true;</span>
<span class="lineNum">    1625 </span>            : }
<a name="1626"><span class="lineNum">    1626 </span>            : </a>
<span class="lineNum">    1627 </span>            : bool
<span class="lineNum">    1628 </span><span class="lineCov">          4 : wasm::EnsureSignalHandlers(JSContext* cx)</span>
<span class="lineNum">    1629 </span>            : {
<span class="lineNum">    1630 </span>            :     // Nothing to do if the platform doesn't support it.
<span class="lineNum">    1631 </span><span class="lineCov">          4 :     if (!ProcessHasSignalHandlers())</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            : #if defined(XP_DARWIN)
<span class="lineNum">    1635 </span>            :     // On OSX, each JSContext which runs wasm gets its own handler thread.
<span class="lineNum">    1636 </span>            :     if (!cx-&gt;wasmMachExceptionHandler.installed() &amp;&amp; !cx-&gt;wasmMachExceptionHandler.install(cx))
<span class="lineNum">    1637 </span>            :         return false;
<span class="lineNum">    1638 </span>            : #endif
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span><span class="lineCov">          4 :     return true;</span>
<span class="lineNum">    1641 </span>            : }
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<span class="lineNum">    1643 </span>            : bool
<span class="lineNum">    1644 </span><span class="lineCov">         19 : wasm::HaveSignalHandlers()</span>
<span class="lineNum">    1645 </span>            : {
<span class="lineNum">    1646 </span><span class="lineCov">         19 :     MOZ_ASSERT(sTriedInstallSignalHandlers);</span>
<span class="lineNum">    1647 </span><span class="lineCov">         19 :     return sHaveSignalHandlers;</span>
<span class="lineNum">    1648 </span>            : }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : // JSRuntime::requestInterrupt sets interrupt_ (which is checked frequently by
<span class="lineNum">    1651 </span>            : // C++ code at every Baseline JIT loop backedge) and jitStackLimit_ (which is
<span class="lineNum">    1652 </span>            : // checked at every Baseline and Ion JIT function prologue). The remaining
<span class="lineNum">    1653 </span>            : // sources of potential iloops (Ion loop backedges and all wasm code) are
<span class="lineNum">    1654 </span>            : // handled by this function:
<span class="lineNum">    1655 </span>            : //  1. Ion loop backedges are patched to instead point to a stub that handles
<span class="lineNum">    1656 </span>            : //     the interrupt;
<span class="lineNum">    1657 </span>            : //  2. if the active thread's pc is inside wasm code, the pc is updated to point
<a name="1658"><span class="lineNum">    1658 </span>            : //     to a stub that handles the interrupt.</a>
<span class="lineNum">    1659 </span>            : void
<span class="lineNum">    1660 </span><span class="lineCov">          2 : js::InterruptRunningJitCode(JSContext* cx)</span>
<span class="lineNum">    1661 </span>            : {
<span class="lineNum">    1662 </span>            :     // If signal handlers weren't installed, then Ion and wasm emit normal
<span class="lineNum">    1663 </span>            :     // interrupt checks and don't need asynchronous interruption.
<span class="lineNum">    1664 </span><span class="lineCov">          2 :     if (!HaveSignalHandlers())</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :     // Do nothing if we're already handling an interrupt here, to avoid races
<span class="lineNum">    1668 </span>            :     // below and in JitRuntime::patchIonBackedges.
<span class="lineNum">    1669 </span><span class="lineCov">          2 :     if (!cx-&gt;startHandlingJitInterrupt())</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            :     // If we are on context's thread, then: pc is not in wasm code (so nothing
<span class="lineNum">    1673 </span>            :     // to do for wasm) and we can patch Ion backedges without any special
<span class="lineNum">    1674 </span>            :     // synchronization.
<span class="lineNum">    1675 </span><span class="lineCov">          2 :     if (cx == TlsContext.get()) {</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :         RedirectIonBackedgesToInterruptCheck(cx);</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :         cx-&gt;finishHandlingJitInterrupt();</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1679 </span>            :     }
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            :     // We are not on the runtime's active thread, so to do 1 and 2 above, we need
<span class="lineNum">    1682 </span>            :     // to halt the runtime's active thread first.
<span class="lineNum">    1683 </span>            : #if defined(XP_WIN)
<span class="lineNum">    1684 </span>            :     // On Windows, we can simply suspend the active thread and work directly on
<span class="lineNum">    1685 </span>            :     // its context from this thread. SuspendThread can sporadically fail if the
<span class="lineNum">    1686 </span>            :     // thread is in the middle of a syscall. Rather than retrying in a loop,
<span class="lineNum">    1687 </span>            :     // just wait for the next request for interrupt.
<span class="lineNum">    1688 </span>            :     HANDLE thread = (HANDLE)cx-&gt;threadNative();
<span class="lineNum">    1689 </span>            :     if (SuspendThread(thread) != (DWORD)-1) {
<span class="lineNum">    1690 </span>            :         CONTEXT context;
<span class="lineNum">    1691 </span>            :         context.ContextFlags = CONTEXT_FULL;
<span class="lineNum">    1692 </span>            :         if (GetThreadContext(thread, &amp;context)) {
<span class="lineNum">    1693 </span>            :             if (RedirectJitCodeToInterruptCheck(cx, &amp;context))
<span class="lineNum">    1694 </span>            :                 SetThreadContext(thread, &amp;context);
<span class="lineNum">    1695 </span>            :         }
<span class="lineNum">    1696 </span>            :         ResumeThread(thread);
<span class="lineNum">    1697 </span>            :     }
<span class="lineNum">    1698 </span>            :     cx-&gt;finishHandlingJitInterrupt();
<span class="lineNum">    1699 </span>            : #else
<span class="lineNum">    1700 </span>            :     // On Unix, we instead deliver an async signal to the active thread which
<span class="lineNum">    1701 </span>            :     // halts the thread and callers our JitInterruptHandler (which has already
<span class="lineNum">    1702 </span>            :     // been installed by EnsureSignalHandlersInstalled).
<span class="lineNum">    1703 </span><span class="lineCov">          2 :     pthread_t thread = (pthread_t)cx-&gt;threadNative();</span>
<span class="lineNum">    1704 </span><span class="lineCov">          2 :     pthread_kill(thread, sInterruptSignal);</span>
<span class="lineNum">    1705 </span>            : #endif
<span class="lineNum">    1706 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

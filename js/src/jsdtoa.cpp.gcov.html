<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jsdtoa.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">js/src</a> - jsdtoa.cpp<span style="font-size: 80%;"> (source / <a href="jsdtoa.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">54</td>
            <td class="headerCovTableEntry">277</td>
            <td class="headerCovTableEntryLo">19.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">44.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /*
<span class="lineNum">       8 </span>            :  * Portable double to alphanumeric string and back converters.
<span class="lineNum">       9 </span>            :  */
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;jsdtoa.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;jsprf.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;jstypes.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;jsutil.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : using namespace js;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #if MOZ_LITTLE_ENDIAN
<span class="lineNum">      20 </span>            : #define IEEE_8087
<span class="lineNum">      21 </span>            : #else
<span class="lineNum">      22 </span>            : #define IEEE_MC68k
<span class="lineNum">      23 </span>            : #endif
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #ifndef Long
<span class="lineNum">      26 </span>            : #define Long int32_t
<span class="lineNum">      27 </span>            : #endif
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #ifndef ULong
<span class="lineNum">      30 </span>            : #define ULong uint32_t
<span class="lineNum">      31 </span>            : #endif
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : /*
<span class="lineNum">      34 </span>            : #ifndef Llong
<span class="lineNum">      35 </span>            : #define Llong int64_t
<span class="lineNum">      36 </span>            : #endif
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #ifndef ULlong
<span class="lineNum">      39 </span>            : #define ULlong uint64_t
<span class="lineNum">      40 </span>            : #endif
<span class="lineNum">      41 </span>            : */
<span class="lineNum">      42 </span>            : 
<a name="43"><span class="lineNum">      43 </span>            : // dtoa.c requires that MALLOC be infallible. Furthermore, its allocations are</a>
<span class="lineNum">      44 </span>            : // few and small. So AutoEnterOOMUnsafeRegion is appropriate here.
<span class="lineNum">      45 </span><span class="lineCov">          7 : static inline void* dtoa_malloc(size_t size)</span>
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span><span class="lineCov">         14 :     AutoEnterOOMUnsafeRegion oomUnsafe;</span>
<span class="lineNum">      48 </span><span class="lineCov">          7 :     void* p = js_malloc(size);</span>
<span class="lineNum">      49 </span><span class="lineCov">          7 :     if (!p)</span>
<span class="lineNum">      50 </span><span class="lineNoCov">          0 :         oomUnsafe.crash(&quot;dtoa_malloc&quot;);</span>
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span><span class="lineCov">         14 :     return p;</span>
<a name="53"><span class="lineNum">      53 </span>            : }</a>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span><span class="lineNoCov">          0 : static inline void dtoa_free(void* p)</span>
<span class="lineNum">      56 </span>            : {
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   return js_free(p);</span>
<span class="lineNum">      58 </span>            : }
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #define NO_GLOBAL_STATE
<span class="lineNum">      61 </span>            : #define NO_ERRNO
<span class="lineNum">      62 </span>            : #define Omit_Private_Memory // This saves memory for the workloads we see.
<span class="lineNum">      63 </span>            : #define MALLOC dtoa_malloc
<span class="lineNum">      64 </span>            : #define FREE dtoa_free
<span class="lineNum">      65 </span>            : #include &quot;dtoa.c&quot;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* Mapping of JSDToStrMode -&gt; js_dtoa mode */
<span class="lineNum">      68 </span>            : static const uint8_t dtoaModes[] = {
<span class="lineNum">      69 </span>            :     0,   /* DTOSTR_STANDARD */
<span class="lineNum">      70 </span>            :     0,   /* DTOSTR_STANDARD_EXPONENTIAL, */
<span class="lineNum">      71 </span>            :     3,   /* DTOSTR_FIXED, */
<span class="lineNum">      72 </span>            :     2,   /* DTOSTR_EXPONENTIAL, */
<span class="lineNum">      73 </span>            :     2};  /* DTOSTR_PRECISION */
<a name="74"><span class="lineNum">      74 </span>            : </a>
<span class="lineNum">      75 </span>            : double
<span class="lineNum">      76 </span><span class="lineCov">        108 : js_strtod_harder(DtoaState* state, const char* s00, char** se, int* err)</span>
<span class="lineNum">      77 </span>            : {
<span class="lineNum">      78 </span>            :     double retval;
<span class="lineNum">      79 </span><span class="lineCov">        108 :     if (err)</span>
<span class="lineNum">      80 </span><span class="lineCov">        108 :         *err = 0;</span>
<span class="lineNum">      81 </span><span class="lineCov">        108 :     retval = _strtod(state, s00, se);</span>
<span class="lineNum">      82 </span><span class="lineCov">        108 :     return retval;</span>
<span class="lineNum">      83 </span>            : }
<a name="84"><span class="lineNum">      84 </span>            : </a>
<span class="lineNum">      85 </span>            : char*
<span class="lineNum">      86 </span><span class="lineCov">         14 : js_dtostr(DtoaState* state, char* buffer, size_t bufferSize, JSDToStrMode mode, int precision,</span>
<span class="lineNum">      87 </span>            :           double dinput)
<span class="lineNum">      88 </span>            : {
<span class="lineNum">      89 </span>            :     U d;
<span class="lineNum">      90 </span>            :     int decPt;        /* Offset of decimal point from first digit */
<span class="lineNum">      91 </span>            :     int sign;         /* Nonzero if the sign bit was set in d */
<span class="lineNum">      92 </span>            :     int nDigits;      /* Number of significand digits returned by js_dtoa */
<span class="lineNum">      93 </span>            :     char* numBegin;   /* Pointer to the digits returned by js_dtoa */
<span class="lineNum">      94 </span><span class="lineCov">         14 :     char* numEnd = 0; /* Pointer past the digits returned by js_dtoa */</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span><span class="lineCov">         14 :     MOZ_ASSERT(bufferSize &gt;= (size_t)(mode &lt;= DTOSTR_STANDARD_EXPONENTIAL</span>
<span class="lineNum">      97 </span>            :                                      ? DTOSTR_STANDARD_BUFFER_SIZE
<span class="lineNum">      98 </span>            :                                      : DTOSTR_VARIABLE_BUFFER_SIZE(precision)));
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     /*
<span class="lineNum">     101 </span>            :      * Change mode here rather than below because the buffer may not be large
<span class="lineNum">     102 </span>            :      * enough to hold a large integer.
<span class="lineNum">     103 </span>            :      */
<span class="lineNum">     104 </span><span class="lineCov">         14 :     if (mode == DTOSTR_FIXED &amp;&amp; (dinput &gt;= 1e21 || dinput &lt;= -1e21))</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         mode = DTOSTR_STANDARD;</span>
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span><span class="lineCov">         14 :     dval(d) = dinput;</span>
<span class="lineNum">     108 </span><span class="lineCov">         14 :     numBegin = dtoa(PASS_STATE d, dtoaModes[mode], precision, &amp;decPt, &amp;sign, &amp;numEnd);</span>
<span class="lineNum">     109 </span><span class="lineCov">         14 :     if (!numBegin) {</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">     111 </span>            :     }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">         14 :     nDigits = numEnd - numBegin;</span>
<span class="lineNum">     114 </span><span class="lineCov">         14 :     MOZ_ASSERT((size_t) nDigits &lt;= bufferSize - 2);</span>
<span class="lineNum">     115 </span><span class="lineCov">         14 :     if ((size_t) nDigits &gt; bufferSize - 2) {</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">     117 </span>            :     }
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span><span class="lineCov">         14 :     js_memcpy(buffer + 2, numBegin, nDigits);</span>
<span class="lineNum">     120 </span><span class="lineCov">         14 :     freedtoa(PASS_STATE numBegin);</span>
<span class="lineNum">     121 </span><span class="lineCov">         14 :     numBegin = buffer + 2; /* +2 leaves space for sign and/or decimal point */</span>
<span class="lineNum">     122 </span><span class="lineCov">         14 :     numEnd = numBegin + nDigits;</span>
<span class="lineNum">     123 </span><span class="lineCov">         14 :     *numEnd = '\0';</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :     /* If Infinity, -Infinity, or NaN, return the string regardless of mode. */
<span class="lineNum">     126 </span><span class="lineCov">         14 :     if (decPt != 9999) {</span>
<span class="lineNum">     127 </span><span class="lineCov">         14 :         bool exponentialNotation = false;</span>
<span class="lineNum">     128 </span><span class="lineCov">         14 :         int minNDigits = 0;  /* Min number of significant digits required */</span>
<span class="lineNum">     129 </span>            :         char* p;
<span class="lineNum">     130 </span>            :         char* q;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">         14 :         switch (mode) {</span>
<span class="lineNum">     133 </span>            :             case DTOSTR_STANDARD:
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :                 if (decPt &lt; -5 || decPt &gt; 21)</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :                     exponentialNotation = true;</span>
<span class="lineNum">     136 </span>            :                 else
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :                     minNDigits = decPt;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :             case DTOSTR_FIXED:
<span class="lineNum">     141 </span><span class="lineCov">         14 :                 if (precision &gt;= 0)</span>
<span class="lineNum">     142 </span><span class="lineCov">         14 :                     minNDigits = decPt + precision;</span>
<span class="lineNum">     143 </span>            :                 else
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                     minNDigits = decPt;</span>
<span class="lineNum">     145 </span><span class="lineCov">         14 :                 break;</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :             case DTOSTR_EXPONENTIAL:
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(precision &gt; 0);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 minNDigits = precision;</span>
<span class="lineNum">     150 </span>            :                 MOZ_FALLTHROUGH;
<span class="lineNum">     151 </span>            :             case DTOSTR_STANDARD_EXPONENTIAL:
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :                 exponentialNotation = true;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :             case DTOSTR_PRECISION:
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(precision &gt; 0);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                 minNDigits = precision;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :                 if (decPt &lt; -5 || decPt &gt; precision)</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                     exponentialNotation = true;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     161 </span>            :         }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :         /* If the number has fewer than minNDigits, end-pad it with zeros. */
<span class="lineNum">     164 </span><span class="lineCov">         14 :         if (nDigits &lt; minNDigits) {</span>
<span class="lineNum">     165 </span><span class="lineCov">         14 :             p = numBegin + minNDigits;</span>
<span class="lineNum">     166 </span><span class="lineCov">         14 :             nDigits = minNDigits;</span>
<span class="lineNum">     167 </span><span class="lineCov">         14 :             do {</span>
<span class="lineNum">     168 </span><span class="lineCov">         28 :                 *numEnd++ = '0';</span>
<span class="lineNum">     169 </span><span class="lineCov">         28 :             } while (numEnd != p);</span>
<span class="lineNum">     170 </span><span class="lineCov">         14 :             *numEnd = '\0';</span>
<span class="lineNum">     171 </span>            :         }
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineCov">         14 :         if (exponentialNotation) {</span>
<span class="lineNum">     174 </span>            :             /* Insert a decimal point if more than one significand digit */
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :             if (nDigits != 1) {</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :                 numBegin--;</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                 numBegin[0] = numBegin[1];</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 numBegin[1] = '.';</span>
<span class="lineNum">     179 </span>            :             }
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :             snprintf(numEnd, bufferSize - (numEnd - buffer), &quot;e%+d&quot;, decPt-1);</span>
<span class="lineNum">     181 </span><span class="lineCov">         14 :         } else if (decPt != nDigits) {</span>
<span class="lineNum">     182 </span>            :             /* Some kind of a fraction in fixed notation */
<span class="lineNum">     183 </span><span class="lineCov">         14 :             MOZ_ASSERT(decPt &lt;= nDigits);</span>
<span class="lineNum">     184 </span><span class="lineCov">         14 :             if (decPt &gt; 0) {</span>
<span class="lineNum">     185 </span>            :                 /* dd...dd . dd...dd */
<span class="lineNum">     186 </span><span class="lineCov">         14 :                 p = --numBegin;</span>
<span class="lineNum">     187 </span><span class="lineCov">         28 :                 do {</span>
<span class="lineNum">     188 </span><span class="lineCov">         14 :                     *p = p[1];</span>
<span class="lineNum">     189 </span><span class="lineCov">         14 :                     p++;</span>
<span class="lineNum">     190 </span><span class="lineCov">         28 :                 } while (--decPt);</span>
<span class="lineNum">     191 </span><span class="lineCov">         14 :                 *p = '.';</span>
<span class="lineNum">     192 </span>            :             } else {
<span class="lineNum">     193 </span>            :                 /* 0 . 00...00dd...dd */
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :                 p = numEnd;</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 numEnd += 1 - decPt;</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                 q = numEnd;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(numEnd &lt; buffer + bufferSize);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :                 *numEnd = '\0';</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                 while (p != numBegin)</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :                     *--q = *--p;</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 for (p = numBegin + 1; p != q; p++)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :                     *p = '0';</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :                 *numBegin = '.';</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :                 *--numBegin = '0';</span>
<span class="lineNum">     205 </span>            :             }
<span class="lineNum">     206 </span>            :         }
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :     /* If negative and neither -0.0 nor NaN, output a leading '-'. */
<span class="lineNum">     210 </span><span class="lineCov">         14 :     if (sign &amp;&amp;</span>
<span class="lineNum">     211 </span><span class="lineCov">         14 :             !(word0(d) == Sign_bit &amp;&amp; word1(d) == 0) &amp;&amp;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :             !((word0(d) &amp; Exp_mask) == Exp_mask &amp;&amp;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :               (word1(d) || (word0(d) &amp; Frac_mask)))) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         *--numBegin = '-';</span>
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span><span class="lineCov">         14 :     return numBegin;</span>
<span class="lineNum">     217 </span>            : }
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : /* Let b = floor(b / divisor), and return the remainder.  b must be nonnegative.
<span class="lineNum">     221 </span>            :  * divisor must be between 1 and 65536.
<a name="222"><span class="lineNum">     222 </span>            :  * This function cannot run out of memory. */</a>
<span class="lineNum">     223 </span>            : static uint32_t
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : divrem(Bigint* b, uint32_t divisor)</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     int32_t n = b-&gt;wds;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     uint32_t remainder = 0;</span>
<span class="lineNum">     228 </span>            :     ULong* bx;
<span class="lineNum">     229 </span>            :     ULong* bp;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(divisor &gt; 0 &amp;&amp; divisor &lt;= 65536);</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :     if (!n)</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         return 0; /* b is zero */</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     bx = b-&gt;x;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     bp = bx + n;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     do {</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         ULong a = *--bp;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         ULong dividend = remainder &lt;&lt; 16 | a &gt;&gt; 16;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :         ULong quotientHi = dividend / divisor;</span>
<span class="lineNum">     241 </span>            :         ULong quotientLo;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         remainder = dividend - quotientHi*divisor;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(quotientHi &lt;= 0xFFFF &amp;&amp; remainder &lt; divisor);</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         dividend = remainder &lt;&lt; 16 | (a &amp; 0xFFFF);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         quotientLo = dividend / divisor;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         remainder = dividend - quotientLo*divisor;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(quotientLo &lt;= 0xFFFF &amp;&amp; remainder &lt; divisor);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         *bp = quotientHi &lt;&lt; 16 | quotientLo;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     } while (bp != bx);</span>
<span class="lineNum">     251 </span>            :     /* Decrease the size of the number if its most significant word is now zero. */
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     if (bx[n-1] == 0)</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         b-&gt;wds--;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     return remainder;</span>
<span class="lineNum">     255 </span>            : }
<a name="256"><span class="lineNum">     256 </span>            : </a>
<span class="lineNum">     257 </span>            : /* Return floor(b/2^k) and set b to be the remainder.  The returned quotient must be less than 2^32. */
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : static uint32_t quorem2(Bigint* b, int32_t k)</span>
<span class="lineNum">     259 </span>            : {
<span class="lineNum">     260 </span>            :     ULong mask;
<span class="lineNum">     261 </span>            :     ULong result;
<span class="lineNum">     262 </span>            :     ULong* bx;
<span class="lineNum">     263 </span>            :     ULong* bxe;
<span class="lineNum">     264 </span>            :     int32_t w;
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     int32_t n = k &gt;&gt; 5;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     k &amp;= 0x1F;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     mask = (1&lt;&lt;k) - 1;</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     w = b-&gt;wds - n;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     if (w &lt;= 0)</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(w &lt;= 2);</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     bx = b-&gt;x;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :     bxe = bx + n;</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     result = *bxe &gt;&gt; k;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :     *bxe &amp;= mask;</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     if (w == 2) {</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(!(bxe[1] &amp; ~mask));</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         if (k)</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             result |= bxe[1] &lt;&lt; (32 - k);</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     n++;</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :     while (!*bxe &amp;&amp; bxe != bx) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         n--;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         bxe--;</span>
<span class="lineNum">     286 </span>            :     }
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     b-&gt;wds = n;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     289 </span>            : }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : /* &quot;-0.0000...(1073 zeros after decimal point)...0001\0&quot; is the longest string that we could produce,
<span class="lineNum">     293 </span>            :  * which occurs when printing -5e-324 in binary.  We could compute a better estimate of the size of
<span class="lineNum">     294 </span>            :  * the output string and malloc fewer bytes depending on d and base, but why bother? */
<span class="lineNum">     295 </span>            : #define DTOBASESTR_BUFFER_SIZE 1078
<span class="lineNum">     296 </span>            : #define BASEDIGIT(digit) ((char)(((digit) &gt;= 10) ? 'a' - 10 + (digit) : '0' + (digit)))
<a name="297"><span class="lineNum">     297 </span>            : </a>
<span class="lineNum">     298 </span>            : char*
<span class="lineNum">     299 </span><span class="lineNoCov">          0 : js_dtobasestr(DtoaState* state, int base, double dinput)</span>
<span class="lineNum">     300 </span>            : {
<span class="lineNum">     301 </span>            :     U d;
<span class="lineNum">     302 </span>            :     char* buffer;        /* The output string */
<span class="lineNum">     303 </span>            :     char* p;             /* Pointer to current position in the buffer */
<span class="lineNum">     304 </span>            :     char* pInt;          /* Pointer to the beginning of the integer part of the string */
<span class="lineNum">     305 </span>            :     char* q;
<span class="lineNum">     306 </span>            :     uint32_t digit;
<span class="lineNum">     307 </span>            :     U di;                /* d truncated to an integer */
<span class="lineNum">     308 </span>            :     U df;                /* The fractional part of d */
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(base &gt;= 2 &amp;&amp; base &lt;= 36);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     dval(d) = dinput;</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     buffer = (char*) js_malloc(DTOBASESTR_BUFFER_SIZE);</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     if (!buffer)</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     p = buffer;</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (dval(d) &lt; 0.0</span>
<span class="lineNum">     319 </span>            : #if defined(XP_WIN)
<span class="lineNum">     320 </span>            :         &amp;&amp; !((word0(d) &amp; Exp_mask) == Exp_mask &amp;&amp; ((word0(d) &amp; Frac_mask) || word1(d))) /* Visual C++ doesn't know how to compare against NaN */
<span class="lineNum">     321 </span>            : #endif
<span class="lineNum">     322 </span>            :        ) {
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         *p++ = '-';</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         dval(d) = -dval(d);</span>
<span class="lineNum">     325 </span>            :     }
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :     /* Check for Infinity and NaN */
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     if ((word0(d) &amp; Exp_mask) == Exp_mask) {</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         strcpy(p, !word1(d) &amp;&amp; !(word0(d) &amp; Frac_mask) ? &quot;Infinity&quot; : &quot;NaN&quot;);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         return buffer;</span>
<span class="lineNum">     331 </span>            :     }
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :     /* Output the integer part of d with the digits in reverse order. */
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     pInt = p;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     dval(di) = floor(dval(d));</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     if (dval(di) &lt;= 4294967295.0) {</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :         uint32_t n = (uint32_t)dval(di);</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         if (n)</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :             do {</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                 uint32_t m = n / base;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                 digit = n - m*base;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                 n = m;</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(digit &lt; (uint32_t)base);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :                 *p++ = BASEDIGIT(digit);</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :             } while (n);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         else *p++ = '0';</span>
<span class="lineNum">     347 </span>            :     } else {
<span class="lineNum">     348 </span>            :         int e;
<span class="lineNum">     349 </span>            :         int bits;  /* Number of significant bits in di; not used. */
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         Bigint* b = d2b(PASS_STATE di, &amp;e, &amp;bits);</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         if (!b)</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :             goto nomem1;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         b = lshift(PASS_STATE b, e);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         if (!b) {</span>
<span class="lineNum">     355 </span>            :           nomem1:
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE b);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :             js_free(buffer);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :             return nullptr;</span>
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             digit = divrem(b, base);</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(digit &lt; (uint32_t)base);</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :             *p++ = BASEDIGIT(digit);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         } while (b-&gt;wds);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         Bfree(PASS_STATE b);</span>
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span>            :     /* Reverse the digits of the integer part of d. */
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     q = p-1;</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     while (q &gt; pInt) {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         char ch = *pInt;</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         *pInt++ = *q;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         *q-- = ch;</span>
<span class="lineNum">     373 </span>            :     }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     dval(df) = dval(d) - dval(di);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if (dval(df) != 0.0) {</span>
<span class="lineNum">     377 </span>            :         /* We have a fraction. */
<span class="lineNum">     378 </span>            :         int e, bbits;
<span class="lineNum">     379 </span>            :         int32_t s2, done;
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         Bigint* b = nullptr;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         Bigint* s = nullptr;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         Bigint* mlo = nullptr;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         Bigint* mhi = nullptr;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         *p++ = '.';</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         b = d2b(PASS_STATE df, &amp;e, &amp;bbits);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         if (!b) {</span>
<span class="lineNum">     388 </span>            :           nomem2:
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE b);</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE s);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             if (mlo != mhi)</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :                 Bfree(PASS_STATE mlo);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE mhi);</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :             js_free(buffer);</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :             return nullptr;</span>
<span class="lineNum">     396 </span>            :         }
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(e &lt; 0);</span>
<span class="lineNum">     398 </span>            :         /* At this point df = b * 2^e.  e must be less than zero because 0 &lt; df &lt; 1. */
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         s2 = -(int32_t)(word0(d) &gt;&gt; Exp_shift1 &amp; Exp_mask&gt;&gt;Exp_shift1);</span>
<span class="lineNum">     401 </span>            : #ifndef Sudden_Underflow
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :         if (!s2)</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             s2 = -1;</span>
<span class="lineNum">     404 </span>            : #endif
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :         s2 += Bias + P;</span>
<span class="lineNum">     406 </span>            :         /* 1/2^s2 = (nextDouble(d) - d)/2 */
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(-s2 &lt; e);</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         mlo = i2b(PASS_STATE 1);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         if (!mlo)</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :             goto nomem2;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         mhi = mlo;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :         if (!word1(d) &amp;&amp; !(word0(d) &amp; Bndry_mask)</span>
<span class="lineNum">     413 </span>            : #ifndef Sudden_Underflow
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :             &amp;&amp; word0(d) &amp; (Exp_mask &amp; Exp_mask &lt;&lt; 1)</span>
<span class="lineNum">     415 </span>            : #endif
<span class="lineNum">     416 </span>            :             ) {
<span class="lineNum">     417 </span>            :             /* The special case.  Here we want to be within a quarter of the last input
<span class="lineNum">     418 </span>            :                significant digit instead of one half of it when the output string's value is less than d.  */
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :             s2 += Log2P;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :             mhi = i2b(PASS_STATE 1&lt;&lt;Log2P);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             if (!mhi)</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                 goto nomem2;</span>
<span class="lineNum">     423 </span>            :         }
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :         b = lshift(PASS_STATE b, e + s2);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         if (!b)</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             goto nomem2;</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         s = i2b(PASS_STATE 1);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         if (!s)</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             goto nomem2;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :         s = lshift(PASS_STATE s, s2);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         if (!s)</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :             goto nomem2;</span>
<span class="lineNum">     433 </span>            :         /* At this point we have the following:
<span class="lineNum">     434 </span>            :          *   s = 2^s2;
<span class="lineNum">     435 </span>            :          *   1 &gt; df = b/2^s2 &gt; 0;
<span class="lineNum">     436 </span>            :          *   (d - prevDouble(d))/2 = mlo/2^s2;
<span class="lineNum">     437 </span>            :          *   (nextDouble(d) - d)/2 = mhi/2^s2. */
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         done = false;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         do {</span>
<span class="lineNum">     441 </span>            :             int32_t j, j1;
<span class="lineNum">     442 </span>            :             Bigint* delta;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :             b = multadd(PASS_STATE b, base, 0);</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :             if (!b)</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                 goto nomem2;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :             digit = quorem2(b, s2);</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :             if (mlo == mhi) {</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                 mlo = mhi = multadd(PASS_STATE mlo, base, 0);</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 if (!mhi)</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                     goto nomem2;</span>
<span class="lineNum">     452 </span>            :             }
<span class="lineNum">     453 </span>            :             else {
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                 mlo = multadd(PASS_STATE mlo, base, 0);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 if (!mlo)</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                     goto nomem2;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 mhi = multadd(PASS_STATE mhi, base, 0);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 if (!mhi)</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                     goto nomem2;</span>
<span class="lineNum">     460 </span>            :             }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :             /* Do we yet have the shortest string that will round to d? */
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             j = cmp(b, mlo);</span>
<span class="lineNum">     464 </span>            :             /* j is b/2^s2 compared with mlo/2^s2. */
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             delta = diff(PASS_STATE s, mhi);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             if (!delta)</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 goto nomem2;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :             j1 = delta-&gt;sign ? 1 : cmp(b, delta);</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE delta);</span>
<span class="lineNum">     470 </span>            :             /* j1 is b/2^s2 compared with 1 - mhi/2^s2. */
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : #ifndef ROUND_BIASED
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :             if (j1 == 0 &amp;&amp; !(word1(d) &amp; 1)) {</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                 if (j &gt; 0)</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                     digit++;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                 done = true;</span>
<span class="lineNum">     477 </span>            :             } else
<span class="lineNum">     478 </span>            : #endif
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :             if (j &lt; 0 || (j == 0</span>
<span class="lineNum">     480 </span>            : #ifndef ROUND_BIASED
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                 &amp;&amp; !(word1(d) &amp; 1)</span>
<span class="lineNum">     482 </span>            : #endif
<span class="lineNum">     483 </span>            :                 )) {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                 if (j1 &gt; 0) {</span>
<span class="lineNum">     485 </span>            :                     /* Either dig or dig+1 would work here as the least significant digit.
<span class="lineNum">     486 </span>            :                        Use whichever would produce an output value closer to d. */
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                     b = lshift(PASS_STATE b, 1);</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                     if (!b)</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                         goto nomem2;</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                     j1 = cmp(b, s);</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                     if (j1 &gt; 0) /* The even test (|| (j1 == 0 &amp;&amp; (digit &amp; 1))) is not here because it messes up odd base output</span>
<span class="lineNum">     492 </span>            :                                  * such as 3.5 in base 3.  */
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                         digit++;</span>
<span class="lineNum">     494 </span>            :                 }
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                 done = true;</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             } else if (j1 &gt; 0) {</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 digit++;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :                 done = true;</span>
<span class="lineNum">     499 </span>            :             }
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(digit &lt; (uint32_t)base);</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :             *p++ = BASEDIGIT(digit);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         } while (!done);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :         Bfree(PASS_STATE b);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         Bfree(PASS_STATE s);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :         if (mlo != mhi)</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             Bfree(PASS_STATE mlo);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         Bfree(PASS_STATE mhi);</span>
<span class="lineNum">     508 </span>            :     }
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(p &lt; buffer + DTOBASESTR_BUFFER_SIZE);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :     *p = '\0';</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     return buffer;</span>
<span class="lineNum">     512 </span>            : }
<a name="513"><span class="lineNum">     513 </span>            : </a>
<span class="lineNum">     514 </span>            : DtoaState*
<span class="lineNum">     515 </span><span class="lineCov">          3 : js::NewDtoaState()</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span><span class="lineCov">          3 :     return newdtoa();</span>
<span class="lineNum">     518 </span>            : }
<a name="519"><span class="lineNum">     519 </span>            : </a>
<span class="lineNum">     520 </span>            : void
<span class="lineNum">     521 </span><span class="lineNoCov">          0 : js::DestroyDtoaState(DtoaState* state)</span>
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     destroydtoa(state);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : /* Cleanup pollution from dtoa.c */
<span class="lineNum">     527 </span>            : #undef Bias
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

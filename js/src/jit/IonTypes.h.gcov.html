<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jit/IonTypes.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/jit</a> - IonTypes.h<span style="font-size: 80%;"> (source / <a href="IonTypes.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">47</td>
            <td class="headerCovTableEntry">231</td>
            <td class="headerCovTableEntryLo">20.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntryLo">18.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef jit_IonTypes_h
<span class="lineNum">       8 </span>            : #define jit_IonTypes_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;mozilla/HashFunctions.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #include &quot;jsfriendapi.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;jstypes.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;js/GCAPI.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;js/Value.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;vm/String.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : namespace js {
<span class="lineNum">      22 </span>            : namespace jit {
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : typedef uint32_t RecoverOffset;
<span class="lineNum">      25 </span>            : typedef uint32_t SnapshotOffset;
<span class="lineNum">      26 </span>            : typedef uint32_t BailoutId;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : // The maximum size of any buffer associated with an assembler or code object.
<span class="lineNum">      29 </span>            : // This is chosen to not overflow a signed integer, leaving room for an extra
<span class="lineNum">      30 </span>            : // bit on offsets.
<span class="lineNum">      31 </span>            : static const uint32_t MAX_BUFFER_SIZE = (1 &lt;&lt; 30) - 1;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : // Maximum number of scripted arg slots.
<span class="lineNum">      34 </span>            : static const uint32_t SNAPSHOT_MAX_NARGS = 127;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : static const SnapshotOffset INVALID_RECOVER_OFFSET = uint32_t(-1);
<span class="lineNum">      37 </span>            : static const SnapshotOffset INVALID_SNAPSHOT_OFFSET = uint32_t(-1);
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : // Different kinds of bailouts. When extending this enum, make sure to check
<span class="lineNum">      40 </span>            : // the bits reserved for bailout kinds in Bailouts.h
<span class="lineNum">      41 </span>            : enum BailoutKind
<span class="lineNum">      42 </span>            : {
<span class="lineNum">      43 </span>            :     // Normal bailouts, that don't need to be handled specially when restarting
<span class="lineNum">      44 </span>            :     // in baseline.
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            :     // An inevitable bailout (MBail instruction or type barrier that always bails)
<span class="lineNum">      47 </span>            :     Bailout_Inevitable,
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :     // Bailing out during a VM call. Many possible causes that are hard
<span class="lineNum">      50 </span>            :     // to distinguish statically at snapshot construction time.
<span class="lineNum">      51 </span>            :     // We just lump them together.
<span class="lineNum">      52 </span>            :     Bailout_DuringVMCall,
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :     // Call to a non-JSFunction (problem for |apply|)
<span class="lineNum">      55 </span>            :     Bailout_NonJSFunctionCallee,
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            :     // Dynamic scope chain lookup produced |undefined|
<span class="lineNum">      58 </span>            :     Bailout_DynamicNameNotFound,
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :     // Input string contains 'arguments' or 'eval'
<span class="lineNum">      61 </span>            :     Bailout_StringArgumentsEval,
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :     // Bailout on overflow, but don't immediately invalidate.
<span class="lineNum">      64 </span>            :     // Used for abs, sub and LoadUnboxedScalar (when loading a uint32 that
<span class="lineNum">      65 </span>            :     // doesn't fit in an int32).
<span class="lineNum">      66 </span>            :     Bailout_Overflow,
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :     // floor, ceiling and round bail if input is NaN, if output would be -0 or
<span class="lineNum">      69 </span>            :     // doesn't fit in int32 range
<span class="lineNum">      70 </span>            :     Bailout_Round,
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :     // Non-primitive value used as input for ToDouble, ToInt32, ToString, etc.
<span class="lineNum">      73 </span>            :     // For ToInt32, can also mean that input can't be converted without precision
<span class="lineNum">      74 </span>            :     // loss (e.g. 5.5).
<span class="lineNum">      75 </span>            :     Bailout_NonPrimitiveInput,
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :     // For ToInt32, would lose precision when converting (e.g. 5.5).
<span class="lineNum">      78 </span>            :     Bailout_PrecisionLoss,
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :     // We tripped a type barrier (object was not in the expected TypeSet)
<span class="lineNum">      81 </span>            :     Bailout_TypeBarrierO,
<span class="lineNum">      82 </span>            :     // We tripped a type barrier (value was not in the expected TypeSet)
<span class="lineNum">      83 </span>            :     Bailout_TypeBarrierV,
<span class="lineNum">      84 </span>            :     // We tripped a type monitor (wrote an unexpected type in a property)
<span class="lineNum">      85 </span>            :     Bailout_MonitorTypes,
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            :     // We hit a hole in an array.
<span class="lineNum">      88 </span>            :     Bailout_Hole,
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :     // Array access with negative index
<span class="lineNum">      91 </span>            :     Bailout_NegativeIndex,
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     // Pretty specific case:
<span class="lineNum">      94 </span>            :     //  - need a type barrier on a property write
<span class="lineNum">      95 </span>            :     //  - all but one of the observed types have property types that reflect the value
<span class="lineNum">      96 </span>            :     //  - we need to guard that we're not given an object of that one other type
<span class="lineNum">      97 </span>            :     // also used for the unused GuardClass instruction
<span class="lineNum">      98 </span>            :     Bailout_ObjectIdentityOrTypeGuard,
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :     // Unbox expects a given type, bails out if it doesn't get it.
<span class="lineNum">     101 </span>            :     Bailout_NonInt32Input,
<span class="lineNum">     102 </span>            :     Bailout_NonNumericInput, // unboxing a double works with int32 too
<span class="lineNum">     103 </span>            :     Bailout_NonBooleanInput,
<span class="lineNum">     104 </span>            :     Bailout_NonObjectInput,
<span class="lineNum">     105 </span>            :     Bailout_NonStringInput,
<span class="lineNum">     106 </span>            :     Bailout_NonSymbolInput,
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :     // SIMD Unbox expects a given type, bails out if it doesn't match.
<span class="lineNum">     109 </span>            :     Bailout_UnexpectedSimdInput,
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     // Atomic operations require shared memory, bail out if the typed array
<span class="lineNum">     112 </span>            :     // maps unshared memory.
<span class="lineNum">     113 </span>            :     Bailout_NonSharedTypedArrayInput,
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :     // We hit a |debugger;| statement.
<span class="lineNum">     116 </span>            :     Bailout_Debugger,
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :     // |this| used uninitialized in a derived constructor
<span class="lineNum">     119 </span>            :     Bailout_UninitializedThis,
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :     // Derived constructors must return object or undefined
<span class="lineNum">     122 </span>            :     Bailout_BadDerivedConstructorReturn,
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     // We hit this code for the first time.
<span class="lineNum">     125 </span>            :     Bailout_FirstExecution,
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :     // END Normal bailouts
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :     // Bailouts caused by invalid assumptions based on Baseline code.
<span class="lineNum">     130 </span>            :     // Causes immediate invalidation.
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     // Like Bailout_Overflow, but causes immediate invalidation.
<span class="lineNum">     133 </span>            :     Bailout_OverflowInvalidate,
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :     // Like NonStringInput, but should cause immediate invalidation.
<span class="lineNum">     136 </span>            :     // Used for jsop_iternext.
<span class="lineNum">     137 </span>            :     Bailout_NonStringInputInvalidate,
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :     // Used for integer division, multiplication and modulo.
<span class="lineNum">     140 </span>            :     // If there's a remainder, bails to return a double.
<span class="lineNum">     141 </span>            :     // Can also signal overflow or result of -0.
<span class="lineNum">     142 </span>            :     // Can also signal division by 0 (returns inf, a double).
<span class="lineNum">     143 </span>            :     Bailout_DoubleOutput,
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :     // END Invalid assumptions bailouts
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :     // A bailout at the very start of a function indicates that there may be
<span class="lineNum">     149 </span>            :     // a type mismatch in the arguments that necessitates a reflow.
<span class="lineNum">     150 </span>            :     Bailout_ArgumentCheck,
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     // A bailout triggered by a bounds-check failure.
<span class="lineNum">     153 </span>            :     Bailout_BoundsCheck,
<span class="lineNum">     154 </span>            :     // A bailout triggered by a typed object whose backing buffer was detached.
<span class="lineNum">     155 </span>            :     Bailout_Detached,
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :     // A shape guard based on TI information failed.
<span class="lineNum">     158 </span>            :     // (We saw an object whose shape does not match that / any of those observed
<span class="lineNum">     159 </span>            :     // by the baseline IC.)
<span class="lineNum">     160 </span>            :     Bailout_ShapeGuard,
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :     // When we're trying to use an uninitialized lexical.
<span class="lineNum">     163 </span>            :     Bailout_UninitializedLexical,
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :     // A bailout to baseline from Ion on exception to handle Debugger hooks.
<span class="lineNum">     166 </span>            :     Bailout_IonExceptionDebugMode
<span class="lineNum">     167 </span>            : };
<a name="168"><span class="lineNum">     168 </span>            : </a>
<span class="lineNum">     169 </span>            : inline const char*
<span class="lineNum">     170 </span><span class="lineNoCov">          0 : BailoutKindString(BailoutKind kind)</span>
<span class="lineNum">     171 </span>            : {
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     switch (kind) {</span>
<span class="lineNum">     173 </span>            :       // Normal bailouts.
<span class="lineNum">     174 </span>            :       case Bailout_Inevitable:
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Inevitable&quot;;</span>
<span class="lineNum">     176 </span>            :       case Bailout_DuringVMCall:
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         return &quot;Bailout_DuringVMCall&quot;;</span>
<span class="lineNum">     178 </span>            :       case Bailout_NonJSFunctionCallee:
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonJSFunctionCallee&quot;;</span>
<span class="lineNum">     180 </span>            :       case Bailout_DynamicNameNotFound:
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         return &quot;Bailout_DynamicNameNotFound&quot;;</span>
<span class="lineNum">     182 </span>            :       case Bailout_StringArgumentsEval:
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :         return &quot;Bailout_StringArgumentsEval&quot;;</span>
<span class="lineNum">     184 </span>            :       case Bailout_Overflow:
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Overflow&quot;;</span>
<span class="lineNum">     186 </span>            :       case Bailout_Round:
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Round&quot;;</span>
<span class="lineNum">     188 </span>            :       case Bailout_NonPrimitiveInput:
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonPrimitiveInput&quot;;</span>
<span class="lineNum">     190 </span>            :       case Bailout_PrecisionLoss:
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         return &quot;Bailout_PrecisionLoss&quot;;</span>
<span class="lineNum">     192 </span>            :       case Bailout_TypeBarrierO:
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         return &quot;Bailout_TypeBarrierO&quot;;</span>
<span class="lineNum">     194 </span>            :       case Bailout_TypeBarrierV:
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         return &quot;Bailout_TypeBarrierV&quot;;</span>
<span class="lineNum">     196 </span>            :       case Bailout_MonitorTypes:
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         return &quot;Bailout_MonitorTypes&quot;;</span>
<span class="lineNum">     198 </span>            :       case Bailout_Hole:
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Hole&quot;;</span>
<span class="lineNum">     200 </span>            :       case Bailout_NegativeIndex:
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NegativeIndex&quot;;</span>
<span class="lineNum">     202 </span>            :       case Bailout_ObjectIdentityOrTypeGuard:
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         return &quot;Bailout_ObjectIdentityOrTypeGuard&quot;;</span>
<span class="lineNum">     204 </span>            :       case Bailout_NonInt32Input:
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonInt32Input&quot;;</span>
<span class="lineNum">     206 </span>            :       case Bailout_NonNumericInput:
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonNumericInput&quot;;</span>
<span class="lineNum">     208 </span>            :       case Bailout_NonBooleanInput:
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonBooleanInput&quot;;</span>
<span class="lineNum">     210 </span>            :       case Bailout_NonObjectInput:
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonObjectInput&quot;;</span>
<span class="lineNum">     212 </span>            :       case Bailout_NonStringInput:
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonStringInput&quot;;</span>
<span class="lineNum">     214 </span>            :       case Bailout_NonSymbolInput:
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonSymbolInput&quot;;</span>
<span class="lineNum">     216 </span>            :       case Bailout_UnexpectedSimdInput:
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         return &quot;Bailout_UnexpectedSimdInput&quot;;</span>
<span class="lineNum">     218 </span>            :       case Bailout_NonSharedTypedArrayInput:
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonSharedTypedArrayInput&quot;;</span>
<span class="lineNum">     220 </span>            :       case Bailout_Debugger:
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Debugger&quot;;</span>
<span class="lineNum">     222 </span>            :       case Bailout_UninitializedThis:
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         return &quot;Bailout_UninitializedThis&quot;;</span>
<span class="lineNum">     224 </span>            :       case Bailout_BadDerivedConstructorReturn:
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         return &quot;Bailout_BadDerivedConstructorReturn&quot;;</span>
<span class="lineNum">     226 </span>            :       case Bailout_FirstExecution:
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         return &quot;Bailout_FirstExecution&quot;;</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :       // Bailouts caused by invalid assumptions.
<span class="lineNum">     230 </span>            :       case Bailout_OverflowInvalidate:
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         return &quot;Bailout_OverflowInvalidate&quot;;</span>
<span class="lineNum">     232 </span>            :       case Bailout_NonStringInputInvalidate:
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         return &quot;Bailout_NonStringInputInvalidate&quot;;</span>
<span class="lineNum">     234 </span>            :       case Bailout_DoubleOutput:
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         return &quot;Bailout_DoubleOutput&quot;;</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :       // Other bailouts.
<span class="lineNum">     238 </span>            :       case Bailout_ArgumentCheck:
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         return &quot;Bailout_ArgumentCheck&quot;;</span>
<span class="lineNum">     240 </span>            :       case Bailout_BoundsCheck:
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         return &quot;Bailout_BoundsCheck&quot;;</span>
<span class="lineNum">     242 </span>            :       case Bailout_Detached:
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         return &quot;Bailout_Detached&quot;;</span>
<span class="lineNum">     244 </span>            :       case Bailout_ShapeGuard:
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :         return &quot;Bailout_ShapeGuard&quot;;</span>
<span class="lineNum">     246 </span>            :       case Bailout_UninitializedLexical:
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :         return &quot;Bailout_UninitializedLexical&quot;;</span>
<span class="lineNum">     248 </span>            :       case Bailout_IonExceptionDebugMode:
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         return &quot;Bailout_IonExceptionDebugMode&quot;;</span>
<span class="lineNum">     250 </span>            :       default:
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;Invalid BailoutKind&quot;);</span>
<span class="lineNum">     252 </span>            :     }
<span class="lineNum">     253 </span>            : }
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : static const uint32_t ELEMENT_TYPE_BITS = 5;
<span class="lineNum">     256 </span>            : static const uint32_t ELEMENT_TYPE_SHIFT = 0;
<span class="lineNum">     257 </span>            : static const uint32_t ELEMENT_TYPE_MASK = (1 &lt;&lt; ELEMENT_TYPE_BITS) - 1;
<span class="lineNum">     258 </span>            : static const uint32_t VECTOR_SCALE_BITS = 3;
<span class="lineNum">     259 </span>            : static const uint32_t VECTOR_SCALE_SHIFT = ELEMENT_TYPE_BITS + ELEMENT_TYPE_SHIFT;
<span class="lineNum">     260 </span>            : static const uint32_t VECTOR_SCALE_MASK = (1 &lt;&lt; VECTOR_SCALE_BITS) - 1;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : class SimdConstant {
<span class="lineNum">     263 </span>            :   public:
<span class="lineNum">     264 </span>            :     enum Type {
<span class="lineNum">     265 </span>            :         Int8x16,
<span class="lineNum">     266 </span>            :         Int16x8,
<span class="lineNum">     267 </span>            :         Int32x4,
<span class="lineNum">     268 </span>            :         Float32x4,
<span class="lineNum">     269 </span>            :         Undefined = -1
<span class="lineNum">     270 </span>            :     };
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     typedef int8_t I8x16[16];
<span class="lineNum">     273 </span>            :     typedef int16_t I16x8[8];
<span class="lineNum">     274 </span>            :     typedef int32_t I32x4[4];
<span class="lineNum">     275 </span>            :     typedef float F32x4[4];
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   private:
<span class="lineNum">     278 </span>            :     Type type_;
<span class="lineNum">     279 </span>            :     union {
<span class="lineNum">     280 </span>            :         I8x16 i8x16;
<span class="lineNum">     281 </span>            :         I16x8 i16x8;
<span class="lineNum">     282 </span>            :         I32x4 i32x4;
<span class="lineNum">     283 </span>            :         F32x4 f32x4;
<a name="284"><span class="lineNum">     284 </span>            :     } u;</a>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     bool defined() const {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         return type_ != Undefined;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   public:
<span class="lineNum">     291 </span>            :     // Doesn't have a default constructor, as it would prevent it from being
<a name="292"><span class="lineNum">     292 </span>            :     // included in unions.</a>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     static SimdConstant CreateX16(const int8_t* array) {</span>
<span class="lineNum">     295 </span>            :         SimdConstant cst;
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         cst.type_ = Int8x16;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         memcpy(cst.u.i8x16, array, sizeof(cst.u));</span>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     static SimdConstant SplatX16(int8_t v) {</span>
<span class="lineNum">     301 </span>            :         SimdConstant cst;
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         cst.type_ = Int8x16;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         std::fill_n(cst.u.i8x16, 16, v);</span>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     305 </span>            :     }
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     static SimdConstant CreateX8(const int16_t* array) {</span>
<span class="lineNum">     307 </span>            :         SimdConstant cst;
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         cst.type_ = Int16x8;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         memcpy(cst.u.i16x8, array, sizeof(cst.u));</span>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     311 </span>            :     }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     static SimdConstant SplatX8(int16_t v) {</span>
<span class="lineNum">     313 </span>            :         SimdConstant cst;
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :         cst.type_ = Int16x8;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :         std::fill_n(cst.u.i16x8, 8, v);</span>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     317 </span>            :     }
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     static SimdConstant CreateX4(const int32_t* array) {</span>
<span class="lineNum">     319 </span>            :         SimdConstant cst;
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         cst.type_ = Int32x4;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         memcpy(cst.u.i32x4, array, sizeof(cst.u));</span>
<a name="322"><span class="lineNum">     322 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     323 </span>            :     }
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :     static SimdConstant SplatX4(int32_t v) {</span>
<span class="lineNum">     325 </span>            :         SimdConstant cst;
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         cst.type_ = Int32x4;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         std::fill_n(cst.u.i32x4, 4, v);</span>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     329 </span>            :     }
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     static SimdConstant CreateX4(const float* array) {</span>
<span class="lineNum">     331 </span>            :         SimdConstant cst;
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         cst.type_ = Float32x4;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :         memcpy(cst.u.f32x4, array, sizeof(cst.u));</span>
<a name="334"><span class="lineNum">     334 </span><span class="lineNoCov">          0 :         return cst;</span></a>
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     static SimdConstant SplatX4(float v) {</span>
<span class="lineNum">     337 </span>            :         SimdConstant cst;
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         cst.type_ = Float32x4;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         std::fill_n(cst.u.f32x4, 4, v);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :         return cst;</span>
<span class="lineNum">     341 </span>            :     }
<a name="342"><span class="lineNum">     342 </span>            : </a>
<a name="343"><span class="lineNum">     343 </span>            :     // Overloads for use by templates.</a>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 :     static SimdConstant CreateSimd128(const int8_t* array) { return CreateX16(array); }</span></a>
<a name="345"><span class="lineNum">     345 </span><span class="lineNoCov">          0 :     static SimdConstant CreateSimd128(const int16_t* array) { return CreateX8(array); }</span></a>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     static SimdConstant CreateSimd128(const int32_t* array) { return CreateX4(array); }</span>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 :     static SimdConstant CreateSimd128(const float* array) { return CreateX4(array); }</span></a>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     Type type() const {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined());</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         return type_;</span>
<span class="lineNum">     352 </span>            :     }
<a name="353"><span class="lineNum">     353 </span>            : </a>
<span class="lineNum">     354 </span>            :     // Get the raw bytes of the constant.
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     const void* bytes() const {</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         return u.i8x16;</span>
<a name="357"><span class="lineNum">     357 </span>            :     }</a>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     const I8x16&amp; asInt8x16() const {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined() &amp;&amp; type_ == Int8x16);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         return u.i8x16;</span>
<a name="362"><span class="lineNum">     362 </span>            :     }</a>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     const I16x8&amp; asInt16x8() const {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined() &amp;&amp; type_ == Int16x8);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         return u.i16x8;</span>
<a name="367"><span class="lineNum">     367 </span>            :     }</a>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     const I32x4&amp; asInt32x4() const {</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined() &amp;&amp; type_ == Int32x4);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         return u.i32x4;</span>
<a name="372"><span class="lineNum">     372 </span>            :     }</a>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :     const F32x4&amp; asFloat32x4() const {</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined() &amp;&amp; type_ == Float32x4);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         return u.f32x4;</span>
<a name="377"><span class="lineNum">     377 </span>            :     }</a>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     bool operator==(const SimdConstant&amp; rhs) const {</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(defined() &amp;&amp; rhs.defined());</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         if (type() != rhs.type())</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     383 </span>            :         // Takes negative zero into accuont, as it's a bit comparison.
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :         return memcmp(&amp;u, &amp;rhs.u, sizeof(u)) == 0;</span>
<span class="lineNum">     385 </span>            :     }
<span class="lineNum">     386 </span>            :     bool operator!=(const SimdConstant&amp; rhs) const {
<span class="lineNum">     387 </span>            :         return !operator==(rhs);
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            : 
<a name="390"><span class="lineNum">     390 </span>            :     // SimdConstant is a HashPolicy</a>
<span class="lineNum">     391 </span>            :     typedef SimdConstant Lookup;
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     static HashNumber hash(const SimdConstant&amp; val) {</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :         uint32_t hash = mozilla::HashBytes(&amp;val.u, sizeof(val.u));</span>
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 :         return mozilla::AddToHash(hash, val.type_);</span></a>
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     static bool match(const SimdConstant&amp; lhs, const SimdConstant&amp; rhs) {</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         return lhs == rhs;</span>
<span class="lineNum">     398 </span>            :     }
<span class="lineNum">     399 </span>            : };
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            : // The ordering of this enumeration is important: Anything &lt; Value is a
<span class="lineNum">     402 </span>            : // specialized type. Furthermore, anything &lt; String has trivial conversion to
<span class="lineNum">     403 </span>            : // a number.
<span class="lineNum">     404 </span>            : enum class MIRType
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span>            :     Undefined,
<span class="lineNum">     407 </span>            :     Null,
<span class="lineNum">     408 </span>            :     Boolean,
<span class="lineNum">     409 </span>            :     Int32,
<span class="lineNum">     410 </span>            :     Int64,
<span class="lineNum">     411 </span>            :     Double,
<span class="lineNum">     412 </span>            :     Float32,
<span class="lineNum">     413 </span>            :     // Types above have trivial conversion to a number.
<span class="lineNum">     414 </span>            :     String,
<span class="lineNum">     415 </span>            :     Symbol,
<span class="lineNum">     416 </span>            :     // Types above are primitive (including undefined and null).
<span class="lineNum">     417 </span>            :     Object,
<span class="lineNum">     418 </span>            :     MagicOptimizedArguments,   // JS_OPTIMIZED_ARGUMENTS magic value.
<span class="lineNum">     419 </span>            :     MagicOptimizedOut,         // JS_OPTIMIZED_OUT magic value.
<span class="lineNum">     420 </span>            :     MagicHole,                 // JS_ELEMENTS_HOLE magic value.
<span class="lineNum">     421 </span>            :     MagicIsConstructing,       // JS_IS_CONSTRUCTING magic value.
<span class="lineNum">     422 </span>            :     MagicUninitializedLexical, // JS_UNINITIALIZED_LEXICAL magic value.
<span class="lineNum">     423 </span>            :     // Types above are specialized.
<span class="lineNum">     424 </span>            :     Value,
<span class="lineNum">     425 </span>            :     SinCosDouble,              // Optimizing a sin/cos to sincos.
<span class="lineNum">     426 </span>            :     ObjectOrNull,
<span class="lineNum">     427 </span>            :     None,                      // Invalid, used as a placeholder.
<span class="lineNum">     428 </span>            :     Slots,                     // A slots vector
<span class="lineNum">     429 </span>            :     Elements,                  // An elements vector
<span class="lineNum">     430 </span>            :     Pointer,                   // An opaque pointer that receives no special treatment
<span class="lineNum">     431 </span>            :     Shape,                     // A Shape pointer.
<span class="lineNum">     432 </span>            :     ObjectGroup,               // An ObjectGroup pointer.
<span class="lineNum">     433 </span>            :     Last = ObjectGroup,
<span class="lineNum">     434 </span>            :     // Representing both SIMD.IntBxN and SIMD.UintBxN.
<span class="lineNum">     435 </span>            :     Int8x16   = Int32   | (4 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     436 </span>            :     Int16x8   = Int32   | (3 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     437 </span>            :     Int32x4   = Int32   | (2 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     438 </span>            :     Float32x4 = Float32 | (2 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     439 </span>            :     Bool8x16  = Boolean | (4 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     440 </span>            :     Bool16x8  = Boolean | (3 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     441 </span>            :     Bool32x4  = Boolean | (2 &lt;&lt; VECTOR_SCALE_SHIFT),
<span class="lineNum">     442 </span>            :     Doublex2  = Double  | (1 &lt;&lt; VECTOR_SCALE_SHIFT)
<span class="lineNum">     443 </span>            : };
<a name="444"><span class="lineNum">     444 </span>            : </a>
<span class="lineNum">     445 </span>            : static inline bool
<span class="lineNum">     446 </span><span class="lineNoCov">          0 : IsSimdType(MIRType type)</span>
<span class="lineNum">     447 </span>            : {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     return ((unsigned(type) &gt;&gt; VECTOR_SCALE_SHIFT) &amp; VECTOR_SCALE_MASK) != 0;</span>
<span class="lineNum">     449 </span>            : }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : // Returns the number of vector elements (hereby called &quot;length&quot;) for a given
<a name="452"><span class="lineNum">     452 </span>            : // SIMD kind. It is the Y part of the name &quot;Foo x Y&quot;.</a>
<span class="lineNum">     453 </span>            : static inline unsigned
<span class="lineNum">     454 </span><span class="lineNoCov">          0 : SimdTypeToLength(MIRType type)</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(IsSimdType(type));</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     return 1 &lt;&lt; ((unsigned(type) &gt;&gt; VECTOR_SCALE_SHIFT) &amp; VECTOR_SCALE_MASK);</span>
<span class="lineNum">     458 </span>            : }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : // Get the type of the individual lanes in a SIMD type.
<a name="461"><span class="lineNum">     461 </span>            : // For example, Int32x4 -&gt; Int32, Float32x4 -&gt; Float32 etc.</a>
<span class="lineNum">     462 </span>            : static inline MIRType
<span class="lineNum">     463 </span><span class="lineNoCov">          0 : SimdTypeToLaneType(MIRType type)</span>
<span class="lineNum">     464 </span>            : {
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(IsSimdType(type));</span>
<span class="lineNum">     466 </span>            :     static_assert(unsigned(MIRType::Last) &lt;= ELEMENT_TYPE_MASK,
<span class="lineNum">     467 </span>            :                   &quot;ELEMENT_TYPE_MASK should be larger than the last MIRType&quot;);
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     return MIRType((unsigned(type) &gt;&gt; ELEMENT_TYPE_SHIFT) &amp; ELEMENT_TYPE_MASK);</span>
<span class="lineNum">     469 </span>            : }
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            : // Get the type expected when inserting a lane into a SIMD type.
<span class="lineNum">     472 </span>            : // This is the argument type expected by the MSimdValue constructors as well as
<a name="473"><span class="lineNum">     473 </span>            : // MSimdSplat and MSimdInsertElement.</a>
<span class="lineNum">     474 </span>            : static inline MIRType
<span class="lineNum">     475 </span><span class="lineNoCov">          0 : SimdTypeToLaneArgumentType(MIRType type)</span>
<span class="lineNum">     476 </span>            : {
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     MIRType laneType = SimdTypeToLaneType(type);</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :     // Boolean lanes should be pre-converted to an Int32 with the values 0 or -1.
<span class="lineNum">     480 </span>            :     // All other lane types are inserted directly.
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     return laneType == MIRType::Boolean ? MIRType::Int32 : laneType;</span>
<span class="lineNum">     482 </span>            : }
<a name="483"><span class="lineNum">     483 </span>            : </a>
<span class="lineNum">     484 </span>            : static inline MIRType
<span class="lineNum">     485 </span><span class="lineCov">       5007 : MIRTypeFromValueType(JSValueType type)</span>
<span class="lineNum">     486 </span>            : {
<span class="lineNum">     487 </span>            :     // This function does not deal with magic types. Magic constants should be
<span class="lineNum">     488 </span>            :     // filtered out in MIRTypeFromValue.
<span class="lineNum">     489 </span><span class="lineCov">       5007 :     switch (type) {</span>
<span class="lineNum">     490 </span>            :       case JSVAL_TYPE_DOUBLE:
<span class="lineNum">     491 </span><span class="lineCov">          1 :         return MIRType::Double;</span>
<span class="lineNum">     492 </span>            :       case JSVAL_TYPE_INT32:
<span class="lineNum">     493 </span><span class="lineCov">       2213 :         return MIRType::Int32;</span>
<span class="lineNum">     494 </span>            :       case JSVAL_TYPE_UNDEFINED:
<span class="lineNum">     495 </span><span class="lineCov">       1722 :         return MIRType::Undefined;</span>
<span class="lineNum">     496 </span>            :       case JSVAL_TYPE_STRING:
<span class="lineNum">     497 </span><span class="lineCov">        180 :         return MIRType::String;</span>
<span class="lineNum">     498 </span>            :       case JSVAL_TYPE_SYMBOL:
<span class="lineNum">     499 </span><span class="lineCov">          5 :         return MIRType::Symbol;</span>
<span class="lineNum">     500 </span>            :       case JSVAL_TYPE_BOOLEAN:
<span class="lineNum">     501 </span><span class="lineCov">        258 :         return MIRType::Boolean;</span>
<span class="lineNum">     502 </span>            :       case JSVAL_TYPE_NULL:
<span class="lineNum">     503 </span><span class="lineCov">         47 :         return MIRType::Null;</span>
<span class="lineNum">     504 </span>            :       case JSVAL_TYPE_OBJECT:
<span class="lineNum">     505 </span><span class="lineCov">        581 :         return MIRType::Object;</span>
<span class="lineNum">     506 </span>            :       case JSVAL_TYPE_UNKNOWN:
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         return MIRType::Value;</span>
<span class="lineNum">     508 </span>            :       default:
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         MOZ_CRASH(&quot;unexpected jsval type&quot;);</span>
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span>            : }
<a name="512"><span class="lineNum">     512 </span>            : </a>
<span class="lineNum">     513 </span>            : static inline JSValueType
<span class="lineNum">     514 </span><span class="lineCov">       5095 : ValueTypeFromMIRType(MIRType type)</span>
<span class="lineNum">     515 </span>            : {
<span class="lineNum">     516 </span><span class="lineCov">       5095 :   switch (type) {</span>
<span class="lineNum">     517 </span>            :     case MIRType::Undefined:
<span class="lineNum">     518 </span><span class="lineCov">        287 :       return JSVAL_TYPE_UNDEFINED;</span>
<span class="lineNum">     519 </span>            :     case MIRType::Null:
<span class="lineNum">     520 </span><span class="lineCov">          3 :       return JSVAL_TYPE_NULL;</span>
<span class="lineNum">     521 </span>            :     case MIRType::Boolean:
<span class="lineNum">     522 </span><span class="lineCov">       2125 :       return JSVAL_TYPE_BOOLEAN;</span>
<span class="lineNum">     523 </span>            :     case MIRType::Int32:
<span class="lineNum">     524 </span><span class="lineCov">        479 :       return JSVAL_TYPE_INT32;</span>
<span class="lineNum">     525 </span>            :     case MIRType::Float32: // Fall through, there's no JSVAL for Float32
<span class="lineNum">     526 </span>            :     case MIRType::Double:
<span class="lineNum">     527 </span><span class="lineCov">          1 :       return JSVAL_TYPE_DOUBLE;</span>
<span class="lineNum">     528 </span>            :     case MIRType::String:
<span class="lineNum">     529 </span><span class="lineCov">        340 :       return JSVAL_TYPE_STRING;</span>
<span class="lineNum">     530 </span>            :     case MIRType::Symbol:
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       return JSVAL_TYPE_SYMBOL;</span>
<span class="lineNum">     532 </span>            :     case MIRType::MagicOptimizedArguments:
<span class="lineNum">     533 </span>            :     case MIRType::MagicOptimizedOut:
<span class="lineNum">     534 </span>            :     case MIRType::MagicHole:
<span class="lineNum">     535 </span>            :     case MIRType::MagicIsConstructing:
<span class="lineNum">     536 </span>            :     case MIRType::MagicUninitializedLexical:
<span class="lineNum">     537 </span><span class="lineCov">          2 :       return JSVAL_TYPE_MAGIC;</span>
<span class="lineNum">     538 </span>            :     default:
<span class="lineNum">     539 </span><span class="lineCov">       1858 :       MOZ_ASSERT(type == MIRType::Object);</span>
<span class="lineNum">     540 </span><span class="lineCov">       1858 :       return JSVAL_TYPE_OBJECT;</span>
<span class="lineNum">     541 </span>            :   }
<span class="lineNum">     542 </span>            : }
<a name="543"><span class="lineNum">     543 </span>            : </a>
<span class="lineNum">     544 </span>            : static inline JSValueTag
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : MIRTypeToTag(MIRType type)</span>
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     return JSVAL_TYPE_TO_TAG(ValueTypeFromMIRType(type));</span>
<span class="lineNum">     548 </span>            : }
<a name="549"><span class="lineNum">     549 </span>            : </a>
<span class="lineNum">     550 </span>            : static inline const char*
<span class="lineNum">     551 </span><span class="lineCov">        143 : StringFromMIRType(MIRType type)</span>
<span class="lineNum">     552 </span>            : {
<span class="lineNum">     553 </span><span class="lineCov">        143 :   switch (type) {</span>
<span class="lineNum">     554 </span>            :     case MIRType::Undefined:
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       return &quot;Undefined&quot;;</span>
<span class="lineNum">     556 </span>            :     case MIRType::Null:
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       return &quot;Null&quot;;</span>
<span class="lineNum">     558 </span>            :     case MIRType::Boolean:
<span class="lineNum">     559 </span><span class="lineCov">         40 :       return &quot;Bool&quot;;</span>
<span class="lineNum">     560 </span>            :     case MIRType::Int32:
<span class="lineNum">     561 </span><span class="lineCov">         16 :       return &quot;Int32&quot;;</span>
<span class="lineNum">     562 </span>            :     case MIRType::Int64:
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       return &quot;Int64&quot;;</span>
<span class="lineNum">     564 </span>            :     case MIRType::Double:
<span class="lineNum">     565 </span><span class="lineCov">          1 :       return &quot;Double&quot;;</span>
<span class="lineNum">     566 </span>            :     case MIRType::Float32:
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :       return &quot;Float32&quot;;</span>
<span class="lineNum">     568 </span>            :     case MIRType::String:
<span class="lineNum">     569 </span><span class="lineCov">         32 :       return &quot;String&quot;;</span>
<span class="lineNum">     570 </span>            :     case MIRType::Symbol:
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :       return &quot;Symbol&quot;;</span>
<span class="lineNum">     572 </span>            :     case MIRType::Object:
<span class="lineNum">     573 </span><span class="lineCov">         54 :       return &quot;Object&quot;;</span>
<span class="lineNum">     574 </span>            :     case MIRType::MagicOptimizedArguments:
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :       return &quot;MagicOptimizedArguments&quot;;</span>
<span class="lineNum">     576 </span>            :     case MIRType::MagicOptimizedOut:
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       return &quot;MagicOptimizedOut&quot;;</span>
<span class="lineNum">     578 </span>            :     case MIRType::MagicHole:
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :       return &quot;MagicHole&quot;;</span>
<span class="lineNum">     580 </span>            :     case MIRType::MagicIsConstructing:
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       return &quot;MagicIsConstructing&quot;;</span>
<span class="lineNum">     582 </span>            :     case MIRType::MagicUninitializedLexical:
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       return &quot;MagicUninitializedLexical&quot;;</span>
<span class="lineNum">     584 </span>            :     case MIRType::Value:
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       return &quot;Value&quot;;</span>
<span class="lineNum">     586 </span>            :     case MIRType::SinCosDouble:
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       return &quot;SinCosDouble&quot;;</span>
<span class="lineNum">     588 </span>            :     case MIRType::ObjectOrNull:
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       return &quot;ObjectOrNull&quot;;</span>
<span class="lineNum">     590 </span>            :     case MIRType::None:
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       return &quot;None&quot;;</span>
<span class="lineNum">     592 </span>            :     case MIRType::Slots:
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :       return &quot;Slots&quot;;</span>
<span class="lineNum">     594 </span>            :     case MIRType::Elements:
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :       return &quot;Elements&quot;;</span>
<span class="lineNum">     596 </span>            :     case MIRType::Pointer:
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       return &quot;Pointer&quot;;</span>
<span class="lineNum">     598 </span>            :     case MIRType::Shape:
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       return &quot;Shape&quot;;</span>
<span class="lineNum">     600 </span>            :     case MIRType::ObjectGroup:
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       return &quot;ObjectGroup&quot;;</span>
<span class="lineNum">     602 </span>            :     case MIRType::Int32x4:
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       return &quot;Int32x4&quot;;</span>
<span class="lineNum">     604 </span>            :     case MIRType::Int16x8:
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       return &quot;Int16x8&quot;;</span>
<span class="lineNum">     606 </span>            :     case MIRType::Int8x16:
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       return &quot;Int8x16&quot;;</span>
<span class="lineNum">     608 </span>            :     case MIRType::Float32x4:
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       return &quot;Float32x4&quot;;</span>
<span class="lineNum">     610 </span>            :     case MIRType::Bool32x4:
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :       return &quot;Bool32x4&quot;;</span>
<span class="lineNum">     612 </span>            :     case MIRType::Bool16x8:
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :       return &quot;Bool16x8&quot;;</span>
<span class="lineNum">     614 </span>            :     case MIRType::Bool8x16:
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       return &quot;Bool8x16&quot;;</span>
<span class="lineNum">     616 </span>            :     case MIRType::Doublex2:
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :       return &quot;Doublex2&quot;;</span>
<span class="lineNum">     618 </span>            :   }
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :   MOZ_CRASH(&quot;Unknown MIRType.&quot;);</span>
<span class="lineNum">     620 </span>            : }
<a name="621"><span class="lineNum">     621 </span>            : </a>
<span class="lineNum">     622 </span>            : static inline bool
<span class="lineNum">     623 </span><span class="lineNoCov">          0 : IsIntType(MIRType type)</span>
<span class="lineNum">     624 </span>            : {
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     return type == MIRType::Int32 ||</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :            type == MIRType::Int64;</span>
<span class="lineNum">     627 </span>            : }
<a name="628"><span class="lineNum">     628 </span>            : </a>
<span class="lineNum">     629 </span>            : static inline bool
<span class="lineNum">     630 </span><span class="lineCov">        480 : IsNumberType(MIRType type)</span>
<span class="lineNum">     631 </span>            : {
<span class="lineNum">     632 </span><span class="lineCov">        107 :     return type == MIRType::Int32 ||</span>
<span class="lineNum">     633 </span><span class="lineCov">         68 :            type == MIRType::Double ||</span>
<span class="lineNum">     634 </span><span class="lineCov">        548 :            type == MIRType::Float32 ||</span>
<span class="lineNum">     635 </span><span class="lineCov">        480 :            type == MIRType::Int64;</span>
<span class="lineNum">     636 </span>            : }
<a name="637"><span class="lineNum">     637 </span>            : </a>
<span class="lineNum">     638 </span>            : static inline bool
<span class="lineNum">     639 </span><span class="lineCov">       1873 : IsTypeRepresentableAsDouble(MIRType type)</span>
<span class="lineNum">     640 </span>            : {
<span class="lineNum">     641 </span><span class="lineCov">       1105 :     return type == MIRType::Int32 ||</span>
<span class="lineNum">     642 </span><span class="lineCov">       2871 :            type == MIRType::Double ||</span>
<span class="lineNum">     643 </span><span class="lineCov">       1873 :            type == MIRType::Float32;</span>
<span class="lineNum">     644 </span>            : }
<a name="645"><span class="lineNum">     645 </span>            : </a>
<span class="lineNum">     646 </span>            : static inline bool
<span class="lineNum">     647 </span><span class="lineNoCov">          0 : IsFloatType(MIRType type)</span>
<span class="lineNum">     648 </span>            : {
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     return type == MIRType::Int32 || type == MIRType::Float32;</span>
<span class="lineNum">     650 </span>            : }
<a name="651"><span class="lineNum">     651 </span>            : </a>
<span class="lineNum">     652 </span>            : static inline bool
<span class="lineNum">     653 </span><span class="lineCov">       1104 : IsFloatingPointType(MIRType type)</span>
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span><span class="lineCov">       1104 :     return type == MIRType::Double || type == MIRType::Float32;</span>
<span class="lineNum">     656 </span>            : }
<a name="657"><span class="lineNum">     657 </span>            : </a>
<span class="lineNum">     658 </span>            : static inline bool
<span class="lineNum">     659 </span><span class="lineCov">       3531 : IsNullOrUndefined(MIRType type)</span>
<span class="lineNum">     660 </span>            : {
<span class="lineNum">     661 </span><span class="lineCov">       3531 :     return type == MIRType::Null || type == MIRType::Undefined;</span>
<span class="lineNum">     662 </span>            : }
<a name="663"><span class="lineNum">     663 </span>            : </a>
<span class="lineNum">     664 </span>            : static inline bool
<span class="lineNum">     665 </span><span class="lineNoCov">          0 : IsFloatingPointSimdType(MIRType type)</span>
<span class="lineNum">     666 </span>            : {
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     return type == MIRType::Float32x4;</span>
<span class="lineNum">     668 </span>            : }
<a name="669"><span class="lineNum">     669 </span>            : </a>
<span class="lineNum">     670 </span>            : static inline bool
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : IsIntegerSimdType(MIRType type)</span>
<span class="lineNum">     672 </span>            : {
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     return IsSimdType(type) &amp;&amp; SimdTypeToLaneType(type) == MIRType::Int32;</span>
<span class="lineNum">     674 </span>            : }
<a name="675"><span class="lineNum">     675 </span>            : </a>
<span class="lineNum">     676 </span>            : static inline bool
<span class="lineNum">     677 </span><span class="lineNoCov">          0 : IsBooleanSimdType(MIRType type)</span>
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     return IsSimdType(type) &amp;&amp; SimdTypeToLaneType(type) == MIRType::Boolean;</span>
<span class="lineNum">     680 </span>            : }
<a name="681"><span class="lineNum">     681 </span>            : </a>
<span class="lineNum">     682 </span>            : static inline bool
<span class="lineNum">     683 </span><span class="lineCov">       1799 : IsMagicType(MIRType type)</span>
<span class="lineNum">     684 </span>            : {
<span class="lineNum">     685 </span><span class="lineCov">       1799 :     return type == MIRType::MagicHole ||</span>
<span class="lineNum">     686 </span><span class="lineCov">        117 :            type == MIRType::MagicOptimizedOut ||</span>
<span class="lineNum">     687 </span><span class="lineCov">        103 :            type == MIRType::MagicIsConstructing ||</span>
<span class="lineNum">     688 </span><span class="lineCov">       1899 :            type == MIRType::MagicOptimizedArguments ||</span>
<span class="lineNum">     689 </span><span class="lineCov">       1799 :            type == MIRType::MagicUninitializedLexical;</span>
<span class="lineNum">     690 </span>            : }
<a name="691"><span class="lineNum">     691 </span>            : </a>
<span class="lineNum">     692 </span>            : static inline MIRType
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : ScalarTypeToMIRType(Scalar::Type type)</span>
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     switch (type) {</span>
<span class="lineNum">     696 </span>            :       case Scalar::Int8:
<span class="lineNum">     697 </span>            :       case Scalar::Uint8:
<span class="lineNum">     698 </span>            :       case Scalar::Int16:
<span class="lineNum">     699 </span>            :       case Scalar::Uint16:
<span class="lineNum">     700 </span>            :       case Scalar::Int32:
<span class="lineNum">     701 </span>            :       case Scalar::Uint32:
<span class="lineNum">     702 </span>            :       case Scalar::Uint8Clamped:
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         return MIRType::Int32;</span>
<span class="lineNum">     704 </span>            :       case Scalar::Int64:
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         return MIRType::Int64;</span>
<span class="lineNum">     706 </span>            :       case Scalar::Float32:
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         return MIRType::Float32;</span>
<span class="lineNum">     708 </span>            :       case Scalar::Float64:
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         return MIRType::Double;</span>
<span class="lineNum">     710 </span>            :       case Scalar::Float32x4:
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         return MIRType::Float32x4;</span>
<span class="lineNum">     712 </span>            :       case Scalar::Int8x16:
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         return MIRType::Int8x16;</span>
<span class="lineNum">     714 </span>            :       case Scalar::Int16x8:
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         return MIRType::Int16x8;</span>
<span class="lineNum">     716 </span>            :       case Scalar::Int32x4:
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :         return MIRType::Int32x4;</span>
<span class="lineNum">     718 </span>            :       case Scalar::MaxTypedArrayViewType:
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;unexpected SIMD kind&quot;);</span>
<span class="lineNum">     722 </span>            : }
<a name="723"><span class="lineNum">     723 </span>            : </a>
<span class="lineNum">     724 </span>            : static inline unsigned
<span class="lineNum">     725 </span><span class="lineNoCov">          0 : ScalarTypeToLength(Scalar::Type type)</span>
<span class="lineNum">     726 </span>            : {
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :     switch (type) {</span>
<span class="lineNum">     728 </span>            :       case Scalar::Int8:
<span class="lineNum">     729 </span>            :       case Scalar::Uint8:
<span class="lineNum">     730 </span>            :       case Scalar::Int16:
<span class="lineNum">     731 </span>            :       case Scalar::Uint16:
<span class="lineNum">     732 </span>            :       case Scalar::Int32:
<span class="lineNum">     733 </span>            :       case Scalar::Uint32:
<span class="lineNum">     734 </span>            :       case Scalar::Int64:
<span class="lineNum">     735 </span>            :       case Scalar::Float32:
<span class="lineNum">     736 </span>            :       case Scalar::Float64:
<span class="lineNum">     737 </span>            :       case Scalar::Uint8Clamped:
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     739 </span>            :       case Scalar::Float32x4:
<span class="lineNum">     740 </span>            :       case Scalar::Int32x4:
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :         return 4;</span>
<span class="lineNum">     742 </span>            :       case Scalar::Int16x8:
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         return 8;</span>
<span class="lineNum">     744 </span>            :       case Scalar::Int8x16:
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         return 16;</span>
<span class="lineNum">     746 </span>            :       case Scalar::MaxTypedArrayViewType:
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     748 </span>            :     }
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;unexpected SIMD kind&quot;);</span>
<span class="lineNum">     750 </span>            : }
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span>            : static inline const char*
<span class="lineNum">     753 </span><span class="lineNoCov">          0 : PropertyNameToExtraName(PropertyName* name)</span>
<span class="lineNum">     754 </span>            : {
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     if (!name-&gt;hasLatin1Chars())</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;const char *&gt;(name-&gt;latin1Chars(nogc));</span>
<span class="lineNum">     759 </span>            : }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            : #ifdef DEBUG
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            : // Track the pipeline of opcodes which has produced a snapshot.
<span class="lineNum">     764 </span>            : #define TRACK_SNAPSHOTS 1
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : // Make sure registers are not modified between an instruction and
<span class="lineNum">     767 </span>            : // its OsiPoint.
<span class="lineNum">     768 </span>            : #define CHECK_OSIPOINT_REGISTERS 1
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : #endif // DEBUG
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : enum ABIArgType {
<span class="lineNum">     773 </span>            :     ArgType_General = 0x1,
<span class="lineNum">     774 </span>            :     ArgType_Double  = 0x2,
<span class="lineNum">     775 </span>            :     ArgType_Float32 = 0x3,
<span class="lineNum">     776 </span>            :     ArgType_Int64   = 0x4,
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :     RetType_Shift   = 0x0,
<span class="lineNum">     779 </span>            :     ArgType_Shift   = 0x3,
<span class="lineNum">     780 </span>            :     ArgType_Mask    = 0x7
<span class="lineNum">     781 </span>            : };
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : enum ABIFunctionType
<span class="lineNum">     784 </span>            : {
<span class="lineNum">     785 </span>            :     // VM functions that take 0-9 non-double arguments
<span class="lineNum">     786 </span>            :     // and return a non-double value.
<span class="lineNum">     787 </span>            :     Args_General0 = ArgType_General &lt;&lt; RetType_Shift,
<span class="lineNum">     788 </span>            :     Args_General1 = Args_General0 | (ArgType_General &lt;&lt; (ArgType_Shift * 1)),
<span class="lineNum">     789 </span>            :     Args_General2 = Args_General1 | (ArgType_General &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     790 </span>            :     Args_General3 = Args_General2 | (ArgType_General &lt;&lt; (ArgType_Shift * 3)),
<span class="lineNum">     791 </span>            :     Args_General4 = Args_General3 | (ArgType_General &lt;&lt; (ArgType_Shift * 4)),
<span class="lineNum">     792 </span>            :     Args_General5 = Args_General4 | (ArgType_General &lt;&lt; (ArgType_Shift * 5)),
<span class="lineNum">     793 </span>            :     Args_General6 = Args_General5 | (ArgType_General &lt;&lt; (ArgType_Shift * 6)),
<span class="lineNum">     794 </span>            :     Args_General7 = Args_General6 | (ArgType_General &lt;&lt; (ArgType_Shift * 7)),
<span class="lineNum">     795 </span>            :     Args_General8 = Args_General7 | (ArgType_General &lt;&lt; (ArgType_Shift * 8)),
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     // int64 f(double)
<span class="lineNum">     798 </span>            :     Args_Int64_Double = (ArgType_Int64 &lt;&lt; RetType_Shift) | (ArgType_Double &lt;&lt; ArgType_Shift),
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :     // double f()
<span class="lineNum">     801 </span>            :     Args_Double_None = ArgType_Double &lt;&lt; RetType_Shift,
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :     // int f(double)
<span class="lineNum">     804 </span>            :     Args_Int_Double = Args_General0 | (ArgType_Double &lt;&lt; ArgType_Shift),
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :     // float f(float)
<span class="lineNum">     807 </span>            :     Args_Float32_Float32 = (ArgType_Float32 &lt;&lt; RetType_Shift) | (ArgType_Float32 &lt;&lt; ArgType_Shift),
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     // float f(int, int)
<span class="lineNum">     810 </span>            :     Args_Float32_IntInt = (ArgType_Float32 &lt;&lt; RetType_Shift) |
<span class="lineNum">     811 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     812 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :     // double f(double)
<span class="lineNum">     815 </span>            :     Args_Double_Double = Args_Double_None | (ArgType_Double &lt;&lt; ArgType_Shift),
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :     // double f(int)
<span class="lineNum">     818 </span>            :     Args_Double_Int = Args_Double_None | (ArgType_General &lt;&lt; ArgType_Shift),
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     // double f(int, int)
<span class="lineNum">     821 </span>            :     Args_Double_IntInt = Args_Double_Int | (ArgType_General &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :     // double f(double, int)
<span class="lineNum">     824 </span>            :     Args_Double_DoubleInt = Args_Double_None |
<span class="lineNum">     825 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     826 </span>            :         (ArgType_Double &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     // double f(double, double)
<span class="lineNum">     829 </span>            :     Args_Double_DoubleDouble = Args_Double_Double | (ArgType_Double &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :     // float f(float, float)
<span class="lineNum">     832 </span>            :     Args_Float32_Float32Float32 = Args_Float32_Float32 | (ArgType_Float32 &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :     // double f(int, double)
<span class="lineNum">     835 </span>            :     Args_Double_IntDouble = Args_Double_None |
<span class="lineNum">     836 </span>            :         (ArgType_Double &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     837 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :     // int f(int, double)
<span class="lineNum">     840 </span>            :     Args_Int_IntDouble = Args_General0 |
<span class="lineNum">     841 </span>            :         (ArgType_Double &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     842 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 2)),
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :     // double f(double, double, double)
<span class="lineNum">     845 </span>            :     Args_Double_DoubleDoubleDouble = Args_Double_DoubleDouble | (ArgType_Double &lt;&lt; (ArgType_Shift * 3)),
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :     // double f(double, double, double, double)
<span class="lineNum">     848 </span>            :     Args_Double_DoubleDoubleDoubleDouble = Args_Double_DoubleDoubleDouble | (ArgType_Double &lt;&lt; (ArgType_Shift * 4)),
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :     // int f(double, int, int)
<span class="lineNum">     851 </span>            :     Args_Int_DoubleIntInt = Args_General0 |
<span class="lineNum">     852 </span>            :        (ArgType_General &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     853 </span>            :        (ArgType_General &lt;&lt; (ArgType_Shift * 2)) |
<span class="lineNum">     854 </span>            :        (ArgType_Double  &lt;&lt; (ArgType_Shift * 3)),
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :     // int f(int, double, int, int)
<span class="lineNum">     857 </span>            :     Args_Int_IntDoubleIntInt = Args_General0 |
<span class="lineNum">     858 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 1)) |
<span class="lineNum">     859 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 2)) |
<span class="lineNum">     860 </span>            :         (ArgType_Double  &lt;&lt; (ArgType_Shift * 3)) |
<span class="lineNum">     861 </span>            :         (ArgType_General &lt;&lt; (ArgType_Shift * 4))
<span class="lineNum">     862 </span>            : };
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : enum class BarrierKind : uint32_t {
<span class="lineNum">     865 </span>            :     // No barrier is needed.
<span class="lineNum">     866 </span>            :     NoBarrier,
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :     // The barrier only has to check the value's type tag is in the TypeSet.
<span class="lineNum">     869 </span>            :     // Specific object types don't have to be checked.
<span class="lineNum">     870 </span>            :     TypeTagOnly,
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :     // Check if the value is in the TypeSet, including the object type if it's
<span class="lineNum">     873 </span>            :     // an object.
<span class="lineNum">     874 </span>            :     TypeSet
<span class="lineNum">     875 </span>            : };
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : enum ReprotectCode { Reprotect = true, DontReprotect = false };
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            : // Rounding modes for round instructions.
<span class="lineNum">     880 </span>            : enum class RoundingMode {
<span class="lineNum">     881 </span>            :     Down,
<span class="lineNum">     882 </span>            :     Up,
<span class="lineNum">     883 </span>            :     NearestTiesToEven,
<span class="lineNum">     884 </span>            :     TowardsZero
<span class="lineNum">     885 </span>            : };
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            : } // namespace jit
<span class="lineNum">     888 </span>            : } // namespace js
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : #endif /* jit_IonTypes_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

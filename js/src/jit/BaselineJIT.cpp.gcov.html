<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jit/BaselineJIT.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">js/src/jit</a> - BaselineJIT.cpp<span style="font-size: 80%;"> (source / <a href="BaselineJIT.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">353</td>
            <td class="headerCovTableEntry">617</td>
            <td class="headerCovTableEntryLo">57.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 16:53:18</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntryLo">68.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;jit/BaselineJIT.h&quot;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;mozilla/BinarySearch.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;mozilla/DebugOnly.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;jit/BaselineCompiler.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;jit/BaselineIC.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;jit/CompileInfo.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;jit/IonControlFlow.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;jit/JitCommon.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;jit/JitSpewer.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;vm/Debugger.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;vm/Interpreter.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;vm/TraceLogging.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;wasm/WasmInstance.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;jsobjinlines.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;jsopcodeinlines.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;jsscriptinlines.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;jit/JitFrames-inl.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;jit/MacroAssembler-inl.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;vm/Stack-inl.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : using mozilla::BinarySearchIf;
<span class="lineNum">      33 </span>            : using mozilla::DebugOnly;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : using namespace js;
<span class="lineNum">      36 </span>            : using namespace js::jit;
<a name="37"><span class="lineNum">      37 </span>            : </a>
<span class="lineNum">      38 </span>            : /* static */ PCMappingSlotInfo::SlotLocation
<span class="lineNum">      39 </span><span class="lineCov">      51873 : PCMappingSlotInfo::ToSlotLocation(const StackValue* stackVal)</span>
<span class="lineNum">      40 </span>            : {
<span class="lineNum">      41 </span><span class="lineCov">      51873 :     if (stackVal-&gt;kind() == StackValue::Register) {</span>
<span class="lineNum">      42 </span><span class="lineCov">      30878 :         if (stackVal-&gt;reg() == R0)</span>
<span class="lineNum">      43 </span><span class="lineCov">      26617 :             return SlotInR0;</span>
<span class="lineNum">      44 </span><span class="lineCov">       4261 :         MOZ_ASSERT(stackVal-&gt;reg() == R1);</span>
<span class="lineNum">      45 </span><span class="lineCov">       4261 :         return SlotInR1;</span>
<span class="lineNum">      46 </span>            :     }
<span class="lineNum">      47 </span><span class="lineCov">      20995 :     MOZ_ASSERT(stackVal-&gt;kind() != StackValue::Stack);</span>
<span class="lineNum">      48 </span><span class="lineCov">      20995 :     return SlotIgnore;</span>
<span class="lineNum">      49 </span>            : }
<a name="50"><span class="lineNum">      50 </span>            : </a>
<span class="lineNum">      51 </span>            : void
<span class="lineNum">      52 </span><span class="lineCov">        555 : ICStubSpace::freeAllAfterMinorGC(Zone* zone)</span>
<span class="lineNum">      53 </span>            : {
<span class="lineNum">      54 </span><span class="lineCov">        555 :     if (zone-&gt;isAtomsZone())</span>
<span class="lineNum">      55 </span><span class="lineCov">          1 :         MOZ_ASSERT(allocator_.isEmpty());</span>
<span class="lineNum">      56 </span>            :     else
<span class="lineNum">      57 </span><span class="lineCov">        554 :         zone-&gt;runtimeFromActiveCooperatingThread()-&gt;gc.freeAllLifoBlocksAfterMinorGC(&amp;allocator_);</span>
<a name="58"><span class="lineNum">      58 </span><span class="lineCov">        555 : }</span></a>
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span><span class="lineCov">        627 : BaselineScript::BaselineScript(uint32_t prologueOffset, uint32_t epilogueOffset,</span>
<span class="lineNum">      61 </span>            :                                uint32_t profilerEnterToggleOffset,
<span class="lineNum">      62 </span>            :                                uint32_t profilerExitToggleOffset,
<span class="lineNum">      63 </span><span class="lineCov">        627 :                                uint32_t postDebugPrologueOffset)</span>
<span class="lineNum">      64 </span>            :   : method_(nullptr),
<span class="lineNum">      65 </span>            :     templateEnv_(nullptr),
<span class="lineNum">      66 </span>            :     fallbackStubSpace_(),
<span class="lineNum">      67 </span>            :     dependentWasmImports_(nullptr),
<span class="lineNum">      68 </span>            :     prologueOffset_(prologueOffset),
<span class="lineNum">      69 </span>            :     epilogueOffset_(epilogueOffset),
<span class="lineNum">      70 </span>            :     profilerEnterToggleOffset_(profilerEnterToggleOffset),
<span class="lineNum">      71 </span>            :     profilerExitToggleOffset_(profilerExitToggleOffset),
<span class="lineNum">      72 </span>            : #ifdef JS_TRACE_LOGGING
<span class="lineNum">      73 </span>            : # ifdef DEBUG
<span class="lineNum">      74 </span>            :     traceLoggerScriptsEnabled_(false),
<span class="lineNum">      75 </span>            :     traceLoggerEngineEnabled_(false),
<span class="lineNum">      76 </span>            : # endif
<span class="lineNum">      77 </span>            :     traceLoggerScriptEvent_(),
<span class="lineNum">      78 </span>            : #endif
<span class="lineNum">      79 </span>            :     postDebugPrologueOffset_(postDebugPrologueOffset),
<span class="lineNum">      80 </span>            :     flags_(0),
<span class="lineNum">      81 </span>            :     inlinedBytecodeLength_(0),
<span class="lineNum">      82 </span>            :     maxInliningDepth_(UINT8_MAX),
<span class="lineNum">      83 </span>            :     pendingBuilder_(nullptr),
<span class="lineNum">      84 </span><span class="lineCov">        627 :     controlFlowGraph_(nullptr)</span>
<span class="lineNum">      85 </span><span class="lineCov">        627 : { }</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : static const unsigned BASELINE_MAX_ARGS_LENGTH = 20000;
<a name="88"><span class="lineNum">      88 </span>            : </a>
<span class="lineNum">      89 </span>            : static bool
<span class="lineNum">      90 </span><span class="lineCov">       2293 : CheckFrame(InterpreterFrame* fp)</span>
<span class="lineNum">      91 </span>            : {
<span class="lineNum">      92 </span><span class="lineCov">       2293 :     if (fp-&gt;isDebuggerEvalFrame()) {</span>
<span class="lineNum">      93 </span>            :         // Debugger eval-in-frame. These are likely short-running scripts so
<span class="lineNum">      94 </span>            :         // don't bother compiling them for now.
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :         JitSpew(JitSpew_BaselineAbort, &quot;debugger frame&quot;);</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">      97 </span>            :     }
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">       2293 :     if (fp-&gt;isFunctionFrame() &amp;&amp; fp-&gt;numActualArgs() &gt; BASELINE_MAX_ARGS_LENGTH) {</span>
<span class="lineNum">     100 </span>            :         // Fall back to the interpreter to avoid running out of stack space.
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :         JitSpew(JitSpew_BaselineAbort, &quot;Too many arguments (%u)&quot;, fp-&gt;numActualArgs());</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     103 </span>            :     }
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineCov">       2293 :     return true;</span>
<span class="lineNum">     106 </span>            : }
<a name="107"><span class="lineNum">     107 </span>            : </a>
<span class="lineNum">     108 </span>            : static JitExecStatus
<span class="lineNum">     109 </span><span class="lineCov">       7638 : EnterBaseline(JSContext* cx, EnterJitData&amp; data)</span>
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span><span class="lineCov">       7638 :     if (data.osrFrame) {</span>
<span class="lineNum">     112 </span>            :         // Check for potential stack overflow before OSR-ing.
<span class="lineNum">     113 </span>            :         uint8_t spDummy;
<span class="lineNum">     114 </span><span class="lineCov">        141 :         uint32_t extra = BaselineFrame::Size() + (data.osrNumStackValues * sizeof(Value));</span>
<span class="lineNum">     115 </span><span class="lineCov">        141 :         uint8_t* checkSp = (&amp;spDummy) - extra;</span>
<span class="lineNum">     116 </span><span class="lineCov">        141 :         if (!CheckRecursionLimitWithStackPointer(cx, checkSp))</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :             return JitExec_Aborted;</span>
<span class="lineNum">     118 </span>            :     } else {
<span class="lineNum">     119 </span><span class="lineCov">       7497 :         if (!CheckRecursionLimit(cx))</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :             return JitExec_Aborted;</span>
<span class="lineNum">     121 </span>            :     }
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #ifdef DEBUG
<span class="lineNum">     124 </span>            :     // Assert we don't GC before entering JIT code. A GC could discard JIT code
<span class="lineNum">     125 </span>            :     // or move the function stored in the CalleeToken (it won't be traced at
<span class="lineNum">     126 </span>            :     // this point). We use Maybe&lt;&gt; here so we can call reset() to call the
<span class="lineNum">     127 </span>            :     // AutoAssertNoGC destructor before we enter JIT code.
<span class="lineNum">     128 </span><span class="lineCov">      15276 :     mozilla::Maybe&lt;JS::AutoAssertNoGC&gt; nogc;</span>
<span class="lineNum">     129 </span><span class="lineCov">       7638 :     nogc.emplace(cx);</span>
<span class="lineNum">     130 </span>            : #endif
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">       7638 :     MOZ_ASSERT(jit::IsBaselineEnabled(cx));</span>
<span class="lineNum">     133 </span><span class="lineCov">       7638 :     MOZ_ASSERT_IF(data.osrFrame, CheckFrame(data.osrFrame));</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span><span class="lineCov">       7638 :     EnterJitCode enter = cx-&gt;runtime()-&gt;jitRuntime()-&gt;enterBaseline();</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     bool constructingLegacyGen =
<span class="lineNum">     138 </span><span class="lineCov">       7638 :         data.constructing &amp;&amp; CalleeTokenToFunction(data.calleeToken)-&gt;isLegacyGenerator();</span>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :     // Caller must construct |this| before invoking the Ion function. Legacy
<span class="lineNum">     141 </span>            :     // generators can be called with 'new' but when we resume them, the
<span class="lineNum">     142 </span>            :     // this-slot and arguments are |undefined| (they are stored in the
<span class="lineNum">     143 </span>            :     // CallObject).
<span class="lineNum">     144 </span><span class="lineCov">       7638 :     MOZ_ASSERT_IF(data.constructing &amp;&amp; !constructingLegacyGen,</span>
<span class="lineNum">     145 </span>            :                   data.maxArgv[0].isObject() || data.maxArgv[0].isMagic(JS_UNINITIALIZED_LEXICAL));
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov">       7638 :     data.result.setInt32(data.numActualArgs);</span>
<span class="lineNum">     148 </span>            :     {
<span class="lineNum">     149 </span><span class="lineCov">      15276 :         AssertCompartmentUnchanged pcc(cx);</span>
<span class="lineNum">     150 </span><span class="lineCov">      15276 :         ActivationEntryMonitor entryMonitor(cx, data.calleeToken);</span>
<span class="lineNum">     151 </span><span class="lineCov">      15276 :         JitActivation activation(cx);</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">       7638 :         if (data.osrFrame)</span>
<span class="lineNum">     154 </span><span class="lineCov">        141 :             data.osrFrame-&gt;setRunningInJit();</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : #ifdef DEBUG
<span class="lineNum">     157 </span><span class="lineCov">       7638 :         nogc.reset();</span>
<span class="lineNum">     158 </span>            : #endif
<span class="lineNum">     159 </span>            :         // Single transition point from Interpreter to Baseline.
<span class="lineNum">     160 </span><span class="lineCov">       7638 :         CALL_GENERATED_CODE(enter, data.jitcode, data.maxArgc, data.maxArgv, data.osrFrame,</span>
<span class="lineNum">     161 </span>            :                             data.calleeToken, data.envChain.get(), data.osrNumStackValues,
<span class="lineNum">     162 </span><span class="lineCov">       7638 :                             data.result.address());</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">       7638 :         if (data.osrFrame)</span>
<span class="lineNum">     165 </span><span class="lineCov">        141 :             data.osrFrame-&gt;clearRunningInJit();</span>
<span class="lineNum">     166 </span>            :     }
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineCov">       7638 :     MOZ_ASSERT(!cx-&gt;hasIonReturnOverride());</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :     // Jit callers wrap primitive constructor return, except for derived
<span class="lineNum">     171 </span>            :     // class constructors, which are forced to do it themselves.
<span class="lineNum">     172 </span><span class="lineCov">      22836 :     if (!data.result.isMagic() &amp;&amp;</span>
<span class="lineNum">     173 </span><span class="lineCov">       7640 :         data.constructing &amp;&amp;</span>
<span class="lineNum">     174 </span><span class="lineCov">       7796 :         data.result.isPrimitive() &amp;&amp;</span>
<span class="lineNum">     175 </span><span class="lineCov">         78 :         !constructingLegacyGen)</span>
<span class="lineNum">     176 </span>            :     {
<span class="lineNum">     177 </span><span class="lineCov">         78 :         MOZ_ASSERT(data.maxArgv[0].isObject());</span>
<span class="lineNum">     178 </span><span class="lineCov">         78 :         data.result = data.maxArgv[0];</span>
<span class="lineNum">     179 </span>            :     }
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :     // Release temporary buffer used for OSR into Ion.
<span class="lineNum">     182 </span><span class="lineCov">       7638 :     cx-&gt;freeOsrTempData();</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineCov">       7638 :     MOZ_ASSERT_IF(data.result.isMagic(), data.result.isMagic(JS_ION_ERROR));</span>
<span class="lineNum">     185 </span><span class="lineCov">       7638 :     return data.result.isMagic() ? JitExec_Error : JitExec_Ok;</span>
<span class="lineNum">     186 </span>            : }
<a name="187"><span class="lineNum">     187 </span>            : </a>
<span class="lineNum">     188 </span>            : JitExecStatus
<span class="lineNum">     189 </span><span class="lineCov">       7497 : jit::EnterBaselineMethod(JSContext* cx, RunState&amp; state)</span>
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span><span class="lineCov">       7497 :     BaselineScript* baseline = state.script()-&gt;baselineScript();</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineCov">      14994 :     EnterJitData data(cx);</span>
<span class="lineNum">     194 </span><span class="lineCov">       7497 :     data.jitcode = baseline-&gt;method()-&gt;raw();</span>
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineCov">      14994 :     Rooted&lt;GCVector&lt;Value&gt;&gt; vals(cx, GCVector&lt;Value&gt;(cx));</span>
<span class="lineNum">     197 </span><span class="lineCov">       7497 :     if (!SetEnterJitData(cx, data, state, &amp;vals))</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         return JitExec_Error;</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">       7497 :     JitExecStatus status = EnterBaseline(cx, data);</span>
<span class="lineNum">     201 </span><span class="lineCov">       7497 :     if (status != JitExec_Ok)</span>
<span class="lineNum">     202 </span><span class="lineCov">         78 :         return status;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">       7419 :     state.setReturnValue(data.result);</span>
<span class="lineNum">     205 </span><span class="lineCov">       7419 :     return JitExec_Ok;</span>
<span class="lineNum">     206 </span>            : }
<a name="207"><span class="lineNum">     207 </span>            : </a>
<span class="lineNum">     208 </span>            : JitExecStatus
<span class="lineNum">     209 </span><span class="lineCov">        141 : jit::EnterBaselineAtBranch(JSContext* cx, InterpreterFrame* fp, jsbytecode* pc)</span>
<span class="lineNum">     210 </span>            : {
<span class="lineNum">     211 </span><span class="lineCov">        141 :     MOZ_ASSERT(JSOp(*pc) == JSOP_LOOPENTRY);</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">        141 :     BaselineScript* baseline = fp-&gt;script()-&gt;baselineScript();</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineCov">        282 :     EnterJitData data(cx);</span>
<span class="lineNum">     216 </span><span class="lineCov">        141 :     data.jitcode = baseline-&gt;nativeCodeForPC(fp-&gt;script(), pc);</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     // Skip debug breakpoint/trap handler, the interpreter already handled it
<span class="lineNum">     219 </span>            :     // for the current op.
<span class="lineNum">     220 </span><span class="lineCov">        141 :     if (fp-&gt;isDebuggee()) {</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         MOZ_RELEASE_ASSERT(baseline-&gt;hasDebugInstrumentation());</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         data.jitcode += MacroAssembler::ToggledCallSize(data.jitcode);</span>
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineCov">        141 :     data.osrFrame = fp;</span>
<span class="lineNum">     226 </span><span class="lineCov">        141 :     data.osrNumStackValues = fp-&gt;script()-&gt;nfixed() + cx-&gt;interpreterRegs().stackDepth();</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">        282 :     AutoValueVector vals(cx);</span>
<span class="lineNum">     229 </span><span class="lineCov">        282 :     RootedValue thisv(cx);</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">        141 :     if (fp-&gt;isFunctionFrame()) {</span>
<span class="lineNum">     232 </span><span class="lineCov">        136 :         data.constructing = fp-&gt;isConstructing();</span>
<span class="lineNum">     233 </span><span class="lineCov">        136 :         data.numActualArgs = fp-&gt;numActualArgs();</span>
<span class="lineNum">     234 </span><span class="lineCov">        136 :         data.maxArgc = Max(fp-&gt;numActualArgs(), fp-&gt;numFormalArgs()) + 1; // +1 = include |this|</span>
<span class="lineNum">     235 </span><span class="lineCov">        136 :         data.maxArgv = fp-&gt;argv() - 1; // -1 = include |this|</span>
<span class="lineNum">     236 </span><span class="lineCov">        136 :         data.envChain = nullptr;</span>
<span class="lineNum">     237 </span><span class="lineCov">        136 :         data.calleeToken = CalleeToToken(&amp;fp-&gt;callee(), data.constructing);</span>
<span class="lineNum">     238 </span>            :     } else {
<span class="lineNum">     239 </span><span class="lineCov">          5 :         thisv.setUndefined();</span>
<span class="lineNum">     240 </span><span class="lineCov">          5 :         data.constructing = false;</span>
<span class="lineNum">     241 </span><span class="lineCov">          5 :         data.numActualArgs = 0;</span>
<span class="lineNum">     242 </span><span class="lineCov">          5 :         data.maxArgc = 1;</span>
<span class="lineNum">     243 </span><span class="lineCov">          5 :         data.maxArgv = thisv.address();</span>
<span class="lineNum">     244 </span><span class="lineCov">          5 :         data.envChain = fp-&gt;environmentChain();</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">          5 :         data.calleeToken = CalleeToToken(fp-&gt;script());</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov">          5 :         if (fp-&gt;isEvalFrame()) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :             if (!vals.reserve(2))</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                 return JitExec_Aborted;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :             vals.infallibleAppend(thisv);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :             if (fp-&gt;script()-&gt;isDirectEvalInFunction())</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                 vals.infallibleAppend(fp-&gt;newTarget());</span>
<span class="lineNum">     256 </span>            :             else
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                 vals.infallibleAppend(NullValue());</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :             data.maxArgc = 2;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :             data.maxArgv = vals.begin();</span>
<span class="lineNum">     261 </span>            :         }
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineCov">        141 :     TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);</span>
<span class="lineNum">     265 </span><span class="lineCov">        141 :     TraceLogStopEvent(logger, TraceLogger_Interpreter);</span>
<span class="lineNum">     266 </span><span class="lineCov">        141 :     TraceLogStartEvent(logger, TraceLogger_Baseline);</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">        141 :     JitExecStatus status = EnterBaseline(cx, data);</span>
<span class="lineNum">     269 </span><span class="lineCov">        141 :     if (status != JitExec_Ok)</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         return status;</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineCov">        141 :     fp-&gt;setReturnValue(data.result);</span>
<span class="lineNum">     273 </span><span class="lineCov">        141 :     return JitExec_Ok;</span>
<span class="lineNum">     274 </span>            : }
<a name="275"><span class="lineNum">     275 </span>            : </a>
<span class="lineNum">     276 </span>            : MethodStatus
<span class="lineNum">     277 </span><span class="lineCov">        628 : jit::BaselineCompile(JSContext* cx, JSScript* script, bool forceDebugInstrumentation)</span>
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span><span class="lineCov">        628 :     MOZ_ASSERT(!script-&gt;hasBaselineScript());</span>
<span class="lineNum">     280 </span><span class="lineCov">        628 :     MOZ_ASSERT(script-&gt;canBaselineCompile());</span>
<span class="lineNum">     281 </span><span class="lineCov">        628 :     MOZ_ASSERT(IsBaselineEnabled(cx));</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineCov">        628 :     script-&gt;ensureNonLazyCanonicalFunction();</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">       1256 :     LifoAlloc alloc(TempAllocator::PreferredLifoChunkSize);</span>
<span class="lineNum">     286 </span><span class="lineCov">        628 :     TempAllocator* temp = alloc.new_&lt;TempAllocator&gt;(&amp;alloc);</span>
<span class="lineNum">     287 </span><span class="lineCov">        628 :     if (!temp) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         return Method_Error;</span>
<span class="lineNum">     290 </span>            :     }
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineCov">       1256 :     JitContext jctx(cx, temp);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineCov">       1256 :     BaselineCompiler compiler(cx, *temp, script);</span>
<span class="lineNum">     295 </span><span class="lineCov">        628 :     if (!compiler.init()) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :         ReportOutOfMemory(cx);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         return Method_Error;</span>
<span class="lineNum">     298 </span>            :     }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">        628 :     if (forceDebugInstrumentation)</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :         compiler.setCompileDebugInstrumentation();</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span><span class="lineCov">        628 :     MethodStatus status = compiler.compile();</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineCov">        628 :     MOZ_ASSERT_IF(status == Method_Compiled, script-&gt;hasBaselineScript());</span>
<span class="lineNum">     306 </span><span class="lineCov">        628 :     MOZ_ASSERT_IF(status != Method_Compiled, !script-&gt;hasBaselineScript());</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">        628 :     if (status == Method_CantCompile)</span>
<span class="lineNum">     309 </span><span class="lineCov">          1 :         script-&gt;setBaselineScript(cx-&gt;runtime(), BASELINE_DISABLED_SCRIPT);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineCov">        628 :     return status;</span>
<span class="lineNum">     312 </span>            : }
<a name="313"><span class="lineNum">     313 </span>            : </a>
<span class="lineNum">     314 </span>            : static MethodStatus
<span class="lineNum">     315 </span><span class="lineCov">      21750 : CanEnterBaselineJIT(JSContext* cx, HandleScript script, InterpreterFrame* osrFrame)</span>
<span class="lineNum">     316 </span>            : {
<span class="lineNum">     317 </span><span class="lineCov">      21750 :     MOZ_ASSERT(jit::IsBaselineEnabled(cx));</span>
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     // Skip if the script has been disabled.
<span class="lineNum">     320 </span><span class="lineCov">      21750 :     if (!script-&gt;canBaselineCompile())</span>
<span class="lineNum">     321 </span><span class="lineCov">         46 :         return Method_Skipped;</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineCov">      21704 :     if (script-&gt;length() &gt; BaselineScript::MAX_JSSCRIPT_LENGTH)</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         return Method_CantCompile;</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">      21704 :     if (script-&gt;nslots() &gt; BaselineScript::MAX_JSSCRIPT_SLOTS)</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         return Method_CantCompile;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineCov">      21704 :     if (script-&gt;hasBaselineScript())</span>
<span class="lineNum">     330 </span><span class="lineCov">       7011 :         return Method_Compiled;</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :     // Check this before calling ensureJitCompartmentExists, so we're less
<span class="lineNum">     333 </span>            :     // likely to report OOM in JSRuntime::createJitRuntime.
<span class="lineNum">     334 </span><span class="lineCov">      14693 :     if (!CanLikelyAllocateMoreExecutableMemory())</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         return Method_Skipped;</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">      14693 :     if (!cx-&gt;compartment()-&gt;ensureJitCompartmentExists(cx))</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         return Method_Error;</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :     // Check script warm-up counter.
<span class="lineNum">     341 </span><span class="lineCov">      14693 :     if (script-&gt;incWarmUpCounter() &lt;= JitOptions.baselineWarmUpThreshold)</span>
<span class="lineNum">     342 </span><span class="lineCov">      14065 :         return Method_Skipped;</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :     // Frames can be marked as debuggee frames independently of its underlying
<span class="lineNum">     345 </span>            :     // script being a debuggee script, e.g., when performing
<span class="lineNum">     346 </span>            :     // Debugger.Frame.prototype.eval.
<span class="lineNum">     347 </span><span class="lineCov">        628 :     return BaselineCompile(cx, script, osrFrame &amp;&amp; osrFrame-&gt;isDebuggee());</span>
<span class="lineNum">     348 </span>            : }
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            : MethodStatus
<span class="lineNum">     351 </span><span class="lineCov">       2152 : jit::CanEnterBaselineAtBranch(JSContext* cx, InterpreterFrame* fp, bool newType)</span>
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span><span class="lineCov">       2152 :    if (!CheckFrame(fp))</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :        return Method_CantCompile;</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :    // This check is needed in the following corner case. Consider a function h,
<span class="lineNum">     357 </span>            :    //
<span class="lineNum">     358 </span>            :    //   function h(x) {
<span class="lineNum">     359 </span>            :    //      h(false);
<span class="lineNum">     360 </span>            :    //      if (!x)
<span class="lineNum">     361 </span>            :    //        return;
<span class="lineNum">     362 </span>            :    //      for (var i = 0; i &lt; N; i++)
<span class="lineNum">     363 </span>            :    //         /* do stuff */
<span class="lineNum">     364 </span>            :    //   }
<span class="lineNum">     365 </span>            :    //
<span class="lineNum">     366 </span>            :    // Suppose h is not yet compiled in baseline and is executing in the
<span class="lineNum">     367 </span>            :    // interpreter. Let this interpreter frame be f_older. The debugger marks
<span class="lineNum">     368 </span>            :    // f_older as isDebuggee. At the point of the recursive call h(false), h is
<span class="lineNum">     369 </span>            :    // compiled in baseline without debug instrumentation, pushing a baseline
<span class="lineNum">     370 </span>            :    // frame f_newer. The debugger never flags f_newer as isDebuggee, and never
<span class="lineNum">     371 </span>            :    // recompiles h. When the recursive call returns and execution proceeds to
<span class="lineNum">     372 </span>            :    // the loop, the interpreter attempts to OSR into baseline. Since h is
<span class="lineNum">     373 </span>            :    // already compiled in baseline, execution jumps directly into baseline
<span class="lineNum">     374 </span>            :    // code. This is incorrect as h's baseline script does not have debug
<span class="lineNum">     375 </span>            :    // instrumentation.
<span class="lineNum">     376 </span><span class="lineCov">       2152 :    if (fp-&gt;isDebuggee() &amp;&amp; !Debugger::ensureExecutionObservabilityOfOsrFrame(cx, fp))</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :        return Method_Error;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">       4304 :    RootedScript script(cx, fp-&gt;script());</span>
<span class="lineNum">     380 </span><span class="lineCov">       2152 :    return CanEnterBaselineJIT(cx, script, fp);</span>
<span class="lineNum">     381 </span>            : }
<a name="382"><span class="lineNum">     382 </span>            : </a>
<span class="lineNum">     383 </span>            : MethodStatus
<span class="lineNum">     384 </span><span class="lineCov">      19598 : jit::CanEnterBaselineMethod(JSContext* cx, RunState&amp; state)</span>
<span class="lineNum">     385 </span>            : {
<span class="lineNum">     386 </span><span class="lineCov">      19598 :     if (state.isInvoke()) {</span>
<span class="lineNum">     387 </span><span class="lineCov">      19100 :         InvokeState&amp; invoke = *state.asInvoke();</span>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">      19100 :         if (invoke.args().length() &gt; BASELINE_MAX_ARGS_LENGTH) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :             JitSpew(JitSpew_BaselineAbort, &quot;Too many arguments (%u)&quot;, invoke.args().length());</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             return Method_CantCompile;</span>
<span class="lineNum">     392 </span>            :         }
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">      19100 :         if (!state.maybeCreateThisForConstructor(cx)) {</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :             if (cx-&gt;isThrowingOutOfMemory()) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 cx-&gt;recoverFromOutOfMemory();</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 return Method_Skipped;</span>
<span class="lineNum">     398 </span>            :             }
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :             return Method_Error;</span>
<span class="lineNum">     400 </span>            :         }
<span class="lineNum">     401 </span>            :     } else {
<span class="lineNum">     402 </span><span class="lineCov">        498 :         if (state.asExecute()-&gt;isDebuggerEval()) {</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             JitSpew(JitSpew_BaselineAbort, &quot;debugger frame&quot;);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :             return Method_CantCompile;</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span>            :     }
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">      39196 :     RootedScript script(cx, state.script());</span>
<span class="lineNum">     409 </span><span class="lineCov">      19598 :     return CanEnterBaselineJIT(cx, script, /* osrFrame = */ nullptr);</span>
<span class="lineNum">     410 </span>            : };
<a name="411"><span class="lineNum">     411 </span>            : </a>
<span class="lineNum">     412 </span>            : BaselineScript*
<span class="lineNum">     413 </span><span class="lineCov">        627 : BaselineScript::New(JSScript* jsscript,</span>
<span class="lineNum">     414 </span>            :                     uint32_t prologueOffset, uint32_t epilogueOffset,
<span class="lineNum">     415 </span>            :                     uint32_t profilerEnterToggleOffset,
<span class="lineNum">     416 </span>            :                     uint32_t profilerExitToggleOffset,
<span class="lineNum">     417 </span>            :                     uint32_t postDebugPrologueOffset,
<span class="lineNum">     418 </span>            :                     size_t icEntries,
<span class="lineNum">     419 </span>            :                     size_t pcMappingIndexEntries, size_t pcMappingSize,
<span class="lineNum">     420 </span>            :                     size_t bytecodeTypeMapEntries,
<span class="lineNum">     421 </span>            :                     size_t yieldEntries,
<span class="lineNum">     422 </span>            :                     size_t traceLoggerToggleOffsetEntries)
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span>            :     static const unsigned DataAlignment = sizeof(uintptr_t);
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">        627 :     size_t icEntriesSize = icEntries * sizeof(BaselineICEntry);</span>
<span class="lineNum">     427 </span><span class="lineCov">        627 :     size_t pcMappingIndexEntriesSize = pcMappingIndexEntries * sizeof(PCMappingIndexEntry);</span>
<span class="lineNum">     428 </span><span class="lineCov">        627 :     size_t bytecodeTypeMapSize = bytecodeTypeMapEntries * sizeof(uint32_t);</span>
<span class="lineNum">     429 </span><span class="lineCov">        627 :     size_t yieldEntriesSize = yieldEntries * sizeof(uintptr_t);</span>
<span class="lineNum">     430 </span><span class="lineCov">        627 :     size_t tlEntriesSize = traceLoggerToggleOffsetEntries * sizeof(uint32_t);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">        627 :     size_t paddedICEntriesSize = AlignBytes(icEntriesSize, DataAlignment);</span>
<span class="lineNum">     433 </span><span class="lineCov">        627 :     size_t paddedPCMappingIndexEntriesSize = AlignBytes(pcMappingIndexEntriesSize, DataAlignment);</span>
<span class="lineNum">     434 </span><span class="lineCov">        627 :     size_t paddedPCMappingSize = AlignBytes(pcMappingSize, DataAlignment);</span>
<span class="lineNum">     435 </span><span class="lineCov">        627 :     size_t paddedBytecodeTypesMapSize = AlignBytes(bytecodeTypeMapSize, DataAlignment);</span>
<span class="lineNum">     436 </span><span class="lineCov">        627 :     size_t paddedYieldEntriesSize = AlignBytes(yieldEntriesSize, DataAlignment);</span>
<span class="lineNum">     437 </span><span class="lineCov">        627 :     size_t paddedTLEntriesSize = AlignBytes(tlEntriesSize, DataAlignment);</span>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineCov">        627 :     size_t allocBytes = paddedICEntriesSize +</span>
<span class="lineNum">     440 </span><span class="lineCov">        627 :                         paddedPCMappingIndexEntriesSize +</span>
<span class="lineNum">     441 </span><span class="lineCov">        627 :                         paddedPCMappingSize +</span>
<span class="lineNum">     442 </span><span class="lineCov">        627 :                         paddedBytecodeTypesMapSize +</span>
<span class="lineNum">     443 </span>            :                         paddedYieldEntriesSize +
<span class="lineNum">     444 </span><span class="lineCov">        627 :                         paddedTLEntriesSize;</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineCov">        627 :     BaselineScript* script = jsscript-&gt;zone()-&gt;pod_malloc_with_extra&lt;BaselineScript, uint8_t&gt;(allocBytes);</span>
<span class="lineNum">     447 </span><span class="lineCov">        627 :     if (!script)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         return nullptr;</span>
<span class="lineNum">     449 </span>            :     new (script) BaselineScript(prologueOffset, epilogueOffset,
<span class="lineNum">     450 </span>            :                                 profilerEnterToggleOffset, profilerExitToggleOffset,
<span class="lineNum">     451 </span><span class="lineCov">        627 :                                 postDebugPrologueOffset);</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">        627 :     size_t offsetCursor = sizeof(BaselineScript);</span>
<span class="lineNum">     454 </span><span class="lineCov">        627 :     MOZ_ASSERT(offsetCursor == AlignBytes(sizeof(BaselineScript), DataAlignment));</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineCov">        627 :     script-&gt;icEntriesOffset_ = offsetCursor;</span>
<span class="lineNum">     457 </span><span class="lineCov">        627 :     script-&gt;icEntries_ = icEntries;</span>
<span class="lineNum">     458 </span><span class="lineCov">        627 :     offsetCursor += paddedICEntriesSize;</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineCov">        627 :     script-&gt;pcMappingIndexOffset_ = offsetCursor;</span>
<span class="lineNum">     461 </span><span class="lineCov">        627 :     script-&gt;pcMappingIndexEntries_ = pcMappingIndexEntries;</span>
<span class="lineNum">     462 </span><span class="lineCov">        627 :     offsetCursor += paddedPCMappingIndexEntriesSize;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">        627 :     script-&gt;pcMappingOffset_ = offsetCursor;</span>
<span class="lineNum">     465 </span><span class="lineCov">        627 :     script-&gt;pcMappingSize_ = pcMappingSize;</span>
<span class="lineNum">     466 </span><span class="lineCov">        627 :     offsetCursor += paddedPCMappingSize;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">        627 :     script-&gt;bytecodeTypeMapOffset_ = bytecodeTypeMapEntries ? offsetCursor : 0;</span>
<span class="lineNum">     469 </span><span class="lineCov">        627 :     offsetCursor += paddedBytecodeTypesMapSize;</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">        627 :     script-&gt;yieldEntriesOffset_ = yieldEntries ? offsetCursor : 0;</span>
<span class="lineNum">     472 </span><span class="lineCov">        627 :     offsetCursor += paddedYieldEntriesSize;</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">        627 :     script-&gt;traceLoggerToggleOffsetsOffset_ = tlEntriesSize ? offsetCursor : 0;</span>
<span class="lineNum">     475 </span><span class="lineCov">        627 :     script-&gt;numTraceLoggerToggleOffsets_ = traceLoggerToggleOffsetEntries;</span>
<span class="lineNum">     476 </span><span class="lineCov">        627 :     offsetCursor += paddedTLEntriesSize;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">        627 :     MOZ_ASSERT(offsetCursor == sizeof(BaselineScript) + allocBytes);</span>
<span class="lineNum">     479 </span><span class="lineCov">        627 :     return script;</span>
<span class="lineNum">     480 </span>            : }
<a name="481"><span class="lineNum">     481 </span>            : </a>
<span class="lineNum">     482 </span>            : void
<span class="lineNum">     483 </span><span class="lineCov">          1 : BaselineScript::trace(JSTracer* trc)</span>
<span class="lineNum">     484 </span>            : {
<span class="lineNum">     485 </span><span class="lineCov">          1 :     TraceEdge(trc, &amp;method_, &quot;baseline-method&quot;);</span>
<span class="lineNum">     486 </span><span class="lineCov">          1 :     TraceNullableEdge(trc, &amp;templateEnv_, &quot;baseline-template-environment&quot;);</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     // Mark all IC stub codes hanging off the IC stub entries.
<span class="lineNum">     489 </span><span class="lineCov">         18 :     for (size_t i = 0; i &lt; numICEntries(); i++) {</span>
<span class="lineNum">     490 </span><span class="lineCov">         17 :         BaselineICEntry&amp; ent = icEntry(i);</span>
<span class="lineNum">     491 </span><span class="lineCov">         17 :         ent.trace(trc);</span>
<span class="lineNum">     492 </span>            :     }
<span class="lineNum">     493 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     494 </span>            : 
<a name="495"><span class="lineNum">     495 </span>            : /* static */</a>
<span class="lineNum">     496 </span>            : void
<span class="lineNum">     497 </span><span class="lineCov">        546 : BaselineScript::writeBarrierPre(Zone* zone, BaselineScript* script)</span>
<span class="lineNum">     498 </span>            : {
<span class="lineNum">     499 </span><span class="lineCov">        546 :     if (zone-&gt;needsIncrementalBarrier())</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         script-&gt;trace(zone-&gt;barrierTracer());</span>
<span class="lineNum">     501 </span><span class="lineCov">        546 : }</span>
<a name="502"><span class="lineNum">     502 </span>            : </a>
<span class="lineNum">     503 </span>            : void
<span class="lineNum">     504 </span><span class="lineCov">          1 : BaselineScript::Trace(JSTracer* trc, BaselineScript* script)</span>
<span class="lineNum">     505 </span>            : {
<span class="lineNum">     506 </span><span class="lineCov">          1 :     script-&gt;trace(trc);</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 : }</span>
<a name="508"><span class="lineNum">     508 </span>            : </a>
<span class="lineNum">     509 </span>            : void
<span class="lineNum">     510 </span><span class="lineCov">        546 : BaselineScript::Destroy(FreeOp* fop, BaselineScript* script)</span>
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineCov">        546 :     MOZ_ASSERT(!script-&gt;hasPendingIonBuilder());</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineCov">        546 :     script-&gt;unlinkDependentWasmImports(fop);</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     /*
<span class="lineNum">     518 </span>            :      * When the script contains pointers to nursery things, the store buffer can
<span class="lineNum">     519 </span>            :      * contain entries that point into the fallback stub space. Since we can
<span class="lineNum">     520 </span>            :      * destroy scripts outside the context of a GC, this situation could result
<span class="lineNum">     521 </span>            :      * in us trying to mark invalid store buffer entries.
<span class="lineNum">     522 </span>            :      *
<span class="lineNum">     523 </span>            :      * Defer freeing any allocated blocks until after the next minor GC.
<span class="lineNum">     524 </span>            :      */
<span class="lineNum">     525 </span><span class="lineCov">        546 :     script-&gt;fallbackStubSpace_.freeAllAfterMinorGC(script-&gt;method()-&gt;zone());</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">        546 :     fop-&gt;delete_(script);</span>
<span class="lineNum">     528 </span><span class="lineCov">        546 : }</span>
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            : void
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : JS::DeletePolicy&lt;js::jit::BaselineScript&gt;::operator()(const js::jit::BaselineScript* script)</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :     BaselineScript::Destroy(rt_-&gt;defaultFreeOp(), const_cast&lt;BaselineScript*&gt;(script));</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 : }</span>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<span class="lineNum">     536 </span>            : void
<span class="lineNum">     537 </span><span class="lineCov">        562 : BaselineScript::clearDependentWasmImports()</span>
<span class="lineNum">     538 </span>            : {
<span class="lineNum">     539 </span>            :     // Remove any links from wasm::Instances that contain optimized import calls into
<span class="lineNum">     540 </span>            :     // this BaselineScript.
<span class="lineNum">     541 </span><span class="lineCov">        562 :     if (dependentWasmImports_) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         for (DependentWasmImport&amp; dep : *dependentWasmImports_)</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :             dep.instance-&gt;deoptimizeImportExit(dep.importIndex);</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         dependentWasmImports_-&gt;clear();</span>
<span class="lineNum">     545 </span>            :     }
<span class="lineNum">     546 </span><span class="lineCov">        562 : }</span>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<span class="lineNum">     548 </span>            : void
<span class="lineNum">     549 </span><span class="lineCov">        546 : BaselineScript::unlinkDependentWasmImports(FreeOp* fop)</span>
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span>            :     // Remove any links from wasm::Instances that contain optimized FFI calls into
<span class="lineNum">     552 </span>            :     // this BaselineScript.
<span class="lineNum">     553 </span><span class="lineCov">        546 :     clearDependentWasmImports();</span>
<span class="lineNum">     554 </span><span class="lineCov">        546 :     if (dependentWasmImports_) {</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         fop-&gt;delete_(dependentWasmImports_);</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         dependentWasmImports_ = nullptr;</span>
<span class="lineNum">     557 </span>            :     }
<span class="lineNum">     558 </span><span class="lineCov">        546 : }</span>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<span class="lineNum">     560 </span>            : bool
<span class="lineNum">     561 </span><span class="lineNoCov">          0 : BaselineScript::addDependentWasmImport(JSContext* cx, wasm::Instance&amp; instance, uint32_t idx)</span>
<span class="lineNum">     562 </span>            : {
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     if (!dependentWasmImports_) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         dependentWasmImports_ = cx-&gt;new_&lt;Vector&lt;DependentWasmImport&gt;&gt;(cx);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         if (!dependentWasmImports_)</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     return dependentWasmImports_-&gt;emplaceBack(instance, idx);</span>
<span class="lineNum">     569 </span>            : }
<a name="570"><span class="lineNum">     570 </span>            : </a>
<span class="lineNum">     571 </span>            : void
<span class="lineNum">     572 </span><span class="lineNoCov">          0 : BaselineScript::removeDependentWasmImport(wasm::Instance&amp; instance, uint32_t idx)</span>
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     if (!dependentWasmImports_)</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     for (DependentWasmImport&amp; dep : *dependentWasmImports_) {</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         if (dep.instance == &amp;instance &amp;&amp; dep.importIndex == idx) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :             dependentWasmImports_-&gt;erase(&amp;dep);</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     581 </span>            :         }
<span class="lineNum">     582 </span>            :     }
<span class="lineNum">     583 </span>            : }
<a name="584"><span class="lineNum">     584 </span>            : </a>
<span class="lineNum">     585 </span>            : BaselineICEntry&amp;
<span class="lineNum">     586 </span><span class="lineCov">    1038900 : BaselineScript::icEntry(size_t index)</span>
<span class="lineNum">     587 </span>            : {
<span class="lineNum">     588 </span><span class="lineCov">    1038900 :     MOZ_ASSERT(index &lt; numICEntries());</span>
<span class="lineNum">     589 </span><span class="lineCov">    1038900 :     return icEntryList()[index];</span>
<span class="lineNum">     590 </span>            : }
<a name="591"><span class="lineNum">     591 </span>            : </a>
<span class="lineNum">     592 </span>            : PCMappingIndexEntry&amp;
<span class="lineNum">     593 </span><span class="lineCov">       7874 : BaselineScript::pcMappingIndexEntry(size_t index)</span>
<span class="lineNum">     594 </span>            : {
<span class="lineNum">     595 </span><span class="lineCov">       7874 :     MOZ_ASSERT(index &lt; numPCMappingIndexEntries());</span>
<span class="lineNum">     596 </span><span class="lineCov">       7874 :     return pcMappingIndexEntryList()[index];</span>
<span class="lineNum">     597 </span>            : }
<a name="598"><span class="lineNum">     598 </span>            : </a>
<span class="lineNum">     599 </span>            : CompactBufferReader
<span class="lineNum">     600 </span><span class="lineCov">       2135 : BaselineScript::pcMappingReader(size_t indexEntry)</span>
<span class="lineNum">     601 </span>            : {
<span class="lineNum">     602 </span><span class="lineCov">       2135 :     PCMappingIndexEntry&amp; entry = pcMappingIndexEntry(indexEntry);</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineCov">       2135 :     uint8_t* dataStart = pcMappingData() + entry.bufferOffset;</span>
<span class="lineNum">     605 </span><span class="lineCov">       2135 :     uint8_t* dataEnd = (indexEntry == numPCMappingIndexEntries() - 1)</span>
<span class="lineNum">     606 </span><span class="lineCov">       2262 :         ? pcMappingData() + pcMappingSize_</span>
<span class="lineNum">     607 </span><span class="lineCov">       2262 :         : pcMappingData() + pcMappingIndexEntry(indexEntry + 1).bufferOffset;</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineCov">       2135 :     return CompactBufferReader(dataStart, dataEnd);</span>
<span class="lineNum">     610 </span>            : }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : struct ICEntries
<span class="lineNum">     613 </span>            : {
<a name="614"><span class="lineNum">     614 </span>            :     BaselineScript* const baseline_;</a>
<span class="lineNum">     615 </span>            : 
<a name="616"><span class="lineNum">     616 </span><span class="lineCov">     125895 :     explicit ICEntries(BaselineScript* baseline) : baseline_(baseline) {}</span></a>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">     609371 :     BaselineICEntry&amp; operator[](size_t index) const {</span>
<span class="lineNum">     619 </span><span class="lineCov">     609371 :         return baseline_-&gt;icEntry(index);</span>
<span class="lineNum">     620 </span>            :     }
<span class="lineNum">     621 </span>            : };
<a name="622"><span class="lineNum">     622 </span>            : </a>
<span class="lineNum">     623 </span>            : BaselineICEntry&amp;
<span class="lineNum">     624 </span><span class="lineCov">       7623 : BaselineScript::icEntryFromReturnOffset(CodeOffset returnOffset)</span>
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span>            :     size_t loc;
<span class="lineNum">     627 </span>            : #ifdef DEBUG
<span class="lineNum">     628 </span>            :     bool found =
<a name="629"><span class="lineNum">     629 </span>            : #endif</a>
<span class="lineNum">     630 </span><span class="lineCov">      15246 :         BinarySearchIf(ICEntries(this), 0, numICEntries(),</span>
<span class="lineNum">     631 </span><span class="lineCov">      27077 :                        [&amp;returnOffset](BaselineICEntry&amp; entry) {</span>
<span class="lineNum">     632 </span><span class="lineCov">      27077 :                            size_t roffset = returnOffset.offset();</span>
<span class="lineNum">     633 </span><span class="lineCov">      27077 :                            size_t entryRoffset = entry.returnOffset().offset();</span>
<span class="lineNum">     634 </span><span class="lineCov">      27077 :                            if (roffset &lt; entryRoffset)</span>
<span class="lineNum">     635 </span><span class="lineCov">       6735 :                                return -1;</span>
<span class="lineNum">     636 </span><span class="lineCov">      20342 :                            if (entryRoffset &lt; roffset)</span>
<span class="lineNum">     637 </span><span class="lineCov">      12719 :                                return 1;</span>
<span class="lineNum">     638 </span><span class="lineCov">       7623 :                            return 0;</span>
<span class="lineNum">     639 </span>            :                        },
<span class="lineNum">     640 </span><span class="lineCov">       7623 :                        &amp;loc);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineCov">       7623 :     MOZ_ASSERT(found);</span>
<span class="lineNum">     643 </span><span class="lineCov">       7623 :     MOZ_ASSERT(loc &lt; numICEntries());</span>
<span class="lineNum">     644 </span><span class="lineCov">       7623 :     MOZ_ASSERT(icEntry(loc).returnOffset().offset() == returnOffset.offset());</span>
<span class="lineNum">     645 </span><span class="lineCov">       7623 :     return icEntry(loc);</span>
<span class="lineNum">     646 </span>            : }
<a name="647"><span class="lineNum">     647 </span>            : </a>
<span class="lineNum">     648 </span>            : static inline size_t
<span class="lineNum">     649 </span><span class="lineCov">     118272 : ComputeBinarySearchMid(BaselineScript* baseline, uint32_t pcOffset)</span>
<span class="lineNum">     650 </span>            : {
<a name="651"><span class="lineNum">     651 </span>            :     size_t loc;</a>
<span class="lineNum">     652 </span><span class="lineCov">     236544 :     BinarySearchIf(ICEntries(baseline), 0, baseline-&gt;numICEntries(),</span>
<span class="lineNum">     653 </span><span class="lineCov">    1525343 :                    [pcOffset](BaselineICEntry&amp; entry) {</span>
<span class="lineNum">     654 </span><span class="lineCov">     582294 :                        uint32_t entryOffset = entry.pcOffset();</span>
<span class="lineNum">     655 </span><span class="lineCov">     582294 :                        if (pcOffset &lt; entryOffset)</span>
<span class="lineNum">     656 </span><span class="lineCov">     221539 :                            return -1;</span>
<span class="lineNum">     657 </span><span class="lineCov">     360755 :                        if (entryOffset &lt; pcOffset)</span>
<span class="lineNum">     658 </span><span class="lineCov">     242483 :                            return 1;</span>
<span class="lineNum">     659 </span><span class="lineCov">     118272 :                        return 0;</span>
<span class="lineNum">     660 </span>            :                    },
<span class="lineNum">     661 </span><span class="lineCov">     118272 :                    &amp;loc);</span>
<span class="lineNum">     662 </span><span class="lineCov">     118272 :     return loc;</span>
<span class="lineNum">     663 </span>            : }
<a name="664"><span class="lineNum">     664 </span>            : </a>
<span class="lineNum">     665 </span>            : uint8_t*
<span class="lineNum">     666 </span><span class="lineNoCov">          0 : BaselineScript::returnAddressForIC(const BaselineICEntry&amp; ent)</span>
<span class="lineNum">     667 </span>            : {
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :     return method()-&gt;raw() + ent.returnOffset().offset();</span>
<span class="lineNum">     669 </span>            : }
<a name="670"><span class="lineNum">     670 </span>            : </a>
<span class="lineNum">     671 </span>            : BaselineICEntry&amp;
<span class="lineNum">     672 </span><span class="lineCov">     118272 : BaselineScript::icEntryFromPCOffset(uint32_t pcOffset)</span>
<span class="lineNum">     673 </span>            : {
<span class="lineNum">     674 </span>            :     // Multiple IC entries can have the same PC offset, but this method only looks for
<span class="lineNum">     675 </span>            :     // those which have isForOp() set.
<span class="lineNum">     676 </span><span class="lineCov">     118272 :     size_t mid = ComputeBinarySearchMid(this, pcOffset);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :     // Found an IC entry with a matching PC offset.  Search backward, and then
<span class="lineNum">     679 </span>            :     // forward from this IC entry, looking for one with the same PC offset which
<span class="lineNum">     680 </span>            :     // has isForOp() set.
<span class="lineNum">     681 </span><span class="lineCov">     125534 :     for (size_t i = mid; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == pcOffset; i--) {</span>
<span class="lineNum">     682 </span><span class="lineCov">     123781 :         if (icEntry(i).isForOp())</span>
<span class="lineNum">     683 </span><span class="lineCov">     116519 :             return icEntry(i);</span>
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span><span class="lineCov">       3003 :     for (size_t i = mid+1; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == pcOffset; i++) {</span>
<span class="lineNum">     686 </span><span class="lineCov">       3003 :         if (icEntry(i).isForOp())</span>
<span class="lineNum">     687 </span><span class="lineCov">       1753 :             return icEntry(i);</span>
<span class="lineNum">     688 </span>            :     }
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Invalid PC offset for IC entry.&quot;);</span>
<span class="lineNum">     690 </span>            : }
<a name="691"><span class="lineNum">     691 </span>            : </a>
<span class="lineNum">     692 </span>            : BaselineICEntry&amp;
<span class="lineNum">     693 </span><span class="lineCov">        274 : BaselineScript::icEntryFromPCOffset(uint32_t pcOffset, BaselineICEntry* prevLookedUpEntry)</span>
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span>            :     // Do a linear forward search from the last queried PC offset, or fallback to a
<span class="lineNum">     696 </span>            :     // binary search if the last offset is too far away.
<span class="lineNum">     697 </span><span class="lineCov">        517 :     if (prevLookedUpEntry &amp;&amp; pcOffset &gt;= prevLookedUpEntry-&gt;pcOffset() &amp;&amp;</span>
<span class="lineNum">     698 </span><span class="lineCov">        243 :         (pcOffset - prevLookedUpEntry-&gt;pcOffset()) &lt;= 10)</span>
<span class="lineNum">     699 </span>            :     {
<span class="lineNum">     700 </span><span class="lineCov">        153 :         BaselineICEntry* firstEntry = &amp;icEntry(0);</span>
<span class="lineNum">     701 </span><span class="lineCov">        153 :         BaselineICEntry* lastEntry = &amp;icEntry(numICEntries() - 1);</span>
<span class="lineNum">     702 </span><span class="lineCov">        153 :         BaselineICEntry* curEntry = prevLookedUpEntry;</span>
<span class="lineNum">     703 </span><span class="lineCov">        207 :         while (curEntry &gt;= firstEntry &amp;&amp; curEntry &lt;= lastEntry) {</span>
<span class="lineNum">     704 </span><span class="lineCov">        180 :             if (curEntry-&gt;pcOffset() == pcOffset &amp;&amp; curEntry-&gt;isForOp())</span>
<span class="lineNum">     705 </span><span class="lineCov">        153 :                 break;</span>
<span class="lineNum">     706 </span><span class="lineCov">         27 :             curEntry++;</span>
<span class="lineNum">     707 </span>            :         }
<span class="lineNum">     708 </span><span class="lineCov">        153 :         MOZ_ASSERT(curEntry-&gt;pcOffset() == pcOffset &amp;&amp; curEntry-&gt;isForOp());</span>
<span class="lineNum">     709 </span><span class="lineCov">        153 :         return *curEntry;</span>
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">        121 :     return icEntryFromPCOffset(pcOffset);</span>
<span class="lineNum">     713 </span>            : }
<a name="714"><span class="lineNum">     714 </span>            : </a>
<span class="lineNum">     715 </span>            : BaselineICEntry&amp;
<span class="lineNum">     716 </span><span class="lineNoCov">          0 : BaselineScript::callVMEntryFromPCOffset(uint32_t pcOffset)</span>
<span class="lineNum">     717 </span>            : {
<span class="lineNum">     718 </span>            :     // Like icEntryFromPCOffset, but only looks for the fake ICEntries
<span class="lineNum">     719 </span>            :     // inserted by VM calls.
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     size_t mid = ComputeBinarySearchMid(this, pcOffset);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :     for (size_t i = mid; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == pcOffset; i--) {</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :         if (icEntry(i).kind() == ICEntry::Kind_CallVM)</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :             return icEntry(i);</span>
<span class="lineNum">     725 </span>            :     }
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :     for (size_t i = mid+1; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == pcOffset; i++) {</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         if (icEntry(i).kind() == ICEntry::Kind_CallVM)</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :             return icEntry(i);</span>
<span class="lineNum">     729 </span>            :     }
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Invalid PC offset for callVM entry.&quot;);</span>
<span class="lineNum">     731 </span>            : }
<a name="732"><span class="lineNum">     732 </span>            : </a>
<span class="lineNum">     733 </span>            : BaselineICEntry&amp;
<span class="lineNum">     734 </span><span class="lineNoCov">          0 : BaselineScript::stackCheckICEntry(bool earlyCheck)</span>
<span class="lineNum">     735 </span>            : {
<span class="lineNum">     736 </span>            :     // The stack check will always be at offset 0, so just do a linear search
<span class="lineNum">     737 </span>            :     // from the beginning. This is only needed for debug mode OSR, when
<span class="lineNum">     738 </span>            :     // patching a frame that has invoked a Debugger hook via the interrupt
<span class="lineNum">     739 </span>            :     // handler via the stack check, which is part of the prologue.
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :     ICEntry::Kind kind = earlyCheck ? ICEntry::Kind_EarlyStackCheck : ICEntry::Kind_StackCheck;</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == 0; i++) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         if (icEntry(i).kind() == kind)</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :             return icEntry(i);</span>
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;No stack check ICEntry found.&quot;);</span>
<span class="lineNum">     746 </span>            : }
<a name="747"><span class="lineNum">     747 </span>            : </a>
<span class="lineNum">     748 </span>            : BaselineICEntry&amp;
<span class="lineNum">     749 </span><span class="lineNoCov">          0 : BaselineScript::warmupCountICEntry()</span>
<span class="lineNum">     750 </span>            : {
<span class="lineNum">     751 </span>            :     // The stack check will be at a very low offset, so just do a linear search
<span class="lineNum">     752 </span>            :     // from the beginning.
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numICEntries() &amp;&amp; icEntry(i).pcOffset() == 0; i++) {</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         if (icEntry(i).kind() == ICEntry::Kind_WarmupCounter)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :             return icEntry(i);</span>
<span class="lineNum">     756 </span>            :     }
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;No warmup count ICEntry found.&quot;);</span>
<span class="lineNum">     758 </span>            : }
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : BaselineICEntry&amp;
<span class="lineNum">     761 </span><span class="lineCov">       7623 : BaselineScript::icEntryFromReturnAddress(uint8_t* returnAddr)</span>
<span class="lineNum">     762 </span>            : {
<span class="lineNum">     763 </span><span class="lineCov">       7623 :     MOZ_ASSERT(returnAddr &gt; method_-&gt;raw());</span>
<span class="lineNum">     764 </span><span class="lineCov">       7623 :     MOZ_ASSERT(returnAddr &lt; method_-&gt;raw() + method_-&gt;instructionsSize());</span>
<span class="lineNum">     765 </span><span class="lineCov">       7623 :     CodeOffset offset(returnAddr - method_-&gt;raw());</span>
<span class="lineNum">     766 </span><span class="lineCov">       7623 :     return icEntryFromReturnOffset(offset);</span>
<span class="lineNum">     767 </span>            : }
<a name="768"><span class="lineNum">     768 </span>            : </a>
<span class="lineNum">     769 </span>            : void
<span class="lineNum">     770 </span><span class="lineCov">        627 : BaselineScript::copyYieldAndAwaitEntries(JSScript* script, Vector&lt;uint32_t&gt;&amp; yieldAndAwaitOffsets)</span>
<span class="lineNum">     771 </span>            : {
<span class="lineNum">     772 </span><span class="lineCov">        627 :     uint8_t** entries = yieldEntryList();</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">        644 :     for (size_t i = 0; i &lt; yieldAndAwaitOffsets.length(); i++) {</span>
<span class="lineNum">     775 </span><span class="lineCov">         17 :         uint32_t offset = yieldAndAwaitOffsets[i];</span>
<span class="lineNum">     776 </span><span class="lineCov">         17 :         entries[i] = nativeCodeForPC(script, script-&gt;offsetToPC(offset));</span>
<span class="lineNum">     777 </span>            :     }
<span class="lineNum">     778 </span><span class="lineCov">        627 : }</span>
<a name="779"><span class="lineNum">     779 </span>            : </a>
<span class="lineNum">     780 </span>            : void
<span class="lineNum">     781 </span><span class="lineCov">        627 : BaselineScript::copyICEntries(JSScript* script, const BaselineICEntry* entries, MacroAssembler&amp; masm)</span>
<span class="lineNum">     782 </span>            : {
<span class="lineNum">     783 </span>            :     // Fix up the return offset in the IC entries and copy them in.
<span class="lineNum">     784 </span>            :     // Also write out the IC entry ptrs in any fallback stubs that were added.
<span class="lineNum">     785 </span><span class="lineCov">      23406 :     for (uint32_t i = 0; i &lt; numICEntries(); i++) {</span>
<span class="lineNum">     786 </span><span class="lineCov">      22779 :         BaselineICEntry&amp; realEntry = icEntry(i);</span>
<span class="lineNum">     787 </span><span class="lineCov">      22779 :         realEntry = entries[i];</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineCov">      22779 :         if (!realEntry.hasStub()) {</span>
<span class="lineNum">     790 </span>            :             // VM call without any stubs.
<span class="lineNum">     791 </span><span class="lineCov">       3438 :             continue;</span>
<span class="lineNum">     792 </span>            :         }
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :         // If the attached stub is a fallback stub, then fix it up with
<span class="lineNum">     795 </span>            :         // a pointer to the (now available) realEntry.
<span class="lineNum">     796 </span><span class="lineCov">      19341 :         if (realEntry.firstStub()-&gt;isFallback())</span>
<span class="lineNum">     797 </span><span class="lineCov">      17208 :             realEntry.firstStub()-&gt;toFallbackStub()-&gt;fixupICEntry(&amp;realEntry);</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">      19341 :         if (realEntry.firstStub()-&gt;isTypeMonitor_Fallback()) {</span>
<span class="lineNum">     800 </span><span class="lineCov">       2122 :             ICTypeMonitor_Fallback* stub = realEntry.firstStub()-&gt;toTypeMonitor_Fallback();</span>
<span class="lineNum">     801 </span><span class="lineCov">       2122 :             stub-&gt;fixupICEntry(&amp;realEntry);</span>
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">      19341 :         if (realEntry.firstStub()-&gt;isTableSwitch()) {</span>
<span class="lineNum">     805 </span><span class="lineCov">         11 :             ICTableSwitch* stub = realEntry.firstStub()-&gt;toTableSwitch();</span>
<span class="lineNum">     806 </span><span class="lineCov">         11 :             stub-&gt;fixupJumpTable(script, this);</span>
<span class="lineNum">     807 </span>            :         }
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span><span class="lineCov">        627 : }</span>
<a name="810"><span class="lineNum">     810 </span>            : </a>
<span class="lineNum">     811 </span>            : void
<span class="lineNum">     812 </span><span class="lineCov">        627 : BaselineScript::adoptFallbackStubs(FallbackICStubSpace* stubSpace)</span>
<span class="lineNum">     813 </span>            : {
<span class="lineNum">     814 </span><span class="lineCov">        627 :     fallbackStubSpace_.adoptFrom(stubSpace);</span>
<span class="lineNum">     815 </span><span class="lineCov">        627 : }</span>
<a name="816"><span class="lineNum">     816 </span>            : </a>
<span class="lineNum">     817 </span>            : void
<span class="lineNum">     818 </span><span class="lineCov">        627 : BaselineScript::copyPCMappingEntries(const CompactBufferWriter&amp; entries)</span>
<span class="lineNum">     819 </span>            : {
<span class="lineNum">     820 </span><span class="lineCov">        627 :     MOZ_ASSERT(entries.length() &gt; 0);</span>
<span class="lineNum">     821 </span><span class="lineCov">        627 :     MOZ_ASSERT(entries.length() == pcMappingSize_);</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">        627 :     memcpy(pcMappingData(), entries.buffer(), entries.length());</span>
<span class="lineNum">     824 </span><span class="lineCov">        627 : }</span>
<a name="825"><span class="lineNum">     825 </span>            : </a>
<span class="lineNum">     826 </span>            : void
<span class="lineNum">     827 </span><span class="lineCov">        627 : BaselineScript::copyPCMappingIndexEntries(const PCMappingIndexEntry* entries)</span>
<span class="lineNum">     828 </span>            : {
<span class="lineNum">     829 </span><span class="lineCov">       1759 :     for (uint32_t i = 0; i &lt; numPCMappingIndexEntries(); i++)</span>
<span class="lineNum">     830 </span><span class="lineCov">       1132 :         pcMappingIndexEntry(i) = entries[i];</span>
<span class="lineNum">     831 </span><span class="lineCov">        627 : }</span>
<a name="832"><span class="lineNum">     832 </span>            : </a>
<span class="lineNum">     833 </span>            : uint8_t*
<span class="lineNum">     834 </span><span class="lineCov">       2135 : BaselineScript::nativeCodeForPC(JSScript* script, jsbytecode* pc, PCMappingSlotInfo* slotInfo)</span>
<span class="lineNum">     835 </span>            : {
<span class="lineNum">     836 </span><span class="lineCov">       2135 :     MOZ_ASSERT_IF(script-&gt;hasBaselineScript(), script-&gt;baselineScript() == this);</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">       2135 :     uint32_t pcOffset = script-&gt;pcToOffset(pc);</span>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :     // Look for the first PCMappingIndexEntry with pc &gt; the pc we are
<span class="lineNum">     841 </span>            :     // interested in.
<span class="lineNum">     842 </span><span class="lineCov">       2135 :     uint32_t i = 1;</span>
<span class="lineNum">     843 </span><span class="lineCov">       6571 :     for (; i &lt; numPCMappingIndexEntries(); i++) {</span>
<span class="lineNum">     844 </span><span class="lineCov">       2345 :         if (pcMappingIndexEntry(i).pcOffset &gt; pcOffset)</span>
<span class="lineNum">     845 </span><span class="lineCov">        127 :             break;</span>
<span class="lineNum">     846 </span>            :     }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :     // The previous entry contains the current pc.
<span class="lineNum">     849 </span><span class="lineCov">       2135 :     MOZ_ASSERT(i &gt; 0);</span>
<span class="lineNum">     850 </span><span class="lineCov">       2135 :     i--;</span>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineCov">       2135 :     PCMappingIndexEntry&amp; entry = pcMappingIndexEntry(i);</span>
<span class="lineNum">     853 </span><span class="lineCov">       2135 :     MOZ_ASSERT(pcOffset &gt;= entry.pcOffset);</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineCov">       2135 :     CompactBufferReader reader(pcMappingReader(i));</span>
<span class="lineNum">     856 </span><span class="lineCov">       2135 :     jsbytecode* curPC = script-&gt;offsetToPC(entry.pcOffset);</span>
<span class="lineNum">     857 </span><span class="lineCov">       2135 :     uint32_t nativeOffset = entry.nativeOffset;</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineCov">       2135 :     MOZ_ASSERT(script-&gt;containsPC(curPC));</span>
<span class="lineNum">     860 </span><span class="lineCov">       2135 :     MOZ_ASSERT(curPC &lt;= pc);</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">      18263 :     while (reader.more()) {</span>
<span class="lineNum">     863 </span>            :         // If the high bit is set, the native offset relative to the
<span class="lineNum">     864 </span>            :         // previous pc != 0 and comes next.
<span class="lineNum">     865 </span><span class="lineCov">      10199 :         uint8_t b = reader.readByte();</span>
<span class="lineNum">     866 </span><span class="lineCov">      10199 :         if (b &amp; 0x80)</span>
<span class="lineNum">     867 </span><span class="lineCov">       6089 :             nativeOffset += reader.readUnsigned();</span>
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span><span class="lineCov">      10199 :         if (curPC == pc) {</span>
<span class="lineNum">     870 </span><span class="lineCov">       2135 :             if (slotInfo)</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                 *slotInfo = PCMappingSlotInfo(b &amp; ~0x80);</span>
<span class="lineNum">     872 </span><span class="lineCov">       4270 :             return method_-&gt;raw() + nativeOffset;</span>
<span class="lineNum">     873 </span>            :         }
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineCov">       8064 :         curPC += GetBytecodeLength(curPC);</span>
<span class="lineNum">     876 </span>            :     }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;No native code for this pc&quot;);</span>
<span class="lineNum">     879 </span>            : }
<a name="880"><span class="lineNum">     880 </span>            : </a>
<span class="lineNum">     881 </span>            : jsbytecode*
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : BaselineScript::approximatePcForNativeAddress(JSScript* script, uint8_t* nativeAddress)</span>
<span class="lineNum">     883 </span>            : {
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(script-&gt;baselineScript() == this);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(nativeAddress &gt;= method_-&gt;raw());</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(nativeAddress &lt; method_-&gt;raw() + method_-&gt;instructionsSize());</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     uint32_t nativeOffset = nativeAddress - method_-&gt;raw();</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(nativeOffset &lt; method_-&gt;instructionsSize());</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :     // Look for the first PCMappingIndexEntry with native offset &gt; the native offset we are
<span class="lineNum">     892 </span>            :     // interested in.
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     uint32_t i = 1;</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     for (; i &lt; numPCMappingIndexEntries(); i++) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         if (pcMappingIndexEntry(i).nativeOffset &gt; nativeOffset)</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     897 </span>            :     }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :     // Go back an entry to search forward from.
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(i &gt; 0);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     i--;</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     PCMappingIndexEntry&amp; entry = pcMappingIndexEntry(i);</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     CompactBufferReader reader(pcMappingReader(i));</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     jsbytecode* curPC = script-&gt;offsetToPC(entry.pcOffset);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     uint32_t curNativeOffset = entry.nativeOffset;</span>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(script-&gt;containsPC(curPC));</span>
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            :     // The native code address can occur before the start of ops.
<span class="lineNum">     912 </span>            :     // Associate those with bytecode offset 0.
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     if (curNativeOffset &gt; nativeOffset)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :         return script-&gt;code();</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     jsbytecode* lastPC = curPC;</span>
<span class="lineNum">     917 </span>            :     while (true) {
<span class="lineNum">     918 </span>            :         // If the high bit is set, the native offset relative to the
<span class="lineNum">     919 </span>            :         // previous pc != 0 and comes next.
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         uint8_t b = reader.readByte();</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         if (b &amp; 0x80)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :             curNativeOffset += reader.readUnsigned();</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :         // Return the last PC that matched nativeOffset. Some bytecode
<span class="lineNum">     925 </span>            :         // generate no native code (e.g., constant-pushing bytecode like
<span class="lineNum">     926 </span>            :         // JSOP_INT8), and so their entries share the same nativeOffset as the
<span class="lineNum">     927 </span>            :         // next op that does generate code.
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         if (curNativeOffset &gt; nativeOffset)</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :             return lastPC;</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :         // The native address may lie in-between the last delta-entry in
<span class="lineNum">     932 </span>            :         // a pcMappingIndexEntry, and the next pcMappingIndexEntry.
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         if (!reader.more())</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :             return curPC;</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         lastPC = curPC;</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         curPC += GetBytecodeLength(curPC);</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     939 </span>            : }
<a name="940"><span class="lineNum">     940 </span>            : </a>
<span class="lineNum">     941 </span>            : void
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : BaselineScript::toggleDebugTraps(JSScript* script, jsbytecode* pc)</span>
<span class="lineNum">     943 </span>            : {
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(script-&gt;baselineScript() == this);</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            :     // Only scripts compiled for debug mode have toggled calls.
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     if (!hasDebugInstrumentation())</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     SrcNoteLineScanner scanner(script-&gt;notes(), script-&gt;lineno());</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     AutoWritableJitCode awjc(method());</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     for (uint32_t i = 0; i &lt; numPCMappingIndexEntries(); i++) {</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         PCMappingIndexEntry&amp; entry = pcMappingIndexEntry(i);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         CompactBufferReader reader(pcMappingReader(i));</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         jsbytecode* curPC = script-&gt;offsetToPC(entry.pcOffset);</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :         uint32_t nativeOffset = entry.nativeOffset;</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :         MOZ_ASSERT(script-&gt;containsPC(curPC));</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :         while (reader.more()) {</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :             uint8_t b = reader.readByte();</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :             if (b &amp; 0x80)</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                 nativeOffset += reader.readUnsigned();</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :             scanner.advanceTo(script-&gt;pcToOffset(curPC));</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :             if (!pc || pc == curPC) {</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :                 bool enabled = (script-&gt;stepModeEnabled() &amp;&amp; scanner.isLineHeader()) ||</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :                     script-&gt;hasBreakpointsAt(curPC);</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :                 // Patch the trap.
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :                 CodeLocationLabel label(method(), CodeOffset(nativeOffset));</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                 Assembler::ToggleCall(label, enabled);</span>
<span class="lineNum">     977 </span>            :             }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :             curPC += GetBytecodeLength(curPC);</span>
<span class="lineNum">     980 </span>            :         }
<span class="lineNum">     981 </span>            :     }
<span class="lineNum">     982 </span>            : }
<span class="lineNum">     983 </span>            : 
<a name="984"><span class="lineNum">     984 </span>            : #ifdef JS_TRACE_LOGGING</a>
<span class="lineNum">     985 </span>            : void
<span class="lineNum">     986 </span><span class="lineCov">        627 : BaselineScript::initTraceLogger(JSRuntime* runtime, JSScript* script,</span>
<span class="lineNum">     987 </span>            :                                 const Vector&lt;CodeOffset&gt;&amp; offsets)
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span>            : #ifdef DEBUG
<span class="lineNum">     990 </span><span class="lineCov">        627 :     traceLoggerScriptsEnabled_ = TraceLogTextIdEnabled(TraceLogger_Scripts);</span>
<span class="lineNum">     991 </span><span class="lineCov">        627 :     traceLoggerEngineEnabled_ = TraceLogTextIdEnabled(TraceLogger_Engine);</span>
<span class="lineNum">     992 </span>            : #endif
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineCov">        627 :     MOZ_ASSERT(offsets.length() == numTraceLoggerToggleOffsets_);</span>
<span class="lineNum">     995 </span><span class="lineCov">       1885 :     for (size_t i = 0; i &lt; offsets.length(); i++)</span>
<span class="lineNum">     996 </span><span class="lineCov">       1258 :         traceLoggerToggleOffsets()[i] = offsets[i].offset();</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineCov">        627 :     if (TraceLogTextIdEnabled(TraceLogger_Engine) || TraceLogTextIdEnabled(TraceLogger_Scripts)) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         traceLoggerScriptEvent_ = TraceLoggerEvent(TraceLogger_Scripts, script);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; numTraceLoggerToggleOffsets_; i++) {</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :             CodeLocationLabel label(method_, CodeOffset(traceLoggerToggleOffsets()[i]));</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :             Assembler::ToggleToCmp(label);</span>
<span class="lineNum">    1003 </span>            :         }
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span><span class="lineCov">        627 : }</span>
<a name="1006"><span class="lineNum">    1006 </span>            : </a>
<span class="lineNum">    1007 </span>            : void
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 : BaselineScript::toggleTraceLoggerScripts(JSRuntime* runtime, JSScript* script, bool enable)</span>
<span class="lineNum">    1009 </span>            : {
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     DebugOnly&lt;bool&gt; engineEnabled = TraceLogTextIdEnabled(TraceLogger_Engine);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(enable == !traceLoggerScriptsEnabled_);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(engineEnabled == traceLoggerEngineEnabled_);</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     // Patch the logging script textId to be correct.
<span class="lineNum">    1015 </span>            :     // When logging log the specific textId else the global Scripts textId.
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     if (enable &amp;&amp; !traceLoggerScriptEvent_.hasTextId())</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         traceLoggerScriptEvent_ = TraceLoggerEvent(TraceLogger_Scripts, script);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :     AutoWritableJitCode awjc(method());</span>
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            :     // Enable/Disable the traceLogger.
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numTraceLoggerToggleOffsets_; i++) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         CodeLocationLabel label(method_, CodeOffset(traceLoggerToggleOffsets()[i]));</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         if (enable)</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :             Assembler::ToggleToCmp(label);</span>
<span class="lineNum">    1026 </span>            :         else
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :             Assembler::ToggleToJmp(label);</span>
<span class="lineNum">    1028 </span>            :     }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : #if DEBUG
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     traceLoggerScriptsEnabled_ = enable;</span>
<span class="lineNum">    1032 </span>            : #endif
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 : }</span>
<a name="1034"><span class="lineNum">    1034 </span>            : </a>
<span class="lineNum">    1035 </span>            : void
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 : BaselineScript::toggleTraceLoggerEngine(bool enable)</span>
<span class="lineNum">    1037 </span>            : {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :     DebugOnly&lt;bool&gt; scriptsEnabled = TraceLogTextIdEnabled(TraceLogger_Scripts);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(enable == !traceLoggerEngineEnabled_);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(scriptsEnabled == traceLoggerScriptsEnabled_);</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     AutoWritableJitCode awjc(method());</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :     // Enable/Disable the traceLogger prologue and epilogue.
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numTraceLoggerToggleOffsets_; i++) {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :         CodeLocationLabel label(method_, CodeOffset(traceLoggerToggleOffsets()[i]));</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :         if (enable)</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :             Assembler::ToggleToCmp(label);</span>
<span class="lineNum">    1049 </span>            :         else
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :             Assembler::ToggleToJmp(label);</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            : #if DEBUG
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :     traceLoggerEngineEnabled_ = enable;</span>
<span class="lineNum">    1055 </span>            : #endif
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1057 </span>            : #endif
<a name="1058"><span class="lineNum">    1058 </span>            : </a>
<span class="lineNum">    1059 </span>            : void
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 : BaselineScript::toggleProfilerInstrumentation(bool enable)</span>
<span class="lineNum">    1061 </span>            : {
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :     if (enable == isProfilerInstrumentationOn())</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     JitSpew(JitSpew_BaselineIC, &quot;  toggling profiling %s for BaselineScript %p&quot;,</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :             enable ? &quot;on&quot; : &quot;off&quot;, this);</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :     // Toggle the jump
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :     CodeLocationLabel enterToggleLocation(method_, CodeOffset(profilerEnterToggleOffset_));</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     CodeLocationLabel exitToggleLocation(method_, CodeOffset(profilerExitToggleOffset_));</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :     if (enable) {</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         Assembler::ToggleToCmp(enterToggleLocation);</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :         Assembler::ToggleToCmp(exitToggleLocation);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         flags_ |= uint32_t(PROFILER_INSTRUMENTATION_ON);</span>
<span class="lineNum">    1075 </span>            :     } else {
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         Assembler::ToggleToJmp(enterToggleLocation);</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         Assembler::ToggleToJmp(exitToggleLocation);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         flags_ &amp;= ~uint32_t(PROFILER_INSTRUMENTATION_ON);</span>
<span class="lineNum">    1079 </span>            :     }
<span class="lineNum">    1080 </span>            : }
<a name="1081"><span class="lineNum">    1081 </span>            : </a>
<span class="lineNum">    1082 </span>            : void
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 : BaselineScript::purgeOptimizedStubs(Zone* zone)</span>
<span class="lineNum">    1084 </span>            : {
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     JitSpew(JitSpew_BaselineIC, &quot;Purging optimized stubs&quot;);</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numICEntries(); i++) {</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         BaselineICEntry&amp; entry = icEntry(i);</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         if (!entry.hasStub())</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         ICStub* lastStub = entry.firstStub();</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         while (lastStub-&gt;next())</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :             lastStub = lastStub-&gt;next();</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :         if (lastStub-&gt;isFallback()) {</span>
<span class="lineNum">    1097 </span>            :             // Unlink all stubs allocated in the optimized space.
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :             ICStub* stub = entry.firstStub();</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :             ICStub* prev = nullptr;</span>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             while (stub-&gt;next()) {</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :                 if (!stub-&gt;allocatedInFallbackSpace()) {</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                     lastStub-&gt;toFallbackStub()-&gt;unlinkStub(zone, prev, stub);</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                     stub = stub-&gt;next();</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1106 </span>            :                 }
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                 prev = stub;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :                 stub = stub-&gt;next();</span>
<span class="lineNum">    1110 </span>            :             }
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :             if (lastStub-&gt;isMonitoredFallback()) {</span>
<span class="lineNum">    1113 </span>            :                 // Monitor stubs can't make calls, so are always in the
<span class="lineNum">    1114 </span>            :                 // optimized stub space.
<span class="lineNum">    1115 </span>            :                 ICTypeMonitor_Fallback* lastMonStub =
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :                     lastStub-&gt;toMonitoredFallbackStub()-&gt;fallbackMonitorStub();</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :                 lastMonStub-&gt;resetMonitorStubChain(zone);</span>
<span class="lineNum">    1118 </span>            :             }
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :         } else if (lastStub-&gt;isTypeMonitor_Fallback()) {</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :             lastStub-&gt;toTypeMonitor_Fallback()-&gt;resetMonitorStubChain(zone);</span>
<span class="lineNum">    1121 </span>            :         } else {
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(lastStub-&gt;isTableSwitch());</span>
<span class="lineNum">    1123 </span>            :         }
<span class="lineNum">    1124 </span>            :     }
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : #ifdef DEBUG
<span class="lineNum">    1127 </span>            :     // All remaining stubs must be allocated in the fallback space.
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :     for (size_t i = 0; i &lt; numICEntries(); i++) {</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :         BaselineICEntry&amp; entry = icEntry(i);</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         if (!entry.hasStub())</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         ICStub* stub = entry.firstStub();</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         while (stub-&gt;next()) {</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(stub-&gt;allocatedInFallbackSpace());</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :             stub = stub-&gt;next();</span>
<span class="lineNum">    1137 </span>            :         }
<span class="lineNum">    1138 </span>            :     }
<span class="lineNum">    1139 </span>            : #endif
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 : }</span>
<a name="1141"><span class="lineNum">    1141 </span>            : </a>
<span class="lineNum">    1142 </span>            : void
<span class="lineNum">    1143 </span><span class="lineCov">      20666 : jit::FinishDiscardBaselineScript(FreeOp* fop, JSScript* script)</span>
<span class="lineNum">    1144 </span>            : {
<span class="lineNum">    1145 </span><span class="lineCov">      20666 :     if (!script-&gt;hasBaselineScript())</span>
<span class="lineNum">    1146 </span><span class="lineCov">      20120 :         return;</span>
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">        546 :     if (script-&gt;baselineScript()-&gt;active()) {</span>
<span class="lineNum">    1149 </span>            :         // Script is live on the stack. Keep the BaselineScript, but destroy
<span class="lineNum">    1150 </span>            :         // stubs allocated in the optimized stub space.
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :         script-&gt;baselineScript()-&gt;purgeOptimizedStubs(script-&gt;zone());</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :         // Reset |active| flag so that we don't need a separate script
<span class="lineNum">    1154 </span>            :         // iteration to unmark them.
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :         script-&gt;baselineScript()-&gt;resetActive();</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            :         // The baseline caches have been wiped out, so the script will need to
<span class="lineNum">    1158 </span>            :         // warm back up before it can be inlined during Ion compilation.
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         script-&gt;baselineScript()-&gt;clearIonCompiledOrInlined();</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1161 </span>            :     }
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineCov">        546 :     BaselineScript* baseline = script-&gt;baselineScript();</span>
<span class="lineNum">    1164 </span><span class="lineCov">        546 :     script-&gt;setBaselineScript(nullptr, nullptr);</span>
<span class="lineNum">    1165 </span><span class="lineCov">        546 :     BaselineScript::Destroy(fop, baseline);</span>
<span class="lineNum">    1166 </span>            : }
<a name="1167"><span class="lineNum">    1167 </span>            : </a>
<span class="lineNum">    1168 </span>            : void
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 : jit::AddSizeOfBaselineData(JSScript* script, mozilla::MallocSizeOf mallocSizeOf, size_t* data,</span>
<span class="lineNum">    1170 </span>            :                            size_t* fallbackStubs)
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     if (script-&gt;hasBaselineScript())</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         script-&gt;baselineScript()-&gt;addSizeOfIncludingThis(mallocSizeOf, data, fallbackStubs);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 : }</span>
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<span class="lineNum">    1176 </span>            : void
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 : jit::ToggleBaselineProfiling(JSRuntime* runtime, bool enable)</span>
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :     JitRuntime* jrt = runtime-&gt;jitRuntime();</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :     if (!jrt)</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :     for (ZonesIter zone(runtime, SkipAtoms); !zone.done(); zone.next()) {</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :         for (auto script = zone-&gt;cellIter&lt;JSScript&gt;(); !script.done(); script.next()) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :             if (!script-&gt;hasBaselineScript())</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :             AutoWritableJitCode awjc(script-&gt;baselineScript()-&gt;method());</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :             script-&gt;baselineScript()-&gt;toggleProfilerInstrumentation(enable);</span>
<span class="lineNum">    1189 </span>            :         }
<span class="lineNum">    1190 </span>            :     }
<span class="lineNum">    1191 </span>            : }
<span class="lineNum">    1192 </span>            : 
<a name="1193"><span class="lineNum">    1193 </span>            : #ifdef JS_TRACE_LOGGING</a>
<span class="lineNum">    1194 </span>            : void
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 : jit::ToggleBaselineTraceLoggerScripts(JSRuntime* runtime, bool enable)</span>
<span class="lineNum">    1196 </span>            : {
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     for (ZonesIter zone(runtime, SkipAtoms); !zone.done(); zone.next()) {</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :         for (auto script = zone-&gt;cellIter&lt;JSScript&gt;(); !script.done(); script.next()) {</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :             if (!script-&gt;hasBaselineScript())</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :             script-&gt;baselineScript()-&gt;toggleTraceLoggerScripts(runtime, script, enable);</span>
<span class="lineNum">    1202 </span>            :         }
<span class="lineNum">    1203 </span>            :     }
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 : }</span>
<a name="1205"><span class="lineNum">    1205 </span>            : </a>
<span class="lineNum">    1206 </span>            : void
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 : jit::ToggleBaselineTraceLoggerEngine(JSRuntime* runtime, bool enable)</span>
<span class="lineNum">    1208 </span>            : {
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     for (ZonesIter zone(runtime, SkipAtoms); !zone.done(); zone.next()) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         for (auto script = zone-&gt;cellIter&lt;JSScript&gt;(); !script.done(); script.next()) {</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :             if (!script-&gt;hasBaselineScript())</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :             script-&gt;baselineScript()-&gt;toggleTraceLoggerEngine(enable);</span>
<span class="lineNum">    1214 </span>            :         }
<span class="lineNum">    1215 </span>            :     }
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1217 </span>            : #endif
<a name="1218"><span class="lineNum">    1218 </span>            : </a>
<span class="lineNum">    1219 </span>            : static void
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 : MarkActiveBaselineScripts(JSContext* cx, const JitActivationIterator&amp; activation)</span>
<span class="lineNum">    1221 </span>            : {
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     for (jit::JitFrameIterator iter(activation); !iter.done(); ++iter) {</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :         switch (iter.type()) {</span>
<span class="lineNum">    1224 </span>            :           case JitFrame_BaselineJS:
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :             iter.script()-&gt;baselineScript()-&gt;setActive();</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1227 </span>            :           case JitFrame_Exit:
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :             if (iter.exitFrame()-&gt;is&lt;LazyLinkExitFrameLayout&gt;()) {</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                 LazyLinkExitFrameLayout* ll = iter.exitFrame()-&gt;as&lt;LazyLinkExitFrameLayout&gt;();</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :                 ScriptFromCalleeToken(ll-&gt;jsFrame()-&gt;calleeToken())-&gt;baselineScript()-&gt;setActive();</span>
<span class="lineNum">    1231 </span>            :             }
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1233 </span>            :           case JitFrame_Bailout:
<span class="lineNum">    1234 </span>            :           case JitFrame_IonJS: {
<span class="lineNum">    1235 </span>            :             // Keep the baseline script around, since bailouts from the ion
<span class="lineNum">    1236 </span>            :             // jitcode might need to re-enter into the baseline jitcode.
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :             iter.script()-&gt;baselineScript()-&gt;setActive();</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :             for (InlineFrameIterator inlineIter(cx, &amp;iter); inlineIter.more(); ++inlineIter)</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :                 inlineIter.script()-&gt;baselineScript()-&gt;setActive();</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1241 </span>            :           }
<span class="lineNum">    1242 </span>            :           default:;
<span class="lineNum">    1243 </span>            :         }
<span class="lineNum">    1244 </span>            :     }
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 : }</span>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<span class="lineNum">    1247 </span>            : void
<span class="lineNum">    1248 </span><span class="lineCov">          4 : jit::MarkActiveBaselineScripts(Zone* zone)</span>
<span class="lineNum">    1249 </span>            : {
<span class="lineNum">    1250 </span><span class="lineCov">          4 :     if (zone-&gt;isAtomsZone())</span>
<span class="lineNum">    1251 </span><span class="lineCov">          1 :         return;</span>
<span class="lineNum">    1252 </span><span class="lineCov">          3 :     JSContext* cx = TlsContext.get();</span>
<span class="lineNum">    1253 </span><span class="lineCov">          3 :     for (JitActivationIterator iter(cx, zone-&gt;group()-&gt;ownerContext()); !iter.done(); ++iter) {</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         if (iter-&gt;compartment()-&gt;zone() == zone)</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :             MarkActiveBaselineScripts(cx, iter);</span>
<span class="lineNum">    1256 </span>            :     }
<span class="lineNum">    1257 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
